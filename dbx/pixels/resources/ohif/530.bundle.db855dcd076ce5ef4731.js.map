{"version":3,"file":"530.bundle.db855dcd076ce5ef4731.js","mappings":"ucAWA,MAAM,WAAEA,GAAeC,EAAAA,MAMvB,SAASC,EAA0BC,GACjC,MAAM,SACJC,EAAQ,WACRC,EAAU,YACVC,EAAW,cACXC,EAAa,gBACbC,EAAe,gBACfC,EAAe,iBACfC,GACEP,GAEGQ,IAAaC,EAAAA,EAAAA,MAEd,kBAAEC,EAAiB,2BAAEC,EAA0B,mBAAEC,GACrDN,EAAgBO,SAEZC,EAAaT,EAAgBS,WAGnC,GAAIX,EAAYY,OAAS,EACvB,MAAM,IAAIC,MAAM,qDAGlB,MAAMC,EAAed,EAAY,IAE1Be,EAAcC,IAAuBC,EAAAA,EAAAA,OACrCC,EAAqBC,IAA0BC,EAAAA,EAAAA,UAAS,IACxDC,EAAkBC,IAAuBF,EAAAA,EAAAA,UAAS,IAClDG,EAA2BC,IAAgCJ,EAAAA,EAAAA,UAAS,OACpEK,EAA8BC,IAAmCN,EAAAA,EAAAA,UAAS,OAC1EO,EAASC,IAAcR,EAAAA,EAAAA,UAAS,OACjC,UAAES,EAAS,iBAAEC,GAAqBf,EAGxC,IAAIgB,EACAC,EAMJ,GAJwC5B,EAAiB6B,uBAAuBC,SAzCxC,wCA6CH,CACnC,MAAMC,EAAgB/B,EAAiBgC,eACrC,iFAGIC,GAAUC,EAAAA,EAAAA,YAAWH,EAAcI,SACzCR,EAAsBM,IAAU,GAChCL,EAA+BK,IAAU,EAC3C,CACKL,IAEHD,EAAsB,KACtBC,EAA+BA,CAACQ,GAAaC,4BAC3ChC,EAAmBiC,oBACnB,MAAM,mBAAEC,IAAuBC,EAAAA,EAAAA,GAC7B,CAAEzC,kBAAiBC,mBAAkBC,aACrCoC,GAEIzC,EAAcO,EAAkBsC,wBAAwBF,EAAmB,IAC7E3C,EAAYY,QACdI,EAAoB8B,2BAA2B,CAC7C,CACEnC,WAAYmB,EACZiB,uBAAwB,CAAC/C,EAAY,GAAGyC,yBAG9C,GASJ,MAAMO,GAAyBC,EAAAA,EAAAA,cAC7B/B,IACE,MAAM,aAAEgC,GAAiBpC,GAEzBqC,EAAAA,EAAAA,IACExB,EACAuB,EAAaE,KAAIC,GAAeA,EAAYC,2BAC5CpC,EACD,GAEH,CAACS,EAAST,EAAqBJ,IAS3ByC,EAAmBC,IACvB5B,EAAW4B,EAAIC,OAAO9B,QAAQ,EAG1B+B,GAAiBT,EAAAA,EAAAA,cACrBU,IACE,MAAM,iBAAEC,EAAgB,sBAAEnB,EAAqB,aAAEoB,GAAiB/C,EAE7D8C,GAAqBnB,IAItBoB,GAAgBA,EAAajD,OAAS,GAGxCkD,QAAQC,KAAK,sEA4QrBC,eACEC,EACA/C,EACAX,GAEA,MAAM,aAAE2C,GAAiBe,EACnBZ,EAAcH,EAAahC,IAE3B,sBAAEuB,GAA0BY,EAE5Ba,EAAuB3D,EAAkB4D,mBAAmB1B,GAE5D2B,EAASF,EAAqBG,OAAO,GACrC5C,EAA+B,CACnC6C,UAAWF,EAAOE,UAClBC,YAAaH,EAAOG,YACpBC,WAAYJ,EAAOI,WACnBC,WAAYL,EAAOK,WACnBC,eAAgBN,EAAOM,eACvBC,UAAWP,EAAOO,UAClBC,kBAAmBR,EAAOQ,kBAC1BC,kBAAmBT,EAAOS,kBAC1BC,aAAcV,EAAOU,aACrBC,sBAAuBX,EAAOW,sBAC9BC,qBAAsBZ,EAAOY,sBAG/B,MAAO,CAAEvD,+BAA8ByC,uBACzC,CArSMe,CACEnE,EACA6C,EACApD,GACA2E,MAAK,EAAGhB,uBAAsBzC,mCAK9B,GAJAN,EAAuBwC,GACvBnC,EAA6B0C,GAC7BxC,EAAgCD,GAG9ByC,EAAqBzB,wBACrBlB,GAA2BkB,sBAC3B,CACA,MAAM,aAAES,GAAiBpC,EAMnBqE,EAAa3E,EAA2B4E,uBAAuBzE,GAI/D0E,EAFWF,EAAWG,cAEEC,QAAQrC,EAAaS,GAAwB6B,UAErD,IAAlBH,GACFF,EAAWM,gBAAgBJ,EAE/B,KACA,GAEJ,CAACtF,EAAYe,EAAcS,EAA2BZ,IAGlDyE,GAAyBnC,EAAAA,EAAAA,cAAY,KACzC,IAAK1B,EACH,OAAO,KAGT,MAAQmE,UAAWC,GAAcvF,EAAiBgC,eAChD,2DAGI,aAAEc,GAAiBpC,EACnBuC,EAAcH,EAAahC,GAEjC,IAAKmC,EACH,OAAO,KAGT,MAAMuC,EAAoBrE,EAA0B8C,OAAOwB,WACzDC,GAASA,EAAMN,UAAYnC,EAAYmC,UAGzC,OACEO,EAAAA,cAACJ,EAASK,EAAA,GACJnG,EAAK,CAGTG,YAAa,CAACuB,GAKdrB,gBAAiB,IACZA,EACH+F,YAAc,cAIdC,aAAc,QAEdC,YAAa,MAEf5C,iBAAkBA,EAClBqC,kBAAmBA,EACnBQ,6BAA6B,IAClB,GAEd,CAAC7E,EAA2BZ,EAAYO,IAErCmF,GAAsBpD,EAAAA,EAAAA,cAC1BqD,IACE,IAAI3C,EAAyBzC,EAEX,UAAdoF,GACF3C,IAEIA,GAA0BtC,IAC5BsC,EAAyB,KAG3BA,IAEIA,EAAyB,IAC3BA,EAAyBtC,EAAmB,IAIhD2B,EAAuBW,GACvBD,EAAeC,EAAuB,GAExC,CAACzC,EAAqBG,EAAkBqC,EAAgBV,KAM1DuD,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAmCjG,EAAkBkG,UACzDlG,EAAkBmG,OAAOC,sBACzB,EAAG5D,6BACD,MAAM6D,EAAiB/E,EAAUgF,IAAI/E,GACjCiB,EAAuBb,SAAS0E,EAAenE,wBACjDzB,EAAoB8F,0BAA0B,CAC5CnG,WAAYmB,EACZiB,uBAAwB,IAE5B,IAIJ,MAAO,KACLyD,EAAiCO,aAAa,CAC/C,GACA,KASHR,EAAAA,EAAAA,YAAU,KACHzF,EAAakG,UAChBlG,EAAamG,OAEf,MAAMC,EAAkBpG,EAAaoC,aAAatC,OAClDU,EAAoB4F,EAAgB,GACnC,CAACpG,KAMJyF,EAAAA,EAAAA,YAAU,KACH5E,GAAYb,EAAakG,UAG9BhE,EAAuB9B,EAAoB,GAC1C,CAACA,EAAqBS,EAASqB,EAAwBlC,IAM1D,IAAIqG,EAAWpF,GAAqBQ,SAAS6E,eAAexG,OAAS,GACrE2F,EAAAA,EAAAA,YAAU,KACRY,EAAWpF,GAAqBQ,SAAS6E,eAAexG,OAAS,CAAC,GACjE,CAACmB,KAMJwE,EAAAA,EAAAA,YAAU,KACR7C,EAAexC,EAAoB,GAClC,CAACnB,EAAYe,IAGhB,IAAIuG,EAAoB,KAExB,IAAK9F,IAA8BE,EACjC,OAAO,KAGL3B,GAAYA,EAASc,SACvByG,EAAoBvH,EAASsD,KAAI,CAACkE,EAAOC,IAErCD,GACAvB,EAAAA,aAAmBuB,EAAO,CACxB3G,aACA6G,IAAKD,OAMb,MAAM,UACJjD,EAAS,YACTC,EAAW,WACXC,EAAU,WACVC,EAAU,eACVC,EAAc,sBACdK,EAAqB,UACrBJ,EAAS,kBACTC,EAAiB,qBACjBI,GAAoB,aACpBF,IACErD,EAGJ,OACEsE,EAAAA,cAAAA,EAAAA,SAAA,KACEA,EAAAA,cAAC0B,EAAAA,GAAiB,CAChBC,cAAelE,IACbA,EAAImE,kBACJnE,EAAIoE,gBAAgB,EAEtBC,cAAexB,EACfyB,mBAAoBA,IAoF5B,UAA6B,aAC3BhH,EAAY,WACZH,EAAU,eACVoH,EAAc,SACdZ,EAAQ,6BACRnF,IAEA,MAAMgG,EAAgBA,KACpBhG,EAA6B,aAAc,CACzCS,sBAAuB3B,EAAa2B,sBACpC9B,cACA,GAGE,EAAEsH,IAAMC,EAAAA,EAAAA,IAAe,UACvBC,EAAUF,EAAE,QAKZG,EAAQL,IAAmBZ,EAAW,EAAIY,GAAkBZ,EAAW,EAAI,EACjF,IAAIkB,EAAiB,KACjBC,EAAa,KAEjB,OAAQF,GACN,KAAK,EACHE,EAAaA,IAAMvC,EAAAA,cAACwC,EAAAA,GAAI,CAACC,KAAK,iBAE9BH,EAAiBA,IACftC,EAAAA,cAAA,WAAK,2CAEHA,EAAAA,cAAA,WAAM,0BAIV,MACF,KAAK,EACHuC,EAAaA,IAAMvC,EAAAA,cAACwC,EAAAA,GAAI,CAACC,KAAK,kBAE9BH,EAAiBA,IACftC,EAAAA,cAAA,WAAK,gDAEHA,EAAAA,cAAA,WAAM,2CAENA,EAAAA,cAAA,WAAM,qBAIV,MACF,KAAK,EACHuC,EAAaA,IACXvC,EAAAA,cAACwC,EAAAA,GAAI,CACHE,UAAU,iBACVD,KAAK,qBAITH,EAAiBA,IAAMtC,EAAAA,cAAA,WAAO,SAAQoC,8BAG1C,MAAMO,EAAaA,IACjB3C,EAAAA,cAAA,OAAK0C,UAAU,wDACb1C,EAAAA,cAAA,OAAK0C,UAAU,+EACb1C,EAAAA,cAACuC,EAAU,MACXvC,EAAAA,cAAA,QAAM0C,UAAU,QAAO,OAEd,IAAVL,GACCrC,EAAAA,cAAA,OACE0C,UAAU,6FAEVE,UAAWX,GAEVG,IAMT,OACEpC,EAAAA,cAAAA,EAAAA,SAAA,KACGsC,GACCtC,EAAAA,cAAC6C,EAAAA,GAAO,CACNC,QAAS9C,EAAAA,cAACsC,EAAc,MACxBS,SAAS,eAET/C,EAAAA,cAAC2C,EAAU,QAGbL,GAAkBtC,EAAAA,cAAC2C,EAAU,MAGrC,CA9KUK,CAAoB,CAClBjI,eACAH,aACAqI,WAAW,EACXjB,eAAgBjH,EAAaiH,eAC7BZ,WACAnF,iCAGJiH,UAAW,CACTC,MAAOjJ,EACPkJ,eAAe,EACfC,UAAW1J,EAAWiF,GACtB0E,cAAevE,GACfwE,kBAAmB1E,GAAqB,GACxC2E,mBAAoB,CAClBC,YAAajF,EAAckF,EAAAA,GAAAA,MAAWC,SAASnF,EAAYoF,YAAc,GACzEC,WAAYpF,GAAc,GAC1BqF,WAAYpF,GAAc,GAC1BqF,IAAKxF,GAAa,GAClByF,UAAWrF,EAAkB,GAAEsF,WAAWtF,GAAgBuF,QAAQ,OAAS,GAC3EC,aAC2BC,IAAzBnF,GAAsC,GAAEA,GAAqBiF,QAAQ,OAAS,GAChFG,QAASrF,GAAyB,OAKxCgB,EAAAA,cAAA,OAAK0C,UAAU,wDACZrD,IACAiC,GAIT,CAEAzH,EAA0ByK,UAAY,CACpCrK,YAAasK,IAAAA,QAAkBA,IAAAA,QAC/B3J,WAAY2J,IAAAA,OAAiBC,WAC7BxK,WAAYuK,IAAAA,OACZxK,SAAUwK,IAAAA,KACVrK,cAAeqK,IAAAA,OACfE,YAAaF,IAAAA,OACbpK,gBAAiBoK,IAAAA,OACjBrK,cAAeqK,IAAAA,OACfnK,gBAAiBmK,IAAAA,WAAqBG,EAAAA,IAAiBF,WACvDnK,iBAAkBkK,IAAAA,WAAqBI,EAAAA,IAAkBH,YAG3D3K,EAA0B+K,aAAe,CACvCH,YAAa,CAAC,GA8HhB,S","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/viewports/OHIFCornerstoneSRViewport.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport OHIF, { utils, ServicesManager, ExtensionManager } from '@ohif/core';\n\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\n\nimport { Icon, Tooltip, useViewportGrid, ViewportActionBar } from '@ohif/ui';\nimport hydrateStructuredReport from '../utils/hydrateStructuredReport';\nimport { useAppConfig } from '@state';\n\nconst { formatDate } = utils;\n\nconst MEASUREMENT_TRACKING_EXTENSION_ID = '@ohif/extension-measurement-tracking';\n\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\n\nfunction OHIFCornerstoneSRViewport(props) {\n  const {\n    children,\n    dataSource,\n    displaySets,\n    viewportLabel,\n    viewportOptions,\n    servicesManager,\n    extensionManager,\n  } = props;\n\n  const [appConfig] = useAppConfig();\n\n  const { displaySetService, cornerstoneViewportService, measurementService } =\n    servicesManager.services;\n\n  const viewportId = viewportOptions.viewportId;\n\n  // SR viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('SR viewport should only have a single display set');\n  }\n\n  const srDisplaySet = displaySets[0];\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const [measurementSelected, setMeasurementSelected] = useState(0);\n  const [measurementCount, setMeasurementCount] = useState(1);\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(null);\n  const [referencedDisplaySetMetadata, setReferencedDisplaySetMetadata] = useState(null);\n  const [element, setElement] = useState(null);\n  const { viewports, activeViewportId } = viewportGrid;\n\n  // Optional hook into tracking extension, if present.\n  let trackedMeasurements;\n  let sendTrackedMeasurementsEvent;\n\n  const hasMeasurementTrackingExtension = extensionManager.registeredExtensionIds.includes(\n    MEASUREMENT_TRACKING_EXTENSION_ID\n  );\n\n  if (hasMeasurementTrackingExtension) {\n    const contextModule = extensionManager.getModuleEntry(\n      '@ohif/extension-measurement-tracking.contextModule.TrackedMeasurementsContext'\n    );\n\n    const tracked = useContext(contextModule.context);\n    trackedMeasurements = tracked?.[0];\n    sendTrackedMeasurementsEvent = tracked?.[1];\n  }\n  if (!sendTrackedMeasurementsEvent) {\n    // if no panels from measurement-tracking extension is used, this code will run\n    trackedMeasurements = null;\n    sendTrackedMeasurementsEvent = (eventName, { displaySetInstanceUID }) => {\n      measurementService.clearMeasurements();\n      const { SeriesInstanceUIDs } = hydrateStructuredReport(\n        { servicesManager, extensionManager, appConfig },\n        displaySetInstanceUID\n      );\n      const displaySets = displaySetService.getDisplaySetsForSeries(SeriesInstanceUIDs[0]);\n      if (displaySets.length) {\n        viewportGridService.setDisplaySetsForViewports([\n          {\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [displaySets[0].displaySetInstanceUID],\n          },\n        ]);\n      }\n    };\n  }\n\n  /**\n   * Store the tracking identifiers per viewport in order to be able to\n   * show the SR measurements on the referenced image on the correct viewport,\n   * when multiple viewports are used.\n   */\n  const setTrackingIdentifiers = useCallback(\n    measurementSelected => {\n      const { measurements } = srDisplaySet;\n\n      setTrackingUniqueIdentifiersForElement(\n        element,\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\n        measurementSelected\n      );\n    },\n    [element, measurementSelected, srDisplaySet]\n  );\n\n  /**\n   * OnElementEnabled callback which is called after the cornerstoneExtension\n   * has enabled the element. Note: we delegate all the image rendering to\n   * cornerstoneExtension, so we don't need to do anything here regarding\n   * the image rendering, element enabling etc.\n   */\n  const onElementEnabled = evt => {\n    setElement(evt.detail.element);\n  };\n\n  const updateViewport = useCallback(\n    newMeasurementSelected => {\n      const { StudyInstanceUID, displaySetInstanceUID, sopClassUids } = srDisplaySet;\n\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\n        return;\n      }\n\n      if (sopClassUids && sopClassUids.length > 1) {\n        // Todo: what happens if there are multiple SOP Classes? Why we are\n        // not throwing an error?\n        console.warn('More than one SOPClassUID in the same series is not yet supported.');\n      }\n\n      _getViewportReferencedDisplaySetData(\n        srDisplaySet,\n        newMeasurementSelected,\n        displaySetService\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\n        setMeasurementSelected(newMeasurementSelected);\n        setActiveImageDisplaySetData(referencedDisplaySet);\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\n\n        if (\n          referencedDisplaySet.displaySetInstanceUID ===\n          activeImageDisplaySetData?.displaySetInstanceUID\n        ) {\n          const { measurements } = srDisplaySet;\n\n          // it means that we have a new referenced display set, and the\n          // imageIdIndex will handle it by updating the viewport, but if they\n          // are the same we just need to use measurementService to jump to the\n          // new measurement\n          const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n          const imageIds = csViewport.getImageIds();\n\n          const imageIdIndex = imageIds.indexOf(measurements[newMeasurementSelected].imageId);\n\n          if (imageIdIndex !== -1) {\n            csViewport.setImageIdIndex(imageIdIndex);\n          }\n        }\n      });\n    },\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportId]\n  );\n\n  const getCornerstoneViewport = useCallback(() => {\n    if (!activeImageDisplaySetData) {\n      return null;\n    }\n\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    const { measurements } = srDisplaySet;\n    const measurement = measurements[measurementSelected];\n\n    if (!measurement) {\n      return null;\n    }\n\n    const initialImageIndex = activeImageDisplaySetData.images.findIndex(\n      image => image.imageId === measurement.imageId\n    );\n\n    return (\n      <Component\n        {...props}\n        // should be passed second since we don't want SR displaySet to\n        // override the activeImageDisplaySetData\n        displaySets={[activeImageDisplaySetData]}\n        // It is possible that there is a hanging protocol applying viewportOptions\n        // for the SR, so inherit the viewport options\n        // TODO: Ensure the viewport options are set correctly with respect to\n        // stack etc, in the incoming viewport options.\n        viewportOptions={{\n          ...viewportOptions,\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\n          // viewportType should not be required, as the stack type should be\n          // required already in order to view SR, but sometimes segmentation\n          // views set the viewport type without fixing the allowed display\n          viewportType: 'stack',\n          // The positionIds for the viewport aren't meaningful for the child display sets\n          positionIds: null,\n        }}\n        onElementEnabled={onElementEnabled}\n        initialImageIndex={initialImageIndex}\n        isJumpToMeasurementDisabled={true}\n      ></Component>\n    );\n  }, [activeImageDisplaySetData, viewportId, measurementSelected]);\n\n  const onMeasurementChange = useCallback(\n    direction => {\n      let newMeasurementSelected = measurementSelected;\n\n      if (direction === 'right') {\n        newMeasurementSelected++;\n\n        if (newMeasurementSelected >= measurementCount) {\n          newMeasurementSelected = 0;\n        }\n      } else {\n        newMeasurementSelected--;\n\n        if (newMeasurementSelected < 0) {\n          newMeasurementSelected = measurementCount - 1;\n        }\n      }\n\n      setTrackingIdentifiers(newMeasurementSelected);\n      updateViewport(newMeasurementSelected);\n    },\n    [measurementSelected, measurementCount, updateViewport, setTrackingIdentifiers]\n  );\n\n  /**\n   Cleanup the SR viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  /**\n   * Loading the measurements from the SR viewport, which goes through the\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\n   * we are changing the state here? isHydrated is always false at this stage, and\n   * if it is hydrated we don't even use the SR viewport.\n   */\n  useEffect(() => {\n    if (!srDisplaySet.isLoaded) {\n      srDisplaySet.load();\n    }\n    const numMeasurements = srDisplaySet.measurements.length;\n    setMeasurementCount(numMeasurements);\n  }, [srDisplaySet]);\n\n  /**\n   * Hook to update the tracking identifiers when the selected measurement changes or\n   * the element changes\n   */\n  useEffect(() => {\n    if (!element || !srDisplaySet.isLoaded) {\n      return;\n    }\n    setTrackingIdentifiers(measurementSelected);\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\n\n  /**\n   * Todo: what is this, not sure what it does regarding the react aspect,\n   * it is updating a local variable? which is not state.\n   */\n  let isLocked = trackedMeasurements?.context?.trackedSeries?.length > 0;\n  useEffect(() => {\n    isLocked = trackedMeasurements?.context?.trackedSeries?.length > 0;\n  }, [trackedMeasurements]);\n\n  /**\n   * Data fetching for the SR displaySet, which updates the measurements and\n   * also gets the referenced image displaySet that SR is based on.\n   */\n  useEffect(() => {\n    updateViewport(measurementSelected);\n  }, [dataSource, srDisplaySet]);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  const {\n    PatientID,\n    PatientName,\n    PatientSex,\n    PatientAge,\n    SliceThickness,\n    ManufacturerModelName,\n    StudyDate,\n    SeriesDescription,\n    SpacingBetweenSlices,\n    SeriesNumber,\n  } = referencedDisplaySetMetadata;\n\n  // TODO -> disabled double click for now: onDoubleClick={_onDoubleClick}\n  return (\n    <>\n      <ViewportActionBar\n        onDoubleClick={evt => {\n          evt.stopPropagation();\n          evt.preventDefault();\n        }}\n        onArrowsClick={onMeasurementChange}\n        getStatusComponent={() =>\n          _getStatusComponent({\n            srDisplaySet,\n            viewportId,\n            isTracked: false,\n            isRehydratable: srDisplaySet.isRehydratable,\n            isLocked,\n            sendTrackedMeasurementsEvent,\n          })\n        }\n        studyData={{\n          label: viewportLabel,\n          useAltStyling: true,\n          studyDate: formatDate(StudyDate),\n          currentSeries: SeriesNumber,\n          seriesDescription: SeriesDescription || '',\n          patientInformation: {\n            patientName: PatientName ? OHIF.utils.formatPN(PatientName.Alphabetic) : '',\n            patientSex: PatientSex || '',\n            patientAge: PatientAge || '',\n            MRN: PatientID || '',\n            thickness: SliceThickness ? `${parseFloat(SliceThickness).toFixed(2)}mm` : '',\n            spacing:\n              SpacingBetweenSlices !== undefined ? `${SpacingBetweenSlices.toFixed(2)}mm` : '',\n            scanner: ManufacturerModelName || '',\n          },\n        }}\n      />\n\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSRViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  customProps: PropTypes.object,\n  viewportOptions: PropTypes.object,\n  viewportLabel: PropTypes.string,\n  servicesManager: PropTypes.instanceOf(ServicesManager).isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nOHIFCornerstoneSRViewport.defaultProps = {\n  customProps: {},\n};\n\nasync function _getViewportReferencedDisplaySetData(\n  displaySet,\n  measurementSelected,\n  displaySetService\n) {\n  const { measurements } = displaySet;\n  const measurement = measurements[measurementSelected];\n\n  const { displaySetInstanceUID } = measurement;\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\n}\n\nfunction _getStatusComponent({\n  srDisplaySet,\n  viewportId,\n  isRehydratable,\n  isLocked,\n  sendTrackedMeasurementsEvent,\n}) {\n  const handleMouseUp = () => {\n    sendTrackedMeasurementsEvent('HYDRATE_SR', {\n      displaySetInstanceUID: srDisplaySet.displaySetInstanceUID,\n      viewportId,\n    });\n  };\n\n  const { t } = useTranslation('Common');\n  const loadStr = t('LOAD');\n\n  // 1 - Incompatible\n  // 2 - Locked\n  // 3 - Rehydratable / Open\n  const state = isRehydratable && !isLocked ? 3 : isRehydratable && isLocked ? 2 : 1;\n  let ToolTipMessage = null;\n  let StatusIcon = null;\n\n  switch (state) {\n    case 1:\n      StatusIcon = () => <Icon name=\"status-alert\" />;\n\n      ToolTipMessage = () => (\n        <div>\n          This structured report is not compatible\n          <br />\n          with this application.\n        </div>\n      );\n      break;\n    case 2:\n      StatusIcon = () => <Icon name=\"status-locked\" />;\n\n      ToolTipMessage = () => (\n        <div>\n          This structured report is currently read-only\n          <br />\n          because you are tracking measurements in\n          <br />\n          another viewport.\n        </div>\n      );\n      break;\n    case 3:\n      StatusIcon = () => (\n        <Icon\n          className=\"text-aqua-pale\"\n          name=\"status-untracked\"\n        />\n      );\n\n      ToolTipMessage = () => <div>{`Click ${loadStr} to restore measurements.`}</div>;\n  }\n\n  const StatusArea = () => (\n    <div className=\"flex h-6 cursor-default text-sm leading-6 text-white\">\n      <div className=\"bg-customgray-100 flex min-w-[45px] items-center rounded-l-xl rounded-r p-1\">\n        <StatusIcon />\n        <span className=\"ml-1\">SR</span>\n      </div>\n      {state === 3 && (\n        <div\n          className=\"bg-primary-main hover:bg-primary-light ml-1 cursor-pointer rounded px-1.5 hover:text-black\"\n          // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\n          onMouseUp={handleMouseUp}\n        >\n          {loadStr}\n        </div>\n      )}\n    </div>\n  );\n\n  return (\n    <>\n      {ToolTipMessage && (\n        <Tooltip\n          content={<ToolTipMessage />}\n          position=\"bottom-left\"\n        >\n          <StatusArea />\n        </Tooltip>\n      )}\n      {!ToolTipMessage && <StatusArea />}\n    </>\n  );\n}\n\nexport default OHIFCornerstoneSRViewport;\n"],"names":["formatDate","utils","OHIFCornerstoneSRViewport","props","children","dataSource","displaySets","viewportLabel","viewportOptions","servicesManager","extensionManager","appConfig","useAppConfig","displaySetService","cornerstoneViewportService","measurementService","services","viewportId","length","Error","srDisplaySet","viewportGrid","viewportGridService","useViewportGrid","measurementSelected","setMeasurementSelected","useState","measurementCount","setMeasurementCount","activeImageDisplaySetData","setActiveImageDisplaySetData","referencedDisplaySetMetadata","setReferencedDisplaySetMetadata","element","setElement","viewports","activeViewportId","trackedMeasurements","sendTrackedMeasurementsEvent","registeredExtensionIds","includes","contextModule","getModuleEntry","tracked","useContext","context","eventName","displaySetInstanceUID","clearMeasurements","SeriesInstanceUIDs","hydrateStructuredReport","getDisplaySetsForSeries","setDisplaySetsForViewports","displaySetInstanceUIDs","setTrackingIdentifiers","useCallback","measurements","setTrackingUniqueIdentifiersForElement","map","measurement","TrackingUniqueIdentifier","onElementEnabled","evt","detail","updateViewport","newMeasurementSelected","StudyInstanceUID","sopClassUids","console","warn","async","displaySet","referencedDisplaySet","getDisplaySetByUID","image0","images","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","StudyDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","ManufacturerModelName","SpacingBetweenSlices","_getViewportReferencedDisplaySetData","then","csViewport","getCornerstoneViewport","imageIdIndex","getImageIds","indexOf","imageId","setImageIdIndex","component","Component","initialImageIndex","findIndex","image","React","_extends","toolGroupId","viewportType","positionIds","isJumpToMeasurementDisabled","onMeasurementChange","direction","useEffect","onDisplaySetsRemovedSubscription","subscribe","EVENTS","DISPLAY_SETS_REMOVED","activeViewport","get","setDisplaySetsForViewport","unsubscribe","isLoaded","load","numMeasurements","isLocked","trackedSeries","childrenWithProps","child","index","key","ViewportActionBar","onDoubleClick","stopPropagation","preventDefault","onArrowsClick","getStatusComponent","isRehydratable","handleMouseUp","t","useTranslation","loadStr","state","ToolTipMessage","StatusIcon","Icon","name","className","StatusArea","onMouseUp","Tooltip","content","position","_getStatusComponent","isTracked","studyData","label","useAltStyling","studyDate","currentSeries","seriesDescription","patientInformation","patientName","OHIF","formatPN","Alphabetic","patientSex","patientAge","MRN","thickness","parseFloat","toFixed","spacing","undefined","scanner","propTypes","PropTypes","isRequired","customProps","ServicesManager","ExtensionManager","defaultProps"],"sourceRoot":""}