(self["webpackChunk"] = self["webpackChunk"] || []).push([[8112],{

/***/ 48405:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ calculateSUVScalingFactors)
/* harmony export */ });
/**
 * Javascript object that handles dates and compute the time.
 *
 * @export
 * @class FullDateInterface
 */
class FullDateInterface {
  /**
   * Creates an instance of FullDateInterface.
   * @param {string} date formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ
   * @memberof FullDateInterface
   */
  constructor(date) {
    this.fullDate = date;
  }
  /**
   * returns time since 1 january 1970
   *
   * @returns {number} time in sec
   * @memberof FullDateInterface
   */


  getTimeInSec() {
    // yyyy-mm-ddTHH:MM:SS.FFFFFFZ
    const dateString = this.fullDate.substring(0, 10);
    const timeString = this.fullDate.substring(11, 28); // yyyy-mm-dd

    const yyyy = parseInt(dateString.substring(0, 4), 10);
    const mm = dateString.length >= 7 ? parseInt(dateString.substring(5, 7), 10) : undefined;
    const dd = dateString.length >= 10 ? parseInt(dateString.substring(8, 10), 10) : undefined;

    if (isNaN(yyyy) || mm !== undefined && isNaN(mm) || dd !== undefined && isNaN(dd) || yyyy > 3000 || mm && (mm < 1 || mm > 12) || dd && (dd < 1 || dd > 31)) {
      throw new Error(`invalid date '${dateString}'`);
    }

    const dateJS = new Date(`${dateString}T00:00:00.000000Z`); // HHMMSS.FFFFFF

    const HH = parseInt(timeString.substring(0, 2), 10);
    const MM = timeString.length >= 5 ? parseInt(timeString.substring(3, 5), 10) : undefined;
    const SS = timeString.length >= 8 ? parseInt(timeString.substring(6, 8), 10) : undefined;
    const fractionalStr = timeString.substring(9, 15);
    const FFFFFF = fractionalStr ? parseInt(fractionalStr, 10) * Math.pow(10, -fractionalStr.length) : undefined;

    if (isNaN(HH) || MM !== undefined && isNaN(MM) || SS !== undefined && isNaN(SS) || FFFFFF !== undefined && isNaN(FFFFFF) || HH < 0 || HH > 23 || MM && (MM < 0 || MM > 59) || SS && (SS < 0 || SS > 59) || FFFFFF && (FFFFFF < 0 || FFFFFF > 999999)) {
      throw new Error(`invalid time '${timeString}'`);
    }

    let timeInSec = dateJS.getTime() / 1000;
    timeInSec += HH * 3600;

    if (MM !== undefined) {
      timeInSec += MM * 60;
    }

    if (SS !== undefined) {
      timeInSec += SS;
    }

    if (FFFFFF !== undefined) {
      timeInSec += FFFFFF;
    }

    return timeInSec;
  }
  /**
   * returns time since 1 january 1970
   *
   * @returns {number} time in microsec
   * @memberof FullDateInterface
   */


  getTimeInMicroSec() {
    const timeInMicroSec = this.getTimeInSec() * 1e6;
    return timeInMicroSec;
  }

}
/**
 * Combines two javascript objects containing the date and time information
 *
 * @export
 * @param {DateInterface} date
 * @param {TimeInterface} time
 * @returns {FullDateInterface}
 */

function combineDateTime(date, time) {
  const hours = `${time.hours || '00'}`.padStart(2, '0');
  const minutes = `${time.minutes || '00'}`.padStart(2, '0');
  const seconds = `${time.seconds || '00'}`.padStart(2, '0');
  const month = `${date.month}`.padStart(2, '0');
  const day = `${date.day}`.padStart(2, '0');
  const fractionalSeconds = `${time.fractionalSeconds || '000000'}`.padEnd(6, '0');
  const dateString = `${date.year}-${month}-${day}`;
  const timeString = `T${hours}:${minutes}:${seconds}.${fractionalSeconds}Z`;
  const fullDateString = `${dateString}${timeString}`;
  return new FullDateInterface(fullDateString);
}

/**
 * Check the number of days for a picked month and year
 * algorithm based on http://stackoverflow.com/questions/1433030/validate-number-of-days-in-a-given-month
 *
 * @param {number} m
 * @param {number} y
 * @returns {number} number of days
 */
function daysInMonth(m, y) {
  // m is 0 indexed: 0-11
  switch (m) {
    case 2:
      return y % 4 === 0 && y % 100 || y % 400 === 0 ? 29 : 28;

    case 9:
    case 4:
    case 6:
    case 11:
      return 30;

    default:
      return 31;
  }
}
/**
 * Check if the date is valid
 *
 * @param {number} d
 * @param {number} m
 * @param {number} y
 * @returns {boolean} boolean result
 */


function isValidDate(d, m, y) {
  // make year is a number
  if (isNaN(y)) {
    return false;
  }

  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
}
/**
 * Parses a DA formatted string into a Javascript object
 * @param {string} date a string in the DA VR format
 * @param {boolean} [validate] - true if an exception should be thrown if the date is invalid
 * @returns {DateInterface} Javascript object with properties year, month and day or undefined if not present or not 8 bytes long
 */


function parseDA(date) {
  if (date === undefined || date === null || date.length !== 8 || typeof date !== 'string') {
    throw new Error(`invalid DA '${date}'`);
  }

  const yyyy = parseInt(date.substring(0, 4), 10);
  const mm = parseInt(date.substring(4, 6), 10);
  const dd = parseInt(date.substring(6, 8), 10);

  if (isValidDate(dd, mm, yyyy) !== true) {
    throw new Error(`invalid DA '${date}'`);
  }

  return {
    year: yyyy,
    month: mm,
    day: dd
  };
}

/**
 * Parses a TM formatted string into a javascript object with properties for hours, minutes, seconds and fractionalSeconds
 * @param {string} time - a string in the TM VR format
 * @returns {string} javascript object with properties for hours, minutes, seconds and fractionalSeconds or undefined if no element or data.  Missing fields are set to undefined
 */
function parseTM(time) {
  if (time === null || time === undefined || time.length < 2 || typeof time !== 'string') {
    // must at least have HH
    throw new Error(`invalid TM '${time}'`);
  } // 0123456789
  // HHMMSS.FFFFFF


  const hh = parseInt(time.substring(0, 2), 10);
  const mm = time.length >= 4 ? parseInt(time.substring(2, 4), 10) : undefined;
  const ss = time.length >= 6 ? parseInt(time.substring(4, 6), 10) : undefined;
  const fractionalStr = time.length >= 8 ? time.substring(7, 13) : undefined;
  const ffffff = fractionalStr ? parseInt(fractionalStr, 10) * Math.pow(10, 6 - fractionalStr.length) : undefined;

  if (isNaN(hh) || mm !== undefined && isNaN(mm) || ss !== undefined && isNaN(ss) || ffffff !== undefined && isNaN(ffffff) || hh < 0 || hh > 23 || mm && (mm < 0 || mm > 59) || ss && (ss < 0 || ss > 59) || ffffff && (ffffff < 0 || ffffff > 999999)) {
    throw new Error(`invalid TM '${time}'`);
  }

  return {
    hours: hh,
    minutes: mm,
    seconds: ss,
    fractionalSeconds: ffffff
  };
}

/**
 * Utility to create a FullDateInterface object given a string formatted as yyyy-mm-ddTHH:MM:SS.FFFFFFZ
 *
 * @export
 * @param {string} dateTime
 * @returns {FullDateInterface}
 */

function dateTimeToFullDateInterface(dateTime) {
  if (dateTime === undefined || dateTime === null) {
    throw new Error('dateTimeToFullDateInterface : dateTime not defined.');
  }

  const date = parseDA(dateTime.substring(0, 8));
  const time = parseTM(dateTime.substring(8));
  return combineDateTime(date, time);
}

/**
 * Calculate the scan times
 *
 * @export
 * @param {InstanceMetadataForScanTimes[]} instances
 * @returns {FullDateInterface[]}
 */

function calculateScanTimes(instances) {
  const {
    SeriesDate,
    SeriesTime,
    GEPrivatePostInjectionDateTime
  } = instances[0];
  const results = new Array(instances.length);
  const seriesDate = parseDA(SeriesDate);
  const seriesTime = parseTM(SeriesTime);
  const seriesDateTime = combineDateTime(seriesDate, seriesTime);
  let earliestAcquisitionDateTime = new FullDateInterface(`3000-01-01T00:00:00.000000Z`);
  let timeError = earliestAcquisitionDateTime.getTimeInSec();
  instances.forEach(instance => {
    const {
      AcquisitionDate,
      AcquisitionTime
    } = instance;
    const acquisitionDate = parseDA(AcquisitionDate);
    const acquisitionTime = parseTM(AcquisitionTime);
    const acquisitionDateTime = combineDateTime(acquisitionDate, acquisitionTime);

    if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {
      earliestAcquisitionDateTime = acquisitionDateTime;
    } else {
      earliestAcquisitionDateTime = acquisitionDateTime.getTimeInSec() < earliestAcquisitionDateTime.getTimeInSec() ? acquisitionDateTime : earliestAcquisitionDateTime;
    }
  });

  if (earliestAcquisitionDateTime.getTimeInSec() >= timeError) {
    throw new Error('Earliest acquisition time or date could not be parsed.');
  }

  if (seriesDateTime.getTimeInSec() <= earliestAcquisitionDateTime.getTimeInSec()) {
    return results.fill(seriesDateTime);
  } else {
    if (GEPrivatePostInjectionDateTime) {
      // GE Private scan
      return results.fill(dateTimeToFullDateInterface(GEPrivatePostInjectionDateTime));
    } else {
      /*const hasValidFrameTimes = instances.every(instance => {
        return (
          instance.FrameReferenceTime &&
          instance.FrameReferenceTime > 0 &&
          instance.ActualFrameDuration &&
          instance.ActualFrameDuration > 0
        );
      });*/
      // TODO: Temporarily commented out the checks and logic below to
      // investigate the BQML_AC_DT_lessThan_S_DT_SIEMENS-instances case
      //if (!hasValidFrameTimes) {
      return results.fill(earliestAcquisitionDateTime); //}

      /* Siemens PETsyngo	3.x	multi-injection logic
      - backcompute	from	center	(average	count	rate	)	of	time	window	for	bed	position	(frame)	in	series (reliable	in	all	cases)
      - Acquisition	Date	(0x0008,0x0022)	and	Time	(0x0008,0x0032) are	the	start	of	the	bed	position	(frame)
      - Frame	Reference	Time	(0x0054,0x1300) is	the	offset	(ms)	from	the	scan	Date	and	Time we	want	to	the	average	count	rate	time
      */

      /*return instances.map(instance => {
        const {
          FrameReferenceTime,
          ActualFrameDuration,
          RadionuclideHalfLife,
          AcquisitionDate,
          AcquisitionTime,
        } = instance;
        // Some of these checks are only here because the compiler is complaining
        // We could potentially use the ! operator instead
        if (!FrameReferenceTime || FrameReferenceTime <= 0) {
          throw new Error(
            `FrameReferenceTime is invalid: ${FrameReferenceTime}`
          );
        }
               if (!ActualFrameDuration || ActualFrameDuration <= 0) {
          throw new Error(
            `ActualFrameDuration is invalid: ${ActualFrameDuration}`
          );
        }
               if (!RadionuclideHalfLife) {
          throw new Error('RadionuclideHalfLife is required');
        }
               if (!AcquisitionDate) {
          throw new Error('AcquisitionDate is required');
        }
               if (!AcquisitionTime) {
          throw new Error('AcquisitionTime is required');
        }
               const acquisitionDate: DateInterface = parseDA(AcquisitionDate);
        const acquisitionTime: TimeInterface = parseTM(AcquisitionTime);
        const acquisitionDateTime: FullDateInterface = combineDateTime(
          acquisitionDate,
          acquisitionTime
        );
               const frameDurationInSec = ActualFrameDuration / 1000;
        const decayConstant = Math.log(2) / RadionuclideHalfLife;
        const decayDuringFrame = decayConstant * frameDurationInSec;
        // TODO: double check this is correctly copied from QIBA pseudocode
        const averageCountRateTimeWithinFrameInSec =
          (1 / decayConstant) *
          Math.log(decayDuringFrame / (1 - Math.exp(-decayConstant)));
        const scanDateTimeAsNumber =
          Number(acquisitionDateTime) -
          FrameReferenceTime / 1000 +
          averageCountRateTimeWithinFrameInSec;
               const scanDate = new Date(scanDateTimeAsNumber);
        console.log('SIEMENS PATH');
        console.log(new Date(scanDateTimeAsNumber));
        return scanDate;
      });*/
    }
  }
}

function calculateSUVlbmScalingFactor(inputs) {
  const {
    PatientSex,
    PatientWeight,
    PatientSize
  } = inputs;
  let LBM;
  const weightSizeFactor = Math.pow(PatientWeight / (PatientSize * 100), 2); // reference: https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/

  if (PatientSex === 'F') {
    LBM = 1.07 * PatientWeight - 148 * weightSizeFactor;
  } else if (PatientSex === 'M') {
    LBM = 1.1 * PatientWeight - 120 * weightSizeFactor;
  } else {
    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);
  }

  return LBM * 1000; // convert in gr
}
/**
 * From https://link.springer.com/article/10.1007/s00259-014-2961-x
 * and https://link.springer.com/article/10.2165/00003088-200544100-00004
 * and
 * @param inputs
 * @returns
 */


function calculateSUVlbmJanmahasatianScalingFactor(inputs) {
  const {
    PatientSex,
    PatientWeight,
    PatientSize
  } = inputs;
  let LBM;
  const bodyMassIndex = PatientWeight / Math.pow(PatientSize, 2);

  if (PatientSex === 'F') {
    LBM = 9270 * PatientWeight / (8780 + 244 * bodyMassIndex);
  } else if (PatientSex === 'M') {
    LBM = 9270 * PatientWeight / (6680 + 216 * bodyMassIndex);
  } else {
    throw new Error(`PatientSex is an invalid value: ${PatientSex}`);
  }

  return LBM * 1000; // convert in gr
}

function calculateSUVbsaScalingFactor(inputs) {
  const {
    PatientWeight,
    PatientSize
  } = inputs;
  let BSA = Math.pow(PatientWeight, 0.425) * Math.pow(PatientSize * 100, 0.725) * 71.84;
  return BSA;
}

/**
 * Calculate start time
 *
 * @export
 * @param {{
 *   RadiopharmaceuticalStartDateTime?: string;
 *   RadiopharmaceuticalStartTime?: string;
 *   SeriesDate?: string;
 * }} input
 * @returns {FullDateInterface}
 */

function calculateStartTime(input) {
  const {
    RadiopharmaceuticalStartDateTime,
    RadiopharmaceuticalStartTime,
    SeriesDate
  } = input;
  let time;
  let date;

  if (RadiopharmaceuticalStartDateTime) {
    return dateTimeToFullDateInterface(RadiopharmaceuticalStartDateTime);
  } else if (RadiopharmaceuticalStartTime && SeriesDate) {
    // start Date	is not explicit - assume	same as	Series Date;
    // but consider	spanning midnight
    // TODO: do we need some logic to check if the scan went over midnight?
    time = parseTM(RadiopharmaceuticalStartTime);
    date = parseDA(SeriesDate);
    return combineDateTime(date, time);
  }

  throw new Error(`Invalid input: ${input}`);
}

/**
 * The injected dose used to calculate SUV is corrected for the
 * decay that occurs between the time of injection and the start of the scan
 *
 * @param {InstanceMetadata[]} instances
 * @returns {number[]}
 */

function calculateDecayCorrection(instances) {
  const {
    RadionuclideTotalDose,
    RadionuclideHalfLife,
    RadiopharmaceuticalStartDateTime,
    RadiopharmaceuticalStartTime,
    SeriesDate
  } = instances[0];

  if (RadionuclideTotalDose === undefined || RadionuclideTotalDose === null) {
    throw new Error('calculateDecayCorrection : RadionuclideTotalDose value not found.');
  }

  if (RadionuclideHalfLife === undefined || RadionuclideHalfLife === null) {
    throw new Error('calculateDecayCorrection : RadionuclideHalfLife value not found.');
  }

  const scanTimes = calculateScanTimes(instances);
  const startTime = calculateStartTime({
    RadiopharmaceuticalStartDateTime,
    RadiopharmaceuticalStartTime,
    SeriesDate
  });
  return instances.map((_, index) => {
    const scanTime = scanTimes[index];
    const decayTimeInSec = scanTime.getTimeInSec() - startTime.getTimeInSec();

    if (decayTimeInSec < 0) {
      throw new Error('Decay time cannot be less than zero');
    }

    const decayedDose = RadionuclideTotalDose * Math.pow(2, -decayTimeInSec / RadionuclideHalfLife);
    return 1 / decayedDose;
  });
}
/**
 *
 * @param a Simple value or array of simple values
 * @param b Simple value or array of simple values
 * @returns boolean true if the values are equal.
 */


const deepEquals = (a, b) => {
  return a === b || Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every((val, index) => val === b[index]);
};
/**
 * Calculate the SUV factor
 *
 * Note: Rescale Slope / Intercept must still be applied. These must be applied
 *       on a per-Frame basis, since some scanners may have different values per Frame.
 *
 * @export
 * @param {InstanceMetadata[]} instances
 * @returns {ScalingFactorResult[]}
 */


function calculateSUVScalingFactors(instances) {
  const {
    CorrectedImage,
    Units,
    PhilipsPETPrivateGroup,
    PatientWeight,
    PatientSex,
    PatientSize
  } = instances[0];

  if (!CorrectedImage.includes('ATTN') || !CorrectedImage.includes('DECY')) {
    throw new Error(`CorrectedImage must contain "ATTN" and "DECY": ${CorrectedImage}`);
  } // Sanity check that every instance provided has identical
  // values for series-level metadata. If not, the provided
  // data is invalid.


  const isSingleSeries = instances.every(instance => {
    return instance.Units === Units && deepEquals(instance.CorrectedImage, CorrectedImage) && instance.PatientWeight === PatientWeight && instance.PatientSex === PatientSex && instance.PatientSize === PatientSize && instance.RadionuclideHalfLife === instances[0].RadionuclideHalfLife && instance.RadionuclideTotalDose === instances[0].RadionuclideTotalDose && instance.DecayCorrection === instances[0].DecayCorrection && instance.SeriesDate === instances[0].SeriesDate && instance.SeriesTime === instances[0].SeriesTime;
  });

  if (!isSingleSeries) {
    throw new Error('The set of instances does not appear to come from one Series. Every instance must have identical values for series-level metadata properties');
  } // Treat null, undefined and zero as a missing PatientWeight.


  if (!PatientWeight) {
    throw new Error('PatientWeight value is missing. It is not possible to calculate the SUV factors');
  }

  let decayCorrectionArray = new Array(instances.length);
  decayCorrectionArray = calculateDecayCorrection(instances);
  let results = new Array(instances.length);
  const weightInGrams = PatientWeight * 1000;

  if (Units === 'BQML') {
    results = decayCorrectionArray.map(function (value) {
      return value * weightInGrams;
    });
  } else if (Units === 'CNTS') {
    const hasValidSUVScaleFactor = instances.every(instance => {
      var _instance$PhilipsPETP, _instance$PhilipsPETP2, _instance$PhilipsPETP3;

      return instance.PhilipsPETPrivateGroup && ((_instance$PhilipsPETP = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP === void 0 ? void 0 : _instance$PhilipsPETP.SUVScaleFactor) !== null && ((_instance$PhilipsPETP2 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP2 === void 0 ? void 0 : _instance$PhilipsPETP2.SUVScaleFactor) !== undefined && ((_instance$PhilipsPETP3 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP3 === void 0 ? void 0 : _instance$PhilipsPETP3.SUVScaleFactor) !== 0;
    });
    const hasValidActivityConcentrationScaleFactor = instances.every(instance => {
      var _instance$PhilipsPETP4, _instance$PhilipsPETP5, _instance$PhilipsPETP6;

      return instance.PhilipsPETPrivateGroup && !((_instance$PhilipsPETP4 = instance.PhilipsPETPrivateGroup) !== null && _instance$PhilipsPETP4 !== void 0 && _instance$PhilipsPETP4.SUVScaleFactor) && ((_instance$PhilipsPETP5 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP5 === void 0 ? void 0 : _instance$PhilipsPETP5.ActivityConcentrationScaleFactor) !== undefined && ((_instance$PhilipsPETP6 = instance.PhilipsPETPrivateGroup) === null || _instance$PhilipsPETP6 === void 0 ? void 0 : _instance$PhilipsPETP6.ActivityConcentrationScaleFactor) !== 0;
    }); //console.log(`hasValidSUVScaleFactor: ${hasValidSUVScaleFactor}`);
    //console.log(`hasValidActivityConcentrationScaleFactor: ${hasValidActivityConcentrationScaleFactor}`);

    if (hasValidSUVScaleFactor) {
      results = instances.map( // Added ! to tell Typescript that this can't be undefined, since we are testing it
      // in the .every loop above.
      instance => instance.PhilipsPETPrivateGroup.SUVScaleFactor);
    } else if (hasValidActivityConcentrationScaleFactor) {
      // if (0x7053,0x1000) not present, but (0x7053,0x1009) is present, then (0x7053,0x1009) * Rescale Slope,
      // scales pixels to Bq/ml, and proceed as if Units are BQML
      results = instances.map((instance, index) => {
        // Added ! to tell Typescript that this can't be undefined, since we are testing it
        // in the .every loop above.
        return instance.PhilipsPETPrivateGroup.ActivityConcentrationScaleFactor * decayCorrectionArray[index] * weightInGrams;
      });
    } else {
      throw new Error(`Units are in CNTS, but PhilipsPETPrivateGroup has invalid values: ${JSON.stringify(PhilipsPETPrivateGroup)}`);
    }
  } else if (Units === 'GML') {
    // assumes that GML indicates SUVbw instead of SUVlbm
    results.fill(1);
  } else {
    throw new Error(`Units has an invalid value: ${Units}`);
  } // get BSA


  let suvbsaFactor;

  if (PatientSize === null || PatientSize === undefined) {
    console.warn('PatientSize value is missing. It is not possible to calculate the SUV bsa factors');
  } else {
    const sulInputs = {
      PatientWeight,
      PatientSize
    };
    suvbsaFactor = calculateSUVbsaScalingFactor(sulInputs);
  } // get LBM


  let suvlbmFactor;
  let suvlbmJenmaFactor;

  if (PatientSize === null || PatientSize === undefined) {
    console.warn('PatientSize value is missing. It is not possible to calculate the SUV lbm factors');
  } else if (PatientSex === null || PatientSex === undefined) {
    console.warn('PatientSex value is missing. It is not possible to calculate the SUV lbm factors');
  } else {
    const suvlbmInputs = {
      PatientWeight,
      PatientSex,
      PatientSize
    };
    suvlbmFactor = calculateSUVlbmScalingFactor(suvlbmInputs);
    suvlbmJenmaFactor = calculateSUVlbmJanmahasatianScalingFactor(suvlbmInputs);
  }

  return results.map(function (result, index) {
    const factors = {
      suvbw: result
    };

    if (suvbsaFactor) {
      // multiply for BSA
      factors.suvbsa = decayCorrectionArray[index] * suvbsaFactor;
    }

    if (suvlbmFactor) {
      // multiply for LBM
      factors.suvlbm = decayCorrectionArray[index] * suvlbmFactor;
    }

    if (suvlbmJenmaFactor) {
      factors.suvlbmJanma = decayCorrectionArray[index] * suvlbmJenmaFactor;
    } // factor formulaes taken from:
    // https://www.medicalconnections.co.uk/kb/calculating-suv-from-pet-images/


    return factors;
  });
}


//# sourceMappingURL=calculate-suv.esm.js.map


/***/ }),

/***/ 36625:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nk: () => (/* binding */ setConfig),
/* harmony export */   Qy: () => (/* binding */ getPolySeg),
/* harmony export */   zj: () => (/* binding */ getConfig)
/* harmony export */ });
/* unused harmony export getAddOns */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94021);


let config = {};
function getConfig() {
    return config;
}
function setConfig(newConfig) {
    config = newConfig;
}
function getAddOns() {
    return config.addons;
}
let polysegInitialized = false;
function getPolySeg() {
    if (!config.addons?.polySeg) {
        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');
        return null;
    }
    const polyseg = config.addons.polySeg;
    if (!polysegInitialized) {
        polyseg.init();
        polysegInitialized = true;
    }
    return polyseg;
}


/***/ }),

/***/ 93952:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const CORNERSTONE_COLOR_LUT = [
    [0, 0, 0, 0],
    [221, 84, 84, 255],
    [77, 228, 121, 255],
    [166, 70, 235, 255],
    [189, 180, 116, 255],
    [109, 182, 196, 255],
    [204, 101, 157, 255],
    [123, 211, 94, 255],
    [93, 87, 218, 255],
    [225, 128, 80, 255],
    [73, 232, 172, 255],
    [181, 119, 186, 255],
    [176, 193, 112, 255],
    [105, 153, 200, 255],
    [208, 97, 120, 255],
    [90, 215, 101, 255],
    [135, 83, 222, 255],
    [229, 178, 76, 255],
    [122, 183, 181, 255],
    [190, 115, 171, 255],
    [149, 197, 108, 255],
    [100, 118, 205, 255],
    [212, 108, 93, 255],
    [86, 219, 141, 255],
    [183, 79, 226, 255],
    [233, 233, 72, 255],
    [118, 167, 187, 255],
    [194, 111, 146, 255],
    [116, 201, 104, 255],
    [115, 96, 209, 255],
    [216, 147, 89, 255],
    [82, 223, 188, 255],
    [230, 75, 224, 255],
    [163, 184, 121, 255],
    [114, 143, 191, 255],
    [198, 107, 114, 255],
    [99, 206, 122, 255],
    [153, 92, 213, 255],
    [220, 192, 85, 255],
    [78, 215, 227, 255],
    [234, 71, 173, 255],
    [141, 188, 117, 255],
    [110, 113, 195, 255],
    [202, 128, 103, 255],
    [95, 210, 157, 255],
    [195, 88, 217, 255],
    [206, 224, 81, 255],
    [74, 166, 231, 255],
    [185, 120, 139, 255],
    [113, 192, 113, 255],
    [133, 106, 199, 255],
    [207, 162, 98, 255],
    [91, 214, 198, 255],
    [221, 84, 198, 255],
    [159, 228, 77, 255],
    [70, 111, 235, 255],
    [189, 119, 116, 255],
    [109, 196, 138, 255],
    [165, 101, 204, 255],
    [211, 201, 94, 255],
    [87, 191, 218, 255],
    [225, 80, 153, 255],
    [106, 232, 73, 255],
    [124, 119, 186, 255],
    [193, 142, 112, 255],
    [105, 200, 168, 255],
    [203, 97, 208, 255],
    [184, 215, 90, 255],
    [83, 147, 222, 255],
    [229, 76, 101, 255],
    [122, 183, 130, 255],
    [146, 115, 190, 255],
    [197, 171, 108, 255],
    [100, 205, 205, 255],
    [212, 93, 177, 255],
    [141, 219, 86, 255],
    [79, 97, 226, 255],
    [233, 99, 72, 255],
    [118, 187, 150, 255],
    [173, 111, 194, 255],
    [197, 201, 104, 255],
    [96, 171, 209, 255],
    [216, 89, 137, 255],
    [94, 223, 82, 255],
    [107, 75, 230, 255],
    [184, 153, 121, 255],
    [114, 191, 175, 255],
    [198, 107, 191, 255],
    [166, 206, 99, 255],
    [92, 132, 213, 255],
    [220, 85, 91, 255],
    [78, 227, 115, 255],
    [159, 71, 234, 255],
    [188, 176, 117, 255],
    [110, 185, 195, 255],
    [202, 103, 161, 255],
    [129, 210, 95, 255],
    [88, 88, 217, 255],
    [224, 123, 81, 255],
    [74, 231, 166, 255],
    [177, 120, 185, 255],
    [179, 192, 113, 255],
    [106, 156, 199, 255],
    [207, 98, 125, 255],
    [91, 214, 96, 255],
    [130, 84, 221, 255],
    [228, 171, 77, 255],
    [70, 235, 221, 255],
    [189, 116, 174, 255],
    [153, 196, 109, 255],
    [101, 123, 204, 255],
    [211, 104, 94, 255],
    [87, 218, 136, 255],
    [177, 80, 225, 255],
    [232, 225, 73, 255],
    [119, 169, 186, 255],
    [193, 112, 149, 255],
    [121, 200, 105, 255],
    [111, 97, 208, 255],
    [215, 142, 90, 255],
    [83, 222, 181, 255],
    [229, 76, 229, 255],
    [165, 183, 122, 255],
    [115, 146, 190, 255],
    [197, 108, 119, 255],
    [100, 205, 118, 255],
    [148, 93, 212, 255],
    [219, 186, 86, 255],
    [79, 220, 226, 255],
    [233, 72, 179, 255],
    [144, 187, 118, 255],
    [111, 118, 194, 255],
    [201, 124, 104, 255],
    [96, 209, 153, 255],
    [189, 89, 216, 255],
    [211, 223, 82, 255],
    [75, 172, 230, 255],
    [184, 121, 142, 255],
    [117, 191, 114, 255],
    [130, 107, 198, 255],
    [206, 157, 99, 255],
    [92, 213, 193, 255],
    [220, 85, 203, 255],
    [165, 227, 78, 255],
    [71, 118, 234, 255],
    [188, 117, 117, 255],
    [110, 195, 135, 255],
    [161, 103, 202, 255],
    [210, 195, 95, 255],
    [88, 195, 217, 255],
    [224, 81, 158, 255],
    [113, 231, 74, 255],
    [123, 120, 185, 255],
    [192, 139, 113, 255],
    [106, 199, 164, 255],
    [198, 98, 207, 255],
    [188, 214, 91, 255],
    [84, 153, 221, 255],
    [228, 77, 108, 255],
    [70, 235, 84, 255],
    [143, 116, 189, 255],
    [196, 167, 109, 255],
    [101, 204, 199, 255],
    [211, 94, 182, 255],
    [147, 218, 87, 255],
    [80, 104, 225, 255],
    [232, 93, 73, 255],
    [119, 186, 147, 255],
    [170, 112, 193, 255],
    [200, 200, 105, 255],
    [97, 175, 208, 255],
    [215, 90, 142, 255],
    [100, 222, 83, 255],
    [101, 76, 229, 255],
    [183, 150, 122, 255],
    [115, 190, 171, 255],
    [197, 108, 194, 255],
    [170, 205, 100, 255],
    [93, 138, 212, 255],
    [219, 86, 97, 255],
    [79, 226, 110, 255],
    [153, 72, 233, 255],
    [187, 173, 118, 255],
    [111, 187, 194, 255],
    [201, 104, 165, 255],
    [134, 209, 96, 255],
    [89, 95, 216, 255],
    [223, 117, 82, 255],
    [75, 230, 159, 255],
    [174, 121, 184, 255],
    [182, 191, 114, 255],
    [107, 160, 198, 255],
    [206, 99, 130, 255],
    [92, 213, 92, 255],
    [124, 85, 220, 255],
    [227, 165, 78, 255],
    [71, 234, 214, 255],
    [188, 117, 176, 255],
    [156, 195, 110, 255],
    [103, 128, 202, 255],
    [210, 100, 95, 255],
    [88, 217, 131, 255],
    [170, 81, 224, 255],
    [231, 218, 74, 255],
    [120, 172, 185, 255],
    [192, 113, 153, 255],
    [125, 199, 106, 255],
    [107, 98, 207, 255],
    [214, 137, 91, 255],
    [84, 221, 175, 255],
    [222, 77, 228, 255],
    [194, 235, 70, 255],
    [116, 149, 189, 255],
    [196, 109, 123, 255],
    [101, 204, 114, 255],
    [143, 94, 211, 255],
    [218, 180, 87, 255],
    [80, 225, 225, 255],
    [232, 73, 186, 255],
    [147, 186, 119, 255],
    [112, 122, 193, 255],
    [200, 121, 105, 255],
    [97, 208, 148, 255],
    [184, 90, 215, 255],
    [216, 222, 83, 255],
    [76, 178, 229, 255],
    [183, 122, 145, 255],
    [121, 190, 115, 255],
    [126, 108, 197, 255],
    [205, 153, 100, 255],
    [93, 212, 187, 255],
    [219, 86, 208, 255],
    [171, 226, 79, 255],
    [72, 126, 233, 255],
    [187, 118, 121, 255],
    [111, 194, 132, 255],
    [157, 104, 201, 255],
    [209, 190, 96, 255],
    [89, 200, 216, 255],
    [223, 82, 164, 255],
    [120, 230, 75, 255],
    [121, 121, 184, 255],
    [191, 136, 114, 255],
    [107, 198, 160, 255],
    [192, 99, 206, 255],
    [193, 213, 92, 255],
    [85, 158, 220, 255],
    [227, 78, 115, 255],
    [71, 234, 78, 255],
    [141, 117, 188, 255],
    [195, 163, 110, 255],
    [103, 202, 194, 255],
    [210, 95, 186, 255],
    [153, 217, 88, 255],
    [81, 111, 224, 255],
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORNERSTONE_COLOR_LUT);


/***/ }),

/***/ 47085:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COLOR_LUT: () => (/* reexport safe */ _COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93952);




/***/ }),

/***/ 94430:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MouseCursor),
/* harmony export */   i: () => (/* binding */ standardCursorNames)
/* harmony export */ });
const DEFINED_CURSORS = Symbol('DefinedCursors');
const STANDARD_CURSORS = new Set([
    'alias',
    'all-scroll',
    'auto',
    'cell',
    'col-resize',
    'context-menu',
    'copy',
    'crosshair',
    'default',
    'e-resize',
    'ew-resize',
    'grab',
    'grabbing',
    'help',
    'move',
    'ne-resize',
    'nesw-resize',
    'no-drop',
    'none',
    'not-allowed',
    'n-resize',
    'ns-resize',
    'nw-resize',
    'nwse-resize',
    'pointer',
    'progress',
    'row-resize',
    'se-resize',
    's-resize',
    'sw-resize',
    'text',
    'vertical-text',
    'wait',
    'w-resize',
    'zoom-in',
    'zoom-out',
]);
class MouseCursor {
    constructor(name, fallback) {
        this.name = name + '';
        this.fallback = fallback;
    }
    getName() {
        return this.name + '';
    }
    addFallbackStyleProperty(style) {
        const { fallback } = this;
        if (fallback instanceof MouseCursor) {
            return `${style}, ${fallback.getStyleProperty()}`;
        }
        return style + '';
    }
    getStyleProperty() {
        return this.addFallbackStyleProperty(this.name) + '';
    }
    static getDefinedCursor(name) {
        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
        let mouseCursor = definedCursors.get(name);
        if (mouseCursor instanceof MouseCursor) {
            return mouseCursor;
        }
        if (STANDARD_CURSORS.has(name)) {
            mouseCursor = new MouseCursor(name);
            definedCursors.set(name, mouseCursor);
            return mouseCursor;
        }
    }
    static setDefinedCursor(name, cursor) {
        if (cursor instanceof MouseCursor) {
            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
            definedCursors.set(name, cursor);
            return true;
        }
        return false;
    }
}
function getDefinedCursors(context, symbol) {
    let definedCursors = context[symbol];
    if (!(definedCursors instanceof Map)) {
        definedCursors = new Map();
        Object.defineProperty(context, symbol, { value: definedCursors });
    }
    return definedCursors;
}
const standardCursorNames = STANDARD_CURSORS.values();



/***/ }),

/***/ 7001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hideElementCursor: () => (/* binding */ hideElementCursor),
/* harmony export */   initElementCursor: () => (/* binding */ initElementCursor),
/* harmony export */   resetElementCursor: () => (/* binding */ resetElementCursor),
/* harmony export */   setElementCursor: () => (/* binding */ _setElementCursor)
/* harmony export */ });
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94430);

const ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');
function initElementCursor(element, cursor) {
    _getElementCursors(element)[0] = cursor;
    _setElementCursor(element, cursor);
}
function _setElementCursor(element, cursor) {
    const cursors = _getElementCursors(element);
    cursors[1] = cursors[0];
    cursors[0] = cursor;
    element.style.cursor = (cursor instanceof _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
        ? cursor
        : _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('auto')).getStyleProperty();
}
function resetElementCursor(element) {
    _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
    _setElementCursor(element, _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('none'));
}
function _getElementCursors(element) {
    let map = _getElementCursors[ELEMENT_CURSORS_MAP];
    if (!(map instanceof WeakMap)) {
        map = new WeakMap();
        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
            value: map,
        });
    }
    let cursors = map.get(element);
    if (!cursors) {
        cursors = [null, null];
        map.set(element, cursors);
    }
    return cursors;
}



/***/ }),

/***/ 79475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CursorNames: () => (/* binding */ CursorNames),
  CursorSVG: () => (/* reexport */ CursorSVG),
  ImageMouseCursor: () => (/* reexport */ ImageMouseCursor),
  MouseCursor: () => (/* reexport */ MouseCursor/* default */.A),
  SVGMouseCursor: () => (/* reexport */ SVGMouseCursor),
  elementCursor: () => (/* reexport */ elementCursor),
  registerCursor: () => (/* reexport */ registerCursor),
  setCursorForElement: () => (/* reexport */ cursors_setCursorForElement)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js
var MouseCursor = __webpack_require__(94430);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js


const DEFAULT_NAME = 'image-cursor';
class ImageMouseCursor extends MouseCursor/* default */.A {
    constructor(url, x, y, name, fallback) {
        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);
        this.url = url;
        this.x = Number(x) || 0;
        this.y = Number(y) || 0;
    }
    getStyleProperty() {
        const { url, x, y } = this;
        let style = `url('${url}')`;
        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {
            style += ` ${x} ${y}`;
        }
        return this.addFallbackStyleProperty(style);
    }
    static getUniqueInstanceName(prefix) {
        return `${prefix}-${esm.utilities.getRuntimeId(ImageMouseCursor)}`;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js
const BASE = {
    iconContent: '',
    iconSize: 16,
    viewBox: {
        x: 16,
        y: 16,
    },
    mousePoint: {
        x: 8,
        y: 8,
    },
    mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `,
};
const SEGMENTATION_CURSOR_BOUNDARIES = {
    x: 127,
    y: 60,
};
const MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
const PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
const SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
const RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
const CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
const CursorSVG = {
    Angle: extend(BASE, {
        name: 'Angle',
        iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    ArrowAnnotate: extend(BASE, {
        name: 'ArrowAnnotate',
        iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Bidirectional: extend(BASE, {
        name: 'Bidirectional',
        iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
        viewBox: {
            x: 48,
            y: 48,
        },
    }),
    CobbAngle: extend(BASE, {
        name: 'CobbAngle',
        iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    CircleROI: extend(BASE, {
        name: 'CircleROI',
        iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    EllipticalROI: extend(BASE, {
        name: 'EllipticalROI',
        iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    FreehandROI: extend(BASE, {
        name: 'FreehandROI',
        iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    FreehandROISculptor: extend(BASE, {
        name: 'FreehandROISculptor',
        iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Length: extend(BASE, {
        name: 'Length',
        iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Height: extend(BASE, {
        name: 'Height',
        iconContent: `<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Probe: extend(BASE, {
        name: 'Probe',
        iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    RectangleROI: extend(BASE, {
        name: 'RectangleROI',
        iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Label: extend(BASE, {
        name: 'Label',
        iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Crosshairs: extend(BASE, {
        name: 'Crosshairs',
        iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Eraser: extend(BASE, {
        name: 'Eraser',
        iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
        viewBox: {
            x: 2048,
            y: 1792,
        },
    }),
    Magnify: extend(BASE, {
        name: 'Magnify',
        iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
        viewBox: {
            x: 512,
            y: 512,
        },
    }),
    Pan: extend(BASE, {
        name: 'Pan',
        iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Rotate: extend(BASE, {
        name: 'Rotate',
        iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    StackScroll: extend(BASE, {
        name: 'StackScroll',
        iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
        viewBox: {
            x: 24,
            y: 28,
        },
    }),
    WindowLevelRegion: extend(BASE, {
        name: 'WindowLevelRegion',
        iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    WindowLevel: extend(BASE, {
        name: 'WindowLevel',
        iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Zoom: extend(BASE, {
        name: 'Zoom',
        iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
        viewBox: {
            x: 640,
            y: 512,
        },
    }),
    SegmentationFreeHandEraseInside: extend(BASE, {
        name: 'SegmentationFreeHandEraseInside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillInside: extend(BASE, {
        name: 'SegmentationFreeHandFillInside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandEraseOutside: extend(BASE, {
        name: 'SegmentationFreeHandEraseOutside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillOutside: extend(BASE, {
        name: 'SegmentationFreeHandFillOutside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationRectangleEraseInside: extend(BASE, {
        name: 'SegmentationRectangleEraseInside',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    RectangleScissor: extend(BASE, {
        name: 'RectangleScissor',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_INSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_INSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    CircleScissor: extend(BASE, {
        name: 'CircleScissor',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_INSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_INSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.ERASE_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
};
function extend(base, values) {
    return Object.assign(Object.create(base), {
        ...values,
        name: values.name || base.name,
    });
}
function registerCursor(toolName, iconContent, viewBox) {
    CursorSVG[toolName] = extend(BASE, {
        iconContent,
        viewBox,
    });
}
function getDefinedSVGCursorDescriptor(name) {
    return CursorSVG[name];
}
const svgCursorNames = Object.keys(CursorSVG);


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js




const PROPERTY = 'color';
const STATE = enums.AnnotationStyleStates.Highlighted;
const MODE = enums.ToolModes.Active;
class SVGMouseCursor extends ImageMouseCursor {
    constructor(url, x, y, name, fallback) {
        super(url, x, y, name, fallback);
    }
    static getDefinedCursor(name, pointer = false, color) {
        if (!color) {
            color = (0,helpers/* getStyleProperty */.h)(PROPERTY, {}, STATE, MODE);
        }
        const urn = getCursorURN(name, pointer, color);
        let cursor = super.getDefinedCursor(urn);
        if (!cursor) {
            const descriptor = getDefinedSVGCursorDescriptor(name);
            if (descriptor) {
                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));
                super.setDefinedCursor(urn, cursor);
            }
        }
        return cursor;
    }
}
function format(template, dictionary) {
    const dict = Object(dictionary);
    const defined = Object.prototype.hasOwnProperty.bind(dict);
    return (template + '').replace(/\{\{(\w+)\}\}/g, (match, key) => {
        return defined(key) ? dict[key] + '' : '';
    });
}
function getCursorURN(name, pointer, color) {
    const type = pointer ? 'pointer' : 'cursor';
    return `${type}:${name}/${color}`;
}
function createSVGMouseCursor(descriptor, name, pointer, color, fallback) {
    const { x, y } = descriptor.mousePoint;
    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);
}
function createSVGIconUrl(descriptor, pointer, options) {
    const blob = createSVGIconBlob(descriptor, pointer, options);
    const url = URL.createObjectURL(blob);
    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;
    return urn;
}
function createSVGIconBlob(descriptor, pointer, options) {
    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);
    return new Blob([svgString], { type: 'image/svg+xml' });
}
function createSVGIcon(descriptor, options) {
    const { iconContent, iconSize, viewBox } = descriptor;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${iconSize}" height="${iconSize}" viewBox="0 0
      ${viewBox.x} ${viewBox.y}">
      ${iconContent}
    </svg>`;
    return format(svgString, options);
}
function createSVGIconWithPointer(descriptor, options) {
    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;
    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);
    const svgSize = 16 + iconSize;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">
      <g>${mousePointerGroupString}</g>
      <g transform="translate(16, 16) scale(${scale})">${iconContent}</g>
    </svg>`;
    return format(svgString, options);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js



function setCursorForElement(element, cursorName) {
    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
    if (!cursor) {
        cursor = MouseCursor/* default */.A.getDefinedCursor(cursorName);
    }
    if (!cursor) {
        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);
        cursor = MouseCursor/* default */.A.getDefinedCursor(cursorName);
    }
    (0,elementCursor.setElementCursor)(element, cursor);
}
/* harmony default export */ const cursors_setCursorForElement = (setCursorForElement);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js






const CursorNames = [...svgCursorNames, ...MouseCursor/* standardCursorNames */.i];



/***/ }),

/***/ 85856:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95074);


function drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {
    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];
    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];
    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];
    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];
    (0,_drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawEllipse);


/***/ }),

/***/ 95074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56442);



function drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'ellipse', ellipseUID);
    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [bottom, top, left, right] = canvasCoordinates;
    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;
    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
    const radiusX = w / 2;
    const radiusY = h / 2;
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        rx: `${radiusX}`,
        ry: `${radiusY}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingEllipse) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, existingEllipse);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');
        if (dataId !== '') {
            svgEllipseElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, svgEllipseElement);
        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawEllipseByCoordinates);


/***/ }),

/***/ 94042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {
    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({
        color: 'rgb(0, 255, 0)',
        handleRadius: '6',
        width: '2',
        lineWidth: undefined,
        fill: 'transparent',
        type: 'circle',
        opacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);
    let attributes;
    if (type === 'circle') {
        attributes = {
            cx: `${handle[0]}`,
            cy: `${handle[1]}`,
            r: handleRadius,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            opacity: opacity,
        };
    }
    else if (type === 'rect') {
        const handleRadiusFloat = parseFloat(handleRadius);
        const side = handleRadiusFloat * 1.5;
        const x = handle[0] - side * 0.5;
        const y = handle[1] - side * 0.5;
        attributes = {
            x: `${x}`,
            y: `${y}`,
            width: `${side}`,
            height: `${side}`,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            rx: `${side * 0.1}`,
            opacity: opacity,
        };
    }
    else {
        throw new Error(`Unsupported handle type: ${type}`);
    }
    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingHandleElement) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingHandleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newHandleElement = document.createElementNS(svgns, type);
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newHandleElement);
        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawHandle);


/***/ }),

/***/ 92118:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawLine)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'line', lineUID);
    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';
    const attributes = {
        x1: `${start[0]}`,
        y1: `${start[1]}`,
        x2: `${end[0]}`,
        y2: `${end[1]}`,
        stroke: color,
        style: dropShadowStyle,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newLine = document.createElementNS(svgns, 'line');
        if (dataId !== '') {
            newLine.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newLine);
        svgDrawingHelper.appendNode(newLine, svgNodeHash);
    }
}


/***/ }),

/***/ 17311:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawPath)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {
    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);
    const pointsArrays = hasSubArrays ? points : [points];
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'path', pathUID);
    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {
        const points = pointsArrays[i];
        const numPoints = points.length;
        if (numPoints < 2) {
            continue;
        }
        for (let j = 0; j < numPoints; j++) {
            const point = points[j];
            const cmd = j ? 'L' : 'M';
            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
        }
        if (closePath) {
            pointsAttribute += 'Z ';
        }
    }
    if (!pointsAttribute) {
        return;
    }
    const attributes = {
        d: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingNode) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingNode);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newNode = document.createElementNS(svgns, 'path');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newNode);
        svgDrawingHelper.appendNode(newNode, svgNodeHash);
    }
}


/***/ }),

/***/ 98812:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawPolyline)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {
    if (points.length < 2) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'polyline', polylineUID);
    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (const point of points) {
        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
    }
    if (closePath) {
        const firstPoint = points[0];
        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;
    }
    const attributes = {
        points: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingPolyLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingPolyLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newPolyLine = document.createElementNS(svgns, 'polyline');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newPolyLine);
        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);
    }
}


/***/ }),

/***/ 75076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawRectByCoordinates)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56442);



function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;
    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);
    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);
    const center = [
        (bottomRight[0] + topLeft[0]) / 2,
        (bottomRight[1] + topLeft[1]) / 2,
    ];
    const leftEdgeCenter = [
        (bottomLeft[0] + topLeft[0]) / 2,
        (bottomLeft[1] + topLeft[1]) / 2,
    ];
    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *
        180) /
        Math.PI;
    const attributes = {
        x: `${center[0] - width / 2}`,
        y: `${center[1] - height / 2}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        if (dataId !== '') {
            svgRectElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}


/***/ }),

/***/ 26290:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);


function drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {
    const mergedOptions = Object.assign({
        fontFamily: 'Helvetica, Arial, sans-serif',
        fontSize: '14px',
        color: 'rgb(255, 255, 0)',
        background: '',
        padding: 25,
        centerX: false,
        centerY: true,
    }, options);
    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);
    return textGroupBoundingBox;
}
function _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {
    const { padding, color, fontFamily, fontSize, background } = options;
    let textGroupBoundingBox;
    const [x, y] = [position[0] + padding, position[1] + padding];
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'text', textUID);
    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingTextGroup) {
        const textElement = existingTextGroup.querySelector('text');
        const textSpans = Array.from(textElement.children);
        for (let i = 0; i < textSpans.length; i++) {
            const textSpanElement = textSpans[i];
            const text = textLines[i] || '';
            textSpanElement.textContent = text;
        }
        if (textLines.length > textSpans.length) {
            for (let i = 0; i < textLines.length - textSpans.length; i++) {
                const textLine = textLines[i + textSpans.length];
                const textSpan = _createTextSpan(textLine);
                textElement.appendChild(textSpan);
            }
            existingTextGroup.appendChild(textElement);
            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);
        }
        const textAttributes = {
            fill: color,
            'font-size': fontSize,
            'font-family': fontFamily,
        };
        const textGroupAttributes = {
            transform: `translate(${x} ${y})`,
        };
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(textAttributes, textElement);
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(textGroupAttributes, existingTextGroup);
        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const textGroup = document.createElementNS(svgns, 'g');
        textGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroup.setAttribute('transform', `translate(${x} ${y})`);
        const textElement = _createTextElement(svgDrawingHelper, options);
        for (let i = 0; i < textLines.length; i++) {
            const textLine = textLines[i];
            const textSpan = _createTextSpan(textLine);
            textElement.appendChild(textSpan);
        }
        textGroup.appendChild(textElement);
        svgDrawingHelper.appendNode(textGroup, svgNodeHash);
        textGroupBoundingBox = _drawTextBackground(textGroup, background);
    }
    return Object.assign({}, textGroupBoundingBox, {
        x,
        y,
        height: textGroupBoundingBox.height + padding,
        width: textGroupBoundingBox.width + padding,
    });
}
function _createTextElement(svgDrawingHelper, options) {
    const { color, fontFamily, fontSize } = options;
    const svgns = 'http://www.w3.org/2000/svg';
    const textElement = document.createElementNS(svgns, 'text');
    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';
    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;
    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;
    textElement.setAttribute('x', '0');
    textElement.setAttribute('y', '0');
    textElement.setAttribute('fill', color);
    textElement.setAttribute('font-family', fontFamily);
    textElement.setAttribute('font-size', fontSize);
    textElement.setAttribute('style', combinedStyle);
    textElement.setAttribute('pointer-events', 'visible');
    return textElement;
}
function _createTextSpan(text) {
    const svgns = 'http://www.w3.org/2000/svg';
    const textSpanElement = document.createElementNS(svgns, 'tspan');
    textSpanElement.setAttribute('x', '0');
    textSpanElement.setAttribute('dy', '1.2em');
    textSpanElement.textContent = text;
    return textSpanElement;
}
function _drawTextBackground(group, color) {
    let element = group.querySelector('rect.background');
    if (!color) {
        if (element) {
            group.removeChild(element);
        }
        return group.getBBox();
    }
    if (!element) {
        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        element.setAttribute('class', 'background');
        group.insertBefore(element, group.firstChild);
    }
    const bBox = group.getBBox();
    const attributes = {
        x: `${bBox.x}`,
        y: `${bBox.y}`,
        width: `${bBox.width}`,
        height: `${bBox.height}`,
        fill: color,
    };
    (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, element);
    return bBox;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawTextBox);


/***/ }),

/***/ 17328:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  draw: () => (/* reexport */ draw/* default */.A),
  drawArrow: () => (/* reexport */ drawArrow),
  drawCircle: () => (/* reexport */ drawCircle/* default */.A),
  drawEllipse: () => (/* reexport */ drawEllipse/* default */.A),
  drawEllipseByCoordinates: () => (/* reexport */ drawEllipseByCoordinates/* default */.A),
  drawHandle: () => (/* reexport */ drawHandle/* default */.A),
  drawHandles: () => (/* reexport */ drawHandles/* default */.A),
  drawHeight: () => (/* reexport */ drawHeight),
  drawLine: () => (/* reexport */ drawLine/* default */.A),
  drawLinkedTextBox: () => (/* reexport */ drawLinkedTextBox/* default */.A),
  drawPath: () => (/* reexport */ drawPath/* default */.A),
  drawPolyline: () => (/* reexport */ drawPolyline/* default */.A),
  drawRect: () => (/* reexport */ drawRect/* default */.A),
  drawRectByCoordinates: () => (/* reexport */ drawRectByCoordinates/* default */.A),
  drawRedactionRect: () => (/* reexport */ drawRedactionRect),
  drawTextBox: () => (/* reexport */ drawTextBox/* default */.A),
  setAttributesIfNecessary: () => (/* reexport */ setAttributesIfNecessary/* default */.A),
  setNewAttributesIfValid: () => (/* reexport */ setNewAttributesIfValid/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js + 1 modules
var draw = __webpack_require__(18262);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js
var drawCircle = __webpack_require__(12004);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js
var drawEllipse = __webpack_require__(85856);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js
var drawEllipseByCoordinates = __webpack_require__(95074);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js
var drawHandles = __webpack_require__(56745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js
var drawHandle = __webpack_require__(94042);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js
var drawLine = __webpack_require__(92118);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js

function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const midX = end[0] + (start[0] - end[0]) / 2;
    const endfirstLine = [midX, start[1]];
    const endsecondLine = [midX, end[1]];
    const firstLine = {
        start: start,
        end: endfirstLine,
    };
    const secondLine = {
        start: endfirstLine,
        end: endsecondLine,
    };
    const threeLine = {
        start: endsecondLine,
        end: end,
    };
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js
var drawPolyline = __webpack_require__(98812);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js
var drawPath = __webpack_require__(17311);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js + 1 modules
var drawLinkedTextBox = __webpack_require__(1595);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js
var drawRect = __webpack_require__(97530);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js
var drawRectByCoordinates = __webpack_require__(75076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js
var drawTextBox = __webpack_require__(26290);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js

const svgns = 'http://www.w3.org/2000/svg';
function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;
    if (!viaMarker) {
        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
        return;
    }
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const markerBaseId = `arrow-${annotationUID}`;
    const markerFullId = `${markerBaseId}-${layerId}`;
    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');
    let arrowMarker = defs.querySelector(`#${markerFullId}`);
    if (!arrowMarker) {
        arrowMarker = document.createElementNS(svgns, 'marker');
        arrowMarker.setAttribute('id', markerFullId);
        arrowMarker.setAttribute('viewBox', '0 0 10 10');
        arrowMarker.setAttribute('refX', '8');
        arrowMarker.setAttribute('refY', '5');
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        arrowMarker.setAttribute('orient', 'auto');
        const arrowPath = document.createElementNS(svgns, 'path');
        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
        arrowPath.setAttribute('fill', color);
        arrowMarker.appendChild(arrowPath);
        defs.appendChild(arrowMarker);
    }
    else {
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        const arrowPath = arrowMarker.querySelector('path');
        if (arrowPath) {
            arrowPath.setAttribute('fill', color);
        }
    }
    options.markerEndId = markerFullId;
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
}
function legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;
    const headLength = 10;
    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
    const firstLine = {
        start: [
            end[0] - headLength * Math.cos(angle - Math.PI / 7),
            end[1] - headLength * Math.sin(angle - Math.PI / 7),
        ],
        end: end,
    };
    const secondLine = {
        start: [
            end[0] - headLength * Math.cos(angle + Math.PI / 7),
            end[1] - headLength * Math.sin(angle + Math.PI / 7),
        ],
        end: end,
    };
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, arrowUID, start, end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js
var _getHash = __webpack_require__(97181);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js
var setAttributesIfNecessary = __webpack_require__(85899);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js
var setNewAttributesIfValid = __webpack_require__(56442);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js



function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    const attributes = {
        x: `${tlhc[0]}`,
        y: `${tlhc[1]}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'black',
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,setAttributesIfNecessary/* default */.A)(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        (0,setNewAttributesIfValid/* default */.A)(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js





















/***/ }),

/***/ 85899:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export setAttributesIfNecessary */
function setAttributesIfNecessary(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const currentValue = svgNode.getAttribute(key);
        const newValue = attributes[key];
        if (newValue === undefined || newValue === '') {
            svgNode.removeAttribute(key);
        }
        else if (currentValue !== newValue) {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setAttributesIfNecessary);


/***/ }),

/***/ 56442:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export setNewAttributesIfValid */
function setNewAttributesIfValid(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const newValue = attributes[key];
        if (newValue !== undefined && newValue !== '') {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setNewAttributesIfValid);


/***/ }),

/***/ 93098:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94021);
/* harmony import */ var _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27740);



const enable = function () {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_COMPLETED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationCompleted);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_MODIFIED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationUpdate);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_REMOVED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationDelete);
};
const disable = function () {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_COMPLETED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationCompleted);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_MODIFIED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationUpdate);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_REMOVED, _utilities_segmentation_InterpolationManager_InterpolationManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.handleAnnotationDelete);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ 24271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70333);



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onCameraModified = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onCameraModified) {
            tool.onCameraModified(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ 93151:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70333);



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onCameraReset = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onResetCamera) {
            tool.onResetCamera(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_RESET, onCameraReset);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.CAMERA_RESET, onCameraReset);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ 75681:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);


const onImageRendered = function (evt) {
    (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(evt.detail.element);
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ 40396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70333);



const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
const onImageSpacingCalibrated = function (evt) {
    const enabledTools = (0,_shared_getToolsWithModesForMouseEvent__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onImageSpacingCalibrated) {
            tool.onImageSpacingCalibrated(evt);
        }
    });
};
const enable = function (element) {
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
const disable = function (element) {
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    enable,
    disable,
});


/***/ }),

/***/ 3406:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $m: () => (/* reexport safe */ _touchToolEventDispatcher__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   In: () => (/* reexport safe */ _imageRenderedEventDispatcher__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   V$: () => (/* reexport safe */ _keyboardToolEventDispatcher__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   aB: () => (/* reexport safe */ _cameraModifiedEventDispatcher__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   dj: () => (/* reexport safe */ _annotationInterpolationEventDispatcher__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   n6: () => (/* reexport safe */ _mouseToolEventDispatcher__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   we: () => (/* reexport safe */ _cameraResetEventDispatcher__WEBPACK_IMPORTED_MODULE_7__.A),
/* harmony export */   z5: () => (/* reexport safe */ _imageSpacingCalibratedEventDispatcher__WEBPACK_IMPORTED_MODULE_4__.A)
/* harmony export */ });
/* harmony import */ var _imageRenderedEventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75681);
/* harmony import */ var _mouseToolEventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66106);
/* harmony import */ var _keyboardToolEventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83438);
/* harmony import */ var _cameraModifiedEventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24271);
/* harmony import */ var _imageSpacingCalibratedEventDispatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40396);
/* harmony import */ var _touchToolEventDispatcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45470);
/* harmony import */ var _annotationInterpolationEventDispatcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93098);
/* harmony import */ var _cameraResetEventDispatcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(93151);











/***/ }),

/***/ 83438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94021);
/* harmony import */ var _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74690);


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.KEY_DOWN, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .keyDown */ .u);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.KEY_UP, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .keyUp */ .L);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.KEY_DOWN, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .keyDown */ .u);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.KEY_UP, _keyboardEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .keyUp */ .L);
};
const keyboardToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keyboardToolEventDispatcher);


/***/ }),

/***/ 66106:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94021);
/* harmony import */ var _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40100);


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseClick */ .q_);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOWN, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDown */ .cT);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOWN_ACTIVATE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDownActivate */ .Xd);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOUBLE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDoubleClick */ .LM);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DRAG, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDrag */ .al);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_MOVE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseMove */ .tG);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_UP, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseUp */ .Je);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_WHEEL, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseWheel */ .rO);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseClick */ .q_);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOWN, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDown */ .cT);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOWN_ACTIVATE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDownActivate */ .Xd);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DOUBLE_CLICK, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDoubleClick */ .LM);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_DRAG, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseDrag */ .al);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_MOVE, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseMove */ .tG);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_UP, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseUp */ .Je);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.MOUSE_WHEEL, _mouseEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .mouseWheel */ .rO);
};
const mouseToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mouseToolEventDispatcher);


/***/ }),

/***/ 45470:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94021);
/* harmony import */ var _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84971);


const enable = function (element) {
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_START, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchStart */ .gX);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_START_ACTIVATE, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchStartActivate */ .$F);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_DRAG, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchDrag */ .Oz);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_END, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchEnd */ .ls);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_TAP, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchTap */ .lI);
    element.addEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_PRESS, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchPress */ .x5);
};
const disable = function (element) {
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_START, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchStart */ .gX);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_START_ACTIVATE, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchStartActivate */ .$F);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_DRAG, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchDrag */ .Oz);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_END, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchEnd */ .ls);
    element.removeEventListener(_enums_Events__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.TOUCH_PRESS, _touchEventHandlers__WEBPACK_IMPORTED_MODULE_1__/* .touchPress */ .x5);
};
const touchToolEventDispatcher = {
    enable,
    disable,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (touchToolEventDispatcher);


/***/ }),

/***/ 50986:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ contourSegmentationCompletedListener),
/* harmony export */   r: () => (/* binding */ createPolylineHole)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15295);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95527);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58640);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93126);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(72967);
/* harmony import */ var _utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64843);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77609);
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68040);












const DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';
async function contourSegmentationCompletedListener(evt) {
    const sourceAnnotation = evt.detail
        .annotation;
    if (!(0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(sourceAnnotation)) {
        return;
    }
    const viewport = getViewport(sourceAnnotation);
    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
    if (!contourSegmentationAnnotations.length) {
        return;
    }
    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
    const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);
    if (!targetAnnotationInfo) {
        return;
    }
    const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;
    if (isContourHole) {
        const { contourHoleProcessingEnabled = false } = evt.detail;
        if (!contourHoleProcessingEnabled) {
            return;
        }
        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
    }
    else {
        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
    }
}
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
    const toolName = 'PlanarFreehandContourSegmentationTool';
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
    let errorMessage;
    if (!toolGroup.hasTool(toolName)) {
        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
    }
    else if (!toolGroup.getToolOptions(toolName)) {
        errorMessage = `Tool ${toolName} must be in active/passive state`;
    }
    if (errorMessage && !silent) {
        console.warn(errorMessage);
    }
    return !errorMessage;
}
function getViewport(annotation) {
    const viewports = (0,_utilities_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(annotation);
    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
    return viewportWithToolRegistered ?? viewports[0];
}
function convertContourPolylineToCanvasSpace(polyline, viewport) {
    const numPoints = polyline.length;
    const projectedPolyline = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
    }
    return projectedPolyline;
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
    const allAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAllAnnotations)();
    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&
        targetAnnotation.annotationUID !== sourceAnnotationUID &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.isContourSegmentationAnnotation)(targetAnnotation) &&
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.areSameSegment)(targetAnnotation, sourceAnnotation) &&
        viewport.isReferenceViewable(targetAnnotation.metadata));
}
function findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {
    const sourceAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(sourcePolyline);
    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {
        const targetAnnotation = contourSegmentationAnnotations[i];
        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);
        const targetAABB = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.getAABB(targetPolyline);
        const aabbIntersect = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.aabb.intersectAABB(sourceAABB, targetAABB);
        const lineSegmentsIntersect = aabbIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.intersectPolyline(sourcePolyline, targetPolyline);
        const isContourHole = aabbIntersect &&
            !lineSegmentsIntersect &&
            _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(targetPolyline, sourcePolyline);
        if (lineSegmentsIntersect || isContourHole) {
            return { targetAnnotation, targetPolyline, isContourHole };
        }
    }
}
function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {
    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;
    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(targetAnnotation, holeAnnotation);
    (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.removeContourSegmentationAnnotation)(holeAnnotation);
    const { contour: holeContour } = holeAnnotation.data;
    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);
    (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(holeAnnotation, {
        points: holePolyline,
        closed: holeContour.closed,
    }, viewport);
    const { element } = viewport;
    const updatedToolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        holeAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedToolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIdsToRender);
    }
}
function getContourHolesData(viewport, annotation) {
    return (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getChildAnnotations)(annotation).map((holeAnnotation) => {
        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);
        return { annotation: holeAnnotation, polyline };
    });
}
function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {
    if (!(0,_store_addTool__WEBPACK_IMPORTED_MODULE_11__/* .hasToolByName */ .l$)(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {
        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);
        return;
    }
    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {
        return;
    }
    const sourceStartPoint = sourcePolyline[0];
    const mergePolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoint(targetPolyline, sourceStartPoint);
    const contourHolesData = getContourHolesData(viewport, targetAnnotation);
    const unassignedContourHolesSet = new Set(contourHolesData);
    const reassignedContourHolesMap = new Map();
    const assignHoleToPolyline = (parentPolyline, holeData) => {
        let holes = reassignedContourHolesMap.get(parentPolyline);
        if (!holes) {
            holes = [];
            reassignedContourHolesMap.set(parentPolyline, holes);
        }
        holes.push(holeData);
        unassignedContourHolesSet.delete(holeData);
    };
    const newPolylines = [];
    if (mergePolylines) {
        const mergedPolyline = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.mergePolylines(targetPolyline, sourcePolyline);
        newPolylines.push(mergedPolyline);
        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));
    }
    else {
        const subtractedPolylines = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.subtractPolylines(targetPolyline, sourcePolyline);
        subtractedPolylines.forEach((newPolyline) => {
            newPolylines.push(newPolyline);
            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {
                const containsHole = _utilities_math__WEBPACK_IMPORTED_MODULE_2__.polyline.containsPoints(newPolyline, holeData.polyline);
                if (containsHole) {
                    assignHoleToPolyline(newPolyline, holeData);
                    unassignedContourHolesSet.delete(holeData);
                }
            });
        });
    }
    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.clearParentAnnotation)(contourHoleData.annotation)));
    const { element } = viewport;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { metadata, data } = targetAnnotation;
    const { handles, segmentation } = data;
    const { textBox } = handles;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(sourceAnnotation.annotationUID);
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(targetAnnotation.annotationUID);
    for (let i = 0; i < newPolylines.length; i++) {
        const polyline = newPolylines[i];
        const startPoint = viewport.canvasToWorld(polyline[0]);
        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);
        const newAnnotation = {
            metadata: {
                ...metadata,
                toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,
                originalToolName: metadata.originalToolName || metadata.toolName,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [startPoint, endPoint],
                    textBox: textBox ? { ...textBox } : undefined,
                },
                contour: {
                    polyline: [],
                    closed: true,
                },
                spline: targetAnnotation.data.spline,
                segmentation: {
                    ...segmentation,
                },
            },
            annotationUID: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            highlighted: true,
            invalidated: true,
            isLocked: false,
            isVisible: undefined,
            interpolationUID: targetAnnotation.interpolationUID,
            interpolationCompleted: targetAnnotation.interpolationCompleted,
        };
        (0,_utilities_contours_updateContourPolyline__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(newAnnotation, {
            points: polyline,
            closed: true,
            targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_6__/* .ContourWindingDirection */ .W.Clockwise,
        }, viewport);
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(newAnnotation, element);
        (0,_utilities_contourSegmentation__WEBPACK_IMPORTED_MODULE_9__.addContourSegmentationAnnotation)(newAnnotation);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(newAnnotation, viewport.element);
        reassignedContourHolesMap
            .get(polyline)
            ?.forEach((holeData) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addChildAnnotation)(newAnnotation, holeData.annotation));
    }
    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);
}
function updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {
    const { viewport } = enabledElement;
    const { element } = viewport;
    const updatedTtoolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOL_NAME,
        targetAnnotation.metadata.toolName,
        sourceAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedTtoolNames.values()) {
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, toolName);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIdsToRender);
    }
    return new Promise((resolve) => window.requestAnimationFrame(resolve));
}


/***/ }),

/***/ 83638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  tQ: () => (/* reexport */ annotationCompletedListener),
  nm: () => (/* reexport */ annotations_annotationModifiedListener),
  Gg: () => (/* reexport */ annotationRemovedListener),
  ge: () => (/* reexport */ annotations_annotationSelectionListener),
  _9: () => (/* reexport */ imageChangeEventListener),
  kt: () => (/* reexport */ keyboard/* default */.A),
  bH: () => (/* reexport */ mouse),
  qI: () => (/* reexport */ segmentationDataModifiedEventListener),
  sp: () => (/* reexport */ segmentationModifiedEventListener),
  F_: () => (/* reexport */ touch),
  CG: () => (/* reexport */ wheel)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js
var mouseDoubleClickListener = __webpack_require__(91099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js
var mouseDownListener = __webpack_require__(68014);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js
var mouseMoveListener = __webpack_require__(41343);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js



function disable(element) {
    element.removeEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.removeEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.removeEventListener('mousemove', mouseMoveListener/* default */.A);
    element.removeEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
function enable(element) {
    disable(element);
    element.addEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.addEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.addEventListener('mousemove', mouseMoveListener/* default */.A);
    element.addEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
/* harmony default export */ const mouse = ({
    enable,
    disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js
var preventGhostClick = __webpack_require__(41666);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js + 1 modules
var touchStartListener = __webpack_require__(82603);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js


function touch_disable(element) {
    preventGhostClick/* default */.A.disable(element);
    element.removeEventListener('touchstart', touchStartListener/* default */.A);
}
function touch_enable(element) {
    touch_disable(element);
    preventGhostClick/* default */.A.enable(element);
    element.addEventListener('touchstart', touchStartListener/* default */.A, {
        passive: false,
    });
}
/* harmony default export */ const touch = ({
    enable: touch_enable,
    disable: touch_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js + 1 modules
var wheelListener = __webpack_require__(17806);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js

function wheel_enable(element) {
    wheel_disable(element);
    element.addEventListener('wheel', wheelListener/* default */.A, { passive: false });
}
function wheel_disable(element) {
    element.removeEventListener('wheel', wheelListener/* default */.A);
}
/* harmony default export */ const wheel = ({
    enable: wheel_enable,
    disable: wheel_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js
var keyboard = __webpack_require__(39595);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js

function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {
    const segmentationVolume = esm.cache.getVolume(representationData[type].volumeId);
    if (!segmentationVolume) {
        console.warn('segmentation not found in cache');
        return;
    }
    const { imageData, vtkOpenGLTexture } = segmentationVolume;
    let slicesToUpdate;
    if (modifiedSlicesToUse?.length > 0) {
        slicesToUpdate = modifiedSlicesToUse;
    }
    else {
        const numSlices = imageData.getDimensions()[2];
        slicesToUpdate = [...Array(numSlices).keys()];
    }
    slicesToUpdate.forEach((i) => {
        vtkOpenGLTexture.setUpdatedFrame(i);
    });
    imageData.modified();
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js
var getSegmentationActor = __webpack_require__(59452);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js





function performStackLabelmapUpdate({ viewportIds, segmentationId, }) {
    viewportIds.forEach((viewportId) => {
        let representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
            segmentationId,
        });
        representations = representations.filter((representation) => representation.type === enums.SegmentationRepresentations.Labelmap);
        representations.forEach((representation) => {
            if (representation.segmentationId !== segmentationId) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            if (viewport instanceof esm.VolumeViewport) {
                return;
            }
            const actorEntries = (0,getSegmentationActor/* getLabelmapActorEntries */.ED)(viewportId, segmentationId);
            if (!actorEntries?.length) {
                return;
            }
            actorEntries.forEach((actorEntry, i) => {
                const segImageData = actorEntry.actor.getMapper().getInputData();
                const currentSegmentationImageIds = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF)(viewportId, segmentationId);
                const segmentationImage = esm.cache.getImage(currentSegmentationImageIds[i]);
                segImageData.modified();
                esm.utilities.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);
            });
        });
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js






const onLabelmapSegmentationDataModified = function (evt) {
    const { segmentationId, modifiedSlicesToUse } = evt.detail;
    const { representationData } = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const viewportIds = (0,getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P)(segmentationId);
    const hasVolumeViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof esm.VolumeViewport;
    });
    const hasStackViewport = viewportIds.some((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        return viewport instanceof esm.StackViewport;
    });
    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;
    viewportIds.forEach((viewportId) => {
        const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (viewport instanceof esm.VolumeViewport) {
            performVolumeLabelmapUpdate({
                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,
                representationData,
                type: enums.SegmentationRepresentations.Labelmap,
            });
        }
        if (viewport instanceof esm.StackViewport) {
            performStackLabelmapUpdate({
                viewportIds,
                segmentationId,
            });
        }
    });
};
/* harmony default export */ const labelmap_onLabelmapSegmentationDataModified = (onLabelmapSegmentationDataModified);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js



const onSegmentationDataModified = function (evt) {
    const { segmentationId } = evt.detail;
    const { representationData } = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (representationData.Labelmap) {
        labelmap_onLabelmapSegmentationDataModified(evt);
    }
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(segmentationId);
};
/* harmony default export */ const segmentationDataModifiedEventListener = (onSegmentationDataModified);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js

const segmentationModifiedListener = function (evt) {
    const { segmentationId } = evt.detail;
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(segmentationId);
};
/* harmony default export */ const segmentationModifiedEventListener = (segmentationModifiedListener);

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js









const imageChangeEventListener_enable = function (element) {
    if (!element) {
        return;
    }
    const enabledElement = (0,esm.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    if (viewport instanceof esm.BaseVolumeViewport) {
        return;
    }
    element.addEventListener(esm.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.addEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const imageChangeEventListener_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);
    element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const perViewportManualTriggers = new Map();
function _imageChangeEventListener(evt) {
    const eventData = evt.detail;
    const { viewportId, renderingEngineId } = eventData;
    const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId);
    if (!representations?.length) {
        return;
    }
    const labelmapRepresentations = representations.filter((representation) => representation.type === enums.SegmentationRepresentations.Labelmap);
    const actors = viewport.getActors();
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        (0,updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)(viewportId, segmentationId);
    });
    const labelmapActors = labelmapRepresentations
        .flatMap((representation) => {
        return (0,getSegmentationActor/* getLabelmapActorEntries */.ED)(viewportId, representation.segmentationId);
    })
        .filter((actor) => actor !== undefined);
    if (!labelmapActors.length) {
        return;
    }
    labelmapActors.forEach((actor) => {
        const validActor = labelmapRepresentations.find((representation) => {
            const derivedImageIds = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF)(viewportId, representation.segmentationId);
            return derivedImageIds?.includes(actor.referencedId);
        });
        if (!validActor) {
            viewport.removeActors([actor.uid]);
        }
    });
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        const currentImageId = viewport.getCurrentImageId();
        const derivedImageIds = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF)(viewportId, segmentationId);
        if (!derivedImageIds) {
            return;
        }
        const updateSegmentationActor = (derivedImageId) => {
            const derivedImage = esm.cache.getImage(derivedImageId);
            if (!derivedImage) {
                console.warn('No derived image found in the cache for segmentation representation', representation);
                return;
            }
            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);
            if (!segmentationActorInput) {
                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
                const currentImage = esm.cache.getImage(currentImageId) ||
                    {
                        imageId: currentImageId,
                    };
                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
                const originToUse = currentOrigin;
                const constructor = derivedImage.voxelManager.getConstructor();
                const newPixelData = derivedImage.voxelManager.getScalarData();
                const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: new constructor(newPixelData),
                });
                const imageData = ImageData/* default.newInstance */.Ay.newInstance();
                imageData.setDimensions(dimensions[0], dimensions[1], 1);
                imageData.setSpacing(spacing);
                imageData.setDirection(direction);
                imageData.setOrigin(originToUse);
                imageData.getPointData().setScalars(scalarArray);
                imageData.modified();
                viewport.addImages([
                    {
                        imageId: derivedImageId,
                        representationUID: `${segmentationId}-${enums.SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,
                        callback: ({ imageActor }) => {
                            imageActor.getMapper().setInputData(imageData);
                        },
                    },
                ]);
                (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
                return;
            }
            else {
                const segmentationImageData = segmentationActorInput.actor
                    .getMapper()
                    .getInputData();
                if (segmentationImageData.setDerivedImage) {
                    segmentationImageData.setDerivedImage(derivedImage);
                }
                else {
                    esm.utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
                }
            }
        };
        derivedImageIds.forEach(updateSegmentationActor);
        viewport.render();
        if (evt.type === esm.Enums.Events.IMAGE_RENDERED) {
            viewport.element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
        }
    });
}
/* harmony default export */ const imageChangeEventListener = ({
    enable: imageChangeEventListener_enable,
    disable: imageChangeEventListener_disable,
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js
var contourSegmentation = __webpack_require__(64843);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js
var contourSegmentationCompleted = __webpack_require__(50986);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js

function contourSegmentationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    (0,contourSegmentation.removeContourSegmentationAnnotation)(annotation);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js


function annotationCompletedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegmentation.isContourSegmentationAnnotation(annotation)) {
        (0,contourSegmentationCompleted/* default */.A)(evt);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js


function annotationSelectionListener(evt) {
    const deselectedAnnotation = evt.detail.removed;
    if (!deselectedAnnotation.length) {
        return;
    }
    const renderingEngines = (0,esm.getRenderingEngines)();
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        (0,triggerAnnotationRenderForViewportIds/* triggerAnnotationRenderForViewportIds */.t)(viewportIds);
    });
}
/* harmony default export */ const annotations_annotationSelectionListener = (annotationSelectionListener);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js

function annotationModifiedListener(evt) {
    const { viewportId } = evt.detail;
    (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewportId]);
}
/* harmony default export */ const annotations_annotationModifiedListener = (annotationModifiedListener);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js


function annotationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegmentation.isContourSegmentationAnnotation(annotation)) {
        contourSegmentationRemovedListener(evt);
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js






;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js









/***/ }),

/***/ 44150:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24917);

const segmentationRepresentationModifiedListener = function (evt) {
    const { viewportId } = evt.detail;
    (0,_stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .triggerSegmentationRender */ .h6)(viewportId);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (segmentationRepresentationModifiedListener);


/***/ }),

/***/ 4667:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdvancedMagnifyTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.M$),
/* harmony export */   AngleTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.yT),
/* harmony export */   AnnotationDisplayTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.wh),
/* harmony export */   AnnotationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.EC),
/* harmony export */   ArrowAnnotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.ao),
/* harmony export */   BaseTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.oS),
/* harmony export */   BidirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Mu),
/* harmony export */   BrushTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.ls),
/* harmony export */   CONSTANTS: () => (/* reexport module object */ _constants__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   CircleROIStartEndThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.pq),
/* harmony export */   CircleROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Vl),
/* harmony export */   CircleScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.G2),
/* harmony export */   CobbAngleTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.EV),
/* harmony export */   CrosshairsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.ep),
/* harmony export */   DragProbeTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.j$),
/* harmony export */   ETDRSGridTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.nJ),
/* harmony export */   EllipticalROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.qD),
/* harmony export */   Enums: () => (/* reexport module object */ _enums__WEBPACK_IMPORTED_MODULE_14__),
/* harmony export */   EraserTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.dB),
/* harmony export */   HeightTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.m8),
/* harmony export */   KeyImageTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Np),
/* harmony export */   LabelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.hz),
/* harmony export */   LabelmapBaseTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.il),
/* harmony export */   LengthTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.LW),
/* harmony export */   LivewireContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Ix),
/* harmony export */   LivewireContourTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Ys),
/* harmony export */   MIPJumpToClickTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.uJ),
/* harmony export */   MagnifyTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.eh),
/* harmony export */   OrientationMarkerTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Xr),
/* harmony export */   OverlayGridTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Nk),
/* harmony export */   PaintFillTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Uj),
/* harmony export */   PanTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.CH),
/* harmony export */   PlanarFreehandContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.qi),
/* harmony export */   PlanarFreehandROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.ex),
/* harmony export */   PlanarRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.A5),
/* harmony export */   ProbeTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.N7),
/* harmony export */   RectangleROIStartEndThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.mX),
/* harmony export */   RectangleROIThresholdTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.TR),
/* harmony export */   RectangleROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.E0),
/* harmony export */   RectangleScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.td),
/* harmony export */   ReferenceCursors: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.xI),
/* harmony export */   ReferenceLinesTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.X8),
/* harmony export */   RegionSegmentPlusTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.sR),
/* harmony export */   RegionSegmentTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.wR),
/* harmony export */   ScaleOverlayTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.FE),
/* harmony export */   SculptorTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.N),
/* harmony export */   SegmentBidirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Fz),
/* harmony export */   SegmentLabelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.u9),
/* harmony export */   SegmentSelectTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.IX),
/* harmony export */   SegmentationIntersectionTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.cN),
/* harmony export */   SphereScissorsTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.zH),
/* harmony export */   SplineContourSegmentationTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.qT),
/* harmony export */   SplineROITool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.J2),
/* harmony export */   StackScrollTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.ae),
/* harmony export */   Synchronizer: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.Synchronizer),
/* harmony export */   SynchronizerManager: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.SynchronizerManager),
/* harmony export */   ToolGroupManager: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.ToolGroupManager),
/* harmony export */   TrackballRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.So),
/* harmony export */   Types: () => (/* reexport module object */ _types__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   UltrasoundDirectionalTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.oi),
/* harmony export */   VideoRedactionTool: () => (/* reexport safe */ _tools_annotation_VideoRedactionTool__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   VolumeRotateTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Oh),
/* harmony export */   WholeBodySegmentTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Tc),
/* harmony export */   WindowLevelRegionTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.TG),
/* harmony export */   WindowLevelTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.Du),
/* harmony export */   ZoomTool: () => (/* reexport safe */ _tools__WEBPACK_IMPORTED_MODULE_12__.OQ),
/* harmony export */   addTool: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.addTool),
/* harmony export */   annotation: () => (/* reexport module object */ _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   cancelActiveManipulations: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.cancelActiveManipulations),
/* harmony export */   cursors: () => (/* reexport module object */ _cursors__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   destroy: () => (/* reexport safe */ _init__WEBPACK_IMPORTED_MODULE_0__.zr),
/* harmony export */   drawing: () => (/* reexport module object */ _drawingSvg__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   init: () => (/* reexport safe */ _init__WEBPACK_IMPORTED_MODULE_0__.Ts),
/* harmony export */   removeTool: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.removeTool),
/* harmony export */   segmentation: () => (/* reexport module object */ _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_10__),
/* harmony export */   splines: () => (/* reexport module object */ _tools_annotation_splines__WEBPACK_IMPORTED_MODULE_11__),
/* harmony export */   state: () => (/* reexport safe */ _store_state__WEBPACK_IMPORTED_MODULE_2__.wk),
/* harmony export */   store: () => (/* reexport module object */ _store__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   synchronizers: () => (/* reexport module object */ _synchronizers__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   utilities: () => (/* reexport module object */ _utilities__WEBPACK_IMPORTED_MODULE_6__)
/* harmony export */ });
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64957);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6657);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85204);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47085);
/* harmony import */ var _synchronizers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34389);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(53860);
/* harmony import */ var _cursors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79475);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13369);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(47807);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(44595);
/* harmony import */ var _tools_annotation_splines__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3040);
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(49975);
/* harmony import */ var _tools_annotation_VideoRedactionTool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(11811);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(99737);



















/***/ }),

/***/ 64957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ts: () => (/* binding */ init),
/* harmony export */   zr: () => (/* binding */ destroy)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6657);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85204);
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(83638);
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3406);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77609);
/* harmony import */ var _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(59475);
/* harmony import */ var _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44150);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36625);











let csToolsInitialized = false;
function init(defaultConfiguration = {}) {
    if (csToolsInitialized) {
        return;
    }
    (0,_config__WEBPACK_IMPORTED_MODULE_10__/* .setConfig */ .Nk)(defaultConfiguration);
    _addCornerstoneEventListeners();
    _addCornerstoneToolsEventListeners();
    csToolsInitialized = true;
}
function destroy() {
    _removeCornerstoneEventListeners();
    _removeCornerstoneToolsEventListeners();
    _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__.destroy();
    (0,_store_state__WEBPACK_IMPORTED_MODULE_4__/* .resetCornerstoneToolsState */ .qh)();
    const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotationManager)();
    const segmentationStateManager = _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_8__/* .defaultSegmentationStateManager */ ._6;
    annotationManager.restoreAnnotations({});
    segmentationStateManager.resetState();
    csToolsInitialized = false;
}
function _addCornerstoneEventListeners() {
    _removeCornerstoneEventListeners();
    const elementEnabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(elementEnabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.addEnabledElement);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(elementDisabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.removeEnabledElement);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__/* .annotationInterpolationEventDispatcher */ .dj.enable();
}
function _removeCornerstoneEventListeners() {
    const elementEnabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED;
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(elementEnabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.addEnabledElement);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(elementDisabledEvent, _store__WEBPACK_IMPORTED_MODULE_3__.removeEnabledElement);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_6__/* .annotationInterpolationEventDispatcher */ .dj.disable();
}
function _addCornerstoneToolsEventListeners() {
    _removeCornerstoneToolsEventListeners();
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_COMPLETED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationCompletedListener */ .tQ);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationModifiedListener */ .nm);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationSelectionListener */ .ge);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationSelectionListener */ .ge);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_REMOVED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationRemovedListener */ .Gg);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .segmentationModifiedListener */ .sp);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_DATA_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .segmentationDataModifiedEventListener */ .qI);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_MODIFIED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_ADDED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
}
function _removeCornerstoneToolsEventListeners() {
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_COMPLETED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationCompletedListener */ .tQ);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationModifiedListener */ .nm);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationSelectionListener */ .ge);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.ANNOTATION_SELECTION_CHANGE, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .annotationSelectionListener */ .ge);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .segmentationModifiedListener */ .sp);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_DATA_MODIFIED, _eventListeners__WEBPACK_IMPORTED_MODULE_5__/* .segmentationDataModifiedEventListener */ .qI);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_MODIFIED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.SEGMENTATION_REPRESENTATION_ADDED, _eventListeners_segmentation_segmentationRepresentationModifiedListener__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (init)));


/***/ }),

/***/ 39011:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ annotationRenderingEngine)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17328);
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39848);




const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
class AnnotationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            const elements = Array.from(this._viewportElements.values());
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                if (this._needsRender.has(element)) {
                    this._triggerRender(element);
                    this._needsRender.delete(element);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            this._render();
        };
        this._viewportElements = new Map();
    }
    addViewportElement(viewportId, element) {
        this._viewportElements.set(viewportId, element);
    }
    removeViewportElement(viewportId, element) {
        this._viewportElements.delete(viewportId);
        this._needsRender.delete(element);
        this._reset();
    }
    renderViewport(element) {
        this._setViewportsToBeRenderedNextFrame([element]);
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setAllViewportsToBeRenderedNextFrame() {
        const elements = [...this._viewportElements.values()];
        elements.forEach((element) => {
            this._needsRender.add(element);
        });
        this._renderFlaggedViewports();
    }
    _setViewportsToBeRenderedNextFrame(elements) {
        const elementsEnabled = [...this._viewportElements.values()];
        elements.forEach((element) => {
            if (elementsEnabled.indexOf(element) !== -1) {
                this._needsRender.add(element);
            }
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(enabledElement.renderingEngineId);
        if (!renderingEngine) {
            console.warn('rendering Engine has been destroyed');
            return;
        }
        const enabledTools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element, [
            Active,
            Passive,
            Enabled,
        ]);
        const { renderingEngineId, viewportId } = enabledElement;
        const eventDetail = {
            element,
            renderingEngineId,
            viewportId,
        };
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.draw)(element, (svgDrawingHelper) => {
            let anyRendered = false;
            const handleDrawSvg = (tool) => {
                if (tool.renderAnnotation) {
                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
                    anyRendered = anyRendered || rendered;
                }
            };
            enabledTools.forEach(handleDrawSvg);
            if (anyRendered) {
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_RENDERED, { ...eventDetail });
            }
        });
    }
    _reset() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._setAllViewportsToBeRenderedNextFrame();
    }
}
const annotationRenderingEngine = new AnnotationRenderingEngine();



/***/ }),

/***/ 67013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   H: () => (/* binding */ defaultFrameOfReferenceSpecificAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

class FrameOfReferenceSpecificAnnotationManager {
    constructor(uid) {
        this.getGroupKey = (annotationGroupSelector) => {
            if (typeof annotationGroupSelector === 'string') {
                return annotationGroupSelector;
            }
            const element = annotationGroupSelector;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');
            }
            return enabledElement.FrameOfReferenceUID;
        };
        this._imageVolumeModifiedHandler = (evt) => {
            const eventDetail = evt.detail;
            const { FrameOfReferenceUID } = eventDetail;
            const annotations = this.annotations;
            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
            if (!frameOfReferenceSpecificAnnotations) {
                return;
            }
            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                toolSpecificAnnotations.forEach((annotation) => {
                    const invalidated = annotation.invalidated;
                    if (invalidated !== undefined) {
                        annotation.invalidated = true;
                    }
                });
            });
        };
        this.getFramesOfReference = () => {
            return Object.keys(this.annotations);
        };
        this.getAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (!annotations[groupKey]) {
                return [];
            }
            if (toolName) {
                return annotations[groupKey][toolName]
                    ? annotations[groupKey][toolName]
                    : [];
            }
            return annotations[groupKey];
        };
        this.getAnnotation = (annotationUID) => {
            const annotations = this.annotations;
            for (const frameOfReferenceUID in annotations) {
                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];
                for (const toolName in frameOfReferenceAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];
                    for (const annotation of toolSpecificAnnotations) {
                        if (annotationUID === annotation.annotationUID) {
                            return annotation;
                        }
                    }
                }
            }
        };
        this.getNumberOfAnnotations = (groupKey, toolName) => {
            const annotations = this.getAnnotations(groupKey, toolName);
            if (!annotations.length) {
                return 0;
            }
            if (toolName) {
                return annotations.length;
            }
            let total = 0;
            for (const toolName in annotations) {
                total += annotations[toolName].length;
            }
            return total;
        };
        this.addAnnotation = (annotation, groupKey) => {
            const { metadata } = annotation;
            const { FrameOfReferenceUID, toolName } = metadata;
            groupKey = groupKey || FrameOfReferenceUID;
            const annotations = this.annotations;
            let frameOfReferenceSpecificAnnotations = annotations[groupKey];
            if (!frameOfReferenceSpecificAnnotations) {
                annotations[groupKey] = {};
                frameOfReferenceSpecificAnnotations = annotations[groupKey];
            }
            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            if (!toolSpecificAnnotations) {
                frameOfReferenceSpecificAnnotations[toolName] = [];
                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            }
            if (this.preprocessingFn) {
                annotation = this.preprocessingFn(annotation);
            }
            toolSpecificAnnotations.push(annotation);
        };
        this.removeAnnotation = (annotationUID) => {
            const { annotations } = this;
            for (const groupKey in annotations) {
                const groupAnnotations = annotations[groupKey];
                for (const toolName in groupAnnotations) {
                    const toolAnnotations = groupAnnotations[toolName];
                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
                    if (index !== -1) {
                        toolAnnotations.splice(index, 1);
                        if (toolAnnotations.length === 0) {
                            delete groupAnnotations[toolName];
                        }
                    }
                }
                if (Object.keys(groupAnnotations).length === 0) {
                    delete annotations[groupKey];
                }
            }
        };
        this.removeAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            const removedAnnotations = [];
            if (!annotations[groupKey]) {
                return removedAnnotations;
            }
            if (toolName) {
                const annotationsForTool = annotations[groupKey][toolName];
                for (const annotation of annotationsForTool) {
                    this.removeAnnotation(annotation.annotationUID);
                    removedAnnotations.push(annotation);
                }
            }
            else {
                for (const toolName in annotations[groupKey]) {
                    const annotationsForTool = annotations[groupKey][toolName];
                    for (const annotation of annotationsForTool) {
                        this.removeAnnotation(annotation.annotationUID);
                        removedAnnotations.push(annotation);
                    }
                }
            }
            return removedAnnotations;
        };
        this.saveAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    return;
                }
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                return structuredClone(toolSpecificAnnotations);
            }
            else if (groupKey) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                return structuredClone(frameOfReferenceSpecificAnnotations);
            }
            return structuredClone(annotations);
        };
        this.restoreAnnotations = (state, groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                let frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    annotations[groupKey] = {};
                    frameOfReferenceSpecificAnnotations = annotations[groupKey];
                }
                frameOfReferenceSpecificAnnotations[toolName] = state;
            }
            else if (groupKey) {
                annotations[groupKey] = state;
            }
            else {
                this.annotations = structuredClone(state);
            }
        };
        this.getAllAnnotations = () => {
            return Object.values(this.annotations)
                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))
                .flat(2);
        };
        this.getNumberOfAllAnnotations = () => {
            let count = 0;
            const annotations = this.annotations;
            for (const groupKey in annotations) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                for (const toolName in frameOfReferenceSpecificAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                    count += toolSpecificAnnotations.length;
                }
            }
            return count;
        };
        this.removeAllAnnotations = () => {
            const removedAnnotations = [];
            for (const annotation of this.getAllAnnotations()) {
                this.removeAnnotation(annotation.annotationUID);
                removedAnnotations.push(annotation);
            }
            return removedAnnotations;
        };
        if (!uid) {
            uid = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        }
        this.annotations = {};
        this.uid = uid;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
    }
    setPreprocessingFn(preprocessingFn) {
        this.preprocessingFn = preprocessingFn;
    }
}
const defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrameOfReferenceSpecificAnnotationManager);


/***/ }),

/***/ 2076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationLocked: () => (/* binding */ checkAndSetAnnotationLocked),
/* harmony export */   getAnnotationsLocked: () => (/* binding */ getAnnotationsLocked),
/* harmony export */   getAnnotationsLockedCount: () => (/* binding */ getAnnotationsLockedCount),
/* harmony export */   isAnnotationLocked: () => (/* binding */ isAnnotationLocked),
/* harmony export */   setAnnotationLocked: () => (/* binding */ setAnnotationLocked),
/* harmony export */   unlockAllAnnotations: () => (/* binding */ unlockAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



const globalLockedAnnotationUIDsSet = new Set();
function setAnnotationLocked(annotationUID, locked = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (locked) {
            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
        else {
            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
    }
    publish(detail, globalLockedAnnotationUIDsSet);
}
function unlockAllAnnotations() {
    const detail = makeEventDetail();
    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);
    publish(detail, globalLockedAnnotationUIDsSet);
}
function getAnnotationsLocked() {
    return Array.from(globalLockedAnnotationUIDsSet);
}
function isAnnotationLocked(annotationUID) {
    return globalLockedAnnotationUIDsSet.has(annotationUID);
}
function getAnnotationsLockedCount() {
    return globalLockedAnnotationUIDsSet.size;
}
function checkAndSetAnnotationLocked(annotationUID) {
    const isLocked = isAnnotationLocked(annotationUID);
    setAnnotationLocked(annotationUID, isLocked);
    return isLocked;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        locked: [],
    });
}
function lock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (!lockedAnnotationUIDsSet.has(annotationUID)) {
        lockedAnnotationUIDsSet.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = true;
        }
    }
}
function unlock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (lockedAnnotationUIDsSet.delete(annotationUID)) {
        detail.removed.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = false;
        }
    }
}
function clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {
    lockedAnnotationUIDsSet.forEach((annotationUID) => {
        unlock(annotationUID, lockedAnnotationUIDsSet, detail);
    });
}
function publish(detail, lockedAnnotationUIDsSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_LOCK_CHANGE, detail);
    }
}



/***/ }),

/***/ 17343:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deselectAnnotation: () => (/* binding */ deselectAnnotation),
/* harmony export */   getAnnotationsSelected: () => (/* binding */ getAnnotationsSelected),
/* harmony export */   getAnnotationsSelectedByToolName: () => (/* binding */ getAnnotationsSelectedByToolName),
/* harmony export */   getAnnotationsSelectedCount: () => (/* binding */ getAnnotationsSelectedCount),
/* harmony export */   isAnnotationSelected: () => (/* binding */ isAnnotationSelected),
/* harmony export */   setAnnotationSelected: () => (/* binding */ setAnnotationSelected)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



const selectedAnnotationUIDs = new Set();
function setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {
    if (selected) {
        selectAnnotation(annotationUID, preserveSelected);
    }
    else {
        deselectAnnotation(annotationUID);
    }
}
function selectAnnotation(annotationUID, preserveSelected = false) {
    const detail = makeEventDetail();
    if (!preserveSelected) {
        clearSelectionSet(selectedAnnotationUIDs, detail);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {
        selectedAnnotationUIDs.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    publish(detail, selectedAnnotationUIDs);
}
function deselectAnnotation(annotationUID) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (selectedAnnotationUIDs.delete(annotationUID)) {
            detail.removed.push(annotationUID);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
            annotation.isSelected = false;
        }
    }
    else {
        clearSelectionSet(selectedAnnotationUIDs, detail);
    }
    publish(detail, selectedAnnotationUIDs);
}
function getAnnotationsSelected() {
    return Array.from(selectedAnnotationUIDs);
}
function getAnnotationsSelectedByToolName(toolName) {
    return getAnnotationsSelected().filter((annotationUID) => {
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        return annotation?.metadata?.toolName === toolName;
    });
}
function isAnnotationSelected(annotationUID) {
    return selectedAnnotationUIDs.has(annotationUID);
}
function getAnnotationsSelectedCount() {
    return selectedAnnotationUIDs.size;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        selection: [],
    });
}
function clearSelectionSet(selectionSet, detail) {
    selectionSet.forEach((value) => {
        if (selectionSet.delete(value)) {
            detail.removed.push(value);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(value);
            if (annotation) {
                annotation.isSelected = false;
            }
        }
    });
}
function publish(detail, selectionSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        selectionSet.forEach((item) => void detail.selection.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_SELECTION_CHANGE, detail);
    }
}



/***/ }),

/***/ 82056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAnnotation: () => (/* binding */ addAnnotation),
/* harmony export */   addChildAnnotation: () => (/* binding */ addChildAnnotation),
/* harmony export */   clearParentAnnotation: () => (/* binding */ clearParentAnnotation),
/* harmony export */   getAllAnnotations: () => (/* binding */ getAllAnnotations),
/* harmony export */   getAnnotation: () => (/* binding */ getAnnotation),
/* harmony export */   getAnnotationManager: () => (/* binding */ getAnnotationManager),
/* harmony export */   getAnnotations: () => (/* binding */ getAnnotations),
/* harmony export */   getChildAnnotations: () => (/* binding */ getChildAnnotations),
/* harmony export */   getNumberOfAnnotations: () => (/* binding */ getNumberOfAnnotations),
/* harmony export */   getParentAnnotation: () => (/* binding */ getParentAnnotation),
/* harmony export */   invalidateAnnotation: () => (/* binding */ invalidateAnnotation),
/* harmony export */   removeAllAnnotations: () => (/* binding */ removeAllAnnotations),
/* harmony export */   removeAnnotation: () => (/* binding */ removeAnnotation),
/* harmony export */   removeAnnotations: () => (/* binding */ removeAnnotations),
/* harmony export */   setAnnotationManager: () => (/* binding */ setAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _helpers_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44049);


let defaultManager;
function getAnnotationManager() {
    return defaultManager;
}
function setAnnotationManager(annotationManager) {
    defaultManager = annotationManager;
}
function getAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getAnnotations(groupKey, toolName);
}
function getAnnotation(annotationUID) {
    const manager = getAnnotationManager();
    return manager.getAnnotation(annotationUID);
}
function getAllAnnotations() {
    const manager = getAnnotationManager();
    return manager.getAllAnnotations();
}
function clearParentAnnotation(annotation) {
    const { annotationUID: childUID, parentAnnotationUID } = annotation;
    if (!parentAnnotationUID) {
        return;
    }
    const parentAnnotation = getAnnotation(parentAnnotationUID);
    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);
    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);
    annotation.parentAnnotationUID = undefined;
}
function addChildAnnotation(parentAnnotation, childAnnotation) {
    const { annotationUID: parentUID } = parentAnnotation;
    const { annotationUID: childUID } = childAnnotation;
    clearParentAnnotation(childAnnotation);
    if (!parentAnnotation.childAnnotationUIDs) {
        parentAnnotation.childAnnotationUIDs = [];
    }
    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {
        return;
    }
    parentAnnotation.childAnnotationUIDs.push(childUID);
    childAnnotation.parentAnnotationUID = parentUID;
}
function getParentAnnotation(annotation) {
    return annotation.parentAnnotationUID
        ? getAnnotation(annotation.parentAnnotationUID)
        : undefined;
}
function getChildAnnotations(annotation) {
    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);
}
function addAnnotation(annotation, annotationGroupSelector) {
    if (!annotation.annotationUID) {
        annotation.annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    }
    const manager = getAnnotationManager();
    if (annotationGroupSelector instanceof HTMLDivElement) {
        const groupKey = manager.getGroupKey(annotationGroupSelector);
        manager.addAnnotation(annotation, groupKey);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForElement)(annotation, annotationGroupSelector);
    }
    else {
        manager.addAnnotation(annotation, undefined);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForFOR)(annotation);
    }
    return annotation.annotationUID;
}
function getNumberOfAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getNumberOfAnnotations(groupKey, toolName);
}
function removeAnnotation(annotationUID) {
    if (!annotationUID) {
        return;
    }
    const manager = getAnnotationManager();
    const annotation = manager.getAnnotation(annotationUID);
    if (!annotation) {
        return;
    }
    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));
    manager.removeAnnotation(annotationUID);
    (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({ annotation, annotationManagerUID: manager.uid });
}
function removeAllAnnotations() {
    const manager = getAnnotationManager();
    const removedAnnotations = manager.removeAllAnnotations();
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function removeAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function invalidateAnnotation(annotation) {
    let currAnnotation = annotation;
    while (currAnnotation) {
        currAnnotation.invalidated = true;
        currAnnotation = currAnnotation.parentAnnotationUID
            ? getAnnotation(currAnnotation.parentAnnotationUID)
            : undefined;
    }
}



/***/ }),

/***/ 29601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationVisibility: () => (/* binding */ checkAndSetAnnotationVisibility),
/* harmony export */   isAnnotationVisible: () => (/* binding */ isAnnotationVisible),
/* harmony export */   setAnnotationVisibility: () => (/* binding */ setAnnotationVisibility),
/* harmony export */   showAllAnnotations: () => (/* binding */ showAllAnnotations)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17343);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);




const globalHiddenAnnotationUIDsSet = new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (visible) {
            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
        else {
            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
    }
    publish(detail);
}
function showAllAnnotations() {
    const detail = makeEventDetail();
    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {
        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    });
    publish(detail);
}
function isAnnotationVisible(annotationUID) {
    const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
    if (annotation) {
        return !globalHiddenAnnotationUIDsSet.has(annotationUID);
    }
}
function makeEventDetail() {
    return Object.freeze({
        lastVisible: [],
        lastHidden: [],
        hidden: [],
    });
}
function show(annotationUID, annotationUIDsSet, detail) {
    if (annotationUIDsSet.delete(annotationUID)) {
        detail.lastVisible.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
        annotation.isVisible = true;
    }
}
function hide(annotationUID, annotationUIDsSet, detail) {
    if (!annotationUIDsSet.has(annotationUID)) {
        annotationUIDsSet.add(annotationUID);
        if ((0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.deselectAnnotation)(annotationUID);
        }
        detail.lastHidden.push(annotationUID);
    }
}
function publish(detail) {
    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_VISIBILITY_CHANGE, detail);
    }
}
function checkAndSetAnnotationVisibility(annotationUID) {
    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);
    setAnnotationVisibility(annotationUID, isVisible);
    return isVisible;
}



/***/ }),

/***/ 8710:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class ToolStyle {
    constructor() {
        const defaultConfig = {
            color: 'rgb(255, 255, 0)',
            colorHighlighted: 'rgb(0, 255, 0)',
            colorSelected: 'rgb(0, 220, 0)',
            colorLocked: 'rgb(209, 193, 90)',
            lineWidth: '1',
            lineDash: '',
            shadow: true,
            textBoxVisibility: true,
            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            textBoxFontSize: '14px',
            textBoxColor: 'rgb(255, 255, 0)',
            textBoxColorHighlighted: 'rgb(0, 255, 0)',
            textBoxColorSelected: 'rgb(0, 255, 0)',
            textBoxColorLocked: 'rgb(209, 193, 90)',
            textBoxBackground: '',
            textBoxLinkLineWidth: '1',
            textBoxLinkLineDash: '2,3',
            textBoxShadow: true,
            markerSize: '10',
            angleArcLineDash: '',
        };
        this._initializeConfig(defaultConfig);
    }
    getAnnotationToolStyles(annotationUID) {
        return this.config.annotations && this.config.annotations[annotationUID];
    }
    getViewportToolStyles(viewportId) {
        return this.config.viewports && this.config.viewports[viewportId];
    }
    getToolGroupToolStyles(toolGroupId) {
        return this.config.toolGroups && this.config.toolGroups[toolGroupId];
    }
    getDefaultToolStyles() {
        return this.config.default;
    }
    setAnnotationStyles(annotationUID, styles) {
        let annotationSpecificStyles = this.config.annotations;
        if (!annotationSpecificStyles) {
            this.config = {
                ...this.config,
                annotations: {},
            };
            annotationSpecificStyles = this.config.annotations;
        }
        annotationSpecificStyles[annotationUID] = styles;
    }
    setViewportToolStyles(viewportId, styles) {
        let viewportSpecificStyles = this.config.viewports;
        if (!viewportSpecificStyles) {
            this.config = {
                ...this.config,
                viewports: {},
            };
            viewportSpecificStyles = this.config.viewports;
        }
        viewportSpecificStyles[viewportId] = styles;
    }
    setToolGroupToolStyles(toolGroupId, styles) {
        let toolGroupSpecificStyles = this.config.toolGroups;
        if (!toolGroupSpecificStyles) {
            this.config = {
                ...this.config,
                toolGroups: {},
            };
            toolGroupSpecificStyles = this.config.toolGroups;
        }
        toolGroupSpecificStyles[toolGroupId] = styles;
    }
    setDefaultToolStyles(styles) {
        this.config.default = styles;
    }
    getStyleProperty(toolStyle, specifications) {
        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);
    }
    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
        if (annotationUID) {
            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);
            if (annotationToolStyles) {
                if (annotationToolStyles[property] !== undefined) {
                    return annotationToolStyles[property];
                }
            }
        }
        if (viewportId) {
            const viewportToolStyles = this.getViewportToolStyles(viewportId);
            if (viewportToolStyles) {
                if (viewportToolStyles[toolName] &&
                    viewportToolStyles[toolName][property] !== undefined) {
                    return viewportToolStyles[toolName][property];
                }
                if (viewportToolStyles.global &&
                    viewportToolStyles.global[property] !== undefined) {
                    return viewportToolStyles.global[property];
                }
            }
        }
        if (toolGroupId) {
            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);
            if (toolGroupToolStyles) {
                if (toolGroupToolStyles[toolName] &&
                    toolGroupToolStyles[toolName][property] !== undefined) {
                    return toolGroupToolStyles[toolName][property];
                }
                if (toolGroupToolStyles.global &&
                    toolGroupToolStyles.global[property] !== undefined) {
                    return toolGroupToolStyles.global[property];
                }
            }
        }
        const globalStyles = this.getDefaultToolStyles();
        if (globalStyles[toolName] &&
            globalStyles[toolName][property] !== undefined) {
            return globalStyles[toolName][property];
        }
        if (globalStyles.global && globalStyles.global[property] !== undefined) {
            return globalStyles.global[property];
        }
    }
    _initializeConfig(config) {
        const toolStyles = {};
        for (const name in config) {
            toolStyles[name] = config[name];
        }
        this.config = {
            default: {
                global: toolStyles,
            },
        };
    }
}
const toolStyle = new ToolStyle();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toolStyle);


/***/ }),

/***/ 76712:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ getStyleProperty)
/* harmony export */ });
/* harmony import */ var _ToolStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8710);

function getHierarchalPropertyStyles(property, state, mode) {
    const list = [`${property}`];
    if (state) {
        list.push(`${list[0]}${state}`);
    }
    if (mode) {
        list.push(`${list[list.length - 1]}${mode}`);
    }
    return list;
}
function getStyleProperty(property, styleSpecifier, state, mode) {
    const alternatives = getHierarchalPropertyStyles(property, state, mode);
    for (let i = alternatives.length - 1; i >= 0; --i) {
        const style = _ToolStyle__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getStyleProperty(alternatives[i], styleSpecifier);
        if (style !== undefined) {
            return style;
        }
    }
}



/***/ }),

/***/ 49310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getFont: () => (/* reexport */ config_getFont),
  getState: () => (/* reexport */ config_getState),
  style: () => (/* reexport */ ToolStyle/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js



function getState(annotation) {
    if (annotation) {
        if (annotation.data && annotation.highlighted) {
            return enums.AnnotationStyleStates.Highlighted;
        }
        if ((0,annotationSelection.isAnnotationSelected)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Selected;
        }
        if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Locked;
        }
        if (annotation.data && annotation.autoGenerated) {
            return enums.AnnotationStyleStates.AutoGenerated;
        }
    }
    return enums.AnnotationStyleStates.Default;
}
/* harmony default export */ const config_getState = (getState);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js

function getFont(styleSpecifier, state, mode) {
    const fontSize = (0,helpers/* getStyleProperty */.h)('textBoxFontSize', styleSpecifier, state, mode);
    const fontFamily = (0,helpers/* getStyleProperty */.h)('textBoxFontFamily', styleSpecifier, state, mode);
    return `${fontSize}px ${fontFamily}`;
}
/* harmony default export */ const config_getFont = (getFont);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js
var ToolStyle = __webpack_require__(8710);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js






/***/ }),

/***/ 44049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerAnnotationAddedForElement: () => (/* binding */ triggerAnnotationAddedForElement),
/* harmony export */   triggerAnnotationAddedForFOR: () => (/* binding */ triggerAnnotationAddedForFOR),
/* harmony export */   triggerAnnotationCompleted: () => (/* binding */ triggerAnnotationCompleted),
/* harmony export */   triggerAnnotationModified: () => (/* binding */ triggerAnnotationModified),
/* harmony export */   triggerAnnotationRemoved: () => (/* binding */ triggerAnnotationRemoved),
/* harmony export */   triggerContourAnnotationCompleted: () => (/* binding */ triggerContourAnnotationCompleted)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77609);



function triggerAnnotationAddedForElement(annotation, element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, viewportId } = enabledElement;
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId: renderingEngine.id,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationAddedForFOR(annotation) {
    const { toolName } = annotation.metadata;
    const toolGroups = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupsWithToolName)(toolName);
    if (!toolGroups.length) {
        return;
    }
    const viewportsToRender = [];
    toolGroups.forEach((toolGroup) => {
        toolGroup.viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const { FrameOfReferenceUID } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
                viewportsToRender.push(viewportInfo);
            }
        });
    });
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = { annotation };
    if (!viewportsToRender.length) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        return;
    }
    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
        eventDetail.viewportId = viewportId;
        eventDetail.renderingEngineId = renderingEngineId;
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
    });
}
function triggerAnnotationRemoved(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_REMOVED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationModified(annotation, element, changeType = _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated) {
    const enabledElement = element && (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement || {};
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_MODIFIED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationCompleted(annotation) {
    const eventDetail = {
        annotation,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
    const eventDetail = {
        annotation,
        contourHoleProcessingEnabled,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function _triggerAnnotationCompleted(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_COMPLETED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}



/***/ }),

/***/ 47807:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationGroup: () => (/* reexport */ AnnotationGroup),
  FrameOfReferenceSpecificAnnotationManager: () => (/* reexport */ FrameOfReferenceSpecificAnnotationManager/* default */.A),
  config: () => (/* reexport */ config),
  locking: () => (/* reexport */ annotationLocking),
  selection: () => (/* reexport */ annotationSelection),
  state: () => (/* binding */ annotation_state),
  visibility: () => (/* reexport */ annotationVisibility)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js + 2 modules
var config = __webpack_require__(49310);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
var state = __webpack_require__(44049);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility = __webpack_require__(29601);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js
var FrameOfReferenceSpecificAnnotationManager = __webpack_require__(67013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js



class AnnotationGroup {
    constructor() {
        this.annotationUIDs = new Set();
        this._isVisible = true;
        this.visibleFilter = this.unboundVisibleFilter.bind(this);
    }
    unboundVisibleFilter(uid) {
        return !this._isVisible || !this.annotationUIDs.has(uid);
    }
    has(uid) {
        return this.annotationUIDs.has(uid);
    }
    setVisible(isVisible = true, baseEvent, filter) {
        if (this._isVisible === isVisible) {
            return;
        }
        this._isVisible = isVisible;
        this.annotationUIDs.forEach((uid) => {
            const annotation = (0,annotationState.getAnnotation)(uid);
            if (!annotation) {
                this.annotationUIDs.delete(uid);
                return;
            }
            if (annotation.isVisible === isVisible) {
                return;
            }
            if (!isVisible && filter?.(uid) === false) {
                return;
            }
            annotation.isVisible = isVisible;
            const eventDetail = {
                ...baseEvent,
                annotation,
            };
            (0,esm.triggerEvent)(esm.eventTarget, Events/* default */.A.ANNOTATION_MODIFIED, eventDetail);
        });
    }
    get isVisible() {
        return this._isVisible;
    }
    findNearby(uid, direction) {
        const uids = [...this.annotationUIDs];
        if (uids.length === 0) {
            return null;
        }
        if (!uid) {
            return uids[direction === 1 ? 0 : uids.length - 1];
        }
        const index = uids.indexOf(uid);
        if (index === -1 ||
            index + direction < 0 ||
            index + direction >= uids.length) {
            return null;
        }
        return uids[index + direction];
    }
    add(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));
    }
    remove(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));
    }
    clear() {
        this.annotationUIDs.clear();
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js + 1 modules
var resetAnnotationManager = __webpack_require__(97);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js









const annotation_state = {
    ...annotationState,
    ...state,
    resetAnnotationManager: resetAnnotationManager/* resetAnnotationManager */.c,
};



/***/ }),

/***/ 24917:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fy: () => (/* binding */ triggerSegmentationRenderBySegmentationId),
/* harmony export */   h6: () => (/* binding */ triggerSegmentationRender)
/* harmony export */ });
/* unused harmony export segmentationRenderingEngine */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18682);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93210);
/* harmony import */ var _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67014);
/* harmony import */ var _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25894);
/* harmony import */ var _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(684);
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68040);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85204);
/* harmony import */ var _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(37590);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77609);











const renderers = {
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Labelmap]: _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Contour]: _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Surface]: _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay,
};
const planarContourToolName = _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.toolName;
class SegmentationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._getAllViewports = () => {
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)();
            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());
        };
        this._renderFlaggedSegmentations = () => {
            this._throwIfDestroyed();
            const viewportIds = Array.from(this._needsRender);
            viewportIds.forEach((viewportId) => {
                this._triggerRender(viewportId);
            });
            this._needsRender.clear();
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
        };
    }
    renderSegmentationsForViewport(viewportId) {
        const viewportIds = viewportId
            ? [viewportId]
            : this._getViewportIdsForSegmentation();
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderSegmentation(segmentationId) {
        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    _getViewportIdsForSegmentation(segmentationId) {
        const viewports = this._getAllViewports();
        const viewportIds = [];
        for (const viewport of viewports) {
            const viewportId = viewport.id;
            if (segmentationId) {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
            else {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
        }
        return viewportIds;
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(viewportId) {
        const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
        if (!segmentationRepresentations?.length) {
            return;
        }
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId) || {};
        if (!viewport) {
            return;
        }
        const viewportRenderList = [];
        const segmentationRenderList = segmentationRepresentations.map((representation) => {
            if (representation.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour) {
                this._addPlanarFreeHandToolIfAbsent(viewport);
            }
            const display = renderers[representation.type];
            try {
                const viewportId = display.render(viewport, representation);
                viewportRenderList.push(viewportId);
            }
            catch (error) {
                console.error(error);
            }
            return Promise.resolve({
                segmentationId: representation.segmentationId,
                type: representation.type,
            });
        });
        Promise.allSettled(segmentationRenderList).then((results) => {
            const segmentationDetails = results
                .filter((r) => r.status === 'fulfilled')
                .map((r) => r.value);
            function onSegmentationRender(evt) {
                const { element, viewportId } = evt.detail;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
                segmentationDetails.forEach((detail) => {
                    const eventDetail = {
                        viewportId,
                        segmentationId: detail.segmentationId,
                        type: detail.type,
                    };
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_RENDERED, {
                        ...eventDetail,
                    });
                });
            }
            const element = viewport.element;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
            viewport.render();
        });
    }
    _addPlanarFreeHandToolIfAbsent(viewport) {
        if (!(planarContourToolName in _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.tools)) {
            (0,_store_addTool__WEBPACK_IMPORTED_MODULE_7__/* .addTool */ .Gx)(_tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
        }
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id);
        if (!toolGroup.hasTool(planarContourToolName)) {
            toolGroup.addTool(planarContourToolName);
            toolGroup.setToolPassive(planarContourToolName);
        }
    }
}
function triggerSegmentationRender(viewportId) {
    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);
}
function triggerSegmentationRenderBySegmentationId(segmentationId) {
    segmentationRenderingEngine.renderSegmentation(segmentationId);
}
const segmentationRenderingEngine = new SegmentationRenderingEngine();



/***/ }),

/***/ 59475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zm: () => (/* binding */ internalComputeVolumeLabelmapFromStack),
/* harmony export */   _6: () => (/* binding */ defaultSegmentationStateManager),
/* harmony export */   cC: () => (/* binding */ internalConvertStackToVolumeLabelmap)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99341);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92686);
/* harmony import */ var _events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75419);







const initialDefaultState = {
    colorLUT: [],
    segmentations: [],
    viewportSegRepresentations: {},
};
class SegmentationStateManager {
    constructor(uid) {
        this._stackLabelmapImageIdReferenceMap = new Map();
        this._labelmapImageIdReferenceMap = new Map();
        uid ||= _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
        this.uid = uid;
    }
    getState() {
        return this.state;
    }
    updateState(updater) {
        const newState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(this.state);
        updater(newState);
        this.state = Object.freeze(newState);
    }
    getColorLUT(lutIndex) {
        return this.state.colorLUT[lutIndex];
    }
    getNextColorLUTIndex() {
        return this.state.colorLUT.length;
    }
    resetState() {
        this._stackLabelmapImageIdReferenceMap.clear();
        this._labelmapImageIdReferenceMap.clear();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
    }
    getSegmentation(segmentationId) {
        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
    }
    updateSegmentation(segmentationId, payload) {
        this.updateState((draftState) => {
            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
            if (!segmentation) {
                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);
                return;
            }
            Object.assign(segmentation, payload);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    addSegmentation(segmentation) {
        if (this.getSegmentation(segmentation.segmentationId)) {
            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);
        }
        this.updateState((state) => {
            const newSegmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(segmentation);
            if (newSegmentation.representationData.Labelmap &&
                'volumeId' in newSegmentation.representationData.Labelmap &&
                !('imageIds' in newSegmentation.representationData.Labelmap)) {
                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);
                newSegmentation.representationData
                    .Labelmap.imageIds = imageIds;
            }
            state.segmentations.push(newSegmentation);
        });
        (0,_events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__/* .triggerSegmentationAdded */ .R)(segmentation.segmentationId);
    }
    removeSegmentation(segmentationId) {
        this.updateState((state) => {
            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);
            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRemoved)(segmentationId);
    }
    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {
            type: type,
            segmentationId,
        });
        if (existingRepresentations.length > 0) {
            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);
            return;
        }
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                state.viewportSegRepresentations[viewportId] = [];
                _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__/* .segmentationStyle */ .Y.setRenderInactiveSegmentations(viewportId, true);
            }
            if (type !== _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);
            }
            else {
                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);
            }
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId, type);
    }
    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {
        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
        if (!segmentation) {
            return;
        }
        const segmentReps = {};
        Object.keys(segmentation.segments).forEach((segmentIndex) => {
            segmentReps[Number(segmentIndex)] = {
                visible: true,
            };
        });
        state.viewportSegRepresentations[viewportId].push({
            segmentationId,
            type,
            active: true,
            visible: true,
            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,
            segments: segmentReps,
            config: {
                ...getDefaultRenderingConfig(type),
                ...renderingConfig,
            },
        });
        this._setActiveSegmentation(state, viewportId, segmentationId);
    }
    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap)) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
        }
        this.processLabelmapRepresentationAddition(viewportId, segmentationId);
        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
    }
    async processLabelmapRepresentationAddition(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const volumeViewport = enabledElement.viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport;
        const { representationData } = segmentation;
        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;
        const viewport = enabledElement.viewport;
        if (!volumeViewport && !isBaseVolumeSegmentation) {
            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);
        }
    }
    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {
        const referenceImageId = viewport.getCurrentImageId();
        let viewableLabelmapImageIdFound = false;
        for (const labelmapImageId of labelmapImageIds) {
            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });
            if (viewableImageId) {
                viewableLabelmapImageIdFound = true;
                this._stackLabelmapImageIdReferenceMap
                    .get(segmentationId)
                    .set(referenceImageId, labelmapImageId);
                this._updateLabelmapImageIdReferenceMap({
                    segmentationId,
                    referenceImageId,
                    labelmapImageId,
                });
            }
        }
        if (updateCallback) {
            updateCallback(viewport, segmentationId, labelmapImageIds);
        }
        return viewableLabelmapImageIdFound
            ? this._stackLabelmapImageIdReferenceMap
                .get(segmentationId)
                .get(referenceImageId)
            : undefined;
    }
    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);
    }
    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {
            const imageIds = stackViewport.getImageIds();
            imageIds.forEach((referenceImageId, index) => {
                for (const labelmapImageId of labelmapImageIds) {
                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });
                    if (viewableImageId) {
                        this._stackLabelmapImageIdReferenceMap
                            .get(segmentationId)
                            .set(referenceImageId, labelmapImageId);
                        this._updateLabelmapImageIdReferenceMap({
                            segmentationId,
                            referenceImageId,
                            labelmapImageId,
                        });
                    }
                }
            });
        });
    }
    getLabelmapImageIds(representationData) {
        const labelmapData = representationData.Labelmap;
        let labelmapImageIds;
        if (labelmapData.imageIds) {
            labelmapImageIds = labelmapData
                .imageIds;
        }
        else if (!labelmapImageIds &&
            labelmapData.volumeId) {
            const volumeId = labelmapData
                .volumeId;
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            labelmapImageIds = volume.imageIds;
        }
        return labelmapImageIds;
    }
    getLabelmapImageIdsForImageId(imageId, segmentationId) {
        const key = this._generateMapKey({
            segmentationId,
            referenceImageId: imageId,
        });
        return this._labelmapImageIdReferenceMap.get(key);
    }
    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const referenceImageId = stackViewport.getCurrentImageId();
        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);
    }
    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const currentImageId = stackViewport.getCurrentImageId();
        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIdReferenceMap.get(currentImageId);
    }
    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return [];
        }
        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const imageIds = viewport.getImageIds();
        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIds.map((imageId) => {
            return associatedReferenceImageAndLabelmapImageIds.get(imageId);
        });
    }
    removeSegmentationRepresentationsInternal(viewportId, specifier) {
        const removedRepresentations = [];
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                return;
            }
            const currentRepresentations = state.viewportSegRepresentations[viewportId];
            let activeRepresentationRemoved = false;
            if (!specifier ||
                Object.values(specifier).every((value) => value === undefined)) {
                removedRepresentations.push(...currentRepresentations);
                delete state.viewportSegRepresentations[viewportId];
            }
            else {
                const { segmentationId, type } = specifier;
                state.viewportSegRepresentations[viewportId] =
                    currentRepresentations.filter((representation) => {
                        const shouldRemove = (segmentationId &&
                            type &&
                            representation.segmentationId === segmentationId &&
                            representation.type === type) ||
                            (segmentationId &&
                                !type &&
                                representation.segmentationId === segmentationId) ||
                            (!segmentationId && type && representation.type === type);
                        if (shouldRemove) {
                            removedRepresentations.push(representation);
                            if (representation.active) {
                                activeRepresentationRemoved = true;
                            }
                        }
                        return !shouldRemove;
                    });
                if (state.viewportSegRepresentations[viewportId].length === 0) {
                    delete state.viewportSegRepresentations[viewportId];
                }
                else if (activeRepresentationRemoved) {
                    state.viewportSegRepresentations[viewportId][0].active = true;
                }
            }
        });
        return removedRepresentations;
    }
    removeSegmentationRepresentations(viewportId, specifier) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        removedRepresentations.forEach((representation) => {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, representation.segmentationId, representation.type);
        });
        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);
        if (remainingRepresentations.length > 0 &&
            remainingRepresentations[0].active) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);
        }
        return removedRepresentations;
    }
    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        if (!suppressEvent) {
            removedRepresentations.forEach(({ segmentationId, type }) => {
                (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, segmentationId, type);
            });
        }
        return removedRepresentations;
    }
    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {
        const key = this._generateMapKey({ segmentationId, referenceImageId });
        if (!this._labelmapImageIdReferenceMap.has(key)) {
            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);
            return;
        }
        const currentValues = this._labelmapImageIdReferenceMap.get(key);
        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));
        this._labelmapImageIdReferenceMap.set(key, newValues);
    }
    _setActiveSegmentation(state, viewportId, segmentationId) {
        const viewport = state.viewportSegRepresentations[viewportId];
        if (!viewport) {
            return;
        }
        viewport.forEach((value) => {
            value.active = value.segmentationId === segmentationId;
        });
    }
    setActiveSegmentation(viewportId, segmentationId) {
        this.updateState((state) => {
            const viewport = state.viewportSegRepresentations[viewportId];
            if (!viewport) {
                return;
            }
            viewport.forEach((value) => {
                value.active = value.segmentationId === segmentationId;
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
    }
    getActiveSegmentation(viewportId) {
        if (!this.state.viewportSegRepresentations[viewportId]) {
            return;
        }
        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);
        if (!activeSegRep) {
            return;
        }
        return this.getSegmentation(activeSegRep.segmentationId);
    }
    getSegmentationRepresentations(viewportId, specifier = {}) {
        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];
        if (!viewportRepresentations) {
            return [];
        }
        if (!specifier.type && !specifier.segmentationId) {
            return viewportRepresentations;
        }
        return viewportRepresentations.filter((representation) => {
            const typeMatch = specifier.type
                ? representation.type === specifier.type
                : true;
            const idMatch = specifier.segmentationId
                ? representation.segmentationId === specifier.segmentationId
                : true;
            return typeMatch && idMatch;
        });
    }
    getSegmentationRepresentation(viewportId, specifier) {
        return this.getSegmentationRepresentations(viewportId, specifier)[0];
    }
    getSegmentationRepresentationVisibility(viewportId, specifier) {
        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);
        return viewportRepresentation?.visible;
    }
    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
        this.updateState((state) => {
            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);
            if (!viewportRepresentations) {
                return;
            }
            viewportRepresentations.forEach((representation) => {
                representation.visible = visible;
                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {
                    segment.visible = visible;
                });
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId, specifier.type);
    }
    addColorLUT(colorLUT, lutIndex) {
        this.updateState((state) => {
            if (state.colorLUT[lutIndex]) {
                console.warn('Color LUT table already exists, overwriting');
            }
            state.colorLUT[lutIndex] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(colorLUT);
        });
    }
    removeColorLUT(colorLUTIndex) {
        this.updateState((state) => {
            delete state.colorLUT[colorLUTIndex];
        });
    }
    _getStackIdForImageIds(imageIds) {
        return imageIds
            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))
            .join('_');
    }
    getAllViewportSegmentationRepresentations() {
        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({
            viewportId,
            representations,
        }));
    }
    getSegmentationRepresentationsBySegmentationId(segmentationId) {
        const result = [];
        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {
            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);
            if (filteredReps.length > 0) {
                result.push({ viewportId, representations: filteredReps });
            }
        });
        return result;
    }
    _generateMapKey({ segmentationId, referenceImageId }) {
        return `${segmentationId}-${referenceImageId}`;
    }
}
async function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {
    const segmentationImageIds = imageIds;
    const volumeId = options?.volumeId || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);
    return { volumeId };
}
async function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {
    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);
    const data = segmentation.representationData
        .Labelmap;
    const { volumeId } = await internalComputeVolumeLabelmapFromStack({
        imageIds: data.imageIds,
        options,
    });
    segmentation.representationData.Labelmap.volumeId = volumeId;
}
function getDefaultRenderingConfig(type) {
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    ofun.addPoint(0, 0);
    if (type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
        return {
            cfun,
            ofun,
        };
    }
    else {
        return {};
    }
}
const defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');



/***/ }),

/***/ 26228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getActiveSegmentation: () => (/* binding */ activeSegmentation_getActiveSegmentation),
  setActiveSegmentation: () => (/* binding */ activeSegmentation_setActiveSegmentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
var getActiveSegmentation = __webpack_require__(67165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js

function setActiveSegmentation(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js


function activeSegmentation_getActiveSegmentation(viewportId) {
    return (0,getActiveSegmentation/* getActiveSegmentation */.T)(viewportId);
}
function activeSegmentation_setActiveSegmentation(viewportId, segmentationId) {
    setActiveSegmentation(viewportId, segmentationId);
}



/***/ }),

/***/ 4714:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ addColorLUT)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);
/* harmony import */ var _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70906);
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93952);




function addColorLUT(colorLUT, index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const indexToUse = index ?? (0,_getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__/* .getNextColorLUTIndex */ .u)();
    let colorLUTToUse = [...colorLUT];
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {
        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');
        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];
    }
    colorLUTToUse = colorLUTToUse.map((color) => {
        if (color.length === 3) {
            return [color[0], color[1], color[2], 255];
        }
        return color;
    });
    if (colorLUTToUse.length < 255) {
        const missingColorLUTs = _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.slice(colorLUTToUse.length);
        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];
    }
    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);
    return indexToUse;
}


/***/ }),

/***/ 74283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $j: () => (/* binding */ addSurfaceRepresentationToViewportMap),
/* harmony export */   At: () => (/* binding */ addContourRepresentationToViewport),
/* harmony export */   Hr: () => (/* binding */ addSurfaceRepresentationToViewport),
/* harmony export */   Wz: () => (/* binding */ addLabelmapRepresentationToViewport),
/* harmony export */   cs: () => (/* binding */ addContourRepresentationToViewportMap),
/* harmony export */   gR: () => (/* binding */ addSegmentationRepresentations),
/* harmony export */   w9: () => (/* binding */ addLabelmapRepresentationToViewportMap)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55894);


function addSegmentationRepresentations(viewportId, segmentationInputArray) {
    segmentationInputArray.map((segmentationInput) => {
        return (0,_internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__/* .internalAddSegmentationRepresentation */ .U)(viewportId, segmentationInput);
    });
}
function addContourRepresentationToViewport(viewportId, contourInputArray) {
    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
    })));
}
function addContourRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}
function addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {
    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
    })));
}
function addLabelmapRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({
            ...input,
            type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Labelmap,
        })));
    }
}
function addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {
    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Surface,
    })));
}
function addSurfaceRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}



/***/ }),

/***/ 30935:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ addSegmentations)
});

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js


function normalizeSegmentationInput(segmentationInput) {
    const { segmentationId, representation, config } = segmentationInput;
    const { type, data: inputData } = representation;
    const data = inputData ? { ...inputData } : {};
    if (!data) {
        throw new Error('Segmentation representation data may not be undefined');
    }
    if (type === enums.SegmentationRepresentations.Contour) {
        normalizeContourData(data);
    }
    const normalizedSegments = normalizeSegments(config?.segments, type, data);
    delete config?.segments;
    return {
        segmentationId,
        label: config?.label ?? null,
        cachedStats: config?.cachedStats ?? {},
        segments: normalizedSegments,
        representationData: {
            [type]: {
                ...data,
            },
        },
    };
}
function normalizeContourData(contourData) {
    contourData.geometryIds = contourData.geometryIds ?? [];
    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();
}
function normalizeSegments(segmentsConfig, type, data) {
    const normalizedSegments = {};
    if (segmentsConfig) {
        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {
            const { label, locked, cachedStats, active, ...rest } = segment;
            const normalizedSegment = {
                segmentIndex: Number(segmentIndex),
                label: label ?? `Segment ${segmentIndex}`,
                locked: locked ?? false,
                cachedStats: cachedStats ?? {},
                active: active ?? false,
                ...rest,
            };
            normalizedSegments[segmentIndex] = normalizedSegment;
        });
    }
    else if (type === enums.SegmentationRepresentations.Surface) {
        normalizeSurfaceSegments(normalizedSegments, data);
    }
    else {
        normalizedSegments[1] = createDefaultSegment();
    }
    return normalizedSegments;
}
function normalizeSurfaceSegments(normalizedSegments, surfaceData) {
    const { geometryIds } = surfaceData;
    geometryIds?.forEach((geometryId) => {
        const geometry = esm.cache.getGeometry(geometryId);
        if (geometry?.data) {
            const { segmentIndex } = geometry.data;
            normalizedSegments[segmentIndex] = { segmentIndex };
        }
    });
}
function createDefaultSegment() {
    return {
        segmentIndex: 1,
        label: 'Segment 1',
        locked: false,
        cachedStats: {},
        active: true,
    };
}
/* harmony default export */ const helpers_normalizeSegmentationInput = (normalizeSegmentationInput);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js



function addSegmentations(segmentationInputArray, suppressEvents) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationInputArray.forEach((segmentationInput) => {
        const segmentation = helpers_normalizeSegmentationInput(segmentationInput);
        segmentationStateManager.addSegmentation(segmentation);
        if (!suppressEvents) {
            (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentation.segmentationId);
        }
    });
}
/* harmony default export */ const segmentation_addSegmentations = ((/* unused pure expression or super */ null && (addSegmentations)));


/***/ }),

/***/ 93733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* binding */ addColorLUT),
/* harmony export */   getSegmentIndexColor: () => (/* binding */ getSegmentIndexColor),
/* harmony export */   setColorLUT: () => (/* binding */ setColorLUT),
/* harmony export */   setSegmentIndexColor: () => (/* binding */ setSegmentIndexColor)
/* harmony export */ });
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4714);
/* harmony import */ var _getColorLUT__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50409);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93210);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);




function addColorLUT(colorLUT, colorLUTIndex) {
    if (!colorLUT) {
        throw new Error('addColorLUT: colorLUT is required');
    }
    return (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_0__/* .addColorLUT */ .u)(colorLUT, colorLUTIndex);
}
function setColorLUT(viewportId, segmentationId, colorLUTsIndex) {
    if (!(0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTsIndex)) {
        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);
    }
    const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
    if (!segmentationRepresentations) {
        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);
    }
    segmentationRepresentations.forEach((segmentationRepresentation) => {
        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;
    });
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}
function getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, {
        segmentationId,
    });
    if (!representations || representations.length === 0) {
        return null;
    }
    const representation = representations[0];
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTIndex);
    let colorValue = colorLUT[segmentIndex];
    if (!colorValue) {
        if (typeof segmentIndex !== 'number') {
            console.warn(`Can't create colour for LUT index ${segmentIndex}`);
            return null;
        }
        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];
    }
    return colorValue;
}
function setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {
    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    for (let i = 0; i < color.length; i++) {
        colorReference[i] = color[i];
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}



/***/ }),

/***/ 60740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ getActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function getActiveSegmentIndex(segmentationId) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (segmentation) {
        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);
        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;
    }
    return undefined;
}


/***/ }),

/***/ 50409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ getColorLUT)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getColorLUT(index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getColorLUT(index);
}


/***/ }),

/***/ 97577:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T8: () => (/* binding */ getLabelmapImageIdsForImageId),
/* harmony export */   aF: () => (/* binding */ getCurrentLabelmapImageIdsForViewport),
/* harmony export */   vl: () => (/* binding */ getCurrentLabelmapImageIdForViewport)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
    return imageIds[0];
}
function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
}
function getLabelmapImageIdsForImageId(imageId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);
}


/***/ }),

/***/ 70906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ getNextColorLUTIndex)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getNextColorLUTIndex() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getNextColorLUTIndex();
}


/***/ }),

/***/ 33283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentation(segmentationId);
}


/***/ }),

/***/ 93210:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ut: () => (/* binding */ getSegmentationRepresentation),
/* harmony export */   ny: () => (/* binding */ getSegmentationRepresentationsBySegmentationId),
/* harmony export */   r$: () => (/* binding */ getSegmentationRepresentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentationRepresentations(viewportId, specifier = {}) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
}
function getSegmentationRepresentation(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    if (!specifier.segmentationId || !specifier.type) {
        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');
    }
    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
    return representations?.[0];
}
function getSegmentationRepresentationsBySegmentationId(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);
}


/***/ }),

/***/ 70758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ getSegmentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    return state.segmentations;
}


/***/ }),

/***/ 58859:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ getViewportIdsWithSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getViewportIdsWithSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportSegRepresentations = state.viewportSegRepresentations;
    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)
        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))
        .map(([viewportId]) => viewportId);
    return viewportIdsWithSegmentation;
}


/***/ }),

/***/ 42568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getViewportSegmentations),
/* harmony export */   z: () => (/* binding */ getViewportSegmentationRepresentations)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);


function getViewportSegmentations(viewportId, type) {
    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);
    const segmentations = viewportRepresentations.map((representation) => {
        if (type && representation.type === type) {
            return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
        }
        return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
    });
    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);
    return filteredSegmentations;
}
function getViewportSegmentationRepresentations(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportRepresentations = state.viewportSegRepresentations[viewportId];
    return viewportRepresentations;
}


/***/ }),

/***/ 93690:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ computeStackLabelmapFromVolume),
/* harmony export */   f: () => (/* binding */ convertVolumeToStackLabelmap)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33283);
/* harmony import */ var _helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98149);



async function computeStackLabelmapFromVolume({ volumeId, }) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    return { imageIds: segmentationVolume.imageIds };
}
function convertVolumeToStackLabelmap({ segmentationId, options, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    const { volumeId } = segmentation.representationData
        .Labelmap;
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    return (0,_helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__/* .updateStackSegmentationState */ .X)({
        segmentationId,
        viewportId: options.viewportId,
        imageIds: segmentationVolume.imageIds,
        options,
    });
}


/***/ }),

/***/ 6994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ computeVolumeLabelmapFromStack)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

async function computeVolumeLabelmapFromStack(args) {
    return (0,_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .internalComputeVolumeLabelmapFromStack */ .Zm)(args);
}


/***/ }),

/***/ 59452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DU: () => (/* binding */ getSurfaceRepresentationUID),
/* harmony export */   ED: () => (/* binding */ getLabelmapActorEntries),
/* harmony export */   Qe: () => (/* binding */ getLabelmapActorUID),
/* harmony export */   Th: () => (/* binding */ getSurfaceActorEntry),
/* harmony export */   wV: () => (/* binding */ getLabelmapActorEntry)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);


function getActorEntry(viewportId, segmentationId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors[0] : undefined;
}
function getActorEntries(viewportId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors : undefined;
}
function getLabelmapActorUID(viewportId, segmentationId) {
    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);
    return actorEntry?.uid;
}
function getLabelmapActorEntries(viewportId, segmentationId) {
    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getLabelmapActorEntry(viewportId, segmentationId) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===
        getSurfaceRepresentationUID(segmentationId, segmentIndex));
}
function getSurfaceRepresentationUID(segmentationId, segmentIndex) {
    return `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Surface}-${segmentIndex}`;
}


/***/ }),

/***/ 91963:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wV: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.wV)
/* harmony export */ });
/* harmony import */ var _validateSegmentationInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9711);
/* harmony import */ var _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59452);





/***/ }),

/***/ 44595:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  activeSegmentation: () => (/* reexport */ activeSegmentation),
  addContourRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addContourRepresentationToViewport */.At),
  addContourRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addContourRepresentationToViewportMap */.cs),
  addLabelmapRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addLabelmapRepresentationToViewport */.Wz),
  addLabelmapRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addLabelmapRepresentationToViewportMap */.w9),
  addRepresentationData: () => (/* reexport */ internalAddRepresentationData/* default */.A),
  addSegmentationRepresentations: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSegmentationRepresentations */.gR),
  addSegmentations: () => (/* reexport */ addSegmentations/* addSegmentations */.d),
  addSurfaceRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSurfaceRepresentationToViewport */.Hr),
  addSurfaceRepresentationToViewportMap: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSurfaceRepresentationToViewportMap */.$j),
  config: () => (/* reexport */ config_namespaceObject),
  defaultSegmentationStateManager: () => (/* reexport */ SegmentationStateManager/* defaultSegmentationStateManager */._6),
  getActiveSegmentation: () => (/* reexport */ getActiveSegmentation/* getActiveSegmentation */.T),
  getCurrentLabelmapImageIdsForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF),
  getLabelmapImageIds: () => (/* reexport */ getLabelmapImageIds),
  getLabelmapImageIdsForImageId: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getLabelmapImageIdsForImageId */.T8),
  helpers: () => (/* binding */ helpers),
  removeAllSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeAllSegmentationRepresentations */.us),
  removeAllSegmentations: () => (/* reexport */ removeSegmentation/* removeAllSegmentations */.j),
  removeContourRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeContourRepresentation */.OE),
  removeLabelmapRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeLabelmapRepresentation */.kN),
  removeSegment: () => (/* reexport */ removeSegment),
  removeSegmentation: () => (/* reexport */ removeSegmentation/* removeSegmentation */.z),
  removeSegmentationRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentation */.E8),
  removeSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentations */.nc),
  removeSurfaceRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSurfaceRepresentation */.JC),
  segmentIndex: () => (/* reexport */ segmentation_segmentIndex),
  segmentLocking: () => (/* reexport */ segmentLocking),
  segmentationStyle: () => (/* reexport */ SegmentationStyle/* segmentationStyle */.Y),
  state: () => (/* reexport */ segmentationState),
  strategies: () => (/* reexport */ strategies),
  triggerSegmentationEvents: () => (/* reexport */ triggerSegmentationEvents),
  updateSegmentations: () => (/* reexport */ updateSegmentations)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js
var segmentationVisibility_namespaceObject = {};
__webpack_require__.r(segmentationVisibility_namespaceObject);
__webpack_require__.d(segmentationVisibility_namespaceObject, {
  getHiddenSegmentIndices: () => (getHiddenSegmentIndices),
  getSegmentIndexVisibility: () => (getSegmentIndexVisibility),
  getSegmentationRepresentationVisibility: () => (segmentationVisibility_getSegmentationRepresentationVisibility),
  setSegmentIndexVisibility: () => (setSegmentIndexVisibility),
  setSegmentationRepresentationVisibility: () => (segmentationVisibility_setSegmentationRepresentationVisibility)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js
var styleHelpers_namespaceObject = {};
__webpack_require__.r(styleHelpers_namespaceObject);
__webpack_require__.d(styleHelpers_namespaceObject, {
  getRenderInactiveSegmentations: () => (getRenderInactiveSegmentations),
  getStyle: () => (getStyle),
  hasCustomStyle: () => (hasCustomStyle),
  resetToGlobalStyle: () => (resetToGlobalStyle),
  setRenderInactiveSegmentations: () => (setRenderInactiveSegmentations),
  setStyle: () => (setStyle)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js
var config_namespaceObject = {};
__webpack_require__.r(config_namespaceObject);
__webpack_require__.d(config_namespaceObject, {
  color: () => (segmentationColor),
  style: () => (styleHelpers_namespaceObject),
  visibility: () => (segmentationVisibility_namespaceObject)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js
var addSegmentationRepresentationsToViewport = __webpack_require__(74283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js
var internalAddRepresentationData = __webpack_require__(44188);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js


function updateSegmentations(segmentationUpdateArray, suppressEvents) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationUpdateArray.forEach((segmentationUpdate) => {
        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);
        if (!suppressEvents) {
            (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationUpdate.segmentationId);
        }
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js + 1 modules
var activeSegmentation = __webpack_require__(26228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js
var segmentLocking = __webpack_require__(26795);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
var segmentationColor = __webpack_require__(93733);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js

function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js
var getSegmentationRepresentationVisibility = __webpack_require__(33658);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js





function segmentationVisibility_setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        setSegmentationRepresentationVisibility(viewportId, {
            segmentationId: representation.segmentationId,
            type: representation.type,
        }, visibility);
    });
}
function segmentationVisibility_getSegmentationRepresentationVisibility(viewportId, specifier) {
    return (0,getSegmentationRepresentationVisibility/* getSegmentationRepresentationVisibility */.I)(viewportId, specifier);
}
function setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        representation.segments[segmentIndex].visible = visibility;
    });
    (0,SegmentationRenderingEngine/* triggerSegmentationRenderBySegmentationId */.fy)(specifier.segmentationId);
    (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId);
}
function getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {
    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);
    return !hiddenSegments.has(segmentIndex);
}
function getHiddenSegmentIndices(viewportId, specifier) {
    const representation = (0,getSegmentationRepresentation/* getSegmentationRepresentation */.Ut)(viewportId, specifier);
    if (!representation) {
        return new Set();
    }
    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
        if (!segment.visible) {
            acc.add(Number(segmentIndex));
        }
        return acc;
    }, new Set());
    return segmentsHidden;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js
var SegmentationStyle = __webpack_require__(92686);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js





function getStyle(specifier) {
    return SegmentationStyle/* segmentationStyle */.Y.getStyle(specifier);
}
function setStyle(specifier, style) {
    SegmentationStyle/* segmentationStyle */.Y.setStyle(specifier, style);
    if (!specifier.viewportId && !specifier.segmentationId) {
        const segmentations = (0,getSegmentations/* getSegmentations */.K)();
        segmentations.forEach((segmentation) => {
            (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(segmentation.segmentationId);
        });
    }
    (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(specifier.viewportId, specifier.segmentationId, specifier.type);
}
function setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
    SegmentationStyle/* segmentationStyle */.Y.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);
    (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
    const segmentations = (0,getViewportSegmentations/* getViewportSegmentations */.a)(viewportId);
    segmentations.forEach((segmentation) => {
        (0,triggerSegmentationEvents.triggerSegmentationRepresentationModified)(viewportId, segmentation.segmentationId);
    });
}
function getRenderInactiveSegmentations(viewportId) {
    return SegmentationStyle/* segmentationStyle */.Y.getRenderInactiveSegmentations(viewportId);
}
function resetToGlobalStyle() {
    SegmentationStyle/* segmentationStyle */.Y.resetToGlobalStyle();
    (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)();
}
function hasCustomStyle(specifier) {
    return SegmentationStyle/* segmentationStyle */.Y.hasCustomStyle(specifier);
}


;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentation_segmentIndex = __webpack_require__(70930);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js
var convertStackToVolumeLabelmap = __webpack_require__(6273);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js
var computeVolumeLabelmapFromStack = __webpack_require__(6994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js



function clearSegmentValue(segmentationId, segmentIndex) {
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (segmentation.representationData.Labelmap) {
        const { representationData } = segmentation;
        const labelmapData = representationData.Labelmap;
        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {
            const items = 'imageIds' in labelmapData
                ? labelmapData.imageIds.map((imageId) => esm.cache.getImage(imageId))
                : [esm.cache.getVolume(labelmapData.volumeId)];
            items.forEach((item) => {
                if (!item) {
                    return;
                }
                const { voxelManager } = item;
                voxelManager.forEach(({ value, index }) => {
                    if (value === segmentIndex) {
                        voxelManager.setAtIndex(index, 0);
                    }
                });
            });
        }
        (0,triggerSegmentationEvents.triggerSegmentationDataModified)(segmentationId);
    }
    else {
        throw new Error('Invalid segmentation type, only labelmap is supported right now');
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js
var computeStackLabelmapFromVolume = __webpack_require__(93690);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js
var getActiveSegmentIndex = __webpack_require__(60740);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js







function removeSegment(segmentationId, segmentIndex, options = {
    setNextSegmentAsActive: true,
}) {
    clearSegmentValue(segmentationId, segmentIndex);
    const isThisSegmentActive = (0,getActiveSegmentIndex/* getActiveSegmentIndex */.Q)(segmentationId) === segmentIndex;
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    const { segments } = segmentation;
    delete segments[segmentIndex];
    const updatedSegments = {
        ...segments,
    };
    updateSegmentations([
        {
            segmentationId,
            payload: {
                segments: updatedSegments,
            },
        },
    ]);
    if (isThisSegmentActive && options.setNextSegmentAsActive) {
        const segmentIndices = Object.keys(segments)
            .map(Number)
            .sort((a, b) => a - b);
        const currentIndex = segmentIndices.indexOf(segmentIndex);
        const nextSegmentIndex = segmentIndices[currentIndex + 1];
        const previousSegmentIndex = segmentIndices[currentIndex - 1];
        if (nextSegmentIndex !== undefined) {
            (0,segmentation_segmentIndex.setActiveSegmentIndex)(segmentationId, nextSegmentIndex);
        }
        else if (previousSegmentIndex !== undefined) {
            (0,segmentation_segmentIndex.setActiveSegmentIndex)(segmentationId, previousSegmentIndex);
        }
    }
    const viewportIds = (0,getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            delete representation.segments[segmentIndex];
        });
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js


function getLabelmapImageIds(segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js
var strategies = __webpack_require__(99522);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
var getActiveSegmentation = __webpack_require__(67165);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js























const helpers = {
    clearSegmentValue: clearSegmentValue,
    convertStackToVolumeLabelmap: convertStackToVolumeLabelmap/* convertStackToVolumeLabelmap */.p,
    computeVolumeLabelmapFromStack: computeVolumeLabelmapFromStack/* computeVolumeLabelmapFromStack */.a,
    convertVolumeToStackLabelmap: computeStackLabelmapFromVolume/* convertVolumeToStackLabelmap */.f,
};



/***/ }),

/***/ 55894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ internalAddSegmentationRepresentation)
/* harmony export */ });
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93952);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4714);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59475);






function internalAddSegmentationRepresentation(viewportId, representationInput) {
    const { segmentationId, config } = representationInput;
    const renderingConfig = {
        colorLUTIndex: getColorLUTIndex(config),
        ...config,
    };
    _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__/* .defaultSegmentationStateManager */ ._6.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);
    if (representationInput.type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* .triggerAnnotationRenderForViewportIds */ .t)([viewportId]);
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
}
function getColorLUTIndex(config) {
    const { colorLUTOrIndex } = config || {};
    if (colorLUTOrIndex === undefined) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)));
        return index;
    }
    if (typeof colorLUTOrIndex === 'number') {
        return colorLUTOrIndex;
    }
    if (Array.isArray(colorLUTOrIndex) &&
        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(colorLUTOrIndex);
        return index;
    }
    const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)));
    return index;
}



/***/ }),

/***/ 63427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ removeAllSegmentations),
/* harmony export */   z: () => (/* binding */ removeSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53662);



function removeSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const viewportsWithSegmentation = segmentationStateManager
        .getAllViewportSegmentationRepresentations()
        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))
        .map(({ viewportId }) => viewportId);
    viewportsWithSegmentation.forEach((viewportId) => {
        (0,_removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* .removeSegmentationRepresentations */ .nc)(viewportId, { segmentationId });
    });
    segmentationStateManager.removeSegmentation(segmentationId);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationRemoved)(segmentationId);
}
function removeAllSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const segmentations = segmentationStateManager.getState().segmentations;
    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);
    segmentationIds.forEach((segmentationId) => {
        removeSegmentation(segmentationId);
    });
    segmentationStateManager.resetState();
}


/***/ }),

/***/ 53662:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  us: () => (/* binding */ removeAllSegmentationRepresentations),
  OE: () => (/* binding */ removeContourRepresentation),
  kN: () => (/* binding */ removeLabelmapRepresentation),
  E8: () => (/* binding */ removeSegmentationRepresentation),
  nc: () => (/* binding */ removeSegmentationRepresentations),
  JC: () => (/* binding */ removeSurfaceRepresentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js
var labelmapDisplay = __webpack_require__(684);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js
var contourDisplay = __webpack_require__(25894);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js
var surfaceDisplay = __webpack_require__(67014);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js







function removeSegmentationRepresentation(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function removeSegmentationRepresentations(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function _removeSegmentationRepresentations(viewportId, specifier, immediate) {
    const { segmentationId, type } = specifier;
    _removeRepresentationObject(viewportId, segmentationId, type, immediate);
    return SegmentationStateManager/* defaultSegmentationStateManager */._6.removeSegmentationRepresentations(viewportId, {
        segmentationId,
        type,
    });
}
function removeAllSegmentationRepresentations() {
    const state = SegmentationStateManager/* defaultSegmentationStateManager */._6.getAllViewportSegmentationRepresentations();
    state.forEach(({ viewportId, representations }) => {
        representations.forEach(({ segmentationId, type }) => {
            removeSegmentationRepresentation(viewportId, {
                segmentationId,
                type,
            });
        });
    });
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}
function removeLabelmapRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Labelmap,
    }, immediate);
}
function removeContourRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Contour,
    }, immediate);
}
function removeSurfaceRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Surface,
    }, immediate);
}
function _removeRepresentationObject(viewportId, segmentationId, type, immediate) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
        segmentationId,
        type,
    });
    representations.forEach((representation) => {
        if (representation.type === SegmentationRepresentations/* default */.A.Labelmap) {
            labelmapDisplay/* default.removeRepresentation */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Contour) {
            contourDisplay/* default */.A.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Surface) {
            surfaceDisplay/* default */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
    });
    const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId) || {};
    if (viewport) {
        viewport.render();
    }
}



/***/ }),

/***/ 70930:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentIndex: () => (/* reexport safe */ _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__.Q),
/* harmony export */   setActiveSegmentIndex: () => (/* binding */ setActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35706);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58859);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60740);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93210);







function setActiveSegmentIndex(segmentationId, segmentIndex) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    if (typeof segmentIndex === 'string') {
        console.warn('segmentIndex is a string, converting to number');
        segmentIndex = Number(segmentIndex);
    }
    Object.values(segmentation.segments).forEach((segment) => {
        segment.active = false;
    });
    if (!segmentation.segments[segmentIndex]) {
        segmentation.segments[segmentIndex] = {
            segmentIndex,
            label: '',
            locked: false,
            cachedStats: {},
            active: false,
        };
    }
    if (segmentation.segments[segmentIndex].active !== true) {
        segmentation.segments[segmentIndex].active = true;
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    const viewportIds = (0,_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getViewportIdsWithSegmentation */ .P)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentationRepresentations */ .r$)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            if (!representation.segments[segmentIndex]) {
                representation.segments[segmentIndex] = {
                    visible: true,
                };
            }
        });
    });
    viewportIds.forEach((viewportId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId);
        (0,_utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__/* .invalidateBrushCursor */ .E)(toolGroup.id);
    });
}



/***/ }),

/***/ 26795:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLockedSegmentIndices: () => (/* binding */ getLockedSegmentIndices),
/* harmony export */   isSegmentIndexLocked: () => (/* binding */ isSegmentIndexLocked),
/* harmony export */   setSegmentIndexLocked: () => (/* binding */ setSegmentIndexLocked)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);


function isSegmentIndexLocked(segmentationId, segmentIndex) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    return segments[segmentIndex].locked;
}
function setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    segments[segmentIndex].locked = locked;
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationModified)(segmentationId);
}
function getLockedSegmentIndices(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);
    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));
}



/***/ }),

/***/ 98870:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  addColorLUT: () => (/* reexport */ addColorLUT/* addColorLUT */.u),
  addSegmentations: () => (/* reexport */ addSegmentations/* addSegmentations */.d),
  destroy: () => (/* binding */ destroy),
  getColorLUT: () => (/* reexport */ getColorLUT/* getColorLUT */.B),
  getCurrentLabelmapImageIdForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdForViewport */.vl),
  getCurrentLabelmapImageIdsForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF),
  getNextColorLUTIndex: () => (/* reexport */ getNextColorLUTIndex/* getNextColorLUTIndex */.u),
  getSegmentation: () => (/* reexport */ getSegmentation/* getSegmentation */.T),
  getSegmentationRepresentation: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentation */.Ut),
  getSegmentationRepresentations: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentations */.r$),
  getSegmentationRepresentationsBySegmentationId: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentationsBySegmentationId */.ny),
  getSegmentations: () => (/* reexport */ getSegmentations/* getSegmentations */.K),
  getStackSegmentationImageIdsForViewport: () => (/* reexport */ getStackSegmentationImageIdsForViewport),
  getViewportIdsWithSegmentation: () => (/* reexport */ getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P),
  getViewportSegmentationRepresentations: () => (/* reexport */ getViewportSegmentations/* getViewportSegmentationRepresentations */.z),
  getViewportSegmentations: () => (/* reexport */ getViewportSegmentations/* getViewportSegmentations */.a),
  removeAllSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeAllSegmentationRepresentations */.us),
  removeAllSegmentations: () => (/* reexport */ removeSegmentation/* removeAllSegmentations */.j),
  removeColorLUT: () => (/* reexport */ removeColorLUT),
  removeContourRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeContourRepresentation */.OE),
  removeLabelmapRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeLabelmapRepresentation */.kN),
  removeSegmentation: () => (/* reexport */ removeSegmentation/* removeSegmentation */.z),
  removeSegmentationRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentation */.E8),
  removeSurfaceRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSurfaceRepresentation */.JC),
  updateLabelmapSegmentationImageReferences: () => (/* reexport */ updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js
var addColorLUT = __webpack_require__(4714);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js
var getColorLUT = __webpack_require__(50409);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js
var getNextColorLUTIndex = __webpack_require__(70906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js

function removeColorLUT(colorLUTIndex) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.removeColorLUT(colorLUTIndex);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js

function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js
















function destroy() {
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}



/***/ }),

/***/ 49906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationDataModified: () => (/* reexport safe */ _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__.Q),
/* harmony export */   triggerSegmentationModified: () => (/* reexport safe */ _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__.G),
/* harmony export */   triggerSegmentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__.B),
/* harmony export */   triggerSegmentationRepresentationModified: () => (/* reexport safe */ _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__.r),
/* harmony export */   triggerSegmentationRepresentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__.O)
/* harmony export */ });
/* harmony import */ var _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98798);
/* harmony import */ var _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9726);
/* harmony import */ var _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1485);
/* harmony import */ var _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44951);
/* harmony import */ var _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65290);








/***/ }),

/***/ 78231:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ updateLabelmapSegmentationImageReferences)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
}


/***/ }),

/***/ 50749:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

class Synchronizer {
    constructor(synchronizerId, eventName, eventHandler, options) {
        this._viewportOptions = {};
        this._onEvent = (evt) => {
            if (this._ignoreFiredEvents === true) {
                return;
            }
            if (!this._targetViewports.length) {
                return;
            }
            const enabledElement = this._eventSource === 'element'
                ? (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(evt.currentTarget)
                : (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(evt.detail?.viewportId);
            if (!enabledElement) {
                return;
            }
            const { renderingEngineId, viewportId } = enabledElement;
            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {
                return;
            }
            this.fireEvent({
                renderingEngineId,
                viewportId,
            }, evt);
        };
        this._enabled = true;
        this._eventName = eventName;
        this._eventHandler = eventHandler;
        this._ignoreFiredEvents = false;
        this._sourceViewports = [];
        this._targetViewports = [];
        this._options = options || {};
        this._eventSource = this._options.eventSource || 'element';
        this._auxiliaryEvents = this._options.auxiliaryEvents || [];
        this.id = synchronizerId;
    }
    isDisabled() {
        return !this._enabled || !this._hasSourceElements();
    }
    setOptions(viewportId, options = {}) {
        this._viewportOptions[viewportId] = options;
    }
    setEnabled(enabled) {
        this._enabled = enabled;
    }
    getOptions(viewportId) {
        return this._viewportOptions[viewportId];
    }
    add(viewportInfo) {
        this.addTarget(viewportInfo);
        this.addSource(viewportInfo);
    }
    addSource(viewportInfo) {
        if (_containsViewport(this._sourceViewports, viewportInfo)) {
            return;
        }
        const { renderingEngineId, viewportId } = viewportInfo;
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId).getViewport(viewportId);
        if (!viewport) {
            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);
            return;
        }
        const eventSource = this._eventSource === 'element' ? viewport.element : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element' ? viewport.element : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
            target.addEventListener(name, this._onEvent.bind(this));
        });
        this._updateDisableHandlers();
        this._sourceViewports.push(viewportInfo);
    }
    addTarget(viewportInfo) {
        if (_containsViewport(this._targetViewports, viewportInfo)) {
            return;
        }
        this._targetViewports.push(viewportInfo);
        this._updateDisableHandlers();
    }
    getSourceViewports() {
        return this._sourceViewports;
    }
    getTargetViewports() {
        return this._targetViewports;
    }
    destroy() {
        this._sourceViewports.forEach((s) => this.removeSource(s));
        this._targetViewports.forEach((t) => this.removeTarget(t));
    }
    remove(viewportInfo) {
        this.removeTarget(viewportInfo);
        this.removeSource(viewportInfo);
    }
    removeSource(viewportInfo) {
        const index = _getViewportIndex(this._sourceViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        const eventSource = this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
        this._sourceViewports.splice(index, 1);
        eventSource.removeEventListener(this._eventName, this._eventHandler);
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element'
                ? this.getViewportElement(viewportInfo)
                : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
            target.removeEventListener(name, this._eventHandler);
        });
        this._updateDisableHandlers();
    }
    removeTarget(viewportInfo) {
        const index = _getViewportIndex(this._targetViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        this._targetViewports.splice(index, 1);
        this._updateDisableHandlers();
    }
    hasSourceViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._sourceViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    hasTargetViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._targetViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    fireEvent(sourceViewport, sourceEvent) {
        if (this.isDisabled() || this._ignoreFiredEvents) {
            return;
        }
        this._ignoreFiredEvents = true;
        const promises = [];
        try {
            for (let i = 0; i < this._targetViewports.length; i++) {
                const targetViewport = this._targetViewports[i];
                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;
                if (targetIsSource) {
                    continue;
                }
                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
        }
        catch (ex) {
            console.warn(`Synchronizer, for: ${this._eventName}`, ex);
        }
        finally {
            if (promises.length) {
                Promise.allSettled(promises).then(() => {
                    this._ignoreFiredEvents = false;
                });
            }
            else {
                this._ignoreFiredEvents = false;
            }
        }
    }
    _hasSourceElements() {
        return this._sourceViewports.length !== 0;
    }
    _updateDisableHandlers() {
        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);
        const _remove = this.remove.bind(this);
        const disableHandler = (elementDisabledEvent) => {
            _remove(elementDisabledEvent.detail.element);
        };
        viewports.forEach((vp) => {
            const eventSource = this.getEventSource(vp);
            if (!eventSource) {
                return;
            }
            eventSource.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED, disableHandler);
            eventSource.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ELEMENT_DISABLED, disableHandler);
        });
    }
    getEventSource(viewportInfo) {
        return this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget;
    }
    getViewportElement(viewportInfo) {
        const { renderingEngineId, viewportId } = viewportInfo;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
        if (!renderingEngine) {
            return null;
        }
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            return null;
        }
        return viewport.element;
    }
}
function _getUniqueViewports(vp1, vp2) {
    const unique = [];
    const vps = vp1.concat(vp2);
    for (let i = 0; i < vps.length; i++) {
        const vp = vps[i];
        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&
            vp.viewportId === u.viewportId)) {
            unique.push(vp);
        }
    }
    return unique;
}
function _getViewportIndex(arr, vp) {
    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&
        vp.viewportId === ar.viewportId);
}
function _containsViewport(arr, vp) {
    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&
        ar.viewportId === vp.viewportId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Synchronizer);


/***/ }),

/***/ 36601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);
/* harmony import */ var _Synchronizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50749);


function createSynchronizer(synchronizerId, eventName, eventHandler, options) {
    const synchronizerWithSameIdExists = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.some((sync) => sync.id === synchronizerId);
    if (synchronizerWithSameIdExists) {
        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);
    }
    const synchronizer = new _Synchronizer__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(synchronizerId, eventName, eventHandler, options);
    _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.push(synchronizer);
    return synchronizer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSynchronizer);


/***/ }),

/***/ 13239:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function destroy() {
    while (_state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.length > 0) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.pop();
        synchronizer.destroy();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroy);


/***/ }),

/***/ 71395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function destroySynchronizer(synchronizerId) {
    const synchronizerIndex = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.findIndex((sync) => sync.id === synchronizerId);
    if (synchronizerIndex > -1) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers[synchronizerIndex];
        synchronizer.destroy();
        _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.splice(synchronizerIndex, 1);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (destroySynchronizer);


/***/ }),

/***/ 92569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function getAllSynchronizers() {
    return _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllSynchronizers);


/***/ }),

/***/ 70321:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function getSynchronizer(synchronizerId) {
    return _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.find((s) => s.id === synchronizerId);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSynchronizer);


/***/ }),

/***/ 27851:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function getSynchronizersForViewport(viewportId, renderingEngineId) {
    const synchronizersFilteredByIds = [];
    if (!renderingEngineId && !viewportId) {
        throw new Error('At least one of renderingEngineId or viewportId should be given');
    }
    for (let i = 0; i < _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers.length; i++) {
        const synchronizer = _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.synchronizers[i];
        const notDisabled = !synchronizer.isDisabled();
        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);
        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);
        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {
            synchronizersFilteredByIds.push(synchronizer);
        }
    }
    return synchronizersFilteredByIds;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSynchronizersForViewport);


/***/ }),

/***/ 70741:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSynchronizer: () => (/* reexport safe */ _createSynchronizer__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   destroy: () => (/* reexport safe */ _destroy__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   destroySynchronizer: () => (/* reexport safe */ _destroySynchronizer__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   getAllSynchronizers: () => (/* reexport safe */ _getAllSynchronizers__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   getSynchronizer: () => (/* reexport safe */ _getSynchronizer__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   getSynchronizersForViewport: () => (/* reexport safe */ _getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_2__.A)
/* harmony export */ });
/* harmony import */ var _createSynchronizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36601);
/* harmony import */ var _destroy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13239);
/* harmony import */ var _getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27851);
/* harmony import */ var _getSynchronizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70321);
/* harmony import */ var _getAllSynchronizers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92569);
/* harmony import */ var _destroySynchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71395);









/***/ }),

/***/ 77609:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createToolGroup: () => (/* reexport */ ToolGroupManager_createToolGroup),
  destroy: () => (/* reexport */ ToolGroupManager_destroy),
  destroyToolGroup: () => (/* reexport */ ToolGroupManager_destroyToolGroup),
  getAllToolGroups: () => (/* reexport */ ToolGroupManager_getAllToolGroups),
  getToolGroup: () => (/* reexport */ ToolGroupManager_getToolGroup),
  getToolGroupForViewport: () => (/* reexport */ getToolGroupForViewport/* default */.A),
  getToolGroupsWithToolName: () => (/* reexport */ getToolGroupsWithToolName/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/lodash.get/index.js
var lodash_get = __webpack_require__(93008);
var lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js + 4 modules
var cursors = __webpack_require__(79475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js

function getToolGroup(toolGroupId) {
    return state/* state */.wk.toolGroups.find((s) => s.id === toolGroupId);
}
/* harmony default export */ const ToolGroupManager_getToolGroup = (getToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js








const { Active, Passive, Enabled, Disabled } = enums.ToolModes;
const PRIMARY_BINDINGS = [{ mouseButton: enums.MouseBindings.Primary }];
class ToolGroup {
    constructor(id) {
        this.viewportsInfo = [];
        this.toolOptions = {};
        this.currentActivePrimaryToolName = null;
        this.prevActivePrimaryToolName = null;
        this.restoreToolOptions = {};
        this._toolInstances = {};
        this.id = id;
    }
    getViewportIds() {
        return this.viewportsInfo.map(({ viewportId }) => viewportId);
    }
    getViewportsInfo() {
        return this.viewportsInfo.slice();
    }
    getToolInstance(toolInstanceName) {
        const toolInstance = this._toolInstances[toolInstanceName];
        if (!toolInstance) {
            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);
            return;
        }
        return toolInstance;
    }
    getToolInstances() {
        return this._toolInstances;
    }
    hasTool(toolName) {
        return !!this._toolInstances[toolName];
    }
    addTool(toolName, configuration = {}) {
        const toolDefinition = state/* state */.wk.tools[toolName];
        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';
        const localToolInstance = this.toolOptions[toolName];
        if (!hasToolName) {
            console.warn('Tool with configuration did not produce a toolName: ', configuration);
            return;
        }
        if (!toolDefinition) {
            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
            return;
        }
        if (localToolInstance) {
            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);
            return;
        }
        const { toolClass: ToolClass } = toolDefinition;
        const toolProps = {
            name: toolName,
            toolGroupId: this.id,
            configuration,
        };
        const instantiatedTool = new ToolClass(toolProps);
        this._toolInstances[toolName] = instantiatedTool;
    }
    addToolInstance(toolName, parentClassName, configuration = {}) {
        let ToolClassToUse = state/* state */.wk.tools[toolName]
            ?.toolClass;
        if (!ToolClassToUse) {
            const ParentClass = state/* state */.wk.tools[parentClassName]
                .toolClass;
            class ToolInstance extends ParentClass {
            }
            ToolInstance.toolName = toolName;
            ToolClassToUse = ToolInstance;
            state/* state */.wk.tools[toolName] = {
                toolClass: ToolInstance,
            };
        }
        this.addTool(ToolClassToUse.toolName, configuration);
    }
    addViewport(viewportId, renderingEngineId) {
        if (typeof viewportId !== 'string') {
            throw new Error('viewportId must be defined and be a string');
        }
        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);
        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {
            this.viewportsInfo.push({
                viewportId,
                renderingEngineId: renderingEngineUIDToUse,
            });
        }
        const toolName = this.getActivePrimaryMouseButtonTool();
        const runtimeSettings = esm.Settings.getRuntimeSettings();
        if (runtimeSettings.get('useCursors')) {
            this.setViewportsCursorByToolName(toolName);
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId: renderingEngineUIDToUse,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);
    }
    removeViewports(renderingEngineId, viewportId) {
        const indices = [];
        this.viewportsInfo.forEach((vpInfo, index) => {
            let match = false;
            if (vpInfo.renderingEngineId === renderingEngineId) {
                match = true;
                if (viewportId && vpInfo.viewportId !== viewportId) {
                    match = false;
                }
            }
            if (match) {
                indices.push(index);
            }
        });
        if (indices.length) {
            for (let i = indices.length - 1; i >= 0; i--) {
                this.viewportsInfo.splice(indices[i], 1);
            }
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);
    }
    setActiveStrategy(toolName, strategyName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);
            return;
        }
        toolInstance.setActiveStrategy(strategyName);
    }
    setToolMode(toolName, mode, options = {}) {
        if (!toolName) {
            console.warn('setToolMode: toolName must be defined');
            return;
        }
        if (mode === enums.ToolModes.Active) {
            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);
            return;
        }
        if (mode === enums.ToolModes.Passive) {
            this.setToolPassive(toolName);
            return;
        }
        if (mode === enums.ToolModes.Enabled) {
            this.setToolEnabled(toolName);
            return;
        }
        if (mode === enums.ToolModes.Disabled) {
            this.setToolDisabled(toolName);
            return;
        }
        console.warn('setToolMode: mode must be defined');
    }
    setToolActive(toolName, toolBindingsOptions = {}) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        if (!toolInstance) {
            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);
            return;
        }
        const prevBindings = this.toolOptions[toolName]
            ? this.toolOptions[toolName].bindings
            : [];
        const newBindings = toolBindingsOptions.bindings
            ? toolBindingsOptions.bindings
            : [];
        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {
            const TouchBinding = binding.numTouchPoints !== undefined;
            const MouseBinding = binding.mouseButton !== undefined;
            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&
                (TouchBinding || MouseBinding)) {
                unique.push(binding);
            }
            return unique;
        }, []);
        const toolOptions = {
            bindings: bindingsToUse,
            mode: Active,
        };
        this.toolOptions[toolName] = toolOptions;
        this._toolInstances[toolName].mode = Active;
        const runtimeSettings = esm.Settings.getRuntimeSettings();
        const useCursor = runtimeSettings.get('useCursors');
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {
            this.setViewportsCursorByToolName(toolName);
        }
        else {
            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();
            if (!activeToolIdentifier && useCursor) {
                const cursor = cursors.MouseCursor.getDefinedCursor('default');
                this._setCursorForViewports(cursor);
            }
        }
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {
            if (this.prevActivePrimaryToolName === null) {
                this.prevActivePrimaryToolName = toolName;
            }
            else {
                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;
            }
            this.currentActivePrimaryToolName = toolName;
        }
        if (typeof toolInstance.onSetToolActive === 'function') {
            toolInstance.onSetToolActive();
        }
        this._renderViewports();
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            toolBindingsOptions,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOL_ACTIVATED, eventDetail);
        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);
    }
    setToolPassive(toolName, options) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const prevToolOptions = this.getToolOptions(toolName);
        const toolOptions = Object.assign({
            bindings: prevToolOptions ? prevToolOptions.bindings : [],
        }, prevToolOptions, {
            mode: Passive,
        });
        const matchBindings = Array.isArray(options?.removeAllBindings)
            ? options.removeAllBindings
            : this.getDefaultPrimaryBindings();
        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&
            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));
        let mode = Passive;
        if (toolOptions.bindings.length !== 0) {
            mode = Active;
            toolOptions.mode = mode;
        }
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = mode;
        if (typeof toolInstance.onSetToolPassive === 'function') {
            toolInstance.onSetToolPassive();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Passive);
    }
    setToolEnabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Enabled,
        };
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Enabled;
        if (typeof toolInstance.onSetToolEnabled === 'function') {
            toolInstance.onSetToolEnabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Enabled);
    }
    setToolDisabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Disabled,
        };
        this.restoreToolOptions[toolName] = this.toolOptions[toolName];
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Disabled;
        if (typeof toolInstance.onSetToolDisabled === 'function') {
            toolInstance.onSetToolDisabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Disabled);
    }
    getToolOptions(toolName) {
        const toolOptionsForTool = this.toolOptions[toolName];
        if (toolOptionsForTool === undefined) {
            return;
        }
        return toolOptionsForTool;
    }
    getActivePrimaryMouseButtonTool() {
        return Object.keys(this.toolOptions).find((toolName) => {
            const toolOptions = this.toolOptions[toolName];
            return (toolOptions.mode === Active &&
                this._hasMousePrimaryButtonBinding(toolOptions));
        });
    }
    setViewportsCursorByToolName(toolName, strategyName) {
        const cursor = this._getCursor(toolName, strategyName);
        this._setCursorForViewports(cursor);
    }
    _getCursor(toolName, strategyName) {
        let cursorName;
        let cursor;
        if (strategyName) {
            cursorName = `${toolName}.${strategyName}`;
            cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
            if (cursor) {
                return cursor;
            }
        }
        cursorName = `${toolName}`;
        cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        cursorName = toolName;
        cursor = cursors.SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        return cursors.MouseCursor.getDefinedCursor('default');
    }
    _setCursorForViewports(cursor) {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            (0,elementCursor.initElementCursor)(viewport.element, cursor);
        });
    }
    setToolConfiguration(toolName, configuration, overwrite) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return false;
        }
        let _configuration;
        if (overwrite) {
            _configuration = configuration;
        }
        else {
            _configuration = Object.assign(toolInstance.configuration, configuration);
        }
        toolInstance.configuration = _configuration;
        if (typeof toolInstance.onSetToolConfiguration === 'function') {
            toolInstance.onSetToolConfiguration();
        }
        this._renderViewports();
        return true;
    }
    getDefaultMousePrimary() {
        return enums.MouseBindings.Primary;
    }
    getDefaultPrimaryBindings() {
        return PRIMARY_BINDINGS;
    }
    getToolConfiguration(toolName, configurationPath) {
        if (this._toolInstances[toolName] === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return;
        }
        const _configuration = lodash_get_default()(this._toolInstances[toolName].configuration, configurationPath) ||
            this._toolInstances[toolName].configuration;
        return esm.utilities.deepClone(_configuration);
    }
    getPrevActivePrimaryToolName() {
        return this.prevActivePrimaryToolName;
    }
    setActivePrimaryTool(toolName) {
        const activeToolName = this.getCurrentActivePrimaryToolName();
        this.setToolDisabled(activeToolName);
        this.setToolActive(toolName, {
            bindings: [{ mouseButton: enums.MouseBindings.Primary }],
        });
    }
    getCurrentActivePrimaryToolName() {
        return this.currentActivePrimaryToolName;
    }
    clone(newToolGroupId, fnToolFilter = null) {
        let toolGroup = ToolGroupManager_getToolGroup(newToolGroupId);
        if (toolGroup) {
            console.debug(`ToolGroup ${newToolGroupId} already exists`);
            return toolGroup;
        }
        toolGroup = new ToolGroup(newToolGroupId);
        state/* state */.wk.toolGroups.push(toolGroup);
        fnToolFilter = fnToolFilter ?? (() => true);
        Object.keys(this._toolInstances)
            .filter(fnToolFilter)
            .forEach((toolName) => {
            const sourceToolInstance = this._toolInstances[toolName];
            const sourceToolOptions = this.toolOptions[toolName];
            const sourceToolMode = sourceToolInstance.mode;
            toolGroup.addTool(toolName);
            toolGroup.setToolMode(toolName, sourceToolMode, {
                bindings: sourceToolOptions.bindings ?? [],
            });
        });
        return toolGroup;
    }
    _hasMousePrimaryButtonBinding(toolOptions) {
        const primaryBindings = this.getDefaultPrimaryBindings();
        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));
    }
    _renderViewports() {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            (0,esm.getRenderingEngine)(renderingEngineId).renderViewport(viewportId);
        });
    }
    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            mode,
            toolBindingsOptions,
        };
        (0,esm.triggerEvent)(esm.eventTarget, enums.Events.TOOL_MODE_CHANGED, eventDetail);
    }
    _findRenderingEngine(viewportId, renderingEngineId) {
        const renderingEngines = (0,esm.getRenderingEngines)();
        if (renderingEngines?.length === 0) {
            throw new Error('No rendering engines found.');
        }
        if (renderingEngineId) {
            return renderingEngineId;
        }
        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));
        if (matchingEngines.length === 0) {
            if (renderingEngines.length === 1) {
                return renderingEngines[0].id;
            }
            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        if (matchingEngines.length > 1) {
            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        return matchingEngines[0].id;
    }
}
function hasSameBinding(binding1, binding2) {
    if (binding1.mouseButton !== binding2.mouseButton) {
        return false;
    }
    if (binding1.numTouchPoints !== binding2.numTouchPoints) {
        return false;
    }
    return binding1.modifierKey === binding2.modifierKey;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js


function createToolGroup(toolGroupId) {
    const toolGroupWithIdExists = state/* state */.wk.toolGroups.some((tg) => tg.id === toolGroupId);
    if (toolGroupWithIdExists) {
        console.warn(`'${toolGroupId}' already exists.`);
        return;
    }
    const toolGroup = new ToolGroup(toolGroupId);
    state/* state */.wk.toolGroups.push(toolGroup);
    return toolGroup;
}
/* harmony default export */ const ToolGroupManager_createToolGroup = (createToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js

function destroyToolGroup(toolGroupId) {
    const toolGroupIndex = state/* state */.wk.toolGroups.findIndex((tg) => tg.id === toolGroupId);
    if (toolGroupIndex > -1) {
        state/* state */.wk.toolGroups.splice(toolGroupIndex, 1);
    }
}
/* harmony default export */ const ToolGroupManager_destroyToolGroup = (destroyToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js


function destroy() {
    const toolGroups = [...state/* state */.wk.toolGroups];
    for (const toolGroup of toolGroups) {
        ToolGroupManager_destroyToolGroup(toolGroup.id);
    }
    state/* state */.wk.toolGroups = [];
}
/* harmony default export */ const ToolGroupManager_destroy = (destroy);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
var getToolGroupForViewport = __webpack_require__(65136);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js

function getAllToolGroups() {
    return state/* state */.wk.toolGroups;
}
/* harmony default export */ const ToolGroupManager_getAllToolGroups = (getAllToolGroups);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js
var getToolGroupsWithToolName = __webpack_require__(88029);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js










/***/ }),

/***/ 17221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ addEnabledElement)
/* harmony export */ });
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83638);
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3406);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85204);
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39011);




function addEnabledElement(evt) {
    const { element, viewportId } = evt.detail;
    const svgLayer = _createSvgAnnotationLayer(viewportId);
    _setSvgNodeCache(element);
    _appendChild(svgLayer, element);
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_3__/* .annotationRenderingEngine */ .o.addViewportElement(viewportId, element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__/* .mouseEventListeners */ .bH.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__/* .wheelEventListener */ .CG.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__/* .touchEventListeners */ .F_.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__/* .keyEventListener */ .kt.enable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_0__/* .imageChangeEventListener */ ._9.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .imageRenderedEventDispatcher */ .In.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .cameraModifiedEventDispatcher */ .aB.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .imageSpacingCalibratedEventDispatcher */ .z5.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .cameraResetEventDispatcher */ .we.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .mouseToolEventDispatcher */ .n6.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .keyboardToolEventDispatcher */ .V$.enable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_1__/* .touchToolEventDispatcher */ .$m.enable(element);
    _state__WEBPACK_IMPORTED_MODULE_2__/* .state */ .wk.enabledElements.push(element);
}
function _createSvgAnnotationLayer(viewportId) {
    const svgns = 'http://www.w3.org/2000/svg';
    const svgLayer = document.createElementNS(svgns, 'svg');
    const svgLayerId = `svg-layer-${viewportId}`;
    svgLayer.classList.add('svg-layer');
    svgLayer.setAttribute('id', svgLayerId);
    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgLayer.style.width = '100%';
    svgLayer.style.height = '100%';
    svgLayer.style.pointerEvents = 'none';
    svgLayer.style.position = 'absolute';
    const defs = document.createElementNS(svgns, 'defs');
    const filter = document.createElementNS(svgns, 'filter');
    const feOffset = document.createElementNS(svgns, 'feOffset');
    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');
    const feBlend = document.createElementNS(svgns, 'feBlend');
    filter.setAttribute('id', `shadow-${svgLayerId}`);
    filter.setAttribute('filterUnits', 'userSpaceOnUse');
    feOffset.setAttribute('result', 'offOut');
    feOffset.setAttribute('in', 'SourceGraphic');
    feOffset.setAttribute('dx', '0.5');
    feOffset.setAttribute('dy', '0.5');
    feColorMatrix.setAttribute('result', 'matrixOut');
    feColorMatrix.setAttribute('in', 'offOut');
    feColorMatrix.setAttribute('in2', 'matrix');
    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');
    feBlend.setAttribute('in', 'SourceGraphic');
    feBlend.setAttribute('in2', 'matrixOut');
    feBlend.setAttribute('mode', 'normal');
    filter.appendChild(feOffset);
    filter.appendChild(feColorMatrix);
    filter.appendChild(feBlend);
    defs.appendChild(filter);
    svgLayer.appendChild(defs);
    return svgLayer;
}
function _setSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    _state__WEBPACK_IMPORTED_MODULE_2__/* .state */ .wk.svgNodeCache[elementHash] = {};
}
function _appendChild(newNode, referenceNode) {
    referenceNode.querySelector('div.viewport-element').appendChild(newNode);
}


/***/ }),

/***/ 68040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bl: () => (/* binding */ removeTool),
/* harmony export */   Gx: () => (/* binding */ addTool),
/* harmony export */   J2: () => (/* binding */ hasTool),
/* harmony export */   l$: () => (/* binding */ hasToolByName)
/* harmony export */ });
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function addTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName]) {
        _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] = {
            toolClass: ToolClass,
        };
    }
}
function hasTool(ToolClass) {
    const toolName = ToolClass.toolName;
    return !!(toolName && _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName]);
}
function hasToolByName(toolName) {
    return !!(toolName && _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName]);
}
function removeTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No tool found for: ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] !== undefined) {
        delete _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName];
    }
    else {
        throw new Error(`${toolName} cannot be removed because it has not been added`);
    }
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (addTool)));


/***/ }),

/***/ 91243:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ cancelActiveManipulations)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39848);
/* harmony import */ var _filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57725);



function cancelActiveManipulations(element) {
    const tools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(element, [
        _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Active,
        _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes.Passive,
    ]);
    const toolsWithData = (0,_filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(element, tools);
    for (const { tool } of toolsWithData) {
        const annotationUID = tool.cancel(element);
        if (annotationUID) {
            return annotationUID;
        }
    }
}


/***/ }),

/***/ 6657:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Synchronizer: () => (/* reexport safe */ _SynchronizerManager_Synchronizer__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   SynchronizerManager: () => (/* reexport module object */ _SynchronizerManager__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   ToolGroupManager: () => (/* reexport module object */ _ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   addEnabledElement: () => (/* reexport safe */ _addEnabledElement__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   addTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.Gx),
/* harmony export */   cancelActiveManipulations: () => (/* reexport safe */ _cancelActiveManipulations__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   hasTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.J2),
/* harmony export */   removeEnabledElement: () => (/* reexport safe */ _removeEnabledElement__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   removeTool: () => (/* reexport safe */ _addTool__WEBPACK_IMPORTED_MODULE_0__.Bl),
/* harmony export */   state: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_4__.Ay),
/* harmony export */   svgNodeCache: () => (/* reexport safe */ _svgNodeCache__WEBPACK_IMPORTED_MODULE_6__.A)
/* harmony export */ });
/* harmony import */ var _addTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68040);
/* harmony import */ var _addEnabledElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17221);
/* harmony import */ var _removeEnabledElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34222);
/* harmony import */ var _cancelActiveManipulations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91243);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85204);
/* harmony import */ var _SynchronizerManager_Synchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50749);
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48145);
/* harmony import */ var _ToolGroupManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77609);
/* harmony import */ var _SynchronizerManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(70741);












/***/ }),

/***/ 34222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _eventListeners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83638);
/* harmony import */ var _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3406);
/* harmony import */ var _filterToolsWithAnnotationsForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57725);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85204);
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39848);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99737);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6802);
/* harmony import */ var _SynchronizerManager_getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27851);
/* harmony import */ var _ToolGroupManager_getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(65136);
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(39011);











const VIEWPORT_ELEMENT = 'viewport-element';
function removeEnabledElement(elementDisabledEvt) {
    const { element, viewportId } = elementDisabledEvt.detail;
    _resetSvgNodeCache(element);
    _removeSvgNode(element);
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_10__/* .annotationRenderingEngine */ .o.removeViewportElement(viewportId, element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__/* .mouseEventListeners */ .bH.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__/* .wheelEventListener */ .CG.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__/* .touchEventListeners */ .F_.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__/* .keyEventListener */ .kt.disable(element);
    _eventListeners__WEBPACK_IMPORTED_MODULE_1__/* .imageChangeEventListener */ ._9.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .imageRenderedEventDispatcher */ .In.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .cameraModifiedEventDispatcher */ .aB.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .imageSpacingCalibratedEventDispatcher */ .z5.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .cameraResetEventDispatcher */ .we.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .mouseToolEventDispatcher */ .n6.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .keyboardToolEventDispatcher */ .V$.disable(element);
    _eventDispatchers__WEBPACK_IMPORTED_MODULE_2__/* .touchToolEventDispatcher */ .$m.disable(element);
    _removeViewportFromSynchronizers(element);
    _removeViewportFromToolGroup(element);
    _removeEnabledElement(element);
}
const _removeViewportFromSynchronizers = (element) => {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const synchronizers = (0,_SynchronizerManager_getSynchronizersForViewport__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(enabledElement.viewportId, enabledElement.renderingEngineId);
    synchronizers.forEach((sync) => {
        sync.remove(enabledElement);
    });
};
const _removeViewportFromToolGroup = (element) => {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = (0,_ToolGroupManager_getToolGroupForViewport__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportId, renderingEngineId);
    if (toolGroup) {
        toolGroup.removeViewports(renderingEngineId, viewportId);
    }
};
const _removeAllToolsForElement = function (element) {
    const tools = getToolsWithModesForElement(element, [
        ToolModes.Active,
        ToolModes.Passive,
    ]);
    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);
    toolsWithData.forEach(({ annotations }) => {
        annotations.forEach((annotation) => {
            removeAnnotation(annotation.annotationUID);
        });
    });
};
function _resetSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    delete _state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.svgNodeCache[elementHash];
}
function _removeSvgNode(element) {
    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);
    const svgLayer = internalViewportNode.querySelector('svg');
    if (svgLayer) {
        internalViewportNode.removeChild(svgLayer);
    }
}
const _removeEnabledElement = function (element) {
    const foundElementIndex = _state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.enabledElements.findIndex((el) => el === element);
    if (foundElementIndex > -1) {
        _state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.enabledElements.splice(foundElementIndex, 1);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeEnabledElement);


/***/ }),

/***/ 85204:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ state),
/* harmony export */   qh: () => (/* binding */ resetCornerstoneToolsState),
/* harmony export */   wk: () => (/* binding */ state)
/* harmony export */ });
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48145);

const defaultState = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
let state = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
function resetCornerstoneToolsState() {
    (0,_svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* .resetSvgNodeCache */ .e)();
    state = {
        ...structuredClone({
            ...defaultState,
            svgNodeCache: {},
        }),
        svgNodeCache: {
            ...defaultState.svgNodeCache,
        },
    };
}



/***/ }),

/***/ 48145:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   e: () => (/* binding */ resetSvgNodeCache)
/* harmony export */ });
let svgNodeCache = {};
function resetSvgNodeCache() {
    svgNodeCache = {};
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (svgNodeCache);


/***/ }),

/***/ 94195:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ areViewportsCoplanar)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function areViewportsCoplanar(viewport1, viewport2) {
    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();
    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();
    const dotProducts = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(viewPlaneNormal1, viewPlaneNormal2);
    return Math.abs(dotProducts) > 0.9;
}


/***/ }),

/***/ 67831:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ cameraSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {
    const { camera } = cameraModifiedEvent.detail;
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    tViewport.setCamera(camera);
    tViewport.render();
}


/***/ }),

/***/ 69877:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ imageSliceSyncCallback)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _areViewportsCoplanar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94195);



const getSpatialRegistration = (targetId, sourceId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);
async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    if (options?.disabled) {
        return;
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const imageId1 = sViewport.getCurrentImageId();
    const imagePlaneModule1 = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId1);
    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;
    const targetImageIds = tViewport.getImageIds();
    if (!(0,_areViewportsCoplanar__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(sViewport, tViewport)) {
        return;
    }
    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
    if (!registrationMatrixMat4) {
        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();
        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();
        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&
            options?.useInitialPosition !== false) {
            registrationMatrixMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.create */ .pB.create());
        }
        else {
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);
            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
        }
        if (!registrationMatrixMat4) {
            return;
        }
    }
    const targetImagePositionPatientWithRegistrationMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sourceImagePositionPatient, registrationMatrixMat4);
    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);
    let imageIndexToSet = closestImageIdIndex2.index;
    if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;
    }
    if (closestImageIdIndex2.index !== -1 &&
        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {
        await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.jumpToSlice(tViewport.element, {
            imageIndex: imageIndexToSet,
        });
    }
}
function _getClosestImageIdIndex(targetPoint, imageIds) {
    return imageIds.reduce((closestImageIdIndex, imageId, index) => {
        const { imagePositionPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(imagePositionPatient, targetPoint);
        if (distance < closestImageIdIndex.distance) {
            return {
                distance,
                index,
            };
        }
        return closestImageIdIndex;
    }, {
        distance: Infinity,
        index: -1,
    });
}


/***/ }),

/***/ 56553:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ presentationViewSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const presentationView = sViewport.getViewPresentation(options);
    tViewport.setViewPresentation(presentationView);
    tViewport.render();
}


/***/ }),

/***/ 9912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ slabThicknessSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const slabThickness = sViewport.getSlabThickness?.();
    if (!slabThickness) {
        return;
    }
    tViewport.setSlabThickness?.(slabThickness);
    tViewport.render();
}


/***/ }),

/***/ 14676:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ voiSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {
    const eventDetail = modifiedEvent.detail;
    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const tProperties = {
        voiRange: range,
    };
    if (options?.syncInvertState && invertStateChanged) {
        tProperties.invert = invert;
    }
    if (options?.syncColormap && colormap) {
        tProperties.colormap = colormap;
    }
    if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const isFusion = tViewport._actors && tViewport._actors.size > 1;
        if (isFusion) {
            tViewport.setProperties(tProperties, volumeId);
        }
        else {
            tViewport.setProperties(tProperties);
        }
    }
    else if (tViewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        tViewport.setProperties(tProperties);
    }
    else {
        throw new Error('Viewport type not supported.');
    }
    tViewport.render();
}


/***/ }),

/***/ 53308:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ zoomPanSyncCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    if (options?.syncZoom !== false) {
        const srcZoom = sViewport.getZoom();
        tViewport.setZoom(srcZoom);
    }
    if (options?.syncPan !== false) {
        const srcPan = sViewport.getPan();
        tViewport.setPan(srcPan);
    }
    tViewport.render();
}


/***/ }),

/***/ 34389:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCameraPositionSynchronizer: () => (/* reexport safe */ _synchronizers_createCameraPositionSynchronizer__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   createImageSliceSynchronizer: () => (/* reexport safe */ _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   createPresentationViewSynchronizer: () => (/* reexport safe */ _synchronizers_createPresentationViewSynchronizer__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   createSlabThicknessSynchronizer: () => (/* reexport safe */ _synchronizers_createSlabThicknessSynchronizer__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   createStackImageSynchronizer: () => (/* binding */ createStackImageSynchronizer),
/* harmony export */   createVOISynchronizer: () => (/* reexport safe */ _synchronizers_createVOISynchronizer__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   createZoomPanSynchronizer: () => (/* reexport safe */ _synchronizers_createZoomPanSynchronizer__WEBPACK_IMPORTED_MODULE_3__.A)
/* harmony export */ });
/* harmony import */ var _synchronizers_createCameraPositionSynchronizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90839);
/* harmony import */ var _synchronizers_createPresentationViewSynchronizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31130);
/* harmony import */ var _synchronizers_createVOISynchronizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32865);
/* harmony import */ var _synchronizers_createZoomPanSynchronizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3889);
/* harmony import */ var _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76266);
/* harmony import */ var _synchronizers_createSlabThicknessSynchronizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7137);






const createStackImageSynchronizer = _synchronizers_createImageSliceSynchronizer__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A;



/***/ }),

/***/ 90839:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createCameraPositionSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70741);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _callbacks_cameraSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67831);



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createCameraPositionSynchronizer(synchronizerName) {
    const cameraPositionSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_cameraSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);
    return cameraPositionSynchronizer;
}


/***/ }),

/***/ 76266:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createImageSliceSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70741);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _callbacks_imageSliceSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69877);



const { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createImageSliceSynchronizer(synchronizerName) {
    const stackImageSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, STACK_NEW_IMAGE, _callbacks_imageSliceSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, {
        auxiliaryEvents: [
            {
                name: 'VOLUME_NEW_IMAGE',
            },
        ],
    });
    return stackImageSynchronizer;
}


/***/ }),

/***/ 31130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createPresentationViewSynchronizer)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70741);
/* harmony import */ var _callbacks_presentationViewSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56553);



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName, options) {
    const presentationView = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_presentationViewSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, { viewPresentation: options });
    return presentationView;
}


/***/ }),

/***/ 7137:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createPresentationViewSynchronizer)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70741);
/* harmony import */ var _callbacks_slabThicknessSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9912);



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName) {
    const presentationView = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_1__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_slabThicknessSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);
    return presentationView;
}


/***/ }),

/***/ 32865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createVOISynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70741);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _callbacks_voiSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14676);



function createVOISynchronizer(synchronizerName, options) {
    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);
    const VOISynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events.VOI_MODIFIED, _callbacks_voiSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, {
        auxiliaryEvents: [
            {
                name: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events.COLORMAP_MODIFIED,
            },
        ],
        ...options,
    });
    return VOISynchronizer;
}


/***/ }),

/***/ 3889:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createZoomPanSynchronizer)
/* harmony export */ });
/* harmony import */ var _store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70741);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _callbacks_zoomPanSyncCallback__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53308);



const { CAMERA_MODIFIED } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums.Events;
function createZoomPanSynchronizer(synchronizerName) {
    const zoomPanSynchronizer = (0,_store_SynchronizerManager__WEBPACK_IMPORTED_MODULE_0__.createSynchronizer)(synchronizerName, CAMERA_MODIFIED, _callbacks_zoomPanSyncCallback__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);
    return zoomPanSynchronizer;
}


/***/ }),

/***/ 45152:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AdvancedMagnifyTool)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(58640);
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(77081);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3823);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(77609);
/* harmony import */ var _utilities_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(52905);
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(82216);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(44595);


















const MAGNIFY_CLASSNAME = 'advancedMagnifyTool';
const MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;
const { Events: csEvents } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums;
const isSegmentation = (actor) => actor.uid !== actor.referencedId;
var AdvancedMagnifyToolActions;
(function (AdvancedMagnifyToolActions) {
    AdvancedMagnifyToolActions["ShowZoomFactorsList"] = "showZoomFactorsList";
})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));
const ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';
const PARALLEL_THRESHOLD = 1 - _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.EPSILON;
class AdvancedMagnifyTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    static { this.Actions = AdvancedMagnifyToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            magnifyingGlass: {
                radius: 125,
                zoomFactor: 3,
                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],
                autoPan: {
                    enabled: true,
                    padding: 10,
                },
            },
            actions: {
                showZoomFactorsList: {
                    method: 'showZoomFactorsList',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_8__.MouseBindings.Secondary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_8__.KeyboardBindings.Shift,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const { magnifyingGlass: config } = this.configuration;
            const { radius, zoomFactor, autoPan } = config;
            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
            const magnifyViewportId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    sourceViewportId: viewport.id,
                    magnifyViewportId,
                    zoomFactor,
                    isCanvasAnnotation: true,
                    handles: {
                        points: canvasHandlePoints,
                        activeHandleIndex: null,
                    },
                },
            };
            this.magnifyViewportManager.createViewport(annotation, {
                magnifyViewportId,
                sourceEnabledElement: enabledElement,
                position: canvasPos,
                radius,
                zoomFactor,
                autoPan: {
                    enabled: autoPan.enabled,
                    padding: autoPan.padding,
                    callback: (data) => {
                        const annotationPoints = annotation.data.handles.points;
                        const { canvas: canvasDelta } = data.delta;
                        for (let i = 0, len = annotationPoints.length; i < len; i++) {
                            const point = annotationPoints[i];
                            point[0] += canvasDelta[0];
                            point[1] += canvasDelta[1];
                            annotation.invalidated = true;
                        }
                    },
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.onSetToolDisabled = () => {
            this.magnifyViewportManager.dispose();
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAllAnnotations)();
            annotations.forEach((annotation) => {
                if (annotation.metadata.toolName === this.getToolName()) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
                }
            });
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const center = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const radiusPoint = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radiusPoint - radius) < proximity * 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            this._activateModify(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { deltaPoints } = eventDetail;
            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];
            const { annotation, viewportIdsToRender } = this.editData;
            const { points } = annotation.data.handles;
            points.forEach((point) => {
                point[0] += canvasDelta[0];
                point[1] += canvasDelta[1];
            });
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const canvasDelta = deltaPoints.canvas;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += canvasDelta[0];
                    point[1] += canvasDelta[1];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const canvasCenter = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const newRadius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_12__.getCanvasCircleRadius)([
                canvasCenter,
                currentCanvasPoints,
            ]);
            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);
            points[0] = newCanvasHandlePoints[0];
            points[1] = newCanvasHandlePoints[1];
            points[2] = newCanvasHandlePoints[2];
            points[3] = newCanvasHandlePoints[3];
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===
                viewport.id);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!filteredAnnotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < filteredAnnotations.length; i++) {
                const annotation = filteredAnnotations[i];
                const { annotationUID, data } = annotation;
                const { magnifyViewportId, zoomFactor, handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points;
                const canvasTop = canvasCoordinates[0];
                const canvasBottom = canvasCoordinates[2];
                const canvasLeft = canvasCoordinates[3];
                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
                const center = [
                    canvasLeft[0] + radius,
                    canvasTop[1] + radius,
                ];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_4__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-advancedMagnify`;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineWidth: 5,
                }, dataId);
                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);
                magnifyViewport.position = center;
                magnifyViewport.radius = radius;
                magnifyViewport.zoomFactor = zoomFactor;
                magnifyViewport.update();
                renderStatus = true;
            }
            return renderStatus;
        };
        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {
            return [
                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],
                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],
                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],
                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],
            ];
        };
        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();
    }
    showZoomFactorsList(evt, annotation) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvas: canvasPoint } = currentPoints;
        const viewportElement = element.querySelector(':scope .viewport-element');
        const currentZoomFactor = annotation.data.zoomFactor;
        const remove = () => dropdown.parentElement.removeChild(dropdown);
        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {
            if (newZoomFactor !== undefined) {
                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);
                annotation.invalidated = true;
            }
            remove();
            viewport.render();
        });
        Object.assign(dropdown.style, {
            left: `${canvasPoint[0]}px`,
            top: `${canvasPoint[1]}px`,
        });
        viewportElement.appendChild(dropdown);
        dropdown.focus();
    }
    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {
        const { zoomFactorList } = this.configuration.magnifyingGlass;
        const dropdown = document.createElement('select');
        dropdown.size = 5;
        Object.assign(dropdown.style, {
            width: '50px',
            position: 'absolute',
        });
        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {
            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());
        });
        dropdown.addEventListener('change', (evt) => {
            evt.stopPropagation();
            onChangeCallback(dropdown.value);
        });
        dropdown.addEventListener('keydown', (evt) => {
            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||
                evt.key?.toLowerCase() === 'escape';
            if (shouldCancel) {
                evt.stopPropagation();
                onChangeCallback();
            }
        });
        zoomFactorList.forEach((zoomFactor) => {
            const option = document.createElement('option');
            option.label = zoomFactor;
            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;
            option.value = zoomFactor;
            option.defaultSelected = zoomFactor === currentZoomFactor;
            dropdown.add(option);
        });
        return dropdown;
    }
}
class AdvancedMagnifyViewportManager {
    constructor() {
        this.createViewport = (annotation, viewportInfo) => {
            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;
            const { viewport: sourceViewport } = sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            const magnifyViewport = new AdvancedMagnifyViewport({
                magnifyViewportId,
                sourceEnabledElement,
                radius,
                position,
                zoomFactor,
                autoPan,
            });
            this._addSourceElementEventListener(sourceElement);
            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {
                annotation,
                magnifyViewport,
                magnifyViewportInfo: viewportInfo,
            });
            return magnifyViewport;
        };
        this._annotationRemovedCallback = (evt) => {
            const { annotation } = evt.detail;
            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {
                return;
            }
            this.destroyViewport(annotation.data.magnifyViewportId);
        };
        this._newStackImageCallback = (evt) => {
            const { viewportId: sourceViewportId, imageId } = evt.detail;
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId);
            if (viewport.stackActorReInitialized) {
                this._reset(sourceViewportId);
            }
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                annotation.metadata.referencedImageId = imageId;
                annotation.invalidated = true;
            });
        };
        this._newVolumeImageCallback = (evt) => {
            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
            const sourceViewport = renderingEngine.getViewport(sourceViewportId);
            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                const { viewPlaneNormal } = annotation.metadata;
                const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.dot */ .eR.dot(viewPlaneNormal, currentViewPlaneNormal)) >
                    PARALLEL_THRESHOLD;
                if (!isParallel) {
                    return;
                }
                const { handles } = annotation.data;
                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);
                const vecHandleToImagePlane = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.create */ .eR.create(), worldImagePlanePoint, handles.points[0]);
                const worldDist = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.dot */ .eR.dot(vecHandleToImagePlane, currentViewPlaneNormal);
                const worldDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.scale */ .eR.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.create */ .eR.create(), currentViewPlaneNormal, worldDist);
                for (let i = 0, len = handles.points.length; i < len; i++) {
                    const point = handles.points[i];
                    point[0] += worldDelta[0];
                    point[1] += worldDelta[1];
                    point[2] += worldDelta[2];
                }
                annotation.invalidated = true;
            });
        };
        this._magnifyViewportsMap = new Map();
        this._initialize();
    }
    static getInstance() {
        AdvancedMagnifyViewportManager._singleton =
            AdvancedMagnifyViewportManager._singleton ??
                new AdvancedMagnifyViewportManager();
        return AdvancedMagnifyViewportManager._singleton;
    }
    getViewport(magnifyViewportId) {
        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;
    }
    dispose() {
        this._removeEventListeners();
        this._destroyViewports();
    }
    destroyViewport(magnifyViewportId) {
        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);
        if (magnifyViewportMapEntry) {
            const { magnifyViewport } = magnifyViewportMapEntry;
            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            this._removeSourceElementEventListener(sourceElement);
            magnifyViewport.dispose();
            this._magnifyViewportsMap.delete(magnifyViewportId);
        }
    }
    _destroyViewports() {
        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());
        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));
    }
    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {
        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());
        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {
            const { viewport } = magnifyViewport.sourceEnabledElement;
            return viewport.id === sourceViewportId;
        });
    }
    _reset(sourceViewportId) {
        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {
            this.destroyViewport(magnifyViewport.viewportId);
            const newEnabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId);
            this.createViewport(annotation, {
                ...magnifyViewportInfo,
                sourceEnabledElement: {
                    ...newEnabledElement,
                },
            });
        });
    }
    _addEventListeners() {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _removeEventListeners() {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _addSourceElementEventListener(element) {
        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        const newStackHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
        const newVolumeHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);
        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.newStackHandler = newStackHandler;
        element.newVolumeHandler = newVolumeHandler;
    }
    _removeSourceElementEventListener(element) {
        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);
        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);
        delete element.newStackHandler;
        delete element.newVolumeHandler;
    }
    _initialize() {
        this._addEventListeners();
    }
}
class AdvancedMagnifyViewport {
    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {
        this._enabledElement = null;
        this._sourceToolGroup = null;
        this._magnifyToolGroup = null;
        this._isViewportReady = false;
        this._radius = 0;
        this._resized = false;
        this._canAutoPan = false;
        this._viewportId = magnifyViewportId ?? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4();
        this._sourceEnabledElement = sourceEnabledElement;
        this._autoPan = autoPan;
        this.radius = radius;
        this.position = position;
        this.zoomFactor = zoomFactor;
        this.visible = true;
        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);
        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);
        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);
        this._mouseDragCallback = this._mouseDragCallback.bind(this);
        this._resizeViewportAsync = ((0,_utilities_debounce__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(this._resizeViewport.bind(this), 1));
        this._initialize();
    }
    get sourceEnabledElement() {
        return this._sourceEnabledElement;
    }
    get viewportId() {
        return this._viewportId;
    }
    get radius() {
        return this._radius;
    }
    set radius(radius) {
        if (Math.abs(this._radius - radius) > 0.00001) {
            this._radius = radius;
            this._resized = true;
        }
    }
    update() {
        const { radius, position, visible } = this;
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const size = 2 * radius;
        const [x, y] = position;
        if (this._resized) {
            this._resizeViewportAsync();
            this._resized = false;
        }
        Object.assign(element.style, {
            display: visible ? 'block' : 'hidden',
            width: `${size}px`,
            height: `${size}px`,
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(${x}px, ${y}px)`,
        });
        if (this._isViewportReady) {
            this._syncViewports();
            viewport.render();
        }
    }
    dispose() {
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const renderingEngine = viewport.getRenderingEngine();
        this._removeEventListeners(element);
        renderingEngine.disableElement(viewport.id);
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
    _handleToolModeChanged(evt) {
        const { _magnifyToolGroup: magnifyToolGroup } = this;
        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;
        if (this._sourceToolGroup?.id !== toolGroupId) {
            return;
        }
        switch (mode) {
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Active:
                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Passive:
                magnifyToolGroup.setToolPassive(toolName);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Enabled:
                magnifyToolGroup.setToolEnabled(toolName);
                break;
            case _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Disabled:
                magnifyToolGroup.setToolDisabled(toolName);
                break;
            default:
                throw new Error(`Unknow tool mode (${mode})`);
        }
    }
    _inheritBorderRadius(magnifyElement) {
        const viewport = magnifyElement.querySelector('.viewport-element');
        const canvas = magnifyElement.querySelector('.cornerstone-canvas');
        viewport.style.borderRadius = 'inherit';
        canvas.style.borderRadius = 'inherit';
    }
    _createViewportNode() {
        const magnifyElement = document.createElement('div');
        const { radius } = this;
        const size = radius * 2;
        magnifyElement.classList.add(MAGNIFY_CLASSNAME);
        Object.assign(magnifyElement.style, {
            display: 'block',
            width: `${size}px`,
            height: `${size}px`,
            position: 'absolute',
            overflow: 'hidden',
            borderRadius: '50%',
            boxSizing: 'border-box',
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(-1000px, -1000px)`,
        });
        return magnifyElement;
    }
    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {
        const { parallelScale } = viewport.getCamera();
        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;
        return parallelScale * (1 / zoomFactor) * canvasRatio;
    }
    _isStackViewport(viewport) {
        return 'setStack' in viewport;
    }
    _isVolumeViewport(viewport) {
        return 'addVolumes' in viewport;
    }
    _cloneToolGroups(sourceViewport, magnifyViewport) {
        const sourceActors = sourceViewport.getActors();
        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;
        const sourceToolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_14__.getToolGroupForViewport)(sourceViewport.id, sourceViewport.renderingEngineId);
        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {
            const toolInstance = sourceToolGroup.getToolInstance(toolName);
            const isAnnotationTool = toolInstance instanceof _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC &&
                !(toolInstance instanceof AdvancedMagnifyTool);
            return isAnnotationTool;
        });
        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);
        sourceActors.filter(isSegmentation).forEach((actor) => {
            (0,_stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_17__.addSegmentationRepresentations)(this.viewportId, [
                {
                    segmentationId: actor.referencedId,
                    type: _enums__WEBPACK_IMPORTED_MODULE_8__.SegmentationRepresentations.Labelmap,
                },
            ]);
        });
        return { sourceToolGroup, magnifyToolGroup };
    }
    _cloneStack(sourceViewport, magnifyViewport) {
        const imageIds = sourceViewport.getImageIds();
        magnifyViewport.setStack(imageIds).then(() => {
            this._isViewportReady = true;
            this.update();
        });
    }
    _cloneVolumes(sourceViewport, magnifyViewport) {
        const actors = sourceViewport.getActors();
        const volumeInputArray = actors
            .filter((actor) => !isSegmentation(actor))
            .map((actor) => ({ volumeId: actor.uid }));
        magnifyViewport.setVolumes(volumeInputArray).then(() => {
            this._isViewportReady = true;
            this.update();
        });
        return magnifyViewport;
    }
    _cloneViewport(sourceViewport, magnifyElement) {
        const { viewportId: magnifyViewportId } = this;
        const renderingEngine = sourceViewport.getRenderingEngine();
        const { options: sourceViewportOptions } = sourceViewport;
        const viewportInput = {
            element: magnifyElement,
            viewportId: magnifyViewportId,
            type: sourceViewport.type,
            defaultOptions: { ...sourceViewportOptions },
        };
        renderingEngine.enableElement(viewportInput);
        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));
        if (this._isStackViewport(sourceViewport)) {
            this._cloneStack(sourceViewport, magnifyViewport);
        }
        else if (this._isVolumeViewport(sourceViewport)) {
            this._cloneVolumes(sourceViewport, magnifyViewport);
        }
        this._inheritBorderRadius(magnifyElement);
        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);
        this._sourceToolGroup = toolGroups.sourceToolGroup;
        this._magnifyToolGroup = toolGroups.magnifyToolGroup;
    }
    _cancelMouseEventCallback(evt) {
        evt.stopPropagation();
        evt.preventDefault();
    }
    _browserMouseUpCallback(evt) {
        const { element } = this._enabledElement.viewport;
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _browserMouseDownCallback(evt) {
        const { element } = this._enabledElement.viewport;
        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');
        document.addEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _mouseDragCallback(evt) {
        if (!_store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool) {
            return;
        }
        const { _autoPan: autoPan } = this;
        if (!autoPan.enabled || !this._canAutoPan) {
            return;
        }
        const { currentPoints } = evt.detail;
        const { viewport } = this._enabledElement;
        const { canvasToWorld } = viewport;
        const { canvas: canvasCurrent } = currentPoints;
        const { radius: magnifyRadius } = this;
        const canvasCenter = [magnifyRadius, magnifyRadius];
        const dist = (0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_16__.distanceToPoint)(canvasCenter, canvasCurrent);
        const maxDist = magnifyRadius - autoPan.padding;
        if (dist <= maxDist) {
            return;
        }
        const panDist = dist - maxDist;
        const canvasDeltaPos = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.sub */ .Zc.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.create */ .Zc.create(), canvasCurrent, canvasCenter);
        gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.normalize */ .Zc.normalize(canvasDeltaPos, canvasDeltaPos);
        gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.scale */ .Zc.scale(canvasDeltaPos, canvasDeltaPos, panDist);
        const newCanvasPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.add */ .Zc.add(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec2.create */ .Zc.create(), this.position, canvasDeltaPos);
        const currentWorldPos = canvasToWorld(this.position);
        const newWorldPos = canvasToWorld(newCanvasPosition);
        const worldDeltaPos = gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_13__/* .vec3.create */ .eR.create(), newWorldPos, currentWorldPos);
        const autoPanCallbackData = {
            points: {
                currentPosition: {
                    canvas: this.position,
                    world: currentWorldPos,
                },
                newPosition: {
                    canvas: newCanvasPosition,
                    world: newWorldPos,
                },
            },
            delta: {
                canvas: canvasDeltaPos,
                world: worldDeltaPos,
            },
        };
        autoPan.callback(autoPanCallbackData);
    }
    _addBrowserEventListeners(element) {
        document.addEventListener('mousedown', this._browserMouseDownCallback, true);
        element.addEventListener('mousedown', this._cancelMouseEventCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
        element.addEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _removeBrowserEventListeners(element) {
        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mousedown', this._cancelMouseEventCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
        element.removeEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _addEventListeners(element) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._addBrowserEventListeners(element);
    }
    _removeEventListeners(element) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._removeBrowserEventListeners(element);
    }
    _initialize() {
        const { _sourceEnabledElement: sourceEnabledElement } = this;
        const { viewport: sourceViewport } = sourceEnabledElement;
        const { canvas: sourceCanvas } = sourceViewport;
        const magnifyElement = this._createViewportNode();
        sourceCanvas.parentNode.appendChild(magnifyElement);
        this._addEventListeners(magnifyElement);
        this._cloneViewport(sourceViewport, magnifyElement);
        this._enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(magnifyElement);
    }
    _syncViewportsCameras(sourceViewport, magnifyViewport) {
        const worldPos = sourceViewport.canvasToWorld(this.position);
        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);
        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
            Math.pow(focalPoint[1] - position[1], 2) +
            Math.pow(focalPoint[2] - position[2], 2));
        const updatedFocalPoint = [
            worldPos[0],
            worldPos[1],
            worldPos[2],
        ];
        const updatedPosition = [
            updatedFocalPoint[0] + distance * viewPlaneNormal[0],
            updatedFocalPoint[1] + distance * viewPlaneNormal[1],
            updatedFocalPoint[2] + distance * viewPlaneNormal[2],
        ];
        magnifyViewport.setCamera({
            parallelScale,
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
    }
    _syncStackViewports(sourceViewport, magnifyViewport) {
        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());
    }
    _syncViewports() {
        const { viewport: sourceViewport } = this._sourceEnabledElement;
        const { viewport: magnifyViewport } = this._enabledElement;
        const sourceProperties = sourceViewport.getProperties();
        const imageData = magnifyViewport.getImageData();
        if (!imageData) {
            return;
        }
        magnifyViewport.setProperties(sourceProperties);
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        if (this._isStackViewport(sourceViewport)) {
            this._syncStackViewports(sourceViewport, magnifyViewport);
        }
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        magnifyViewport.render();
    }
    _resizeViewport() {
        const { viewport } = this._enabledElement;
        const renderingEngine = viewport.getRenderingEngine();
        renderingEngine.resize();
    }
}
AdvancedMagnifyTool.toolName = 'AdvancedMagnify';



/***/ }),

/***/ 68760:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17343);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77609);




class AnnotationEraserTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'mouse');
        };
        this.preTouchStartCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'touch');
        };
    }
    _deleteNearbyAnnotations(evt, interactionType) {
        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(viewportId, renderingEngineId);
        if (!toolGroup) {
            return false;
        }
        const tools = toolGroup._toolInstances;
        const annotationsToRemove = [];
        for (const toolName in tools) {
            const toolInstance = tools[toolName];
            if (typeof toolInstance.isPointNearTool !== 'function' ||
                typeof toolInstance.filterInteractableAnnotationsForElement !==
                    'function') {
                continue;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(toolName, element);
            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);
            if (!interactableAnnotations) {
                continue;
            }
            for (const annotation of interactableAnnotations) {
                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {
                    annotationsToRemove.push(annotation.annotationUID);
                }
            }
        }
        for (const annotationUID of annotationsToRemove) {
            (0,_stateManagement_annotation_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.setAnnotationSelected)(annotationUID);
            const annotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotation)(annotationUID);
            _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC.createAnnotationMemo(element, annotation, {
                deleting: true,
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.removeAnnotation)(annotationUID);
        }
        evt.preventDefault();
        return true;
    }
}
AnnotationEraserTool.toolName = 'Eraser';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationEraserTool);


/***/ }),

/***/ 14840:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84607);
/* harmony import */ var _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89265);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15327);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77609);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(35381);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(15305);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(2076);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(58640);
















const { RENDERING_DEFAULTS } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.CONSTANTS;
function defaultReferenceLineColor() {
    return 'rgb(0, 200, 0)';
}
function defaultReferenceLineControllable() {
    return true;
}
function defaultReferenceLineDraggableRotatable() {
    return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
    return true;
}
const OPERATION = {
    DRAG: 1,
    ROTATE: 2,
    SLAB: 3,
};
const EPSILON = 1e-3;
class CrosshairsTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse'],
        configuration: {
            shadow: true,
            viewportIndicators: false,
            viewportIndicatorsConfig: {
                radius: 5,
                x: null,
                y: null,
            },
            autoPan: {
                enabled: false,
                panSize: 10,
            },
            handleRadius: 3,
            enableHDPIHandles: false,
            referenceLinesCenterGapRadius: 20,
            filterActorUIDsToSetSlabThickness: [],
            slabThicknessBlendMode: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
            mobile: {
                enabled: false,
                opacity: 0.8,
                handleRadius: 9,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.toolCenter = [0, 0, 0];
        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { FrameOfReferenceUID, viewport } = enabledElement;
            const { element } = viewport;
            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
            let annotations = this._getAnnotations(enabledElement);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (annotations?.length) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotations[0].annotationUID);
            }
            const annotation = {
                highlighted: false,
                metadata: {
                    cameraPosition: [...position],
                    cameraFocalPoint: [...focalPoint],
                    FrameOfReferenceUID,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        rotationPoints: [],
                        slabThicknessPoints: [],
                        toolCenter: this.toolCenter,
                    },
                    activeOperation: null,
                    activeViewportIds: [],
                    viewportId,
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.addAnnotation)(annotation, element);
            return {
                normal: viewPlaneNormal,
                point: viewport.canvasToWorld([
                    viewport.canvas.clientWidth / 2,
                    viewport.canvas.clientHeight / 2,
                ]),
            };
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resetCrosshairs = () => {
            const viewportsInfo = this._getViewportsInfo();
            for (const viewportInfo of viewportsInfo) {
                const { viewportId, renderingEngineId } = viewportInfo;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const viewport = enabledElement.viewport;
                const resetPan = true;
                const resetZoom = true;
                const resetToCenter = true;
                const resetRotation = true;
                const suppressEvents = true;
                viewport.resetCamera({
                    resetPan,
                    resetZoom,
                    resetToCenter,
                    resetRotation,
                    suppressEvents,
                });
                viewport.resetSlabThickness();
                const { element } = viewport;
                let annotations = this._getAnnotations(enabledElement);
                annotations = this.filterInteractableAnnotationsForElement(element, annotations);
                if (annotations.length) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotations[0].annotationUID);
                }
                viewport.render();
            }
            this._computeToolCenter(viewportsInfo);
        };
        this.computeToolCenter = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._computeToolCenter = (viewportsInfo) => {
            if (!viewportsInfo.length || viewportsInfo.length === 1) {
                console.warn('For crosshairs to operate, at least two viewports must be given.');
                return;
            }
            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
            let normal3 = [0, 0, 0];
            let point3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
            if (thirdViewport) {
                ({ normal: normal3, point: point3 } =
                    this.initializeViewport(thirdViewport));
            }
            else {
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(point3, point1, point2);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(point3, point3, 0.5);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(normal3, normal1, normal2);
            }
            const firstPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal1, point1);
            const secondPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal2, point2);
            const thirdPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.planeEquation(normal3, point3);
            const toolCenter = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
            this.setToolCenter(toolCenter);
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const jumpWorld = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this._jump(enabledElement, jumpWorld);
            const annotations = this._getAnnotations(enabledElement);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
            const { data } = filteredAnnotations[0];
            const { rotationPoints } = data.handles;
            const viewportIdArray = [];
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                if (!viewportControllable || !viewportDraggableRotatable) {
                    continue;
                }
                viewportIdArray.push(otherViewport.id);
                i++;
            }
            data.activeViewportIds = [...viewportIdArray];
            data.handles.activeOperation = OPERATION.DRAG;
            evt.preventDefault();
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this._activateModify(element);
            return filteredAnnotations[0];
        };
        this.cancel = () => {
            console.log('Not implemented yet');
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const viewport = enabledElement.viewport;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const currentCamera = viewport.getCamera();
            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
            const deltaCameraPosition = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
            viewportAnnotation.metadata.cameraFocalPoint = [
                ...currentCamera.focalPoint,
            ];
            const viewportControllable = this._getReferenceLineControllable(viewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&
                viewportControllable &&
                viewportDraggableRotatable) {
                let isRotation = false;
                const cameraModifiedSameForPosAndFocalPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
                if (!cameraModifiedSameForPosAndFocalPoint) {
                    isRotation = true;
                }
                const cameraModifiedInPlane = Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;
                if (!isRotation && !cameraModifiedInPlane) {
                    this.toolCenter[0] += deltaCameraPosition[0];
                    this.toolCenter[1] += deltaCameraPosition[1];
                    this.toolCenter[2] += deltaCameraPosition[2];
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_9__.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                        toolGroupId: this.toolGroupId,
                        toolCenter: this.toolCenter,
                    });
                }
            }
            if (this.configuration.autoPan?.enabled) {
                const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroupForViewport)(viewport.id, renderingEngine.id);
                const otherViewportIds = toolGroup
                    .getViewportIds()
                    .filter((id) => id !== viewport.id);
                otherViewportIds.forEach((viewportId) => {
                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);
                });
            }
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.onResetCamera = (evt) => {
            this.resetCrosshairs();
        };
        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let imageNeedsUpdate = false;
            for (let i = 0; i < filteredToolAnnotations.length; i++) {
                const annotation = filteredToolAnnotations[i];
                if ((0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_14__.isAnnotationLocked)(annotation.annotationUID)) {
                    continue;
                }
                const { data, highlighted } = annotation;
                if (!data.handles) {
                    continue;
                }
                const previousActiveOperation = data.handles.activeOperation;
                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0
                    ? [...data.activeViewportIds]
                    : [];
                data.activeViewportIds = [];
                data.handles.activeOperation = null;
                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
                let near = false;
                if (handleNearImagePoint) {
                    near = true;
                }
                else {
                    near = this._pointNearTool(element, annotation, canvasCoords, 6);
                }
                const nearToolAndNotMarkedActive = near && !highlighted;
                const notNearToolAndMarkedActive = !near && highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !highlighted;
                    imageNeedsUpdate = true;
                }
                else if (data.handles.activeOperation !== previousActiveOperation ||
                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
                    imageNeedsUpdate = true;
                }
            }
            return imageNeedsUpdate;
        };
        this.filterInteractableAnnotationsForElement = (element, annotations) => {
            if (!annotations || !annotations.length) {
                return [];
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { viewportId } = enabledElement;
            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
            return viewportUIDSpecificCrosshairs;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, renderingEngine } = enabledElement;
            const { element } = viewport;
            const annotations = this._getAnnotations(enabledElement);
            const camera = viewport.getCamera();
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!annotations?.length || !viewportAnnotation?.data) {
                return renderStatus;
            }
            const annotationUID = viewportAnnotation.annotationUID;
            const { clientWidth, clientHeight } = viewport.canvas;
            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);
            const data = viewportAnnotation.data;
            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
            const referenceLines = [];
            const canvasBox = [0, 0, clientWidth, clientHeight];
            otherViewportAnnotations.forEach((annotation) => {
                const { data } = annotation;
                data.handles.toolCenter = this.toolCenter;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                const { clientWidth, clientHeight } = otherViewport.canvas;
                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                const otherCanvasCenter = [
                    clientWidth * 0.5,
                    clientHeight * 0.5,
                ];
                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
                const direction = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].cross */ .Ay.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(direction);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(direction, otherCanvasDiagonalLength);
                const pointWorld0 = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(otherViewportCenterWorld, direction, pointWorld0);
                const pointWorld1 = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(otherViewportCenterWorld, direction, pointWorld1);
                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
                const canvasUnitVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
                const canvasVectorFromCenterLong = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
                const canvasVectorFromCenterMid = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);
                const canvasVectorFromCenterShort = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);
                const canvasVectorFromCenterStart = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const centerGap = this.configuration.referenceLinesCenterGapRadius;
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);
                const refLinePointOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const refLinePointTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const refLinePointThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const refLinePointFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                let refLinesCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.clone */ .Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable || !otherViewportControllable) {
                    refLinesCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.clone */ .Zc.clone(otherViewportCenterCanvas);
                }
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(refLinePointOne, refLinePointTwo, canvasBox);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(refLinePointThree, refLinePointFour, canvasBox);
                const rotHandleOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
                const rotHandleTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
                let stHandlesCenterCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.clone */ .Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.clone */ .Zc.clone(otherViewportCenterCanvas);
                }
                let stHandlesCenterWorld = [...this.toolCenter];
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterWorld = [...otherViewportCenterWorld];
                }
                const worldUnitVectorFromCenter = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(worldUnitVectorFromCenter);
                const { viewPlaneNormal } = camera;
                const { matrix } = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A
                    .buildFromDegree()
                    .rotate(90, viewPlaneNormal);
                const worldUnitOrthoVectorFromCenter = [0, 0, 0];
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
                const slabThicknessValue = otherViewport.getSlabThickness();
                const worldOrthoVectorFromCenter = [
                    ...worldUnitOrthoVectorFromCenter,
                ];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
                const worldVerticalRefPoint = [0, 0, 0];
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
                const canvasOrthoVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
                const stLinePointOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
                const stLinePointTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(stLinePointOne, stLinePointTwo, canvasBox);
                const stLinePointThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
                const stLinePointFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
                (0,_utilities_math_vec2_liangBarksyClip__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(stLinePointThree, stLinePointFour, canvasBox);
                const stHandleOne = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const stHandleTwo = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const stHandleThree = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const stHandleFour = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
                referenceLines.push([
                    otherViewport,
                    refLinePointOne,
                    refLinePointTwo,
                    refLinePointThree,
                    refLinePointFour,
                    stLinePointOne,
                    stLinePointTwo,
                    stLinePointThree,
                    stLinePointFour,
                    rotHandleOne,
                    rotHandleTwo,
                    stHandleOne,
                    stHandleTwo,
                    stHandleThree,
                    stHandleFour,
                ]);
            });
            const newRtpoints = [];
            const newStpoints = [];
            const viewportColor = this._getReferenceLineColor(viewport.id);
            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
            referenceLines.forEach((line, lineIndex) => {
                const otherViewport = line[0];
                const viewportColor = this._getReferenceLineColor(otherViewport.id);
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                let lineWidth = 1;
                const lineActive = data.handles.activeOperation !== null &&
                    data.handles.activeOperation === OPERATION.DRAG &&
                    selectedViewportId;
                if (lineActive) {
                    lineWidth = 2.5;
                }
                let lineUID = `${lineIndex}`;
                if (viewportControllable && viewportDraggableRotatable) {
                    lineUID = `${lineIndex}One`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
                        color,
                        lineWidth,
                    });
                    lineUID = `${lineIndex}Two`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
                        color,
                        lineWidth,
                    });
                }
                else {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
                        color,
                        lineWidth,
                    });
                }
                if (viewportControllable) {
                    color =
                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;
                    const rotationHandles = [line[9], line[10]];
                    const rotHandleWorldOne = [
                        viewport.canvasToWorld(line[9]),
                        otherViewport,
                        line[1],
                        line[2],
                    ];
                    const rotHandleWorldTwo = [
                        viewport.canvasToWorld(line[10]),
                        otherViewport,
                        line[3],
                        line[4],
                    ];
                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;
                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
                    const slabThicknessHandleWorldOne = [
                        viewport.canvasToWorld(line[11]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldTwo = [
                        viewport.canvasToWorld(line[12]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldThree = [
                        viewport.canvasToWorld(line[13]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    const slabThicknessHandleWorldFour = [
                        viewport.canvasToWorld(line[14]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
                    let handleRadius = this.configuration.handleRadius *
                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);
                    let opacity = 1;
                    if (this.configuration.mobile?.enabled) {
                        handleRadius = this.configuration.mobile.handleRadius;
                        opacity = this.configuration.mobile.opacity;
                    }
                    if ((lineActive || this.configuration.mobile?.enabled) &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable &&
                        viewportSlabThicknessControlsOn) {
                        let handleUID = `${lineIndex}One`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                        handleUID = `${lineIndex}Two`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (lineActive &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                    }
                    else if (selectedViewportId &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportSlabThicknessControlsOn) {
                        const handleUID = `${lineIndex}`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (rotHandlesActive && viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'circle',
                        });
                    }
                    else if (slabThicknessHandlesActive &&
                        selectedViewportId &&
                        viewportSlabThicknessControlsOn) {
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawHandles)(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'rect',
                        });
                    }
                    const slabThicknessValue = otherViewport.getSlabThickness();
                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
                        lineUID = `${lineIndex}STOne`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
                            color,
                            width: 1,
                            lineDash: [2, 3],
                        });
                        lineUID = `${lineIndex}STTwo`;
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
                            color,
                            width: line,
                            lineDash: [2, 3],
                        });
                    }
                }
            });
            renderStatus = true;
            data.handles.rotationPoints = newRtpoints;
            data.handles.slabThicknessPoints = newStpoints;
            if (this.configuration.viewportIndicators) {
                const { viewportIndicatorsConfig } = this.configuration;
                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;
                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;
                const referenceColorCoordinates = [
                    clientWidth * xOffset,
                    clientHeight * yOffset,
                ];
                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
            }
            return renderStatus;
        };
        this._getAnnotations = (enabledElement) => {
            const { viewport } = enabledElement;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.getAnnotations)(this.getToolName(), viewport.element) || [];
            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
            const toolGroupAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                return viewportIds.includes(data.viewportId);
            });
            return toolGroupAnnotations;
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
                return false;
            }
            viewportIdArrayOne.forEach((id) => {
                let itemFound = false;
                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
                    if (id === viewportIdArrayTwo[i]) {
                        itemFound = true;
                        break;
                    }
                }
                if (itemFound === false) {
                    return false;
                }
            });
            return true;
        };
        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
            const { viewportId, renderingEngine, viewport } = enabledElement;
            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const { viewPlaneNormal, position } = camera;
            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const targetViewport = renderingEngine.getViewport(viewportId);
                const cameraOfTarget = targetViewport.getCamera();
                return !(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfTarget.position, position, 1));
            });
            return viewportsWithDifferentCameras;
        };
        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
            const { renderingEngine } = enabledElement;
            const { data } = referenceAnnotation;
            const viewport = renderingEngine.getViewport(data.viewportId);
            const linkedViewportAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return otherViewportControllable === true;
            });
            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(viewPlaneNormal);
            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(otherViewPlaneNormal);
                return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));
            });
            return otherViewportsAnnotationsWithSameCameraDirection;
        };
        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
            const { renderingEngine, viewport } = enabledElement;
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(viewPlaneNormal);
            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable === true);
            });
            const otherViewportsAnnotationsWithUniqueCameras = [];
            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable !== true);
            });
            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            for (let i = 0; i < otherViewportAnnotations.length; ++i) {
                const annotation = otherViewportAnnotations[i];
                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {
                    continue;
                }
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Ay.normalize(otherViewPlaneNormal);
                if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            return otherViewportsAnnotationsWithUniqueCameras;
        };
        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
            const volumeIds = viewport.getAllVolumeIds();
            const otherVolumeIds = otherViewport.getAllVolumeIds();
            return (volumeIds.length === otherVolumeIds.length &&
                volumeIds.every((id) => otherVolumeIds.includes(id)));
        };
        this._jump = (enabledElement, jumpWorld) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.isInteractingWithTool = true;
            const { viewport, renderingEngine } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const delta = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(jumpWorld, this.toolCenter, delta);
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
                return (this._getReferenceLineControllable(otherViewport.id) &&
                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&
                    sameScene);
            });
            if (viewportsAnnotationsToUpdate.length === 0) {
                _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.isInteractingWithTool = false;
                return false;
            }
            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.isInteractingWithTool = false;
            return true;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.isInteractingWithTool = !this.configuration.mobile?.enabled;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_9__.Events.TOUCH_TAP, this._endCallback);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this.editData.annotation.data.handles.activeOperation = null;
            this.editData.annotation.data.activeViewportIds = [];
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            this.editData = null;
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const delta = eventDetail.deltaPoints.world;
            if (Math.abs(delta[0]) < 1e-3 &&
                Math.abs(delta[1]) < 1e-3 &&
                Math.abs(delta[2]) < 1e-3) {
                return;
            }
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const { handles } = viewportAnnotation.data;
            const { currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            if (handles.activeOperation === OPERATION.DRAG) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            }
            else if (handles.activeOperation === OPERATION.ROTATE) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true);
                });
                const dir1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const dir2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                const center = [
                    this.toolCenter[0],
                    this.toolCenter[1],
                    this.toolCenter[2],
                ];
                const centerCanvas = viewport.worldToCanvas(center);
                const finalPointCanvas = eventDetail.currentPoints.canvas;
                const originalPointCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.sub */ .Zc.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.sub */ .Zc.sub(dir1, originalPointCanvas, centerCanvas);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.sub */ .Zc.sub(dir2, finalPointCanvas, centerCanvas);
                let angle = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.angle */ .Zc.angle(dir1, dir2);
                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
                    angle *= -1;
                }
                angle = Math.round(angle * 100) / 100;
                const rotationAxis = viewport.getCamera().viewPlaneNormal;
                const { matrix } = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A
                    .buildFromRadian()
                    .translate(center[0], center[1], center[2])
                    .rotate(angle, rotationAxis)
                    .translate(-center[0], -center[1], -center[2]);
                const otherViewportsIds = [];
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    data.handles.toolCenter = center;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const { viewUp, position, focalPoint } = camera;
                    viewUp[0] += position[0];
                    viewUp[1] += position[1];
                    viewUp[2] += position[2];
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(focalPoint, focalPoint, matrix);
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(position, position, matrix);
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(viewUp, viewUp, matrix);
                    viewUp[0] -= position[0];
                    viewUp[1] -= position[1];
                    viewUp[2] -= position[2];
                    otherViewport.setCamera({
                        position,
                        viewUp,
                        focalPoint,
                    });
                    otherViewportsIds.push(otherViewport.id);
                });
                renderingEngine.renderViewports(otherViewportsIds);
            }
            else if (handles.activeOperation === OPERATION.SLAB) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportSlabThicknessControlsOn === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                if (referenceAnnotations.length === 0) {
                    return;
                }
                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
                const viewportsIds = [];
                viewportsIds.push(viewport.id);
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const normal = camera.viewPlaneNormal;
                    const dotProd = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(delta, normal);
                    const projectedDelta = [...normal];
                    _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(projectedDelta, dotProd);
                    if (Math.abs(projectedDelta[0]) > 1e-3 ||
                        Math.abs(projectedDelta[1]) > 1e-3 ||
                        Math.abs(projectedDelta[2]) > 1e-3) {
                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +
                            projectedDelta[1] * projectedDelta[1] +
                            projectedDelta[2] * projectedDelta[2]);
                        const currentPoint = eventDetail.lastPoints.world;
                        const direction = [0, 0, 0];
                        const currentCenter = [
                            this.toolCenter[0],
                            this.toolCenter[1],
                            this.toolCenter[2],
                        ];
                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                        if (!viewportDraggableRotatable) {
                            const { rotationPoints } = this.editData.annotation.data.handles;
                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
                            if (otherViewportRotationPoints.length === 2) {
                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(point1, point2, currentCenter);
                                _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(currentCenter, 0.5);
                            }
                        }
                        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(currentPoint, currentCenter, direction);
                        const dotProdDirection = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(direction, normal);
                        const projectedDirection = [...normal];
                        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(projectedDirection, dotProdDirection);
                        const normalizedProjectedDirection = [
                            projectedDirection[0],
                            projectedDirection[1],
                            projectedDirection[2],
                        ];
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normalizedProjectedDirection, normalizedProjectedDirection);
                        const normalizedProjectedDelta = [
                            projectedDelta[0],
                            projectedDelta[1],
                            projectedDelta[2],
                        ];
                        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normalizedProjectedDelta, normalizedProjectedDelta);
                        let slabThicknessValue = otherViewport.getSlabThickness();
                        if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.utilities.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
                            slabThicknessValue -= mod;
                        }
                        else {
                            slabThicknessValue += mod;
                        }
                        slabThicknessValue = Math.abs(slabThicknessValue);
                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
                        if (near) {
                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                        }
                        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroupForViewport)(otherViewport.id, renderingEngine.id);
                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
                        viewportsIds.push(otherViewport.id);
                    }
                });
                renderingEngine.renderViewports(viewportsIds);
            }
        };
        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
            const { data } = annotation;
            const { rotationPoints } = data.handles;
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                if (otherViewport.id !== lineViewport.id) {
                    continue;
                }
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                if (!viewportControllable) {
                    continue;
                }
                const lineSegment1 = {
                    start: {
                        x: rotationPoints[i][2][0],
                        y: rotationPoints[i][2][1],
                    },
                    end: {
                        x: rotationPoints[i][3][0],
                        y: rotationPoints[i][3][1],
                    },
                };
                const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
                const lineSegment2 = {
                    start: {
                        x: rotationPoints[i + 1][2][0],
                        y: rotationPoints[i + 1][2][1],
                    },
                    end: {
                        x: rotationPoints[i + 1][3][0],
                        y: rotationPoints[i + 1][3][1],
                    },
                };
                const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                    return true;
                }
                i++;
            }
            return false;
        };
        this._getReferenceLineColor =
            toolProps.configuration?.getReferenceLineColor ||
                defaultReferenceLineColor;
        this._getReferenceLineControllable =
            toolProps.configuration?.getReferenceLineControllable ||
                defaultReferenceLineControllable;
        this._getReferenceLineDraggableRotatable =
            toolProps.configuration?.getReferenceLineDraggableRotatable ||
                defaultReferenceLineDraggableRotatable;
        this._getReferenceLineSlabThicknessControlsOn =
            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||
                defaultReferenceLineSlabThicknessControlsOn;
    }
    onSetToolActive() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        this._subscribeToViewportNewVolumeSet(viewportsInfo);
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolPassive() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolEnabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolDisabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            if (annotations?.length) {
                annotations.forEach((annotation) => {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_6__.removeAnnotation)(annotation.annotationUID);
                });
            }
        });
    }
    setToolCenter(toolCenter, suppressEvents = false) {
        this.toolCenter = toolCenter;
        const viewportsInfo = this._getViewportsInfo();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportsInfo.map(({ viewportId }) => viewportId));
        if (!suppressEvents) {
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_9__.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                toolGroupId: this.toolGroupId,
                toolCenter: this.toolCenter,
            });
        }
    }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _autoPanViewportIfNecessary(viewportId, renderingEngine) {
        const viewport = renderingEngine.getViewport(viewportId);
        const { clientWidth, clientHeight } = viewport.canvas;
        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);
        const pan = this.configuration.autoPan.panSize;
        const visiblePointCanvas = [
            toolCenterCanvas[0],
            toolCenterCanvas[1],
        ];
        if (toolCenterCanvas[0] < 0) {
            visiblePointCanvas[0] = pan;
        }
        else if (toolCenterCanvas[0] > clientWidth) {
            visiblePointCanvas[0] = clientWidth - pan;
        }
        if (toolCenterCanvas[1] < 0) {
            visiblePointCanvas[1] = pan;
        }
        else if (toolCenterCanvas[1] > clientHeight) {
            visiblePointCanvas[1] = clientHeight - pan;
        }
        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&
            visiblePointCanvas[1] === toolCenterCanvas[1]) {
            return;
        }
        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);
        const deltaPointsWorld = [
            visiblePointWorld[0] - this.toolCenter[0],
            visiblePointWorld[1] - this.toolCenter[1],
            visiblePointWorld[2] - this.toolCenter[2],
        ];
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
    setSlabThickness(viewport, slabThickness) {
        let actorUIDs;
        const { filterActorUIDsToSetSlabThickness } = this.configuration;
        if (filterActorUIDsToSetSlabThickness &&
            filterActorUIDsToSetSlabThickness.length > 0) {
            actorUIDs = filterActorUIDsToSetSlabThickness;
        }
        let blendModeToUse = this.configuration.slabThicknessBlendMode;
        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
            blendModeToUse = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.Enums.BlendModes.COMPOSITE;
        }
        const immediate = false;
        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
        viewport.setSlabThickness(slabThickness, actorUIDs);
    }
    _isClockWise(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
        viewportsAnnotationsToUpdate.forEach((annotation) => {
            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
        });
    }
    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
        const { data } = annotation;
        const viewport = renderingEngine.getViewport(data.viewportId);
        const camera = viewport.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(delta, normal);
        const projectedDelta = [...normal];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(camera.focalPoint, projectedDelta, newFocalPoint);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(camera.position, projectedDelta, newPosition);
            viewport.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            viewport.render();
        }
    }
    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        for (let i = 0; i < rotationPoints.length; i++) {
            const point = rotationPoints[i][0];
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.ROTATE;
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { slabThicknessPoints } = data.handles;
        for (let i = 0; i < slabThicknessPoints.length; i++) {
            const point = slabThicknessPoints[i][0];
            const otherViewport = slabThicknessPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportSlabThicknessControlsOn) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = OPERATION.SLAB;
                data.activeViewportIds = [otherViewport.id];
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _pointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_4__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { clientWidth, clientHeight } = viewport.canvas;
        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        const { slabThicknessPoints } = data.handles;
        const viewportIdArray = [];
        for (let i = 0; i < rotationPoints.length - 1; ++i) {
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportControllable || !viewportDraggableRotatable) {
                continue;
            }
            const lineSegment1 = {
                start: {
                    x: rotationPoints[i][2][0],
                    y: rotationPoints[i][2][1],
                },
                end: {
                    x: rotationPoints[i][3][0],
                    y: rotationPoints[i][3][1],
                },
            };
            const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: rotationPoints[i + 1][2][0],
                    y: rotationPoints[i + 1][2][1],
                },
                end: {
                    x: rotationPoints[i + 1][3][0],
                    y: rotationPoints[i + 1][3][1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = OPERATION.DRAG;
            }
            i++;
        }
        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
            const otherViewport = slabThicknessPoints[i][1];
            if (viewportIdArray.find((id) => id === otherViewport.id)) {
                continue;
            }
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportControllable || !viewportSlabThicknessControlsOn) {
                continue;
            }
            const stPointLineCanvas1 = slabThicknessPoints[i][2];
            const stPointLineCanvas2 = slabThicknessPoints[i][3];
            const centerCanvas = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(centerCanvas, centerCanvas, 0.5);
            const canvasUnitVectorFromCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
            const canvasVectorFromCenterStart = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scale */ .Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
            const stPointLineCanvas1Start = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            const stPointLineCanvas2Start = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.add */ .Zc.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
            const lineSegment1 = {
                start: {
                    x: stPointLineCanvas1Start[0],
                    y: stPointLineCanvas1Start[1],
                },
                end: {
                    x: stPointLineCanvas1[0],
                    y: stPointLineCanvas1[1],
                },
            };
            const distanceToPoint1 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: stPointLineCanvas2Start[0],
                    y: stPointLineCanvas2Start[1],
                },
                end: {
                    x: stPointLineCanvas2[0],
                    y: stPointLineCanvas2[1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = null;
            }
            i++;
        }
        data.activeViewportIds = [...viewportIdArray];
        this.editData = {
            annotation,
        };
        return data.handles.activeOperation === OPERATION.DRAG ? true : false;
    }
}
CrosshairsTool.toolName = 'Crosshairs';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CrosshairsTool);


/***/ }),

/***/ 66944:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13165);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77609);





class MIPJumpToClickTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            targetViewportIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseClickCallback(evt) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const volumeId = viewport.getVolumeId();
        if (!volumeId) {
            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);
        }
        let maxIntensity = -Infinity;
        const maxFn = (intensity, point) => {
            if (intensity > maxIntensity) {
                maxIntensity = intensity;
                return point;
            }
        };
        const brightestPoint = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_2__.getPointInLineOfSightWithCriteria)(viewport, currentPoints.world, volumeId, maxFn);
        if (!brightestPoint || !brightestPoint.length) {
            return;
        }
        const { targetViewportIds, toolGroupId } = this.configuration;
        const viewports = renderingEngine.getViewports().filter((vp) => {
            if (targetViewportIds?.indexOf(vp.id) >= 0) {
                return true;
            }
            const foundToolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroupForViewport)(vp.id, renderingEngine.id);
            if (toolGroupId && toolGroupId === foundToolGroup?.id) {
                return true;
            }
            return false;
        });
        viewports.forEach((viewport) => {
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                viewport.jumpToWorld(brightestPoint);
            }
            else {
                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');
            }
        });
    }
}
MIPJumpToClickTool.toolName = 'MIPJumpToClickTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MIPJumpToClickTool);


/***/ }),

/***/ 72674:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58640);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(85204);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7001);







const MAGNIFY_VIEWPORT_ID = 'magnify-viewport';
class MagnifyTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            magnifySize: 10,
            magnifyWidth: 250,
            magnifyHeight: 250,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._hasBeenRemoved = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.StackViewport)) {
                throw new Error('MagnifyTool only works on StackViewports');
            }
            const referencedImageId = this._getReferencedImageId(viewport);
            if (!referencedImageId) {
                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_3__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                referencedImageId,
                viewportIdsToRender,
                enabledElement,
                renderingEngine,
                currentPoints,
            };
            this._createMagnificationViewport();
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportIdsToRender);
            return true;
        };
        this.preTouchStartCallback = (evt) => {
            this.preMouseDownCallback(evt);
        };
        this._createMagnificationViewport = () => {
            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportProperties = viewport.getProperties();
            const { rotation: originalViewportRotation } = viewport.getViewPresentation();
            const { canvas: canvasPos, world: worldPos } = currentPoints;
            let magnifyToolElement;
            magnifyToolElement = element.querySelector('.magnifyTool');
            if (magnifyToolElement === null) {
                const magnifyElement = document.createElement('div');
                magnifyElement.classList.add('magnifyTool');
                magnifyElement.style.display = 'block';
                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;
                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;
                magnifyElement.style.position = 'absolute';
                magnifyToolElement = magnifyElement;
                const viewportElement = element.querySelector('.viewport-element');
                viewportElement.appendChild(magnifyElement);
                const viewportInput = {
                    viewportId: MAGNIFY_VIEWPORT_ID,
                    type: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.ViewportType.STACK,
                    element: magnifyToolElement,
                };
                renderingEngine.enableElement(viewportInput);
            }
            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            magnifyViewport.setStack([referencedImageId]).then(() => {
                if (this._hasBeenRemoved) {
                    return;
                }
                magnifyViewport.setProperties(viewportProperties);
                magnifyViewport.setViewPresentation({
                    rotation: originalViewportRotation,
                });
                const { parallelScale } = viewport.getCamera();
                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
                    Math.pow(focalPoint[1] - position[1], 2) +
                    Math.pow(focalPoint[2] - position[2], 2));
                const updatedFocalPoint = [
                    worldPos[0],
                    worldPos[1],
                    worldPos[2],
                ];
                const updatedPosition = [
                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],
                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],
                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],
                ];
                magnifyViewport.setCamera({
                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),
                    focalPoint: updatedFocalPoint,
                    position: updatedPosition,
                });
                magnifyViewport.render();
            });
            magnifyToolElement.style.display = 'block';
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { deltaPoints, element, currentPoints } = eventDetail;
            const deltaPointsWorld = deltaPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            const magnifyElement = element.querySelector('.magnifyTool');
            if (!magnifyElement) {
                return;
            }
            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const { focalPoint, position } = magnifyViewport.getCamera();
            const updatedPosition = [
                position[0] + deltaPointsWorld[0],
                position[1] + deltaPointsWorld[1],
                position[2] + deltaPointsWorld[2],
            ];
            const updatedFocalPoint = [
                focalPoint[0] + deltaPointsWorld[0],
                focalPoint[1] + deltaPointsWorld[1],
                focalPoint[2] + deltaPointsWorld[2],
            ];
            magnifyViewport.setCamera({
                focalPoint: updatedFocalPoint,
                position: updatedPosition,
            });
            magnifyViewport.render();
        };
        this._dragEndCallback = (evt) => {
            const { element } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);
            const viewportElement = element.querySelector('.viewport-element');
            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');
            viewportElement.removeChild(magnifyToolElement);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            this._hasBeenRemoved = true;
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__/* .state */ .wk.isInteractingWithTool = true;
            this._hasBeenRemoved = false;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._dragEndCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._dragEndCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
    }
    _getReferencedImageId(viewport) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.StackViewport) {
            referencedImageId = targetId.split('imageId:')[1];
        }
        return referencedImageId;
    }
}
MagnifyTool.toolName = 'Magnify';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MagnifyTool);


/***/ }),

/***/ 36913:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25161);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85825);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_AxesActor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45700);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7019);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82409);
/* harmony import */ var _kitware_vtk_js_IO_XML_XMLPolyDataReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(94199);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87275);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15327);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(60810);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77609);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99737);












var OverlayMarkerType;
(function (OverlayMarkerType) {
    OverlayMarkerType[OverlayMarkerType["ANNOTATED_CUBE"] = 1] = "ANNOTATED_CUBE";
    OverlayMarkerType[OverlayMarkerType["AXES"] = 2] = "AXES";
    OverlayMarkerType[OverlayMarkerType["CUSTOM"] = 3] = "CUSTOM";
})(OverlayMarkerType || (OverlayMarkerType = {}));
class OrientationMarkerTool extends _base__WEBPACK_IMPORTED_MODULE_7__/* .BaseTool */ .oS {
    static { this.CUBE = 1; }
    static { this.AXIS = 2; }
    static { this.VTPFILE = 3; }
    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            orientationWidget: {
                enabled: true,
                viewportCorner: _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.Corners.BOTTOM_RIGHT,
                viewportSize: 0.15,
                minPixelSize: 100,
                maxPixelSize: 300,
            },
            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,
            overlayConfiguration: {
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {
                    faceProperties: {
                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },
                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },
                        yPlus: {
                            text: 'P',
                            faceColor: '#00ffff',
                            fontColor: 'white',
                            faceRotation: 180,
                        },
                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },
                        zPlus: { text: 'S' },
                        zMinus: { text: 'I' },
                    },
                    defaultStyle: {
                        fontStyle: 'bold',
                        fontFamily: 'Arial',
                        fontColor: 'black',
                        fontSizeScale: (res) => res / 2,
                        faceColor: '#0000ff',
                        edgeThickness: 0.1,
                        edgeColor: 'black',
                        resolution: 400,
                    },
                },
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {
                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this.onSetToolEnabled = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolActive = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolDisabled = () => {
            this.cleanUpData();
            this._unsubscribeToViewportNewVolumeSet();
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resize = (viewportId) => {
            const orientationMarker = this.orientationMarkers[viewportId];
            if (!orientationMarker) {
                return;
            }
            const { orientationWidget } = orientationMarker;
            orientationWidget.updateViewport();
        };
        this.orientationMarkers = {};
        this.updatingOrientationMarker = {};
    }
    _unsubscribeToViewportNewVolumeSet() {
        const unsubscribe = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = this._resizeObservers.get(viewportId);
                resizeObserver.unobserve(element);
            });
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            unsubscribe();
            this.initViewports();
        });
    }
    _subscribeToViewportEvents() {
        const subscribeToElementResize = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                this.initViewports();
                element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = new ResizeObserver(() => {
                    setTimeout(() => {
                        const element = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getEnabledElementByIds)(viewportId, renderingEngineId);
                        if (!element) {
                            return;
                        }
                        const { viewport } = element;
                        this.resize(viewportId);
                        viewport.render();
                    }, 100);
                });
                resizeObserver.observe(element);
                this._resizeObservers.set(viewportId, resizeObserver);
            });
        };
        subscribeToElementResize();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            subscribeToElementResize();
            this.initViewports();
        });
    }
    cleanUpData() {
        const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        const viewports = renderingEngine.getViewports();
        viewports.forEach((viewport) => {
            const orientationMarker = this.orientationMarkers[viewport.id];
            if (!orientationMarker) {
                return;
            }
            const { actor, orientationWidget } = orientationMarker;
            orientationWidget?.setEnabled(false);
            orientationWidget?.delete();
            actor?.delete();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            renderWindow.render();
            viewport.getRenderingEngine().render();
            delete this.orientationMarkers[viewport.id];
        });
    }
    initViewports() {
        const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_8__.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        if (!renderingEngine) {
            return;
        }
        let viewports = renderingEngine.getViewports();
        viewports = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.filterViewportsWithToolEnabled)(viewports, this.getToolName());
        viewports.forEach((viewport) => {
            const widget = viewport.getWidget(this.getToolName());
            if (!widget || widget.isDeleted()) {
                this.addAxisActorInViewport(viewport);
            }
        });
    }
    async addAxisActorInViewport(viewport) {
        const viewportId = viewport.id;
        if (!this.updatingOrientationMarker[viewportId]) {
            this.updatingOrientationMarker[viewportId] = true;
            const type = this.configuration.overlayMarkerType;
            const overlayConfiguration = this.configuration.overlayConfiguration[type];
            if (this.orientationMarkers[viewportId]) {
                const { actor, orientationWidget } = this.orientationMarkers[viewportId];
                viewport.getRenderer().removeActor(actor);
                orientationWidget.setEnabled(false);
            }
            let actor;
            if (type === 1) {
                actor = this.createAnnotationCube(overlayConfiguration);
            }
            else if (type === 2) {
                actor = _kitware_vtk_js_Rendering_Core_AxesActor__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
            }
            else if (type === 3) {
                actor = await this.createCustomActor();
            }
            const renderer = viewport.getRenderer();
            const renderWindow = viewport
                .getRenderingEngine()
                .offscreenMultiRenderWindow.getRenderWindow();
            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;
            const orientationWidget = _kitware_vtk_js_Interaction_Widgets_OrientationMarkerWidget__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance({
                actor,
                interactor: renderWindow.getInteractor(),
                parentRenderer: renderer,
            });
            orientationWidget.setEnabled(enabled);
            orientationWidget.setViewportCorner(viewportCorner);
            orientationWidget.setViewportSize(viewportSize);
            orientationWidget.setMinPixelSize(minPixelSize);
            orientationWidget.setMaxPixelSize(maxPixelSize);
            orientationWidget.updateMarkerOrientation();
            this.orientationMarkers[viewportId] = {
                orientationWidget,
                actor,
            };
            viewport.addWidget(this.getToolName(), orientationWidget);
            renderWindow.render();
            viewport.getRenderingEngine().render();
            this.updatingOrientationMarker[viewportId] = false;
        }
    }
    async createCustomActor() {
        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]
            .polyDataURL;
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const vtpReader = _kitware_vtk_js_IO_XML_XMLPolyDataReader__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance();
        vtpReader.parseAsArrayBuffer(arrayBuffer);
        vtpReader.update();
        const polyData = _kitware_vtk_js_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_6__/* ["default"].newInstance */ .Ay.newInstance();
        polyData.shallowCopy(vtpReader.getOutputData());
        polyData.getPointData().setActiveScalars('Color');
        const mapper = _kitware_vtk_js_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance();
        mapper.setInputData(polyData);
        mapper.setColorModeToDirectScalars();
        const actor = _kitware_vtk_js_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
        actor.setMapper(mapper);
        actor.rotateZ(180);
        return actor;
    }
    createAnnotationCube(overlayConfiguration) {
        const actor = _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });
        actor.setXPlusFaceProperty({
            ...overlayConfiguration.faceProperties.xPlus,
        });
        actor.setXMinusFaceProperty({
            ...overlayConfiguration.faceProperties.xMinus,
        });
        actor.setYPlusFaceProperty({
            ...overlayConfiguration.faceProperties.yPlus,
        });
        actor.setYMinusFaceProperty({
            ...overlayConfiguration.faceProperties.yMinus,
        });
        actor.setZPlusFaceProperty({
            ...overlayConfiguration.faceProperties.zPlus,
        });
        actor.setZMinusFaceProperty({
            ...overlayConfiguration.faceProperties.zMinus,
        });
        return actor;
    }
    async createAnnotatedCubeActor() {
        const axes = _kitware_vtk_js_Rendering_Core_AnnotatedCubeActor__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;
        axes.setDefaultStyle(defaultStyle);
        Object.keys(faceProperties).forEach((key) => {
            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;
            axes[methodName](faceProperties[key]);
        });
        return axes;
    }
}
OrientationMarkerTool.toolName = 'OrientationMarker';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrientationMarkerTool);


/***/ }),

/***/ 43185:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77609);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6030);







const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
class OverlayGridTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceImageIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolActive = () => {
            this._init();
        };
        this._init = () => {
            const sourceImageIds = this.configuration.sourceImageIds;
            if (!sourceImageIds?.length) {
                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');
                return;
            }
            const imagePlaneModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', sourceImageIds[0]);
            if (!imagePlaneModule) {
                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');
                return;
            }
            const { frameOfReferenceUID } = imagePlaneModule;
            const viewportsInfo = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn('OverlayGridTool: No viewports found');
                return;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const pointSets = sourceImageIds.map((id) => {
                    return this.calculateImageIdPointSets(id);
                });
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        viewportData: new Map(),
                        pointSets,
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.calculateImageIdPointSets = (imageId) => {
            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
            const topLeft = [...imagePositionPatient];
            const topRight = [...imagePositionPatient];
            const bottomLeft = [...imagePositionPatient];
            const bottomRight = [...imagePositionPatient];
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            return { pointSet1, pointSet2 };
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const sourceImageIds = this.configuration.sourceImageIds;
            let renderStatus = false;
            if (!sourceImageIds?.length) {
                return renderStatus;
            }
            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;
            const targetImageIds = targetViewport.getImageIds();
            if (targetImageIds.length < 2) {
                return renderStatus;
            }
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));
            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSets = annotation.data.pointSets;
            const viewportData = annotation.data.viewportData;
            for (let i = 0; i < sourceImageIds.length; i++) {
                const { pointSet1, pointSet2 } = pointSets[i];
                const targetData = viewportData.get(targetViewport.id) ||
                    this.initializeViewportData(viewportData, targetViewport.id);
                if (!targetData.pointSetsToUse[i]) {
                    let pointSetToUse = pointSet1;
                    let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), pointSet1[0], pointSet1[1]);
                    topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), topBottomVec);
                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                        pointSetToUse = pointSet2;
                    }
                    targetData.pointSetsToUse[i] = pointSetToUse;
                    targetData.lineStartsWorld[i] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
                    targetData.lineEndsWorld[i] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
                }
                const lineStartWorld = targetData.lineStartsWorld[i];
                const lineEndWorld = targetData.lineEndsWorld[i];
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const shadow = this.getStyle('shadow', styleSpecifier, annotation);
                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
                const dataId = `${annotationUID}-line`;
                const lineUID = `${i}`;
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
            }
            renderStatus = true;
            return renderStatus;
        };
        this.initializeViewportData = (viewportData, id) => {
            viewportData.set(id, {
                pointSetsToUse: [],
                lineStartsWorld: [],
                lineEndsWorld: [],
            });
            return viewportData.get(id);
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vec1, vec2);
            return Math.abs(dot) < EPSILON;
        };
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vec1, vec2)) > 1 - EPSILON;
    }
    getImageIdNormal(imageId) {
        const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', imageId);
        const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
        const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), rowCosineVec, colCosineVec);
    }
}
OverlayGridTool.toolName = 'OverlayGrid';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OverlayGridTool);


/***/ }),

/***/ 38782:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);


class PanTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        if (deltaPointsWorld[0] === 0 &&
            deltaPointsWorld[1] === 0 &&
            deltaPointsWorld[2] === 0) {
            return;
        }
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
PanTool.toolName = 'Pan';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PanTool);


/***/ }),

/***/ 82058:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25963);




class PlanarRotateTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.mouseWheelCallback = (evt) => {
            const { element, wheel } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { invert } = this.configuration;
            const angle = wheel.direction * 10 * (invert ? -1 : 1);
            this.setAngle(viewport, angle);
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, startPoints } = evt.detail;
        const currentPointWorld = currentPoints.world;
        const startPointWorld = startPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const centerCanvas = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(centerCanvas);
        let angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);
        const { viewPlaneNormal } = camera;
        const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), centerWorld, startPointWorld);
        const v2 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), centerWorld, currentPointWorld);
        const cross = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), v1, v2);
        if (gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.dot */ .eR.dot(viewPlaneNormal, cross) > 0) {
            angle = -angle;
        }
        if (Number.isNaN(angle)) {
            return;
        }
        this.setAngle(viewport, angle);
    }
    setAngle(viewport, angle) {
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;
            const rotMat = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .mat4.identity */ .pB.identity(new Float32Array(16));
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .mat4.rotate */ .pB.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);
            const rotatedViewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.transformMat4 */ .eR.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), viewUp, rotMat);
            viewport.setCamera({ viewUp: rotatedViewUp });
        }
        else {
            const { rotation } = viewport.getViewPresentation();
            viewport.setViewPresentation({
                rotation: (rotation + angle + 360) % 360,
            });
        }
        viewport.render();
    }
}
PlanarRotateTool.toolName = 'PlanarRotate';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarRotateTool);


/***/ }),

/***/ 85735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29601);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3823);
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6030);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(84607);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7001);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77609);











class ReferenceCursors extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            displayThreshold: 5,
            positionSync: true,
            disableCursor: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isHandleOutsideImage = false;
        this._elementWithCursor = null;
        this._currentCursorWorldPosition = null;
        this._currentCanvasPosition = null;
        this._disableCursorEnabled = false;
        this.mouseMoveCallback = (evt) => {
            const { detail } = evt;
            const { element, currentPoints } = detail;
            this._currentCursorWorldPosition = currentPoints.world;
            this._currentCanvasPosition = currentPoints.canvas;
            this._elementWithCursor = element;
            const annotation = this.getActiveAnnotation(element);
            if (annotation === null) {
                this.createInitialAnnotation(currentPoints.world, element);
                return false;
            }
            this.updateAnnotationPosition(element, annotation);
            return false;
        };
        this.createInitialAnnotation = (worldPos, element) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('No enabled element found');
            }
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            if (!viewPlaneNormal || !viewUp) {
                throw new Error('Camera not found');
            }
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                },
            };
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (annotations.length > 0) {
                return null;
            }
            const annotationId = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
            if (annotationId === null) {
                return;
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element, previousCamera, camera } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const viewport = enabledElement.viewport;
            if (element !== this._elementWithCursor) {
                return;
            }
            const oldFocalPoint = previousCamera.focalPoint;
            const cameraNormal = camera.viewPlaneNormal;
            const newFocalPoint = camera.focalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__/* ["default"].subtract */ .Ay.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);
            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {
                return;
            }
            const dotProduct = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_8__/* ["default"].dot */ .Ay.dot(deltaCameraFocalPoint, cameraNormal);
            if (Math.abs(dotProduct) < 1e-2) {
                return;
            }
            if (!this._currentCanvasPosition) {
                return;
            }
            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);
            this._currentCursorWorldPosition = newWorldPos;
            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, FrameOfReferenceUID } = enabledElement;
            const isElementWithCursor = this._elementWithCursor === viewport.element;
            if (this.configuration.positionSync && !isElementWithCursor) {
                this.updateViewportImage(viewport);
            }
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                if (!annotationUID) {
                    return renderStatus;
                }
                styleSpecifier.annotationUID = annotationUID;
                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));
                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor
                    ? lineWidthBase
                    : lineWidthBase;
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (points[0].some((e) => isNaN(e))) {
                    return renderStatus;
                }
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_2__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const crosshairUIDs = {
                    upper: 'upper',
                    right: 'right',
                    lower: 'lower',
                    left: 'left',
                };
                const [x, y] = canvasCoordinates[0];
                const centerSpace = isElementWithCursor ? 20 : 7;
                const lineLength = isElementWithCursor ? 5 : 7;
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });
                renderStatus = true;
            }
            return renderStatus;
        };
        this._disableCursorEnabled = this.configuration.disableCursor;
    }
    onSetToolActive() {
        this._disableCursorEnabled = this.configuration.disableCursor;
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element.viewport.element);
            }
        });
    }
    onSetToolDisabled() {
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element.viewport.element);
            }
        });
    }
    getActiveAnnotation(element) {
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
        if (!annotations.length) {
            return null;
        }
        const targetAnnotation = annotations[0];
        return targetAnnotation;
    }
    updateAnnotationPosition(element, annotation) {
        const worldPos = this._currentCursorWorldPosition;
        if (!worldPos) {
            return;
        }
        if (!annotation.data?.handles?.points) {
            return;
        }
        annotation.data.handles.points = [[...worldPos]];
        annotation.invalidated = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(viewportIdsToRender);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!(annotations instanceof Array) || annotations.length === 0) {
            return [];
        }
        const annotation = annotations[0];
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element)?.viewport;
        if (!viewport) {
            return [];
        }
        const camera = viewport.getCamera();
        const { viewPlaneNormal, focalPoint } = camera;
        if (!viewPlaneNormal || !focalPoint) {
            return [];
        }
        const points = annotation.data?.handles?.points;
        if (!(points instanceof Array) || points.length !== 1) {
            return [];
        }
        const worldPos = points[0];
        const plane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
        const distance = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeDistanceToPoint(plane, worldPos);
        return distance < this.configuration.displayThreshold ? [annotation] : [];
    }
    updateViewportImage(viewport) {
        const currentMousePosition = this._currentCursorWorldPosition;
        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {
            return;
        }
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
            const closestIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);
            if (closestIndex === null) {
                return;
            }
            if (closestIndex !== viewport.getCurrentImageIdIndex()) {
                viewport.setImageIdIndex(closestIndex);
            }
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const { focalPoint, viewPlaneNormal } = viewport.getCamera();
            if (!focalPoint || !viewPlaneNormal) {
                return;
            }
            const plane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const currentDistance = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);
            if (Math.abs(currentDistance) < 0.5) {
                return;
            }
            const normalizedViewPlane = gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.create */ .eR.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.fromValues */ .eR.fromValues(...viewPlaneNormal));
            const scaledPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.scale */ .eR.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.create */ .eR.create(), normalizedViewPlane, currentDistance);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.create */ .eR.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.fromValues */ .eR.fromValues(...focalPoint), scaledPlaneNormal);
            const isInBounds = true;
            if (isInBounds) {
                viewport.setCamera({ focalPoint: newFocalPoint });
                const renderingEngine = viewport.getRenderingEngine();
                if (renderingEngine) {
                    renderingEngine.renderViewport(viewport.id);
                }
            }
        }
    }
}
ReferenceCursors.toolName = 'ReferenceCursors';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReferenceCursors);


/***/ }),

/***/ 36797:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6030);








const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
class ReferenceLines extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceViewportId: '',
            enforceSameFrameOfReference: true,
            showFullDimension: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            let viewports = renderingEngine.getViewports();
            viewports = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.filterViewportsWithToolEnabled)(viewports, this.getToolName());
            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);
            if (!sourceViewport?.getImageData()) {
                return;
            }
            const { element } = sourceViewport;
            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();
            const sourceViewportCanvasCornersInWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportImageCornersInWorld(sourceViewport);
            let annotation = this.editData?.annotation;
            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();
            if (!annotation) {
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [...viewPlaneNormal],
                        viewUp: [...viewUp],
                        FrameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        handles: {
                            points: sourceViewportCanvasCornersInWorld,
                        },
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(newAnnotation, element);
                annotation = newAnnotation;
            }
            else {
                this.editData.annotation.data.handles.points =
                    sourceViewportCanvasCornersInWorld;
            }
            this.editData = {
                sourceViewportId: sourceViewport.id,
                renderingEngine,
                annotation,
            };
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(viewports
                .filter((viewport) => viewport.id !== sourceViewport.id)
                .map((viewport) => viewport.id));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolConfiguration = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport: targetViewport } = enabledElement;
            if (!this.editData) {
                return false;
            }
            const { annotation, sourceViewportId } = this.editData;
            let renderStatus = false;
            const { viewport: sourceViewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(sourceViewportId) || {};
            if (!sourceViewport) {
                return renderStatus;
            }
            if (sourceViewport.id === targetViewport.id) {
                return renderStatus;
            }
            if (!annotation || !annotation?.data?.handles?.points) {
                return renderStatus;
            }
            if (this.configuration.enforceSameFrameOfReference &&
                sourceViewport.getFrameOfReferenceUID() !==
                    targetViewport.getFrameOfReferenceUID()) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const topLeft = annotation.data.handles.points[0];
            const topRight = annotation.data.handles.points[1];
            const bottomLeft = annotation.data.handles.points[2];
            const bottomRight = annotation.data.handles.points[3];
            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();
            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();
            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            let pointSetToUse = pointSet1;
            let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), pointSet1[0], pointSet1[1]);
            topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), topBottomVec);
            let topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), pointSet1[2], pointSet1[0]);
            topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), topRightVec);
            const newNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), topBottomVec, topRightVec);
            if (this.isParallel(newNormal, viewPlaneNormal)) {
                return renderStatus;
            }
            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                pointSetToUse = pointSet2;
            }
            const lineStartWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
            const lineEndWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
            const { annotationUID } = annotation;
            styleSpecifier.annotationUID = annotationUID;
            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
            const color = this.getStyle('color', styleSpecifier, annotation);
            const shadow = this.getStyle('shadow', styleSpecifier, annotation);
            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
            if (this.configuration.showFullDimension) {
                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);
            }
            if (canvasCoordinates.length < 2) {
                return renderStatus;
            }
            const dataId = `${annotationUID}-line`;
            const lineUID = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, dataId);
            renderStatus = true;
            return renderStatus;
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vec1, vec2);
            return Math.abs(dot) < EPSILON;
        };
    }
    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {
        const renderingEngine = targetViewport.getRenderingEngine();
        const targetId = this.getTargetId(targetViewport);
        const targetImage = this.getTargetImageData(targetId);
        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);
        if (referencedImageId && targetImage) {
            try {
                const { imageData, dimensions } = targetImage;
                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [
                    imageData.indexToWorld([0, 0, 0]),
                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),
                    imageData.indexToWorld([
                        dimensions[0] - 1,
                        dimensions[1] - 1,
                        0,
                    ]),
                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),
                ].map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.worldToImageCoords(referencedImageId, world));
                const [lineStartImageCoord, lineEndImageCoord] = [
                    lineStartWorld,
                    lineEndWorld,
                ].map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.worldToImageCoords(referencedImageId, world));
                canvasCoordinates = [
                    [topLeftImageCoord, topRightImageCoord],
                    [topRightImageCoord, bottomRightImageCoord],
                    [bottomLeftImageCoord, bottomRightImageCoord],
                    [topLeftImageCoord, bottomLeftImageCoord],
                ]
                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))
                    .filter((point) => point && this.isInBound(point, dimensions))
                    .map((point) => {
                    const world = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageToWorldCoords(referencedImageId, point);
                    return targetViewport.worldToCanvas(world);
                });
            }
            catch (err) {
                console.log(err);
            }
        }
        return canvasCoordinates;
    }
    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {
        const [x1, y1] = line1Start;
        const [x2, y2] = line1End;
        const [x3, y3] = line2Start;
        const [x4, y4] = line2End;
        const a1 = y2 - y1;
        const b1 = x1 - x2;
        const c1 = x2 * y1 - x1 * y2;
        const a2 = y4 - y3;
        const b2 = x3 - x4;
        const c2 = x4 * y3 - x3 * y4;
        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {
            return;
        }
        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);
        return [x, y];
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vec1, vec2)) > 1 - EPSILON;
    }
    isInBound(point, dimensions) {
        return (point[0] >= 0 &&
            point[0] <= dimensions[0] &&
            point[1] >= 0 &&
            point[1] <= dimensions[1]);
    }
}
ReferenceLines.toolName = 'ReferenceLines';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReferenceLines);


/***/ }),

/***/ 26039:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6030);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77609);






const viewportsWithAnnotations = [];
class ScaleOverlayTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            viewportId: '',
            scaleLocation: 'bottom',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            const viewportIds = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportIds) {
                return;
            }
            const enabledElements = viewportIds.map((e) => (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
            let { viewport } = enabledElements[0];
            const { FrameOfReferenceUID } = enabledElements[0];
            if (this.configuration.viewportId) {
                enabledElements.forEach((element) => {
                    if (element.viewport.id == this.configuration.viewportId) {
                        viewport = element.viewport;
                    }
                });
            }
            if (!viewport) {
                return;
            }
            const { viewUp, viewPlaneNormal } = viewport.getCamera();
            const viewportCanvasCornersInWorld = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.getViewportImageCornersInWorld(viewport);
            let annotation = this.editData?.annotation;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), viewport.element);
            if (annotations.length) {
                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
            }
            enabledElements.forEach((element) => {
                const { viewport } = element;
                if (!viewportsWithAnnotations.includes(viewport.id)) {
                    const newAnnotation = {
                        metadata: {
                            toolName: this.getToolName(),
                            viewPlaneNormal: [...viewPlaneNormal],
                            viewUp: [...viewUp],
                            FrameOfReferenceUID,
                            referencedImageId: null,
                        },
                        data: {
                            handles: {
                                points: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.getViewportImageCornersInWorld(viewport),
                            },
                            viewportId: viewport.id,
                        },
                    };
                    viewportsWithAnnotations.push(viewport.id);
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(newAnnotation, viewport.element);
                    annotation = newAnnotation;
                }
            });
            if (this.editData?.annotation &&
                this.editData.annotation.data.viewportId == viewport.id) {
                this.editData.annotation.data.handles.points =
                    viewportCanvasCornersInWorld;
                this.editData.annotation.data.viewportId = viewport.id;
            }
            this.editData = {
                viewport,
                renderingEngine,
                annotation,
            };
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this.configuration.viewportId = evt.detail.viewportId;
            this._init();
        };
        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {
            const scaleSizes = [
                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,
            ];
            let currentScaleSize;
            if (location == 'top' || location == 'bottom') {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&
                    scaleSize > worldWidthViewport * 0.2);
            }
            else {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&
                    scaleSize > worldHeightViewport * 0.2);
            }
            return currentScaleSize[0];
        };
        this.computeEndScaleTicks = (canvasCoordinates, location) => {
            const locationTickOffset = {
                bottom: [
                    [0, -10],
                    [0, -10],
                ],
                top: [
                    [0, 10],
                    [0, 10],
                ],
                left: [
                    [0, 0],
                    [10, 0],
                ],
                right: [
                    [0, 0],
                    [-10, 0],
                ],
            };
            const endTick1 = [
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],
                ],
            ];
            const endTick2 = [
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],
                ],
            ];
            return {
                endTick1: endTick1,
                endTick2: endTick2,
            };
        };
        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {
            let canvasScaleSize;
            if (location == 'bottom' || location == 'top') {
                canvasScaleSize = rightTick[0][0] - leftTick[0][0];
            }
            else if (location == 'left' || location == 'right') {
                canvasScaleSize = rightTick[0][1] - leftTick[0][1];
            }
            const tickIds = [];
            const tickUIDs = [];
            const tickCoordinates = [];
            let numberSmallTicks = scaleSize;
            if (scaleSize >= 50) {
                numberSmallTicks = scaleSize / 10;
            }
            const tickSpacing = canvasScaleSize / numberSmallTicks;
            for (let i = 0; i < numberSmallTicks - 1; i++) {
                const locationOffset = {
                    bottom: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), 5],
                    ],
                    top: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), -5],
                    ],
                    left: [
                        [0, tickSpacing * (i + 1)],
                        [-5, tickSpacing * (i + 1)],
                    ],
                    right: [
                        [0, tickSpacing * (i + 1)],
                        [5, tickSpacing * (i + 1)],
                    ],
                };
                tickIds.push(`${annotationUID}-tick${i}`);
                tickUIDs.push(`tick${i}`);
                if ((i + 1) % 5 == 0) {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][0][0],
                            leftTick[1][1] + locationOffset[location][0][1],
                        ],
                    ]);
                }
                else {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][1][0],
                            leftTick[1][1] + locationOffset[location][1][1],
                        ],
                    ]);
                }
            }
            return { tickIds, tickUIDs, tickCoordinates };
        };
        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {
            let worldCoordinates;
            let topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), pointSet[0], pointSet[1]);
            topBottomVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), topBottomVec);
            let topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), pointSet[2], pointSet[0]);
            topRightVec = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), topRightVec);
            const midpointLocation = {
                bottom: [pointSet[1], pointSet[2]],
                top: [pointSet[0], pointSet[3]],
                right: [pointSet[2], pointSet[3]],
                left: [pointSet[0], pointSet[1]],
            };
            const midpoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), midpointLocation[location][0], midpointLocation[location][0])
                .map((i) => i / 2);
            const offset = scaleSize /
                2 /
                Math.sqrt(Math.pow(topBottomVec[0], 2) +
                    Math.pow(topBottomVec[1], 2) +
                    Math.pow(topBottomVec[2], 2));
            if (location == 'top' || location == 'bottom') {
                worldCoordinates = [
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                ];
            }
            else if (location == 'left' || location == 'right') {
                worldCoordinates = [
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                ];
            }
            return worldCoordinates;
        };
        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {
            let scaleCanvasCoordinates;
            if (location == 'top' || location == 'bottom') {
                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];
                scaleCanvasCoordinates = [
                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],
                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],
                ];
            }
            else if (location == 'left' || location == 'right') {
                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];
                scaleCanvasCoordinates = [
                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],
                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],
                ];
            }
            return scaleCanvasCoordinates;
        };
        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {
            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);
            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);
            const locationBounds = {
                bottom: [-vReduction, -hReduction],
                top: [vReduction, hReduction],
                left: [vReduction, hReduction],
                right: [-vReduction, -hReduction],
            };
            const canvasBounds = {
                bottom: [canvasSize.height, canvasSize.width],
                top: [0, canvasSize.width],
                left: [canvasSize.height, 0],
                right: [canvasSize.height, canvasSize.width],
            };
            return {
                height: canvasBounds[location][0] + locationBounds[location][0],
                width: canvasBounds[location][1] + locationBounds[location][1],
            };
        };
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.editData || !this.editData.viewport) {
            return;
        }
        const location = this.configuration.scaleLocation;
        const { viewport } = enabledElement;
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), viewport.element);
        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
        const canvas = enabledElement.viewport.canvas;
        const renderStatus = false;
        if (!viewport) {
            return renderStatus;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        const canvasSize = {
            width: canvas.width / window.devicePixelRatio || 1,
            height: canvas.height / window.devicePixelRatio || 1,
        };
        const topLeft = annotation.data.handles.points[0];
        const topRight = annotation.data.handles.points[1];
        const bottomLeft = annotation.data.handles.points[2];
        const bottomRight = annotation.data.handles.points[3];
        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
        const worldWidthViewport = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(bottomLeft, bottomRight);
        const worldHeightViewport = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(topLeft, bottomLeft);
        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);
        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));
        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);
        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);
        const { annotationUID } = annotation;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
        const color = this.getStyle('color', styleSpecifier, annotation);
        const shadow = this.getStyle('shadow', styleSpecifier, annotation);
        const scaleId = `${annotationUID}-scaleline`;
        const scaleLineUID = '1';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, scaleId);
        const leftTickId = `${annotationUID}-left`;
        const leftTickUID = '2';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, leftTickId);
        const rightTickId = `${annotationUID}-right`;
        const rightTickUID = '3';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, rightTickId);
        const locationTextOffest = {
            bottom: [-10, -42],
            top: [-12, -35],
            left: [-40, -20],
            right: [-50, -20],
        };
        const textCanvasCoordinates = [
            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],
            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],
        ];
        const textBoxLines = this._getTextLines(scaleSize);
        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);
        for (let i = 0; i < tickUIDs.length; i++) {
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, tickIds[i]);
        }
        const textUID = 'text0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {
            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            fontSize: '14px',
            lineDash: '2,3',
            lineWidth: '1',
            shadow: true,
            color: color,
        });
        return renderStatus;
    }
    _getTextLines(scaleSize) {
        let scaleSizeDisplayValue;
        let scaleSizeUnits;
        if (scaleSize >= 50) {
            scaleSizeDisplayValue = scaleSize / 10;
            scaleSizeUnits = ' cm';
        }
        else {
            scaleSizeDisplayValue = scaleSize;
            scaleSizeUnits = ' mm';
        }
        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];
        return textLines;
    }
}
ScaleOverlayTool.toolName = 'ScaleOverlay';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScaleOverlayTool);


/***/ }),

/***/ 3751:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export contourIndex */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6802);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(95527);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(76712);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(16175);
/* harmony import */ var _distancePointToContour__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13271);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(77609);












class SculptorTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minSpacing: 1,
            referencedToolNames: [
                'PlanarFreehandROI',
                'PlanarFreehandContourSegmentationTool',
            ],
            toolShape: 'circle',
            referencedToolName: 'PlanarFreehandROI',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.registeredShapes = new Map();
        this.isActive = false;
        this.commonData = {
            activeAnnotationUID: null,
            viewportIdsToRender: [],
            isEditingOpenContour: false,
            canvasLocation: undefined,
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.configureToolSize(evt);
            this.selectFreehandTool(eventData);
            if (this.commonData.activeAnnotationUID === null) {
                return;
            }
            this.isActive = true;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            this.activateModify(element);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active) {
                this.configureToolSize(evt);
                this.updateCursor(evt);
            }
            else {
                this.commonData.canvasLocation = undefined;
            }
        };
        this.endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const config = this.configuration;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.isActive = false;
            this.deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const { renderingEngineId, viewportId } = enabledElement;
            const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__.getToolGroupForViewport)(viewportId, renderingEngineId);
            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (toolInstance.configuration.calculateStats) {
                activeAnnotation.invalidated = true;
            }
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(activeAnnotation, element, _enums__WEBPACK_IMPORTED_MODULE_4__.ChangeTypes.HandlesUpdated);
        };
        this.dragCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.updateCursor(evt);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (!annotations?.length || !this.isActive) {
                return;
            }
            const points = activeAnnotation.data.contour.polyline;
            this.sculpt(eventData, points);
        };
        this.registerShapes(_SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.shapeName, _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
        this.setToolShape(this.configuration.toolShape);
    }
    registerShapes(shapeName, shapeClass) {
        const shape = new shapeClass();
        this.registeredShapes.set(shapeName, shape);
    }
    sculpt(eventData, points) {
        const config = this.configuration;
        const element = eventData.element;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        this.sculptData = {
            mousePoint: eventData.currentPoints.world,
            mouseCanvasPoint: eventData.currentPoints.canvas,
            points,
            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),
            element: element,
        };
        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);
        if (pushedHandles.first !== undefined) {
            this.insertNewHandles(pushedHandles);
        }
    }
    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {
        const { element } = this.sculptData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const nextHandleIndex = contourIndex(i + 1, points.length);
        const currentCanvasPoint = viewport.worldToCanvas(points[i]);
        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);
        const distanceToNextHandle = _utilities_math__WEBPACK_IMPORTED_MODULE_3__.point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);
        if (distanceToNextHandle > maxSpacing) {
            indicesToInsertAfter.push(i);
        }
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const element = eventData.element;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine, viewport } = enabledElement;
        this.commonData.viewportIdsToRender = [viewport.id];
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
        this.commonData.canvasLocation = eventData.currentPoints.canvas;
        if (this.isActive) {
            activeAnnotation.highlighted = true;
        }
        else {
            const cursorShape = this.registeredShapes.get(this.selectedShape);
            const canvasCoords = eventData.currentPoints.canvas;
            cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* .triggerAnnotationRenderForViewportIds */ .t)(this.commonData.viewportIdsToRender);
    }
    filterSculptableAnnotationsForElement(element) {
        const config = this.configuration;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngineId, viewportId } = enabledElement;
        const sculptableAnnotations = [];
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_11__.getToolGroupForViewport)(viewportId, renderingEngineId);
        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
        config.referencedToolNames.forEach((referencedToolName) => {
            const annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotations */ .Rh)(referencedToolName, element);
            if (annotations) {
                sculptableAnnotations.push(...annotations);
            }
        });
        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);
    }
    configureToolSize(evt) {
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.configureToolSize(evt);
    }
    insertNewHandles(pushedHandles) {
        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);
        let newIndexModifier = 0;
        for (let i = 0; i < indicesToInsertAfter?.length; i++) {
            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;
            this.insertHandleRadially(insertIndex);
            newIndexModifier++;
        }
    }
    findNewHandleIndices(pushedHandles) {
        const { points, maxSpacing } = this.sculptData;
        const indicesToInsertAfter = [];
        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {
            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);
        }
        return indicesToInsertAfter;
    }
    insertHandleRadially(insertIndex) {
        const { points } = this.sculptData;
        if (insertIndex > points.length - 1 &&
            this.commonData.isEditingOpenContour) {
            return;
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        const previousIndex = insertIndex - 1;
        const nextIndex = contourIndex(insertIndex, points.length);
        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);
        const handleData = insertPosition;
        points.splice(insertIndex, 0, handleData);
    }
    selectFreehandTool(eventData) {
        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);
        if (closestAnnotationUID === undefined) {
            return;
        }
        this.commonData.activeAnnotationUID = closestAnnotationUID;
    }
    getClosestFreehandToolOnElement(eventData) {
        const { element } = eventData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const config = this.configuration;
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const canvasPoints = eventData.currentPoints.canvas;
        const closest = {
            distance: Infinity,
            toolIndex: undefined,
            annotationUID: undefined,
        };
        for (let i = 0; i < annotations?.length; i++) {
            if (annotations[i].isLocked || !annotations[i].isVisible) {
                continue;
            }
            const distanceFromTool = (0,_distancePointToContour__WEBPACK_IMPORTED_MODULE_10__/* .distancePointToContour */ .X)(viewport, annotations[i], canvasPoints);
            if (distanceFromTool === -1) {
                continue;
            }
            if (distanceFromTool < closest.distance) {
                closest.distance = distanceFromTool;
                closest.toolIndex = i;
                closest.annotationUID = annotations[i].annotationUID;
            }
        }
        this.commonData.isEditingOpenContour =
            !annotations[closest.toolIndex].data.contour.closed;
        config.referencedToolName =
            annotations[closest.toolIndex].metadata.toolName;
        return closest.annotationUID;
    }
    activateModify(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this.dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this.endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this.dragCallback);
    }
    deactivateModify(element) {
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this.dragCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this.endCallback);
        element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this.dragCallback);
    }
    setToolShape(toolShape) {
        this.selectedShape =
            this.registeredShapes.get(toolShape) ?? _SculptorTool_CircleSculptCursor__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.shapeName;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        const { viewport } = enabledElement;
        const { element } = viewport;
        const viewportIdsToRender = this.commonData.viewportIdsToRender;
        if (!this.commonData.canvasLocation ||
            this.mode !== _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active ||
            !viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        let color = (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__/* .getStyleProperty */ .h)('color', styleSpecifier, _enums__WEBPACK_IMPORTED_MODULE_4__.AnnotationStyleStates.Default, this.mode);
        if (this.isActive) {
            color = (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_7__/* .getStyleProperty */ .h)('color', styleSpecifier, _enums__WEBPACK_IMPORTED_MODULE_4__.AnnotationStyleStates.Highlighted, this.mode);
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {
            color,
        });
    }
}
const contourIndex = (i, length) => {
    return (i + length) % length;
};
SculptorTool.toolName = 'SculptorTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SculptorTool);


/***/ }),

/***/ 32302:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17328);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77609);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58640);
/* harmony import */ var _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6030);
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82216);
/* harmony import */ var _utilities_pointToString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(38726);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(53860);









class SegmentationIntersectionTool extends _base_AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            opacity: 0.5,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._init = () => {
            const viewportsInfo = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_3__.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn(this.getToolName() + 'Tool: No viewports found');
                return;
            }
            const firstViewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);
            if (!firstViewport) {
                return;
            }
            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const actorsWorldPointsMap = new Map();
                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        actorsWorldPointsMap,
                    },
                };
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport, FrameOfReferenceUID } = enabledElement;
            let renderStatus = false;
            const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;
            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
            const actorEntries = viewport.getActors();
            const cacheId = getCacheId(viewport);
            actorEntries.forEach((actorEntry) => {
                if (!actorEntry?.clippingFilter) {
                    return;
                }
                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);
                if (!actorWorldPointMap) {
                    return;
                }
                if (!actorWorldPointMap.get(cacheId)) {
                    return;
                }
                let polyLineIdx = 1;
                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);
                for (let i = 0; i < worldPointsSet.length; i++) {
                    const worldPoints = worldPointsSet[i];
                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));
                    const options = {
                        color: color,
                        fillColor: color,
                        fillOpacity: this.configuration.opacity,
                        closePath: true,
                        lineWidth: 2,
                    };
                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawPath)(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);
                    polyLineIdx++;
                }
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
function calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const viewport = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId)?.getViewport(viewportId);
        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
    });
}
function calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {
    const actorEntries = viewport.getActors();
    const cacheId = getCacheId(viewport);
    actorEntries.forEach((actorEntry) => {
        if (!actorEntry?.clippingFilter) {
            return;
        }
        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);
        if (!actorWorldPointsMap) {
            actorWorldPointsMap = new Map();
            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);
        }
        if (!actorWorldPointsMap.get(cacheId)) {
            const polyData = actorEntry.clippingFilter.getOutputData();
            const worldPointsSet = _utilities__WEBPACK_IMPORTED_MODULE_8__.polyDataUtils.getPolyDataPoints(polyData);
            if (!worldPointsSet) {
                return;
            }
            const colorArray = actorEntry.actor.getProperty().getColor();
            const color = colorToString(colorArray);
            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });
        }
    });
}
function getCacheId(viewport) {
    const { viewPlaneNormal } = viewport.getCamera();
    const imageIndex = viewport.getCurrentImageIdIndex();
    return `${viewport.id}-${(0,_utilities_pointToString__WEBPACK_IMPORTED_MODULE_7__/* .pointToString */ .l)(viewPlaneNormal)}-${imageIndex}`;
}
function colorToString(colorArray) {
    function colorComponentToString(component) {
        let componentString = Math.floor(component * 255).toString(16);
        if (componentString.length === 1) {
            componentString = '0' + componentString;
        }
        return componentString;
    }
    return ('#' +
        colorComponentToString(colorArray[0]) +
        colorComponentToString(colorArray[1]) +
        colorComponentToString(colorArray[2]));
}
function removeExtraPoints(viewport, worldPointsSet) {
    return worldPointsSet.map((worldPoints) => {
        const canvasPoints = worldPoints.map((point) => {
            const canvasPoint = viewport.worldToCanvas(point);
            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];
        });
        let lastPoint;
        const newWorldPoints = [];
        let newCanvasPoints = [];
        for (let i = 0; i < worldPoints.length; i++) {
            if (lastPoint) {
                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {
                    newWorldPoints.push(worldPoints[i]);
                    newCanvasPoints.push(canvasPoints[i]);
                }
            }
            lastPoint = canvasPoints[i];
        }
        const firstPoint = newCanvasPoints[0];
        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {
            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {
                newCanvasPoints = newCanvasPoints.slice(0, j);
                return newWorldPoints.slice(0, j);
            }
        }
        return newWorldPoints;
    });
}
SegmentationIntersectionTool.toolName = 'SegmentationIntersection';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentationIntersectionTool);


/***/ }),

/***/ 89460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);


class StackScrollTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            invert: false,
            debounceIfNotLoaded: true,
            loop: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.deltaY = 1;
    }
    mouseWheelCallback(evt) {
        this._scroll(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        this._scrollDrag(evt);
    }
    _scrollDrag(evt) {
        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
        const { debounceIfNotLoaded, invert, loop } = this.configuration;
        const deltaPointY = deltaPoints.canvas[1];
        let volumeId;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            volumeId = viewport.getVolumeId();
        }
        const pixelsPerImage = this._getPixelPerImage(viewport);
        const deltaY = deltaPointY + this.deltaY;
        if (!pixelsPerImage) {
            return;
        }
        if (Math.abs(deltaY) >= pixelsPerImage) {
            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.scroll(viewport, {
                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,
                volumeId,
                debounceLoading: debounceIfNotLoaded,
                loop: loop,
            });
            this.deltaY = deltaY % pixelsPerImage;
        }
        else {
            this.deltaY = deltaY;
        }
    }
    _scroll(evt) {
        const { wheel, element } = evt.detail;
        const { direction } = wheel;
        const { invert } = this.configuration;
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const delta = direction * (invert ? -1 : 1);
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.scroll(viewport, {
            delta,
            debounceLoading: this.configuration.debounceIfNotLoaded,
            loop: this.configuration.loop,
            volumeId: viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport
                ? viewport.getVolumeId()
                : undefined,
            scrollSlabs: this.configuration.scrollSlabs,
        });
    }
    _getPixelPerImage(viewport) {
        const { element } = viewport;
        const numberOfSlices = viewport.getNumberOfSlices();
        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));
    }
}
StackScrollTool.toolName = 'StackScroll';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StackScrollTool);


/***/ }),

/***/ 26884:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84607);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85817);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77609);






class TrackballRotateTool extends _base__WEBPACK_IMPORTED_MODULE_4__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            rotateIncrementDegrees: 2,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this._hasResolutionChanged = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const actorEntry = viewport.getDefaultActor();
            const actor = actorEntry.actor;
            const mapper = actor.getMapper();
            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;
            if (!hasSampleDistance) {
                return true;
            }
            const originalSampleDistance = mapper.getSampleDistance();
            if (!this._hasResolutionChanged) {
                mapper.setSampleDistance(originalSampleDistance * 2);
                this._hasResolutionChanged = true;
                if (this.cleanUp !== null) {
                    document.removeEventListener('mouseup', this.cleanUp);
                }
                this.cleanUp = () => {
                    mapper.setSampleDistance(originalSampleDistance);
                    viewport.render();
                    this._hasResolutionChanged = false;
                };
                document.addEventListener('mouseup', this.cleanUp, { once: true });
            }
            return true;
        };
        this._getViewportsInfo = () => {
            const viewports = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_5__.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.onSetToolActive = () => {
            const subscribeToElementResize = () => {
                const viewportsInfo = this._getViewportsInfo();
                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                    if (!this._resizeObservers.has(viewportId)) {
                        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId) || { viewport: null };
                        if (!viewport) {
                            return;
                        }
                        const { element } = viewport;
                        const resizeObserver = new ResizeObserver(() => {
                            const element = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByIds)(viewportId, renderingEngineId);
                            if (!element) {
                                return;
                            }
                            const { viewport } = element;
                            const viewPresentation = viewport.getViewPresentation();
                            viewport.resetCamera();
                            viewport.setViewPresentation(viewPresentation);
                            viewport.render();
                        });
                        resizeObserver.observe(element);
                        this._resizeObservers.set(viewportId, resizeObserver);
                    }
                });
            };
            subscribeToElementResize();
            this._viewportAddedListener = (evt) => {
                if (evt.detail.toolGroupId === this.toolGroupId) {
                    subscribeToElementResize();
                }
            };
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
        };
        this.onSetToolDisabled = () => {
            this._resizeObservers.forEach((resizeObserver, viewportId) => {
                resizeObserver.disconnect();
                this._resizeObservers.delete(viewportId);
            });
            if (this._viewportAddedListener) {
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.eventTarget.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
                this._viewportAddedListener = null;
            }
        };
        this.rotateCamera = (viewport, centerWorld, axis, angle) => {
            const vtkCamera = viewport.getVtkActiveCamera();
            const viewUp = vtkCamera.getViewUp();
            const focalPoint = vtkCamera.getFocalPoint();
            const position = vtkCamera.getPosition();
            const newPosition = [0, 0, 0];
            const newFocalPoint = [0, 0, 0];
            const newViewUp = [0, 0, 0];
            const transform = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(new Float32Array(16));
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.translate */ .pB.translate(transform, transform, centerWorld);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.rotate */ .pB.rotate(transform, transform, angle, axis);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.translate */ .pB.translate(transform, transform, [
                -centerWorld[0],
                -centerWorld[1],
                -centerWorld[2],
            ]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, position, transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, focalPoint, transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(transform);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.rotate */ .pB.rotate(transform, transform, angle, axis);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.transformMat4 */ .eR.transformMat4(newViewUp, viewUp, transform);
            viewport.setCamera({
                position: newPosition,
                viewUp: newViewUp,
                focalPoint: newFocalPoint,
            });
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, lastPoints } = evt.detail;
        const currentPointsCanvas = currentPoints.canvas;
        const lastPointsCanvas = lastPoints.canvas;
        const { rotateIncrementDegrees } = this.configuration;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const normalizedPosition = [
            currentPointsCanvas[0] / width,
            currentPointsCanvas[1] / height,
        ];
        const normalizedPreviousPosition = [
            lastPointsCanvas[0] / width,
            lastPointsCanvas[1] / height,
        ];
        const center = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(center);
        const normalizedCenter = [0.5, 0.5];
        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;
        const op = [normalizedPreviousPosition[0], 0, 0];
        const oe = [normalizedPosition[0], 0, 0];
        const opsq = op[0] ** 2;
        const oesq = oe[0] ** 2;
        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
        const nop = [op[0], 0, lop];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Ay.normalize(nop);
        const noe = [oe[0], 0, loe];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Ay.normalize(noe);
        const dot = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Ay.dot(nop, noe);
        if (Math.abs(dot) > 0.0001) {
            const angleX = -2 *
                Math.acos(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clampValue */ .Ay.clampValue(dot, -1.0, 1.0)) *
                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *
                rotateIncrementDegrees;
            const upVec = camera.viewUp;
            const atV = camera.viewPlaneNormal;
            const rightV = [0, 0, 0];
            const forwardV = [0, 0, 0];
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Ay.cross(upVec, atV, rightV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Ay.normalize(rightV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Ay.cross(atV, rightV, forwardV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Ay.normalize(forwardV);
            _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Ay.normalize(upVec);
            this.rotateCamera(viewport, centerWorld, forwardV, angleX);
            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *
                rotateIncrementDegrees;
            this.rotateCamera(viewport, centerWorld, rightV, angleY);
            viewport.render();
        }
    }
}
TrackballRotateTool.toolName = 'TrackballRotate';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TrackballRotateTool);


/***/ }),

/***/ 30588:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);



const DIRECTIONS = {
    X: [1, 0, 0],
    Y: [0, 1, 0],
    Z: [0, 0, 1],
    CUSTOM: [],
};
class VolumeRotateTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            direction: DIRECTIONS.Z,
            rotateIncrementDegrees: 30,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseWheelCallback(evt) {
        const { element, wheel } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { direction, rotateIncrementDegrees } = this.configuration;
        const camera = viewport.getCamera();
        const { viewUp, position, focalPoint } = camera;
        const { direction: deltaY } = wheel;
        const [cx, cy, cz] = focalPoint;
        const [ax, ay, az] = direction;
        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;
        const newPosition = [0, 0, 0];
        const newFocalPoint = [0, 0, 0];
        const newViewUp = [0, 0, 0];
        const transform = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.identity */ .pB.identity(new Float32Array(16));
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.translate */ .pB.translate(transform, transform, [cx, cy, cz]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.rotate */ .pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.translate */ .pB.translate(transform, transform, [-cx, -cy, -cz]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, position, transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, focalPoint, transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.identity */ .pB.identity(transform);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .mat4.rotate */ .pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.transformMat4 */ .eR.transformMat4(newViewUp, viewUp, transform);
        viewport.setCamera({
            position: newPosition,
            viewUp: newViewUp,
            focalPoint: newFocalPoint,
        });
        viewport.render();
    }
}
VolumeRotateTool.toolName = 'VolumeRotateMouseWheel';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumeRotateTool);


/***/ }),

/***/ 17819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58640);
/* harmony import */ var _utilities_voi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(97213);











class WindowLevelRegionTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minWindowWidth: 10,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                    cachedStats: {},
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__.triggerAnnotationCompleted)(annotation);
            this.applyWindowLevelRegion(annotation, element);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            const DEFAULT_HANDLE_INDEX = 3;
            points[DEFAULT_HANDLE_INDEX] = [...worldPos];
            const bottomLeftCanvas = worldToCanvas(points[0]);
            const topRightCanvas = worldToCanvas(points[3]);
            const bottomRightCanvas = [
                topRightCanvas[0],
                bottomLeftCanvas[1],
            ];
            const topLeftCanvas = [
                bottomLeftCanvas[0],
                topRightCanvas[1],
            ];
            const bottomRightWorld = canvasToWorld(bottomRightCanvas);
            const topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_5__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_2__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
            }
            return renderStatus;
        };
        this.applyWindowLevelRegion = (annotation, element) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const imageData = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.extractWindowLevelRegionToolData(viewport);
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const startCanvas = canvasCoordinates[0];
            const endCanvas = canvasCoordinates[3];
            let left = Math.min(startCanvas[0], endCanvas[0]);
            let top = Math.min(startCanvas[1], endCanvas[1]);
            let width = Math.abs(startCanvas[0] - endCanvas[0]);
            let height = Math.abs(startCanvas[1] - endCanvas[1]);
            left = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.clip(left, 0, imageData.width);
            top = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.clip(top, 0, imageData.height);
            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));
            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));
            const pixelLuminanceData = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);
            const minMaxMean = _utilities_voi__WEBPACK_IMPORTED_MODULE_10__.windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);
            if (this.configuration.minWindowWidth === undefined) {
                this.configuration.minWindowWidth = 10;
            }
            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);
            const windowCenter = minMaxMean.mean;
            const voiLutFunction = viewport.getProperties().VOILUTFunction;
            const voiRange = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
            viewport.setProperties({ voiRange });
            viewport.render();
        };
        this.cancel = () => {
            return null;
        };
        this.isPointNearTool = () => {
            return null;
        };
        this.toolSelectedCallback = () => {
            return null;
        };
        this.handleSelectedCallback = () => {
            return null;
        };
        this._activateModify = () => {
            return null;
        };
        this._deactivateModify = () => {
            return null;
        };
    }
}
WindowLevelRegionTool.toolName = 'WindowLevelRegion';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WindowLevelRegionTool);


/***/ }),

/***/ 43159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);


const DEFAULT_MULTIPLIER = 4;
const DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;
const PT = 'PT';
class WindowLevelTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            const frameLength = dimensions[0] * dimensions[1];
            let bytesPerVoxel;
            let TypedArrayConstructor;
            if (scalarData instanceof Float32Array) {
                bytesPerVoxel = 4;
                TypedArrayConstructor = Float32Array;
            }
            else if (scalarData instanceof Uint8Array) {
                bytesPerVoxel = 1;
                TypedArrayConstructor = Uint8Array;
            }
            else if (scalarData instanceof Uint16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Uint16Array;
            }
            else if (scalarData instanceof Int16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Int16Array;
            }
            const buffer = scalarData.buffer;
            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;
            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);
            const { max, min } = this._getMinMax(frame, frameLength);
            return max - min;
        };
    }
    touchDragCallback(evt) {
        this.mouseDragCallback(evt);
    }
    mouseDragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;
        let isPreScaled = false;
        const properties = viewport.getProperties();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            volumeId = viewport.getVolumeId();
            viewportsContainingVolumeUID =
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportsWithVolumeId(volumeId);
            ({ lower, upper } = properties.voiRange);
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
            if (!volume) {
                throw new Error('Volume not found ' + volumeId);
            }
            modality = volume.metadata.Modality;
            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;
        }
        else if (properties.voiRange) {
            modality = viewport.modality;
            ({ lower, upper } = properties.voiRange);
            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};
            isPreScaled =
                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;
        }
        else {
            throw new Error('Viewport is not a valid type');
        }
        if (modality === PT && isPreScaled) {
            newRange = this.getPTScaledNewRange({
                deltaPointsCanvas: deltaPoints.canvas,
                lower,
                upper,
                clientHeight: element.clientHeight,
                isPreScaled,
                viewport,
                volumeId,
            });
        }
        else {
            newRange = this.getNewRange({
                viewport,
                deltaPointsCanvas: deltaPoints.canvas,
                volumeId,
                lower,
                upper,
            });
        }
        if (newRange.lower >= newRange.upper) {
            return;
        }
        viewport.setProperties({
            voiRange: newRange,
        });
        viewport.render();
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            viewportsContainingVolumeUID.forEach((vp) => {
                if (viewport !== vp) {
                    vp.render();
                }
            });
            return;
        }
    }
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {
        let multiplier = DEFAULT_MULTIPLIER;
        if (isPreScaled) {
            multiplier = 5 / clientHeight;
        }
        else {
            multiplier =
                this._getMultiplierFromDynamicRange(viewport, volumeId) ||
                    DEFAULT_MULTIPLIER;
        }
        const deltaY = deltaPointsCanvas[1];
        const wcDelta = deltaY * multiplier;
        upper -= wcDelta;
        upper = isPreScaled ? Math.max(upper, 0.1) : upper;
        return { lower, upper };
    }
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {
        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||
            DEFAULT_MULTIPLIER;
        const wwDelta = deltaPointsCanvas[0] * multiplier;
        const wcDelta = deltaPointsCanvas[1] * multiplier;
        let { windowWidth, windowCenter } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toWindowLevel(lower, upper);
        windowWidth += wwDelta;
        windowCenter += wcDelta;
        windowWidth = Math.max(windowWidth, 1);
        const voiLutFunction = viewport.getProperties().VOILUTFunction;
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
    }
    _getMultiplierFromDynamicRange(viewport, volumeId) {
        let imageDynamicRange;
        if (volumeId) {
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
            const { voxelManager } = viewport.getImageData();
            const middleSlicePixelData = voxelManager.getMiddleSliceData();
            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {
                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];
            }, [Infinity, -Infinity]);
            const BitsStored = imageVolume?.metadata?.BitsStored;
            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;
            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);
        }
        else {
            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);
        }
        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;
        return ratio > 1 ? Math.round(ratio) : ratio;
    }
    _getImageDynamicRangeFromViewport(viewport) {
        const { imageData, voxelManager } = viewport.getImageData();
        if (voxelManager?.getRange) {
            const range = voxelManager.getRange();
            return range[1] - range[0];
        }
        const dimensions = imageData.getDimensions();
        if (imageData.getRange) {
            const imageDataRange = imageData.getRange();
            return imageDataRange[1] - imageDataRange[0];
        }
        let scalarData;
        if (imageData.getScalarData) {
            scalarData = imageData.getScalarData();
        }
        else {
            scalarData = imageData.getPointData().getScalars().getData();
        }
        if (dimensions[2] !== 1) {
            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);
        }
        let range;
        if (scalarData.getRange) {
            range = scalarData.getRange();
        }
        else {
            const { min, max } = this._getMinMax(scalarData, scalarData.length);
            range = [min, max];
        }
        return range[1] - range[0];
    }
    _getMinMax(frame, frameLength) {
        let min = Infinity;
        let max = -Infinity;
        for (let i = 0; i < frameLength; i++) {
            const voxel = frame[i];
            if (voxel < min) {
                min = voxel;
            }
            if (voxel > max) {
                max = voxel;
            }
        }
        return { max, min };
    }
}
WindowLevelTool.toolName = 'WindowLevel';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WindowLevelTool);


/***/ }),

/***/ 26938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84607);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);





class ZoomTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            zoomToCenter: false,
            minZoomScale: 0.001,
            maxZoomScale: 3000,
            pinchToZoom: true,
            pan: true,
            invert: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const camera = enabledElement.viewport.getCamera();
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), dirVec);
            this.dirVec = dirVec;
            return false;
        };
        this.preTouchStartCallback = (evt) => {
            if (!this.configuration.pinchToZoom) {
                return this.preMouseDownCallback(evt);
            }
        };
        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { parallelScale, focalPoint, position } = camera;
            const zoomScale = 5 / size[1];
            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);
            const parallelScaleToSet = (1.0 - k) * parallelScale;
            let focalPointToSet = focalPoint;
            let positionToSet = position;
            if (!this.configuration.zoomToCenter) {
                const distanceToCanvasCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(focalPoint, this.initialMousePosWorld);
                positionToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), position, this.dirVec, -distanceToCanvasCenter * k);
                focalPointToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);
            }
            const imageData = viewport.getImageData();
            let spacing = [1, 1, 1];
            if (imageData) {
                spacing = imageData.spacing;
            }
            const { minZoomScale, maxZoomScale } = this.configuration;
            const t = element.clientHeight * spacing[1] * 0.5;
            const scale = t / parallelScaleToSet;
            let cappedParallelScale = parallelScaleToSet;
            let thresholdExceeded = false;
            if (imageData) {
                if (scale < minZoomScale) {
                    cappedParallelScale = t / minZoomScale;
                    thresholdExceeded = true;
                }
                else if (scale >= maxZoomScale) {
                    cappedParallelScale = t / maxZoomScale;
                    thresholdExceeded = true;
                }
            }
            viewport.setCamera({
                parallelScale: cappedParallelScale,
                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,
                position: thresholdExceeded ? position : positionToSet,
            });
        };
        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { position, focalPoint, viewPlaneNormal } = camera;
            const distance = _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].distance2BetweenPoints */ .Ay.distance2BetweenPoints(position, focalPoint);
            const zoomScale = Math.sqrt(distance) / size[1];
            const directionOfProjection = [
                -viewPlaneNormal[0],
                -viewPlaneNormal[1],
                -viewPlaneNormal[2],
            ];
            const k = this.configuration.invert
                ? deltaY / zoomScale
                : deltaY * zoomScale;
            let tmp = k * directionOfProjection[0];
            position[0] += tmp;
            focalPoint[0] += tmp;
            tmp = k * directionOfProjection[1];
            position[1] += tmp;
            focalPoint[1] += tmp;
            tmp = k * directionOfProjection[2];
            position[2] += tmp;
            focalPoint[2] += tmp;
            viewport.setCamera({ position, focalPoint });
        };
        this.initialMousePosWorld = [0, 0, 0];
        this.dirVec = [0, 0, 0];
        if (this.configuration.pinchToZoom) {
            this.touchDragCallback = this._pinchCallback.bind(this);
        }
        else {
            this.touchDragCallback = this._dragCallback.bind(this);
        }
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    mouseWheelCallback(evt) {
        this._zoom(evt);
    }
    _pinchCallback(evt) {
        const pointsList = evt.detail
            .currentPointsList;
        if (pointsList.length > 1) {
            const { element, currentPoints } = evt.detail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const worldPos = currentPoints.world;
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), dirVec);
            this.dirVec = dirVec;
            if (camera.parallelProjection) {
                this._dragParallelProjection(evt, viewport, camera, true);
            }
            else {
                this._dragPerspectiveProjection(evt, viewport, camera, true);
            }
            viewport.render();
        }
        if (this.configuration.pan) {
            this._panCallback(evt);
        }
    }
    _dragCallback(evt) {
        const { element } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        if (camera.parallelProjection) {
            this._dragParallelProjection(evt, viewport, camera);
        }
        else {
            this._dragPerspectiveProjection(evt, viewport, camera);
        }
        viewport.render();
    }
    _zoom(evt) {
        const { element, points } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const wheelData = evt.detail.wheel;
        const direction = wheelData.direction;
        const eventDetails = {
            detail: {
                element,
                eventName: _enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_WHEEL,
                renderingEngineId: enabledElement.renderingEngineId,
                viewportId: viewport.id,
                camera: {},
                deltaPoints: {
                    page: points.page,
                    client: points.client,
                    world: points.world,
                    canvas: [0, -direction * 5],
                },
                startPoints: points,
                lastPoints: points,
                currentPoints: points,
            },
        };
        if (viewport.type === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.Enums.ViewportType.STACK) {
            this.preMouseDownCallback(eventDetails);
        }
        this._dragCallback(eventDetails);
    }
    _panCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
ZoomTool.toolName = 'Zoom';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZoomTool);


/***/ }),

/***/ 9608:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2076);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15305);
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25963);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(44049);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(29601);















class AngleTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Angle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            showAngleArc: false,
            arcOffset: 5,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2, point3] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            if (!point3) {
                return false;
            }
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const line2 = {
                start: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
                end: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
            };
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {
                this.editData.handleIndex = 2;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.angleStartedNotYetCompleted = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotation.annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_14__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                let lineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length !== 3) {
                    return renderStatus;
                }
                lineUID = '2';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                if (this.configuration.showAngleArc) {
                    const center = canvasCoordinates[1];
                    const offset = this.configuration.arcOffset;
                    const radius = Math.min(_utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), _utilities_math_line__WEBPACK_IMPORTED_MODULE_6__.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;
                    const anglePoints = [];
                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);
                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const angleDifference = endAngle - startAngle;
                    if (angleDifference > Math.PI) {
                        const temp = startAngle;
                        startAngle = endAngle;
                        endAngle = temp + 2 * Math.PI;
                    }
                    const segments = 32;
                    for (let i = 0; i <= segments; i++) {
                        const angle = startAngle + (i / segments) * (endAngle - startAngle);
                        anglePoints.push([
                            center[0] + radius * Math.cos(angle),
                            center[1] + radius * Math.sin(angle),
                        ]);
                    }
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawPath)(svgDrawingHelper, annotationUID, '3', anglePoints, {
                        color: color,
                        width: lineWidth,
                        lineDash: angleArcLineDash,
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_10__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_13__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 3) {
            return;
        }
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const worldPos3 = data.handles.points[2];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)([worldPos1, worldPos2], [worldPos2, worldPos3]);
            const { dimensions, imageData } = this.getTargetImageData(targetId);
            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]
                .map((worldPos) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, worldPos))
                .some((index) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index, dimensions));
            cachedStats[targetId] = {
                angle: isNaN(angle) ? 'Incomplete Angle' : angle,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    if (isNaN(angle)) {
        return [`${angle}`];
    }
    const textLines = [
        `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(angle)} ${String.fromCharCode(176)}`,
    ];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AngleTool);


/***/ }),

/***/ 24146:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2076);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15305);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(44049);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(29601);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(53860);














class ArrowAnnotateTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'ArrowAnnotate'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
            arrowFirst: true,
            arrowHeadStyle: 'legacy',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const { arrowFirst } = this.configuration;
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    text: '',
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        arrowFirst,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_5__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            if (newAnnotation) {
                this.configuration.getTextCallback((text) => {
                    if (!text) {
                        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
                        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
                        this.editData = null;
                        this.isDrawing = false;
                        return;
                    }
                    annotation.data.text = text;
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationCompleted)(annotation);
                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });
                    (0,_utilities__WEBPACK_IMPORTED_MODULE_13__.setAnnotationLabel)(annotation, element, text);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
                });
            }
            else if (!movingTextBox) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.touchTapCallback = (evt) => {
            if (evt.detail.taps == 2) {
                this.doubleClickCallback(evt);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.editData = null;
            this.isDrawing = false;
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles, text } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_12__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineWidth,
                    });
                }
                const arrowUID = '1';
                if (this.configuration.arrowFirst) {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                else {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                renderStatus = true;
                if (!text) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, points, text, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                text: text || '',
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_10__.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrowAnnotateTool);


/***/ }),

/***/ 25072:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60810);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(15305);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(473);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);

















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class BidirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Bidirectional'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            let canvasPoint1 = viewport.worldToCanvas(points[0]);
            let canvasPoint2 = viewport.worldToCanvas(points[1]);
            let line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            let distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            canvasPoint1 = viewport.worldToCanvas(points[2]);
            canvasPoint2 = viewport.worldToCanvas(points[3]);
            line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const data = annotation.data;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if (this.editData.handleIndex !== undefined) {
                const { points } = data.handles;
                const firstLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[0], points[1]);
                const secondLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[2], points[3]);
                if (secondLineSegmentLength > firstLineSegmentLength) {
                    const longAxis = [[...points[2]], [...points[3]]];
                    const shortAxisPoint0 = [...points[0]];
                    const shortAxisPoint1 = [...points[1]];
                    const longAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);
                    const counterClockWisePerpendicularToLongAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);
                    const currentShortAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);
                    let shortAxis;
                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.dot */ .Zc.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {
                        shortAxis = [shortAxisPoint0, shortAxisPoint1];
                    }
                    else {
                        shortAxis = [shortAxisPoint1, shortAxisPoint0];
                    }
                    data.handles.points = [
                        longAxis[0],
                        longAxis[1],
                        shortAxis[0],
                        shortAxis[1],
                    ];
                }
            }
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { worldToCanvas } = viewport;
            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            const worldPos = currentPoints.world;
            data.handles.points[handleIndex] = [...worldPos];
            const canvasCoordPoints = data.handles.points.map(worldToCanvas);
            const canvasCoords = {
                longLineSegment: {
                    start: {
                        x: canvasCoordPoints[0][0],
                        y: canvasCoordPoints[0][1],
                    },
                    end: {
                        x: canvasCoordPoints[1][0],
                        y: canvasCoordPoints[1][1],
                    },
                },
                shortLineSegment: {
                    start: {
                        x: canvasCoordPoints[2][0],
                        y: canvasCoordPoints[2][1],
                    },
                    end: {
                        x: canvasCoordPoints[3][0],
                        y: canvasCoordPoints[3][1],
                    },
                },
            };
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoordPoints[0], canvasCoordPoints[1]);
            const shortAxisDistFromCenter = dist / 3;
            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;
            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const vectorX = dx / length;
            const vectorY = dy / length;
            const xMid = (canvasCoords.longLineSegment.start.x +
                canvasCoords.longLineSegment.end.x) /
                2;
            const yMid = (canvasCoords.longLineSegment.start.y +
                canvasCoords.longLineSegment.end.y) /
                2;
            const startX = xMid + shortAxisDistFromCenter * vectorY;
            const startY = yMid - shortAxisDistFromCenter * vectorX;
            const endX = xMid - shortAxisDistFromCenter * vectorY;
            const endY = yMid + shortAxisDistFromCenter * vectorX;
            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);
            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            this.editData.hasMoved = true;
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragModifyHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragModifyHandle = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotation, handleIndex: movingHandleIndex } = this.editData;
            const { data } = annotation;
            const worldPos = currentPoints.world;
            const canvasCoordHandlesCurrent = [
                viewport.worldToCanvas(data.handles.points[0]),
                viewport.worldToCanvas(data.handles.points[1]),
                viewport.worldToCanvas(data.handles.points[2]),
                viewport.worldToCanvas(data.handles.points[3]),
            ];
            const firstLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[0][0],
                    y: canvasCoordHandlesCurrent[0][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[1][0],
                    y: canvasCoordHandlesCurrent[1][1],
                },
            };
            const secondLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[2][0],
                    y: canvasCoordHandlesCurrent[2][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[3][0],
                    y: canvasCoordHandlesCurrent[3][1],
                },
            };
            const proposedPoint = [...worldPos];
            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);
            if (movingHandleIndex === 0 || movingHandleIndex === 1) {
                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;
                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];
                const fixedHandleToProposedCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);
                const fixedHandleToOldCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -
                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -
                    fixedHandleCanvasCoord[1]);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);
                const proposedFirstLineSegment = {
                    start: {
                        x: fixedHandleCanvasCoord[0],
                        y: fixedHandleCanvasCoord[1],
                    },
                    end: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                };
                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {
                    return;
                }
                const centerOfRotation = fixedHandleCanvasCoord;
                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);
                let firstPointX = canvasCoordHandlesCurrent[2][0];
                let firstPointY = canvasCoordHandlesCurrent[2][1];
                let secondPointX = canvasCoordHandlesCurrent[3][0];
                let secondPointY = canvasCoordHandlesCurrent[3][1];
                firstPointX -= centerOfRotation[0];
                firstPointY -= centerOfRotation[1];
                secondPointX -= centerOfRotation[0];
                secondPointY -= centerOfRotation[1];
                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);
                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);
                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);
                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);
                firstPointX = rotatedFirstPoint + centerOfRotation[0];
                firstPointY = rotatedFirstPointY + centerOfRotation[1];
                secondPointX = rotatedSecondPoint + centerOfRotation[0];
                secondPointY = rotatedSecondPointY + centerOfRotation[1];
                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);
                const newSecondPoint = viewport.canvasToWorld([
                    secondPointX,
                    secondPointY,
                ]);
                data.handles.points[movingHandleIndex] = proposedPoint;
                data.handles.points[2] = newFirstPoint;
                data.handles.points[3] = newSecondPoint;
            }
            else {
                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;
                const canvasCoordsCurrent = {
                    longLineSegment: {
                        start: firstLineSegment.start,
                        end: firstLineSegment.end,
                    },
                    shortLineSegment: {
                        start: secondLineSegment.start,
                        end: secondLineSegment.end,
                    },
                };
                const longLineSegmentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordsCurrent.longLineSegment.end.x,
                    canvasCoordsCurrent.longLineSegment.end.y,
                ], [
                    canvasCoordsCurrent.longLineSegment.start.x,
                    canvasCoordsCurrent.longLineSegment.start.y,
                ]);
                const longLineSegmentVecNormalized = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), longLineSegmentVec);
                const proposedToCurrentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [
                    canvasCoordHandlesCurrent[movingHandleIndex][0],
                    canvasCoordHandlesCurrent[movingHandleIndex][1],
                ]);
                const movementLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.length */ .Zc.length(proposedToCurrentVec);
                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);
                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;
                const newTranslatedPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scaleAndAdd */ .Zc.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordHandlesCurrent[translateHandleIndex][0],
                    canvasCoordHandlesCurrent[translateHandleIndex][1],
                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);
                if (this._movingLongAxisWouldPutItThroughShortAxis({
                    start: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                    end: {
                        x: newTranslatedPoint[0],
                        y: newTranslatedPoint[1],
                    },
                }, {
                    start: {
                        x: canvasCoordsCurrent.longLineSegment.start.x,
                        y: canvasCoordsCurrent.longLineSegment.start.y,
                    },
                    end: {
                        x: canvasCoordsCurrent.longLineSegment.end.x,
                        y: canvasCoordsCurrent.longLineSegment.end.y,
                    },
                })) {
                    return;
                }
                const intersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
                if (!intersectionPoint) {
                    return;
                }
                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);
                data.handles.points[movingHandleIndex] = proposedPoint;
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {
            const vectorInSecondLineDirection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);
            const extendedSecondLineSegment = {
                start: {
                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,
                },
                end: {
                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,
                },
            };
            const proposedIntersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
            const wouldPutThroughShortAxis = !proposedIntersectionPoint;
            return wouldPutThroughShortAxis;
        };
        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { element } = enabledElement.viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const worldPos3 = data.handles.points[2];
            const worldPos4 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, dimensions } = image;
                const index1 = transformWorldToIndex(imageData, worldPos1);
                const index2 = transformWorldToIndex(imageData, worldPos2);
                const index3 = transformWorldToIndex(imageData, worldPos3);
                const index4 = transformWorldToIndex(imageData, worldPos4);
                const handles1 = [index1, index2];
                const handles2 = [index3, index4];
                const { scale: scale1, unit: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles1);
                const { scale: scale2, unit: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles2);
                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;
                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;
                const length = dist1 > dist2 ? dist1 : dist2;
                const width = dist1 > dist2 ? dist2 : dist1;
                const unit = dist1 > dist2 ? units1 : units2;
                const widthUnit = dist1 > dist2 ? units2 : units1;
                this._isInsideVolume(index1, index2, index3, index4, dimensions)
                    ? (this.isHandleOutsideImage = false)
                    : (this.isHandleOutsideImage = true);
                cachedStats[targetId] = {
                    length,
                    width,
                    unit,
                    widthUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index3, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index4, dimensions));
        };
        this._getSignedAngle = (vector1, vector2) => {
            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, [], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)([viewport.id]);
        return annotation;
    }; }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
}
function defaultGetTextLines(data, targetId) {
    const { cachedStats, label } = data;
    const { length, width, unit } = cachedStats[targetId];
    const textLines = [];
    if (label) {
        textLines.push(label);
    }
    if (length === undefined) {
        return textLines;
    }
    textLines.push(`L: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit || unit}`, `W: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(width)} ${unit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BidirectionalTool);


/***/ }),

/***/ 31137:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(473);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(62514);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(58640);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(40634);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(77081);
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(11683);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(73262);





















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class CircleROITool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    static { this.toolName = 'CircleROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)(canvasCoordinates);
            const radiusPoint = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)([
                canvasCoordinates[0],
                canvasCoords,
            ]);
            if (Math.abs(radiusPoint - radius) < proximity / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            data.handles.points = [
                data.handles.points[0],
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation, handleIndex } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0) {
                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
                const canvasCenter = currentCanvasPoints;
                const canvasEnd = [
                    canvasCoordinates[1][0] + dXCanvas,
                    canvasCoordinates[1][1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasCenter);
                points[1] = canvasToWorld(canvasEnd);
            }
            else {
                points[1] = canvasToWorld(currentCanvasPoints);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_14__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleRadius)(canvasCoordinates);
                const canvasCorners = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleCorners)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                        radius: null,
                        radiusUnit: null,
                        perimeter: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-circle`;
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_12__.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const wasInvalidated = annotation.invalidated;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_18__.getCanvasCircleCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const center = [
                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                    ];
                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
                    const ellipseObj = {
                        center,
                        xRadius: xRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : xRadius,
                        yRadius: yRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : yRadius,
                        zRadius: zRadius < _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.EPSILON / 2 ? 0 : zRadius,
                    };
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                    const handles = [pos1Index, pos2Index];
                    const { scale, unit, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
                    const aspect = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedAspect */ .CQ)(image);
                    const area = Math.abs(Math.PI *
                        (worldWidth / scale / 2) *
                        (worldHeight / aspect / scale / 2));
                    const pixelUnitsOptions = {
                        isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_17__/* .isViewportPreScaled */ .u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_16__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                        isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_19__.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                        boundsIJK,
                        imageData,
                        returnPoints: this.configuration.storePointData,
                    });
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        max: stats.max?.value,
                        pointsInShape,
                        stdDev: stats.stdDev?.value,
                        statsArray: stats.array,
                        isEmptyArea,
                        areaUnit,
                        radius: worldWidth / 2 / scale,
                        radiusUnit: unit,
                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            annotation.invalidated = false;
            if (wasInvalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;
    const textLines = [];
    if (radius) {
        const radiusLine = isEmptyArea
            ? `Radius: Oblique not supported`
            : `Radius: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(radius)} ${radiusUnit}`;
        textLines.push(radiusLine);
    }
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleROITool);


/***/ }),

/***/ 99718:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15305);
/* harmony import */ var _utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25963);
/* harmony import */ var _utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(82983);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(473);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(29601);


















class CobbAngleTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'CobbAngle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            showArcLines: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({
                viewport,
                points: data.handles.points,
                canvasCoords,
                proximity,
            });
            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({
                viewport,
                points: annotation.data.handles.points,
                canvasCoords,
                proximity,
            });
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
                isNearFirstLine,
                isNearSecondLine,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
                this.editData.handleIndex = data.handles.points.length;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._mouseDownCallback = (evt) => {
            const { annotation, handleIndex } = this.editData;
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const worldPos = currentPoints.world;
            const { data } = annotation;
            if (handleIndex === 1) {
                data.handles.points[1] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[1][0] !== data.handles.points[0][0] ||
                        data.handles.points[1][1] !== data.handles.points[0][0];
                return;
            }
            if (handleIndex === 3) {
                data.handles.points[3] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[3][0] !== data.handles.points[2][0] ||
                        data.handles.points[3][1] !== data.handles.points[2][0];
                this.angleStartedNotYetCompleted = false;
                return;
            }
            this.editData.hasMoved = false;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
            data.handles.points[2] = data.handles.points[3] = worldPos;
            this.editData.handleIndex = data.handles.points.length - 1;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined &&
                (isNearFirstLine || isNearSecondLine)) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                if (isNearFirstLine) {
                    const firstLinePoints = [points[0], points[1]];
                    firstLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                else if (isNearSecondLine) {
                    const secondLinePoints = [points[2], points[3]];
                    secondLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length < 4) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.angleStartedNotYetCompleted = false;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_12__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                        arc1Angle: null,
                        arc2Angle: null,
                        points: {
                            world: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                            canvas: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                        },
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_17__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];
                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];
                let lineUID = 'line1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length < 4) {
                    return renderStatus;
                }
                lineUID = 'line2';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                lineUID = 'linkLine';
                const mid1 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(firstLine[0], firstLine[1]);
                const mid2 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(secondLine[0], secondLine[1]);
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {
                    color,
                    lineWidth: '1',
                    lineDash: '1,4',
                });
                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;
                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];
                if (this.configuration.showArcLines) {
                    lineUID = 'arc1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {
                        color,
                        lineWidth: '1',
                    });
                    lineUID = 'arc2';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {
                        color,
                        lineWidth: '1',
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = 'cobbAngleText';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
                if (this.configuration.showArcLines) {
                    const arc1TextBoxUID = 'arcAngle1';
                    const arc1TextLine = [
                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch1TextPosCanvas = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(arc1Start, arc1End);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawTextBox)(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                    const arc2TextBoxUID = 'arcAngle2';
                    const arc2TextLine = [
                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch2TextPosCanvas = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(arc2Start, arc2End);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_11__.drawTextBox)(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                }
            }
            return renderStatus;
        };
        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {
            const [point1, point2, point3, point4] = points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const canvasPoint4 = viewport.worldToCanvas(point4);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const line2 = {
                start: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
                end: {
                    x: canvasPoint4[0],
                    y: canvasPoint4[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const distanceToPoint2 = _utilities_math_line__WEBPACK_IMPORTED_MODULE_8__.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            let isNearFirstLine = false;
            let isNearSecondLine = false;
            if (distanceToPoint <= proximity) {
                isNearFirstLine = true;
            }
            else if (distanceToPoint2 <= proximity) {
                isNearSecondLine = true;
            }
            return {
                distanceToPoint,
                distanceToPoint2,
                isNearFirstLine,
                isNearSecondLine,
            };
        };
        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {
            const linkLine = [mid1, mid2];
            const arc1Angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(firstLine, linkLine);
            const arc2Angle = (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(secondLine, linkLine);
            const arc1Side = arc1Angle > 90 ? 1 : 0;
            const arc2Side = arc2Angle > 90 ? 0 : 1;
            const midLinkLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(linkLine[0], linkLine[1]);
            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +
                (linkLine[1][1] - linkLine[0][1]) ** 2);
            const ratio = 0.1;
            const midFirstLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(firstLine[0], firstLine[1]);
            const midSecondLine = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(secondLine[0], secondLine[1]);
            const directionVectorStartArc1 = [
                firstLine[arc1Side][0] - midFirstLine[0],
                firstLine[arc1Side][1] - midFirstLine[1],
            ];
            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);
            const normalizedDirectionStartArc1 = [
                directionVectorStartArc1[0] / magnitudeStartArc1,
                directionVectorStartArc1[1] / magnitudeStartArc1,
            ];
            const arc1Start = [
                midFirstLine[0] +
                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,
                midFirstLine[1] +
                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc1 = [
                midLinkLine[0] - mid1[0],
                midLinkLine[1] - mid1[1],
            ];
            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);
            const normalizedDirectionEndArc1 = [
                directionVectorEndArc1[0] / magnitudeEndArc1,
                directionVectorEndArc1[1] / magnitudeEndArc1,
            ];
            const arc1End = [
                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,
                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorStartArc2 = [
                secondLine[arc2Side][0] - midSecondLine[0],
                secondLine[arc2Side][1] - midSecondLine[1],
            ];
            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);
            const normalizedDirectionStartArc2 = [
                directionVectorStartArc2[0] / magnitudeStartArc2,
                directionVectorStartArc2[1] / magnitudeStartArc2,
            ];
            const arc2Start = [
                midSecondLine[0] +
                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,
                midSecondLine[1] +
                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc2 = [
                midLinkLine[0] - mid2[0],
                midLinkLine[1] - mid2[1],
            ];
            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);
            const normalizedDirectionEndArc2 = [
                directionVectorEndArc2[0] / magnitudeEndArc2,
                directionVectorEndArc2[1] / magnitudeEndArc2,
            ];
            const arc2End = [
                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,
                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,
            ];
            return {
                arc1Start,
                arc1End,
                arc2Start,
                arc2End,
                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,
                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,
            };
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 25, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_13__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_16__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        if (data.handles.points.length !== 4) {
            return;
        }
        const seg1 = [null, null];
        const seg2 = [null, null];
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 2; i += 1) {
            for (let j = 2; j < 4; j += 1) {
                const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(data.handles.points[i], data.handles.points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    seg1[1] = data.handles.points[i];
                    seg1[0] = data.handles.points[(i + 1) % 2];
                    seg2[0] = data.handles.points[j];
                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];
                }
            }
        }
        const { viewport } = enabledElement;
        const { element } = viewport;
        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const firstLine = [canvasPoints[0], canvasPoints[1]];
        const secondLine = [canvasPoints[2], canvasPoints[3]];
        const mid1 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(firstLine[0], firstLine[1]);
        const mid2 = (0,_utilities_math_midPoint__WEBPACK_IMPORTED_MODULE_10__/* .midPoint2 */ .f)(secondLine[0], secondLine[1]);
        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({
            firstLine,
            secondLine,
            mid1,
            mid2,
        });
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            cachedStats[targetId] = {
                angle: (0,_utilities_math_angle_angleBetweenLines__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(seg1, seg2),
                arc1Angle,
                arc2Angle,
                points: {
                    canvas: {
                        arc1Start,
                        arc1End,
                        arc2End,
                        arc2Start,
                    },
                    world: {
                        arc1Start: viewport.canvasToWorld(arc1Start),
                        arc1End: viewport.canvasToWorld(arc1End),
                        arc2End: viewport.canvasToWorld(arc2End),
                        arc2Start: viewport.canvasToWorld(arc2Start),
                    },
                },
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CobbAngleTool);


/***/ }),

/***/ 40487:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58640);
/* harmony import */ var _ProbeTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61873);






class DragProbeTool extends _ProbeTool__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A {
    static { this.toolName = 'DragProbe'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.postMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                invalidated: true,
                highlighted: true,
                isVisible: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: { points: [[...worldPos]] },
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_2__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.postTouchStartCallback = (evt) => {
            return this.postMouseDownCallback(evt);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            if (!this.editData) {
                return renderStatus;
            }
            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const annotation = this.editData.annotation;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const point = data.handles.points[0];
            const canvasCoordinates = viewport.worldToCanvas(point);
            styleSpecifier.annotationUID = annotationUID;
            const { color } = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!data.cachedStats[targetId] ||
                data.cachedStats[targetId].value === null) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    index: null,
                    value: null,
                };
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const handleGroupUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_1__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
            renderStatus = true;
            const textLines = this.configuration.getTextLines(data, targetId);
            if (textLines) {
                const textCanvasCoordinates = [
                    canvasCoordinates[0] + 6,
                    canvasCoordinates[1] - 6,
                ];
                const textUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_1__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));
            }
            return renderStatus;
        };
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DragProbeTool);


/***/ }),

/***/ 8467:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58640);
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(77081);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3823);













const CROSSHAIR_SIZE = 5;
class ETDRSGridTool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    static { this.toolName = 'ETDRSGrid'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            degrees: [45, 135, 225, 315],
            diameters: [10, 30, 60],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                    },
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const center = viewport.worldToCanvas(points[0]);
            const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_11__.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radius) < proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points = [
                canvasToWorld(currentCanvasPoints),
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { deltaPoints } = eventDetail;
            const worldPosDelta = deltaPoints.world;
            const points = data.handles.points;
            points.forEach((point) => {
                point[0] += worldPosDelta[0];
                point[1] += worldPosDelta[1];
                point[2] += worldPosDelta[2];
            });
            annotation.invalidated = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
            const canvasCenter = currentCanvasPoints;
            const canvasEnd = [
                canvasCoordinates[1][0] + dXCanvas,
                canvasCoordinates[1][1] + dYCanvas,
            ];
            points[0] = canvasToWorld(canvasCenter);
            points[1] = canvasToWorld(canvasEnd);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                let lineUID = `${annotationUID}-crosshair-vertical`;
                let start = [center[0], center[1] + CROSSHAIR_SIZE];
                let end = [center[0], center[1] - CROSSHAIR_SIZE];
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                lineUID = `${annotationUID}-crosshair-horizontal`;
                start = [center[0] + CROSSHAIR_SIZE, center[1]];
                end = [center[0] - CROSSHAIR_SIZE, center[1]];
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));
                for (let i = 0; i < diametersCanvas.length; i++) {
                    const dataId = `${annotationUID}-circle-${i}`;
                    const circleUID = `${annotationUID}-circle-${i}`;
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {
                        color,
                        lineDash,
                        lineWidth,
                    }, dataId);
                }
                const degreesRad = (x) => (x * Math.PI) / 180;
                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));
                for (let i = 0; i < angleRadians.length; i++) {
                    const lineUID = `${annotationUID}-line-${i}`;
                    const start = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],
                    ];
                    const end = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],
                    ];
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                renderStatus = true;
            }
            return renderStatus;
        };
    }
    worldMeasureToCanvas(measurement, viewport) {
        const p1 = viewport.canvasToWorld([
            viewport.canvas.width / 2,
            viewport.canvas.height / 2,
        ]);
        const { viewUp } = viewport.getCamera();
        const p2 = gl_matrix__WEBPACK_IMPORTED_MODULE_12__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_12__/* .vec3.create */ .eR.create(), p1, viewUp, measurement);
        const p1Canvas = viewport.worldToCanvas(p1);
        const p2Canvas = viewport.worldToCanvas(p2);
        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +
            Math.pow(p2Canvas[1] - p1Canvas[1], 2));
        return distance;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ETDRSGridTool);


/***/ }),

/***/ 78684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(473);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(62514);
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(11683);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(40634);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(73262);




















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class EllipticalROITool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    static { this.toolName = 'EllipticalROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    initialRotation: viewport.getRotation(),
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                centerWorld: worldPos,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const canvasCorners = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates);
            const [canvasPoint1, canvasPoint2] = canvasCorners;
            const minorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,
            };
            const majorEllipse = {
                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,
                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,
                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,
                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,
            };
            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);
            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);
            if (pointInMajorEllipse && !pointInMinorEllipse) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            let centerCanvas;
            let centerWorld;
            let canvasWidth;
            let canvasHeight;
            let originalHandleCanvas;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = viewport;
                handleIndex = points.findIndex((p) => p === handle);
                const pointsCanvas = points.map(worldToCanvas);
                originalHandleCanvas = pointsCanvas[handleIndex];
                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);
                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);
                centerCanvas = [
                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,
                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,
                ];
                centerWorld = canvasToWorld(centerCanvas);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                canvasWidth,
                canvasHeight,
                centerWorld,
                originalHandleCanvas,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];
            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];
            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];
            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = viewport;
            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const { points } = data.handles;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0 || handleIndex === 1) {
                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - dYCanvas,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];
                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;
                const canvasLeft = [
                    centerCanvas[0] - newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
            }
            else {
                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
                const canvasLeft = [
                    centerCanvas[0] - dXCanvas,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + dXCanvas,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];
                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - newHalfCanvasHeight,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + newHalfCanvasHeight,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasCorners = ((0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates));
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-ellipse`;
                const ellipseUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawEllipseByCoordinates)(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);
                    if (minRadius > 3 * centerPointRadius) {
                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawCircle)(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_12__.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.getCanvasEllipseCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const post2Index = transformWorldToIndex(imageData, worldPos2);
                post2Index[0] = Math.floor(post2Index[0]);
                post2Index[1] = Math.floor(post2Index[1]);
                post2Index[2] = Math.floor(post2Index[2]);
                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);
                const iMin = Math.min(pos1Index[0], post2Index[0]);
                const iMax = Math.max(pos1Index[0], post2Index[0]);
                const jMin = Math.min(pos1Index[1], post2Index[1]);
                const jMax = Math.max(pos1Index[1], post2Index[1]);
                const kMin = Math.min(pos1Index[2], post2Index[2]);
                const kMax = Math.max(pos1Index[2], post2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = [
                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                ];
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                const handles = [pos1Index, post2Index];
                const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /
                    scale /
                    scale;
                const pixelUnitsOptions = {
                    isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__/* .isViewportPreScaled */ .u)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_14__.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                    returnPoints: this.configuration.storePointData,
                });
                const stats = this.configuration.statsCalculator.getStatistics();
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    mean: stats.mean?.value,
                    max: stats.max?.value,
                    stdDev: stats.stdDev?.value,
                    statsArray: stats.array,
                    pointsInShape,
                    isEmptyArea,
                    areaUnit,
                    modalityUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)([viewport.id]);
    }; }
    _pointInEllipseCanvas(ellipse, location) {
        const xRadius = ellipse.width / 2;
        const yRadius = ellipse.height / 2;
        if (xRadius <= 0.0 || yRadius <= 0.0) {
            return false;
        }
        const center = [ellipse.left + xRadius, ellipse.top + yRadius];
        const normalized = [location[0] - center[0], location[1] - center[1]];
        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +
            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=
            1.0;
        return inEllipse;
    }
    _getCanvasEllipseCenter(ellipseCanvasPoints) {
        const [bottom, top, left, right] = ellipseCanvasPoints;
        const topLeft = [left[0], top[1]];
        const bottomRight = [right[0], bottom[1]];
        return [
            (topLeft[0] + bottomRight[0]) / 2,
            (topLeft[1] + bottomRight[1]) / 2,
        ];
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (mean) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (max) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (stdDev) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EllipticalROITool);


/***/ }),

/***/ 59320:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15305);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(473);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class HeightTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Height'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const heightUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHeight)(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash: lineDash,
                });
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateHeight(pos1, pos2) {
        const dx = pos2[0] - pos1[0];
        const dy = pos2[1] - pos1[1];
        const dz = pos2[2] - pos1[2];
        if (dx == 0) {
            if (dy != 0) {
                return Math.abs(dz);
            }
            else {
                return 0;
            }
        }
        else if (dy == 0) {
            return Math.abs(dz);
        }
        else if (dz == 0) {
            return Math.abs(dy);
        }
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = transformWorldToIndex(imageData, worldPos1);
            const index2 = transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
            const height = this._calculateHeight(worldPos1, worldPos2) / scale;
            const outside = this._isInsideVolume(index1, index2, dimensions);
            this.isHandleOutsideImage = outside;
            cachedStats[targetId] = {
                height,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { height, unit } = cachedVolumeStats;
    if (height === undefined || height === null || isNaN(height)) {
        return;
    }
    const textLines = [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(height)} ${unit}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeightTool);


/***/ }),

/***/ 33327:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7001);










class KeyImageTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'KeyImage'; }
    static { this.dataSeries = {
        data: {
            seriesLevel: true,
        },
    }; }
    static { this.dataPoint = {
        data: {
            isPoint: true,
        },
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextCallback,
            changeTextCallback,
            canvasPosition: [10, 10],
            canvasSize: 10,
            handleRadius: '6',
            seriesLevel: false,
            isPoint: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const worldPos = currentPoints.world;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                    seriesLevel: this.configuration.seriesLevel,
                    isPoint: this.configuration.isPoint,
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            this.configuration.getTextCallback((text) => {
                if (!text) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                annotation.data.text = text;
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            if (!data?.isPoint) {
                return false;
            }
            const { canvasPosition, canvasSize } = this.configuration;
            if (!canvasPosition?.length) {
                return false;
            }
            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=
                canvasSize / 2 &&
                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=
                    canvasSize / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            annotation.highlighted = true;
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.createMemo(element, annotation);
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.isDrawing = false;
            this.doneEditMemo();
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { canvasPosition, canvasSize } = this.configuration;
                const arrowUID = '1';
                if (data?.isPoint) {
                    const point = data.handles.points[0];
                    const canvasCoordinates = viewport.worldToCanvas(point);
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {
                        color,
                        lineWidth,
                        handleRadius: this.configuration.handleRadius,
                    });
                }
                else if (canvasPosition?.length) {
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {
                        color,
                        width: 1,
                    });
                }
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
            }
            return renderStatus;
        };
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {
        annotation.data.isPoint = isPoint;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element);
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element);
    }
    cancel(element) {
        if (this.isDrawing) {
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_9__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        }
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyImageTool);


/***/ }),

/***/ 37117:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44049);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(29601);












class LabelTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Label'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotationUID } = annotation;
            const point = annotation.data.handles.points[0];
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, annotationCanvasCoordinate);
            if (dist < proximity) {
                return true;
            }
            const svgLayer = element.querySelector('svg');
            if (!svgLayer) {
                return false;
            }
            const textGroup = svgLayer.querySelector(`g[data-annotation-uid="${annotationUID}"]`);
            if (!textGroup) {
                return false;
            }
            const textGroupElement = textGroup;
            const bbox = textGroupElement.getBBox();
            const transform = textGroupElement.getAttribute('transform');
            let translateX = 0;
            let translateY = 0;
            if (transform) {
                const matches = transform.match(/translate\(([-\d.]+)\s+([-\d.]+)\)/);
                if (matches) {
                    translateX = parseFloat(matches[1]);
                    translateY = parseFloat(matches[2]);
                }
            }
            const x = bbox.x + translateX;
            const y = bbox.y + translateY;
            const isNear = canvasCoords[0] >= x &&
                canvasCoords[0] <= x + bbox.width &&
                canvasCoords[1] >= y &&
                canvasCoords[1] <= y + bbox.height;
            return isNear;
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID: null,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    text: '',
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                    },
                    label: '',
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
                offset: [0, 0, 0],
            };
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            this.configuration.getTextCallback((text) => {
                if (!text) {
                    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
                    (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                annotation.data.text = text;
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            let offset = [0, 0, 0];
            if (currentPoints && currentPoints.world) {
                const initialWorldPos = currentPoints.world;
                const anchorWorldPos = annotation.data.handles.points[0];
                offset = [
                    anchorWorldPos[0] - initialWorldPos[0],
                    anchorWorldPos[1] - initialWorldPos[1],
                    anchorWorldPos[2] - initialWorldPos[2],
                ];
            }
            this.editData = {
                annotation,
                viewportIdsToRender,
                offset,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, offset } = this.editData;
            if (offset) {
                annotation.data.handles.points[0] = [
                    worldPos[0] + offset[0],
                    worldPos[1] + offset[1],
                    worldPos[2] + offset[2],
                ];
            }
            else {
                annotation.data.handles.points[0] = [...worldPos];
            }
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.LabelChange);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const point = data.handles.points[0];
                styleSpecifier.annotationUID = annotationUID;
                const canvasCoordinates = viewport.worldToCanvas(point);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!data.text) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                const textBoxUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [data.text], canvasCoordinates, {
                    ...options,
                    padding: 0,
                });
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, position, text, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        const instance = new this();
        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.uuidv4(),
            data: {
                text,
                handles: {
                    points: [position],
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...options,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle, interactionType) { }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.text = updatedText;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_9__.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
LabelTool.toolName = 'Label';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LabelTool);


/***/ }),

/***/ 14335:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15305);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(473);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class LengthTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Length'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [{ key: 'z' }],
                },
                redo: {
                    method: 'redo',
                    bindings: [{ key: 'y' }],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_11__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const dataId = `${annotationUID}-line`;
                const lineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_10__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = transformWorldToIndex(imageData, worldPos1);
            const index2 = transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
            const length = this._calculateLength(worldPos1, worldPos2) / scale;
            if (this._isInsideVolume(index1, index2, dimensions)) {
                this.isHandleOutsideImage = false;
            }
            else {
                this.isHandleOutsideImage = true;
            }
            cachedStats[targetId] = {
                length,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { length, unit } = cachedVolumeStats;
    if (length === undefined || length === null || isNaN(length)) {
        return;
    }
    const textLines = [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit}`];
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LengthTool);


/***/ }),

/***/ 76358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _LivewireContourTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9136);
/* harmony import */ var _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38776);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44049);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);






class LivewireContourSegmentationTool extends _LivewireContourTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
    static { this.toolName = 'LivewireContourSegmentationTool'; }
    updateInterpolatedAnnotation(annotation, enabledElement) {
        if (this.editData ||
            !annotation.invalidated ||
            !annotation.data.handles.interpolationSources) {
            return;
        }
        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;
        queueMicrotask(() => {
            if (!annotation.data.handles.interpolationSources) {
                return;
            }
            const { points } = annotation.data.handles;
            const { element } = enabledElement.viewport;
            this.setupBaseEditData(points[0], element, annotation);
            const { length: count } = points;
            const { scissors } = this;
            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;
            annotation.data.handles.originalPoints = points;
            const { worldToSlice, sliceToWorld } = this.editData;
            const handleSmoothing = [];
            if (nearestEdge) {
                let lastPoint = worldToSlice(points[points.length - 1]);
                points.forEach((point, hIndex) => {
                    const testPoint = worldToSlice(point);
                    lastPoint = testPoint;
                    handleSmoothing.push(testPoint);
                    scissors.startSearch(lastPoint);
                    scissors.findPathToPoint(testPoint);
                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));
                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);
                    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(testPoint, minPoint)) {
                        handleSmoothing[hIndex] = minPoint;
                        lastPoint = minPoint;
                        points[hIndex] = sliceToWorld(minPoint);
                    }
                });
            }
            const acceptedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_2__/* .LivewirePath */ .j();
            for (let i = 0; i < count; i++) {
                scissors.startSearch(worldToSlice(points[i]));
                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));
                acceptedPath.addPoints(path);
            }
            this.updateAnnotation(acceptedPath);
            this.scissors = null;
            this.scissorsNext = null;
            this.editData = null;
            annotation.data.handles.interpolationSources = null;
            if (repeatInterpolation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_3__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, _enums__WEBPACK_IMPORTED_MODULE_4__.ChangeTypes.InterpolationUpdated);
            }
        });
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { showInterpolationPolyline } = this.configuration.interpolation || {};
        this.updateInterpolatedAnnotation?.(annotation, enabledElement);
        const { originalPolyline } = annotation.data.contour;
        const rendered = super.renderAnnotationInstance(renderContext);
        if (showInterpolationPolyline &&
            originalPolyline &&
            annotation.autoGenerated) {
            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);
            polylineCanvasPoints.push(polylineCanvasPoints[0]);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawPolyline)(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {
                color: '#70ffff',
                lineWidth: 1,
                fillOpacity: 0,
            });
        }
        return rendered;
    }
    isContourSegmentationTool() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivewireContourSegmentationTool);


/***/ }),

/***/ 9136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99737);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7001);
/* harmony import */ var _eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(76910);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(95527);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58640);
/* harmony import */ var _utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(98013);
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(93126);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(44049);
/* harmony import */ var _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(78044);
/* harmony import */ var _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(38776);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(60810);
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(36320);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(473);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(53860);



















const CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
class LivewireContourTool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A {
    static { this.toolName = 'LivewireContour'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextLines: defaultGetTextLines,
            calculateStats: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
            snapHandleNearby: 2,
            interpolation: {
                enabled: false,
                nearestEdge: 2,
                showInterpolationPolyline: false,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            actions: {
                cancelInProgress: {
                    method: 'cancelInProgress',
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt, clearAnnotation = false) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if ((this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) ||
                clearAnnotation) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
                this.clearEditData();
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
                return;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            const changeType = newAnnotation
                ? _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed
                : _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.HandlesUpdated;
            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
            this.clearEditData();
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {
            if (changeType === _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerContourAnnotationCompleted)(annotation, contourHoleProcessingEnabled);
            }
            else {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, changeType);
            }
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === _enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
            let worldPos = worldPosOriginal;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            this.doneEditMemo();
            this.createMemo(element, annotation, {
                newAnnotation: newAnnotation && controlPoints.length === 1,
            });
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            const { snapHandleNearby } = this.configuration;
            if (snapHandleNearby && !this.editData.closed) {
                const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
                const pathPoints = this.scissors.findPathToPoint(snapPoint);
                currentPath.addPoints(pathPoints);
                currentPath.prependPath(this.editData.confirmedPath);
                worldPos = sliceToWorld(snapPoint);
                this.editData.currentPath = currentPath;
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            const lastPoint = this.editData.currentPath.getLastPoint();
            this.editData.confirmedPath.addControlPoint(lastPoint);
            annotation.data.handles.points.push(sliceToWorld(lastPoint));
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            if (this.editData.closed) {
                this.updateAnnotation(this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
            currentPath.addPoints(pathPoints);
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                console.warn('Drag annotation not implemented');
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                this.editHandle(worldPos, element, annotation, handleIndex);
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            this.doneEditMemo();
            this.scissors = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,_utilities__WEBPACK_IMPORTED_MODULE_18__.getCalibratedLengthUnitsAndScale)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = _utilities_math__WEBPACK_IMPORTED_MODULE_8__.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit: areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.contour.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_17__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget, eventType, eventDetail);
        };
        this._throttledCalculateCachedStats = (0,_utilities__WEBPACK_IMPORTED_MODULE_18__.throttle)(this._calculateCachedStats, 100, { trailing: true });
    }
    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let width;
        let height;
        let scalarData;
        if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport)) {
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
            scalarData = viewportImageData.scalarData;
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            const sliceImageData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(vtkImageData, point);
                const slicePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        scalarData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.convertToGrayscale(scalarData, width, height);
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__/* .LivewireScissors */ .f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        if (nextPos) {
            this.scissorsNext = _utilities_livewire_LivewireScissors__WEBPACK_IMPORTED_MODULE_13__/* .LivewireScissors */ .f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
            this.scissorsNext.startSearch(worldToSlice(nextPos));
        }
        this.scissors.startSearch(startPos);
        const newAnnotation = !nextPos;
        const confirmedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
        const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
        const currentPathNext = newAnnotation ? undefined : new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_15__.getViewportIdsWithToolToRender)(element, this.getToolName());
        const lastCanvasPoint = viewport.worldToCanvas(worldPos);
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation,
            hasMoved: false,
            lastCanvasPoint,
            confirmedPath,
            currentPath,
            confirmedPathNext: currentPathNext,
            closed: false,
            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,
            worldToSlice,
            sliceToWorld,
            contourHoleProcessingEnabled,
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const annotation = this.createAnnotation(evt);
        const contourHoleProcessingEnabled = (0,_eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);
        this.addAnnotation(annotation, element);
        this._activateDraw(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.editData.viewportIdsToRender);
        return annotation;
    }
    clearEditData() {
        this.editData = null;
        this.scissors = null;
        this.scissorsNext = null;
        this.isDrawing = false;
    }
    editHandle(worldPos, element, annotation, handleIndex) {
        const { data } = annotation;
        const { points: handlePoints } = data.handles;
        const { length: numHandles } = handlePoints;
        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
        if (!this.editData?.confirmedPathNext) {
            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
            const { polyline } = data.contour;
            const confirmedPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
            const confirmedPathNext = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
            const { worldToSlice } = this.editData;
            const previousIndex = (0,_utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(annotation, handleIndex - 1);
            const nextIndex = (0,_utilities_contours_findHandlePolylineIndex__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(annotation, handleIndex + 1);
            if (nextIndex === -1 || previousIndex === -1) {
                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
            }
            if (handleIndex === 0) {
                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));
            }
            else {
                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));
                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));
            }
            this.editData.confirmedPath = confirmedPath;
            this.editData.confirmedPathNext = confirmedPathNext;
        }
        const { editData, scissors } = this;
        const { worldToSlice, sliceToWorld } = editData;
        const { activeHandleIndex } = data.handles;
        if (activeHandleIndex === null || activeHandleIndex === undefined) {
            data.handles.activeHandleIndex = handleIndex;
        }
        else if (activeHandleIndex !== handleIndex) {
            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
        }
        const slicePos = worldToSlice(worldPos);
        if (slicePos[0] < 0 ||
            slicePos[0] >= scissors.width ||
            slicePos[1] < 0 ||
            slicePos[1] >= scissors.height) {
            return;
        }
        handlePoints[handleIndex] = sliceToWorld(slicePos);
        const pathPointsLeft = scissors.findPathToPoint(slicePos);
        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);
        const currentPath = new _utilities_livewire_LiveWirePath__WEBPACK_IMPORTED_MODULE_14__/* .LivewirePath */ .j();
        currentPath.prependPath(editData.confirmedPath);
        if (handleIndex !== 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        currentPath.addPoints(pathPointsRight.reverse());
        currentPath.appendPath(editData.confirmedPathNext);
        if (handleIndex === 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        editData.currentPath = currentPath;
        annotation.invalidated = true;
        editData.hasMoved = true;
        editData.closed = true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        this.updateAnnotation(this.editData?.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
        return annotation;
    }
    cancelInProgress(element, config, evt) {
        if (!this.editData) {
            this.undo();
            return;
        }
        this._endCallback(evt, true);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;
        const { viewport } = enabledElement;
        const { element } = viewport;
        const { worldToCanvas } = viewport;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (highlighted ||
            (newAnnotation &&
                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {
            const handleGroupUID = '0';
            const canvasHandles = handles.points.map(worldToCanvas);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId]?.areaUnit === null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        return true;
    }
    updateAnnotation(livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;
        let { pointArray: imagePoints } = livewirePath;
        if (imagePoints.length > 1) {
            imagePoints = [...imagePoints, imagePoints[0]];
        }
        const targetWindingDirection = newAnnotation && closed ? _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_11__/* .ContourWindingDirection */ .W.Clockwise : undefined;
        this.updateContourPolyline(annotation, {
            points: imagePoints,
            closed,
            targetWindingDirection,
        }, {
            canvasToWorld: sliceToWorld,
            worldToCanvas: worldToSlice,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivewireContourTool);
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}


/***/ }),

/***/ 61873:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44049);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4096);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7001);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(29601);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(58640);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(40634);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(18990);















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class ProbeTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Probe'; }
    static { this.probeDefaults = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            handleRadius: '6',
            textCanvasOffset: {
                x: 6,
                y: -6,
            },
        },
    }; }
    constructor(toolProps = {}, defaultToolProps) {
        super(toolProps, _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                },
            });
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_8__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const annotationUID = annotation.annotationUID;
                const data = annotation.data;
                const point = data.handles.points[0];
                const canvasCoordinates = viewport.worldToCanvas(point);
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats) {
                    data.cachedStats = {};
                }
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].value === null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        index: null,
                        value: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_8__.ChangeTypes.StatsUpdated);
                }
                else if (annotation.invalidated) {
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_11__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const handleGroupUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (textLines) {
                    const textCanvasCoordinates = [
                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,
                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,
                    ];
                    const textUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);
                }
            }
            return renderStatus;
        };
    }
    isPointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
    }
    toolSelectedCallback() { }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_3__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)([viewport.id]);
    }; }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        const near = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
        if (near === true) {
            return point;
        }
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_8__.ChangeTypes.StatsUpdated) {
        const data = annotation.data;
        const { renderingEngineId, viewport } = enabledElement;
        const { element } = viewport;
        const worldPos = data.handles.points[0];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const pixelUnitsOptions = {
                isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_14__/* .isViewportPreScaled */ .u)(viewport, targetId),
                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
            };
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { dimensions, imageData, metadata, voxelManager } = image;
            const modality = metadata.Modality;
            let ijk = transformWorldToIndex(imageData, worldPos);
            ijk = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.round */ .eR.round(ijk, ijk);
            if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(ijk, dimensions)) {
                this.isHandleOutsideImage = false;
                let value = voxelManager.getAtIJKPoint(ijk);
                if (targetId.startsWith('imageId:')) {
                    const imageId = targetId.split('imageId:')[1];
                    const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(imageId);
                    const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getViewportsWithImageURI(imageURI);
                    const viewport = viewports[0];
                    ijk[2] = viewport.getCurrentImageIdIndex();
                }
                let modalityUnit;
                if (modality === 'US') {
                    const calibratedResults = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_5__/* .getCalibratedProbeUnitsAndValue */ .Xw)(image, [
                        ijk,
                    ]);
                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);
                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);
                    modalityUnit = hasEnhancedRegionValues
                        ? calibratedResults.units
                        : 'raw';
                }
                else {
                    modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_13__/* .getPixelValueUnits */ .j)(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                }
                cachedStats[targetId] = {
                    index: ijk,
                    value,
                    Modality: modality,
                    modalityUnit,
                };
            }
            else {
                this.isHandleOutsideImage = true;
                cachedStats[targetId] = {
                    index: ijk,
                    Modality: modality,
                };
            }
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_4__.triggerAnnotationModified)(annotation, element, changeType);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined || !index) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    if (value instanceof Array && modalityUnit instanceof Array) {
        for (let i = 0; i < value.length; i++) {
            textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(value[i])} ${modalityUnit[i]}`);
        }
    }
    else {
        textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(value)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProbeTool);


/***/ }),

/***/ 7750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93759);
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10639);
/* harmony import */ var _utilities_segmentation_growCut_runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16171);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);





class RegionSegmentPlusTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A {
    static { this.toolName = 'RegionSegmentPlus'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: false,
            positiveSeedVariance: 0.4,
            negativeSeedVariance: 0.9,
            subVolumePaddingPercentage: 0.1,
            islandRemoval: {
                enabled: false,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseTimer = null;
        this.allowedToProceed = false;
    }
    mouseMoveCallback(evt) {
        if (this.mode !== _enums__WEBPACK_IMPORTED_MODULE_4__.ToolModes.Active) {
            return;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const { world: worldPoint } = currentPoints;
        element.style.cursor = 'default';
        if (this.mouseTimer !== null) {
            window.clearTimeout(this.mouseTimer);
            this.mouseTimer = null;
        }
        this.mouseTimer = window.setTimeout(() => {
            this.onMouseStable(evt, worldPoint, element);
        }, this.configuration.mouseStabilityDelay || 500);
    }
    async onMouseStable(evt, worldPoint, element) {
        await super.preMouseDownCallback(evt);
        const refVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(this.growCutData.segmentation.referencedVolumeId);
        const seeds = (0,_utilities_segmentation_growCut_runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__/* .calculateGrowCutSeeds */ .sG)(refVolume, worldPoint, {}) || {
            positiveSeedIndices: new Set(),
            negativeSeedIndices: new Set(),
        };
        const { positiveSeedIndices, negativeSeedIndices } = seeds;
        let cursor;
        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||
            negativeSeedIndices.size < 30) {
            cursor = 'not-allowed';
            this.allowedToProceed = false;
        }
        else {
            cursor = 'copy';
            this.allowedToProceed = true;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (element) {
            element.style.cursor = cursor;
            requestAnimationFrame(() => {
                if (element.style.cursor !== cursor) {
                    element.style.cursor = cursor;
                }
            });
        }
        if (this.allowedToProceed) {
            this.seeds = seeds;
        }
        if (enabledElement && enabledElement.viewport) {
            enabledElement.viewport.render();
        }
    }
    async preMouseDownCallback(evt) {
        if (!this.allowedToProceed) {
            return false;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (enabledElement) {
            element.style.cursor = 'wait';
            requestAnimationFrame(() => {
                if (element.style.cursor !== 'wait') {
                    element.style.cursor = 'wait';
                }
            });
        }
        const { world: worldPoint } = currentPoints;
        await super.preMouseDownCallback(evt);
        this.growCutData = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.growCutData, {
            worldPoint,
            islandRemoval: {
                worldIslandPoints: [worldPoint],
            },
        });
        this.growCutData.worldPoint = worldPoint;
        this.growCutData.islandRemoval = {
            worldIslandPoints: [worldPoint],
        };
        await this.runGrowCut();
        if (element) {
            element.style.cursor = 'default';
        }
        return true;
    }
    getRemoveIslandData(growCutData) {
        const { worldPoint } = growCutData;
        return {
            worldIslandPoints: [worldPoint],
        };
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;
        const { subVolumePaddingPercentage } = this.configuration;
        const mergedOptions = {
            ...options,
            subVolumePaddingPercentage,
            seeds: this.seeds,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_1__.growCut.runOneClickGrowCut({
            referencedVolumeId,
            worldPosition: worldPoint,
            options: mergedOptions,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegionSegmentPlusTool);


/***/ }),

/***/ 9626:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7001);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93759);
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10639);








class RegionSegmentTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    static { this.toolName = 'RegionSegment'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positiveSeedVariance: 0.5,
            negativeSeedVariance: 0.9,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.growCutData.circleBorderPoint = currentWorldPoint;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.resetElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        await super.preMouseDownCallback(evt);
        Object.assign(this.growCutData, {
            circleCenterPoint: worldPoint,
            circleBorderPoint: worldPoint,
        });
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        return true;
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const worldCircleRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.len */ .eR.len(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), circleCenterPoint, circleBorderPoint));
        const sphereInfo = {
            center: circleCenterPoint,
            radius: worldCircleRadius,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);
    }
    _activateDraw(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;
        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);
        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);
        const vecCenterToBorder = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.sub */ .Zc.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), canvasBorderPoint, canvasCenterPoint);
        const circleRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.len */ .Zc.len(vecCenterToBorder);
        if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(circleRadius, 0)) {
            return;
        }
        const annotationUID = 'growcut';
        const circleUID = '0';
        const { color } = this.getSegmentStyle({
            segmentationId: segmentationData.segmentationId,
            segmentIndex: segmentationData.segmentIndex,
            viewportId: viewport.id,
        });
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {
            color,
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RegionSegmentTool);


/***/ }),

/***/ 60580:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _SplineROITool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3066);


class SplineContourSegmentationTool extends _SplineROITool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
    static { this.toolName = 'SplineContourSegmentationTool'; }
    constructor(toolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                calculateStats: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SplineContourSegmentationTool);


/***/ }),

/***/ 3066:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99737);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7001);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(95527);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27730);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(473);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4096);
/* harmony import */ var _eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(76910);
/* harmony import */ var _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(93126);
/* harmony import */ var _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(71543);
/* harmony import */ var _splines_LinearSpline__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(63802);
/* harmony import */ var _splines_CatmullRomSpline__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(31147);
/* harmony import */ var _splines_BSpline__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(34115);
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(36320);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(53860);




















const SPLINE_MIN_POINTS = 3;
const SPLINE_CLICK_CLOSE_CURVE_DIST = 10;
const DEFAULT_SPLINE_CONFIG = {
    resolution: 20,
    controlPointAdditionDistance: 6,
    controlPointDeletionDistance: 6,
    showControlPointsConnectors: false,
    controlPointAdditionEnabled: true,
    controlPointDeletionEnabled: true,
};
var SplineTypesEnum;
(function (SplineTypesEnum) {
    SplineTypesEnum["Cardinal"] = "CARDINAL";
    SplineTypesEnum["Linear"] = "LINEAR";
    SplineTypesEnum["CatmullRom"] = "CATMULLROM";
    SplineTypesEnum["BSpline"] = "BSPLINE";
})(SplineTypesEnum || (SplineTypesEnum = {}));
var SplineToolActions;
(function (SplineToolActions) {
    SplineToolActions["AddControlPoint"] = "addControlPoint";
    SplineToolActions["DeleteControlPoint"] = "deleteControlPoint";
})(SplineToolActions || (SplineToolActions = {}));
class SplineROITool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .A {
    static { this.toolName = 'SplineROI'; }
    static { this.SplineTypes = SplineTypesEnum; }
    static { this.Actions = SplineToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            spline: {
                configuration: {
                    [SplineTypesEnum.Cardinal]: {
                        Class: _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__/* .CardinalSpline */ .A,
                        scale: 0.5,
                    },
                    [SplineTypesEnum.CatmullRom]: {
                        Class: _splines_CatmullRomSpline__WEBPACK_IMPORTED_MODULE_16__/* .CatmullRomSpline */ .e,
                    },
                    [SplineTypesEnum.Linear]: {
                        Class: _splines_LinearSpline__WEBPACK_IMPORTED_MODULE_15__/* .LinearSpline */ .F,
                    },
                    [SplineTypesEnum.BSpline]: {
                        Class: _splines_BSpline__WEBPACK_IMPORTED_MODULE_17__/* .BSpline */ .k,
                        controlPointAdditionEnabled: false,
                        controlPointDeletionEnabled: false,
                        showControlPointsConnectors: true,
                    },
                },
                type: SplineTypesEnum.CatmullRom,
                drawPreviewEnabled: true,
                lastControlPointDeletionKeys: ['Backspace', 'Delete'],
            },
            actions: {
                [SplineToolActions.AddControlPoint]: {
                    method: 'addControlPointCallback',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_5__.MouseBindings.Primary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Shift,
                        },
                    ],
                },
                [SplineToolActions.DeleteControlPoint]: {
                    method: 'deleteControlPointCallback',
                    bindings: [
                        {
                            mouseButton: _enums__WEBPACK_IMPORTED_MODULE_5__.MouseBindings.Primary,
                            modifierKey: _enums__WEBPACK_IMPORTED_MODULE_5__.KeyboardBindings.Ctrl,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.fireChangeOnUpdate = null;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { instance: spline } = annotation.data.spline;
            return spline.isPointNearCurve(canvasCoords, proximity);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            annotation.autoGenerated = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));
            const { imageData, dimensions } = image;
            this.isHandleOutsideImage = data.handles.points
                .map((p) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, p))
                .some((index) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.indexWithinDimensions(index, dimensions));
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            const changeType = newAnnotation
                ? _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed
                : _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.HandlesUpdated;
            if (!this.fireChangeOnUpdate) {
                this.fireChangeOnUpdate = {
                    annotationUID: annotation.annotationUID,
                    changeType,
                    contourHoleProcessingEnabled,
                };
            }
            else {
                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;
                this.fireChangeOnUpdate.changeType = changeType;
            }
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._keyDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const key = eventDetail.key ?? '';
            const { lastControlPointDeletionKeys } = this.configuration.spline;
            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);
            if (!deleteLastPoint) {
                return;
            }
            const { annotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length === SPLINE_MIN_POINTS) {
                this.cancel(element);
                return;
            }
            else {
                const controlPointIndex = data.handles.points.length - 1;
                this._deleteControlPointByIndex(element, annotation, controlPointIndex);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { drawPreviewEnabled } = this.configuration.spline;
            if (!drawPreviewEnabled) {
                return;
            }
            const { element } = evt.detail;
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === _enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            if (data.contour.closed) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const { canvas: canvasPoint, world: worldPoint } = currentPoints;
            let closeContour = data.handles.points.length >= 2 && doubleClick;
            let addNewPoint = true;
            if (data.handles.points.length) {
                this.createMemo(element, annotation, {
                    newAnnotation: data.handles.points.length === 1,
                });
            }
            if (data.handles.points.length >= 3) {
                this.createMemo(element, annotation);
                const { instance: spline } = data.spline;
                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
                if (closestControlPoint?.index === 0) {
                    addNewPoint = false;
                    closeContour = true;
                }
            }
            if (addNewPoint) {
                data.handles.points.push(worldPoint);
            }
            data.contour.closed = data.contour.closed || closeContour;
            annotation.invalidated = true;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
            if (data.contour.closed) {
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                this.moveAnnotation(annotation, worldPosDelta);
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
                changeType: _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed,
                contourHoleProcessingEnabled,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = _enums__WEBPACK_IMPORTED_MODULE_5__.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {
            if (changeType === _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.Completed) {
                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);
            }
            else {
                this.triggerAnnotationModified(annotation, enabledElement, changeType);
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_DOWN, this._keyDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_4__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.KEY_DOWN, this._keyDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.spline.instance.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_10__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.addControlPointCallback = (evt, annotation) => {
            const { data } = annotation;
            const splineType = data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointAdditionDistance;
            if (splineConfig.controlPointAdditionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { instance: spline } = data.spline;
            const canvasPos = evt.detail.currentPoints.canvas;
            const closestPointInfo = spline.getClosestPoint(canvasPos);
            if (closestPointInfo.distance > maxDist) {
                return;
            }
            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);
            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));
            annotation.invalidated = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        };
        this.deleteControlPointCallback = (evt, annotation) => {
            const splineType = annotation.data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointDeletionDistance;
            if (splineConfig.controlPointDeletionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const { canvas: canvasPos } = currentPoints;
            const { instance: spline } = annotation.data.spline;
            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);
            if (!closestControlPoint) {
                return;
            }
            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_11__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_7__.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = _utilities_math__WEBPACK_IMPORTED_MODULE_7__.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, _enums__WEBPACK_IMPORTED_MODULE_5__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { canvas: canvasPos } = currentPoints;
        const contourHoleProcessingEnabled = (0,_eventDispatchers_shared_getMouseModifier__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        const annotation = this.createAnnotation(evt);
        this.isDrawing = true;
        this.addAnnotation(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
            lastCanvasPoint: canvasPos,
            contourHoleProcessingEnabled,
        };
        this._activateDraw(element);
        evt.preventDefault();
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        return annotation;
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        if (newAnnotation) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
        }
        super.cancelAnnotation(annotation);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
        this.editData = null;
        return annotation.annotationUID;
    }
    isContourSegmentationTool() {
        return false;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { element } = viewport;
        const annotation = renderContext.annotation;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const { points: controlPoints, activeHandleIndex } = handles;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;
        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));
        const { drawPreviewEnabled } = this.configuration.spline;
        const splineType = annotation.data.spline.type;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = annotation.data.spline.instance;
        const childAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getChildAnnotations)(annotation);
        const missingAnnotation = childAnnotations.findIndex((it) => !it);
        if (missingAnnotation !== -1) {
            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);
        }
        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));
        splineAnnotationsGroup.forEach((annotation) => {
            const spline = this._updateSplineInstance(element, annotation);
            const splinePolylineCanvas = spline.getPolylinePoints();
            this.updateContourPolyline(annotation, {
                points: splinePolylineCanvas,
                closed: data.contour.closed,
                targetWindingDirection: _types_ContourAnnotation__WEBPACK_IMPORTED_MODULE_13__/* .ContourWindingDirection */ .W.Clockwise,
            }, viewport, { updateWindingDirection: data.contour.closed });
        });
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId].areaUnit == null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        let activeHandleCanvasCoords;
        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {
            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords || newAnnotation || highlighted) {
            const handleGroupUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                color,
                lineWidth,
                handleRadius: '3',
            });
        }
        if (drawPreviewEnabled &&
            spline.numControlPoints > 1 &&
            this.editData?.lastCanvasPoint &&
            !spline.closed) {
            const { lastCanvasPoint } = this.editData;
            const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawPolyline)(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {
                color: '#9EA0CA',
                lineDash: lineDash,
                lineWidth: 1,
            });
        }
        if (splineConfig.showControlPointsConnectors) {
            const controlPointsConnectors = [...canvasCoordinates];
            if (spline.closed) {
                controlPointsConnectors.push(canvasCoordinates[0]);
            }
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawPolyline)(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {
                color: 'rgba(255, 255, 255, 0.5)',
                lineWidth: 1,
            });
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {
            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);
            this.fireChangeOnUpdate = null;
        }
        annotation.invalidated = false;
        return true;
    }
    createInterpolatedSplineControl(annotation) {
        if (annotation.data.handles.points?.length) {
            return;
        }
        const { polyline } = annotation.data.contour;
        if (!polyline || !polyline.length) {
            return;
        }
        annotation.data.handles.points = [];
        const { points } = annotation.data.handles;
        const increment = Math.max(10, Math.floor(polyline.length / 20));
        for (let i = 0; i < polyline.length - increment; i += increment) {
            points.push(polyline[i]);
        }
        points.push(polyline[polyline.length - 1]);
    }
    createAnnotation(evt) {
        const contourAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const { type: splineType } = this.configuration.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = new splineConfig.Class();
        const createSpline = () => ({
            type: splineConfig.type,
            instance: spline,
            resolution: splineConfig.resolution,
        });
        let onInterpolationComplete;
        if (this.configuration.interpolation?.enabled) {
            onInterpolationComplete = (annotation) => {
                annotation.data.spline ||= createSpline();
                this.createInterpolatedSplineControl(annotation);
            };
        }
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(contourAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
                spline: createSpline(),
                cachedStats: {},
            },
            onInterpolationComplete,
        });
    }
    _deleteControlPointByIndex(element, annotation, controlPointIndex) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { points: controlPoints } = annotation.data.handles;
        if (controlPoints.length === 3) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
        }
        else {
            controlPoints.splice(controlPointIndex, 1);
        }
        const { renderingEngine } = enabledElement;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_9__.getViewportIdsWithToolToRender)(element, this.getToolName());
        annotation.invalidated = true;
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)(viewportIdsToRender);
    }
    _isSplineROIAnnotation(annotation) {
        return !!annotation.data?.spline;
    }
    _getSplineConfig(type) {
        const { configuration: config } = this;
        const splineConfigs = config.spline.configuration;
        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);
    }
    _updateSplineInstance(element, annotation) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { data } = annotation;
        const { type: splineType, instance: spline } = annotation.data.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const worldPoints = data.handles.points;
        const canvasPoints = worldPoints.map(worldToCanvas);
        const resolution = splineConfig.resolution !== undefined
            ? parseInt(splineConfig.resolution)
            : undefined;
        const scale = splineConfig.scale !== undefined
            ? parseFloat(splineConfig.scale)
            : undefined;
        spline.setControlPoints(canvasPoints);
        spline.closed = !!data.contour.closed;
        if (!spline.fixedResolution &&
            resolution !== undefined &&
            spline.resolution !== resolution) {
            spline.resolution = resolution;
            annotation.invalidated = true;
        }
        if (spline instanceof _splines_CardinalSpline__WEBPACK_IMPORTED_MODULE_14__/* .CardinalSpline */ .A &&
            !spline.fixedScale &&
            scale !== undefined &&
            spline.scale !== scale) {
            spline.scale = scale;
            annotation.invalidated = true;
        }
        return spline;
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (points.length < SPLINE_MIN_POINTS) {
            console.warn('Spline requires at least 3 control points');
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);
        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;
        const splineConfig = instance._getSplineConfig(splineType);
        const SplineClass = splineConfig.Class;
        const splineInstance = new SplineClass();
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
                label: '',
                cachedStats: {},
                spline: {
                    type: splineType,
                    instance: splineInstance,
                },
                contour: {
                    closed: true,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: true,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, viewport.element);
        (0,_utilities__WEBPACK_IMPORTED_MODULE_19__.triggerAnnotationRenderForViewportIds)([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SplineROITool);


/***/ }),

/***/ 94504:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85204);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60810);
/* harmony import */ var _utilities_math_point__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82216);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58640);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(4096);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(95527);














const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class UltrasoundDirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'UltrasoundDirectionalTool'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            displayBothAxesDistances: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.startedDrawing) {
                return;
            }
            this.startedDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport)) {
                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');
            }
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    label: '',
                    cachedStats: {},
                },
            };
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = _utilities_math__WEBPACK_IMPORTED_MODULE_13__.lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.startedDrawing && data.handles.points.length === 1) {
                this.editData.handleIndex = 1;
                return;
            }
            this.startedDrawing = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.startedDrawing = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_0__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_4__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].xValues == null) {
                    data.cachedStats[targetId] = {
                        xValues: [0, 0],
                        yValues: [0, 0],
                        isHorizontal: false,
                        units: [''],
                        isUnitless: false,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let handleGroupUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {
                    color,
                }, 0);
                renderStatus = true;
                if (canvasCoordinates.length !== 2) {
                    return renderStatus;
                }
                handleGroupUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {
                    color,
                }, 1);
                const isUnitless = data.cachedStats[targetId].isUnitless;
                if (!isUnitless) {
                    const canvasPoint1 = canvasCoordinates[0];
                    const canvasPoint2 = canvasCoordinates[1];
                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                    const isHorizontal = data.cachedStats[targetId].isHorizontal;
                    let projectedPointCanvas = [0, 0];
                    if (isHorizontal) {
                        projectedPointCanvas = [
                            canvasPoint1[0] + canvasDeltaX,
                            canvasPoint1[1],
                        ];
                    }
                    else {
                        projectedPointCanvas = [
                            canvasPoint1[0],
                            canvasPoint1[1] + canvasDeltaY,
                        ];
                    }
                    let dataId = `${annotationUID}-line-1`;
                    let lineUID = '1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                    dataId = `${annotationUID}-line-2`;
                    lineUID = '2';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {
                        color,
                        width: 1,
                        lineDash: [1, 1],
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                else {
                    const dataId = `${annotationUID}-line-1`;
                    const lineUID = '1';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {
        return;
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName());
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        this.editData = {
            handleIndex,
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 2) {
            return;
        }
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData } = image;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);
            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);
            const { values: values1, units: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__/* .getCalibratedProbeUnitsAndValue */ .Xw)(image, [imageIndex1]);
            const { values: values2, units: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_12__/* .getCalibratedProbeUnitsAndValue */ .Xw)(image, [imageIndex2]);
            let xValues, yValues, units, isHorizontal;
            let isUnitless = false;
            if (units1[0] !== units2[0] ||
                units1[1] !== units2[1] ||
                (units1[0] === 'raw' && units2[0] === 'raw')) {
                const value = (0,_utilities_math_point__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint)(worldPos1, worldPos2);
                xValues = [value, 0];
                yValues = [value, 0];
                units = ['px'];
                isUnitless = true;
            }
            else {
                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);
                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);
                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);
                xValues = [values1[0], values2[0]];
                yValues = [values1[1], values2[1]];
                units = [units1[0], units1[1]];
            }
            cachedStats[targetId] = {
                xValues,
                yValues,
                isHorizontal,
                units,
                isUnitless,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_5__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_0__.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function defaultGetTextLines(data, targetId, configuration) {
    const cachedStats = data.cachedStats[targetId];
    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;
    if (isUnitless) {
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(xValues[0])} px`];
    }
    if (configuration.displayBothAxesDistances) {
        const dist1 = Math.abs(xValues[1] - xValues[0]);
        const dist2 = Math.abs(yValues[1] - yValues[0]);
        return [
            `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist1)} ${units[0]}`,
            `${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist2)} ${units[1]}`,
        ];
    }
    if (isHorizontal) {
        const dist = Math.abs(xValues[1] - xValues[0]);
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist)} ${units[0]}`];
    }
    else {
        const dist = Math.abs(yValues[1] - yValues[0]);
        return [`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(dist)} ${units[1]}`];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UltrasoundDirectionalTool);


/***/ }),

/***/ 11811:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6802);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60810);
/* harmony import */ var _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33657);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(58640);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(62514);













class VideoRedactionTool extends _base__WEBPACK_IMPORTED_MODULE_2__/* .AnnotationTool */ .EC {
    static { this.toolName = 'VideoRedaction'; }
    constructor(toolConfiguration = {}) {
        super(toolConfiguration, {
            supportedInteractionTypes: ['Mouse', 'Touch'],
            configuration: { shadow: true, preventHandleOutsideImage: false },
        });
        this.addNewAnnotation = (evt) => {
            const eventData = evt.detail;
            const { currentPoints, element } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                },
            });
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .addAnnotation */ .lC)(annotation, element);
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
            return annotation;
        };
        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);
                const near = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;
                if (near === true) {
                    data.handles.activeHandleIndex = i;
                    return point;
                }
            }
            data.handles.activeHandleIndex = null;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_9__.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
        };
        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportUIDsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_8__.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.active = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventData;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                data.invalidated = true;
            }
            else {
                const { currentPoints } = eventData;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                data.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_7__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID } = annotation;
                const data = annotation.data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return;
                }
                let activeHandleCanvasCoords;
                if (!this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRedactionRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color: 'black',
                    lineDash,
                    lineWidth,
                });
            }
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetUIDs = Object.keys(cachedStats);
            for (let i = 0; i < targetUIDs.length; i++) {
                const targetUID = targetUIDs[i];
                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);
                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;
                const worldPos1Index = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(0, 0, 0);
                const worldPos2Index = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(0, 0, 0);
                imageData.worldToIndexVec3(worldPos1, worldPos1Index);
                worldPos1Index[0] = Math.floor(worldPos1Index[0]);
                worldPos1Index[1] = Math.floor(worldPos1Index[1]);
                worldPos1Index[2] = Math.floor(worldPos1Index[2]);
                imageData.worldToIndexVec3(worldPos2, worldPos2Index);
                worldPos2Index[0] = Math.floor(worldPos2Index[0]);
                worldPos2Index[1] = Math.floor(worldPos2Index[1]);
                worldPos2Index[2] = Math.floor(worldPos2Index[2]);
                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const area = worldWidth * worldHeight;
                    let count = 0;
                    let mean = 0;
                    let stdDev = 0;
                    const yMultiple = dimensions[0];
                    const zMultiple = dimensions[0] * dimensions[1];
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                count++;
                                mean += value;
                            }
                        }
                    }
                    mean /= count;
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                const valueMinusMean = value - mean;
                                stdDev += valueMinusMean * valueMinusMean;
                            }
                        }
                    }
                    stdDev /= count;
                    stdDev = Math.sqrt(stdDev);
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                        area,
                        mean,
                        stdDev,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                const eventType = _enums__WEBPACK_IMPORTED_MODULE_7__.Events.ANNOTATION_MODIFIED;
                const eventDetail = {
                    annotation,
                    viewportUID,
                    renderingEngineUID,
                    sceneUID: sceneUID,
                    changeType: _enums__WEBPACK_IMPORTED_MODULE_7__.ChangeTypes.StatsUpdated,
                };
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.eventTarget, eventType, eventDetail);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._getTargetVolumeUID = (scene) => {
            if (this.configuration.volumeUID) {
                return this.configuration.volumeUID;
            }
            const volumeActors = scene.getVolumeActors();
            if (!volumeActors && !volumeActors.length) {
                return;
            }
            return volumeActors[0].uid;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
        const { annotation, viewportUIDsToRender } = this.editData;
        const { data } = annotation;
        data.active = false;
        data.handles.activeHandleIndex = null;
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportUIDsToRender);
        this.editData = null;
        return annotation.metadata.annotationUID;
    }
    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {
        let imageVolume, viewport;
        if (targetUID.startsWith('stackTarget')) {
            const coloneIndex = targetUID.indexOf(':');
            const viewportUID = targetUID.substring(coloneIndex + 1);
            const viewport = renderingEngine.getViewport(viewportUID);
            imageVolume = viewport.getImageData();
        }
        else {
            imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(targetUID);
        }
        return { imageVolume, viewport };
    }
    _getTargetStackUID(viewport) {
        return `stackTarget:${viewport.uid}`;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VideoRedactionTool);


/***/ }),

/***/ 31787:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7001);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58640);
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93759);
/* harmony import */ var _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10639);








const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
const ISLAND_PIXEL_RANGE = [1000, 1900];
const { transformWorldToIndex, transformIndexToWorld } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class WholeBodySegmentTool extends _base_GrowCutBaseTool__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positivePixelRange: POSITIVE_PIXEL_RANGE,
            negativePixelRange: NEGATIVE_PIXEL_RANGE,
            islandRemoval: {
                enabled: true,
                islandPixelRange: ISLAND_PIXEL_RANGE,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);
            this.growCutData.horizontalLines[1] = linePoints;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            await this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.resetElementCursor)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);
        await super.preMouseDownCallback(evt);
        this.growCutData.horizontalLines = [linePoints, linePoints];
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_3__.hideElementCursor)(element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)([viewport.id]);
        return true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { segmentation: segmentationData, horizontalLines } = this.growCutData;
        if (horizontalLines.length !== 2) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentationId, segmentIndex } = segmentationData;
        const [line1, line2] = horizontalLines;
        const [worldLine1P1, worldLine1P2] = line1;
        const [worldLine2P1, worldLine2P2] = line2;
        const canvasPoints = [
            worldLine1P1,
            worldLine1P2,
            worldLine2P2,
            worldLine2P1,
        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));
        const annotationUID = 'growCutRect';
        const squareGroupUID = '0';
        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({
            segmentationId,
            segmentIndex,
            viewportId: viewport.id,
        });
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.drawPolyline)(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {
            color,
            fillColor,
            fillOpacity,
            lineWidth,
            lineDash,
            closePath: true,
        });
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const [line1, line2] = horizontalLines;
        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];
        const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);
        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);
        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);
        const boundingBoxInfo = {
            boundingBox: {
                ijkTopLeft,
                ijkBottomRight,
            },
        };
        const config = this.configuration;
        const options = {
            positiveSeedValue: segmentIndex,
            negativeSeedValue: 255,
            negativePixelRange: config.negativePixelRange,
            positivePixelRange: config.positivePixelRange,
        };
        return _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);
    }
    getRemoveIslandData() {
        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;
        const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
        const labelmapVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(labelmapVolumeId);
        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();
        const { islandPixelRange } = this.configuration.islandRemoval;
        const islandPointIndexes = [];
        for (let i = 0, len = labelmapData.length; i < len; i++) {
            if (labelmapData[i] !== segmentIndex) {
                continue;
            }
            const pixelValue = referencedVolumeData[i];
            if (pixelValue >= islandPixelRange[0] &&
                pixelValue <= islandPixelRange[1]) {
                islandPointIndexes.push(i);
            }
        }
        return {
            islandPointIndexes,
        };
    }
    _activateDraw(element) {
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
    }
    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);
        const axis = vecDirection.findIndex((n) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(n), 1));
        if (axis === -1) {
            throw new Error('Non-orthogonal direction vector');
        }
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {
        const { viewPlaneNormal } = viewport.getCamera();
        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);
    }
    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {
        const cuboidPoints = [];
        const volume = this._getViewportVolume(viewport);
        worldSquarePoints.forEach((worldSquarePoint) => {
            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);
            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));
            cuboidPoints.push(...worldEdgePoints);
        });
        return cuboidPoints;
    }
    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {
        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);
        const topLeft = [...worldCuboidPoints[0]];
        const bottomRight = [...worldCuboidPoints[0]];
        worldCuboidPoints.forEach((worldPoint) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.min */ .eR.min(topLeft, topLeft, worldPoint);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.max */ .eR.max(bottomRight, bottomRight, worldPoint);
        });
        return { topLeft, bottomRight };
    }
    _getViewportVolume(viewport) {
        if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.BaseVolumeViewport)) {
            throw new Error('Viewport is not a BaseVolumeViewport');
        }
        const volumeId = viewport.getAllVolumeIds()[0];
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
    }
    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);
        const { viewUp, viewPlaneNormal } = viewport.getCamera();
        const vecRow = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), viewUp, viewPlaneNormal);
        const axis = vecRow.findIndex((n) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(n), 1));
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);
        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);
        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);
        return [worldPoint1, worldPoint2];
    }
}
WholeBodySegmentTool.toolName = 'WholeBodySegment';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WholeBodySegmentTool);


/***/ }),

/***/ 34115:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ BSpline),
/* harmony export */   k: () => (/* binding */ BSpline)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57163);


const TRANSFORM_MATRIX = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiplyScalar */ .pB.multiplyScalar(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.create */ .pB.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromValues */ .pB.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);
class BSpline extends _CubicSpline__WEBPACK_IMPORTED_MODULE_1__/* .CubicSpline */ .m {
    getTransformMatrix() {
        return TRANSFORM_MATRIX;
    }
}



/***/ }),

/***/ 71543:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CardinalSpline),
/* harmony export */   h: () => (/* binding */ CardinalSpline)
/* harmony export */ });
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57163);

class CardinalSpline extends _CubicSpline__WEBPACK_IMPORTED_MODULE_0__/* .CubicSpline */ .m {
    constructor(props) {
        super(props);
        this._scale = props?.scale ?? 0.5;
        this._fixedScale = props?.fixedScale ?? false;
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        if (this._fixedScale || this._scale === scale) {
            return;
        }
        this._scale = scale;
        this.invalidated = true;
    }
    get fixedScale() {
        return this._fixedScale;
    }
    getTransformMatrix() {
        const { scale: s } = this;
        const s2 = 2 * s;
        return [
            0, 1, 0, 0,
            -s, 0, s, 0,
            s2, s - 3, 3 - s2, -s,
            -s, 2 - s, s - 2, s
        ];
    }
}



/***/ }),

/***/ 31147:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CatmullRomSpline),
/* harmony export */   e: () => (/* binding */ CatmullRomSpline)
/* harmony export */ });
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71543);

class CatmullRomSpline extends _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__/* .CardinalSpline */ .A {
    constructor() {
        super({ scale: 0.5, fixedScale: true });
    }
}



/***/ }),

/***/ 57163:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CubicSpline),
/* harmony export */   m: () => (/* binding */ CubicSpline)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56091);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95527);



const MAX_U_ERROR = 1e-8;
class CubicSpline extends _Spline__WEBPACK_IMPORTED_MODULE_1__/* .Spline */ .e {
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        const previewNumCurveSegments = this._getNumCurveSegments() + 1;
        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);
        const endCurveSegIndex = closeSpline
            ? previewNumCurveSegments
            : previewNumCurveSegments - 1;
        const transformMatrix = this.getTransformMatrix();
        const controlPoints = [...this.controlPoints];
        const curveSegments = [];
        if (!closeSpline) {
            controlPoints.push(controlPointPreview);
        }
        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);
            curveSegments.push(curveSegment);
        }
        return curveSegments;
    }
    getSplineCurves() {
        const numCurveSegments = this._getNumCurveSegments();
        const curveSegments = new Array(numCurveSegments);
        if (numCurveSegments <= 0) {
            return [];
        }
        const transformMatrix = this.getTransformMatrix();
        let previousCurveSegmentsLength = 0;
        for (let i = 0; i < numCurveSegments; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix);
            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;
            curveSegments[i] = curveSegment;
            previousCurveSegmentsLength += curveSegment.length;
        }
        return curveSegments;
    }
    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {
        return closed
            ? controlPoints.length
            : Math.max(0, controlPoints.length - 1);
    }
    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const uInt = Math.floor(u);
        let curveSegmentIndex = uInt % numCurveSegments;
        const t = u - uInt;
        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;
        if (curveSegmentIndexOutOfBounds) {
            if (this.closed) {
                curveSegmentIndex =
                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;
            }
            else {
                return;
            }
        }
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const tt = t * t;
        const ttt = tt * t;
        const tValues = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.fromValues */ .ln.fromValues(1, t, tt, ttt);
        const qValues = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.create */ .ln.create(), tValues, transformMatrix);
        return [
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.dot */ .ln.dot(qValues, gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.fromValues */ .ln.fromValues(p0[0], p1[0], p2[0], p3[0])),
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.dot */ .ln.dot(qValues, gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.fromValues */ .ln.fromValues(p0[1], p1[1], p2[1], p3[1])),
        ];
    }
    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const p1Index = curveSegmentIndex;
        const p0Index = p1Index - 1;
        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;
        const p3Index = p2Index + 1;
        const p1 = controlPoints[p1Index];
        const p2 = controlPoints[p2Index];
        let p0;
        let p3;
        if (p0Index >= 0) {
            p0 = controlPoints[p0Index];
        }
        else {
            p0 = closed
                ? controlPoints[controlPoints.length - 1]
                : _utilities_math__WEBPACK_IMPORTED_MODULE_2__.point.mirror(p2, p1);
        }
        if (p3Index < controlPoints.length) {
            p3 = controlPoints[p3Index];
        }
        else {
            p3 = closed ? controlPoints[0] : _utilities_math__WEBPACK_IMPORTED_MODULE_2__.point.mirror(p1, p2);
        }
        return { p0, p1, p2, p3 };
    }
    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const numLineSegments = this.resolution + 1;
        const inc = 1 / numLineSegments;
        const minU = curveSegmentIndex;
        let maxU = minU + 1;
        if (!closed && curveSegmentIndex === numCurveSegments - 1) {
            maxU -= MAX_U_ERROR;
        }
        const lineSegments = [];
        let startPoint;
        let endPoint;
        let previousLineSegmentsLength = 0;
        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {
            u = u > maxU ? maxU : u;
            const point = this._getPoint(u, transformMatrix, controlPoints, closed);
            if (!i) {
                startPoint = point;
                continue;
            }
            endPoint = point;
            const dx = endPoint[0] - startPoint[0];
            const dy = endPoint[1] - startPoint[1];
            const length = Math.sqrt(dx ** 2 + dy ** 2);
            const aabb = {
                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],
                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],
                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],
                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],
            };
            lineSegments.push({
                points: {
                    start: startPoint,
                    end: endPoint,
                },
                aabb,
                length,
                previousLineSegmentsLength,
            });
            startPoint = endPoint;
            previousLineSegmentsLength += length;
        }
        return lineSegments;
    }
    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);
        let curveSegmentLength = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {
            minX = Math.min(minX, lineSegAABB.minX);
            minY = Math.min(minY, lineSegAABB.minY);
            maxX = Math.max(maxX, lineSegAABB.maxX);
            maxY = Math.max(maxY, lineSegAABB.maxY);
            curveSegmentLength += lineSegLength;
        });
        return {
            controlPoints: { p0, p1, p2, p3 },
            aabb: { minX, minY, maxX, maxY },
            length: curveSegmentLength,
            previousCurveSegmentsLength: 0,
            lineSegments,
        };
    }
}



/***/ }),

/***/ 63802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ LinearSpline),
/* harmony export */   F: () => (/* binding */ LinearSpline)
/* harmony export */ });
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71543);

class LinearSpline extends _CardinalSpline__WEBPACK_IMPORTED_MODULE_0__/* .CardinalSpline */ .A {
    constructor() {
        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });
    }
}



/***/ }),

/***/ 33941:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ QuadraticBezier)
/* harmony export */ });
/* unused harmony export QuadraticBezier */
/* harmony import */ var _QuadraticSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(711);

const TRANSFORM_MATRIX = [
    1, 0, 0,
    -2, 2, 0,
    1, -2, 1,
];
class QuadraticBezier extends _QuadraticSpline__WEBPACK_IMPORTED_MODULE_0__/* .QuadraticSpline */ .s {
    hasTangentPoints() {
        return true;
    }
    getTransformMatrix() {
        return TRANSFORM_MATRIX;
    }
}



/***/ }),

/***/ 711:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ QuadraticSpline),
/* harmony export */   s: () => (/* binding */ QuadraticSpline)
/* harmony export */ });
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56091);

class QuadraticSpline extends _Spline__WEBPACK_IMPORTED_MODULE_0__/* .Spline */ .e {
    getSplineCurves() {
        return [];
    }
    getLineSegments() {
        return [];
    }
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        return [];
    }
}



/***/ }),

/***/ 56091:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Spline),
/* harmony export */   e: () => (/* binding */ Spline)
/* harmony export */ });
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95527);

class Spline {
    constructor(props) {
        this._controlPoints = [];
        this._invalidated = false;
        this._length = 0;
        this._controlPoints = [];
        this._resolution = props?.resolution ?? 20;
        this._fixedResolution = props?.fixedResolution ?? false;
        this._closed = props?.closed ?? false;
        this._invalidated = true;
    }
    get controlPoints() {
        return this._controlPoints;
    }
    get numControlPoints() {
        return this._controlPoints.length;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        if (this._fixedResolution || this._resolution === resolution) {
            return;
        }
        this._resolution = resolution;
        this.invalidated = true;
    }
    get fixedResolution() {
        return this._fixedResolution;
    }
    get closed() {
        return this._closed;
    }
    set closed(closed) {
        if (this._closed === closed) {
            return;
        }
        this._closed = closed;
        this.invalidated = true;
    }
    get aabb() {
        this._update();
        return this._aabb;
    }
    get length() {
        this._update();
        return this._length;
    }
    get invalidated() {
        return this._invalidated;
    }
    set invalidated(invalidated) {
        this._invalidated = invalidated;
    }
    hasTangentPoints() {
        return false;
    }
    addControlPoint(point) {
        this._controlPoints.push([point[0], point[1]]);
        this.invalidated = true;
    }
    addControlPoints(points) {
        points.forEach((point) => this.addControlPoint(point));
    }
    addControlPointAtU(u) {
        const lineSegment = this._getLineSegmentAt(u);
        const { start: startPoint, end: endPoint } = lineSegment.points;
        const curveSegmentIndex = Math.floor(u);
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const t = u - Math.floor(curveSegmentIndex);
        const controlPointPos = [
            startPoint[0] + t * (endPoint[0] - startPoint[0]),
            startPoint[1] + t * (endPoint[1] - startPoint[1]),
        ];
        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;
        this._controlPoints.splice(insertIndex, 0, controlPointPos);
        this.invalidated = true;
        return {
            index: insertIndex,
            point: controlPointPos,
        };
    }
    deleteControlPointByIndex(index) {
        const minControlPoints = this._closed ? 3 : 1;
        const canDelete = index >= 0 &&
            index < this._controlPoints.length &&
            this._controlPoints.length > minControlPoints;
        if (!canDelete) {
            return false;
        }
        this._controlPoints.splice(index, 1);
        this.invalidated = true;
        return true;
    }
    clearControlPoints() {
        this._controlPoints = [];
        this.invalidated = true;
    }
    setControlPoints(points) {
        this.clearControlPoints();
        this.addControlPoints(points);
    }
    updateControlPoint(index, newControlPoint) {
        if (index < 0 || index >= this._controlPoints.length) {
            throw new Error('Index out of bounds');
        }
        this._controlPoints[index] = [...newControlPoint];
        this.invalidated = true;
    }
    getControlPoints() {
        return this._controlPoints.map((controlPoint) => [
            controlPoint[0],
            controlPoint[1],
        ]);
    }
    getClosestControlPoint(point) {
        const controlPoints = this._controlPoints;
        let minSquaredDist = Infinity;
        let closestPointIndex = -1;
        for (let i = 0, len = controlPoints.length; i < len; i++) {
            const controlPoint = controlPoints[i];
            const dx = point[0] - controlPoint[0];
            const dy = point[1] - controlPoint[1];
            const squaredDist = dx * dx + dy * dy;
            if (squaredDist < minSquaredDist) {
                minSquaredDist = squaredDist;
                closestPointIndex = i;
            }
        }
        return {
            index: closestPointIndex,
            point: closestPointIndex === -1
                ? undefined
                : [...controlPoints[closestPointIndex]],
            distance: Math.sqrt(minSquaredDist),
        };
    }
    getClosestControlPointWithinDistance(point, maxDist) {
        const closestControlPoint = this.getClosestControlPoint(point);
        return closestControlPoint.distance <= maxDist
            ? closestControlPoint
            : undefined;
    }
    getClosestPoint(point) {
        this._update();
        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);
        if (!curveSegmentsDistInfo.length) {
            return;
        }
        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);
        let closestPoint;
        let closestPointCurveSegmentIndex = -1;
        let minDistSquared = Infinity;
        let minDistCurveSegment;
        let minDistLineSegment;
        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {
            const curveSegmentDistInfo = curveSegmentsDistInfo[i];
            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {
                continue;
            }
            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;
            const { lineSegments } = curveSegment;
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);
                if (lineSegDistSquared < minDistSquared) {
                    minDistLineSegment = lineSegment;
                    closestPointCurveSegmentIndex = curveSegmentIndex;
                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;
                    closestPoint = lineSegPoint;
                    minDistSquared = lineSegDistSquared;
                }
            }
        }
        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +
            _utilities_math__WEBPACK_IMPORTED_MODULE_0__.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);
        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;
        const u = closestPointCurveSegmentIndex + t;
        return {
            point: closestPoint,
            uValue: u,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getClosestPointOnControlPointLines(point) {
        const linePoints = [...this._controlPoints];
        if (this._closed) {
            linePoints.push(this._controlPoints[0]);
        }
        if (!linePoints.length) {
            return;
        }
        let closestPoint;
        let minDistSquared = Infinity;
        let startPoint = linePoints[0];
        for (let i = 1, len = linePoints.length; i < len; i++) {
            const endPoint = linePoints[i];
            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);
            if (lineSegDistSquared < minDistSquared) {
                closestPoint = lineSegPoint;
                minDistSquared = lineSegDistSquared;
            }
            startPoint = endPoint;
        }
        return {
            point: closestPoint,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getPolylinePoints() {
        this._update();
        return this._convertCurveSegmentsToPolyline(this._curveSegments);
    }
    getPreviewPolylinePoints(controlPointPreview, closeDistance) {
        if (this._closed) {
            return [];
        }
        this._update();
        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);
        const closeSpline = closestControlPoint?.index === 0;
        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);
        return previewCurveSegments?.length
            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)
            : [];
    }
    isPointNearCurve(point, maxDist) {
        this._update();
        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);
        const maxDistSquared = maxDist * maxDist;
        for (let i = 0; i < curveSegments.length; i++) {
            const { lineSegments } = curveSegments[i];
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const lineDistSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);
                if (lineDistSquared <= maxDistSquared) {
                    return true;
                }
            }
        }
        return false;
    }
    containsPoint(point) {
        this._update();
        const controlPoints = this._controlPoints;
        if (controlPoints.length < 3) {
            return false;
        }
        const curveSegments = [...this._curveSegments];
        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();
        if (closingCurveSegment) {
            curveSegments.push(closingCurveSegment);
        }
        let numIntersections = 0;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const { aabb: curveSegAABB } = curveSegment;
            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&
                point[1] >= curveSegAABB.minY &&
                point[1] < curveSegAABB.maxY;
            if (!mayIntersectCurveSegment) {
                continue;
            }
            const { lineSegments } = curveSegment;
            for (let i = 0; i < lineSegments.length; i++) {
                const lineSegment = lineSegments[i];
                const { aabb: lineSegmentAABB } = lineSegment;
                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&
                    point[1] >= lineSegmentAABB.minY &&
                    point[1] < lineSegmentAABB.maxY;
                if (mayIntersectLineSegment) {
                    const { start: p1, end: p2 } = lineSegment.points;
                    const isVerticalLine = p1[0] === p2[0];
                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];
                    numIntersections +=
                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;
                }
            }
        }
        return numIntersections % 2 === 1;
    }
    _update() {
        if (!this._invalidated) {
            return;
        }
        const curveSegments = this.getSplineCurves();
        let length = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0, len = curveSegments.length; i < len; i++) {
            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];
            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;
            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;
            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;
            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;
            length += curveSegLength;
        }
        this._curveSegments = curveSegments;
        this._aabb = { minX, minY, maxX, maxY };
        this._length = length;
        this._invalidated = false;
    }
    _convertCurveSegmentsToPolyline(curveSegments) {
        this._update();
        const polylinePoints = [];
        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {
            lineSegments.forEach((lineSegment, lineSegIndex) => {
                if (curveSegIndex === 0 && lineSegIndex === 0) {
                    polylinePoints.push([...lineSegment.points.start]);
                }
                polylinePoints.push([...lineSegment.points.end]);
            });
        });
        return polylinePoints;
    }
    _getCurveSegmmentsDistanceSquaredInfo(point) {
        this._update();
        const curveSegmentsDistanceSquared = [];
        const { _curveSegments: curveSegments } = this;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const distanceSquared = _utilities_math__WEBPACK_IMPORTED_MODULE_0__.aabb.distanceToPointSquared(curveSegment.aabb, point);
            curveSegmentsDistanceSquared.push({
                curveSegmentIndex: i,
                curveSegment,
                distanceSquared,
            });
        }
        return curveSegmentsDistanceSquared;
    }
    _getCurveSegmmentsWithinDistance(point, maxDist) {
        this._update();
        const maxDistSquared = maxDist * maxDist;
        if (_utilities_math__WEBPACK_IMPORTED_MODULE_0__.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {
            return [];
        }
        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);
        const curveSegmentsWithinRange = [];
        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {
            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];
            if (curveSegmentDistSquared <= maxDistSquared) {
                curveSegmentsWithinRange.push(curveSegment);
            }
        }
        return curveSegmentsWithinRange;
    }
    _getLineSegmentAt(u) {
        this._update();
        const curveSegmentIndex = Math.floor(u);
        const t = u - curveSegmentIndex;
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const { lineSegments } = curveSegment;
        const pointLength = curveSegment.length * t;
        for (let i = 0; i < lineSegments.length; i++) {
            const lineSegment = lineSegments[i];
            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;
            if (pointLength >= lineSegment.previousLineSegmentsLength &&
                pointLength <= lengthEnd) {
                return lineSegment;
            }
        }
    }
    _getClosingCurveSegmentWithStraightLineSegment() {
        if (this.closed) {
            return;
        }
        const controlPoints = this._controlPoints;
        const startControlPoint = controlPoints[0];
        const endControlPoint = controlPoints[controlPoints.length - 1];
        const closingLineSegment = {
            points: {
                start: [...startControlPoint],
                end: [...endControlPoint],
            },
            aabb: {
                minX: Math.min(startControlPoint[0], endControlPoint[0]),
                minY: Math.min(startControlPoint[1], endControlPoint[1]),
                maxX: Math.max(startControlPoint[0], endControlPoint[0]),
                maxY: Math.max(startControlPoint[1], endControlPoint[1]),
            },
        };
        return {
            aabb: {
                minX: closingLineSegment.aabb.minX,
                minY: closingLineSegment.aabb.minY,
                maxX: closingLineSegment.aabb.maxX,
                maxY: closingLineSegment.aabb.maxY,
            },
            lineSegments: [closingLineSegment],
        };
    }
}



/***/ }),

/***/ 3040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BSpline: () => (/* reexport safe */ _BSpline__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   CardinalSpline: () => (/* reexport safe */ _CardinalSpline__WEBPACK_IMPORTED_MODULE_1__.h),
/* harmony export */   CatmullRomSpline: () => (/* reexport safe */ _CatmullRomSpline__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   CubicSpline: () => (/* reexport safe */ _CubicSpline__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   LinearSpline: () => (/* reexport safe */ _LinearSpline__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   QuadraticBezier: () => (/* reexport safe */ _QuadraticBezier__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   QuadraticSpline: () => (/* reexport safe */ _QuadraticSpline__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   Spline: () => (/* reexport safe */ _Spline__WEBPACK_IMPORTED_MODULE_7__.A)
/* harmony export */ });
/* harmony import */ var _BSpline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34115);
/* harmony import */ var _CardinalSpline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71543);
/* harmony import */ var _CatmullRomSpline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31147);
/* harmony import */ var _CubicSpline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57163);
/* harmony import */ var _LinearSpline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63802);
/* harmony import */ var _QuadraticBezier__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33941);
/* harmony import */ var _QuadraticSpline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(711);
/* harmony import */ var _Spline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56091);











/***/ }),

/***/ 6030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37234);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56069);
/* harmony import */ var _utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94418);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76712);
/* harmony import */ var _stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(49310);







class AnnotationDisplayTool extends _BaseTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
    constructor() {
        super(...arguments);
        this.onImageSpacingCalibrated = (evt) => {
            const { element, imageId } = evt.detail;
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotationManager)();
            const framesOfReference = annotationManager.getFramesOfReference();
            framesOfReference.forEach((frameOfReference) => {
                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
                    return;
                }
                toolSpecificAnnotations.forEach((annotation) => {
                    if (!annotation.metadata?.referencedImageId) {
                        return;
                    }
                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(annotation.metadata.referencedImageId);
                    if (referencedImageURI === imageURI) {
                        annotation.invalidated = true;
                        annotation.data.cachedStats = {};
                    }
                });
                (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element);
            });
        };
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations?.length) {
            return [];
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        return (0,_utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewport, annotations);
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const viewReference = viewport.getViewReference({ points: [worldPos] });
        return {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                ...viewReference,
                referencedImageId,
                viewUp,
                cameraPosition,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [],
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
            },
        };
    }
    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
        }
        return referencedImageId;
    }
    getStyle(property, specifications, annotation) {
        return (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__/* .getStyleProperty */ .h)(property, specifications, (0,_stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__.getState)(annotation), this.mode);
    }
}
AnnotationDisplayTool.toolName = 'AnnotationDisplayTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationDisplayTool);


/***/ }),

/***/ 37234:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49892);


const { DefaultHistoryMemo } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.HistoryMemo;
class BaseTool {
    static { this.defaults = {
        configuration: {
            strategies: {},
            defaultStrategy: undefined,
            activeStrategy: undefined,
            strategyOptions: {},
        },
    }; }
    constructor(toolProps, defaultToolProps) {
        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(mergedDefaults, toolProps);
        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;
        this.toolGroupId = toolGroupId;
        this.supportedInteractionTypes = supportedInteractionTypes || [];
        this.configuration = Object.assign({}, configuration);
        this.mode = _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Disabled;
    }
    static mergeDefaultProps(defaultProps = {}, additionalProps) {
        if (!additionalProps) {
            return defaultProps;
        }
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(defaultProps, additionalProps);
    }
    get toolName() {
        return this.getToolName();
    }
    getToolName() {
        return this.constructor.toolName;
    }
    applyActiveStrategy(enabledElement, operationData) {
        const { strategies, activeStrategy } = this.configuration;
        return strategies[activeStrategy]?.call(this, enabledElement, operationData);
    }
    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {
        const { strategies, activeStrategy } = this.configuration;
        if (!strategies[activeStrategy]) {
            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);
        }
        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);
    }
    setConfiguration(newConfiguration) {
        this.configuration = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.configuration, newConfiguration);
    }
    setActiveStrategy(strategyName) {
        this.setConfiguration({ activeStrategy: strategyName });
    }
    getTargetImageData(targetId) {
        if (targetId.startsWith('imageId:')) {
            const imageId = targetId.split('imageId:')[1];
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            let viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            viewports = viewports.filter((viewport) => {
                return viewport.getCurrentImageId() === imageId;
            });
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('volumeId:')) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('videoId:')) {
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else {
            throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
        }
    }
    getTargetId(viewport) {
        const targetId = viewport.getViewReferenceId?.();
        if (targetId) {
            return targetId;
        }
        throw new Error('getTargetId: viewport must have a getViewReferenceId method');
    }
    undo() {
        this.doneEditMemo();
        DefaultHistoryMemo.undo();
    }
    redo() {
        DefaultHistoryMemo.redo();
    }
    static createZoomPanMemo(viewport) {
        const state = {
            pan: viewport.getPan(),
            zoom: viewport.getZoom(),
        };
        const zoomPanMemo = {
            restoreMemo: () => {
                const currentPan = viewport.getPan();
                const currentZoom = viewport.getZoom();
                viewport.setZoom(state.zoom);
                viewport.setPan(state.pan);
                viewport.render();
                state.pan = currentPan;
                state.zoom = currentZoom;
            },
        };
        DefaultHistoryMemo.push(zoomPanMemo);
        return zoomPanMemo;
    }
    doneEditMemo() {
        if (this.memo?.commitMemo?.()) {
            DefaultHistoryMemo.push(this.memo);
        }
        this.memo = null;
    }
}
BaseTool.toolName = 'BaseTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTool);


/***/ }),

/***/ 85817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EC: () => (/* reexport safe */ _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   oS: () => (/* reexport safe */ _BaseTool__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   wh: () => (/* reexport safe */ _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__.A)
/* harmony export */ });
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37234);
/* harmony import */ var _AnnotationTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91350);
/* harmony import */ var _AnnotationDisplayTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6030);






/***/ }),

/***/ 25894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22384);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);
/* harmony import */ var _removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(87420);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27479);
/* harmony import */ var _utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25758);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82056);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3823);










const polySegConversionInProgressForViewportId = new Map();
const processedViewportSegmentations = new Map();
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportId, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour];
    const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)();
    if (!contourData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour) &&
        !polySegConversionInProgressForViewportId.get(viewport.id)) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        contourData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    else if (!contourData && !(0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)()) {
        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!contourData) {
        return;
    }
    if (!contourData.geometryIds?.length) {
        return;
    }
    let hasContourDataButNotMatchingViewport = false;
    const viewportNormal = viewport.getCamera().viewPlaneNormal;
    if (contourData.annotationUIDsMap) {
        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);
    }
    if (contourData.geometryIds.length > 0) {
        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);
    }
    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();
    if (hasContourDataButNotMatchingViewport &&
        !polySegConversionInProgressForViewportId.get(viewport.id) &&
        !viewportProcessed.has(segmentationId) &&
        viewport.viewportStatus === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.ViewportStatus.RENDERED) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        const segmentIndices = (0,_utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__/* .getUniqueSegmentIndices */ .O)(segmentationId);
        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {
            segmentIndices,
            viewport,
        });
        const geometryIds = surfacesInfo.geometryIds;
        const pointsAndPolys = [];
        for (const geometryId of geometryIds.values()) {
            const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
            const data = geometry.data;
            pointsAndPolys.push({
                points: data.points,
                polys: data.polys,
                segmentIndex: data.segmentIndex,
                id: data.segmentIndex,
            });
        }
        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);
        const rawResults = polySeg.extractContourData(polyDataCache);
        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);
        contourData.annotationUIDsMap = new Map([
            ...contourData.annotationUIDsMap,
            ...annotationUIDsMap,
        ]);
        viewportProcessed.add(segmentationId);
        processedViewportSegmentations.set(viewport.id, viewportProcessed);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    (0,_contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .handleContourSegmentation */ .d)(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
function _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {
    let validGeometry = null;
    let geometryData = null;
    for (const geometryId of geometryIds) {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry) {
            continue;
        }
        const data = geometry.data;
        if (data.contours?.[0]?.points?.length >= 3) {
            validGeometry = geometry;
            geometryData = data;
            break;
        }
    }
    if (!validGeometry || !geometryData) {
        return false;
    }
    const contours = geometryData.contours;
    const points = contours[0].points;
    const point1 = points[0];
    const point2 = points[1];
    const point3 = points[2];
    let normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), point2, point1), gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), point3, point1));
    normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), normal);
    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.dot */ .eR.dot(normal, viewportNormal);
    return Math.abs(dotProduct) > 0.9;
}
function _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {
    const annotationUIDs = Array.from(annotationUIDsMap.values())
        .flat()
        .map((uidSet) => Array.from(uidSet))
        .flat();
    const randomAnnotationUIDs = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getRandomSampleFromArray(annotationUIDs, 3);
    for (const annotationUID of randomAnnotationUIDs) {
        const annotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__.getAnnotation)(annotationUID);
        if (annotation?.metadata) {
            if (!annotation.metadata.viewPlaneNormal) {
                continue;
            }
            const annotationNormal = annotation.metadata.viewPlaneNormal;
            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +
                viewportNormal[1] * annotationNormal[1] +
                viewportNormal[2] * annotationNormal[2]);
            if (Math.abs(dotProduct - 1) > 0.01) {
                return false;
            }
        }
    }
    return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});


/***/ }),

/***/ 684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports MAX_NUMBER_COLORS, render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63597);
/* harmony import */ var _removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88234);
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26228);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50409);
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97577);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92686);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18682);
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(47098);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(59452);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(27479);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(49906);
/* harmony import */ var _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(59475);
















const MAX_NUMBER_COLORS = 255;
const labelMapConfigCache = new Map();
let polySegConversionInProgress = false;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    labelMapConfigCache.forEach((value, key) => {
        if (key.includes(segmentationId)) {
            labelMapConfigCache.delete(key);
        }
    });
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, config } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        console.warn('No segmentation found for segmentationId: ', segmentationId);
        return;
    }
    let labelmapData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap];
    let labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    if (!labelmapData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)();
        labelmapData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => null, () => {
            _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__/* .defaultSegmentationStateManager */ ._6.processLabelmapRepresentationAddition(viewport.id, segmentationId);
            setTimeout(() => {
                (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__.triggerSegmentationDataModified)(segmentationId);
            }, 0);
        });
        if (!labelmapData) {
            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);
        }
        polySegConversionInProgress = false;
    }
    else if (!labelmapData && !(0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)()) {
        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!labelmapData) {
        return;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        if (!labelmapActorEntries?.length) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    }
    else {
        const labelmapImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__/* .getCurrentLabelmapImageIdsForViewport */ .aF)(viewport.id, segmentationId);
        if (!labelmapImageIds?.length) {
            return;
        }
        if (!labelmapActorEntries) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    }
    if (!labelmapActorEntries?.length) {
        return;
    }
    for (const labelmapActorEntry of labelmapActorEntries) {
        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);
    }
}
function _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {
    const { segmentationId } = segmentationRepresentation;
    const { cfun, ofun } = segmentationRepresentation.config;
    const { colorLUTIndex } = segmentationRepresentation;
    const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewportId);
    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;
    const labelmapStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getStyle({
        viewportId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
        segmentationId,
    });
    const renderInactiveSegmentations = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getRenderInactiveSegmentations(viewportId);
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .getColorLUT */ .B)(colorLUTIndex);
    const numColors = Math.min(256, colorLUT.length);
    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);
    const segmentsHidden = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__/* .internalGetHiddenSegmentIndices */ .s)(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
    });
    for (let i = 0; i < numColors; i++) {
        const segmentIndex = i;
        const segmentColor = colorLUT[segmentIndex];
        const perSegmentStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getStyle({
            viewportId,
            type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
            segmentationId,
            segmentIndex,
        });
        const segmentSpecificLabelmapConfig = perSegmentStyle;
        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);
        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {
            fillAlpha,
            renderFill,
            renderOutline,
            segmentColor,
            outlineWidth,
            segmentsHidden: segmentsHidden,
            cfun,
            ofun,
        });
        if (forceColorUpdate) {
            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);
        }
        if (forceOpacityUpdate) {
            if (renderFill) {
                const segmentOpacity = segmentsHidden.has(segmentIndex)
                    ? 0
                    : (segmentColor[3] / 255) * fillAlpha;
                ofun.removePoint(segmentIndex);
                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);
            }
            else {
                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);
            }
        }
    }
    ofun.setClamping(false);
    const labelmapActor = labelmapActorEntry.actor;
    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };
    if (preLoad) {
        preLoad({ cfun, ofun, actor: labelmapActor });
    }
    else {
        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);
        labelmapActor.getProperty().setScalarOpacity(0, ofun);
        labelmapActor.getProperty().setInterpolationTypeToNearest();
    }
    if (renderOutline) {
        labelmapActor.getProperty().setUseLabelOutline(renderOutline);
        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);
        const activeSegmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__/* .getActiveSegmentIndex */ .Q)(segmentationRepresentation.segmentationId);
        const outlineWidths = new Array(numColors - 1);
        for (let i = 1; i < numColors; i++) {
            const isHidden = segmentsHidden.has(i);
            if (isHidden) {
                outlineWidths[i - 1] = 0;
                continue;
            }
            outlineWidths[i - 1] =
                i === activeSegmentIndex
                    ? outlineWidth + activeSegmentOutlineWidthDelta
                    : outlineWidth;
        }
        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);
        labelmapActor.modified();
        labelmapActor.getProperty().modified();
        labelmapActor.getMapper().modified();
    }
    else {
        labelmapActor
            .getProperty()
            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));
    }
    const visible = isActiveLabelmap || renderInactiveSegmentations;
    labelmapActor.setVisibility(visible);
}
function _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {
    const segmentLabelmapConfig = segmentsLabelmapConfig || {};
    const configToUse = {
        ...labelmapConfig,
        ...segmentLabelmapConfig,
    };
    const fillAlpha = isActiveLabelmap
        ? configToUse.fillAlpha
        : configToUse.fillAlphaInactive;
    const outlineWidth = isActiveLabelmap
        ? configToUse.outlineWidth
        : configToUse.outlineWidthInactive;
    const renderFill = isActiveLabelmap
        ? configToUse.renderFill
        : configToUse.renderFillInactive;
    const renderOutline = isActiveLabelmap
        ? configToUse.renderOutline
        : configToUse.renderOutlineInactive;
    const outlineOpacity = isActiveLabelmap
        ? configToUse.outlineOpacity
        : configToUse.outlineOpacityInactive;
    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;
    return {
        fillAlpha,
        outlineWidth,
        renderFill,
        renderOutline,
        outlineOpacity,
        activeSegmentOutlineWidthDelta,
    };
}
function _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {
    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;
    const oldConfig = labelMapConfigCache.get(cacheUID);
    if (!oldConfig) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
        return {
            forceOpacityUpdate: true,
            forceColorUpdate: true,
        };
    }
    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;
    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||
        oldSegmentColor[1] !== segmentColor[1] ||
        oldSegmentColor[2] !== segmentColor[2];
    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||
        oldFillAlpha !== fillAlpha ||
        oldRenderFill !== renderFill ||
        oldRenderOutline !== renderOutline ||
        oldOutlineWidth !== outlineWidth ||
        oldSegmentsHidden !== segmentsHidden;
    if (forceOpacityUpdate || forceColorUpdate) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
    }
    return {
        forceOpacityUpdate,
        forceColorUpdate,
    };
}
async function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {
    const result = await (0,_addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element, labelmapData, segmentationId, config);
    return result || undefined;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 67014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20552);
/* harmony import */ var _addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18796);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50409);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27479);
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(47098);









function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, type } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let SurfaceData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface];
    if (!SurfaceData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface)) {
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)();
        SurfaceData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }), () => polySeg.updateSurfaceData(segmentationId, { viewport }));
        if (!SurfaceData) {
            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);
        }
    }
    else if (!SurfaceData && !(0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)()) {
        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!SurfaceData) {
        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);
        return;
    }
    const { geometryIds } = SurfaceData;
    if (!geometryIds?.size) {
        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);
    }
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__/* .getColorLUT */ .B)(colorLUTIndex);
    const surfaces = [];
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry?.data) {
            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const { segmentIndex } = geometry.data;
        const hiddenSegments = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__/* .internalGetHiddenSegmentIndices */ .s)(viewport.id, {
            segmentationId,
            type,
        });
        const isHidden = hiddenSegments.has(segmentIndex);
        const surface = geometry.data;
        const color = colorLUT[segmentIndex];
        surface.color = color.slice(0, 3);
        surface.visible = !isHidden;
        surfaces.push(surface);
        (0,_addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewport.element, surface, segmentationId);
    });
    viewport.render();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 49975:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A5: () => (/* reexport safe */ _PlanarRotateTool__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   CH: () => (/* reexport safe */ _PanTool__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   Du: () => (/* reexport safe */ _WindowLevelTool__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   E0: () => (/* reexport safe */ _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_25__.A),
/* harmony export */   EC: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.EC),
/* harmony export */   EV: () => (/* reexport safe */ _annotation_CobbAngleTool__WEBPACK_IMPORTED_MODULE_37__.A),
/* harmony export */   FE: () => (/* reexport safe */ _ScaleOverlayTool__WEBPACK_IMPORTED_MODULE_16__.A),
/* harmony export */   Fz: () => (/* reexport safe */ _segmentation_SegmentBidirectionalTool__WEBPACK_IMPORTED_MODULE_55__.A),
/* harmony export */   G2: () => (/* reexport safe */ _segmentation_CircleScissorsTool__WEBPACK_IMPORTED_MODULE_46__.A),
/* harmony export */   IX: () => (/* reexport safe */ _segmentation_SegmentSelectTool__WEBPACK_IMPORTED_MODULE_54__.A),
/* harmony export */   Ix: () => (/* reexport safe */ _annotation_LivewireContourSegmentationTool__WEBPACK_IMPORTED_MODULE_34__.A),
/* harmony export */   J2: () => (/* reexport safe */ _annotation_SplineROITool__WEBPACK_IMPORTED_MODULE_29__.A),
/* harmony export */   LW: () => (/* reexport safe */ _annotation_LengthTool__WEBPACK_IMPORTED_MODULE_21__.A),
/* harmony export */   M$: () => (/* reexport safe */ _AdvancedMagnifyTool__WEBPACK_IMPORTED_MODULE_11__.A),
/* harmony export */   Mu: () => (/* reexport safe */ _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_19__.A),
/* harmony export */   N: () => (/* reexport safe */ _SculptorTool__WEBPACK_IMPORTED_MODULE_17__.A),
/* harmony export */   N7: () => (/* reexport safe */ _annotation_ProbeTool__WEBPACK_IMPORTED_MODULE_23__.A),
/* harmony export */   Nk: () => (/* reexport safe */ _OverlayGridTool__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   Np: () => (/* reexport safe */ _annotation_KeyImageTool__WEBPACK_IMPORTED_MODULE_39__.A),
/* harmony export */   OQ: () => (/* reexport safe */ _ZoomTool__WEBPACK_IMPORTED_MODULE_7__.A),
/* harmony export */   Oh: () => (/* reexport safe */ _VolumeRotateTool__WEBPACK_IMPORTED_MODULE_18__.A),
/* harmony export */   So: () => (/* reexport safe */ _TrackballRotateTool__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   TG: () => (/* reexport safe */ _WindowLevelRegionTool__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   TR: () => (/* reexport safe */ _segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_48__.A),
/* harmony export */   Tc: () => (/* reexport safe */ _annotation_WholeBodySegmentTool__WEBPACK_IMPORTED_MODULE_43__.A),
/* harmony export */   Uj: () => (/* reexport safe */ _segmentation_PaintFillTool__WEBPACK_IMPORTED_MODULE_52__.A),
/* harmony export */   Vl: () => (/* reexport safe */ _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_27__.A),
/* harmony export */   X8: () => (/* reexport safe */ _ReferenceLinesTool__WEBPACK_IMPORTED_MODULE_12__.A),
/* harmony export */   Xr: () => (/* reexport safe */ _OrientationMarkerTool__WEBPACK_IMPORTED_MODULE_53__.A),
/* harmony export */   Ys: () => (/* reexport safe */ _annotation_LivewireContourTool__WEBPACK_IMPORTED_MODULE_33__.A),
/* harmony export */   ae: () => (/* reexport safe */ _StackScrollTool__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   ao: () => (/* reexport safe */ _annotation_ArrowAnnotateTool__WEBPACK_IMPORTED_MODULE_35__.A),
/* harmony export */   cN: () => (/* reexport safe */ _SegmentationIntersectionTool__WEBPACK_IMPORTED_MODULE_14__.A),
/* harmony export */   dB: () => (/* reexport safe */ _AnnotationEraserTool__WEBPACK_IMPORTED_MODULE_40__.A),
/* harmony export */   eh: () => (/* reexport safe */ _MagnifyTool__WEBPACK_IMPORTED_MODULE_10__.A),
/* harmony export */   ep: () => (/* reexport safe */ _CrosshairsTool__WEBPACK_IMPORTED_MODULE_9__.A),
/* harmony export */   ex: () => (/* reexport safe */ _annotation_PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_31__.A),
/* harmony export */   hz: () => (/* reexport safe */ _annotation_LabelTool__WEBPACK_IMPORTED_MODULE_20__.A),
/* harmony export */   il: () => (/* reexport safe */ _segmentation_LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_44__.A),
/* harmony export */   j$: () => (/* reexport safe */ _annotation_DragProbeTool__WEBPACK_IMPORTED_MODULE_24__.A),
/* harmony export */   ls: () => (/* reexport safe */ _segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_51__.A),
/* harmony export */   m8: () => (/* reexport safe */ _annotation_HeightTool__WEBPACK_IMPORTED_MODULE_22__.A),
/* harmony export */   mX: () => (/* reexport safe */ _segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_49__.A),
/* harmony export */   nJ: () => (/* reexport safe */ _annotation_ETDRSGridTool__WEBPACK_IMPORTED_MODULE_28__.A),
/* harmony export */   oS: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.oS),
/* harmony export */   oi: () => (/* reexport safe */ _annotation_UltrasoundDirectionalTool__WEBPACK_IMPORTED_MODULE_38__.A),
/* harmony export */   pq: () => (/* reexport safe */ _segmentation_CircleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_50__.A),
/* harmony export */   qD: () => (/* reexport safe */ _annotation_EllipticalROITool__WEBPACK_IMPORTED_MODULE_26__.A),
/* harmony export */   qT: () => (/* reexport safe */ _annotation_SplineContourSegmentationTool__WEBPACK_IMPORTED_MODULE_30__.A),
/* harmony export */   qi: () => (/* reexport safe */ _annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_32__.A),
/* harmony export */   sR: () => (/* reexport safe */ _annotation_RegionSegmentPlusTool__WEBPACK_IMPORTED_MODULE_42__.A),
/* harmony export */   td: () => (/* reexport safe */ _segmentation_RectangleScissorsTool__WEBPACK_IMPORTED_MODULE_45__.A),
/* harmony export */   u9: () => (/* reexport safe */ _segmentation_SegmentLabelTool__WEBPACK_IMPORTED_MODULE_57__.A),
/* harmony export */   uJ: () => (/* reexport safe */ _MIPJumpToClickTool__WEBPACK_IMPORTED_MODULE_8__.A),
/* harmony export */   wR: () => (/* reexport safe */ _annotation_RegionSegmentTool__WEBPACK_IMPORTED_MODULE_41__.A),
/* harmony export */   wh: () => (/* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.wh),
/* harmony export */   xI: () => (/* reexport safe */ _ReferenceCursors__WEBPACK_IMPORTED_MODULE_15__.A),
/* harmony export */   yT: () => (/* reexport safe */ _annotation_AngleTool__WEBPACK_IMPORTED_MODULE_36__.A),
/* harmony export */   zH: () => (/* reexport safe */ _segmentation_SphereScissorsTool__WEBPACK_IMPORTED_MODULE_47__.A)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _PanTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38782);
/* harmony import */ var _TrackballRotateTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26884);
/* harmony import */ var _WindowLevelTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43159);
/* harmony import */ var _WindowLevelRegionTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17819);
/* harmony import */ var _StackScrollTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(89460);
/* harmony import */ var _PlanarRotateTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82058);
/* harmony import */ var _ZoomTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26938);
/* harmony import */ var _MIPJumpToClickTool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(66944);
/* harmony import */ var _CrosshairsTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14840);
/* harmony import */ var _MagnifyTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(72674);
/* harmony import */ var _AdvancedMagnifyTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(45152);
/* harmony import */ var _ReferenceLinesTool__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36797);
/* harmony import */ var _OverlayGridTool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(43185);
/* harmony import */ var _SegmentationIntersectionTool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(32302);
/* harmony import */ var _ReferenceCursors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(85735);
/* harmony import */ var _ScaleOverlayTool__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(26039);
/* harmony import */ var _SculptorTool__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(3751);
/* harmony import */ var _VolumeRotateTool__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(30588);
/* harmony import */ var _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(25072);
/* harmony import */ var _annotation_LabelTool__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(37117);
/* harmony import */ var _annotation_LengthTool__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(14335);
/* harmony import */ var _annotation_HeightTool__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(59320);
/* harmony import */ var _annotation_ProbeTool__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(61873);
/* harmony import */ var _annotation_DragProbeTool__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(40487);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(4010);
/* harmony import */ var _annotation_EllipticalROITool__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(78684);
/* harmony import */ var _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(31137);
/* harmony import */ var _annotation_ETDRSGridTool__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(8467);
/* harmony import */ var _annotation_SplineROITool__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(3066);
/* harmony import */ var _annotation_SplineContourSegmentationTool__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(60580);
/* harmony import */ var _annotation_PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(28220);
/* harmony import */ var _annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(37590);
/* harmony import */ var _annotation_LivewireContourTool__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(9136);
/* harmony import */ var _annotation_LivewireContourSegmentationTool__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(76358);
/* harmony import */ var _annotation_ArrowAnnotateTool__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(24146);
/* harmony import */ var _annotation_AngleTool__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(9608);
/* harmony import */ var _annotation_CobbAngleTool__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(99718);
/* harmony import */ var _annotation_UltrasoundDirectionalTool__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(94504);
/* harmony import */ var _annotation_KeyImageTool__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(33327);
/* harmony import */ var _AnnotationEraserTool__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(68760);
/* harmony import */ var _annotation_RegionSegmentTool__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(9626);
/* harmony import */ var _annotation_RegionSegmentPlusTool__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(7750);
/* harmony import */ var _annotation_WholeBodySegmentTool__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(31787);
/* harmony import */ var _segmentation_LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(23631);
/* harmony import */ var _segmentation_RectangleScissorsTool__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(56526);
/* harmony import */ var _segmentation_CircleScissorsTool__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(66917);
/* harmony import */ var _segmentation_SphereScissorsTool__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(10804);
/* harmony import */ var _segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(40336);
/* harmony import */ var _segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(67847);
/* harmony import */ var _segmentation_CircleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(65284);
/* harmony import */ var _segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(48736);
/* harmony import */ var _segmentation_PaintFillTool__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(61777);
/* harmony import */ var _OrientationMarkerTool__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(36913);
/* harmony import */ var _segmentation_SegmentSelectTool__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(12905);
/* harmony import */ var _segmentation_SegmentBidirectionalTool__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(38502);
/* harmony import */ var _segmentation_strategies__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(99522);
/* harmony import */ var _segmentation_SegmentLabelTool__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(987);





























































/***/ }),

/***/ 48736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17492);
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1989);
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56789);
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33852);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58640);
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(23631);
/* harmony import */ var _strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(40905);












class BrushTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .fillInsideCircle */ .kr,
                ERASE_INSIDE_CIRCLE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__/* .eraseInsideCircle */ .r,
                FILL_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .fillInsideSphere */ .Jq,
                ERASE_INSIDE_SPHERE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__/* .eraseInsideSphere */ ._,
                THRESHOLD_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .thresholdInsideCircle */ .q,
                THRESHOLD_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .thresholdInsideSphere */ .rd,
                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .thresholdInsideSphereIsland */ .Sw,
            },
            defaultStrategy: 'FILL_INSIDE_CIRCLE',
            activeStrategy: 'FILL_INSIDE_CIRCLE',
            brushSize: 25,
            useCenterSegmentIndex: false,
            preview: {
                enabled: false,
                previewColors: {
                    0: [255, 255, 255, 128],
                },
                previewTimeMs: 250,
                previewMoveDistance: 8,
                dragMoveDistance: 4,
                dragTimeMs: 500,
            },
            actions: {
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview,
                    bindings: [
                        {
                            key: 'Enter',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview,
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'i',
                        },
                    ],
                    configuration: {
                        useBallStructuringElement: true,
                        noUseDistanceTransform: true,
                        noUseExtrapolation: true,
                    },
                },
                interpolateExtrapolation: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'e',
                        },
                    ],
                    configuration: {},
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolPassive = (evt) => {
            this.disableCursor();
        };
        this.onSetToolEnabled = () => {
            this.disableCursor();
        };
        this.onSetToolDisabled = (evt) => {
            this.disableCursor();
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this._editData = this.createEditData(element);
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.hideElementCursor)(element);
            evt.preventDefault();
            this._previewData.isDrag = false;
            this._previewData.timerStart = Date.now();
            const hoverData = this._hoverData || this.createHoverData(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(hoverData.viewportIdsToRender);
            const operationData = this.getOperationData(element);
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionStart);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_2__.ToolModes.Active) {
                this.updateCursor(evt);
                if (!this.configuration.preview.enabled) {
                    return;
                }
                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
                const { currentPoints, element } = evt.detail;
                const { canvas } = currentPoints;
                const { startPoint, timer, timerStart, isDrag } = this._previewData;
                if (isDrag) {
                    return;
                }
                const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(canvas, startPoint);
                const time = Date.now() - timerStart;
                if (delta > previewMoveDistance ||
                    (time > previewTimeMs && delta > dragMoveDistance)) {
                    if (timer) {
                        window.clearTimeout(timer);
                        this._previewData.timer = null;
                    }
                    if (!isDrag) {
                        this.rejectPreview(element);
                    }
                }
                if (!this._previewData.timer) {
                    const timer = window.setTimeout(this.previewCallback, 250);
                    Object.assign(this._previewData, {
                        timerStart: Date.now(),
                        timer,
                        startPoint: canvas,
                        element,
                    });
                }
            }
        };
        this.previewCallback = () => {
            if (this._previewData.isDrag) {
                this._previewData.timer = null;
                return;
            }
            this._previewData.timer = null;
            const operationData = this.getOperationData(this._previewData.element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const activeStrategy = this.configuration.activeStrategy;
            const strategyData = (0,_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__/* .getStrategyData */ .S)({
                operationData,
                viewport,
                strategy: activeStrategy,
            });
            if (!operationData) {
                return;
            }
            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);
            this._previewData.preview = this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element), {
                ...operationData,
                ...strategyData,
                memo,
            }, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Preview);
        };
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.updateCursor(evt);
            const { viewportIdsToRender } = this._hoverData;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(currentPoints.canvas, this._previewData.startPoint);
            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
            if (!this._previewData.isDrag &&
                Date.now() - this._previewData.timerStart < dragTimeMs &&
                delta < dragMoveDistance) {
                return;
            }
            if (this._previewData.timer) {
                window.clearTimeout(this._previewData.timer);
                this._previewData.timer = null;
            }
            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));
            this._previewData.element = element;
            this._previewData.timerStart = Date.now() + dragTimeMs;
            this._previewData.isDrag = true;
            this._previewData.startPoint = currentPoints.canvas;
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = this.getOperationData(element);
            if (!this._previewData.preview && !this._previewData.isDrag) {
                this.applyActiveStrategy(enabledElement, operationData);
            }
            this.doneEditMemo();
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.resetElementCursor)(element);
            this.updateCursor(evt);
            this._editData = null;
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionEnd);
            if (!this._previewData.isDrag) {
                this.acceptPreview(element);
            }
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    disableCursor() {
        this._hoverData = undefined;
        this.rejectPreview();
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const { element } = eventData;
        const { currentPoints } = eventData;
        const centerCanvas = currentPoints.canvas;
        this._hoverData = this.createHoverData(element, centerCanvas);
        this._calculateCursor(element, centerCanvas);
        if (!this._hoverData) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this._hoverData.viewportIdsToRender);
    }
    _calculateCursor(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvasToWorld } = viewport;
        const camera = viewport.getCamera();
        const { brushSize } = this.configuration;
        const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
        const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
        const centerCursorInWorld = canvasToWorld([
            centerCanvas[0],
            centerCanvas[1],
        ]);
        const bottomCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const topCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const leftCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const rightCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        for (let i = 0; i <= 2; i++) {
            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
        }
        if (!this._hoverData) {
            return;
        }
        const { brushCursor } = this._hoverData;
        const { data } = brushCursor;
        if (data.handles === undefined) {
            data.handles = {};
        }
        data.handles.points = [
            bottomCursorInWorld,
            topCursorInWorld,
            leftCursorInWorld,
            rightCursorInWorld,
        ];
        const activeStrategy = this.configuration.activeStrategy;
        const strategy = this.configuration.strategies[activeStrategy];
        if (typeof strategy?.computeInnerCircleRadius === 'function') {
            strategy.computeInnerCircleRadius({
                configuration: this.configuration,
                viewport,
            });
        }
        data.invalidated = false;
    }
    getStatistics(element, segmentIndices) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.GetStatistics, segmentIndices);
        return stats;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        this.doneEditMemo();
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        super.acceptPreview(element);
    }
    interpolate(element, config) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate, config.configuration);
        this._previewData.isDrag = true;
    }
    invalidateBrushCursor() {
        if (this._hoverData === undefined) {
            return;
        }
        const { data } = this._hoverData.brushCursor;
        const { viewport } = this._hoverData;
        data.invalidated = true;
        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};
        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._hoverData) {
            return;
        }
        const { viewport } = enabledElement;
        const viewportIdsToRender = this._hoverData.viewportIdsToRender;
        if (!viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const brushCursor = this._hoverData.brushCursor;
        if (brushCursor.data.invalidated === true) {
            const { centerCanvas } = this._hoverData;
            const { element } = viewport;
            this._calculateCursor(element, centerCanvas);
        }
        const toolMetadata = brushCursor.metadata;
        if (!toolMetadata) {
            return;
        }
        const annotationUID = toolMetadata.brushCursorUID;
        const data = brushCursor.data;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const bottom = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const center = [
            Math.floor((bottom[0] + top[0]) / 2),
            Math.floor((bottom[1] + top[1]) / 2),
        ];
        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return;
        }
        const circleUID = '0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
            color,
            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,
        });
        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {
            dynamicRadiusInCanvas: 0,
        };
        if (dynamicRadiusInCanvas) {
            const circleUID1 = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
                color,
            });
        }
    }
}
BrushTool.toolName = 'Brush';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTool);


/***/ }),

/***/ 65284:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60810);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62514);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(473);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(29601);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(44049);
/* harmony import */ var _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(31137);
/* harmony import */ var _utilities_math_circle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(77081);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(4096);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(11683);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(73262);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(13165);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(40634);





















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class CircleROIStartEndThresholdTool extends _annotation_CircleROITool__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            calculatePointsInsideVolume: false,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_18__.BasicStatsCalculator,
            showTextBox: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    volumeId,
                    spacingInNormal,
                    enabledElement,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        statistics: [],
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_10__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.removeAnnotation)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            if (this.configuration.calculatePointsInsideVolume) {
                this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationCompleted)(annotation);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotations)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_19__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_14__.getCanvasCircleRadius)(canvasCoordinates);
                const { centerPointRadius } = this.configuration;
                const canvasCorners = (0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_14__.getCanvasCircleCorners)(canvasCoordinates);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let tempStartCoordinate = startCoordinate;
                let tempEndCoordinate = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);
                    data.startCoordinate = tempStartCoordinate;
                }
                if (Array.isArray(endCoordinate)) {
                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);
                    data.endCoordinate = tempEndCoordinate;
                }
                const roundedStartCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(data.startCoordinate);
                const roundedEndCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(data.endCoordinate);
                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCameraCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(cameraCoordinate);
                if (roundedCameraCoordinate <
                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||
                    roundedCameraCoordinate >
                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {
                    continue;
                }
                const middleCoordinate = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);
                let isMiddleSlice = false;
                if (roundedCameraCoordinate === middleCoordinate) {
                    isMiddleSlice = true;
                }
                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_9__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_3__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    isMiddleSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineWidthToUse = lineWidth;
                let lineDashToUse = lineDash;
                if (isMiddleSlice) {
                    lineWidthToUse = lineWidth;
                    lineDashToUse = [];
                }
                else {
                    lineDashToUse = [5, 5];
                }
                const circleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth: lineWidthToUse,
                });
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                if (this.configuration.showTextBox == true &&
                    this.configuration.calculatePointsInsideVolume == true) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    let canvasTextBoxCoords;
                    if (!data.handles.textBox.hasMoved) {
                        canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_7__.getTextBoxCoordsCanvas)(canvasCorners);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(this._calculateCachedStatsTool, 100, { trailing: true });
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const handlesToStart = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(points);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
            handlesToStart[0][2] = startCoordinate;
            handlesToStart[1][2] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
            handlesToStart[0][0] = startCoordinate;
            handlesToStart[1][0] = startCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
            handlesToStart[0][1] = startCoordinate;
            handlesToStart[1][1] = startCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(handlesToStart.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_14__.getCanvasCircleCorners)(canvasCoordinates));
        const pos1 = viewport.canvasToWorld(topLeftCanvas);
        const pos2 = viewport.canvasToWorld(bottomRightCanvas);
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromTwoPoints__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewPlaneNormal, viewUp, pos1, pos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_15__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, data.handles);
        const aspect = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_15__/* .getCalibratedAspect */ .CQ)(image);
        const area = Math.abs(Math.PI *
            (worldWidth / measureInfo.scale / 2) *
            (worldHeight / aspect / measureInfo.scale / 2));
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_16__/* .isViewportPreScaled */ .u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_20__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const centerWorld = projectionPoints[i][0];
            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));
            const [topLeftCanvas, bottomRightCanvas] = ((0,_utilities_math_circle__WEBPACK_IMPORTED_MODULE_14__.getCanvasCircleCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = centerWorld;
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    isInObject: (pointLPS) => (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_17__.pointInEllipse)(ellipseObj, pointLPS),
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
        }
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_12__.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);
        const startPos = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
CircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleROIStartEndThresholdTool);


/***/ }),

/***/ 66917:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56789);
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33852);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44595);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98870);
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(23631);











class CircleScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_2__/* .fillInsideCircle */ .kr,
                ERASE_INSIDE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_3__/* .eraseInsideCircle */ .r,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_8__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__.getSegmentation)(segmentationId);
            const labelmapData = representationData.Labelmap;
            if (!labelmapData) {
                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');
            }
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    isDrawing: true,
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_9__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_6__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_4__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
CircleScissorsTool.toolName = 'CircleScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CircleScissorsTool);


/***/ }),

/***/ 61777:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44595);
/* harmony import */ var _utilities_segmentation_floodFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(84882);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98870);







const { transformWorldToIndex, isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class PaintFillTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal } = camera;
            const activeSegmentationRepresentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_4__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__.getSegmentation)(segmentationId);
            let dimensions;
            let direction;
            let index;
            let voxelManager;
            this.doneEditMemo();
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = representationData[_enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap];
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                ({ dimensions, direction } = segmentation);
                voxelManager = segmentation.voxelManager;
                index = transformWorldToIndex(segmentation.imageData, worldPos);
            }
            else {
                const currentSegmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_6__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                if (!currentSegmentationImageId) {
                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');
                }
                const { imageData } = viewport.getImageData();
                dimensions = imageData.getDimensions();
                direction = imageData.getDirection();
                const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(currentSegmentationImageId);
                voxelManager = image.voxelManager;
                index = transformWorldToIndex(imageData, worldPos);
            }
            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);
            if (fixedDimension === undefined) {
                console.warn('Oblique paint fill not yet supported');
                return;
            }
            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);
            if (index[0] < 0 ||
                index[0] >= dimensions[0] ||
                index[1] < 0 ||
                index[1] >= dimensions[1] ||
                index[2] < 0 ||
                index[2] >= dimensions[2]) {
                return;
            }
            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);
            if (segmentsLocked.includes(clickedLabelValue)) {
                return;
            }
            const floodFillResult = (0,_utilities_segmentation_floodFill__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(floodFillGetter, inPlaneSeedPoint);
            const { flooded } = floodFillResult;
            flooded.forEach((index) => {
                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);
                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);
            });
            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationDataModified)(segmentationId, framesModified);
            return true;
        };
        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {
            const { flooded: boundaries } = floodFillResult;
            if (fixedDimension === 2) {
                return [fixedDimensionValue];
            }
            let minJ = Infinity;
            let maxJ = -Infinity;
            for (let b = 0; b < boundaries.length; b++) {
                const j = boundaries[b][1];
                if (j < minJ) {
                    minJ = j;
                }
                if (j > maxJ) {
                    maxJ = j;
                }
            }
            const framesModified = [];
            for (let frame = minJ; frame <= maxJ; frame++) {
                framesModified.push(frame);
            }
            return framesModified;
        };
        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {
            let fixedDimensionValue;
            let inPlaneSeedPoint;
            switch (fixedDimension) {
                case 0:
                    fixedDimensionValue = seedIndex3D[0];
                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];
                    break;
                case 1:
                    fixedDimensionValue = seedIndex3D[1];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];
                    break;
                case 2:
                    fixedDimensionValue = seedIndex3D[2];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            const getScalarDataPosition = (x, y, z) => {
                return voxelManager.toIndex([x, y, z]);
            };
            const getLabelValue = (x, y, z) => {
                return voxelManager.getAtIJK(x, y, z);
            };
            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);
            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);
            return {
                getScalarDataPositionFromPlane,
                getLabelValue,
                floodFillGetter,
                inPlaneSeedPoint,
                fixedDimensionValue,
            };
        };
        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {
            let floodFillGetter;
            switch (fixedDimension) {
                case 0:
                    floodFillGetter = (y, z) => {
                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    floodFillGetter = (x, z) => {
                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    floodFillGetter = (x, y) => {
                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {
                            return;
                        }
                        return getLabelValue(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return floodFillGetter;
        };
        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {
            let getScalarDataPositionFromPlane;
            switch (fixedDimension) {
                case 0:
                    getScalarDataPositionFromPlane = (y, z) => {
                        return getScalarDataPosition(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    getScalarDataPositionFromPlane = (x, z) => {
                        return getScalarDataPosition(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    getScalarDataPositionFromPlane = (x, y) => {
                        return getScalarDataPosition(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return getScalarDataPositionFromPlane;
        };
    }
    getFixedDimension(viewPlaneNormal, direction) {
        const xDirection = direction.slice(0, 3);
        const yDirection = direction.slice(3, 6);
        const zDirection = direction.slice(6, 9);
        const absoluteOfViewPlaneNormal = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const absoluteOfXDirection = [
            Math.abs(xDirection[0]),
            Math.abs(xDirection[1]),
            Math.abs(xDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {
            return 0;
        }
        const absoluteOfYDirection = [
            Math.abs(yDirection[0]),
            Math.abs(yDirection[1]),
            Math.abs(yDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {
            return 1;
        }
        const absoluteOfZDirection = [
            Math.abs(zDirection[0]),
            Math.abs(zDirection[1]),
            Math.abs(zDirection[2]),
        ];
        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {
            return 2;
        }
    }
}
PaintFillTool.toolName = 'PaintFill';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaintFillTool);


/***/ }),

/***/ 67847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4096);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60810);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27730);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(473);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(35489);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(29601);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4010);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(73262);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(13165);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(40634);



















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class RectangleROIStartEndThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            computePointsInsideVolume: false,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__.BasicStatsCalculator,
            showTextBox: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                    spacingInNormal,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        projectionPointsImageIds: [referencedImageId],
                        statistics: [],
                    },
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            if (this.configuration.calculatePointsInsideVolume) {
                this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationCompleted)(annotation);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotations */ .Rh)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_17__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let startCoord = startCoordinate;
                let endCoord = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);
                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);
                    data.handles.points.forEach((point) => {
                        point[indexOfDirection] = startCoord;
                    });
                    data.startCoordinate = startCoord;
                }
                if (Array.isArray(endCoordinate)) {
                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);
                    data.endCoordinate = endCoord;
                    data.endCoordinate = endCoord;
                }
                const roundedStartCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(startCoord);
                const roundedEndCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(endCoord);
                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(coord);
                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||
                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {
                    continue;
                }
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                let firstOrLastSlice = false;
                if (roundedCoord === roundedStartCoord ||
                    roundedCoord === roundedEndCoord) {
                    firstOrLastSlice = true;
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    firstOrLastSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineDashToUse = lineDash;
                if (!firstOrLastSlice) {
                    lineDashToUse = 2;
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth,
                });
                renderStatus = true;
                if (this.configuration.showTextBox &&
                    this.configuration.calculatePointsInsideVolume) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    if (!data.handles.textBox.hasMoved) {
                        const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_8__.getTextBoxCoordsCanvas)(canvasCoordinates);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this._calculateCachedStatsTool, 100, { trailing: true });
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.distance */ .eR.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(points.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[3];
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, data.habdles);
        const area = Math.abs(worldWidth * worldHeight) /
            (measureInfo.scale * measureInfo.scale);
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__/* .isViewportPreScaled */ .u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const projectionPoint = projectionPoints[i][0];
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                this.isHandleOutsideImage = false;
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
        }
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, viewPlaneNormal) {
        const startPos = worldPos;
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
RectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIStartEndThresholdTool);


/***/ }),

/***/ 40336:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4010);










class RectangleROIThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const targetId = this.getTargetId(viewport);
            let referencedImageId, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                referencedImageId = targetId.split('imageId:')[1];
            }
            else {
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: null,
                            worldBoundingBox: null,
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    segmentationId: null,
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element);
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                });
                renderStatus = true;
            }
            return renderStatus;
        };
    }
}
RectangleROIThresholdTool.toolName = 'RectangleROIThreshold';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROIThresholdTool);


/***/ }),

/***/ 56526:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _strategies_fillRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10088);
/* harmony import */ var _strategies_eraseRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47347);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(44595);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(98870);
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23631);












class RectangleScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillRectangle__WEBPACK_IMPORTED_MODULE_2__/* .fillInsideRectangle */ .pY,
                ERASE_INSIDE: _strategies_eraseRectangle__WEBPACK_IMPORTED_MODULE_3__/* .eraseInsideRectangle */ .M,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_9__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__.getSegmentation)(segmentationId);
            const labelmapData = representationData[_enums__WEBPACK_IMPORTED_MODULE_5__.SegmentationRepresentations.Labelmap];
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                },
            };
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_10__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            points[handleIndex] = [...worldPos];
            let bottomLeftCanvas;
            let bottomRightCanvas;
            let topLeftCanvas;
            let topRightCanvas;
            let bottomLeftWorld;
            let bottomRightWorld;
            let topLeftWorld;
            let topRightWorld;
            switch (handleIndex) {
                case 0:
                case 3:
                    bottomLeftCanvas = worldToCanvas(points[0]);
                    topRightCanvas = worldToCanvas(points[3]);
                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                    bottomRightWorld = canvasToWorld(bottomRightCanvas);
                    topLeftWorld = canvasToWorld(topLeftCanvas);
                    points[1] = bottomRightWorld;
                    points[2] = topLeftWorld;
                    break;
                case 1:
                case 2:
                    bottomRightCanvas = worldToCanvas(points[1]);
                    topLeftCanvas = worldToCanvas(points[2]);
                    bottomLeftCanvas = [
                        topLeftCanvas[0],
                        bottomRightCanvas[1],
                    ];
                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];
                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                    topRightWorld = canvasToWorld(topRightCanvas);
                    points[0] = bottomLeftWorld;
                    points[3] = topRightWorld;
                    break;
            }
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_5__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const rectangleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_6__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
RectangleScissorsTool.toolName = 'RectangleScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleScissorsTool);


/***/ }),

/***/ 38502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29601);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60810);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(473);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58640);
/* harmony import */ var _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25072);
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(93733);











class SegmentBidirectionalTool extends _annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    static { this.toolName = 'SegmentBidirectional'; }
    constructor(toolProps = {}) {
        super(toolProps);
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportId = viewport.id;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { segmentIndex, segmentationId } = annotation.metadata;
                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const colorArray = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_10__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_3__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                options.color = color;
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_6__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_5__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_7__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const existingAnnotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAllAnnotations)();
        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');
        const existingAnnotation = toolAnnotations.find((annotation) => {
            const { metadata } = annotation;
            if (metadata.segmentIndex === options?.segmentIndex &&
                metadata.segmentationId === options?.segmentationId) {
                return true;
            }
            return false;
        });
        if (existingAnnotation) {
            (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.removeAnnotation)(existingAnnotation.annotationUID);
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                segmentIndex: options?.segmentIndex,
                segmentationId: options?.segmentationId,
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)([viewport.id]);
        return annotation;
    }; }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentBidirectionalTool);


/***/ }),

/***/ 987:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49906);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26228);
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(93759);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85204);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17328);








class SegmentLabelTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    constructor(toolProps = {
        data: {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        },
    }, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setHoveredSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.data = toolProps.data ?? {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        };
        this.hoverTimer = null;
    }
    _setHoveredSegment(evt = {}) {
        if (_store_state__WEBPACK_IMPORTED_MODULE_6__/* .state */ .wk.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId } = activeSegmentation;
        const hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_5__.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
            viewport,
        });
        const segment = activeSegmentation.segments[hoveredSegmentIndex];
        const label = segment?.label;
        const canvasCoordinates = viewport.worldToCanvas(worldPoint);
        this._editData = {
            hoveredSegmentIndex,
            hoveredSegmentLabel: label,
            canvasCoordinates,
            worldPoint,
        };
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationModified)(segmentationId);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIds);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._editData) {
            return;
        }
        const { viewport } = enabledElement;
        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, worldPoint, } = this._editData;
        if (!hoveredSegmentIndex) {
            return;
        }
        const textBoxPosition = viewport.worldToCanvas(worldPoint);
        const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawLinkedTextBox)(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ? hoveredSegmentLabel : '(unnamed segment)'], textBoxPosition, [canvasCoordinates], {}, {});
        const left = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const { width, height } = boundingBox;
        this.data.handles.textBox.worldBoundingBox = {
            topLeft: viewport.canvasToWorld([left, top]),
            topRight: viewport.canvasToWorld([left + width, top]),
            bottomLeft: viewport.canvasToWorld([left, top + height]),
            bottomRight: viewport.canvasToWorld([left + width, top + height]),
        };
    }
}
SegmentLabelTool.toolName = 'SegmentLabelTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentLabelTool);


/***/ }),

/***/ 12905:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49906);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26228);
/* harmony import */ var _stateManagement_segmentation_segmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70930);
/* harmony import */ var _utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93759);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99737);









class SegmentSelectTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    static { this.SelectMode = {
        Inside: 'Inside',
        Border: 'Border',
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.mode !== _enums__WEBPACK_IMPORTED_MODULE_8__.ToolModes.Active) {
                return;
            }
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        if (_store_state__WEBPACK_IMPORTED_MODULE_7__/* .state */ .wk.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_4__.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, representationData } = activeSegmentation;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            if (representationData.Labelmap) {
                hoveredSegmentIndex = (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getSegmentIndexAtLabelmapBorder)(segmentationId, worldPoint, {
                    viewport,
                    searchRadius: this.configuration.searchRadius,
                });
            }
            else if (representationData.Contour) {
                hoveredSegmentIndex =
                    (0,_utilities_segmentation__WEBPACK_IMPORTED_MODULE_6__.getHoveredContourSegmentationAnnotation)(segmentationId);
            }
            else if (representationData.Surface) {
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0,_stateManagement_segmentation_segmentIndex__WEBPACK_IMPORTED_MODULE_5__.setActiveSegmentIndex)(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationModified)(segmentationId);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportIds);
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentSelectTool);


/***/ }),

/***/ 10804:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17492);
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1989);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17328);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44595);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98870);
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(23631);










class SphereScissorsTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_1__/* .fillInsideSphere */ .Jq,
                ERASE_INSIDE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_2__/* .eraseInsideSphere */ ._,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeSegmentationRepresentation = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = _stateManagement_segmentation__WEBPACK_IMPORTED_MODULE_7__.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            this.isDrawing = true;
            const annotation = {
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    invalidated: true,
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    highlighted: true,
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                toolGroupId: this.toolGroupId,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            const { representationData } = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_8__.getSegmentation)(segmentationId);
            const editData = this.getEditData({
                viewport,
                representationData,
                segmentsLocked,
                segmentationId,
            });
            this.editData = {
                ...this.editData,
                ...editData,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                segmentIndex,
                segmentsLocked,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_3__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_4__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
SphereScissorsTool.toolName = 'SphereScissor';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SphereScissorsTool);


/***/ }),

/***/ 62753:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84093);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83075);




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.EnsureImageVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        let referencedImageIds;
        if (viewport) {
            referencedImageIds = viewport.getImageIds();
            const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
            if (!isValidVolumeForSphere) {
                throw new Error('Volume is not reconstructable for sphere manipulation');
            }
        }
        else {
            const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(operationData.segmentationId);
            const imageIds = segmentation.representationData
                .Labelmap.imageIds;
            referencedImageIds = imageIds.map((imageId) => {
                const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
                return image.referencedImageId;
            });
        }
        const imageVolume = (0,_utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(referencedImageIds);
        if (!imageVolume) {
            throw new Error('Failed to create or get image volume');
        }
        operationData.imageVoxelManager = imageVolume.voxelManager;
        operationData.imageData = imageVolume.imageData;
    },
});


/***/ }),

/***/ 38732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84093);
/* harmony import */ var _utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30722);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.EnsureSegmentationVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        const { segmentationId, imageIds: segImageIds } = operationData;
        const referencedImageIds = viewport
            ? viewport.getImageIds()
            : segImageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
        const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
        if (!isValidVolumeForSphere) {
            throw new Error('Volume is not reconstructable for sphere manipulation');
        }
        const segVolume = (0,_utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(segmentationId);
        if (!segVolume) {
            return;
        }
        operationData.segmentationVoxelManager = segVolume.voxelManager;
        operationData.segmentationImageData = segVolume.imageData;
        return;
    },
});


/***/ }),

/***/ 56789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N5: () => (/* binding */ fillOutsideCircle),
/* harmony export */   kr: () => (/* binding */ fillInsideCircle),
/* harmony export */   mu: () => (/* binding */ createPointInEllipse),
/* harmony export */   pB: () => (/* binding */ CIRCLE_STRATEGY),
/* harmony export */   q: () => (/* binding */ thresholdInsideCircle)
/* harmony export */ });
/* unused harmony export CIRCLE_THRESHOLD_STRATEGY */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11683);
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72282);
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55887);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99737);
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11990);
/* harmony import */ var _utilities_math_sphere__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(62783);








const { transformWorldToIndex, isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const initializeCircle = {
    [_enums__WEBPACK_IMPORTED_MODULE_5__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const [topLeftCanvas, bottomRightCanvas] = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__.getCanvasEllipseCorners)(canvasCoordinates);
        const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
        const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
        const circleCornersIJK = points.map((world) => {
            return transformWorldToIndex(segmentationImageData, world);
        });
        const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_3__.getBoundingBoxAroundShapeIJK)(circleCornersIJK, segmentationImageData.getDimensions());
        operationData.isInObject = createPointInEllipse({
            topLeftWorld,
            bottomRightWorld,
            center,
        });
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInEllipse(worldInfo) {
    const { topLeftWorld, bottomRightWorld, center } = worldInfo;
    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
    const radius = Math.max(xRadius, yRadius, zRadius);
    if (isEqual(xRadius, radius) &&
        isEqual(yRadius, radius) &&
        isEqual(zRadius, radius)) {
        const sphereObj = {
            center,
            radius,
            radius2: radius * radius,
        };
        return (pointLPS) => (0,_utilities_math_sphere__WEBPACK_IMPORTED_MODULE_7__/* .pointInSphere */ .d)(sphereObj, pointLPS);
    }
    const ellipseObj = {
        center: center,
        xRadius,
        yRadius,
        zRadius,
    };
    const { precalculated } = (0,_utilities_math_ellipse__WEBPACK_IMPORTED_MODULE_2__.precalculatePointInEllipse)(ellipseObj, {});
    return precalculated;
}
const CIRCLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A('Circle', _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.labelmapStatistics);
const CIRCLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A('CircleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.threshold, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.labelmapStatistics);
const fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
const thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
function fillOutsideCircle() {
    throw new Error('Not yet implemented');
}



/***/ }),

/***/ 10088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VQ: () => (/* binding */ thresholdInsideRectangle),
/* harmony export */   pY: () => (/* binding */ fillInsideRectangle)
/* harmony export */ });
/* unused harmony exports RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72282);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);
/* harmony import */ var _utils_getStrategyData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40905);
/* harmony import */ var _utilities_rectangleROITool_isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26384);
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55887);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99737);
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(11990);









const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const initializeRectangle = {
    [_enums__WEBPACK_IMPORTED_MODULE_7__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, imageVoxelManager, viewport, segmentationImageData, segmentationVoxelManager, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);
        operationData.isInObject = pointInShapeFn;
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInRectangle(viewport, points, segmentationImageData) {
    let rectangleCornersIJK = points.map((world) => {
        return transformWorldToIndex(segmentationImageData, world);
    });
    rectangleCornersIJK = rectangleCornersIJK.map((point) => {
        return point.map((coord) => {
            return Math.round(coord);
        });
    });
    const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)(rectangleCornersIJK, segmentationImageData.getDimensions());
    const isStackViewport = viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport;
    const isAligned = isStackViewport || (0,_utilities_rectangleROITool_isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_5__/* .isAxisAlignedRectangle */ .l)(rectangleCornersIJK);
    const direction = segmentationImageData.getDirection();
    const spacing = segmentationImageData.getSpacing();
    const { viewPlaneNormal } = viewport.getCamera();
    const EPS = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getSpacingInNormalDirection({
        direction,
        spacing,
    }, viewPlaneNormal);
    const pointsBoundsLPS = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeWorld)(points);
    let [[xMin, xMax], [yMin, yMax], [zMin, zMax]] = pointsBoundsLPS;
    xMin -= EPS;
    xMax += EPS;
    yMin -= EPS;
    yMax += EPS;
    zMin -= EPS;
    zMax += EPS;
    const pointInShapeFn = isAligned
        ? () => true
        : (pointLPS) => {
            const [x, y, z] = pointLPS;
            const xInside = x >= xMin && x <= xMax;
            const yInside = y >= yMin && y <= yMax;
            const zInside = z >= zMin && z <= zMax;
            return xInside && yInside && zInside;
        };
    return { boundsIJK, pointInShapeFn };
}
const RECTANGLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A('Rectangle', _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.labelmapStatistics);
const RECTANGLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A('RectangleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.threshold, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.labelmapStatistics);
const fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;
const thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;



/***/ }),

/***/ 99522:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillInsideCircle: () => (/* reexport safe */ _fillCircle__WEBPACK_IMPORTED_MODULE_1__.kr),
/* harmony export */   fillInsideRectangle: () => (/* reexport safe */ _fillRectangle__WEBPACK_IMPORTED_MODULE_0__.pY),
/* harmony export */   fillOutsideCircle: () => (/* reexport safe */ _fillCircle__WEBPACK_IMPORTED_MODULE_1__.N5),
/* harmony export */   thresholdInsideRectangle: () => (/* reexport safe */ _fillRectangle__WEBPACK_IMPORTED_MODULE_0__.VQ)
/* harmony export */ });
/* harmony import */ var _fillRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10088);
/* harmony import */ var _fillCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56789);





/***/ }),

/***/ 93126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ContourWindingDirection)
/* harmony export */ });
var ContourWindingDirection;
(function (ContourWindingDirection) {
    ContourWindingDirection[ContourWindingDirection["CounterClockwise"] = -1] = "CounterClockwise";
    ContourWindingDirection[ContourWindingDirection["Unknown"] = 0] = "Unknown";
    ContourWindingDirection[ContourWindingDirection["Clockwise"] = 1] = "Clockwise";
})(ContourWindingDirection || (ContourWindingDirection = {}));


/***/ }),

/***/ 13369:
/***/ (() => {



/***/ }),

/***/ 16678:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AnnotationMultiSlice)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94021);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);



class AnnotationMultiSlice {
    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, startRange);
    }
    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, undefined, endRange);
    }
    static setRange(viewport, annotation, startRange, endRange) {
        const { metadata } = annotation;
        if (startRange === undefined) {
            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;
            if (endRange === undefined) {
                endRange = viewport.getNumberOfSlices() - 1;
            }
        }
        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);
        if (endRange === undefined) {
            endRange =
                rangeEndSliceIndex >= startRange
                    ? rangeEndSliceIndex
                    : viewport.getNumberOfSlices() - 1;
        }
        endRange = Math.max(startRange, endRange);
        metadata.sliceIndex = Math.min(startRange, endRange);
        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);
        metadata.referencedImageURI = undefined;
        if (endRange === metadata.sliceIndex) {
            metadata.multiSliceReference = undefined;
        }
        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {
            metadata.multiSliceReference = {
                referencedImageId: viewport.getCurrentImageId(endRange),
                sliceIndex: endRange,
            };
        }
        const eventDetail = {
            viewportId: viewport.id,
            renderingEngineId: viewport.renderingEngineId,
            changeType: _enums__WEBPACK_IMPORTED_MODULE_2__.ChangeTypes.MetadataReferenceModified,
            annotation,
        };
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.ANNOTATION_MODIFIED, eventDetail);
        this.setViewportFrameRange(viewport, metadata);
    }
    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, current, current);
    }
    static getFrameRange(annotation) {
        const { metadata } = annotation;
        const { sliceIndex, multiSliceReference } = metadata;
        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;
        return rangeEndSliceIndex
            ? [sliceIndex + 1, rangeEndSliceIndex + 1]
            : sliceIndex + 1;
    }
    static getFrameRangeStr(annotation) {
        const range = this.getFrameRange(annotation);
        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);
    }
    static setViewportFrameRange(viewport, specifier) {
        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {
            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);
        }
    }
}


/***/ }),

/***/ 64485:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ annotationHydration),
/* harmony export */   x: () => (/* binding */ getClosestImageIdForStackViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);



function annotationHydration(viewport, toolName, worldPoints, options) {
    const viewReference = viewport.getViewReference();
    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;
    const annotation = {
        annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        data: {
            handles: {
                points: worldPoints,
            },
        },
        highlighted: false,
        autoGenerated: false,
        invalidated: false,
        isLocked: false,
        isVisible: true,
        metadata: {
            toolName,
            viewPlaneNormal,
            FrameOfReferenceUID,
            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),
            ...options,
        },
    };
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.addAnnotation)(annotation, viewport.element);
    return annotation;
}
function getReferencedImageId(viewport, worldPos, viewPlaneNormal) {
    let referencedImageId;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);
    }
    else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const targetId = getTargetId(viewport);
        const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    else {
        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');
    }
    return referencedImageId;
}
function getTargetId(viewport) {
    const targetId = viewport.getViewReferenceId?.();
    if (targetId) {
        return targetId;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        return `volumeId:${getTargetVolumeId(viewport)}`;
    }
    throw new Error('getTargetId: viewport must have a getTargetId method');
}
function getTargetVolumeId(viewport) {
    const actorEntries = viewport.getActors();
    if (!actorEntries) {
        return;
    }
    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;
}
function getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {
    const imageIds = viewport.getImageIds();
    if (!imageIds || !imageIds.length) {
        return;
    }
    const distanceImagePairs = imageIds.map((imageId) => {
        const { imagePositionPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('imagePlaneModule', imageId);
        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);
        return { imageId, distance };
    });
    distanceImagePairs.sort((a, b) => a.distance - b.distance);
    return distanceImagePairs[0].imageId;
}
function calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {
    const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.sub */ .eR.sub(dir, worldPos, ImagePositionPatient);
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.dot */ .eR.dot(dir, viewPlaneNormal);
    return Math.abs(dot);
}



/***/ }),

/***/ 76802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {
    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);
    if (sliceNormalIndex === -1) {
        throw new Error('3D bounding boxes not supported in an oblique plane');
    }
    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;
    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;
    return boundsIJK;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extend2DBoundingBoxInViewAxis);


/***/ }),

/***/ 87063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ getBoundingBoxAroundShapeWorld),
/* harmony export */   g: () => (/* binding */ getBoundingBoxAroundShapeIJK)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
function calculateBoundingBox(points, dimensions, isWorld = false) {
    let xMin = Infinity;
    let xMax = isWorld ? -Infinity : 0;
    let yMin = Infinity;
    let yMax = isWorld ? -Infinity : 0;
    let zMin = Infinity;
    let zMax = isWorld ? -Infinity : 0;
    const is3D = points[0]?.length === 3;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        xMin = Math.min(p[0], xMin);
        xMax = Math.max(p[0], xMax);
        yMin = Math.min(p[1], yMin);
        yMax = Math.max(p[1], yMax);
        if (is3D) {
            zMin = Math.min(p[2] ?? zMin, zMin);
            zMax = Math.max(p[2] ?? zMax, zMax);
        }
    }
    if (dimensions) {
        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
        if (is3D && dimensions.length === 3) {
            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
        }
    }
    else if (!isWorld) {
        xMin = Math.max(0, xMin);
        xMax = Math.min(Infinity, xMax);
        yMin = Math.max(0, yMin);
        yMax = Math.min(Infinity, yMax);
        if (is3D) {
            zMin = Math.max(0, zMin);
            zMax = Math.min(Infinity, zMax);
        }
    }
    return is3D
        ? [
            [xMin, xMax],
            [yMin, yMax],
            [zMin, zMax],
        ]
        : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
    return calculateBoundingBox(points, dimensions, false);
}
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
    return calculateBoundingBox(points, clipBounds, true);
}


/***/ }),

/***/ 72282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extend2DBoundingBoxInViewAxis: () => (/* reexport safe */ _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   getBoundingBoxAroundShape: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   getBoundingBoxAroundShapeIJK: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   getBoundingBoxAroundShapeWorld: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.C)
/* harmony export */ });
/* harmony import */ var _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76802);
/* harmony import */ var _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);





/***/ }),

/***/ 58271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ calibrateImageSpacing)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { calibratedPixelSpacingMetadataProvider } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {
    if (typeof calibrationOrScale === 'number') {
        calibrationOrScale = {
            type: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.CalibrationTypes.USER,
            scale: calibrationOrScale,
        };
    }
    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);
    const viewports = renderingEngine.getStackViewports();
    viewports.forEach((viewport) => {
        const imageIds = viewport.getImageIds();
        if (imageIds.includes(imageId)) {
            viewport.calibrateSpacing(imageId);
        }
    });
}


/***/ }),

/***/ 14655:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["CLIP_STOPPED"] = "CORNERSTONE_CINE_TOOL_STOPPED";
    Events["CLIP_STARTED"] = "CORNERSTONE_CINE_TOOL_STARTED";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 67108:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   addToolState: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_2__.Pi),
/* harmony export */   getToolState: () => (/* reexport safe */ _state__WEBPACK_IMPORTED_MODULE_2__.k6),
/* harmony export */   playClip: () => (/* reexport safe */ _playClip__WEBPACK_IMPORTED_MODULE_0__.n),
/* harmony export */   stopClip: () => (/* reexport safe */ _playClip__WEBPACK_IMPORTED_MODULE_0__.D)
/* harmony export */ });
/* harmony import */ var _playClip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53322);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14655);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36085);






/***/ }),

/***/ 53322:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ stopClip),
/* harmony export */   n: () => (/* binding */ playClip)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14655);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36085);




const { ViewportStatus } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.Enums;
const { triggerEvent } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const debounced = true;
const dynamicVolumesPlayingMap = new Map();
function playClip(element, playClipOptions) {
    let playClipTimeouts;
    let playClipIsTimeVarying;
    if (element === undefined) {
        throw new Error('playClip: element must not be undefined');
    }
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    if (!enabledElement) {
        throw new Error('playClip: element must be a valid Cornerstone enabled element');
    }
    if (!playClipOptions) {
        playClipOptions = {};
    }
    playClipOptions.dynamicCineEnabled =
        playClipOptions.dynamicCineEnabled ?? true;
    const { viewport } = enabledElement;
    const playClipContext = _createCinePlayContext(viewport, playClipOptions);
    let playClipData = (0,_state__WEBPACK_IMPORTED_MODULE_3__/* .getToolState */ .k6)(element);
    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;
    if (isDynamicCinePlaying) {
        _stopDynamicVolumeCine(element);
    }
    if (!playClipData) {
        playClipData = {
            intervalId: undefined,
            framesPerSecond: 30,
            lastFrameTimeStamp: undefined,
            ignoreFrameTimeVector: false,
            usingFrameTimeVector: false,
            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,
            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,
            reverse: playClipOptions.reverse ?? false,
            loop: playClipOptions.loop ?? true,
        };
        (0,_state__WEBPACK_IMPORTED_MODULE_3__/* .addToolState */ .Pi)(element, playClipData);
    }
    else {
        _stopClip(element, {
            stopDynamicCine: !isDynamicCinePlaying,
            viewportId: viewport.id,
        });
    }
    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;
    if (playClipOptions.framesPerSecond < 0 ||
        playClipOptions.framesPerSecond > 0) {
        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);
        playClipData.reverse = playClipData.framesPerSecond < 0;
        playClipData.ignoreFrameTimeVector = true;
    }
    if (playClipData.ignoreFrameTimeVector !== true &&
        playClipData.frameTimeVector &&
        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&
        playClipContext.frameTimeVectorEnabled) {
        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);
        playClipTimeouts = timeouts;
        playClipIsTimeVarying = isTimeVarying;
    }
    const playClipAction = () => {
        const { numScrollSteps, currentStepIndex } = playClipContext;
        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
        const newStepIndexOutOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;
        if (!playClipData.loop && newStepIndexOutOfRange) {
            _stopClip(element, {
                stopDynamicCine: !isDynamicCinePlaying,
                viewportId: viewport.id,
            });
            const eventDetail = { element };
            triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.CLIP_STOPPED, eventDetail);
            return;
        }
        if (newStepIndex >= numScrollSteps) {
            newStepIndex = 0;
        }
        else if (newStepIndex < 0) {
            newStepIndex = numScrollSteps - 1;
        }
        const delta = newStepIndex - currentStepIndex;
        if (delta) {
            try {
                playClipContext.scroll(delta);
            }
            catch (e) {
                console.warn('Play clip not scrolling', e);
                _stopClipWithData(playClipData);
                triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.CLIP_STOPPED, eventDetail);
                return;
            }
        }
    };
    if (isDynamicCinePlaying) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume) {
            dynamicVolumesPlayingMap.set(volume.volumeId, element);
        }
    }
    if (playClipContext.play) {
        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);
    }
    else if (playClipTimeouts &&
        playClipTimeouts.length > 0 &&
        playClipIsTimeVarying) {
        playClipData.usingFrameTimeVector = true;
        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {
            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);
            playClipAction();
        }, 0);
    }
    else {
        playClipData.usingFrameTimeVector = false;
        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));
    }
    const eventDetail = {
        element,
    };
    triggerEvent(element, _events__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.CLIP_STARTED, eventDetail);
}
function stopClip(element, options = {}) {
    _stopClip(element, {
        stopDynamicCine: true,
        ...options,
    });
}
function _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {
    const { stopDynamicCine, viewportId } = options;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    let toolState;
    const viewport = enabledElement?.viewport;
    if (!enabledElement) {
        if (viewportId) {
            toolState = (0,_state__WEBPACK_IMPORTED_MODULE_3__/* .getToolStateByViewportId */ .CS)(viewportId);
        }
        else {
            return;
        }
    }
    else {
        const { viewport } = enabledElement;
        toolState = (0,_state__WEBPACK_IMPORTED_MODULE_3__/* .getToolState */ .k6)(viewport.element);
    }
    if (toolState) {
        _stopClipWithData(toolState);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VideoViewport) {
        viewport.pause();
    }
    else if (stopDynamicCine && viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.BaseVolumeViewport) {
        _stopDynamicVolumeCine(element);
    }
}
function _stopDynamicVolumeCine(element) {
    const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume?.isDynamicVolume()) {
            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);
            dynamicVolumesPlayingMap.delete(volume.volumeId);
            if (dynamicCineElement && dynamicCineElement !== element) {
                stopClip(dynamicCineElement);
            }
        }
    }
}
function _getPlayClipTimeouts(vector, speed) {
    let i;
    let sample;
    let delay;
    let sum = 0;
    const limit = vector.length;
    const timeouts = [];
    let isTimeVarying = false;
    if (typeof speed !== 'number' || speed <= 0) {
        speed = 1;
    }
    for (i = 1; i < limit; i++) {
        delay = (Number(vector[i]) / speed) | 0;
        timeouts.push(delay);
        if (i === 1) {
            sample = delay;
        }
        else if (delay !== sample) {
            isTimeVarying = true;
        }
        sum += delay;
    }
    if (timeouts.length > 0) {
        if (isTimeVarying) {
            delay = (sum / timeouts.length) | 0;
        }
        else {
            delay = timeouts[0];
        }
        timeouts.push(delay);
    }
    return { timeouts, isTimeVarying };
}
function _stopClipWithData(playClipData) {
    const id = playClipData.intervalId;
    if (typeof id !== 'undefined') {
        playClipData.intervalId = undefined;
        if (playClipData.usingFrameTimeVector) {
            clearTimeout(id);
        }
        else {
            clearInterval(id);
        }
    }
}
function _getVolumeFromViewport(viewport) {
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport)) {
        return undefined;
    }
    const volumeIds = viewport.getAllVolumeIds();
    if (!volumeIds?.length) {
        return undefined;
    }
    const dynamicVolumeId = volumeIds.find((volumeId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId)?.isDynamicVolume());
    const volumeId = dynamicVolumeId ?? volumeIds[0];
    return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(volumeId);
}
function _createStackViewportCinePlayContext(viewport, waitForRendered) {
    const imageIds = viewport.getImageIds();
    return {
        get numScrollSteps() {
            return imageIds.length;
        },
        get currentStepIndex() {
            return viewport.getTargetImageIdIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta, debounceLoading: debounced });
        },
    };
}
function _createVideoViewportCinePlayContext(viewport, waitForRendered) {
    return {
        get numScrollSteps() {
            return viewport.getNumberOfSlices();
        },
        get currentStepIndex() {
            return viewport.getSliceIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta, debounceLoading: debounced });
        },
        play(fps) {
            if (fps) {
                viewport.setPlaybackRate(fps / 24);
            }
            viewport.play();
            return viewport.getFrameRate();
        },
    };
}
function _createVolumeViewportCinePlayContext(viewport, volume) {
    const { volumeId } = volume;
    const cachedScrollInfo = {
        viewPlaneNormal: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(),
        scrollInfo: null,
    };
    const getScrollInfo = () => {
        const camera = viewport.getCamera();
        const updateCache = !cachedScrollInfo.scrollInfo ||
            !gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.equals */ .eR.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);
        if (updateCache) {
            const scrollInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeViewportScrollInfo(viewport, volumeId);
            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;
            cachedScrollInfo.scrollInfo = scrollInfo;
        }
        return cachedScrollInfo.scrollInfo;
    };
    return {
        get numScrollSteps() {
            return getScrollInfo().numScrollSteps;
        },
        get currentStepIndex() {
            return getScrollInfo().currentStepIndex;
        },
        get frameTimeVectorEnabled() {
            const camera = viewport.getCamera();
            const volumeViewPlaneNormal = volume.direction
                .slice(6, 9)
                .map((x) => -x);
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);
            return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .glMatrix.equals */ .Fd.equals(dot, 1);
        },
        scroll(delta) {
            getScrollInfo().currentStepIndex += delta;
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.scroll(viewport, { delta });
        },
    };
}
function _createDynamicVolumeViewportCinePlayContext(volume) {
    return {
        get numScrollSteps() {
            return volume.numDimensionGroups;
        },
        get currentStepIndex() {
            return volume.dimensionGroupNumber - 1;
        },
        get frameTimeVectorEnabled() {
            return false;
        },
        scroll(delta) {
            volume.scroll(delta);
        },
    };
}
function _createCinePlayContext(viewport, playClipOptions) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.StackViewport) {
        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {
            return _createDynamicVolumeViewportCinePlayContext(volume);
        }
        return _createVolumeViewportCinePlayContext(viewport, volume);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VideoViewport) {
        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    throw new Error('Unknown viewport type');
}



/***/ }),

/***/ 36085:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CS: () => (/* binding */ getToolStateByViewportId),
/* harmony export */   Pi: () => (/* binding */ addToolState),
/* harmony export */   k6: () => (/* binding */ getToolState)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const state = {};
function addToolState(element, data) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    state[viewportId] = data;
}
function getToolState(element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId } = enabledElement;
    return state[viewportId];
}
function getToolStateByViewportId(viewportId) {
    return state[viewportId];
}



/***/ }),

/***/ 62854:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ areSameSegment)
/* harmony export */ });
function areSameSegment(firstAnnotation, secondAnnotation) {
    const { segmentation: firstSegmentation } = firstAnnotation.data;
    const { segmentation: secondSegmentation } = secondAnnotation.data;
    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&
        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);
}


/***/ }),

/***/ 64843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addContourSegmentationAnnotation: () => (/* reexport safe */ _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__.V),
/* harmony export */   areSameSegment: () => (/* reexport safe */ _areSameSegment__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   isContourSegmentationAnnotation: () => (/* reexport safe */ _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   removeContourSegmentationAnnotation: () => (/* reexport safe */ _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__.M)
/* harmony export */ });
/* harmony import */ var _areSameSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62854);
/* harmony import */ var _isContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78130);
/* harmony import */ var _addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85263);
/* harmony import */ var _removeContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37354);






/***/ }),

/***/ 78130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ isContourSegmentationAnnotation)
/* harmony export */ });
function isContourSegmentationAnnotation(annotation) {
    return !!annotation.data?.segmentation;
}


/***/ }),

/***/ 37354:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ removeContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function removeContourSegmentationAnnotation(annotation) {
    if (!annotation.data.segmentation) {
        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');
    }
    const { segmentationId, segmentIndex } = annotation.data.segmentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};
    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);
    if (!annotationsUIDsSet) {
        return;
    }
    annotationsUIDsSet.delete(annotation.annotationUID);
    if (!annotationsUIDsSet.size) {
        annotationUIDsMap.delete(segmentIndex);
    }
}


/***/ }),

/***/ 93843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function calculatePerimeter(polyline, closed) {
    let perimeter = 0;
    for (let i = 0; i < polyline.length - 1; i++) {
        const point1 = polyline[i];
        const point2 = polyline[i + 1];
        perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));
    }
    if (closed) {
        const firstPoint = polyline[0];
        const lastPoint = polyline[polyline.length - 1];
        perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) +
            Math.pow(lastPoint[1] - firstPoint[1], 2));
    }
    return perimeter;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calculatePerimeter);


/***/ }),

/***/ 46228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports findContours, findContoursFromReducedSet */
function findNextLink(line, lines, contourPoints) {
    let index = -1;
    lines.forEach((cell, i) => {
        if (index >= 0) {
            return;
        }
        if (cell.a == line.b) {
            index = i;
        }
    });
    if (index >= 0) {
        const nextLine = lines[index];
        lines.splice(index, 1);
        contourPoints.push(nextLine.b);
        if (contourPoints[0] == nextLine.b) {
            return {
                remainingLines: lines,
                contourPoints,
                type: 'CLOSED_PLANAR',
            };
        }
        return findNextLink(nextLine, lines, contourPoints);
    }
    return {
        remainingLines: lines,
        contourPoints,
        type: 'OPEN_PLANAR',
    };
}
function findContours(lines) {
    if (lines.length == 0) {
        return [];
    }
    const contourPoints = [];
    const firstCell = lines.shift();
    contourPoints.push(firstCell.a);
    contourPoints.push(firstCell.b);
    const result = findNextLink(firstCell, lines, contourPoints);
    if (result.remainingLines.length == 0) {
        return [
            {
                type: result.type,
                contourPoints: result.contourPoints,
            },
        ];
    }
    else {
        const extraContours = findContours(result.remainingLines);
        extraContours.push({
            type: result.type,
            contourPoints: result.contourPoints,
        });
        return extraContours;
    }
}
function findContoursFromReducedSet(lines) {
    return findContours(lines);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    findContours,
    findContoursFromReducedSet,
});


/***/ }),

/***/ 98013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findHandlePolylineIndex)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function findHandlePolylineIndex(annotation, handleIndex) {
    const { polyline } = annotation.data.contour;
    const { points } = annotation.data.handles;
    const { length } = points;
    if (handleIndex === length) {
        return polyline.length;
    }
    if (handleIndex < 0) {
        handleIndex = (handleIndex + length) % length;
    }
    if (handleIndex === 0) {
        return 0;
    }
    const handle = points[handleIndex];
    const index = polyline.findIndex((point) => isEqual(handle, point));
    if (index !== -1) {
        return index;
    }
    let closestDistance = Infinity;
    return polyline.reduce((closestIndex, point, testIndex) => {
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.squaredDistance */ .eR.squaredDistance(point, handle);
        if (distance < closestDistance) {
            closestDistance = distance;
            return testIndex;
        }
        return closestIndex;
    }, -1);
}


/***/ }),

/***/ 15451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getContourHolesDataCanvas)
/* harmony export */ });
/* harmony import */ var _getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55659);

function getContourHolesDataCanvas(annotation, viewport) {
    const worldHoleContours = (0,_getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotation);
    const canvasHoleContours = [];
    worldHoleContours.forEach((worldHoleContour) => {
        const numPoints = worldHoleContour.length;
        const canvasHoleContour = new Array(numPoints);
        for (let i = 0; i < numPoints; i++) {
            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);
        }
        canvasHoleContours.push(canvasHoleContour);
    });
    return canvasHoleContours;
}


/***/ }),

/***/ 55659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getContourHolesDataWorld)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82056);

function getContourHolesDataWorld(annotation) {
    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];
    return childAnnotationUIDs.map((uid) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotation)(uid).data.contour.polyline);
}


/***/ }),

/***/ 37546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ getDeduplicatedVTKPolyDataPoints)
/* harmony export */ });
function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {
    const points = polyData.getPoints();
    const lines = polyData.getLines();
    const pointsArray = new Array(points.getNumberOfPoints())
        .fill(0)
        .map((_, i) => points.getPoint(i).slice());
    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {
        const cell = lines.getCell(i * 3).slice();
        return { a: cell[0], b: cell[1] };
    });
    if (bypass) {
        return { points: pointsArray, lines: linesArray };
    }
    const newPoints = [];
    for (const [i, pt] of pointsArray.entries()) {
        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);
        if (index >= 0) {
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = index;
                }
                if (line.b === i) {
                    line.b = index;
                }
                return line;
            });
        }
        else {
            const newIndex = newPoints.length;
            newPoints.push(pt);
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = newIndex;
                }
                if (line.b === i) {
                    line.b = newIndex;
                }
                return line;
            });
        }
    }
    const newLines = linesArray.filter((line) => line.a !== line.b);
    return { points: newPoints, lines: newLines };
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({ getDeduplicatedVTKPolyDataPoints });


/***/ }),

/***/ 54889:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationToPointData: () => (/* reexport */ contours_AnnotationToPointData),
  acceptAutogeneratedInterpolations: () => (/* reexport */ acceptAutogeneratedInterpolations),
  areCoplanarContours: () => (/* reexport */ areCoplanarContours),
  calculatePerimeter: () => (/* reexport */ calculatePerimeter/* default */.A),
  contourFinder: () => (/* reexport */ contourFinder/* default */.Ay),
  detectContourHoles: () => (/* reexport */ detectContourHoles),
  findHandlePolylineIndex: () => (/* reexport */ findHandlePolylineIndex/* default */.A),
  generateContourSetsFromLabelmap: () => (/* reexport */ generateContourSetsFromLabelmap),
  getContourHolesDataCanvas: () => (/* reexport */ getContourHolesDataCanvas/* default */.A),
  getContourHolesDataWorld: () => (/* reexport */ getContourHolesDataWorld/* default */.A),
  getDeduplicatedVTKPolyDataPoints: () => (/* reexport */ getDeduplicatedVTKPolyDataPoints/* getDeduplicatedVTKPolyDataPoints */.v),
  updateContourPolyline: () => (/* reexport */ updateContourPolyline/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js

function areCoplanarContours(firstAnnotation, secondAnnotation) {
    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;
    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;
    const dot = esm/* vec3.dot */.eR.dot(firstViewPlaneNormal, secondViewPlaneNormal);
    const parallelPlanes = esm/* glMatrix.equals */.Fd.equals(1, Math.abs(dot));
    if (!parallelPlanes) {
        return false;
    }
    const { polyline: firstPolyline } = firstAnnotation.data.contour;
    const { polyline: secondPolyline } = secondAnnotation.data.contour;
    const firstDistance = esm/* vec3.dot */.eR.dot(firstViewPlaneNormal, firstPolyline[0]);
    const secondDistance = esm/* vec3.dot */.eR.dot(firstViewPlaneNormal, secondPolyline[0]);
    return esm/* glMatrix.equals */.Fd.equals(firstDistance, secondDistance);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js
var contourFinder = __webpack_require__(46228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js
var getDeduplicatedVTKPolyDataPoints = __webpack_require__(37546);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js
const getIsPointInsidePolygon = (point, vertices) => {
    const x = point[0];
    const y = point[1];
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i][0], yi = vertices[i][1];
        const xj = vertices[j][0], yj = vertices[j][1];
        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
        if (intersect) {
            inside = !inside;
        }
    }
    return inside;
};
function checkEnclosed(outerContour, innerContour, points) {
    const vertices = [];
    outerContour.contourPoints.forEach((point) => {
        vertices.push([points[point][0], points[point][1]]);
    });
    let pointsNotEnclosed = 0;
    innerContour.contourPoints.forEach((point) => {
        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);
        if (!result) {
            pointsNotEnclosed++;
        }
    });
    return pointsNotEnclosed === 0;
}
function processContourHoles(contours, points, useXOR = true) {
    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');
    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');
    const contourWithHoles = [];
    let contourWithoutHoles = [];
    closedContours.forEach((contour, index) => {
        const holes = [];
        closedContours.forEach((hContour, hIndex) => {
            if (index != hIndex) {
                if (checkEnclosed(contour, hContour, points)) {
                    holes.push(hIndex);
                }
            }
        });
        if (holes.length > 0) {
            contourWithHoles.push({
                contour,
                holes,
            });
        }
        else {
            contourWithoutHoles.push(index);
        }
    });
    if (useXOR) {
        contourWithHoles.forEach((contourHoleSet) => {
            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';
            retContours.push(contourHoleSet.contour);
            contourHoleSet.holes.forEach((holeIndex) => {
                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';
                retContours.push(closedContours[holeIndex]);
                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {
                    return contourIndex !== holeIndex;
                });
            });
        });
        contourWithoutHoles.forEach((contourIndex) => {
            retContours.push(closedContours[contourIndex]);
        });
    }
    else {
    }
    return retContours;
}
/* harmony default export */ const detectContourHoles = ({ processContourHoles });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var dist_esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js
var registerComputeWorker = __webpack_require__(44460);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js
var utilsForWorker = __webpack_require__(54285);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js
var getOrCreateSegmentationVolume = __webpack_require__(30722);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js






const { Labelmap } = SegmentationRepresentations/* default */.A;
async function generateContourSetsFromLabelmap({ segmentations }) {
    (0,registerComputeWorker/* registerComputeWorker */.D)();
    (0,utilsForWorker/* triggerWorkerProgress */.sg)(enums.WorkerTypes.GENERATE_CONTOUR_SETS, 0);
    const { representationData, segments = [0, 1], segmentationId, } = segmentations;
    let { volumeId: segVolumeId } = representationData[Labelmap];
    if (!segVolumeId) {
        const segVolume = (0,getOrCreateSegmentationVolume/* default */.A)(segmentationId);
        if (segVolume) {
            segVolumeId = segVolume.volumeId;
        }
    }
    const vol = dist_esm.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    const voxelManager = vol.voxelManager;
    const segScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segScalarData,
        dimensions: vol.dimensions,
        spacing: vol.imageData.getSpacing(),
        origin: vol.imageData.getOrigin(),
        direction: vol.imageData.getDirection(),
    };
    const indices = Array.isArray(segments)
        ? segments
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment)
        : Object.values(segments)
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment);
    const contourSets = await (0,dist_esm.getWebWorkerManager)().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {
        segmentation: segmentationInfo,
        indices,
        mode: 'individual',
    });
    const refImages = vol.imageIds.map((imageId) => {
        const refImageId = dist_esm.cache.getImage(imageId)?.referencedImageId;
        return refImageId ? dist_esm.cache.getImage(refImageId) : undefined;
    });
    const refImageDataMetadata = refImages.map((image) => {
        return dist_esm.utilities.getImageDataMetadata(image);
    });
    const processedContourSets = contourSets
        .map((contourSet) => {
        const segment = segments[contourSet.segment.segmentIndex] || {};
        if (!contourSet.sliceContours.length) {
            return null;
        }
        const p1 = contourSet.sliceContours[0].polyData.points[0];
        let refImageId;
        if (p1) {
            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {
                const { scanAxisNormal, origin } = imageDataMetadata;
                const plane = dist_esm.utilities.planar.planeEquation(scanAxisNormal, origin);
                return dist_esm.utilities.planar.isPointOnPlane(p1, plane);
            });
            if (refImageIndex !== -1) {
                refImageId = refImages[refImageIndex].imageId;
            }
        }
        return {
            label: segment.label,
            color: segment.color,
            metadata: {
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            },
            sliceContours: contourSet.sliceContours.map((contourData) => ({
                contours: contourData.contours,
                polyData: contourData.polyData,
                FrameNumber: contourData.sliceIndex + 1,
                sliceIndex: contourData.sliceIndex,
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            })),
        };
    })
        .filter((contourSet) => contourSet !== null);
    (0,utilsForWorker/* triggerWorkerProgress */.sg)(enums.WorkerTypes.GENERATE_CONTOUR_SETS, 100);
    return processedContourSets;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js
var RectangleROIStartEndThreshold = __webpack_require__(109);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js

function validateAnnotation(annotation) {
    if (!annotation?.data) {
        throw new Error('Tool data is empty');
    }
    if (!annotation.metadata || annotation.metadata.referencedImageId) {
        throw new Error('Tool data is not associated with any imageId');
    }
}
class AnnotationToPointData {
    static { this.TOOL_NAMES = {}; }
    constructor() {
    }
    static convert(annotation, index, metadataProvider) {
        validateAnnotation(annotation);
        const { toolName } = annotation.metadata;
        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];
        if (!toolClass) {
            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);
        }
        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);
        const color = [
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
        ];
        return {
            ReferencedROINumber: index + 1,
            ROIDisplayColor: color,
            ContourSequence,
        };
    }
    static register(toolClass) {
        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;
    }
}
AnnotationToPointData.register(RectangleROIStartEndThreshold/* default */.A);
/* harmony default export */ const contours_AnnotationToPointData = (AnnotationToPointData);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js
var getContourHolesDataWorld = __webpack_require__(55659);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js
var getContourHolesDataCanvas = __webpack_require__(15451);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js
var updateContourPolyline = __webpack_require__(72967);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js
var InterpolationManager = __webpack_require__(27740);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js

function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {
    InterpolationManager/* default */.A.acceptAutoGenerated(annotationGroupSelector, selector);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js
var findHandlePolylineIndex = __webpack_require__(98013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js
var calculatePerimeter = __webpack_require__(93843);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js















/***/ }),

/***/ 72967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ updateContourPolyline)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95527);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



function updateContourPolyline(annotation, polylineData, transforms, options) {
    const { canvasToWorld, worldToCanvas } = transforms;
    const { data } = annotation;
    const { targetWindingDirection } = polylineData;
    let { points: polyline } = polylineData;
    let windingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    if (options?.decimate?.enabled) {
        polyline = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.decimate(polylineData.points, options?.decimate?.epsilon);
    }
    let { closed } = polylineData;
    const numPoints = polyline.length;
    const polylineWorldPoints = new Array(numPoints);
    const currentPolylineWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    const parentAnnotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getParentAnnotation)(annotation);
    if (closed === undefined) {
        let currentClosedState = false;
        if (polyline.length > 3) {
            const lastToFirstDist = _math__WEBPACK_IMPORTED_MODULE_1__.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);
            currentClosedState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(0, lastToFirstDist);
        }
        closed = currentClosedState;
    }
    if (options?.updateWindingDirection !== false) {
        let updatedWindingDirection = parentAnnotation
            ? parentAnnotation.data.contour.windingDirection * -1
            : targetWindingDirection;
        if (updatedWindingDirection === undefined) {
            updatedWindingDirection = windingDirection;
        }
        if (updatedWindingDirection !== windingDirection) {
            polyline.reverse();
        }
        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);
        if (handlePoints.length > 2) {
            const currentHandlesWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(handlePoints);
            if (currentHandlesWindingDirection !== updatedWindingDirection) {
                data.handles.points.reverse();
            }
        }
        windingDirection = updatedWindingDirection;
    }
    for (let i = 0; i < numPoints; i++) {
        polylineWorldPoints[i] = canvasToWorld(polyline[i]);
    }
    data.contour.polyline = polylineWorldPoints;
    data.contour.closed = closed;
    data.contour.windingDirection = windingDirection;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.invalidateAnnotation)(annotation);
}


/***/ }),

/***/ 473:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextBoxCoordsCanvas: () => (/* reexport safe */ _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1239);




/***/ }),

/***/ 94593:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ generateImageFromTimeData),
/* harmony export */   H: () => (/* binding */ updateVolumeFromTimeData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function sumOverDimensionGroups(voxelManager, dimensionGroups) {
    const arrayLength = voxelManager.getScalarDataLength();
    const resultArray = new Float32Array(arrayLength);
    for (const dimensionGroupNumber of dimensionGroups) {
        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);
        for (let i = 0; i < arrayLength; i++) {
            resultArray[i] += scalarData[i];
        }
    }
    return resultArray;
}
function averageOverDimensionGroups(voxelManager, dimensionGroups) {
    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
    const numDimensionGroups = dimensionGroups.length;
    for (let i = 0; i < sumArray.length; i++) {
        sumArray[i] /= numDimensionGroups;
    }
    return sumArray;
}
const operationFunctions = {
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {
        if (dimensionGroups.length !== 2) {
            throw new Error('Please provide only 2 dimension groups for subtraction.');
        }
        const arrayLength = voxelManager.getScalarDataLength();
        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);
        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);
        for (let i = 0; i < arrayLength; i++) {
            const difference = scalarData1[i] - scalarData2[i];
            callback(i, difference);
        }
    },
};
function generateImageFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers } = options;
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const arrayLength = voxelManager.getScalarDataLength();
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    const resultArray = new Float32Array(arrayLength);
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        resultArray[index] = value;
    });
    return resultArray;
}
function updateVolumeFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;
    if (!targetVolume) {
        throw new Error('A target volume must be provided');
    }
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const targetVoxelManager = targetVolume.voxelManager;
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        targetVoxelManager.setAtIndex(index, value);
    });
    targetVoxelManager.resetModifiedSlices();
    for (let k = 0; k < targetVolume.dimensions[2]; k++) {
        targetVoxelManager.modifiedSlices.add(k);
    }
}



/***/ }),

/***/ 41362:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _segmentation_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64063);


function getDataInTime(dynamicVolume, options) {
    let dataInTime;
    const dimensionGroups = options.dimensionGroupNumbers ||
        options.frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (options.frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    if (!options.maskVolumeId && !options.worldCoordinate) {
        throw new Error('You should provide either maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId && options.worldCoordinate) {
        throw new Error('You can only use one of maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId) {
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(options.maskVolumeId);
        if (!segmentationVolume) {
            throw new Error('Segmentation volume not found');
        }
        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);
        return [dataInTime, ijkCoords];
    }
    if (options.worldCoordinate) {
        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);
        return dataInTime;
    }
    return dataInTime;
}
function _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {
    const { dimensions, imageData } = volume;
    const index = imageData.worldToIndex(coordinate);
    index[0] = Math.floor(index[0]);
    index[1] = Math.floor(index[1]);
    index[2] = Math.floor(index[2]);
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.indexWithinDimensions(index, dimensions)) {
        throw new Error('outside bounds');
    }
    const yMultiple = dimensions[0];
    const zMultiple = dimensions[0] * dimensions[1];
    const value = [];
    dimensionGroups.forEach((dimensionGroupNumber) => {
        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];
        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));
    });
    return value;
}
function _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {
    const { imageData: maskImageData } = segmentationVolume;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    const nonZeroVoxelIndices = [];
    nonZeroVoxelIndices.length = scalarDataLength;
    let actualLen = 0;
    for (let i = 0, len = scalarDataLength; i < len; i++) {
        if (segVoxelManager.getAtIndex(i) !== 0) {
            nonZeroVoxelIndices[actualLen++] = i;
        }
    }
    nonZeroVoxelIndices.length = actualLen;
    const nonZeroVoxelValuesInTime = [];
    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&
        JSON.stringify(dynamicVolume.spacing) ===
            JSON.stringify(segmentationVolume.spacing);
    const ijkCoords = [];
    if (isSameVolume) {
        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {
            const valuesInTime = [];
            const index = nonZeroVoxelIndices[i];
            for (let j = 0; j < dimensionGroups.length; j++) {
                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));
            }
            nonZeroVoxelValuesInTime.push(valuesInTime);
            ijkCoords.push(segVoxelManager.toIJK(index));
        }
        return [nonZeroVoxelValuesInTime, ijkCoords];
    }
    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {
        if (segValue === 0) {
            return;
        }
        const overlapIJKMinMax = (0,_segmentation_utilities__WEBPACK_IMPORTED_MODULE_1__/* .getVoxelOverlap */ .Q5)(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);
        let count = 0;
        const perDimensionGroupSum = new Map();
        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));
        const averageCallback = ({ index }) => {
            for (let i = 0; i < dimensionGroups.length; i++) {
                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);
                const dimensionGroupNumber = dimensionGroups[i];
                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);
            }
            count++;
        };
        dynamicVolume.voxelManager.forEach(averageCallback, {
            imageData: dynamicVolume.imageData,
            boundsIJK: overlapIJKMinMax,
        });
        const averageValues = [];
        perDimensionGroupSum.forEach((sum) => {
            averageValues.push(sum / count);
        });
        ijkCoords.push(segPointIJK);
        nonZeroVoxelValuesInTime.push(averageValues);
    };
    segmentationVolume.voxelManager.forEach(callback, {
        imageData: maskImageData,
    });
    return [nonZeroVoxelValuesInTime, ijkCoords];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getDataInTime);


/***/ }),

/***/ 83052:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateImageFromTimeData: () => (/* reexport safe */ _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__.G),
/* harmony export */   getDataInTime: () => (/* reexport safe */ _getDataInTime__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   updateVolumeFromTimeData: () => (/* reexport safe */ _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__.H)
/* harmony export */ });
/* harmony import */ var _getDataInTime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41362);
/* harmony import */ var _generateImageFromTimeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94593);






/***/ }),

/***/ 41293:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ getAnnotationNearPoint),
/* harmony export */   s: () => (/* binding */ getAnnotationNearPointOnEnabledElement)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77609);



function getAnnotationNearPoint(element, canvasPoint, proximity = 5) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    if (!enabledElement) {
        throw new Error('getAnnotationNearPoint: enabledElement not found');
    }
    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);
}
function getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupForViewport(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const { _toolInstances: tools } = toolGroup;
    for (const name in tools) {
        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);
        if (found) {
            return found;
        }
    }
    return null;
}
function findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {
    const { viewport } = enabledElement;
    const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__.getAnnotations)(tool.constructor.toolName, viewport?.element);
    const currentId = viewport?.getCurrentImageId?.();
    if (annotations?.length) {
        const { element } = enabledElement.viewport;
        for (const annotation of annotations) {
            const referencedImageId = annotation.metadata?.referencedImageId;
            if ((currentId && referencedImageId && currentId !== referencedImageId) ||
                !tool.isPointNearTool) {
                continue;
            }
            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||
                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {
                return annotation;
            }
        }
    }
    return null;
}



/***/ }),

/***/ 4096:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CQ: () => (/* binding */ getCalibratedAspect),
/* harmony export */   Op: () => (/* binding */ getCalibratedLengthUnitsAndScale),
/* harmony export */   Xw: () => (/* binding */ getCalibratedProbeUnitsAndValue)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { CalibrationTypes } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
const PIXEL_UNITS = 'px';
const VOXEL_UNITS = 'voxels';
const SUPPORTED_REGION_DATA_TYPES = [
    1,
    2,
    3,
    4,
];
const SUPPORTED_LENGTH_VARIANT = [
    '3,3',
    '4,7',
];
const SUPPORTED_PROBE_VARIANT = [
    '4,3',
    '4,7',
];
const UNIT_MAPPING = {
    0: 'px',
    1: 'percent',
    2: 'dB',
    3: 'cm',
    4: 'seconds',
    5: 'hertz',
    6: 'dB/seconds',
    7: 'cm/sec',
    8: 'cm\xb2',
    9: 'cm\xb2/s',
    0xc: 'degrees',
};
const EPS = 1e-3;
const SQUARE = '\xb2';
const getCalibratedLengthUnitsAndScale = (image, handles) => {
    const { calibration, hasPixelSpacing } = image;
    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;
    const volumeUnit = hasPixelSpacing ? 'mm\xb3' : VOXEL_UNITS;
    let areaUnit = unit + SQUARE;
    let scale = 1;
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { unit, areaUnit, scale, volumeUnit };
    }
    if (calibration.type === CalibrationTypes.UNCALIBRATED) {
        return {
            unit: PIXEL_UNITS,
            areaUnit: PIXEL_UNITS + SQUARE,
            scale,
            volumeUnit: VOXEL_UNITS,
        };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        let imageIndex1, imageIndex2;
        if (Array.isArray(handles) && handles.length === 2) {
            [imageIndex1, imageIndex2] = handles;
        }
        else if (typeof handles === 'function') {
            const points = handles();
            imageIndex1 = points[0];
            imageIndex2 = points[1];
        }
        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&
            imageIndex1[0] <= region.regionLocationMaxX1 &&
            imageIndex1[1] >= region.regionLocationMinY0 &&
            imageIndex1[1] <= region.regionLocationMaxY1 &&
            imageIndex2[0] >= region.regionLocationMinX0 &&
            imageIndex2[0] <= region.regionLocationMaxX1 &&
            imageIndex2[1] >= region.regionLocationMinY0 &&
            imageIndex2[1] <= region.regionLocationMaxY1);
        if (!regions?.length) {
            return { unit, areaUnit, scale, volumeUnit };
        }
        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!regions.length) {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
        const region = regions[0];
        const physicalDeltaX = Math.abs(region.physicalDeltaX);
        const physicalDeltaY = Math.abs(region.physicalDeltaY);
        const isSamePhysicalDelta = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);
        if (isSamePhysicalDelta) {
            scale = 1 / physicalDeltaX;
            calibrationType = 'US Region';
            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';
            areaUnit = unit + SQUARE;
        }
        else {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
    }
    else if (calibration.scale) {
        scale = calibration.scale;
    }
    const types = [
        CalibrationTypes.ERMF,
        CalibrationTypes.USER,
        CalibrationTypes.ERROR,
        CalibrationTypes.PROJECTION,
        CalibrationTypes.CALIBRATED,
        CalibrationTypes.UNKNOWN,
    ];
    if (types.includes(calibration?.type)) {
        calibrationType = calibration.type;
    }
    return {
        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),
        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),
        scale,
        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),
    };
};
const getCalibratedProbeUnitsAndValue = (image, handles) => {
    const [imageIndex] = handles;
    const { calibration } = image;
    let units = ['raw'];
    let values = [null];
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { units, values };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!supportedRegionsMetadata?.length) {
            return { units, values };
        }
        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&
            imageIndex[0] <= region.regionLocationMaxX1 &&
            imageIndex[1] >= region.regionLocationMinY0 &&
            imageIndex[1] <= region.regionLocationMaxY1);
        if (!region) {
            return { units, values };
        }
        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;
        const { physicalDeltaX, physicalDeltaY } = region;
        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *
            physicalDeltaY;
        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *
            physicalDeltaX;
        calibrationType = 'US Region';
        values = [xValue, yValue];
        units = [
            UNIT_MAPPING[region.physicalUnitsXDirection],
            UNIT_MAPPING[region.physicalUnitsYDirection],
        ];
    }
    return {
        units,
        values,
        calibrationType,
    };
};
const getCalibratedAspect = (image) => image.calibration?.aspect || 1;



/***/ }),

/***/ 40634:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ getPixelValueUnitsImageId),
/* harmony export */   j: () => (/* binding */ getPixelValueUnits)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getPixelValueUnitsImageId(imageId, options) {
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);
}
function getPixelValueUnits(modality, imageId, options) {
    if (modality === 'CT') {
        return 'HU';
    }
    else if (modality === 'PT') {
        return _handlePTModality(imageId, options);
    }
    else {
        return '';
    }
}
function _handlePTModality(imageId, options) {
    if (!options.isPreScaled) {
        return 'raw';
    }
    if (options.isSuvScaled) {
        return 'SUV';
    }
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    if (generalSeriesModule?.modality === 'PT') {
        const petSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('petSeriesModule', imageId);
        return petSeriesModule?.units || 'unitless';
    }
    return 'unknown';
}



/***/ }),

/***/ 4296:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSphereBoundsInfo),
/* harmony export */   l: () => (/* binding */ getSphereBoundsInfoFromViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72282);



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(bottom, top) / 2;
    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
        topLeftWorld: topLeftWorld,
        bottomRightWorld: bottomRightWorld,
    };
}
function getSphereBoundsInfo(circlePoints, imageData) {
    const direction = imageData.getDirection();
    const rowCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[0], direction[1], direction[2]);
    const columnCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[3], direction[4], direction[5]);
    const scanAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[6], direction[7], direction[8]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), scanAxis);
    const directionVectors = {
        row: rowCosine,
        column: columnCosine,
        normal: viewPlaneNormal,
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {
    if (!viewport) {
        throw new Error('viewport is required in order to calculate the sphere bounds');
    }
    const camera = viewport.getCamera();
    const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
    const directionVectors = {
        row: viewRight,
        normal: viewPlaneNormal,
        column: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), viewUp),
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {
    const dimensions = imageData.getDimensions();
    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;
    const topLeftWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    const bottomRightWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);
    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);
    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));
    const boundsIJK = (0,_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);
    return { boundsIJK, topLeftWorld, bottomRightWorld };
}



/***/ }),

/***/ 15295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getViewportsForAnnotation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function getViewportsForAnnotation(annotation) {
    const { metadata } = annotation;
    return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElements)()
        .filter((enabledElement) => {
        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
            const viewport = enabledElement.viewport;
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&
                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));
        }
        return;
    })
        .map((enabledElement) => enabledElement.viewport);
}


/***/ }),

/***/ 53860:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotationMultiSlice: () => (/* reexport safe */ _AnnotationMultiSlice__WEBPACK_IMPORTED_MODULE_12__.A),
/* harmony export */   IslandRemoval: () => (/* reexport safe */ _segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_35__.A),
/* harmony export */   annotationHydration: () => (/* reexport safe */ _annotationHydration__WEBPACK_IMPORTED_MODULE_14__.i),
/* harmony export */   boundingBox: () => (/* reexport module object */ _boundingBox__WEBPACK_IMPORTED_MODULE_23__),
/* harmony export */   calibrateImageSpacing: () => (/* reexport safe */ _calibrateImageSpacing__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   cine: () => (/* reexport module object */ _cine__WEBPACK_IMPORTED_MODULE_22__),
/* harmony export */   contourSegmentation: () => (/* reexport module object */ _contourSegmentation__WEBPACK_IMPORTED_MODULE_32__),
/* harmony export */   contours: () => (/* reexport module object */ _contours__WEBPACK_IMPORTED_MODULE_15__),
/* harmony export */   debounce: () => (/* reexport safe */ _debounce__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   drawing: () => (/* reexport module object */ _drawing__WEBPACK_IMPORTED_MODULE_17__),
/* harmony export */   dynamicVolume: () => (/* reexport module object */ _dynamicVolume__WEBPACK_IMPORTED_MODULE_29__),
/* harmony export */   geometricSurfaceUtils: () => (/* reexport module object */ _geometricSurfaceUtils__WEBPACK_IMPORTED_MODULE_37__),
/* harmony export */   getAnnotationNearPoint: () => (/* reexport safe */ _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__.S),
/* harmony export */   getAnnotationNearPointOnEnabledElement: () => (/* reexport safe */ _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__.s),
/* harmony export */   getCalibratedAspect: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.CQ),
/* harmony export */   getCalibratedLengthUnitsAndScale: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.Op),
/* harmony export */   getCalibratedProbeUnitsAndValue: () => (/* reexport safe */ _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__.Xw),
/* harmony export */   getClosestImageIdForStackViewport: () => (/* reexport safe */ _annotationHydration__WEBPACK_IMPORTED_MODULE_14__.x),
/* harmony export */   getOrCreateImageVolume: () => (/* reexport safe */ _segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_40__.A),
/* harmony export */   getPixelValueUnits: () => (/* reexport safe */ _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__.j),
/* harmony export */   getPixelValueUnitsImageId: () => (/* reexport safe */ _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__.N),
/* harmony export */   getSphereBoundsInfo: () => (/* reexport safe */ _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_10__.R),
/* harmony export */   getViewportForAnnotation: () => (/* reexport safe */ _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   isObject: () => (/* reexport safe */ _isObject__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   math: () => (/* reexport module object */ _math__WEBPACK_IMPORTED_MODULE_18__),
/* harmony export */   moveAnnotationToViewPlane: () => (/* reexport safe */ _moveAnnotationToViewPlane__WEBPACK_IMPORTED_MODULE_39__.T),
/* harmony export */   normalizeViewportPlane: () => (/* reexport safe */ _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_34__.A),
/* harmony export */   orientation: () => (/* reexport module object */ _orientation__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   planar: () => (/* reexport module object */ _planar__WEBPACK_IMPORTED_MODULE_19__),
/* harmony export */   planarFreehandROITool: () => (/* reexport module object */ _planarFreehandROITool__WEBPACK_IMPORTED_MODULE_24__),
/* harmony export */   pointInSurroundingSphereCallback: () => (/* reexport safe */ _pointInSurroundingSphereCallback__WEBPACK_IMPORTED_MODULE_33__.i),
/* harmony export */   pointToString: () => (/* reexport safe */ _pointToString__WEBPACK_IMPORTED_MODULE_11__.l),
/* harmony export */   polyDataUtils: () => (/* reexport module object */ _polyData_utils__WEBPACK_IMPORTED_MODULE_30__),
/* harmony export */   rectangleROITool: () => (/* reexport module object */ _rectangleROITool__WEBPACK_IMPORTED_MODULE_25__),
/* harmony export */   roundNumber: () => (/* binding */ roundNumber),
/* harmony export */   segmentation: () => (/* reexport module object */ _segmentation__WEBPACK_IMPORTED_MODULE_16__),
/* harmony export */   setAnnotationLabel: () => (/* reexport safe */ _setAnnotationLabel__WEBPACK_IMPORTED_MODULE_38__.A),
/* harmony export */   stackContextPrefetch: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__.N),
/* harmony export */   stackPrefetch: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__.S),
/* harmony export */   throttle: () => (/* reexport safe */ _throttle__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   touch: () => (/* reexport module object */ _touch__WEBPACK_IMPORTED_MODULE_28__),
/* harmony export */   triggerAnnotationRender: () => (/* reexport safe */ _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_9__.A),
/* harmony export */   triggerAnnotationRenderForToolGroupIds: () => (/* reexport safe */ _triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_8__.A),
/* harmony export */   triggerAnnotationRenderForViewportIds: () => (/* reexport safe */ _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__.A),
/* harmony export */   triggerEvent: () => (/* reexport safe */ _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent),
/* harmony export */   viewport: () => (/* reexport module object */ _viewport__WEBPACK_IMPORTED_MODULE_27__),
/* harmony export */   viewportFilters: () => (/* reexport module object */ _viewportFilters__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   voi: () => (/* reexport module object */ _voi__WEBPACK_IMPORTED_MODULE_31__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _getAnnotationNearPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41293);
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52905);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45217);
/* harmony import */ var _calibrateImageSpacing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58271);
/* harmony import */ var _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4096);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58640);
/* harmony import */ var _triggerAnnotationRenderForToolGroupIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(94779);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56069);
/* harmony import */ var _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4296);
/* harmony import */ var _pointToString__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(38726);
/* harmony import */ var _AnnotationMultiSlice__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(16678);
/* harmony import */ var _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(40133);
/* harmony import */ var _annotationHydration__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(64485);
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(54889);
/* harmony import */ var _segmentation__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(93759);
/* harmony import */ var _drawing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(473);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(95527);
/* harmony import */ var _planar__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(13165);
/* harmony import */ var _viewportFilters__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(60810);
/* harmony import */ var _orientation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(90141);
/* harmony import */ var _cine__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(67108);
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(72282);
/* harmony import */ var _planarFreehandROITool__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(55002);
/* harmony import */ var _rectangleROITool__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(74866);
/* harmony import */ var _stackPrefetch__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(71132);
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(19027);
/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(76260);
/* harmony import */ var _dynamicVolume__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(83052);
/* harmony import */ var _polyData_utils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(32994);
/* harmony import */ var _voi__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(97213);
/* harmony import */ var _contourSegmentation__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(64843);
/* harmony import */ var _pointInSurroundingSphereCallback__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(10261);
/* harmony import */ var _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(27963);
/* harmony import */ var _segmentation_islandRemoval__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(67912);
/* harmony import */ var _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(40634);
/* harmony import */ var _geometricSurfaceUtils__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(5565);
/* harmony import */ var _setAnnotationLabel__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(1355);
/* harmony import */ var _moveAnnotationToViewPlane__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(79646);
/* harmony import */ var _segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(83075);


































const roundNumber = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber;










/***/ }),

/***/ 95527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* reexport module object */ _basic__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   aabb: () => (/* reexport module object */ _aabb__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   angle: () => (/* reexport module object */ _angle__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   circle: () => (/* reexport module object */ _circle__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   ellipse: () => (/* reexport module object */ _ellipse__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   lineSegment: () => (/* reexport module object */ _line__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   point: () => (/* reexport module object */ _point__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   polyline: () => (/* reexport module object */ _polyline__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   rectangle: () => (/* reexport module object */ _rectangle__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   vec2: () => (/* reexport module object */ _vec2__WEBPACK_IMPORTED_MODULE_8__)
/* harmony export */ });
/* harmony import */ var _aabb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88638);
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73262);
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77081);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11683);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15305);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82216);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(92984);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(33657);
/* harmony import */ var _vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(23324);
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(83923);













/***/ }),

/***/ 92984:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addCanvasPointsToArray: () => (/* reexport safe */ _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__.A),
/* harmony export */   containsPoint: () => (/* reexport safe */ _containsPoint__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   containsPoints: () => (/* reexport safe */ _containsPoints__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   decimate: () => (/* reexport safe */ _decimate__WEBPACK_IMPORTED_MODULE_11__.A),
/* harmony export */   getAABB: () => (/* reexport safe */ _getAABB__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   getArea: () => (/* reexport safe */ _getArea__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   getClosestLineSegmentIntersection: () => (/* reexport safe */ _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__.A),
/* harmony export */   getFirstLineSegmentIntersectionIndexes: () => (/* reexport safe */ _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__.A),
/* harmony export */   getLineSegmentIntersectionsCoordinates: () => (/* reexport safe */ _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__.A),
/* harmony export */   getLineSegmentIntersectionsIndexes: () => (/* reexport safe */ _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   getNormal2: () => (/* reexport safe */ _getNormal2__WEBPACK_IMPORTED_MODULE_8__.A),
/* harmony export */   getNormal3: () => (/* reexport safe */ _getNormal3__WEBPACK_IMPORTED_MODULE_7__.A),
/* harmony export */   getSignedArea: () => (/* reexport safe */ _getSignedArea__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   getSubPixelSpacingAndXYDirections: () => (/* reexport safe */ _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__.A),
/* harmony export */   getWindingDirection: () => (/* reexport safe */ _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   intersectPolyline: () => (/* reexport safe */ _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__.A),
/* harmony export */   isClosed: () => (/* reexport safe */ _isClosed__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   isPointInsidePolyline3D: () => (/* reexport safe */ _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__.i),
/* harmony export */   mergePolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.S),
/* harmony export */   pointCanProjectOnLine: () => (/* reexport safe */ _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__.A),
/* harmony export */   pointsAreWithinCloseContourProximity: () => (/* reexport safe */ _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__.A),
/* harmony export */   projectTo2D: () => (/* reexport safe */ _projectTo2D__WEBPACK_IMPORTED_MODULE_21__.p),
/* harmony export */   subtractPolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.Y)
/* harmony export */ });
/* harmony import */ var _isClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19246);
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46513);
/* harmony import */ var _containsPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42436);
/* harmony import */ var _getAABB__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98122);
/* harmony import */ var _getArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86909);
/* harmony import */ var _getSignedArea__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63113);
/* harmony import */ var _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4239);
/* harmony import */ var _getNormal3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43490);
/* harmony import */ var _getNormal2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(11377);
/* harmony import */ var _combinePolyline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(68385);
/* harmony import */ var _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(405);
/* harmony import */ var _decimate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99944);
/* harmony import */ var _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(4338);
/* harmony import */ var _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(37135);
/* harmony import */ var _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(50932);
/* harmony import */ var _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(32979);
/* harmony import */ var _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(61785);
/* harmony import */ var _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82265);
/* harmony import */ var _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(97792);
/* harmony import */ var _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(80514);
/* harmony import */ var _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(8361);
/* harmony import */ var _projectTo2D__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(28502);

























/***/ }),

/***/ 90554:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findClosestPoint)
/* harmony export */ });
function findClosestPoint(sourcePoints, targetPoint) {
    let minPoint = [0, 0];
    let minDistance = Number.MAX_SAFE_INTEGER;
    sourcePoints.forEach(function (sourcePoint) {
        const distance = _distanceBetween(targetPoint, sourcePoint);
        if (distance < minDistance) {
            minDistance = distance;
            minPoint = [...sourcePoint];
        }
    });
    return minPoint;
}
function _distanceBetween(p1, p2) {
    const [x1, y1] = p1;
    const [x2, y2] = p2;
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}


/***/ }),

/***/ 79646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ moveAnnotationToViewPlane)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9175);


function moveAnnotationToViewPlane(annotation, viewport) {
    const { data } = annotation;
    const { points } = data.handles;
    const { focalPoint, viewPlaneNormal } = viewport.getCamera();
    const projectedDistance = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.dot(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.sub(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.create(), points[0], focalPoint), viewPlaneNormal);
    points.forEach((point) => {
        gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.add(point, point, gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.scale(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_1__.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));
    });
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        annotation.metadata.referencedImageId = viewport.getCurrentImageId();
    }
    return annotation;
}


/***/ }),

/***/ 27963:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ normalizeViewportPlane)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const acquisitionMapping = {
    toIJK: (ijkPrime) => ijkPrime,
    fromIJK: (ijk) => ijk,
    type: 'acquistion',
};
const jkMapping = {
    toIJK: ([j, k, i]) => [i, j, k],
    fromIJK: ([i, j, k]) => [j, k, i],
    type: 'jk',
};
const ikMapping = {
    toIJK: ([i, k, j]) => [i, j, k],
    fromIJK: ([i, j, k]) => [i, k, j],
    type: 'ik',
};
function normalizeViewportPlane(viewport, boundsIJK) {
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport)) {
        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };
    }
    const { viewPlaneNormal } = viewport.getCamera();
    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);
    if (!mapping) {
        return {
            toIJK: null,
            boundsIJKPrime: null,
            fromIJK: null,
            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,
        };
    }
    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };
}


/***/ }),

/***/ 7193:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getOrientationStringLPS)
/* harmony export */ });
function getOrientationStringLPS(vector) {
    let orientation = '';
    const orientationX = vector[0] < 0 ? 'R' : 'L';
    const orientationY = vector[1] < 0 ? 'A' : 'P';
    const orientationZ = vector[2] < 0 ? 'F' : 'H';
    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];
    const MIN = 0.0001;
    for (let i = 0; i < 3; i++) {
        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {
            orientation += orientationX;
            abs[0] = 0;
        }
        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {
            orientation += orientationY;
            abs[1] = 0;
        }
        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {
            orientation += orientationZ;
            abs[2] = 0;
        }
        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {
            orientation += orientationX + orientationY;
            abs[0] = 0;
            abs[1] = 0;
        }
        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {
            orientation += orientationX + orientationZ;
            abs[0] = 0;
            abs[2] = 0;
        }
        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {
            orientation += orientationY + orientationZ;
            abs[1] = 0;
            abs[2] = 0;
        }
        else {
            break;
        }
    }
    return orientation;
}


/***/ }),

/***/ 90141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getOrientationStringLPS: () => (/* reexport safe */ _getOrientationStringLPS__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   invertOrientationStringLPS: () => (/* reexport safe */ _invertOrientationStringLPS__WEBPACK_IMPORTED_MODULE_1__.A)
/* harmony export */ });
/* harmony import */ var _getOrientationStringLPS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7193);
/* harmony import */ var _invertOrientationStringLPS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80405);





/***/ }),

/***/ 80405:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ invertOrientationStringLPS)
/* harmony export */ });
function invertOrientationStringLPS(orientationString) {
    let inverted = orientationString.replace('H', 'f');
    inverted = inverted.replace('F', 'h');
    inverted = inverted.replace('R', 'l');
    inverted = inverted.replace('L', 'r');
    inverted = inverted.replace('A', 'p');
    inverted = inverted.replace('P', 'a');
    inverted = inverted.toUpperCase();
    return inverted;
}


/***/ }),

/***/ 55002:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   smoothAnnotation: () => (/* reexport safe */ _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61587);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    smoothAnnotation: _smoothAnnotation__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
});



/***/ }),

/***/ 10261:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ pointInSurroundingSphereCallback)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _math_sphere__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62783);
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72282);




const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {
    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);
    const sphereObj = {
        center: centerWorld,
        radius: radiusWorld,
    };
    const dimensions = imageData.getDimensions();
    const voxelManager = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
        dimensions: dimensions,
        scalarData: imageData.getPointData().getScalars().getData(),
    });
    voxelManager.forEach(callback, {
        boundsIJK,
        isInObject: (pointLPS) => (0,_math_sphere__WEBPACK_IMPORTED_MODULE_2__/* .pointInSphere */ .d)(sphereObj, pointLPS),
        imageData,
    });
}
function _getBounds(circlePoints, imageData, viewport) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(bottom, top) / 2;
    let boundsIJK;
    if (!viewport) {
        const centerIJK = transformWorldToIndex(imageData, centerWorld);
        const spacings = imageData.getSpacing();
        const minSpacing = Math.min(...spacings);
        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);
        boundsIJK = [
            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],
            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],
            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],
        ];
        return {
            boundsIJK,
            centerWorld: centerWorld,
            radiusWorld,
        };
    }
    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
    };
}
function _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {
    const [bottom, top] = circlePoints;
    const dimensions = imageData.getDimensions();
    const camera = viewport.getCamera();
    const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
    const topLeftWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    const bottomRightWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);
    const sphereCornersIJK = [
        transformWorldToIndex(imageData, topLeftWorld),
        (transformWorldToIndex(imageData, bottomRightWorld)),
    ];
    const boundsIJK = (0,_boundingBox__WEBPACK_IMPORTED_MODULE_3__.getBoundingBoxAroundShape)(sphereCornersIJK, dimensions);
    return boundsIJK;
}


/***/ }),

/***/ 38726:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ pointToString)
/* harmony export */ });
function pointToString(point, decimals = 5) {
    return (parseFloat(point[0]).toFixed(decimals) +
        ',' +
        parseFloat(point[1]).toFixed(decimals) +
        ',' +
        parseFloat(point[2]).toFixed(decimals) +
        ',');
}


/***/ }),

/***/ 32994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPoint: () => (/* binding */ getPoint),
/* harmony export */   getPolyDataPointIndexes: () => (/* binding */ getPolyDataPointIndexes),
/* harmony export */   getPolyDataPoints: () => (/* binding */ getPolyDataPoints)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function getPoint(points, idx) {
    const idx3 = idx * 3;
    if (idx3 < points.length) {
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);
    }
}
function getPolyDataPointIndexes(polyData) {
    const linesData = polyData.getLines().getData();
    let idx = 0;
    const lineSegments = new Map();
    while (idx < linesData.length) {
        const segmentSize = linesData[idx++];
        const segment = [];
        for (let i = 0; i < segmentSize; i++) {
            segment.push(linesData[idx + i]);
        }
        lineSegments.set(segment[0], segment);
        idx += segmentSize;
    }
    const contours = [];
    const findStartingPoint = (map) => {
        for (const [key, value] of map.entries()) {
            if (value !== undefined) {
                return key;
            }
        }
        return -1;
    };
    let startPoint = findStartingPoint(lineSegments);
    while (startPoint !== -1) {
        const contour = [startPoint];
        while (lineSegments.has(startPoint)) {
            const nextPoint = lineSegments.get(startPoint)[1];
            if (lineSegments.has(nextPoint)) {
                contour.push(nextPoint);
            }
            lineSegments.delete(startPoint);
            startPoint = nextPoint;
        }
        contours.push(contour);
        startPoint = findStartingPoint(lineSegments);
    }
    return contours.length ? contours : undefined;
}
function getPolyDataPoints(polyData) {
    const contoursIndexes = getPolyDataPointIndexes(polyData);
    if (!contoursIndexes) {
        return;
    }
    const rawPointsData = polyData.getPoints().getData();
    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));
}


/***/ }),

/***/ 37162:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);
/* harmony import */ var _boundingBox_extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76802);



function getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {
    const AllBoundsIJK = [];
    annotations.forEach((annotation) => {
        const { data } = annotation;
        const { points } = data.handles;
        const { imageData, dimensions } = referenceVolume;
        let pointsToUse = points;
        if (data.cachedStats?.projectionPoints) {
            const { projectionPoints } = data.cachedStats;
            pointsToUse = [].concat(...projectionPoints);
        }
        const rectangleCornersIJK = pointsToUse.map((world) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, world));
        let boundsIJK = (0,_boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__/* .getBoundingBoxAroundShapeIJK */ .g)(rectangleCornersIJK, dimensions);
        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {
            boundsIJK = (0,_boundingBox_extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(boundsIJK, options.numSlicesToProject);
        }
        AllBoundsIJK.push(boundsIJK);
    });
    if (AllBoundsIJK.length === 1) {
        return AllBoundsIJK[0];
    }
    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {
        return {
            iMin: Math.min(accumulator.iMin, currentValue.iMin),
            jMin: Math.min(accumulator.jMin, currentValue.jMin),
            kMin: Math.min(accumulator.kMin, currentValue.kMin),
            iMax: Math.max(accumulator.iMax, currentValue.iMax),
            jMax: Math.max(accumulator.jMax, currentValue.jMax),
            kMax: Math.max(accumulator.kMax, currentValue.kMax),
        };
    }, {
        iMin: Infinity,
        jMin: Infinity,
        kMin: Infinity,
        iMax: -Infinity,
        jMax: -Infinity,
        kMax: -Infinity,
    });
    return boundsIJK;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getBoundsIJKFromRectangleAnnotations);


/***/ }),

/***/ 74866:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBoundsIJKFromRectangleAnnotations: () => (/* reexport safe */ _getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   isAxisAlignedRectangle: () => (/* reexport safe */ _isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_1__.l)
/* harmony export */ });
/* harmony import */ var _getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37162);
/* harmony import */ var _isAxisAlignedRectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26384);





/***/ }),

/***/ 44460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ registerComputeWorker)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36625);


let registered = false;
function registerComputeWorker() {
    if (registered) {
        return;
    }
    registered = true;
    const workerFn = () => {
        return new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(3694), __webpack_require__.b), {
            name: 'compute',
            type: undefined,
        });
    };
    const workerManager = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)();
    const config = (0,_config__WEBPACK_IMPORTED_MODULE_1__/* .getConfig */ .zj)();
    const computeWorkerConfig = config.computeWorker;
    const options = {
        maxWorkerInstances: 1,
        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {
            enabled: true,
            idleTimeThreshold: 2000,
        },
    };
    workerManager.registerWorker('compute', workerFn, options);
}


/***/ }),

/***/ 27740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ InterpolationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47807);
/* harmony import */ var _contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51893);
/* harmony import */ var _contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73816);
/* harmony import */ var _deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56229);
/* harmony import */ var _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75183);
/* harmony import */ var _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40133);
/* harmony import */ var _contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85263);








const { uuidv4 } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const ChangeTypesForInterpolation = [
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.HandlesUpdated,
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.InterpolationUpdated,
];
class InterpolationManager {
    static { this.toolNames = []; }
    static addTool(toolName) {
        if (!this.toolNames.includes(toolName)) {
            this.toolNames.push(toolName);
        }
    }
    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {
        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;
        for (const toolName of toolNames || InterpolationManager.toolNames) {
            const annotations = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.getAnnotations(toolName, annotationGroupSelector);
            if (!annotations?.length) {
                continue;
            }
            for (const annotation of annotations) {
                const { interpolationUID, data, autoGenerated, metadata } = annotation;
                if (interpolationUID) {
                    annotation.interpolationCompleted = true;
                }
                if (!autoGenerated) {
                    continue;
                }
                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
                    continue;
                }
                if (sliceIndex !== undefined &&
                    metadata &&
                    sliceIndex !== metadata.sliceIndex) {
                    continue;
                }
                if (segmentationId &&
                    segmentationId !== data.segmentation.segmentationId) {
                    continue;
                }
                (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__/* .addContourSegmentationAnnotation */ .V)(annotation);
                annotation.autoGenerated = false;
            }
        }
    }
    static { this.handleAnnotationCompleted = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn('Unable to find viewport for', annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        const hasInterpolationUID = !!annotation.interpolationUID;
        annotation.autoGenerated = false;
        if (hasInterpolationUID) {
            (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportData);
            (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
            return;
        }
        const filterData = [
            {
                key: 'segmentIndex',
                value: annotation.data.segmentation.segmentIndex,
                parentKey: (annotation) => annotation.data.segmentation,
            },
            {
                key: 'viewPlaneNormal',
                value: annotation.metadata.viewPlaneNormal,
                parentKey: (annotation) => annotation.metadata,
            },
            {
                key: 'viewUp',
                value: annotation.metadata.viewUp,
                parentKey: (annotation) => annotation.metadata,
            },
        ];
        let interpolationAnnotations = (0,_contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewportData, filterData);
        const { sliceIndex } = annotation.metadata;
        const skipUIDs = new Set();
        interpolationAnnotations.forEach((interpolationAnnotation) => {
            if (interpolationAnnotation.interpolationCompleted ||
                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {
                const { interpolationUID } = interpolationAnnotation;
                skipUIDs.add(interpolationUID);
            }
        });
        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));
        annotation.interpolationUID =
            interpolationAnnotations[0]?.interpolationUID || uuidv4();
        viewportData.interpolationUID = annotation.interpolationUID;
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
    }; }
    static { this.handleAnnotationUpdate = (evt) => {
        const annotation = evt.detail.annotation;
        const { changeType = _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.HandlesUpdated } = evt.detail;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if ((!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) ||
            !ChangeTypesForInterpolation.includes(changeType)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn('Unable to find matching viewport for annotation interpolation', annotation);
            return;
        }
        if (annotation.autoGenerated) {
            (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__/* .addContourSegmentationAnnotation */ .V)(annotation);
            annotation.autoGenerated = false;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
            isInterpolationUpdate: changeType === _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.InterpolationUpdated,
        };
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
    }; }
    static { this.handleAnnotationDelete = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn("No viewport, can't delete interpolated results", annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        annotation.autoGenerated = false;
        (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportData);
    }; }
}
function getSliceData(viewport) {
    const sliceData = {
        numberOfSlices: viewport.getNumberOfSlices(),
        imageIndex: viewport.getCurrentImageIdIndex(),
    };
    return sliceData;
}


/***/ }),

/***/ 13179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ SegmentStatsCalculator)
/* harmony export */ });
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68915);

class SegmentStatsCalculator {
    static { this.calculators = new Map(); }
    static { this.indices = []; }
    static { this.mode = 'collective'; }
    static statsInit(options) {
        const { storePointData, indices, mode } = options;
        this.mode = mode;
        this.indices = indices;
        this.calculators.clear();
        if (this.mode === 'individual') {
            indices.forEach((index) => {
                this.calculators.set(index, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceVolumetricCalculator */ .C3({ storePointData }));
            });
        }
        else {
            this.calculators.set(indices, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceVolumetricCalculator */ .C3({ storePointData }));
        }
    }
    static statsCallback(data) {
        const { segmentIndex, ...statsData } = data;
        if (!segmentIndex) {
            throw new Error('Segment index is required for stats calculation');
        }
        const calculator = this.mode === 'individual'
            ? this.calculators.get(segmentIndex)
            : this.calculators.get(this.indices);
        if (!calculator) {
            throw new Error(`No calculator found for segment ${segmentIndex}`);
        }
        calculator.statsCallback(statsData);
    }
    static getStatistics(options) {
        if (this.mode === 'individual') {
            const result = {};
            this.calculators.forEach((calculator, segmentIndex) => {
                result[segmentIndex] = calculator.getStatistics(options);
            });
            return result;
        }
        const calculator = this.calculators.get(this.indices);
        return calculator.getStatistics(options);
    }
}


/***/ }),

/***/ 68915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   C3: () => (/* binding */ InstanceVolumetricCalculator)
/* harmony export */ });
/* unused harmony export VolumetricCalculator */
/* harmony import */ var _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69013);
/* harmony import */ var _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4096);


const TEST_MAX_LOCATIONS = 10;
function createVolumetricState() {
    return {
        maxIJKs: [],
    };
}
function volumetricStatsCallback(state, data) {
    const { value } = data;
    const { maxIJKs } = state;
    const length = maxIJKs.length;
    if (typeof value !== 'number' ||
        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {
        return;
    }
    const dataCopy = {
        value: data.value,
        pointLPS: data.pointLPS
            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]
            : undefined,
        pointIJK: data.pointIJK
            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]
            : undefined,
    };
    if (!length || value >= maxIJKs[length - 1].value) {
        maxIJKs.push(dataCopy);
    }
    else {
        for (let i = 0; i < length; i++) {
            if (value <= maxIJKs[i].value) {
                maxIJKs.splice(i, 0, dataCopy);
                break;
            }
        }
    }
    if (length >= TEST_MAX_LOCATIONS) {
        maxIJKs.splice(0, 1);
    }
}
function volumetricGetStatistics(state, stats, options) {
    const { spacing, calibration } = options;
    const { volumeUnit } = (0,_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__/* .getCalibratedLengthUnitsAndScale */ .Op)({
        calibration,
        hasPixelSpacing: true,
    }, []);
    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] * 1000 : 1;
    stats.volume = {
        value: Array.isArray(stats.count.value)
            ? stats.count.value.map((v) => v * volumeScale)
            : stats.count.value * volumeScale,
        unit: volumeUnit,
        name: 'volume',
        label: 'Volume',
    };
    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);
    stats.array.push(stats.volume);
    state.maxIJKs = [];
    return stats;
}
class VolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__/* .BasicStatsCalculator */ .O {
    static { this.volumetricState = createVolumetricState(); }
    static statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    static statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    static getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
class InstanceVolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceBasicStatsCalculator */ .B {
    constructor(options) {
        super(options);
        this.volumetricState = createVolumetricState();
    }
    statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumetricCalculator);


/***/ }),

/***/ 17014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getBrushSizeForToolGroup),
/* harmony export */   M: () => (/* binding */ setBrushSizeForToolGroup)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14957);




function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__/* .getBrushToolInstances */ .n)(toolGroupId, toolName);
    brushBasedToolInstances.forEach((tool) => {
        tool.configuration.brushSize = brushSize;
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const { renderingEngineId } = viewportsInfoArray[0];
    const viewportIds = toolGroup.getViewportIds();
    const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__.getRenderingEngine)(renderingEngineId);
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewportIds);
}
function getBrushSizeForToolGroup(toolGroupId, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__/* .getBrushToolInstances */ .n)(toolGroupId, toolName);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.brushSize;
}


/***/ }),

/***/ 49492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ setBrushThresholdForToolGroup),
/* harmony export */   Q: () => (/* binding */ getBrushThresholdForToolGroup)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14957);



function setBrushThresholdForToolGroup(toolGroupId, threshold) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__/* .getBrushToolInstances */ .n)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        const activeStrategy = tool.configuration.activeStrategy;
        if (!activeStrategy.toLowerCase().includes('threshold')) {
            return;
        }
        tool.configuration = {
            ...tool.configuration,
            threshold: {
                ...tool.configuration.threshold,
                ...threshold,
            },
        };
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    if (!viewportsInfo.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewportIds);
}
function getBrushThresholdForToolGroup(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__/* .getBrushToolInstances */ .n)(toolGroupId);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.threshold.range;
}


/***/ }),

/***/ 88274:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ computeMetabolicStats)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js
var utilsForWorker = __webpack_require__(54285);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js
var registerComputeWorker = __webpack_require__(44460);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js
var createMergedLabelmapForIndex = __webpack_require__(4334);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js
var getOrCreateSegmentationVolume = __webpack_require__(30722);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js
var getOrCreateImageVolume = __webpack_require__(83075);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js



function getReferenceVolumeForSegmentation(segmentationId) {
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationId);
    if (!segmentation) {
        return null;
    }
    let referenceImageIds;
    const labelmap = segmentation.representationData.Labelmap;
    if ('imageIds' in labelmap) {
        const { imageIds } = labelmap;
        const firstImage = esm.cache.getImage(imageIds[0]);
        const volumeInfo = esm.cache.getVolumeContainingImageId(firstImage.referencedImageId);
        if (volumeInfo?.volume) {
            return volumeInfo.volume;
        }
        referenceImageIds = imageIds.map((imageId) => esm.cache.getImage(imageId).referencedImageId);
    }
    else if ('volumeId' in labelmap) {
        const { volumeId, referencedVolumeId } = labelmap;
        if (referencedVolumeId) {
            const refVolume = esm.cache.getVolume(referencedVolumeId);
            if (refVolume) {
                return refVolume;
            }
        }
        const segVolume = esm.cache.getVolume(volumeId);
        if (segVolume) {
            referenceImageIds = segVolume.imageIds.map((imageId) => esm.cache.getImage(imageId).referencedImageId);
        }
    }
    return (0,getOrCreateImageVolume/* default */.A)(referenceImageIds);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js








async function computeMetabolicStats({ segmentationIds, segmentIndex, }) {
    (0,registerComputeWorker/* registerComputeWorker */.D)();
    (0,utilsForWorker/* triggerWorkerProgress */.sg)(enums.WorkerTypes.COMPUTE_STATISTICS, 0);
    const segmentation = (0,getSegmentation/* getSegmentation */.T)(segmentationIds[0]);
    const { imageIds: segImageIds } = segmentation.representationData
        .Labelmap;
    const isValidVolume = esm.utilities.isValidVolume(segImageIds);
    if (!isValidVolume) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const stats = await calculateForVolume({
        segmentationIds,
        segmentIndex,
    });
    return stats;
}
async function calculateForVolume({ segmentationIds, segmentIndex }) {
    const labelmapVolumes = segmentationIds.map((id) => {
        return (0,getOrCreateSegmentationVolume/* default */.A)(id);
    });
    const mergedLabelmap = (0,createMergedLabelmapForIndex/* default */.A)(labelmapVolumes, segmentIndex);
    if (!mergedLabelmap) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;
    const spacing = imageData.getSpacing();
    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions,
        spacing,
        origin,
        direction,
    };
    const referenceVolume = getReferenceVolumeForSegmentation(segmentationIds[0]);
    const imageInfo = {
        dimensions: referenceVolume.dimensions,
        spacing: referenceVolume.spacing,
        origin: referenceVolume.origin,
        direction: referenceVolume.direction,
        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),
    };
    if (imageInfo.scalarData.length === 0 ||
        segmentationInfo.scalarData.length === 0) {
        return {
            [segmentIndex]: {
                name: 'TMTV',
                value: 0,
            },
        };
    }
    const stats = await (0,esm.getWebWorkerManager)().executeTask('compute', 'computeMetabolicStats', {
        segmentationInfo,
        imageInfo,
    });
    (0,utilsForWorker/* triggerWorkerProgress */.sg)(enums.WorkerTypes.COMPUTE_STATISTICS, 100);
    return stats;
}



/***/ }),

/***/ 13276:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ contourAndFindLargestBidirectional)
/* harmony export */ });
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54889);
/* harmony import */ var _findLargestBidirectional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60199);
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30722);



async function contourAndFindLargestBidirectional(segmentation) {
    const contours = await (0,_contours__WEBPACK_IMPORTED_MODULE_0__.generateContourSetsFromLabelmap)({
        segmentations: segmentation,
    });
    if (!contours?.length || !contours[0].sliceContours.length) {
        return;
    }
    const { segments = [
        null,
        { label: 'Unspecified', color: null, containedSegmentIndices: null },
    ], } = segmentation;
    const vol = (0,_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(segmentation.segmentationId);
    if (!vol) {
        return;
    }
    const segmentIndex = segments.findIndex((it) => !!it);
    if (segmentIndex === -1) {
        return;
    }
    segments[segmentIndex].segmentIndex = segmentIndex;
    return (0,_findLargestBidirectional__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(contours[0], vol.volumeId, segments[segmentIndex]);
}


/***/ }),

/***/ 14514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createBidirectionalToolData)
/* harmony export */ });
function createBidirectionalToolData(bidirectionalData, viewport) {
    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;
    const [major0, major1] = majorAxis;
    const [minor0, minor1] = minorAxis;
    const points = [major0, major1, minor0, minor1];
    const bidirectionalToolData = {
        highlighted: true,
        invalidated: true,
        metadata: {
            toolName: 'Bidirectional',
            ...viewport.getViewReference({ sliceIndex }),
        },
        data: {
            handles: {
                points,
                textBox: {
                    hasMoved: false,
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
                activeHandleIndex: null,
            },
            label,
            cachedStats: {},
        },
        isLocked: false,
        isVisible: true,
    };
    return bidirectionalToolData;
}


/***/ }),

/***/ 2397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLabelmapMemo: () => (/* binding */ createLabelmapMemo),
/* harmony export */   createRleMemo: () => (/* binding */ createRleMemo),
/* harmony export */   restoreMemo: () => (/* binding */ restoreMemo)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94021);



const { VoxelManager, RLEVoxelMap } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function createLabelmapMemo(segmentationId, segmentationVoxelManager) {
    return createRleMemo(segmentationId, segmentationVoxelManager);
}
function restoreMemo(isUndo) {
    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;
    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;
    useVoxelManager.forEach(({ value, pointIJK }) => {
        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);
    });
    const slices = useVoxelManager.getArrayOfModifiedSlices();
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(this.segmentationId, slices);
}
function createRleMemo(segmentationId, segmentationVoxelManager) {
    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    const state = {
        segmentationId,
        restoreMemo,
        commitMemo,
        segmentationVoxelManager,
        voxelManager,
        id: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        operationType: 'labelmap',
    };
    return state;
}
function commitMemo() {
    if (this.redoVoxelManager) {
        return true;
    }
    if (!this.voxelManager.modifiedSlices.size) {
        return false;
    }
    const { segmentationVoxelManager } = this;
    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);
    for (const key of this.voxelManager.modifiedSlices.keys()) {
        undoVoxelManager.modifiedSlices.add(key);
    }
    this.undoVoxelManager = undoVoxelManager;
    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({
        dimensions: this.segmentationVoxelManager.dimensions,
    });
    this.redoVoxelManager = redoVoxelManager;
    undoVoxelManager.forEach(({ index, pointIJK, value }) => {
        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);
        if (currentValue === value) {
            return;
        }
        redoVoxelManager.setAtIndex(index, currentValue);
    });
    return true;
}


/***/ }),

/***/ 97492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createLabelmapVolumeForViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

async function createLabelmapVolumeForViewport(input) {
    const { viewportId, renderingEngineId, options } = input;
    let { segmentationId } = input;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
    if (!enabledElement) {
        throw new Error('element disabled');
    }
    const { viewport } = enabledElement;
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport)) {
        throw new Error('Segmentation only supports VolumeViewport');
    }
    const { uid } = viewport.getDefaultActor();
    if (segmentationId === undefined) {
        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4().slice(0, 8)}`;
    }
    if (options) {
        const properties = structuredClone(options);
        await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createLocalVolume(segmentationId, properties);
    }
    else {
        const volumeId = viewport.getVolumeId();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {
            volumeId: segmentationId,
        });
    }
    return segmentationId;
}


/***/ }),

/***/ 4334:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {
    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {
        if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(dimensions, labelmaps[0].dimensions) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(direction, labelmaps[0].direction) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(spacing, labelmaps[0].spacing) ||
            !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(origin, labelmaps[0].origin)) {
            throw new Error('labelmaps must have the same size and shape');
        }
    });
    const labelmap = labelmaps[0];
    const arrayType = labelmap.voxelManager.getConstructor();
    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());
    labelmaps.forEach((labelmap) => {
        const voxelManager = labelmap.voxelManager;
        const scalarDataLength = voxelManager.getScalarDataLength();
        for (let i = 0; i < scalarDataLength; i++) {
            if (voxelManager.getAtIndex(i) === segmentIndex) {
                outputData[i] = segmentIndex;
            }
        }
    });
    const options = {
        scalarData: outputData,
        metadata: labelmap.metadata,
        spacing: labelmap.spacing,
        origin: labelmap.origin,
        direction: labelmap.direction,
        dimensions: labelmap.dimensions,
    };
    const cachedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    let mergedVolume;
    if (cachedVolume) {
        mergedVolume = cachedVolume;
        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);
    }
    else {
        mergedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createLocalVolume(volumeId, options);
    }
    return mergedVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMergedLabelmapForIndex);


/***/ }),

/***/ 60199:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findLargestBidirectional)
/* harmony export */ });
/* unused harmony export createBidirectionalForSlice */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _isLineInSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82594);


const EPSILON = 1e-2;
function findLargestBidirectional(contours, segVolumeId, segment) {
    const { sliceContours } = contours;
    const { segmentIndex, containedSegmentIndices } = segment;
    let maxBidirectional;
    const isInSegment = (0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__/* .createIsInSegment */ .Hs)(segVolumeId, segmentIndex, containedSegmentIndices);
    for (const sliceContour of sliceContours) {
        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);
        if (!bidirectional) {
            continue;
        }
        maxBidirectional = bidirectional;
    }
    if (maxBidirectional) {
        Object.assign(maxBidirectional, segment);
    }
    return maxBidirectional;
}
function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {
    const { points } = sliceContour.polyData;
    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;
    let maxMajor = currentMaxMajor * currentMaxMajor;
    let maxMinor = currentMaxMinor * currentMaxMinor;
    let maxMajorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sqrDist */ .eR.sqrDist(point1, point2);
            if (distance2 < maxMajor) {
                continue;
            }
            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!(0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__/* .isLineInSegment */ .pW)(point1, point2, isInSegment)) {
                continue;
            }
            maxMajor = distance2 - EPSILON;
            maxMajorPoints = [index1, index2];
            maxMinor = 0;
        }
    }
    if (!maxMajorPoints) {
        return;
    }
    maxMajor = Math.sqrt(maxMajor + EPSILON);
    const handle0 = points[maxMajorPoints[0]];
    const handle1 = points[maxMajorPoints[1]];
    const unitMajor = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), handle0, handle1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(unitMajor, unitMajor, 1 / maxMajor);
    let maxMinorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sqrDist */ .eR.sqrDist(point1, point2);
            if (distance2 <= maxMinor) {
                continue;
            }
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), point1, point2);
            const dot = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(delta, unitMajor)) / Math.sqrt(distance2);
            if (dot > EPSILON) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!(0,_isLineInSegment__WEBPACK_IMPORTED_MODULE_1__/* .isLineInSegment */ .pW)(point1, point2, isInSegment)) {
                continue;
            }
            maxMinor = distance2;
            maxMinorPoints = [index1, index2];
        }
    }
    if (!maxMinorPoints) {
        return;
    }
    maxMinor = Math.sqrt(maxMinor);
    const handle2 = points[maxMinorPoints[0]];
    const handle3 = points[maxMinorPoints[1]];
    const bidirectional = {
        majorAxis: [handle0, handle1],
        minorAxis: [handle2, handle3],
        maxMajor,
        maxMinor,
        ...sliceContour,
    };
    return bidirectional;
}


/***/ }),

/***/ 84882:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function floodFill(getter, seed, options = {}) {
    const onFlood = options.onFlood;
    const onBoundary = options.onBoundary;
    const equals = options.equals;
    const filter = options.filter;
    const diagonals = options.diagonals || false;
    const startNode = get(seed);
    const permutations = prunedPermutations();
    const stack = [];
    const flooded = [];
    const visits = new Set();
    const bounds = options.bounds;
    stack.push({ currentArgs: seed });
    while (stack.length > 0) {
        flood(stack.pop());
    }
    return {
        flooded,
    };
    function flood(job) {
        const getArgs = job.currentArgs;
        const prevArgs = job.previousArgs;
        if (visited(getArgs)) {
            return;
        }
        markAsVisited(getArgs);
        if (member(getArgs)) {
            markAsFlooded(getArgs);
            pushAdjacent(getArgs);
        }
        else {
            markAsBoundary(prevArgs);
        }
    }
    function visited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        return visits.has(iKey);
    }
    function markAsVisited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        visits.add(iKey);
    }
    function member(getArgs) {
        const node = get(getArgs);
        return equals ? equals(node, startNode) : node === startNode;
    }
    function markAsFlooded(getArgs) {
        flooded.push(getArgs);
        if (onFlood) {
            onFlood(...getArgs);
        }
    }
    function markAsBoundary(prevArgs) {
        const [x, y, z = 0] = prevArgs;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        bounds?.set(iKey, prevArgs);
        if (onBoundary) {
            onBoundary(...prevArgs);
        }
    }
    function pushAdjacent(getArgs) {
        for (let i = 0; i < permutations.length; i += 1) {
            const perm = permutations[i];
            const nextArgs = getArgs.slice(0);
            for (let j = 0; j < getArgs.length; j += 1) {
                nextArgs[j] += perm[j];
            }
            if (filter?.(nextArgs) === false) {
                continue;
            }
            if (visited(nextArgs)) {
                continue;
            }
            stack.push({
                currentArgs: nextArgs,
                previousArgs: getArgs,
            });
        }
    }
    function get(getArgs) {
        return getter(...getArgs);
    }
    function prunedPermutations() {
        const permutations = permute(seed.length);
        return permutations.filter(function (perm) {
            const count = countNonZeroes(perm);
            return count !== 0 && (count === 1 || diagonals);
        });
    }
    function permute(length) {
        const perms = [];
        const permutation = function (string) {
            return string.split('').map(function (c) {
                return parseInt(c, 10) - 1;
            });
        };
        for (let i = 0; i < Math.pow(3, length); i += 1) {
            const string = lpad(i.toString(3), '0', length);
            perms.push(permutation(string));
        }
        return perms;
    }
}
function countNonZeroes(array) {
    let count = 0;
    for (let i = 0; i < array.length; i += 1) {
        if (array[i] !== 0) {
            count += 1;
        }
    }
    return count;
}
function lpad(string, character, length) {
    const array = new Array(length + 1);
    const pad = array.join(character);
    return (pad + string).slice(-length);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (floodFill);


/***/ }),

/***/ 14957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ getBrushToolInstances)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48736);


function getBrushToolInstances(toolGroupId, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    if (toolName && toolInstances[toolName]) {
        return [toolInstances[toolName]];
    }
    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
    return brushBasedToolInstances;
}


/***/ }),

/***/ 20527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ getHoveredContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98870);


function getHoveredContourSegmentationAnnotation(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const { annotationUIDsMap } = segmentation.representationData.Contour;
    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {
        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => (0,_stateManagement__WEBPACK_IMPORTED_MODULE_0__/* .getAnnotation */ .gw)(annotationUID).highlighted);
        if (highlightedAnnotationUID) {
            return segmentIndex;
        }
    }
    return undefined;
}


/***/ }),

/***/ 83075:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getOrCreateImageVolume(referencedImageIds) {
    if (!referencedImageIds || referencedImageIds.length <= 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
    if (!isValidVolume) {
        return;
    }
    const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(referencedImageIds);
    let imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    if (imageVolume) {
        return imageVolume;
    }
    imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);
    return imageVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateImageVolume);


/***/ }),

/***/ 30722:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33283);


function getOrCreateSegmentationVolume(segmentationId) {
    const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentation */ .T)(segmentationId);
    let { volumeId } = representationData.Labelmap;
    let segVolume;
    if (volumeId) {
        segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (segVolume) {
            return segVolume;
        }
    }
    const { imageIds: labelmapImageIds } = representationData.Labelmap;
    volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(labelmapImageIds);
    if (!labelmapImageIds || labelmapImageIds.length === 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(labelmapImageIds);
    if (!isValidVolume) {
        return;
    }
    segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);
    return segVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateSegmentationVolume);


/***/ }),

/***/ 12853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ getReferenceVolumeForSegmentationVolume)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationVolumeId);
    if (!segmentationVolume) {
        return null;
    }
    const referencedVolumeId = segmentationVolume.referencedVolumeId;
    let imageVolume;
    if (referencedVolumeId) {
        imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    }
    else {
        const imageIds = segmentationVolume.imageIds;
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        const referencedImageId = image.referencedImageId;
        const volumeInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolumeContainingImageId(referencedImageId);
        imageVolume = volumeInfo?.volume;
    }
    return imageVolume;
}


/***/ }),

/***/ 46507:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSegmentIndexAtLabelmapBorder)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98870);
/* harmony import */ var _stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91963);



function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const voxelManager = segmentationVolume.voxelManager;
        const imageData = segmentationVolume.imageData;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
        const canvasPoint = viewport.worldToCanvas(worldPoint);
        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);
        return onEdge ? segmentIndex : undefined;
    }
    const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);
    return onEdge ? segmentIndex : undefined;
}
function isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {
    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);
    for (const deltaI of neighborRange) {
        for (const deltaJ of neighborRange) {
            for (const deltaK of neighborRange) {
                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {
                    continue;
                }
                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);
                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {
                    return true;
                }
            }
        }
    }
    return false;
}
function isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {
        const neighborIJK = [
            indexIJK[0] + deltaI,
            indexIJK[1] + deltaJ,
            indexIJK[2] + deltaK,
        ];
        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
function isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ) => {
        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];
        const worldPoint = viewport.canvasToWorld(neighborCanvas);
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}


/***/ }),

/***/ 71751:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hX: () => (/* binding */ getSegmentIndexAtWorldPoint)
/* harmony export */ });
/* unused harmony exports getSegmentIndexAtWorldForLabelmap, getSegmentIndexAtWorldForContour */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98870);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6802);
/* harmony import */ var _math_polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92984);
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59452);






function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    const representationData = segmentation.representationData;
    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];
    if (!desiredRepresentation) {
        throw new Error(`Segmentation ${segmentationId} does not have any representations`);
    }
    switch (desiredRepresentation) {
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap:
            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour:
            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);
        default:
            return;
    }
}
function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        return segmentIndex;
    }
    const segmentationImageIds = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getCurrentLabelmapImageIdsForViewport)(viewport.id, segmentation.segmentationId);
    if (segmentationImageIds.length > 1) {
        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');
        return;
    }
    const segmentationImageId = segmentationImageIds[0];
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentation.segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    return segmentIndex;
}
function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {
    const contourData = segmentation.representationData.Contour;
    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
    const { viewPlaneNormal } = viewport.getCamera();
    for (const segmentIndex of segmentIndices) {
        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
        if (!annotationsSet) {
            continue;
        }
        for (const annotationUID of annotationsSet) {
            const annotation = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotation */ .gw)(annotationUID);
            if (!annotation) {
                continue;
            }
            const { polyline } = annotation.data.contour;
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
                continue;
            }
            if ((0,_math_polyline__WEBPACK_IMPORTED_MODULE_4__.isPointInsidePolyline3D)(worldPoint, polyline)) {
                return Number(segmentIndex);
            }
        }
    }
}


/***/ }),

/***/ 78773:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSegmentLargestBidirectional)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44460);
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54285);




async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_2__/* .registerComputeWorker */ .D)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_1__.WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);
    const segData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationDataForWorker */ .yR)(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segImageIds, reconstructableVolume, indices } = segData;
    const bidirectionalData = reconstructableVolume
        ? await calculateVolumeBidirectional({
            operationData,
            indices,
            mode,
        })
        : await calculateStackBidirectional({
            segImageIds,
            indices,
            mode,
        });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_1__.WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);
    return bidirectionalData;
}
async function calculateVolumeBidirectional({ operationData, indices, mode }) {
    const strategyData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__/* .prepareVolumeStrategyDataForWorker */ .o9)(operationData);
    const { segmentationVoxelManager, segmentationImageData } = strategyData;
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const bidirectionalData = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
    });
    return bidirectionalData;
}
async function calculateStackBidirectional({ segImageIds, indices, mode }) {
    const { segmentationInfo } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_3__/* .prepareStackDataForWorker */ .Dn)(segImageIds);
    const bidirectionalData = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
        isStack: true,
    });
    return bidirectionalData;
}


/***/ }),

/***/ 38440:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54285);
/* harmony import */ var _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40634);
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68915);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44460);






const radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);
async function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__/* .registerComputeWorker */ .D)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const segData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentationDataForWorker */ .yR)(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;
    const { refImageId, modalityUnitOptions } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .getImageReferenceInfo */ .FI)(segVolumeId, segImageIds);
    const unit = (0,_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__/* .getPixelValueUnitsImageId */ .N)(refImageId, modalityUnitOptions);
    const stats = reconstructableVolume
        ? await calculateVolumeStatistics({
            operationData,
            indices,
            unit,
            mode,
        })
        : await calculateStackStatistics({
            segImageIds,
            indices,
            unit,
            mode,
        });
    return stats;
}
async function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {
    const strategyData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .prepareVolumeStrategyDataForWorker */ .o9)(operationData);
    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;
    if (!segmentationVoxelManager || !segmentationImageData) {
        return;
    }
    const spacing = segmentationImageData.getSpacing();
    const { boundsIJK: boundsOrig } = segmentationVoxelManager;
    if (!boundsOrig) {
        return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.getStatistics({ spacing });
    }
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const imageInfo = {
        scalarData: imageVoxelManager.getCompleteScalarDataArray(),
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
    if (!imageInfo.scalarData?.length) {
        return;
    }
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsVolume', {
        segmentationInfo,
        imageInfo,
        indices,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
const updateStatsArray = (stats, newStat) => {
    if (!stats.array) {
        return;
    }
    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);
    if (existingIndex !== -1) {
        stats.array[existingIndex] = newStat;
    }
    else {
        stats.array.push(newStat);
    }
};
const processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {
    stats.mean.unit = unit;
    stats.max.unit = unit;
    stats.min.unit = unit;
    if (unit !== 'SUV') {
        return stats;
    }
    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));
    for (const testMax of stats.maxIJKs) {
        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);
        if (!testStats) {
            continue;
        }
        const { mean } = testStats;
        if (!stats.peakValue || stats.peakValue.value <= mean.value) {
            stats.peakValue = {
                name: 'peakValue',
                label: 'Peak Value',
                value: mean.value,
                unit,
            };
            stats.peakPoint = {
                name: 'peakLPS',
                label: 'Peak SUV Point',
                value: testMax.pointLPS ? [...testMax.pointLPS] : null,
                unit: null,
            };
            updateStatsArray(stats, stats.peakValue);
            updateStatsArray(stats, stats.peakPoint);
        }
    }
    if (stats.volume && stats.mean) {
        const mtv = stats.volume.value;
        const suvMean = stats.mean.value;
        stats.lesionGlycolysis = {
            name: 'lesionGlycolysis',
            label: 'Lesion Glycolysis',
            value: mtv * suvMean,
            unit: `${stats.volume.unit}${unit}`,
        };
        updateStatsArray(stats, stats.lesionGlycolysis);
    }
    return stats;
};
async function calculateStackStatistics({ segImageIds, indices, unit, mode }) {
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const { segmentationInfo, imageInfo } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .prepareStackDataForWorker */ .Dn)(segImageIds);
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsStack', {
        segmentationInfo,
        imageInfo,
        indices,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    const spacing = segmentationInfo[0].spacing;
    const segmentationImageData = segmentationInfo[0];
    const imageVoxelManager = imageInfo[0].voxelManager;
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
function getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {
    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;
    if (!centerIJK) {
        return;
    }
    const boundsIJK = centerIJK.map((ijk, idx) => [
        ijk - radiusIJK[idx],
        ijk + radiusIJK[idx],
    ]);
    const testFunction = (_pointLPS, pointIJK) => {
        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];
        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];
        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];
        const radius = i * i + j * j + k * k;
        return radius <= 1;
    };
    const statsFunction = ({ pointIJK, pointLPS }) => {
        const value = imageVoxels.getAtIJKPoint(pointIJK);
        if (value === undefined) {
            return;
        }
        _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.statsCallback({ value, pointLPS, pointIJK });
    };
    _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.statsInit({ storePointData: false });
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.pointInShapeCallback(segData, {
        pointInShapeFn: testFunction,
        callback: statsFunction,
        boundsIJK,
    });
    return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.getStatistics({ spacing });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getStatistics);


/***/ }),

/***/ 25758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ getUniqueSegmentIndices)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64063);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);




function getUniqueSegmentIndices(segmentationId) {
    const cachedResult = (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .getCachedSegmentIndices */ .R1)(segmentationId);
    if (cachedResult) {
        return cachedResult;
    }
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
    }
    let indices;
    if (segmentation.representationData.Labelmap) {
        indices = handleLabelmapSegmentation(segmentation, segmentationId);
    }
    else if (segmentation.representationData.Contour) {
        indices = handleContourSegmentation(segmentation);
    }
    else if (segmentation.representationData.Surface) {
        indices = handleSurfaceSegmentation(segmentation);
    }
    else {
        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);
    }
    (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .setCachedSegmentIndices */ .Dm)(segmentationId, indices);
    return indices;
}
function handleLabelmapSegmentation(segmentation, segmentationId) {
    const labelmapData = segmentation.representationData[_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap];
    const keySet = new Set();
    if (labelmapData.imageIds) {
        addImageSegmentIndices(keySet, labelmapData.imageIds);
    }
    else {
        addVolumeSegmentIndices(keySet, segmentationId);
    }
    return Array.from(keySet)
        .map(Number)
        .sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationId);
    volume.voxelManager.forEach(({ value }) => {
        if (value !== 0) {
            keySet.add(value);
        }
    });
}
function addImageSegmentIndices(keySet, imageIds) {
    imageIds.forEach((segmentationImageId) => {
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
        const scalarData = image.voxelManager.getScalarData();
        scalarData.forEach((segmentIndex) => {
            if (segmentIndex !== 0) {
                keySet.add(segmentIndex);
            }
        });
    });
}
function handleContourSegmentation(segmentation) {
    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};
    if (!geometryIds) {
        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
    }
    const indices = new Set([...annotationUIDsMap.keys()]);
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        indices.add(geometry.data.segmentIndex);
    });
    return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];
    return Array.from(geometryIds.keys())
        .map(Number)
        .sort((a, b) => a - b);
}



/***/ }),

/***/ 2733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const shader = `
const MAX_STRENGTH = 65535f;

// Workgroup size - X*Y*Z must be multiple of 32 for better performance
override workGroupSizeX = 1u;
override workGroupSizeY = 1u;
override workGroupSizeZ = 1u;

// Compare the current voxel to neighbors using a 9x9x9 window
override windowSize = 9i;

struct Params {
  size: vec3u,
  iteration: u32,
}

// New structure to track bounds of modified voxels
struct Bounds {
  minX: atomic<i32>,
  minY: atomic<i32>,
  minZ: atomic<i32>,
  maxX: atomic<i32>,
  maxY: atomic<i32>,
  maxZ: atomic<i32>,
}

@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage> volumePixelData: array<f32>;
@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;
@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;
@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;
@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;
@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;
@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;

fn getPixelIndex(ijkPos: vec3u) -> u32 {
  let numPixelsPerSlice = params.size.x * params.size.y;
  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;
}

fn updateBounds(position: vec3i) {
  // Atomically update min bounds (use min operation)
  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);
  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);
  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);

  // Atomically update max bounds (use max operation)
  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);
  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);
  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);
}

@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
fn main(
  @builtin(global_invocation_id) globalId: vec3u,
) {
  // Make sure it will not get out of bounds for volume with sizes that
  // are not multiple of workGroupSize
  if (
    globalId.x >= params.size.x ||
    globalId.y >= params.size.y ||
    globalId.z >= params.size.z
  ) {
    return;
  }

  // Initialize bounds for the first iteration
  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {
    // Initialize to opposite extremes to ensure any update will improve the bounds
    atomicStore(&modifiedBounds.minX, i32(params.size.x));
    atomicStore(&modifiedBounds.minY, i32(params.size.y));
    atomicStore(&modifiedBounds.minZ, i32(params.size.z));
    atomicStore(&modifiedBounds.maxX, -1);
    atomicStore(&modifiedBounds.maxY, -1);
    atomicStore(&modifiedBounds.maxZ, -1);
  }

  let currentCoord = vec3i(globalId);
  let currentPixelIndex = getPixelIndex(globalId);

  let numPixels = arrayLength(&volumePixelData);
  let currentPixelValue = volumePixelData[currentPixelIndex];

  if (params.iteration == 0) {
    // All non-zero initial labels are given maximum strength
    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);

    // Update bounds for non-zero initial labels
    if (labelmap[currentPixelIndex] != 0) {
      updateBounds(currentCoord);
    }
    return;
  }

  // It should at least copy the values from previous state
  var newLabel = prevLabelmap[currentPixelIndex];
  var newStrength = prevStrengthData[currentPixelIndex];

  let window = i32(ceil(f32(windowSize - 1) * .5));
  let minWindow = -1i * window;
  let maxWindow = 1i * window;

  for (var k = minWindow; k <= maxWindow; k++) {
    for (var j = minWindow; j <= maxWindow; j++) {
      for (var i = minWindow; i <= maxWindow; i++) {
        // Skip current voxel
        if (i == 0 && j == 0 && k == 0) {
          continue;
        }

        let neighborCoord = currentCoord + vec3i(i, j, k);

        //  Boundary conditions. Do not grow outside of the volume
        if (
          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||
          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||
          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)
        ) {
          continue;
        }

        let neighborIndex = getPixelIndex(vec3u(neighborCoord));
        let neighborPixelValue = volumePixelData[neighborIndex];
        let prevNeighborStrength = prevStrengthData[neighborIndex];
        let strengthCost = abs(neighborPixelValue - currentPixelValue);
        let takeoverStrength = prevNeighborStrength - strengthCost;

        if (takeoverStrength > newStrength) {
          newLabel = prevLabelmap[neighborIndex];
          newStrength = takeoverStrength;
        }
      }
    }
  }

  if (labelmap[currentPixelIndex] != newLabel) {
    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);

    // Update bounds for modified voxels
    updateBounds(currentCoord);
  }

  labelmap[currentPixelIndex] = newLabel;
  strengthData[currentPixelIndex] = newStrength;
}
`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shader);


/***/ }),

/***/ 95373:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   run: () => (/* reexport safe */ _runGrowCut__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   runGrowCutForBoundingBox: () => (/* reexport safe */ _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__.z),
/* harmony export */   runGrowCutForSphere: () => (/* reexport safe */ _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__.n),
/* harmony export */   runOneClickGrowCut: () => (/* reexport safe */ _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__.HW)
/* harmony export */ });
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66499);
/* harmony import */ var _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73569);
/* harmony import */ var _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20271);
/* harmony import */ var _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16171);






/***/ }),

/***/ 66499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ runGrowCut)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _growCutShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2733);


const GB = 1024 * 1024 * 1024;
const WEBGPU_MEMORY_LIMIT = 1.99 * GB;
const DEFAULT_GROWCUT_OPTIONS = {
    windowSize: 3,
    maxProcessingTime: 30000,
    inspection: {
        numCyclesInterval: 5,
        numCyclesBelowThreshold: 3,
        threshold: 1e-4,
    },
};
async function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {
    const workGroupSize = [8, 8, 4];
    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);
    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referenceVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapVolumeId);
    const [columns, rows, numSlices] = volume.dimensions;
    if (labelmap.dimensions[0] !== columns ||
        labelmap.dimensions[1] !== rows ||
        labelmap.dimensions[2] !== numSlices) {
        throw new Error('Volume and labelmap must have the same size');
    }
    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);
    numIterations = Math.min(numIterations, 500);
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();
    if (!(volumePixelData instanceof Float32Array)) {
        volumePixelData = new Float32Array(volumePixelData);
    }
    const requiredLimits = {
        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,
        maxBufferSize: WEBGPU_MEMORY_LIMIT,
    };
    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter.requestDevice({ requiredLimits });
    const BUFFER_SIZE = volumePixelData.byteLength;
    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;
    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;
    const shaderModule = device.createShaderModule({
        code: _growCutShader__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A,
    });
    const numIterationIndex = 3;
    const paramsArrayValues = new Uint32Array([
        columns,
        rows,
        numSlices,
        0,
    ]);
    const gpuParamsBuffer = device.createBuffer({
        size: paramsArrayValues.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    const gpuVolumePixelDataBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);
    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    }));
    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));
    const gpuStrengthBuffers = [0, 1].map(() => {
        const strengthBuffer = device.createBuffer({
            size: BUFFER_SIZE,
            usage: GPUBufferUsage.STORAGE |
                GPUBufferUsage.COPY_SRC |
                GPUBufferUsage.COPY_DST,
        });
        return strengthBuffer;
    });
    const gpuCounterBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const gpuBoundsBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const initialBounds = new Int32Array([
        columns,
        rows,
        numSlices,
        -1,
        -1,
        -1,
    ]);
    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 4,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 5,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 6,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 7,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });
    const bindGroups = [0, 1].map((i) => {
        const outputLabelmapBuffer = gpuLabelmapBuffers[i];
        const outputStrengthBuffer = gpuStrengthBuffers[i];
        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];
        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];
        return device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: gpuParamsBuffer,
                    },
                },
                {
                    binding: 1,
                    resource: {
                        buffer: gpuVolumePixelDataBuffer,
                    },
                },
                {
                    binding: 2,
                    resource: {
                        buffer: outputLabelmapBuffer,
                    },
                },
                {
                    binding: 3,
                    resource: {
                        buffer: outputStrengthBuffer,
                    },
                },
                {
                    binding: 4,
                    resource: {
                        buffer: previouLabelmapBuffer,
                    },
                },
                {
                    binding: 5,
                    resource: {
                        buffer: previousStrengthBuffer,
                    },
                },
                {
                    binding: 6,
                    resource: {
                        buffer: gpuCounterBuffer,
                    },
                },
                {
                    binding: 7,
                    resource: {
                        buffer: gpuBoundsBuffer,
                    },
                },
            ],
        });
    });
    const pipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout],
        }),
        compute: {
            module: shaderModule,
            entryPoint: 'main',
            constants: {
                workGroupSizeX: workGroupSize[0],
                workGroupSizeY: workGroupSize[1],
                workGroupSizeZ: workGroupSize[2],
                windowSize,
            },
        },
    });
    const numWorkGroups = [
        Math.ceil(columns / workGroupSize[0]),
        Math.ceil(rows / workGroupSize[1]),
        Math.ceil(numSlices / workGroupSize[2]),
    ];
    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const limitProcessingTime = maxProcessingTime
        ? performance.now() + maxProcessingTime
        : 0;
    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
    let belowThresholdCounter = 0;
    for (let i = 0; i < numIterations; i++) {
        paramsArrayValues[numIterationIndex] = i;
        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroups[i % 2]);
        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);
        passEncoder.end();
        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);
        device.queue.submit([commandEncoder.finish()]);
        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);
        if (inspect) {
            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));
            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;
            gpuUpdatedVoxelsCounterStagingBuffer.unmap();
            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {
                currentInspectionNumCyclesInterval = 1;
                belowThresholdCounter++;
                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {
                    break;
                }
            }
            else {
                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
            }
        }
        if (limitProcessingTime && performance.now() > limitProcessingTime) {
            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);
            break;
        }
    }
    const commandEncoder = device.createCommandEncoder();
    const outputLabelmapBufferIndex = (numIterations + 1) % 2;
    const labelmapStagingBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const boundsStagingBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);
    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);
    device.queue.submit([commandEncoder.finish()]);
    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);
    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);
    const labelmapResult = new Uint32Array(labelmapResultBuffer);
    labelmapData.set(labelmapResult);
    labelmapStagingBuffer.unmap();
    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);
    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);
    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));
    boundsStagingBuffer.unmap();
    const minX = boundsResult[0];
    const minY = boundsResult[1];
    const minZ = boundsResult[2];
    const maxX = boundsResult[3];
    const maxY = boundsResult[4];
    const maxZ = boundsResult[5];
    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);
    labelmap.voxelManager.clearBounds();
    labelmap.voxelManager.setBounds([
        [minX, maxX],
        [minY, maxY],
        [minZ, maxZ],
    ]);
}



/***/ }),

/***/ 20271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ runGrowCutForBoundingBox)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66499);


const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
function _setNegativeSeedValues(subVolume, labelmap, options) {
    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const visited = new Array(width * height).fill(false);
    const sliceOffset = middleSliceIndex * width * height;
    const bfs = (startX, startY) => {
        const queue = [[startX, startY]];
        while (queue.length) {
            const [x, y] = queue.shift();
            const slicePixelIndex = y * width + x;
            if (x < 0 ||
                x >= width ||
                y < 0 ||
                y >= height ||
                visited[slicePixelIndex]) {
                continue;
            }
            visited[slicePixelIndex] = true;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);
            queue.push([x - 1, y]);
            queue.push([x + 1, y]);
            queue.push([x, y - 1]);
            queue.push([x, y + 1]);
        }
    };
    const scanLine = (startX, limitX, incX, y) => {
        for (let x = startX; x !== limitX; x += incX) {
            const slicePixelIndex = y * width + x;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                break;
            }
            if (!visited[slicePixelIndex]) {
                bfs(x, y);
            }
        }
    };
    for (let y = 0; y < height; y++) {
        scanLine(0, width - 1, 1, y);
        scanLine(width - 1, 0, -1, y);
    }
}
function _setPositiveSeedValues(subVolume, labelmap, options) {
    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);
    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);
    const pixelsPerSlice = width * height;
    for (let z = startSliceIndex; z < stopSliceIndex; z++) {
        const zOffset = z * pixelsPerSlice;
        for (let y = 0; y < height; y++) {
            const yOffset = y * width;
            for (let x = 0; x < width; x++) {
                const index = zOffset + yOffset + x;
                const pixelValue = subVolPixelData[index];
                const isPositiveValue = pixelValue >= positivePixelRange[0] &&
                    pixelValue <= positivePixelRange[1];
                if (isPositiveValue) {
                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);
                }
            }
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, options);
    _setNegativeSeedValues(subVolume, labelmap, options);
    return labelmap;
}
async function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {
    const { boundingBox } = boundingBoxInfo;
    const { ijkTopLeft, ijkBottomRight } = boundingBox;
    const subVolumeBoundsIJK = {
        minX: ijkTopLeft[0],
        maxX: ijkBottomRight[0],
        minY: ijkTopLeft[1],
        maxY: ijkBottomRight[1],
        minZ: ijkTopLeft[2],
        maxZ: ijkBottomRight[2],
    };
    const subVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__/* .run */ .e)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ 73569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ runGrowCutForSphere)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66499);
/* harmony import */ var _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4296);




const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const POSITIVE_SEED_VARIANCE = 0.1;
const NEGATIVE_SEED_VARIANCE = 0.8;
function _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {
    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;
    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);
    return {
        ...sphereBoundsInfo,
        topLeftIJK,
        bottomRightIJK,
    };
}
function _getSphereBoundsInfo(referencedVolume, sphereInfo) {
    const direction = referencedVolume.imageData.getDirection();
    const vecColumn = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(direction[3], direction[4], direction[5]);
    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;
    const refVolImageData = referencedVolume.imageData;
    const topCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereCenterPoint, vecColumn, -sphereRadius);
    const bottomCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereCenterPoint, vecColumn, sphereRadius);
    const sphereBoundsInfo = (0,_getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__/* .getSphereBoundsInfo */ .R)([bottomCirclePoint, topCirclePoint], refVolImageData);
    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);
}
function _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {
    const refVolImageData = referencedVolume.imageData;
    const camera = viewport.getCamera();
    const { ijkVecRowDir, ijkVecColDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(refVolImageData, camera);
    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[0]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[1]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[2]), 1));
    if (obliqueView) {
        console.warn('Oblique view is not supported!');
        return;
    }
    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);
    const subVolumeBoundsIJK = {
        minX: sphereBoundsIJK[0][0],
        maxX: sphereBoundsIJK[0][1] + 1,
        minY: sphereBoundsIJK[1][0],
        maxY: sphereBoundsIJK[1][1] + 1,
        minZ: sphereBoundsIJK[2][0],
        maxZ: sphereBoundsIJK[2][1] + 1,
    };
    return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
}
function _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {
    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    const worldStartPos = sphereInfo.center;
    const [width, height, numSlices] = referencedVolume.dimensions;
    const numPixelsPerSlice = width * height;
    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);
    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0]];
    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;
    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;
    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0];
    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);
    const queue = [ijkStartPosition];
    while (queue.length) {
        const ijkVoxel = queue.shift();
        const [x, y, z] = ijkVoxel;
        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
            const neighborCoordDelta = neighborsCoordDelta[i];
            const nx = x + neighborCoordDelta[0];
            const ny = y + neighborCoordDelta[1];
            const nz = z + neighborCoordDelta[2];
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];
            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);
            if (neighborLabelmapValue === positiveSeedValue ||
                neighborPixelValue < minPositivePixelValue ||
                neighborPixelValue > maxPositivePixelValue) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);
            queue.push([nx, ny, nz]);
        }
    }
}
function _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [columns, rows, numSlices] = labelmap.dimensions;
    const numPixelsPerSlice = columns * rows;
    const { worldVecRowDir, worldVecSliceDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());
    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);
    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +
        ijkSphereCenter[1] * columns +
        ijkSphereCenter[0]];
    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;
    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;
    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
    const numCirclePoints = 360;
    const rotationAngle = (2 * Math.PI) / numCirclePoints;
    const worldQuat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create(), worldVecSliceDir, rotationAngle);
    const vecRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(worldVecRowDir);
    for (let i = 0; i < numCirclePoints; i++) {
        const worldCircleBorderPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereInfo.center, vecRotation, sphereInfo.radius);
        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);
        const [x, y, z] = ijkCircleBorderPoint;
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformQuat */ .eR.transformQuat(vecRotation, vecRotation, worldQuat);
        if (x < 0 ||
            x >= columns ||
            y < 0 ||
            y >= rows ||
            z < 0 ||
            z >= numSlices) {
            continue;
        }
        const offset = x + y * columns + z * numPixelsPerSlice;
        const pixelValue = subVolPixelData[offset];
        if (pixelValue < minNegativePixelValue ||
            pixelValue > maxNegativePixelValue) {
            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {
    const labelmap = await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);
    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);
    return labelmap;
}
async function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);
    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_2__/* .run */ .e)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ 16171:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HW: () => (/* binding */ runOneClickGrowCut),
/* harmony export */   sG: () => (/* binding */ calculateGrowCutSeeds)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66499);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10564);



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_POSITIVE_SEEDS = 100000;
function calculateGrowCutSeeds(referencedVolume, worldPosition, options) {
    const { dimensions, imageData: refImageData } = referencedVolume;
    const [width, height, numSlices] = dimensions;
    const referenceVolumeVoxelManager = referencedVolume.voxelManager;
    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();
    const numPixelsPerSlice = width * height;
    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEIGHBORHOOD_RADIUS */ .Sp;
    const positiveK = options?.positiveStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_POSITIVE_STD_DEV_MULTIPLIER */ .ee;
    const negativeK = options?.negativeStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER */ .ag;
    const negativeSeedMargin = options?.negativeSeedMargin ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_SEED_MARGIN */ .BX;
    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_SEEDS_COUNT */ .Zi;
    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);
    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);
    if (ijkStart[0] < 0 ||
        ijkStart[0] >= width ||
        ijkStart[1] < 0 ||
        ijkStart[1] >= height ||
        ijkStart[2] < 0 ||
        ijkStart[2] >= numSlices) {
        console.warn('Click position is outside volume bounds.');
        return null;
    }
    const initialStats = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);
    if (initialStats.count === 0) {
        initialStats.mean = scalarData[startIndex];
        initialStats.stdDev = 0;
    }
    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;
    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
    const positiveSeedIndices = new Set();
    const queue = [];
    const startValue = scalarData[startIndex];
    if (startValue >= positiveIntensityMin &&
        startValue <= positiveIntensityMax) {
        positiveSeedIndices.add(startIndex);
        queue.push(ijkStart);
        minX = maxX = ijkStart[0];
        minY = maxY = ijkStart[1];
        minZ = maxZ = ijkStart[2];
    }
    else {
        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let currentQueueIndex = 0;
    while (currentQueueIndex < queue.length &&
        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
        const [x, y, z] = queue[currentQueueIndex++];
        minX = Math.min(x, minX);
        minY = Math.min(y, minY);
        minZ = Math.min(z, minZ);
        maxX = Math.max(x, maxX);
        maxY = Math.max(y, maxY);
        maxZ = Math.max(z, maxZ);
        for (let i = 0; i < neighborsCoordDelta.length; i++) {
            const [dx, dy, dz] = neighborsCoordDelta[i];
            const nx = x + dx;
            const ny = y + dy;
            const nz = z + dz;
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;
            if (positiveSeedIndices.has(neighborIndex)) {
                continue;
            }
            const neighborValue = scalarData[neighborIndex];
            if (neighborValue >= positiveIntensityMin &&
                neighborValue <= positiveIntensityMax) {
                positiveSeedIndices.add(neighborIndex);
                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
                    queue.push([nx, ny, nz]);
                }
            }
        }
    }
    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {
        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);
    }
    if (positiveSeedIndices.size === 0) {
        console.warn('No positive seeds found after BFS.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let positiveSum = 0;
    let positiveSumSq = 0;
    positiveSeedIndices.forEach((index) => {
        const value = scalarData[index];
        positiveSum += value;
        positiveSumSq += value * value;
    });
    const positiveCount = positiveSeedIndices.size;
    const positiveMean = positiveSum / positiveCount;
    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;
    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));
    const negativeDiffThreshold = negativeK * positiveStdDev;
    const minXm = Math.max(0, minX - negativeSeedMargin);
    const minYm = Math.max(0, minY - negativeSeedMargin);
    const minZm = Math.max(0, minZ - negativeSeedMargin);
    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);
    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);
    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);
    const negativeSeedIndices = new Set();
    let attempts = 0;
    let patchesAdded = 0;
    const maxAttempts = negativeSeedsTargetPatches * _constants__WEBPACK_IMPORTED_MODULE_2__/* .MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER */ .gN;
    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {
        attempts++;
        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);
        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);
        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);
        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;
        if (positiveSeedIndices.has(centerIndex) ||
            negativeSeedIndices.has(centerIndex)) {
            continue;
        }
        const centerValue = scalarData[centerIndex];
        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {
            let patchContributed = false;
            for (let dy = -1; dy <= 1; dy++) {
                const ny = ry + dy;
                if (ny < 0 || ny >= height) {
                    continue;
                }
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = rx + dx;
                    if (nx < 0 || nx >= width) {
                        continue;
                    }
                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;
                    if (positiveSeedIndices.has(neighborIndex) ||
                        negativeSeedIndices.has(neighborIndex)) {
                        continue;
                    }
                    negativeSeedIndices.add(neighborIndex);
                    patchContributed = true;
                }
            }
            if (patchContributed) {
                patchesAdded++;
            }
        }
    }
    if (negativeSeedIndices.size === 0) {
        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');
    }
    console.debug('positiveSeedIndices', positiveSeedIndices.size);
    console.debug('negativeSeedIndices', negativeSeedIndices.size);
    return { positiveSeedIndices, negativeSeedIndices };
}
async function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);
    labelmap.voxelManager.forEach(({ index, value }) => {
        if (value !== 0) {
            labelmap.voxelManager.setAtIndex(index, 0);
        }
    });
    const seeds = options.seeds ??
        calculateGrowCutSeeds(referencedVolume, worldPosition, options);
    const positiveSeedLabel = options?.positiveSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .POSITIVE_SEED_LABEL */ .VD;
    const negativeSeedLabel = options?.negativeSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .NEGATIVE_SEED_LABEL */ .bs;
    if (!seeds) {
        return null;
    }
    const { positiveSeedIndices, negativeSeedIndices } = seeds;
    if (positiveSeedIndices.size < 10 ||
        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||
        negativeSeedIndices.size < 10) {
        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');
        return labelmap;
    }
    positiveSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);
    });
    negativeSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);
    });
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__/* .run */ .e)(referencedVolumeId, labelmap.volumeId, options);
    return labelmap;
}



/***/ }),

/***/ 93759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IslandRemoval: () => (/* reexport safe */ _islandRemoval__WEBPACK_IMPORTED_MODULE_22__.A),
/* harmony export */   LabelmapMemo: () => (/* reexport module object */ _createLabelmapMemo__WEBPACK_IMPORTED_MODULE_21__),
/* harmony export */   SegmentStatsCalculator: () => (/* reexport safe */ _SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_9__.A),
/* harmony export */   VolumetricCalculator: () => (/* reexport safe */ _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_8__.Ay),
/* harmony export */   computeMetabolicStats: () => (/* reexport safe */ _computeMetabolicStats__WEBPACK_IMPORTED_MODULE_31__.B),
/* harmony export */   computeStackLabelmapFromVolume: () => (/* reexport safe */ _stateManagement_segmentation_helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_27__._),
/* harmony export */   computeVolumeLabelmapFromStack: () => (/* reexport safe */ _stateManagement_segmentation_helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_28__.a),
/* harmony export */   contourAndFindLargestBidirectional: () => (/* reexport safe */ _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_11__.A),
/* harmony export */   createBidirectionalToolData: () => (/* reexport safe */ _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_12__.A),
/* harmony export */   createLabelmapVolumeForViewport: () => (/* reexport safe */ _createLabelmapVolumeForViewport__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   createMergedLabelmapForIndex: () => (/* reexport safe */ _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   floodFill: () => (/* reexport safe */ _floodFill__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   getBrushSizeForToolGroup: () => (/* reexport safe */ _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   getBrushThresholdForToolGroup: () => (/* reexport safe */ _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__.Q),
/* harmony export */   getBrushToolInstances: () => (/* reexport safe */ _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_19__.n),
/* harmony export */   getHoveredContourSegmentationAnnotation: () => (/* reexport safe */ _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__.L),
/* harmony export */   getOrCreateImageVolume: () => (/* reexport safe */ _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_24__.A),
/* harmony export */   getOrCreateSegmentationVolume: () => (/* reexport safe */ _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__.A),
/* harmony export */   getReferenceVolumeForSegmentationVolume: () => (/* reexport safe */ _getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_29__.b),
/* harmony export */   getSegmentIndexAtLabelmapBorder: () => (/* reexport safe */ _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__.T),
/* harmony export */   getSegmentIndexAtWorldPoint: () => (/* reexport safe */ _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__.hX),
/* harmony export */   getSegmentLargestBidirectional: () => (/* reexport safe */ _getSegmentLargestBidirectional__WEBPACK_IMPORTED_MODULE_30__.T),
/* harmony export */   getStatistics: () => (/* reexport safe */ _getStatistics__WEBPACK_IMPORTED_MODULE_25__.A),
/* harmony export */   getUniqueSegmentIndices: () => (/* reexport safe */ _getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_15__.O),
/* harmony export */   growCut: () => (/* reexport module object */ _growCut__WEBPACK_IMPORTED_MODULE_20__),
/* harmony export */   invalidateBrushCursor: () => (/* reexport safe */ _invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_14__.E),
/* harmony export */   rectangleROIThresholdVolumeByRange: () => (/* reexport safe */ _rectangleROIThresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   segmentContourAction: () => (/* reexport safe */ _segmentContourAction__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   setBrushSizeForToolGroup: () => (/* reexport safe */ _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__.M),
/* harmony export */   setBrushThresholdForToolGroup: () => (/* reexport safe */ _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__.K),
/* harmony export */   thresholdSegmentationByRange: () => (/* reexport safe */ _thresholdSegmentationByRange__WEBPACK_IMPORTED_MODULE_10__.A),
/* harmony export */   thresholdVolumeByRange: () => (/* reexport safe */ _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   triggerSegmentationRender: () => (/* reexport safe */ _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__.h6),
/* harmony export */   triggerSegmentationRenderBySegmentationId: () => (/* reexport safe */ _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__.fy),
/* harmony export */   validateLabelmap: () => (/* reexport module object */ _validateLabelmap__WEBPACK_IMPORTED_MODULE_26__)
/* harmony export */ });
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8582);
/* harmony import */ var _rectangleROIThresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52323);
/* harmony import */ var _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4334);
/* harmony import */ var _createLabelmapVolumeForViewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97492);
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24917);
/* harmony import */ var _floodFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(84882);
/* harmony import */ var _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17014);
/* harmony import */ var _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(49492);
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68915);
/* harmony import */ var _SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13179);
/* harmony import */ var _thresholdSegmentationByRange__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(73706);
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13276);
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(14514);
/* harmony import */ var _segmentContourAction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(22592);
/* harmony import */ var _invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35706);
/* harmony import */ var _getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(25758);
/* harmony import */ var _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(71751);
/* harmony import */ var _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(46507);
/* harmony import */ var _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(20527);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(14957);
/* harmony import */ var _growCut__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(95373);
/* harmony import */ var _createLabelmapMemo__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(2397);
/* harmony import */ var _islandRemoval__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(67912);
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(30722);
/* harmony import */ var _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(83075);
/* harmony import */ var _getStatistics__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(38440);
/* harmony import */ var _validateLabelmap__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(21345);
/* harmony import */ var _stateManagement_segmentation_helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(93690);
/* harmony import */ var _stateManagement_segmentation_helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(6994);
/* harmony import */ var _getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(12853);
/* harmony import */ var _getSegmentLargestBidirectional__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(78773);
/* harmony import */ var _computeMetabolicStats__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(88274);



































/***/ }),

/***/ 35706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ invalidateBrushCursor)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14957);



function invalidateBrushCursor(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__/* .getBrushToolInstances */ .n)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewportIds);
}


/***/ }),

/***/ 82594:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hs: () => (/* binding */ createIsInSegment),
/* harmony export */   pW: () => (/* binding */ isLineInSegment)
/* harmony export */ });
/* unused harmony exports default, createIsInSegmentMetadata */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);


function isLineInSegment(point1, point2, isInSegment) {
    const ijk1 = isInSegment.toIJK(point1);
    const ijk2 = isInSegment.toIJK(point2);
    const testPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    const { testIJK } = isInSegment;
    const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), ijk1, ijk2);
    const testSize = Math.round(Math.max(...delta.map(Math.abs)));
    if (testSize < 2) {
        return true;
    }
    const unitDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scale */ .eR.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), delta, 1 / testSize);
    for (let i = 1; i < testSize; i++) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(testPoint, ijk2, unitDelta, i);
        if (!testIJK(testPoint)) {
            return false;
        }
    }
    return true;
}
function createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {
    const width = dimensions[0];
    const pixelsPerSlice = width * dimensions[1];
    return {
        testCenter: (point1, point2) => {
            const point = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), point1, point2).map((it) => it / 2);
            const ijk = imageData.worldToIndex(point).map(Math.round);
            const [i, j, k] = ijk;
            const index = i + j * width + k * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
        toIJK: (point) => imageData.worldToIndex(point),
        testIJK: (ijk) => {
            const [i, j, k] = ijk;
            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
    };
}
function createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {
    const vol = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    return createIsInSegmentMetadata({
        dimensions: vol.dimensions,
        imageData: vol.imageData,
        voxelManager: vol.voxelManager,
        segmentIndex,
        containedSegmentIndices,
    });
}



/***/ }),

/***/ 67912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ IslandRemoval)
/* harmony export */ });
/* unused harmony export SegmentationEnum */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27963);


const { RLEVoxelMap, VoxelManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_IMAGE_SIZE = 65535;
var SegmentationEnum;
(function (SegmentationEnum) {
    SegmentationEnum[SegmentationEnum["SEGMENT"] = -1] = "SEGMENT";
    SegmentationEnum[SegmentationEnum["ISLAND"] = -2] = "ISLAND";
    SegmentationEnum[SegmentationEnum["INTERIOR"] = -3] = "INTERIOR";
    SegmentationEnum[SegmentationEnum["EXTERIOR"] = -4] = "EXTERIOR";
    SegmentationEnum[SegmentationEnum["INTERIOR_SMALL"] = -5] = "INTERIOR_SMALL";
    SegmentationEnum[SegmentationEnum["INTERIOR_TEST"] = -6] = "INTERIOR_TEST";
})(SegmentationEnum || (SegmentationEnum = {}));
class IslandRemoval {
    constructor(options) {
        this.fillInternalEdge = false;
        this.maxInternalRemove = 128;
        this.maxInternalRemove =
            options?.maxInternalRemove ?? this.maxInternalRemove;
        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;
    }
    initialize(viewport, segmentationVoxels, options) {
        const hasSource = !!segmentationVoxels.sourceVoxelManager;
        const segmentationVoxelManager = hasSource
            ? segmentationVoxels.sourceVoxelManager
            : segmentationVoxels;
        const previewVoxelManager = hasSource
            ? segmentationVoxels
            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;
        const clickedPoints = options.points || segmentationVoxelManager.getPoints();
        if (!clickedPoints?.length) {
            return;
        }
        const boundsIJK = segmentationVoxelManager
            .getBoundsIJK()
            .map((bound, i) => [
            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),
            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),
        ]);
        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {
            return;
        }
        const { toIJK, fromIJK, boundsIJKPrime, error } = (0,_normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport, boundsIJK);
        if (error) {
            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);
            return;
        }
        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);
        const segmentSet = new RLEVoxelMap(width, height, depth);
        const getter = (i, j, k) => {
            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));
            const oldVal = segmentationVoxelManager.getAtIndex(index);
            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {
                return SegmentationEnum.SEGMENT;
            }
        };
        segmentSet.fillFrom(getter, boundsIJKPrime);
        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };
        this.segmentSet = segmentSet;
        this.previewVoxelManager = previewVoxelManager;
        this.segmentIndex = segmentIndex;
        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;
        this.selectedPoints = clickedPoints;
        return true;
    }
    floodFillSegmentIsland() {
        const { selectedPoints: clickedPoints, segmentSet } = this;
        let floodedCount = 0;
        const { fromIJK } = segmentSet.normalizer;
        clickedPoints.forEach((clickedPoint) => {
            const ijkPrime = fromIJK(clickedPoint);
            const index = segmentSet.toIndex(ijkPrime);
            const [iPrime, jPrime, kPrime] = ijkPrime;
            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {
                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);
            }
        });
        return floodedCount;
    }
    removeExternalIslands() {
        const { previewVoxelManager, segmentSet } = this;
        const { toIJK } = segmentSet.normalizer;
        const callback = (index, rle) => {
            const [, jPrime, kPrime] = segmentSet.toIJK(index);
            if (rle.value !== SegmentationEnum.ISLAND) {
                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);
                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);
                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);
                }
            }
        };
        segmentSet.forEach(callback, { rowModified: true });
    }
    removeInternalIslands() {
        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;
        const { height, normalizer, width } = segmentSet;
        const { toIJK } = normalizer;
        segmentSet.forEachRow((baseIndex, row) => {
            let lastRle;
            for (const rle of [...row]) {
                if (rle.value !== SegmentationEnum.ISLAND) {
                    continue;
                }
                if (!lastRle) {
                    if (this.fillInternalEdge && rle.start > 0) {
                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {
                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                        }
                    }
                    lastRle = rle;
                    continue;
                }
                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
                lastRle = rle;
            }
            if (this.fillInternalEdge && lastRle?.end < width) {
                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;
            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;
            const isLast = jPrime === height - 1;
            const isFirst = jPrime === 0;
            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||
                (isFirst && this.fillInternalEdge);
            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);
            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {
                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);
            const isBig = size > this.maxInternalRemove;
            const newType = isBig
                ? SegmentationEnum.EXTERIOR
                : SegmentationEnum.INTERIOR_SMALL;
            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {
                return;
            }
            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));
                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);
            }
        });
        return previewVoxelManager.getArrayOfModifiedSlices();
    }
    static covers(rle, row) {
        if (!row) {
            return false;
        }
        let { start } = rle;
        const { end } = rle;
        for (const rowRle of row) {
            if (start >= rowRle.start && start < rowRle.end) {
                start = rowRle.end;
                if (start >= end) {
                    return true;
                }
            }
        }
        return false;
    }
}


/***/ }),

/***/ 52323:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47807);
/* harmony import */ var _tools_segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67847);
/* harmony import */ var _tools_segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40336);
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8582);
/* harmony import */ var _rectangleROITool_getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37162);





function rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {
    const annotations = annotationUIDs.map((annotationUID) => {
        return _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__.state.getAnnotation(annotationUID);
    });
    _validateAnnotations(annotations);
    let boundsIJK;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||
            i === 0) {
            boundsIJK = (0,_rectangleROITool_getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(annotations, thresholdVolumeInformation[i].volume, options);
        }
    }
    const outputSegmentationVolume = (0,_thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });
    outputSegmentationVolume.modified();
    return outputSegmentationVolume;
}
function _validateAnnotations(annotations) {
    const validToolNames = [
        _tools_segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.toolName,
        _tools_segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.toolName,
    ];
    for (const annotation of annotations) {
        const name = annotation.metadata.toolName;
        if (!validToolNames.includes(name)) {
            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rectangleROIThresholdVolumeByRange);


/***/ }),

/***/ 22592:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ segmentContourAction)
/* harmony export */ });
/* unused harmony export defaultGetSegment */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47807);
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13276);
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14514);
/* harmony import */ var _tools_annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25072);
/* harmony import */ var _stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70758);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60740);







async function segmentContourAction(element, configuration) {
    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');
    const { data: configurationData } = configuration;
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);
    if (!segment) {
        return;
    }
    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();
    const segmentationsList = (0,_stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__/* .getSegmentations */ .K)();
    const { segmentIndex, segmentationId } = segment;
    const bidirectionals = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.getAnnotations(this.toolName || _tools_annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.toolName, FrameOfReferenceUID);
    let hasExistingActiveSegment = false;
    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {
        const segment = existingBidirectionalItem.data.segment;
        if (!segment) {
            return false;
        }
        if (segment.segmentationId === segmentationId &&
            segment.segmentIndex === segmentIndex) {
            hasExistingActiveSegment = true;
            existingBidirectionalItem.data.segment = segment;
        }
        return true;
    });
    if (!hasExistingActiveSegment) {
        existingLargestBidirectionals.push({
            data: { segment },
        });
    }
    let newBidirectional;
    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {
        const segments = [];
        const updateSegment = existingLargestBidirectional.data
            .segment;
        const { segmentIndex, segmentationId } = updateSegment;
        segments[segmentIndex] = updateSegment;
        _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.removeAnnotation(existingLargestBidirectional.annotationUID);
        const bidirectionalData = await (0,_contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)({
            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),
            segments,
        });
        if (!bidirectionalData) {
            return;
        }
        const bidirectionalToolData = (0,_createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(bidirectionalData, enabledElement.viewport);
        bidirectionalToolData.annotationUID =
            existingLargestBidirectional.annotationUID;
        bidirectionalToolData.data.segment = updateSegment;
        const annotationUID = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);
        if (updateSegment.segmentIndex === segment.segmentIndex &&
            updateSegment.segmentationId === segment.segmentationId) {
            newBidirectional = bidirectionalData;
            const { style } = segment;
            if (style) {
                _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.config.style.setAnnotationStyles(annotationUID, style);
            }
        }
    });
    if (newBidirectional) {
        const { sliceIndex } = newBidirectional;
        const imageIds = enabledElement.viewport.getImageIds();
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.jumpToSlice(element, {
            imageIndex: imageIds.length - 1 - sliceIndex,
        });
        enabledElement.viewport.render();
    }
    else {
        console.warn('No bidirectional found');
    }
    return newBidirectional;
}
function defaultGetSegment(enabledElement, configuration) {
    const segmentationsList = (0,_stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__/* .getSegmentations */ .K)();
    if (!segmentationsList.length) {
        return;
    }
    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;
    const segmentIndex = configuration.segmentIndex ?? (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_6__/* .getActiveSegmentIndex */ .Q)(segmentationId);
    if (!segmentIndex) {
        return;
    }
    const segmentData = configuration.segmentData?.get(segmentIndex);
    return {
        label: `Segment ${segmentIndex}`,
        segmentIndex,
        segmentationId,
        ...segmentData,
    };
}


/***/ }),

/***/ 73706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49906);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64063);


function thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');
    }
    const { baseVolumeIdx, volumeInfoList } = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__/* .processVolumes */ .zf)(segmentationVolume, thresholdVolumeInformation);
    const { voxelManager } = volumeInfoList[baseVolumeIdx];
    const refVoxelManager = voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const segVoxelManager = segmentationVolume.voxelManager;
    volumeInfoList.forEach((volumeInfo) => {
        const { volumeSize } = volumeInfo;
        if (volumeSize === scalarDataLength) {
            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);
        }
        else {
            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);
        }
    });
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified)(segmentationId);
    return segmentationVolume;
}
function _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {
    const { imageData, lower, upper, dimensions } = volumeInfo;
    let total, overlaps, range;
    const segScalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < segScalarDataLength; i++) {
        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {
            const overlapBounds = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__/* .getVoxelOverlap */ .Q5)(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));
            const callbackOverlap = ({ value }) => {
                total = total + 1;
                if (value >= range.lower && value <= range.upper) {
                    overlaps = overlaps + 1;
                }
            };
            total = 0;
            overlaps = 0;
            range = { lower, upper };
            let overlapTest = false;
            segVoxelManager.forEach(callbackOverlap, {
                imageData,
                boundsIJK: overlapBounds,
            });
            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;
            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);
        }
    }
    return { total, range, overlaps };
}
function _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {
    const { lower, upper } = volumeInfo;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < scalarDataLength; i++) {
        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {
            const value = refVoxelManager.getAtIndex(i);
            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (thresholdSegmentationByRange);


/***/ }),

/***/ 8582:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49906);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64063);


function thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {
    const { imageData: segmentationImageData } = segmentationVolume;
    const { overwrite, boundsIJK, segmentationId } = options;
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');
    }
    const overlapType = options?.overlapType || 0;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    if (overwrite) {
        for (let i = 0; i < scalarDataLength; i++) {
            segVoxelManager.setAtIndex(i, 0);
        }
    }
    const { baseVolumeIdx, volumeInfoList } = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__/* .processVolumes */ .zf)(segmentationVolume, thresholdVolumeInformation);
    let overlaps, total, range;
    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {
        const callbackOverlap = ({ value }) => {
            total = total + 1;
            if (value >= range.lower && value <= range.upper) {
                overlaps = overlaps + 1;
            }
        };
        const { imageData, dimensions, lower, upper } = volumeInfo;
        const overlapBounds = (0,_utilities__WEBPACK_IMPORTED_MODULE_1__/* .getVoxelOverlap */ .Q5)(imageData, dimensions, voxelSpacing, voxelCenter);
        total = 0;
        overlaps = 0;
        range = { lower, upper };
        let overlapTest = false;
        const { voxelManager } = imageData.get('voxelManager');
        voxelManager.forEach(callbackOverlap, {
            imageData,
            boundsIJK: overlapBounds,
        });
        if (overlapType === 0) {
            overlapTest = overlaps > 0;
        }
        else if (overlapType == 1) {
            overlapTest = overlaps === total;
        }
        return overlapTest;
    };
    const testRange = (volumeInfo, pointIJK) => {
        const { imageData, lower, upper } = volumeInfo;
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const offset = voxelManager.toIndex(pointIJK);
        const value = voxelManager.getAtIndex(offset);
        if (value <= lower || value >= upper) {
            return false;
        }
        else {
            return true;
        }
    };
    const callback = ({ index, pointIJK, pointLPS }) => {
        let insert = volumeInfoList.length > 0;
        for (let i = 0; i < volumeInfoList.length; i++) {
            if (volumeInfoList[i].volumeSize === scalarDataLength) {
                insert = testRange(volumeInfoList[i], pointIJK);
            }
            else {
                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);
            }
            if (!insert) {
                break;
            }
        }
        if (insert) {
            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);
        }
    };
    const voxelManager = segmentationVolume.voxelManager;
    voxelManager.forEach(callback, {
        imageData: segmentationImageData,
        boundsIJK,
    });
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__.triggerSegmentationDataModified)(options.segmentationId);
    return segmentationVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (thresholdVolumeByRange);


/***/ }),

/***/ 64063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dm: () => (/* binding */ setCachedSegmentIndices),
/* harmony export */   HM: () => (/* binding */ setSegmentationDirty),
/* harmony export */   Q5: () => (/* binding */ getVoxelOverlap),
/* harmony export */   R1: () => (/* binding */ getCachedSegmentIndices),
/* harmony export */   zf: () => (/* binding */ processVolumes)
/* harmony export */ });
/* unused harmony export setSegmentationClean */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);


const equalsCheck = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};
function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {
    const halfSpacingX = voxelSpacing[0] / 2;
    const halfSpacingY = voxelSpacing[1] / 2;
    const halfSpacingZ = voxelSpacing[2] / 2;
    const voxelCornersIJK = new Array(8);
    voxelCornersIJK[0] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
        voxelCenter[0] - halfSpacingX,
        voxelCenter[1] - halfSpacingY,
        voxelCenter[2] - halfSpacingZ,
    ]);
    const offsets = [
        [1, -1, -1],
        [-1, 1, -1],
        [1, 1, -1],
        [-1, -1, 1],
        [1, -1, 1],
        [-1, 1, 1],
        [1, 1, 1],
    ];
    for (let i = 0; i < 7; i++) {
        const [xOff, yOff, zOff] = offsets[i];
        voxelCornersIJK[i + 1] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, [
            voxelCenter[0] + xOff * halfSpacingX,
            voxelCenter[1] + yOff * halfSpacingY,
            voxelCenter[2] + zOff * halfSpacingZ,
        ]);
    }
    return (0,_boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__/* .getBoundingBoxAroundShapeIJK */ .g)(voxelCornersIJK, dimensions);
}
function processVolumes(segmentationVolume, thresholdVolumeInformation) {
    const { spacing: segmentationSpacing } = segmentationVolume;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const volumeInfoList = [];
    let baseVolumeIdx = 0;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === scalarDataLength &&
            equalsCheck(spacing, segmentationSpacing)) {
            baseVolumeIdx = i;
        }
        const lower = thresholdVolumeInformation[i].lower;
        const upper = thresholdVolumeInformation[i].upper;
        volumeInfoList.push({
            imageData,
            lower,
            upper,
            spacing,
            dimensions,
            volumeSize,
            voxelManager,
        });
    }
    return {
        volumeInfoList,
        baseVolumeIdx,
    };
}
const segmentIndicesCache = new Map();
const setSegmentationDirty = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = true;
    }
};
const setSegmentationClean = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = false;
    }
};
const getCachedSegmentIndices = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached && !cached.isDirty) {
        return cached.indices;
    }
    return null;
};
const setCachedSegmentIndices = (segmentationId, indices) => {
    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
};


/***/ }),

/***/ 54285:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dn: () => (/* binding */ prepareStackDataForWorker),
/* harmony export */   FI: () => (/* binding */ getImageReferenceInfo),
/* harmony export */   o9: () => (/* binding */ prepareVolumeStrategyDataForWorker),
/* harmony export */   sg: () => (/* binding */ triggerWorkerProgress),
/* harmony export */   yR: () => (/* binding */ getSegmentationDataForWorker)
/* harmony export */ });
/* unused harmony export prepareImageInfo */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40905);
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38732);
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62753);






const triggerWorkerProgress = (workerType, progress) => {
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: workerType,
    });
};
const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    const { representationData } = segmentation;
    const { Labelmap } = representationData;
    if (!Labelmap) {
        console.debug('No labelmap found for segmentation', segmentationId);
        return null;
    }
    const segVolumeId = Labelmap.volumeId;
    const segImageIds = Labelmap.imageIds;
    const operationData = {
        segmentationId,
        volumeId: segVolumeId,
        imageIds: segImageIds,
    };
    let reconstructableVolume = false;
    if (segImageIds) {
        const refImageIds = segImageIds.map((imageId) => {
            const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
            return image.referencedImageId;
        });
        reconstructableVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(refImageIds);
    }
    let indices = segmentIndices;
    if (!indices) {
        indices = [(0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__/* .getActiveSegmentIndex */ .Q)(segmentationId)];
    }
    else if (!Array.isArray(indices)) {
        indices = [indices, 255];
    }
    return {
        operationData,
        segVolumeId,
        segImageIds,
        reconstructableVolume,
        indices,
    };
};
const prepareVolumeStrategyDataForWorker = (operationData) => {
    return (0,_tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__/* .getStrategyData */ .S)({
        operationData,
        strategy: {
            ensureSegmentationVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ensureSegmentationVolumeFor3DManipulation,
            ensureImageVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.ensureImageVolumeFor3DManipulation,
        },
    });
};
const prepareImageInfo = (imageVoxelManager, imageData) => {
    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();
    return {
        scalarData: imageScalarData,
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
};
const prepareStackDataForWorker = (segImageIds) => {
    const segmentationInfo = [];
    const imageInfo = [];
    for (const segImageId of segImageIds) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageId);
        const segPixelData = segImage.getPixelData();
        const { origin, direction, spacing, dimensions } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getImageDataMetadata(segImage);
        segmentationInfo.push({
            scalarData: segPixelData,
            dimensions,
            spacing,
            origin,
            direction,
        });
        const refImageId = segImage.referencedImageId;
        if (refImageId) {
            const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
            if (!refImage) {
                continue;
            }
            const refPixelData = refImage.getPixelData();
            const refVoxelManager = refImage.voxelManager;
            const refSpacing = [
                refImage.rowPixelSpacing,
                refImage.columnPixelSpacing,
            ];
            imageInfo.push({
                scalarData: refPixelData,
                dimensions: refVoxelManager
                    ? refVoxelManager.dimensions
                    : [refImage.columns, refImage.rows, 1],
                spacing: refSpacing,
            });
        }
    }
    return { segmentationInfo, imageInfo };
};
const getImageReferenceInfo = (segVolumeId, segImageIds) => {
    let refImageId;
    if (segVolumeId) {
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
        const imageIds = segmentationVolume.imageIds;
        const cachedImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        if (cachedImage) {
            refImageId = cachedImage.referencedImageId;
        }
    }
    else if (segImageIds?.length) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageIds[0]);
        refImageId = segImage.referencedImageId;
    }
    const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
    const scalingModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('scalingModule', refImageId);
    const modalityUnitOptions = {
        isPreScaled: Boolean(refImage?.preScale?.scaled),
        isSuvScaled: typeof scalingModule?.suvbw === 'number',
    };
    return { refImageId, modalityUnitOptions };
};


/***/ }),

/***/ 21345:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   validate: () => (/* binding */ validate),
/* harmony export */   validatePublic: () => (/* binding */ validatePublic)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function validateRepresentationData(segmentationRepresentationData) {
    if ('volumeId' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        const cachedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationRepresentationData.volumeId);
        if (!cachedVolume) {
            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);
        }
    }
    else if ('imageIds' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        if (!segmentationRepresentationData.imageIds) {
            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');
        }
    }
    else {
        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');
    }
}
function validatePublic(segmentationInput) {
    if (!segmentationInput.representation.data) {
        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');
    }
    const representationData = segmentationInput.representation
        .data;
    validateRepresentationData(representationData);
}
function validate(segmentationRepresentationData) {
    validateRepresentationData(segmentationRepresentationData);
}


/***/ }),

/***/ 1355:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ setAnnotationLabel)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44049);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);


function setAnnotationLabel(annotation, element, updatedLabel) {
    annotation.data.label = updatedLabel;
    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_0__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.LabelChange);
}


/***/ }),

/***/ 71132:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* reexport safe */ _stackContextPrefetch__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   S: () => (/* reexport safe */ _stackPrefetch__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _stackPrefetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34331);
/* harmony import */ var _stackContextPrefetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52734);





/***/ }),

/***/ 52734:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30045);
/* harmony import */ var _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94762);



let configuration = {
    maxImagesToPrefetch: Infinity,
    minBefore: 2,
    maxAfter: 2,
    directionExtraImages: 10,
    preserveExistingPool: false,
};
let resetPrefetchTimeout;
const resetPrefetchDelay = 5;
const enable = (element) => {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getStackData */ .bV)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    updateToolState(element);
    prefetch(element);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getPromiseRemovedHandler */ .m0)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
};
function prefetch(element) {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getStackData */ .bV)(element);
    if (!stack) {
        return;
    }
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .getToolState */ .k)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    const { currentImageIdIndex } = stack;
    indicesToRequestCopy.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImageLoadObject(imageId)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!configuration.preserveExistingPool) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.filterRequests((0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .clearFromImageIds */ .Pg)(stack));
    }
    function doneCallback(imageId) {
        const imageIdIndex = stack.imageIds.indexOf(imageId);
        removeFromList(imageIdIndex);
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getCachedImageBasedOnImageURI(imageId);
        const { stats } = stackPrefetch;
        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;
        if (decodeTimeInMS) {
            stats.imageIds.set(imageId, decodeTimeInMS);
            stats.decodeTimeInMS += decodeTimeInMS;
            const loadTimeInMS = image?.image?.loadTimeInMS || 0;
            stats.loadTimeInMS += loadTimeInMS;
        }
        if (!stackPrefetch.indicesToRequest.length) {
            if (image?.sizeInBytes) {
                const { sizeInBytes } = image;
                const usage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getMaxCacheSize() / 4 / sizeInBytes;
                if (!stackPrefetch.cacheFill) {
                    stats.initialTime = Date.now() - stats.start;
                    stats.initialSize = stats.imageIds.size;
                    updateToolState(element, usage);
                    prefetch(element);
                }
                else if (stats.imageIds.size) {
                    stats.fillTime = Date.now() - stats.start;
                    const { size } = stats.imageIds;
                    stats.fillSize = size;
                }
            }
        }
    }
    const requestFn = (imageId, options) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.loadAndCacheImage(imageId, options)
        .then(() => doneCallback(imageId));
    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        const options = {
            requestType: _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9,
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9, {
            imageId,
        }, _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .priority */ .Lr);
    });
}
function onImageUpdated(e) {
    clearTimeout(resetPrefetchTimeout);
    resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            updateToolState(element);
            prefetch(element);
        }
        catch (error) {
            return;
        }
    }, resetPrefetchDelay);
}
const signum = (x) => (x < 0 ? -1 : 1);
const updateToolState = (element, usage) => {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getStackData */ .bV)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    let { maxAfter = 2, minBefore = 2 } = configuration;
    const { directionExtraImages = 10 } = configuration;
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .getToolState */ .k)(element) ||
        {
            indicesToRequest: [],
            currentImageIdIndex,
            stackCount: 0,
            enabled: true,
            direction: 1,
            stats: {
                start: Date.now(),
                imageIds: new Map(),
                decodeTimeInMS: 0,
                loadTimeInMS: 0,
                totalBytes: 0,
            },
        };
    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;
    stackPrefetchData.direction = signum(delta);
    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;
    stackPrefetchData.enabled = true;
    if (stackPrefetchData.stackCount < 100) {
        stackPrefetchData.stackCount += directionExtraImages;
    }
    if (Math.abs(delta) > maxAfter || !delta) {
        stackPrefetchData.stackCount = 0;
        if (usage) {
            const positionFraction = currentImageIdIndex / stack.imageIds.length;
            minBefore = Math.ceil(usage * positionFraction);
            maxAfter = Math.ceil(usage * (1 - positionFraction));
            stackPrefetchData.cacheFill = true;
        }
        else {
            stackPrefetchData.cacheFill = false;
        }
    }
    else if (delta < 0) {
        minBefore += stackPrefetchData.stackCount;
        maxAfter = 0;
    }
    else {
        maxAfter += stackPrefetchData.stackCount;
        minBefore = 0;
    }
    const minIndex = Math.max(0, currentImageIdIndex - minBefore);
    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);
    const indicesToRequest = [];
    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {
        indicesToRequest.push(i);
    }
    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {
        indicesToRequest.push(i);
    }
    stackPrefetchData.indicesToRequest = indicesToRequest;
    (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .addToolState */ .P)(element, stackPrefetchData);
};
function disable(element) {
    clearTimeout(resetPrefetchTimeout);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getPromiseRemovedHandler */ .m0)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .getToolState */ .k)(element);
    if (stackPrefetchData) {
        stackPrefetchData.enabled = false;
    }
}
function getConfiguration() {
    return configuration;
}
function setConfiguration(config) {
    configuration = config;
}
const stackContextPrefetch = {
    enable,
    disable,
    getConfiguration,
    setConfiguration,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackContextPrefetch);


/***/ }),

/***/ 34331:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30045);
/* harmony import */ var _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94762);



let configuration = {
    maxImagesToPrefetch: Infinity,
    preserveExistingPool: true,
};
let resetPrefetchTimeout;
const resetPrefetchDelay = 10;
function prefetch(element) {
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .getToolState */ .k)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getStackData */ .bV)(element);
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    indicesToRequestCopy.forEach(function (imageIdIndex) {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImageLoadObject(imageId)
            : _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!configuration.preserveExistingPool) {
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.clearRequestStack(_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9);
    }
    const nearest = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .nearestIndex */ .zo)(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);
    let imageId;
    let nextImageIdIndex;
    const preventCache = false;
    function doneCallback(image) {
        console.log('prefetch done: %s', image.imageId);
        const imageIdIndex = stack.imageIds.indexOf(image.imageId);
        removeFromList(imageIdIndex);
    }
    let lowerIndex = nearest.low;
    let higherIndex = nearest.high;
    const imageIdsToPrefetch = [];
    while (lowerIndex >= 0 ||
        higherIndex < stackPrefetch.indicesToRequest.length) {
        const currentIndex = stack.currentImageIdIndex;
        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >
            configuration.maxImagesToPrefetch;
        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >
            configuration.maxImagesToPrefetch;
        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;
        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;
        if (!shouldLoadHigher && !shouldLoadLower) {
            break;
        }
        if (shouldLoadLower) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
        if (shouldLoadHigher) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
    }
    const requestFn = (imageId, options) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoader.loadAndCacheImage(imageId, options);
    imageIdsToPrefetch.forEach((imageId) => {
        const options = {
            requestType: _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9,
        };
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9, {
            imageId,
        }, _stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .priority */ .Lr);
    });
}
function onImageUpdated(e) {
    clearTimeout(resetPrefetchTimeout);
    resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            prefetch(element);
        }
        catch (error) {
            return;
        }
    }, resetPrefetchDelay);
}
function enable(element) {
    const stack = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getStackData */ .bV)(element);
    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = {
        indicesToRequest: (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .range */ .y1)(0, stack.imageIds.length - 1),
        enabled: true,
        direction: 1,
    };
    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);
    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);
    (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .addToolState */ .P)(element, stackPrefetchData);
    prefetch(element);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getPromiseRemovedHandler */ .m0)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
}
function disable(element) {
    clearTimeout(resetPrefetchTimeout);
    element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .getPromiseRemovedHandler */ .m0)(element);
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,_state__WEBPACK_IMPORTED_MODULE_1__/* .getToolState */ .k)(element);
    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {
        stackPrefetchData.enabled = false;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.imageLoadPoolManager.clearRequestStack(_stackPrefetchUtils__WEBPACK_IMPORTED_MODULE_2__/* .requestType */ .y9);
    }
}
function getConfiguration() {
    return configuration;
}
function setConfiguration(config) {
    configuration = config;
}
const stackPrefetch = { enable, disable, getConfiguration, setConfiguration };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackPrefetch);


/***/ }),

/***/ 76260:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyPoints: () => (/* binding */ copyPoints),
/* harmony export */   copyPointsList: () => (/* binding */ copyPointsList),
/* harmony export */   getDeltaDistance: () => (/* binding */ getDeltaDistance),
/* harmony export */   getDeltaDistanceBetweenIPoints: () => (/* binding */ getDeltaDistanceBetweenIPoints),
/* harmony export */   getDeltaPoints: () => (/* binding */ getDeltaPoints),
/* harmony export */   getDeltaRotation: () => (/* binding */ getDeltaRotation),
/* harmony export */   getMeanPoints: () => (/* binding */ getMeanPoints),
/* harmony export */   getMeanTouchPoints: () => (/* binding */ getMeanTouchPoints)
/* harmony export */ });
function getDeltaPoints(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _subtractPoints2D(curr.page, last.page),
        client: _subtractPoints2D(curr.client, last.client),
        canvas: _subtractPoints2D(curr.canvas, last.canvas),
        world: _subtractPoints3D(curr.world, last.world),
    };
}
function getDeltaDistance(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _getDistance2D(curr.page, last.page),
        client: _getDistance2D(curr.client, last.client),
        canvas: _getDistance2D(curr.canvas, last.canvas),
        world: _getDistance3D(curr.world, last.world),
    };
}
function getDeltaRotation(currentPoints, lastPoints) {
}
function getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {
    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);
    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);
    const deltaDistance = {
        page: currentDistance.page - lastDistance.page,
        client: currentDistance.client - lastDistance.client,
        canvas: currentDistance.canvas - lastDistance.canvas,
        world: currentDistance.world - lastDistance.world,
    };
    return deltaDistance;
}
function copyPointsList(points) {
    return JSON.parse(JSON.stringify(points));
}
function copyPoints(points) {
    return JSON.parse(JSON.stringify(points));
}
function getMeanPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    });
}
function getMeanTouchPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
            touch: {
                identifier: null,
                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,
                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,
                force: prev.touch.force + curr.touch.force / points.length,
                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,
            },
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
        touch: {
            identifier: null,
            radiusX: 0,
            radiusY: 0,
            force: 0,
            rotationAngle: 0,
        },
    });
}
function _subtractPoints2D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function _getMeanDistanceBetweenAllIPoints(points) {
    const pairedDistance = [];
    for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
            if (i < j) {
                pairedDistance.push({
                    page: _getDistance2D(points[i].page, points[j].page),
                    client: _getDistance2D(points[i].client, points[j].client),
                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),
                    world: _getDistance3D(points[i].world, points[j].world),
                });
            }
        }
    }
    return pairedDistance.reduce((prev, curr) => {
        return {
            page: prev.page + curr.page / pairedDistance.length,
            client: prev.client + curr.client / pairedDistance.length,
            canvas: prev.canvas + curr.canvas / pairedDistance.length,
            world: prev.world + curr.world / pairedDistance.length,
        };
    }, {
        page: 0,
        client: 0,
        canvas: 0,
        world: 0,
    });
}
function _getDistance2D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));
}
function _getDistance3D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +
        Math.pow(point0[1] - point1[1], 2) +
        Math.pow(point0[2] - point1[2], 2));
}



/***/ }),

/***/ 56069:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39011);

function triggerAnnotationRender(element) {
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .annotationRenderingEngine */ .o.renderViewport(element);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRender);


/***/ }),

/***/ 94779:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   _: () => (/* binding */ triggerAnnotationRenderForToolGroupIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77609);



function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {
    toolGroupIds.forEach((toolGroupId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroup)(toolGroupId);
        if (!toolGroup) {
            console.warn(`ToolGroup not available for ${toolGroupId}`);
            return;
        }
        const viewportsInfo = toolGroup.getViewportsInfo();
        viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
            if (!renderingEngine) {
                console.warn(`RenderingEngine not available for ${renderingEngineId}`);
                return;
            }
            const viewport = renderingEngine.getViewport(viewportId);
            (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element);
        });
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForToolGroupIds);


/***/ }),

/***/ 58640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   t: () => (/* binding */ triggerAnnotationRenderForViewportIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);


function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {
    if (!viewportIdsToRender.length) {
        return;
    }
    viewportIdsToRender.forEach((viewportId) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const { viewport } = enabledElement;
        if (!viewport) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const element = viewport.element;
        (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(element);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForViewportIds);


/***/ }),

/***/ 19027:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isViewportPreScaled: () => (/* reexport safe */ _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__.u)
/* harmony export */ });
/* harmony import */ var _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18990);




/***/ }),

/***/ 3198:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ filterViewportsWithFrameOfReferenceUID)
/* harmony export */ });
function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {
    const numViewports = viewports.length;
    const viewportsWithFrameOfReferenceUID = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {
            viewportsWithFrameOfReferenceUID.push(viewport);
        }
    }
    return viewportsWithFrameOfReferenceUID;
}


/***/ }),

/***/ 67514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export filterViewportsWithParallelNormals */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {
    return viewports.filter((viewport) => {
        const vpCamera = viewport.getCamera();
        const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >
            EPS;
        return isParallel;
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (filterViewportsWithParallelNormals);


/***/ }),

/***/ 9356:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ filterViewportsWithToolEnabled)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77609);


const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function filterViewportsWithToolEnabled(viewports, toolName) {
    const numViewports = viewports.length;
    const viewportsWithToolEnabled = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
        if (!toolGroup) {
            continue;
        }
        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);
        if (hasTool) {
            viewportsWithToolEnabled.push(viewport);
        }
    }
    return viewportsWithToolEnabled;
}
function _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {
    const { toolOptions } = toolGroup;
    const tool = toolOptions[toolName];
    if (!tool) {
        return false;
    }
    const toolMode = tool.mode;
    return toolMode === Active || toolMode === Passive || toolMode === Enabled;
}


/***/ }),

/***/ 60810:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterViewportsWithFrameOfReferenceUID: () => (/* reexport safe */ _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   filterViewportsWithParallelNormals: () => (/* reexport safe */ _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   filterViewportsWithToolEnabled: () => (/* reexport safe */ _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   getViewportIdsWithToolToRender: () => (/* reexport safe */ _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__.A)
/* harmony export */ });
/* harmony import */ var _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3198);
/* harmony import */ var _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9356);
/* harmony import */ var _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14543);
/* harmony import */ var _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67514);







/***/ }),

/***/ 4848:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ Colorbar)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57227);
/* harmony import */ var _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20646);
/* harmony import */ var _ColorbarCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33517);
/* harmony import */ var _ColorbarTicks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62184);
/* harmony import */ var _common_isRangeTextPositionValid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(79457);
/* harmony import */ var _widgets_Widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44845);








const DEFAULTS = {
    MULTIPLIER: 1,
    RANGE_TEXT_POSITION: _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__/* .ColorbarRangeTextPosition */ .U.Right,
    TICKS_BAR_SIZE: 50,
};
class Colorbar extends _widgets_Widget__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    constructor(props) {
        super(props);
        this._isMouseOver = false;
        this._isInteracting = false;
        this._mouseOverCallback = (evt) => {
            this._isMouseOver = true;
            this.showTicks();
            evt.stopPropagation();
        };
        this._mouseOutCallback = (evt) => {
            this._isMouseOver = false;
            this.hideTicks();
            evt.stopPropagation();
        };
        this._mouseDownCallback = (evt) => {
            this._isInteracting = true;
            this.showTicks();
            this._addVOIEventListeners(evt);
            evt.stopPropagation();
        };
        this._mouseDragCallback = (evt, initialState) => {
            const multipliers = this.getVOIMultipliers();
            const currentPoints = this._getPointsFromMouseEvent(evt);
            const { points: startPoints, voiRange: startVOIRange } = initialState;
            const canvasDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.sub */ .Zc.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), currentPoints.local, startPoints.local);
            const wwDelta = canvasDelta[0] * multipliers[0];
            const wcDelta = canvasDelta[1] * multipliers[1];
            if (!wwDelta && !wcDelta) {
                return;
            }
            const { lower: voiLower, upper: voiUpper } = startVOIRange;
            let { windowWidth, windowCenter } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toWindowLevel(voiLower, voiUpper);
            windowWidth = Math.max(windowWidth + wwDelta, 1);
            windowCenter += wcDelta;
            const newVoiRange = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);
            this.voiRange = newVoiRange;
            evt.stopPropagation();
            evt.preventDefault();
        };
        this._mouseUpCallback = (evt) => {
            this._isInteracting = false;
            this.hideTicks();
            this._removeVOIEventListeners();
            evt.stopPropagation();
        };
        this._eventListenersManager =
            new _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.eventListener.MultiTargetEventListenerManager();
        this._colormaps = Colorbar.getColormapsMap(props);
        this._activeColormapName = Colorbar.getInitialColormapName(props);
        this._canvas = this._createCanvas(props);
        this._ticksBar = this._createTicksBar(props);
        this._rangeTextPosition =
            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;
        this._canvas.appendTo(this.rootElement);
        this._ticksBar.appendTo(this.rootElement);
        this._addRootElementEventListeners();
    }
    get activeColormapName() {
        return this._activeColormapName;
    }
    set activeColormapName(colormapName) {
        if (colormapName === this._activeColormapName) {
            return;
        }
        const colormap = this._colormaps.get(colormapName);
        if (!colormap) {
            console.warn(`Invalid colormap name (${colormapName})`);
            return;
        }
        this._activeColormapName = colormapName;
        this._canvas.colormap = colormap;
    }
    get imageRange() {
        return this._canvas.imageRange;
    }
    set imageRange(imageRange) {
        this._canvas.imageRange = imageRange;
        this._ticksBar.imageRange = imageRange;
    }
    get voiRange() {
        return this._canvas.voiRange;
    }
    set voiRange(voiRange) {
        const { voiRange: currentVoiRange } = this._canvas;
        if (!(0,_common__WEBPACK_IMPORTED_MODULE_2__/* .isRangeValid */ .kB)(voiRange) ||
            (0,_common__WEBPACK_IMPORTED_MODULE_2__/* .areColorbarRangesEqual */ .bh)(voiRange, currentVoiRange)) {
            return;
        }
        this._canvas.voiRange = voiRange;
        this._ticksBar.voiRange = voiRange;
        this.onVoiChange(voiRange);
    }
    get showFullImageRange() {
        return this._canvas.showFullImageRange;
    }
    set showFullImageRange(value) {
        this._canvas.showFullImageRange = value;
        this._ticksBar.showFullPixelValueRange = value;
    }
    destroy() {
        super.destroy();
        this._eventListenersManager.reset();
    }
    createRootElement() {
        const rootElement = document.createElement('div');
        Object.assign(rootElement.style, {
            position: 'relative',
            fontSize: '0',
            width: '100%',
            height: '100%',
        });
        return rootElement;
    }
    onContainerResize() {
        super.onContainerResize();
        this.updateTicksBar();
        this._canvas.size = this.containerSize;
    }
    getVOIMultipliers() {
        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];
    }
    onVoiChange(voiRange) {
    }
    showTicks() {
        this.updateTicksBar();
        this._ticksBar.visible = true;
    }
    hideTicks() {
        if (this._isInteracting || this._isMouseOver) {
            return;
        }
        this._ticksBar.visible = false;
    }
    static getColormapsMap(props) {
        const { colormaps } = props;
        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());
    }
    static getInitialColormapName(props) {
        const { activeColormapName, colormaps } = props;
        const colormapExists = !!activeColormapName &&
            colormaps.some((cm) => cm.Name === activeColormapName);
        return colormapExists ? activeColormapName : colormaps[0].Name;
    }
    _createCanvas(props) {
        const { imageRange, voiRange, showFullPixelValueRange } = props;
        const colormap = this._colormaps.get(this._activeColormapName);
        return new _ColorbarCanvas__WEBPACK_IMPORTED_MODULE_4__/* .ColorbarCanvas */ .n({
            colormap,
            imageRange,
            voiRange: voiRange,
            showFullPixelValueRange,
        });
    }
    _createTicksBar(props) {
        const ticksProps = props.ticks;
        return new _ColorbarTicks__WEBPACK_IMPORTED_MODULE_5__/* .ColorbarTicks */ .f({
            imageRange: props.imageRange,
            voiRange: props.voiRange,
            ticks: ticksProps,
            showFullPixelValueRange: props.showFullPixelValueRange,
        });
    }
    _getPointsFromMouseEvent(evt) {
        const { rootElement: element } = this;
        const clientPoint = [evt.clientX, evt.clientY];
        const pagePoint = [evt.pageX, evt.pageY];
        const rect = element.getBoundingClientRect();
        const localPoints = [
            pagePoint[0] - rect.left - window.pageXOffset,
            pagePoint[1] - rect.top - window.pageYOffset,
        ];
        return { client: clientPoint, page: pagePoint, local: localPoints };
    }
    updateTicksBar() {
        const { width: containerWidth, height: containerHeight } = this.containerSize;
        if (containerWidth === 0 && containerHeight === 0) {
            return;
        }
        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;
        const isHorizontal = containerWidth >= containerHeight;
        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;
        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;
        if (!(0,_common_isRangeTextPositionValid__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(containerWidth, containerHeight, rangeTextPosition)) {
            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');
        }
        let ticksBarTop;
        let ticksBarLeft;
        ticksBar.size = { width, height };
        if (isHorizontal) {
            ticksBarLeft = 0;
            ticksBarTop =
                rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__/* .ColorbarRangeTextPosition */ .U.Top
                    ? -height
                    : containerHeight;
        }
        else {
            ticksBarTop = 0;
            ticksBarLeft =
                rangeTextPosition === _enums_ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_3__/* .ColorbarRangeTextPosition */ .U.Left
                    ? -width
                    : containerWidth;
        }
        ticksBar.top = ticksBarTop;
        ticksBar.left = ticksBarLeft;
    }
    _addRootElementEventListeners() {
        const { _eventListenersManager: manager } = this;
        const { rootElement: element } = this;
        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);
        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);
        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);
    }
    _addVOIEventListeners(evt) {
        const { _eventListenersManager: manager } = this;
        const points = this._getPointsFromMouseEvent(evt);
        const voiRange = { ...this._canvas.voiRange };
        const initialDragState = { points, voiRange };
        this._removeVOIEventListeners();
        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);
        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));
    }
    _removeVOIEventListeners() {
        const { _eventListenersManager: manager } = this;
        manager.removeEventListener(document, 'voi.mouseup');
        manager.removeEventListener(document, 'voi.mousemove');
    }
}



/***/ }),

/***/ 91994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ ViewportColorbar)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _Colorbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4848);
/* harmony import */ var _getVOIMultipliers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22658);



const { Events } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
const defaultImageRange = { lower: -1000, upper: 1000 };
class ViewportColorbar extends _Colorbar__WEBPACK_IMPORTED_MODULE_1__/* .Colorbar */ .P {
    constructor(props) {
        const { element, volumeId } = props;
        const imageRange = ViewportColorbar._getImageRange(element, volumeId);
        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);
        super({ ...props, imageRange, voiRange });
        this.autoHideTicks = () => {
            if (this._hideTicksTimeoutId) {
                return;
            }
            const timeLeft = this._hideTicksTime - Date.now();
            if (timeLeft <= 0) {
                this.hideTicks();
            }
            else {
                this._hideTicksTimeoutId = window.setTimeout(() => {
                    this._hideTicksTimeoutId = 0;
                    this.autoHideTicks();
                }, timeLeft);
            }
        };
        this._stackNewImageCallback = () => {
            this.imageRange = ViewportColorbar._getImageRange(this._element);
        };
        this._imageVolumeModifiedCallback = (evt) => {
            const { volumeId } = evt.detail;
            if (volumeId !== this._volumeId) {
                return;
            }
            const { _element: element } = this;
            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);
        };
        this._viewportVOIModifiedCallback = (evt) => {
            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.voiRange = voiRange;
            if (colormap) {
                this.activeColormapName = colormap.name;
            }
            this.showAndAutoHideTicks();
        };
        this._viewportColormapModifiedCallback = (evt) => {
            const { viewportId, colormap, volumeId } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.activeColormapName = colormap.name;
        };
        this._element = element;
        this._volumeId = volumeId;
        this._addCornerstoneEventListener();
    }
    get element() {
        return this._element;
    }
    get enabledElement() {
        return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._element);
    }
    getVOIMultipliers() {
        const { viewport } = this.enabledElement;
        return (0,_getVOIMultipliers__WEBPACK_IMPORTED_MODULE_2__/* .getVOIMultipliers */ .j)(viewport, this._volumeId);
    }
    onVoiChange(voiRange) {
        super.onVoiChange(voiRange);
        const { viewport } = this.enabledElement;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
            viewport.setProperties({
                voiRange: voiRange,
            });
            viewport.render();
        }
        else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
            const { _volumeId: volumeId } = this;
            const viewportsContainingVolumeUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            viewport.setProperties({ voiRange }, volumeId);
            viewportsContainingVolumeUID.forEach((vp) => vp.render());
        }
    }
    static _getImageRange(element, volumeId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const imageData = actor.getMapper().getInputData();
        const scalarData = imageData.getPointData().getScalars();
        let imageRange;
        if (!scalarData) {
            if (!volumeId) {
                throw new Error('volumeId is required when scalarData is not available');
            }
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const [minValue, maxValue] = volume.voxelManager.getRange();
            imageRange = [minValue, maxValue];
        }
        else {
            imageRange = scalarData.getRange();
        }
        return imageRange[0] === 0 && imageRange[1] === 0
            ? defaultImageRange
            : { lower: imageRange[0], upper: imageRange[1] };
    }
    static _getVOIRange(element, volumeId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();
        return voiRange[0] === 0 && voiRange[1] === 0
            ? defaultImageRange
            : { lower: voiRange[0], upper: voiRange[1] };
    }
    showAndAutoHideTicks(interval = 1000) {
        this._hideTicksTime = Date.now() + interval;
        this.showTicks();
        this.autoHideTicks();
    }
    _addCornerstoneEventListener() {
        const { _element: element } = this;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
    destroy() {
        super.destroy();
        const { _element: element } = this;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
}



/***/ }),

/***/ 20646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ ColorbarRangeTextPosition)
/* harmony export */ });
var ColorbarRangeTextPosition;
(function (ColorbarRangeTextPosition) {
    ColorbarRangeTextPosition["Top"] = "top";
    ColorbarRangeTextPosition["Left"] = "left";
    ColorbarRangeTextPosition["Bottom"] = "bottom";
    ColorbarRangeTextPosition["Right"] = "right";
})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));


/***/ }),

/***/ 51807:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarRangeTextPosition: () => (/* reexport safe */ _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__.U)
/* harmony export */ });
/* harmony import */ var _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20646);



/***/ }),

/***/ 28802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Colorbar: () => (/* reexport safe */ _Colorbar__WEBPACK_IMPORTED_MODULE_1__.P),
/* harmony export */   Enums: () => (/* reexport module object */ _enums__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   ViewportColorbar: () => (/* reexport safe */ _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__.b)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51807);
/* harmony import */ var _Colorbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4848);
/* harmony import */ var _ViewportColorbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91994);






/***/ }),

/***/ 97213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   colorbar: () => (/* reexport module object */ _colorbar__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   windowLevel: () => (/* reexport module object */ _windowlevel__WEBPACK_IMPORTED_MODULE_1__)
/* harmony export */ });
/* harmony import */ var _colorbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28802);
/* harmony import */ var _windowlevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72936);





/***/ }),

/***/ 95995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ calculateMinMaxMean)
/* harmony export */ });
function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {
    const numPixels = pixelLuminance.length;
    let min = globalMax;
    let max = globalMin;
    let sum = 0;
    if (numPixels < 2) {
        return {
            min,
            max,
            mean: (globalMin + globalMax) / 2,
        };
    }
    for (let index = 0; index < numPixels; index++) {
        const spv = pixelLuminance[index];
        min = Math.min(min, spv);
        max = Math.max(max, spv);
        sum += spv;
    }
    return {
        min,
        max,
        mean: sum / numPixels,
    };
}



/***/ }),

/***/ 41433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ extractWindowLevelRegionToolData)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function extractWindowLevelRegionToolData(viewport) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        return extractImageDataVolume(viewport);
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        return extractImageDataStack(viewport);
    }
    throw new Error('Viewport not supported');
}
function extractImageDataVolume(viewport) {
    const { scalarData, width, height } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getCurrentVolumeViewportSlice(viewport);
    const { min: minPixelValue, max: maxPixelValue } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getMinMax(scalarData);
    return {
        scalarData,
        minPixelValue,
        maxPixelValue,
        width,
        height,
        rows: width,
        columns: height,
    };
}
function extractImageDataStack(viewport) {
    const imageData = viewport.getImageData();
    const { scalarData } = imageData;
    const { min: minPixelValue, max: maxPixelValue } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getMinMax(scalarData);
    const width = imageData.dimensions[0];
    const height = imageData.dimensions[1];
    const { rows, columns, color } = viewport.getCornerstoneImage();
    return {
        scalarData,
        width,
        height,
        minPixelValue,
        maxPixelValue,
        rows,
        columns,
        color,
    };
}



/***/ }),

/***/ 98148:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ getLuminanceFromRegion)
/* harmony export */ });
function getLuminanceFromRegion(imageData, x, y, width, height) {
    const luminance = [];
    let index = 0;
    const pixelData = imageData.scalarData;
    let spIndex, row, column;
    if (imageData.color) {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;
                const red = pixelData[spIndex];
                const green = pixelData[spIndex + 1];
                const blue = pixelData[spIndex + 2];
                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
            }
        }
    }
    else {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = (row + y) * imageData.columns + (column + x);
                luminance[index++] = pixelData[spIndex];
            }
        }
    }
    return luminance;
}



/***/ }),

/***/ 72936:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateMinMaxMean: () => (/* reexport safe */ _calculateMinMaxMean__WEBPACK_IMPORTED_MODULE_1__.a),
/* harmony export */   extractWindowLevelRegionToolData: () => (/* reexport safe */ _extractWindowLevelRegionToolData__WEBPACK_IMPORTED_MODULE_2__.u),
/* harmony export */   getLuminanceFromRegion: () => (/* reexport safe */ _getLuminanceFromRegion__WEBPACK_IMPORTED_MODULE_0__.l)
/* harmony export */ });
/* harmony import */ var _getLuminanceFromRegion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98148);
/* harmony import */ var _calculateMinMaxMean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95995);
/* harmony import */ var _extractWindowLevelRegionToolData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41433);






/***/ }),

/***/ 81810:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(86326);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var DEFAULT_SIZE = 24;

exports.A = function (_ref) {
  var _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
      _ref$width = _ref.width,
      width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? {} : _ref$style,
      props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);

  return _react2.default.createElement(
    'svg',
    _extends({
      viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
      style: _extends({ fill: fill, width: width, height: height }, style)
    }, props),
    _react2.default.createElement('path', { d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z' })
  );
};

/***/ }),

/***/ 69767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(86326);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var DEFAULT_SIZE = 24;

exports.A = function (_ref) {
  var _ref$fill = _ref.fill,
      fill = _ref$fill === undefined ? 'currentColor' : _ref$fill,
      _ref$width = _ref.width,
      width = _ref$width === undefined ? DEFAULT_SIZE : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === undefined ? DEFAULT_SIZE : _ref$height,
      _ref$style = _ref.style,
      style = _ref$style === undefined ? {} : _ref$style,
      props = _objectWithoutProperties(_ref, ['fill', 'width', 'height', 'style']);

  return _react2.default.createElement(
    'svg',
    _extends({
      viewBox: '0 0 ' + DEFAULT_SIZE + ' ' + DEFAULT_SIZE,
      style: _extends({ fill: fill, width: width, height: height }, style)
    }, props),
    _react2.default.createElement('path', { d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z' })
  );
};

/***/ }),

/***/ 26711:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(75443);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 66297:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(26711));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ 83562:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FH: () => (/* binding */ api)
/* harmony export */ });
/* unused harmony exports utils, version */
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/**
 * Converts a Uint8Array to a String.
 * @param {Uint8Array} array that should be converted
 * @param {Number} offset array offset in case only subset of array items should
                   be extracted (default: 0)
 * @param {Number} limit maximum number of array items that should be extracted
                   (defaults to length of array)
 * @returns {String}
 */
function uint8ArrayToString(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var limit = arguments.length > 2 ? arguments[2] : undefined;
  var itemLimit = limit || arr.length - offset;
  var str = '';
  for (var i = offset; i < offset + itemLimit; i++) {
    str += String.fromCharCode(arr[i]);
  }
  return str;
}

/**
 * Converts a String to a Uint8Array.
 * @param {String} str string that should be converted
 * @returns {Uint8Array}
 */
function stringToUint8Array(str) {
  var arr = new Uint8Array(str.length);
  for (var i = 0, j = str.length; i < j; i++) {
    arr[i] = str.charCodeAt(i);
  }
  return arr;
}

/**
 * Identifies the boundary in a multipart/related message header.
 * @param {String} header message header
 * @returns {String} boundary
 */
function identifyBoundary(header) {
  var parts = header.split('\r\n');
  for (var i = 0; i < parts.length; i++) {
    if (parts[i].substr(0, 2) === '--') {
      return parts[i];
    }
  }
  return null;
}

/**
 * Checks whether a given token is contained by a message at a given offset.
 * @param {Uint8Array} message message content
 * @param {Uint8Array} token substring that should be present
 * @param {Number} offset offset in message content from where search should start
 * @returns {Boolean} whether message contains token at offset
 */
function containsToken(message, token) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (offset + token.length > message.length) {
    return false;
  }
  var index = offset;
  for (var i = 0; i < token.length; i++) {
    if (token[i] !== message[index]) {
      return false;
    }
    index += 1;
  }
  return true;
}

/**
 * Finds a given token in a message at a given offset.
 * @param {Uint8Array} message message content
 * @param {Uint8Array} token substring that should be found
 * @param {String} offset message body offset from where search should start
 * @returns {Boolean} whether message has a part at given offset or not
 */
function findToken(message, token) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxSearchLength = arguments.length > 3 ? arguments[3] : undefined;
  var searchLength = message.length;
  if (maxSearchLength) {
    searchLength = Math.min(offset + maxSearchLength, message.length);
  }
  for (var i = offset; i < searchLength; i++) {
    // If the first value of the message matches
    // the first value of the token, check if
    // this is the full token.
    if (message[i] === token[0]) {
      if (containsToken(message, token, i)) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * Create a random GUID
 *
 * @return {string}
 */
function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }
  return "".concat(s4() + s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4(), "-").concat(s4()).concat(s4()).concat(s4());
}

/**
 * @typedef {Object} MultipartEncodedData
 * @property {ArrayBuffer} data The encoded Multipart Data
 * @property {String} boundary The boundary used to divide pieces of the encoded data
 */

/**
 * Encode one or more DICOM datasets into a single body so it can be
 * sent using the Multipart Content-Type.
 *
 * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the
                          multipart body, passed as ArrayBuffers.
 * @param {String} [boundary] Optional string to define a boundary between each part
                              of the multipart body. If this is not specified, a random
                              GUID will be generated.
 * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This
                                  contains both the data itself, and the boundary string
                                  used to divide it.
 */
function multipartEncode(datasets) {
  var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();
  var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/dicom';
  var contentTypeString = "Content-Type: ".concat(contentType);
  var header = "\r\n--".concat(boundary, "\r\n").concat(contentTypeString, "\r\n\r\n");
  var footer = "\r\n--".concat(boundary, "--");
  var headerArray = stringToUint8Array(header);
  var footerArray = stringToUint8Array(footer);
  var headerLength = headerArray.length;
  var footerLength = footerArray.length;
  var length = 0;

  // Calculate the total length for the final array
  var contentArrays = datasets.map(function (datasetBuffer) {
    var contentArray = new Uint8Array(datasetBuffer);
    var contentLength = contentArray.length;
    length += headerLength + contentLength + footerLength;
    return contentArray;
  });

  // Allocate the array
  var multipartArray = new Uint8Array(length);

  // Set the initial header
  multipartArray.set(headerArray, 0);

  // Write each dataset into the multipart array
  var position = 0;
  contentArrays.forEach(function (contentArray) {
    multipartArray.set(headerArray, position);
    multipartArray.set(contentArray, position + headerLength);
    position += headerLength + contentArray.length;
  });
  multipartArray.set(footerArray, position);
  return {
    data: multipartArray.buffer,
    boundary: boundary
  };
}

/**
 * Decode a Multipart encoded ArrayBuffer and return the components as an Array.
 *
 * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message
 * @returns {Array} The content
 */
function multipartDecode(response) {
  // Use the raw data if it is provided in an appropriate format
  var message = ArrayBuffer.isView(response) ? response : new Uint8Array(response);

  /* Set a maximum length to search for the header boundaries, otherwise
       findToken can run for a long time
    */
  var maxSearchLength = 1000;

  // First look for the multipart mime header
  var separator = stringToUint8Array('\r\n\r\n');
  var headerIndex = findToken(message, separator, 0, maxSearchLength);
  if (headerIndex === -1) {
    throw new Error('Response message has no multipart mime header');
  }
  var header = uint8ArrayToString(message, 0, headerIndex);
  var boundaryString = identifyBoundary(header);
  if (!boundaryString) {
    throw new Error('Header of response message does not specify boundary');
  }
  var boundary = stringToUint8Array(boundaryString);
  var boundaryLength = boundary.length;
  var components = [];
  var offset = boundaryLength;

  // Loop until we cannot find any more boundaries
  var boundaryIndex;
  while (boundaryIndex !== -1) {
    // Search for the next boundary in the message, starting
    // from the current offset position
    boundaryIndex = findToken(message, boundary, offset);

    // If no further boundaries are found, stop here.
    if (boundaryIndex === -1) {
      break;
    }
    var headerTokenIndex = findToken(message, separator, offset, maxSearchLength);
    if (headerTokenIndex === -1) {
      throw new Error('Response message part has no mime header');
    }
    offset = headerTokenIndex + separator.length;

    // Extract data from response message, excluding "\r\n"
    var spacingLength = 2;
    var data = response.slice(offset, boundaryIndex - spacingLength);

    // Add the data to the array of results
    components.push(data);

    // Move the offset to the end of the current section,
    // plus the identified boundary
    offset = boundaryIndex + boundaryLength;
  }
  return components;
}

function isObject(obj) {
  return _typeof(obj) === 'object' && obj !== null;
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
}
function areValidRequestHooks(requestHooks) {
  var isValid = Array.isArray(requestHooks) && requestHooks.every(function (requestHook) {
    return typeof requestHook === 'function' && requestHook.length === 2;
  });
  if (!isValid) {
    console.warn('Request hooks should have the following signature: ' + 'function requestHook(request, metadata) { return request; }');
  }
  return isValid;
}
var getFirstResult = function getFirstResult(result) {
  return result[0];
};
var MEDIATYPES = {
  DICOM: 'application/dicom',
  DICOM_JSON: 'application/dicom+json',
  OCTET_STREAM: 'application/octet-stream',
  PDF: 'application/pdf',
  JPEG: 'image/jpeg',
  PNG: 'image/png'
};

/**
 * debugLog is a function that can be called with console.log arguments, and will
 * be conditionally displayed, only when debug logging is enabled.
 */
var debugLog = function debugLog() {};

/**
 * @typedef { import("../types/types").InstanceMetadata } InstanceMetadata
 */

/**
 * A callback with the request instance and metadata information
 * of the currently request being executed that should necessarily
 * return the given request optionally modified.
 * @typedef {function} RequestHook
 * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.
 * @param {object} metadata - The metadata used by the request.
 */

/**
 * Class for interacting with DICOMweb RESTful services.
 */
var DICOMwebClient = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} options
   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint
   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS
   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS
   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS
   * @param {String=} options.username - Username
   * @param {String=} options.password - Password
   * @param {Object=} options.headers - HTTP headers
   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.
   * @param {Object=} options.verbose - print to console request warnings and errors, default true
   * @param {Object=} options.debug - print to the console debug level information/status updates.
   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.
   * The available types are:  bulkdata, video, image.  true means all.
   */
  function DICOMwebClient(options) {
    _classCallCheck(this, DICOMwebClient);
    this.baseURL = options.url;
    if (!this.baseURL) {
      console.error('no DICOMweb base url provided - calls that require a URL will fail');
    }
    if ('username' in options) {
      this.username = options.username;
      if (!('password' in options)) {
        console.error('no password provided to authenticate with DICOMweb service');
      }
      this.password = options.password;
    }
    if ('qidoURLPrefix' in options) {
      debugLog("use URL prefix for QIDO-RS: ".concat(options.qidoURLPrefix));
      this.qidoURL = "".concat(this.baseURL, "/").concat(options.qidoURLPrefix);
    } else {
      this.qidoURL = this.baseURL;
    }
    if ('wadoURLPrefix' in options) {
      debugLog("use URL prefix for WADO-RS: ".concat(options.wadoURLPrefix));
      this.wadoURL = "".concat(this.baseURL, "/").concat(options.wadoURLPrefix);
    } else {
      this.wadoURL = this.baseURL;
    }
    if ('stowURLPrefix' in options) {
      debugLog("use URL prefix for STOW-RS: ".concat(options.stowURLPrefix));
      this.stowURL = "".concat(this.baseURL, "/").concat(options.stowURLPrefix);
    } else {
      this.stowURL = this.baseURL;
    }
    if (options.singlepart) {
      debugLog('use singlepart', options.singlepart);
      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;
    } else {
      this.singlepart = '';
    }
    if ('requestHooks' in options) {
      this.requestHooks = options.requestHooks;
    }

    // Headers to pass to requests.
    this.headers = options.headers || {};

    // Optional error interceptor callback to handle any failed request.
    this.errorInterceptor = options.errorInterceptor || function () {
      return undefined;
    };

    // Verbose - print to console request warnings and errors, default true
    this.verbose = options.verbose !== false;
    this.setDebug(options.debug);
  }

  /**
   * Allows setting the debug log information. 
   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true
   * 
   * @param {boolean} debugLevel 
   * @param {function} debugLogFunction to call with the debug output arguments. 
   */
  _createClass(DICOMwebClient, [{
    key: "setDebug",
    value: function setDebug() {
      var debugLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var debugLogFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.debugLevel = !!debugLevel;
      debugLog = debugLogFunction || debugLevel ? console.log : function () {};
    }
    /**
     * Gets debug flag
     * 
     * @returns true if debug logging is enabled
     */
  }, {
    key: "getDebug",
    value: function getDebug() {
      return this.debugLevel;
    }
    /**
     * Sets verbose flag.
     *
     * @param {Boolean} verbose
     */
  }, {
    key: "setVerbose",
    value: function setVerbose(verbose) {
      this.verbose = verbose;
    }
    /**
     * Gets verbose flag.
     *
     * @return {Boolean} verbose
     */
  }, {
    key: "getVerbose",
    value: function getVerbose() {
      return this.verbose;
    }
  }, {
    key: "_httpRequest",
    /**
     * Performs an HTTP request.
     *
     * @param {String} url
     * @param {String} method
     * @param {Object} headers
     * @param {Object} options
     * @param {Array.<RequestHook>} options.requestHooks - Request hooks.
     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects
     * @return {*}
     * @private
     */
    value: function _httpRequest(url, method) {
      var _this = this;
      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var errorInterceptor = this.errorInterceptor,
        requestHooks = this.requestHooks;
      return new Promise(function (resolve, reject) {
        var request = options.request ? options.request : new XMLHttpRequest();
        request.open(method, url, true);
        if ('responseType' in options) {
          request.responseType = options.responseType;
        }
        if (_typeof(headers) === 'object') {
          Object.keys(headers).forEach(function (key) {
            request.setRequestHeader(key, headers[key]);
          });
        }

        // now add custom headers from the user
        // (e.g. access tokens)
        var userHeaders = _this.headers;
        Object.keys(userHeaders).forEach(function (key) {
          request.setRequestHeader(key, userHeaders[key]);
        });

        // Event triggered when upload starts
        request.onloadstart = function onloadstart() {
          debugLog('upload started: ', url);
        };

        // Event triggered when upload ends
        request.onloadend = function onloadend() {
          debugLog('upload finished');
        };

        // Handle response message
        request.onreadystatechange = function () {
          if (request.readyState === 4) {
            if (request.status === 200) {
              var contentType = request.getResponseHeader('Content-Type');
              // Automatically distinguishes between multipart and singlepart in an array buffer, and
              // converts them into a consistent type.
              if (contentType && contentType.indexOf('multipart') !== -1) {
                resolve(multipartDecode(request.response));
              } else if (request.responseType === 'arraybuffer') {
                resolve([request.response]);
              } else {
                resolve(request.response);
              }
            } else if (request.status === 202) {
              if (_this.verbose) {
                console.warn('some resources already existed: ', request);
              }
              resolve(request.response);
            } else if (request.status === 204) {
              if (_this.verbose) {
                console.warn('empty response for request: ', request);
              }
              resolve([]);
            } else {
              var error = new Error('request failed');
              error.request = request;
              error.response = request.response;
              error.status = request.status;
              if (_this.verbose) {
                console.error('request failed: ', request);
                console.error(error);
                console.error(error.response);
              }
              errorInterceptor(error);
              reject(error);
            }
          }
        };

        // Event triggered while download progresses
        if ('progressCallback' in options) {
          if (typeof options.progressCallback === 'function') {
            request.onprogress = options.progressCallback;
          }
        }
        if (requestHooks && areValidRequestHooks(requestHooks)) {
          var combinedHeaders = Object.assign({}, headers, _this.headers);
          var metadata = {
            method: method,
            url: url,
            headers: combinedHeaders
          };
          var pipeRequestHooks = function pipeRequestHooks(functions) {
            return function (args) {
              return functions.reduce(function (props, fn) {
                return fn(props, metadata);
              }, args);
            };
          };
          var pipedRequest = pipeRequestHooks(requestHooks);
          request = pipedRequest(request);
        }

        // Add withCredentials to request if needed
        if ('withCredentials' in options) {
          if (options.withCredentials) {
            request.withCredentials = true;
          }
        }
        if ('data' in options) {
          request.send(options.data);
        } else {
          request.send();
        }
      });
    }
    /**
     * Performs an HTTP GET request.
     *
     * @param {String} url
     * @param {Object} headers
     * @param {Object} responseType
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGet",
    value: function _httpGet(url, headers, responseType, progressCallback, withCredentials) {
      return this._httpRequest(url, 'get', headers, {
        responseType: responseType,
        progressCallback: progressCallback,
        withCredentials: withCredentials
      });
    }
    /**
     * Performs an HTTP GET request that accepts a message with application/json
     * media type.
     *
     * @param {String} url
     * @param {Object} params
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGetApplicationJson",
    value: function _httpGetApplicationJson(url) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;
      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;
      var urlWithQueryParams = url;
      if (_typeof(params) === 'object') {
        if (!isEmptyObject(params)) {
          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
        }
      }
      var headers = {
        Accept: MEDIATYPES.DICOM_JSON
      };
      var responseType = 'json';
      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a message with application/pdf
     * media type.
     *
     * @param {String} url
     * @param {Object} params
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGetApplicationPdf",
    value: function _httpGetApplicationPdf(url) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var progressCallback = arguments.length > 2 ? arguments[2] : undefined;
      var withCredentials = arguments.length > 3 ? arguments[3] : undefined;
      var urlWithQueryParams = url;
      if (_typeof(params) === 'object') {
        if (!isEmptyObject(params)) {
          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
        }
      }
      var headers = {
        Accept: MEDIATYPES.PDF
      };
      var responseType = 'json';
      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a message with an image
     media type.
     *
     * @param {String} url
     * @param {Object[]} mediaTypes
     * @param {Object} params
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGetImage",
    value: function _httpGetImage(url, mediaTypes) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;
      var urlWithQueryParams = url;
      if (_typeof(params) === 'object') {
        if (!isEmptyObject(params)) {
          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
        }
      }
      var supportedMediaTypes = ['image/', 'image/*', 'image/jpeg', 'image/jp2', 'image/gif', 'image/png'];
      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
      var headers = {
        Accept: acceptHeaderFieldValue
      };
      var responseType = 'arraybuffer';
      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a message with a text
     media type.
     *
     * @param {String} url
     * @param {Object[]} mediaTypes
     * @param {Object} params
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGetText",
    value: function _httpGetText(url, mediaTypes) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;
      var urlWithQueryParams = url;
      if (_typeof(params) === 'object') {
        if (!isEmptyObject(params)) {
          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
        }
      }
      var supportedMediaTypes = ['text/', 'text/*', 'text/html', 'text/plain', 'text/rtf', 'text/xml'];
      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
      var headers = {
        Accept: acceptHeaderFieldValue
      };
      var responseType = 'arraybuffer';
      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a message with a video
     media type.
     *
     * @param {String} url
     * @param {Object[]} mediaTypes
     * @param {Object} params
     * @param {Function} progressCallback
     * @return {*}
     * @private
     */
  }, {
    key: "_httpGetVideo",
    value: function _httpGetVideo(url, mediaTypes) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var progressCallback = arguments.length > 3 ? arguments[3] : undefined;
      var withCredentials = arguments.length > 4 ? arguments[4] : undefined;
      var urlWithQueryParams = url;
      if (_typeof(params) === 'object') {
        if (!isEmptyObject(params)) {
          urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);
        }
      }
      var supportedMediaTypes = ['video/', 'video/*', 'video/mpeg', 'video/mp4', 'video/H265'];
      var acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
      var headers = {
        Accept: acceptHeaderFieldValue
      };
      var responseType = 'arraybuffer';
      return this._httpGet(urlWithQueryParams, headers, responseType, progressCallback, withCredentials);
    }
    /**
     * Asserts that a given media type is valid.
     *
     * @params {String} mediaType media type
     */
  }, {
    key: "_httpGetMultipartImage",
    /**
     * Performs an HTTP GET request that accepts a multipart message with an image media type.
     *
     * @param {String} url - Unique resource locator
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @param {Array} byteRange - Start and end of byte range
     * @param {Object} params - Additional HTTP GET query parameters
     * @param {Boolean} rendered - Whether resource should be requested using rendered media types
     * @param {Function} progressCallback
     * @private
     * @returns {Promise<Array>} Content of HTTP message body parts
     */
    value: function _httpGetMultipartImage(url, mediaTypes, byteRange, params) {
      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;
      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;
      var headers = {};
      var supportedMediaTypes;
      if (rendered) {
        supportedMediaTypes = ['image/jpeg', 'image/gif', 'image/png', 'image/jp2'];
      } else {
        supportedMediaTypes = {
          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],
          '1.2.840.10008.1.2.4.50': ['image/jpeg'],
          '1.2.840.10008.1.2.4.51': ['image/jpeg'],
          '1.2.840.10008.1.2.4.57': ['image/jpeg'],
          '1.2.840.10008.1.2.4.70': ['image/jpeg'],
          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],
          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],
          '1.2.840.10008.1.2.4.90': ['image/jp2'],
          '1.2.840.10008.1.2.4.91': ['image/jp2'],
          '1.2.840.10008.1.2.4.92': ['image/jpx'],
          '1.2.840.10008.1.2.4.93': ['image/jpx']
        };
        if (byteRange) {
          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
        }
      }
      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a multipart message with a video media type.
     *
     * @param {String} url - Unique resource locator
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @param {Array} byteRange - Start and end of byte range
     * @param {Object} params - Additional HTTP GET query parameters
     * @param {Boolean} rendered - Whether resource should be requested using rendered media types
     * @param {Function} progressCallback
     * @private
     * @returns {Promise<Array>} Content of HTTP message body parts
     */
  }, {
    key: "_httpGetMultipartVideo",
    value: function _httpGetMultipartVideo(url, mediaTypes, byteRange, params) {
      var rendered = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var progressCallback = arguments.length > 5 ? arguments[5] : undefined;
      var withCredentials = arguments.length > 6 ? arguments[6] : undefined;
      var headers = {};
      var supportedMediaTypes;
      if (rendered) {
        supportedMediaTypes = ['video/', 'video/*', 'video/mpeg2', 'video/mp4', 'video/H265'];
      } else {
        supportedMediaTypes = {
          '1.2.840.10008.1.2.4.100': ['video/mpeg2'],
          '1.2.840.10008.1.2.4.101': ['video/mpeg2'],
          '1.2.840.10008.1.2.4.102': ['video/mp4'],
          '1.2.840.10008.1.2.4.103': ['video/mp4'],
          '1.2.840.10008.1.2.4.104': ['video/mp4'],
          '1.2.840.10008.1.2.4.105': ['video/mp4'],
          '1.2.840.10008.1.2.4.106': ['video/mp4']
        };
        if (byteRange) {
          headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
        }
      }
      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes);
      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a multipart message
     * with a application/dicom media type.
     *
     * @param {String} url - Unique resource locator
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @param {Object} params - Additional HTTP GET query parameters
     * @param {Function} progressCallback
     * @private
     * @returns {Promise<Array>} Content of HTTP message body parts
     */
  }, {
    key: "_httpGetMultipartApplicationDicom",
    value: function _httpGetMultipartApplicationDicom(url, mediaTypes, params, progressCallback, withCredentials) {
      var headers = {};
      var defaultMediaType = 'application/dicom';
      var supportedMediaTypes = {
        '1.2.840.10008.1.2.1': [defaultMediaType],
        '1.2.840.10008.1.2.5': [defaultMediaType],
        '1.2.840.10008.1.2.4.50': [defaultMediaType],
        '1.2.840.10008.1.2.4.51': [defaultMediaType],
        '1.2.840.10008.1.2.4.57': [defaultMediaType],
        '1.2.840.10008.1.2.4.70': [defaultMediaType],
        '1.2.840.10008.1.2.4.80': [defaultMediaType],
        '1.2.840.10008.1.2.4.81': [defaultMediaType],
        '1.2.840.10008.1.2.4.90': [defaultMediaType],
        '1.2.840.10008.1.2.4.91': [defaultMediaType],
        '1.2.840.10008.1.2.4.92': [defaultMediaType],
        '1.2.840.10008.1.2.4.93': [defaultMediaType],
        '1.2.840.10008.1.2.4.100': [defaultMediaType],
        '1.2.840.10008.1.2.4.101': [defaultMediaType],
        '1.2.840.10008.1.2.4.102': [defaultMediaType],
        '1.2.840.10008.1.2.4.103': [defaultMediaType],
        '1.2.840.10008.1.2.4.104': [defaultMediaType],
        '1.2.840.10008.1.2.4.105': [defaultMediaType],
        '1.2.840.10008.1.2.4.106': [defaultMediaType]
      };
      var acceptableMediaTypes = mediaTypes;
      if (!mediaTypes) {
        acceptableMediaTypes = [{
          mediaType: defaultMediaType
        }];
      }
      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);
      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP GET request that accepts a multipart message
     * with a application/octet-stream, OR any of the equivalencies for that (eg
     * application/pdf etc)
     *
     * @param {String} url - Unique resource locator
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @param {Array} byteRange start and end of byte range
     * @param {Object} params - Additional HTTP GET query parameters
     * @param {Function} progressCallback
     * @private
     * @returns {Promise<Array>} Content of HTTP message body parts
     */
  }, {
    key: "_httpGetMultipartApplicationOctetStream",
    value: function _httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, params, progressCallback, withCredentials) {
      var headers = {};
      var defaultMediaType = 'application/octet-stream';
      var supportedMediaTypes = {
        '1.2.840.10008.1.2.1': _toConsumableArray(Object.values(MEDIATYPES))
      };
      var acceptableMediaTypes = mediaTypes;
      if (!mediaTypes) {
        acceptableMediaTypes = [{
          mediaType: defaultMediaType
        }];
      }
      if (byteRange) {
        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);
      }
      headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(acceptableMediaTypes, supportedMediaTypes);
      return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);
    }
    /**
     * Performs an HTTP POST request.
     *
     * @param {String} url - Unique resource locator
     * @param {Object} headers - HTTP header fields
     * @param {Array} data - Data that should be stored
     * @param {Function} progressCallback
     * @param {Function} progressCallback
     * @param {XMLHttpRequest} request - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects
     * @private
     * @returns {Promise} Response
     */
  }, {
    key: "_httpPost",
    value: function _httpPost(url, headers, data, progressCallback, withCredentials, request) {
      return this._httpRequest(url, 'post', headers, {
        data: data,
        progressCallback: progressCallback,
        withCredentials: withCredentials,
        request: request
      });
    }
    /**
     * Performs an HTTP POST request with content-type application/dicom+json.
     *
     * @param {String} url - Unique resource locator
     * @param {Object} headers - HTTP header fields
     * @param {Array} data - Data that should be stored
     * @param {Function} progressCallback
     * @private
     * @returns {Promise} Response
     */
  }, {
    key: "_httpPostApplicationJson",
    value: function _httpPostApplicationJson(url, data, progressCallback, withCredentials) {
      var headers = {
        'Content-Type': MEDIATYPES.DICOM_JSON
      };
      return this._httpPost(url, headers, data, progressCallback, withCredentials);
    }
    /**
     * Parses media type and extracts its type and subtype.
     *
     * @param {String} mediaType - HTTP media type (e.g. image/jpeg)
     * @private
     * @returns {String[]} Media type and subtype
     */
  }, {
    key: "searchForStudies",
    /**
     * Searches for DICOM studies.
     *
     * @param {Object} options
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)
     */
    value: function searchForStudies() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      debugLog('search for studies');
      var withCredentials = false;
      var url = "".concat(this.qidoURL, "/studies");
      if ('queryParams' in options) {
        url += DICOMwebClient._parseQueryParameters(options.queryParams);
      }
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /**
     * Retrieves metadata for a DICOM study.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance
                        belonging to the study
     */
  }, {
    key: "retrieveStudyMetadata",
    value: function retrieveStudyMetadata(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of study metadata');
      }
      debugLog("retrieve metadata of study ".concat(options.studyInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/metadata");
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /**
     * Searches for DICOM series.
     *
     * @param {Object} options
     * @param {Object} [options.studyInstanceUID] - Study Instance UID
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)
     */
  }, {
    key: "searchForSeries",
    value: function searchForSeries() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var url = this.qidoURL;
      if ('studyInstanceUID' in options) {
        debugLog("search series of study ".concat(options.studyInstanceUID));
        url += "/studies/".concat(options.studyInstanceUID);
      }
      url += '/series';
      if ('queryParams' in options) {
        url += DICOMwebClient._parseQueryParameters(options.queryParams);
      }
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /**
     * Retrieves metadata for a DICOM series.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance
                        belonging to the series
     */
  }, {
    key: "retrieveSeriesMetadata",
    value: function retrieveSeriesMetadata(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of series metadata');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of series metadata');
      }
      debugLog("retrieve metadata of series ".concat(options.seriesInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/metadata");
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /**
     * Searches for DICOM Instances.
     *
     * @param {Object} options
     * @param {String} [options.studyInstanceUID] - Study Instance UID
     * @param {String} [options.seriesInstanceUID] - Series Instance UID
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)
     */
  }, {
    key: "searchForInstances",
    value: function searchForInstances() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var url = this.qidoURL;
      var withCredentials = false;
      if ('studyInstanceUID' in options) {
        url += "/studies/".concat(options.studyInstanceUID);
        if ('seriesInstanceUID' in options) {
          debugLog("search for instances of series ".concat(options.seriesInstanceUID));
          url += "/series/".concat(options.seriesInstanceUID);
        } else {
          debugLog("search for instances of study ".concat(options.studyInstanceUID));
        }
      } else {
        debugLog('search for instances');
      }
      url += '/instances';
      if ('queryParams' in options) {
        url += DICOMwebClient._parseQueryParameters(options.queryParams);
      }
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /** Returns a WADO-URI URL for an instance
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @returns {String} WADO-URI URL
     */
  }, {
    key: "buildInstanceWadoURIUrl",
    value: function buildInstanceWadoURIUrl(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required.');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required.');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required.');
      }
      var contentType = options.contentType || MEDIATYPES.DICOM;
      var transferSyntax = options.transferSyntax || '*';
      var params = [];
      params.push('requestType=WADO');
      params.push("studyUID=".concat(options.studyInstanceUID));
      params.push("seriesUID=".concat(options.seriesInstanceUID));
      params.push("objectUID=".concat(options.sopInstanceUID));
      params.push("contentType=".concat(contentType));
      params.push("transferSyntax=".concat(transferSyntax));
      var paramString = params.join('&');
      return "".concat(this.wadoURL, "?").concat(paramString);
    }
    /**
     * Retrieves metadata for a DICOM Instance.
     *
     * @param {Object} options object
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format
     */
  }, {
    key: "retrieveInstanceMetadata",
    value: function retrieveInstanceMetadata(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of instance metadata');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of instance metadata');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of instance metadata');
      }
      debugLog("retrieve metadata of instance ".concat(options.sopInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/metadata");
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      return this._httpGetApplicationJson(url, {}, false, withCredentials);
    }
    /**
     * Retrieves frames for a DICOM Instance.
     * @param {Object} options options object
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @param {String} options.frameNumbers - One-based indices of Frame Items
     * @returns {Array} frame items as byte arrays of the pixel data element
     */
  }, {
    key: "retrieveInstanceFrames",
    value: function retrieveInstanceFrames(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of instance frames');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of instance frames');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of instance frames');
      }
      if (!('frameNumbers' in options)) {
        throw new Error('frame numbers are required for retrieval of instance frames');
      }
      debugLog("retrieve frames ".concat(options.frameNumbers.toString(), " of instance ").concat(options.sopInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/frames/").concat(options.frameNumbers.toString());
      var mediaTypes = options.mediaTypes;
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        return this._httpGetMultipartApplicationOctetStream(url, false, false, false, progressCallback, withCredentials);
      }
      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);
      if (sharedMediaTypes.length > 1) {
        /**
         * Enable request of frames that are stored either compressed
         * (image/* media type) or uncompressed (application/octet-stream
         * media type).
         */
        var supportedMediaTypes = {
          '1.2.840.10008.1.2.1': ['application/octet-stream'],
          '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],
          '1.2.840.10008.1.2.4.50': ['image/jpeg'],
          '1.2.840.10008.1.2.4.51': ['image/jpeg'],
          '1.2.840.10008.1.2.4.57': ['image/jpeg'],
          '1.2.840.10008.1.2.4.70': ['image/jpeg'],
          '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],
          '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],
          '1.2.840.10008.1.2.4.90': ['image/jp2'],
          '1.2.840.10008.1.2.4.91': ['image/jp2'],
          '1.2.840.10008.1.2.4.92': ['image/jpx'],
          '1.2.840.10008.1.2.4.93': ['image/jpx'],
          '1.2.840.10008.1.2.4.201': ['image/jhc'],
          '1.2.840.10008.1.2.4.202': ['image/jhc']
        };
        var headers = {
          Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes)
        };
        return this._httpGet(url, headers, 'arraybuffer', progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType.startsWith('application')) {
        return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, false, false, progressCallback, withCredentials);
      }
      if (commonMediaType.startsWith('image')) {
        return this._httpGetMultipartImage(url, mediaTypes, false, false, false, progressCallback, withCredentials);
      }
      if (commonMediaType.startsWith('video')) {
        return this._httpGetMultipartVideo(url, mediaTypes, false, false, false, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of frames."));
    }
    /**
    * Element in mediaTypes parameter
    * @typedef {Object} MediaType
    * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...
    */
    /**
     * Retrieves an individual, server-side rendered DICOM Instance.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance
     */
  }, {
    key: "retrieveInstanceRendered",
    value: function retrieveInstanceRendered(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of rendered instance');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of rendered instance');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of rendered instance');
      }
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/rendered");
      var mediaTypes = options.mediaTypes,
        queryParams = options.queryParams;
      var headers = {};
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        var responseType = 'arraybuffer';
        if (queryParams) {
          url += DICOMwebClient._parseQueryParameters(queryParams);
        }
        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType.startsWith('image')) {
        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      if (commonMediaType.startsWith('video')) {
        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      if (commonMediaType.startsWith('text')) {
        return this._httpGetText(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      if (commonMediaType === MEDIATYPES.PDF) {
        return this._httpGetApplicationPdf(url, queryParams, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported ") + 'for retrieval of rendered instance.');
    }
    /**
     * Retrieves a thumbnail of an DICOM Instance.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {ArrayBuffer} Thumbnail
     */
  }, {
    key: "retrieveInstanceThumbnail",
    value: function retrieveInstanceThumbnail(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of rendered instance');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of rendered instance');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of rendered instance');
      }
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/thumbnail");
      var mediaTypes = options.mediaTypes,
        queryParams = options.queryParams;
      var headers = {};
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        var responseType = 'arraybuffer';
        if (queryParams) {
          url += DICOMwebClient._parseQueryParameters(queryParams);
        }
        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType.startsWith('image')) {
        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported ") + 'for retrieval of rendered instance.');
    }
    /**
     * Retrieves rendered frames for a DICOM Instance.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @param {String} options.frameNumbers - One-based indices of Frame Items
     * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays
     */
  }, {
    key: "retrieveInstanceFramesRendered",
    value: function retrieveInstanceFramesRendered(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('frameNumbers' in options)) {
        throw new Error('frame numbers are required for retrieval of rendered instance frames');
      }
      debugLog("retrieve rendered frames ".concat(options.frameNumbers.toString(), " of instance ").concat(options.sopInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/frames/").concat(options.frameNumbers.toString(), "/rendered");
      var mediaTypes = options.mediaTypes,
        queryParams = options.queryParams;
      var headers = {};
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        var responseType = 'arraybuffer';
        if (queryParams) {
          url += DICOMwebClient._parseQueryParameters(queryParams);
        }
        return this._httpGet(url, headers, responseType, false, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType.startsWith('image')) {
        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      if (commonMediaType.startsWith('video')) {
        return this._httpGetVideo(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported ") + 'for retrieval of rendered frame.');
    }
    /**
     * Retrieves thumbnail of frames for a DICOM Instance.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @param {String} options.frameNumbers - One-based indices of Frame Items
     * @param {Object} [options.queryParams] - HTTP query parameters
     * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays
     */
  }, {
    key: "retrieveInstanceFramesThumbnail",
    value: function retrieveInstanceFramesThumbnail(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required for retrieval of rendered instance frames');
      }
      if (!('frameNumbers' in options)) {
        throw new Error('frame numbers are required for retrieval of rendered instance frames');
      }
      console.debug("retrieve rendered frames ".concat(options.frameNumbers.toString(), " of instance ").concat(options.sopInstanceUID));
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID, "/frames/").concat(options.frameNumbers.toString(), "/thumbnail");
      var mediaTypes = options.mediaTypes,
        queryParams = options.queryParams;
      var headers = {};
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        var responseType = 'arraybuffer';
        if (queryParams) {
          url += DICOMwebClient._parseQueryParameters(queryParams);
        }
        return this._httpGet(url, headers, responseType, progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType.startsWith('image')) {
        return this._httpGetImage(url, mediaTypes, queryParams, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported ") + 'for retrieval of rendered frame.');
    }
    /**
     * Retrieves a DICOM Instance.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {String} options.sopInstanceUID - SOP Instance UID
     * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer
     */
  }, {
    key: "retrieveInstance",
    value: function retrieveInstance(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required');
      }
      if (!('sopInstanceUID' in options)) {
        throw new Error('SOP Instance UID is required');
      }
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID, "/instances/").concat(options.sopInstanceUID);
      var mediaTypes = options.mediaTypes;
      var _options$withCredenti = options.withCredentials,
        withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti;
      var _options$progressCall = options.progressCallback,
        progressCallback = _options$progressCall === void 0 ? false : _options$progressCall;
      if (!mediaTypes) {
        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials).then(getFirstResult);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType === MEDIATYPES.DICOM) {
        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials).then(getFirstResult);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of instance."));
    }
    /**
     * Retrieves all DICOM Instances of a Series.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @param {String} options.seriesInstanceUID - Series Instance UID
     * @param {Function} options.progressCallback
     * @returns {Promise<ArrayBuffer[]>} DICOM Instances
     */
  }, {
    key: "retrieveSeries",
    value: function retrieveSeries(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required');
      }
      if (!('seriesInstanceUID' in options)) {
        throw new Error('Series Instance UID is required');
      }
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID, "/series/").concat(options.seriesInstanceUID);
      var mediaTypes = options.mediaTypes;
      var withCredentials = false;
      if ('withCredentials' in options) {
        if (options.withCredentials) {
          withCredentials = options.withCredentials;
        }
      }
      var progressCallback = false;
      if ('progressCallback' in options) {
        progressCallback = options.progressCallback;
      }
      if (!mediaTypes) {
        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType === MEDIATYPES.DICOM) {
        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of series."));
    }
    /**
     * Retrieves all DICOM Instances of a Study.
     *
     * @param {Object} options
     * @param {String} options.studyInstanceUID - Study Instance UID
     * @returns {ArrayBuffer[]} DICOM Instances
     */
  }, {
    key: "retrieveStudy",
    value: function retrieveStudy(options) {
      if (!('studyInstanceUID' in options)) {
        throw new Error('Study Instance UID is required');
      }
      var url = "".concat(this.wadoURL, "/studies/").concat(options.studyInstanceUID);
      var mediaTypes = options.mediaTypes;
      var _options$withCredenti2 = options.withCredentials,
        withCredentials = _options$withCredenti2 === void 0 ? false : _options$withCredenti2;
      var _options$progressCall2 = options.progressCallback,
        progressCallback = _options$progressCall2 === void 0 ? false : _options$progressCall2;
      if (!mediaTypes) {
        return this._httpGetMultipartApplicationDicom(url, false, false, progressCallback, withCredentials);
      }
      var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
      if (commonMediaType === MEDIATYPES.DICOM) {
        return this._httpGetMultipartApplicationDicom(url, mediaTypes, false, progressCallback, withCredentials);
      }
      throw new Error("Media type ".concat(commonMediaType, " is not supported for retrieval of study."));
    }
    /**
     * Retrieves and parses BulkData from a BulkDataURI location.
     * Decodes the multipart encoded data and returns the resulting data
     * as an ArrayBuffer.
     *
     * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html
     *
     * @param {Object} options
     * @param {string} options.BulkDataURI to retrieve
     * @param {Array}  options.mediaTypes to use to fetch the URI
     * @param {string} options.byteRange to request a sub-range (only valid on single part)
     * @returns {Promise<Array>} Bulkdata parts
     */
  }, {
    key: "retrieveBulkData",
    value: function retrieveBulkData(options) {
      if (!('BulkDataURI' in options)) {
        throw new Error('BulkDataURI is required.');
      }
      var url = options.BulkDataURI;
      var mediaTypes = options.mediaTypes,
        byteRange = options.byteRange;
      var _options$withCredenti3 = options.withCredentials,
        withCredentials = _options$withCredenti3 === void 0 ? false : _options$withCredenti3;
      var _options$progressCall3 = options.progressCallback,
        progressCallback = _options$progressCall3 === void 0 ? false : _options$progressCall3;
      if (this.singlepart.indexOf('bulkdata') !== -1) {
        return this._httpGet(url, options.headers, 'arraybuffer', null, withCredentials);
      }
      if (mediaTypes) {
        try {
          var commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);
          if (commonMediaType === 'image/') {
            return this._httpGetMultipartImage(url, mediaTypes, byteRange, false, false, progressCallback, withCredentials);
          }
        } catch (e) {
          // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream
        }
      }

      // Just use the media types provided
      return this._httpGetMultipartApplicationOctetStream(url, mediaTypes, byteRange, false, progressCallback, withCredentials);
    }
    /**
     * Stores DICOM Instances.
     *
     * @param {Object} options
     * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format
     * @param {String} [options.studyInstanceUID] - Study Instance UID
     * @param {XMLHttpRequest} [options.request] - if specified, the request to use, otherwise one will be created; useful for adding custom upload and abort listeners/objects
     * @returns {Promise} Response message
     */
  }, {
    key: "storeInstances",
    value: function storeInstances(options) {
      if (!('datasets' in options)) {
        throw new Error('datasets are required for storing');
      }
      var url = "".concat(this.stowURL, "/studies");
      if ('studyInstanceUID' in options) {
        url += "/".concat(options.studyInstanceUID);
      }
      var _multipartEncode = multipartEncode(options.datasets),
        data = _multipartEncode.data,
        boundary = _multipartEncode.boundary;
      var headers = {
        'Content-Type': "multipart/related; type=\"application/dicom\"; boundary=\"".concat(boundary, "\"")
      };
      var _options$withCredenti4 = options.withCredentials,
        withCredentials = _options$withCredenti4 === void 0 ? false : _options$withCredenti4;
      return this._httpPost(url, headers, data, options.progressCallback, withCredentials, options.request);
    }
  }], [{
    key: "_parseQueryParameters",
    value: function _parseQueryParameters() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var queryString = '?';
      Object.keys(params).forEach(function (key, index) {
        if (index !== 0) {
          queryString += '&';
        }
        queryString += "".concat(key, "=").concat(encodeURIComponent(params[key]));
      });
      return queryString;
    }
  }, {
    key: "_assertMediaTypeIsValid",
    value: function _assertMediaTypeIsValid(mediaType) {
      if (!mediaType) {
        throw new Error("Not a valid media type: ".concat(mediaType));
      }
      var sepIndex = mediaType.indexOf('/');
      if (sepIndex === -1) {
        throw new Error("Not a valid media type: ".concat(mediaType));
      }
      var mediaTypeType = mediaType.slice(0, sepIndex);
      var types = ['application', 'image', 'text', 'video'];
      if (!types.includes(mediaTypeType)) {
        throw new Error("Not a valid media type: ".concat(mediaType));
      }
      if (mediaType.slice(sepIndex + 1).includes('/')) {
        throw new Error("Not a valid media type: ".concat(mediaType));
      }
    }
  }, {
    key: "_parseMediaType",
    value: function _parseMediaType(mediaType) {
      DICOMwebClient._assertMediaTypeIsValid(mediaType);
      return mediaType.split('/');
    }
    /**
     * Builds an accept header field value for HTTP GET request messages.
     *
     * @param {Object[]} mediaTypes - Acceptable media types
     * @param {Object[]} supportedMediaTypes - Supported media types
     * @return {*}
     * @private
     */
  }, {
    key: "_buildAcceptHeaderFieldValue",
    value: function _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {
      if (!Array.isArray(mediaTypes)) {
        throw new Error('Acceptable media types must be provided as an Array');
      }
      var fieldValueParts = mediaTypes.map(function (item) {
        var mediaType = item.mediaType;
        DICOMwebClient._assertMediaTypeIsValid(mediaType);
        if (!supportedMediaTypes.includes(mediaType)) {
          throw new Error("Media type ".concat(mediaType, " is not supported for requested resource"));
        }
        return mediaType;
      });
      return fieldValueParts.join(', ');
    }
    /**
     * Builds an accept header field value for HTTP GET multipart request
     * messages.  Will throw an exception if no media types are found which are acceptable,
     * but will only log a verbose level message when types are specified which are
     * not acceptable.  This allows requesting several types with having to know
     * whether they are all acceptable or not.
     *
     * @param {Object[]} mediaTypes - Acceptable media types
     * @param {Object[]} supportedMediaTypes - Supported media types
     * @private
     */
  }, {
    key: "_buildMultipartAcceptHeaderFieldValue",
    value: function _buildMultipartAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {
      var _this2 = this;
      if (!Array.isArray(mediaTypes)) {
        throw new Error('Acceptable media types must be provided as an Array');
      }
      if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {
        throw new Error('Supported media types must be provided as an Array or an Object');
      }
      var fieldValueParts = [];
      mediaTypes.forEach(function (item) {
        var transferSyntaxUID = item.transferSyntaxUID,
          mediaType = item.mediaType;
        DICOMwebClient._assertMediaTypeIsValid(mediaType);
        var fieldValue = "multipart/related; type=\"".concat(mediaType, "\"");
        if (isObject(supportedMediaTypes)) {
          // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID
          // to one or more Media Types
          if (!Object.values(supportedMediaTypes).flat(1).includes(mediaType)) {
            if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {
              debugLog("Media type ".concat(mediaType, " is not supported for requested resource"));
              return;
            }
          }
          if (transferSyntaxUID) {
            if (transferSyntaxUID !== '*') {
              if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {
                throw new Error("Transfer syntax ".concat(transferSyntaxUID, " is not supported for requested resource"));
              }
              var expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];
              if (!expectedMediaTypes.includes(mediaType)) {
                var actualType = DICOMwebClient._parseMediaType(mediaType)[0];
                expectedMediaTypes.map(function (expectedMediaType) {
                  var expectedType = DICOMwebClient._parseMediaType(expectedMediaType)[0];
                  var haveSameType = actualType === expectedType;
                  if (haveSameType && (mediaType.endsWith('/*') || mediaType.endsWith('/'))) {
                    return;
                  }
                  throw new Error("Transfer syntax ".concat(transferSyntaxUID, " is not supported for requested resource"));
                });
              }
            }
            fieldValue += "; transfer-syntax=".concat(transferSyntaxUID);
          }
        } else if (Array.isArray(supportedMediaTypes) && !supportedMediaTypes.includes(mediaType)) {
          if (_this2.verbose) {
            console.warn("Media type ".concat(mediaType, " is not supported for requested resource"));
          }
          return;
        }
        fieldValueParts.push(fieldValue);
      });
      if (!fieldValueParts.length) {
        throw new Error("No acceptable media types found among ".concat(JSON.stringify(mediaTypes)));
      }
      return fieldValueParts.join(', ');
    }
    /**
     * Builds a range header field value for HTTP GET request messages.
     *
     * @param {Array} byteRange - Start and end of byte range
     * @returns {String} Range header field value
     * @private
     */
  }, {
    key: "_buildRangeHeaderFieldValue",
    value: function _buildRangeHeaderFieldValue() {
      var byteRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (byteRange.length === 1) {
        return "bytes=".concat(byteRange[0], "-");
      }
      if (byteRange.length === 2) {
        return "bytes=".concat(byteRange[0], "-").concat(byteRange[1]);
      }
      return 'bytes=0-';
    }
    /**
     * Gets types that are shared among acceptable media types.
     *
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @private
     * @returns {String[]} Types that are shared among acceptable media types
     */
  }, {
    key: "_getSharedMediaTypes",
    value: function _getSharedMediaTypes(mediaTypes) {
      var types = new Set();
      if (!mediaTypes || !mediaTypes.length) {
        return types;
      }
      mediaTypes.forEach(function (item) {
        var mediaType = item.mediaType;
        var type = DICOMwebClient._parseMediaType(mediaType)[0];
        types.add("".concat(type, "/"));
      });
      return Array.from(types);
    }
    /**
     * Gets common base type of acceptable media types and asserts that only
     one type is specified. For example, ``("image/jpeg", "image/jp2")``
     will pass, but ``("image/jpeg", "video/mpeg2")`` will raise an
     exception.
     *
     * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the
     corresponding transfer syntaxes
     * @private
     * @returns {String[]} Common media type, eg `image/` for the above example.
     */
  }, {
    key: "_getCommonMediaType",
    value: function _getCommonMediaType(mediaTypes) {
      if (!mediaTypes || !mediaTypes.length) {
        throw new Error('No acceptable media types provided');
      }
      var sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);
      if (sharedMediaTypes.length === 0) {
        throw new Error('No common acceptable media type could be identified.');
      } else if (sharedMediaTypes.length > 1) {
        throw new Error('Acceptable media types must have the same type.');
      }
      return sharedMediaTypes[0];
    }
  }]);
  return DICOMwebClient;
}();

function findSubstring(str, before, after) {
  var beforeIndex = str.lastIndexOf(before) + before.length;
  if (beforeIndex < before.length) {
    return null;
  }
  if (after !== undefined) {
    var afterIndex = str.lastIndexOf(after);
    if (afterIndex < 0) {
      return null;
    }
    return str.substring(beforeIndex, afterIndex);
  }
  return str.substring(beforeIndex);
}
function getStudyInstanceUIDFromUri(uri) {
  var uid = findSubstring(uri, 'studies/', '/series');
  if (!uid) {
    uid = findSubstring(uri, 'studies/');
  }
  if (!uid) {
    console.debug("Study Instance UID could not be dertermined from URI \"".concat(uri, "\""));
  }
  return uid;
}
function getSeriesInstanceUIDFromUri(uri) {
  var uid = findSubstring(uri, 'series/', '/instances');
  if (!uid) {
    uid = findSubstring(uri, 'series/');
  }
  if (!uid) {
    console.debug("Series Instance UID could not be dertermined from URI \"".concat(uri, "\""));
  }
  return uid;
}
function getSOPInstanceUIDFromUri(uri) {
  var uid = findSubstring(uri, '/instances/', '/frames');
  if (!uid) {
    uid = findSubstring(uri, '/instances/', '/metadata');
  }
  if (!uid) {
    uid = findSubstring(uri, '/instances/');
  }
  if (!uid) {
    console.debug("SOP Instance UID could not be dertermined from URI\"".concat(uri, "\""));
  }
  return uid;
}
function getFrameNumbersFromUri(uri) {
  var numbers = findSubstring(uri, '/frames/', '/rendered');
  if (!numbers) {
    numbers = findSubstring(uri, '/frames/');
  }
  if (numbers === undefined) {
    console.debug("Frame Numbers could not be dertermined from URI\"".concat(uri, "\""));
  }
  return numbers.split(',');
}

var version = '0.5.2';

var api = {
  DICOMwebClient: DICOMwebClient
};
var utils = {
  getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,
  getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,
  getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,
  getFrameNumbersFromUri: getFrameNumbersFromUri
};


//# sourceMappingURL=dicomweb-client.es.js.map


/***/ }),

/***/ 93008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 75178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188),
    root = __webpack_require__(37183);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 13615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(48342),
    hashDelete = __webpack_require__(9184),
    hashGet = __webpack_require__(7747),
    hashHas = __webpack_require__(74287),
    hashSet = __webpack_require__(80007);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 60789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(57752),
    listCacheDelete = __webpack_require__(718),
    listCacheGet = __webpack_require__(57849),
    listCacheHas = __webpack_require__(43957),
    listCacheSet = __webpack_require__(50845);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 48561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188),
    root = __webpack_require__(37183);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 91451:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(35674),
    mapCacheDelete = __webpack_require__(11036),
    mapCacheGet = __webpack_require__(90031),
    mapCacheHas = __webpack_require__(21907),
    mapCacheSet = __webpack_require__(60971);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 1490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188),
    root = __webpack_require__(37183);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 96775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188),
    root = __webpack_require__(37183);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 48869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(91451),
    setCacheAdd = __webpack_require__(86810),
    setCacheHas = __webpack_require__(75813);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 92823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(60789),
    stackClear = __webpack_require__(88926),
    stackDelete = __webpack_require__(22680),
    stackGet = __webpack_require__(73851),
    stackHas = __webpack_require__(98423),
    stackSet = __webpack_require__(3967);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 16846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(37183);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 88985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188),
    root = __webpack_require__(37183);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 20607:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 40836:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 70661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(40142),
    isArguments = __webpack_require__(95962),
    isArray = __webpack_require__(64383),
    isBuffer = __webpack_require__(78098),
    isIndex = __webpack_require__(84683),
    isTypedArray = __webpack_require__(63905);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 26138:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 65862:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 87938:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 72177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(9142),
    eq = __webpack_require__(29830);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ 40435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(29830);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 90267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(26837),
    keys = __webpack_require__(38420);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ 55240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(26837),
    keysIn = __webpack_require__(53435);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ 9142:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(83733);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ 69557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(92823),
    arrayEach = __webpack_require__(20607),
    assignValue = __webpack_require__(72177),
    baseAssign = __webpack_require__(90267),
    baseAssignIn = __webpack_require__(55240),
    cloneBuffer = __webpack_require__(6064),
    copyArray = __webpack_require__(28601),
    copySymbols = __webpack_require__(2881),
    copySymbolsIn = __webpack_require__(26186),
    getAllKeys = __webpack_require__(53300),
    getAllKeysIn = __webpack_require__(44667),
    getTag = __webpack_require__(58355),
    initCloneArray = __webpack_require__(86203),
    initCloneByTag = __webpack_require__(57981),
    initCloneObject = __webpack_require__(50235),
    isArray = __webpack_require__(64383),
    isBuffer = __webpack_require__(78098),
    isMap = __webpack_require__(4024),
    isObject = __webpack_require__(46015),
    isSet = __webpack_require__(88802),
    keys = __webpack_require__(38420),
    keysIn = __webpack_require__(53435);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ 61534:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(46015);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ 14183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(76895),
    createBaseEach = __webpack_require__(19835);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ 61311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(37747);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ 76895:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(61311),
    keys = __webpack_require__(38420);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ 92748:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(84679),
    toKey = __webpack_require__(54671);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 59169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(65862),
    isArray = __webpack_require__(64383);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 71607:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ 23871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(16990),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 93028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(87114),
    isObjectLike = __webpack_require__(46184);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 87114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(92823),
    equalArrays = __webpack_require__(55237),
    equalByTag = __webpack_require__(53728),
    equalObjects = __webpack_require__(45355),
    getTag = __webpack_require__(58355),
    isArray = __webpack_require__(64383),
    isBuffer = __webpack_require__(78098),
    isTypedArray = __webpack_require__(63905);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 10162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(58355),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ 49121:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(92823),
    baseIsEqual = __webpack_require__(93028);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ 73829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(94360),
    isMasked = __webpack_require__(67234),
    isObject = __webpack_require__(46015),
    toSource = __webpack_require__(70275);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 18344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(58355),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ 84271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(16990),
    isLength = __webpack_require__(31784),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 94207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(12801),
    baseMatchesProperty = __webpack_require__(72208),
    identity = __webpack_require__(69090),
    isArray = __webpack_require__(64383),
    property = __webpack_require__(46062);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ 29966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(88089),
    nativeKeys = __webpack_require__(6128);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 7641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(46015),
    isPrototype = __webpack_require__(88089),
    nativeKeysIn = __webpack_require__(65567);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ 35218:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(14183),
    isArrayLike = __webpack_require__(19592);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ 12801:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(49121),
    getMatchData = __webpack_require__(59406),
    matchesStrictComparable = __webpack_require__(76459);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ 72208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(93028),
    get = __webpack_require__(29650),
    hasIn = __webpack_require__(2993),
    isKey = __webpack_require__(39668),
    isStrictComparable = __webpack_require__(48938),
    matchesStrictComparable = __webpack_require__(76459),
    toKey = __webpack_require__(54671);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ 55351:
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ 54953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(92748);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ 40142:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 84742:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(7187),
    arrayMap = __webpack_require__(26138),
    isArray = __webpack_require__(64383),
    isSymbol = __webpack_require__(63536);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 26143:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 37773:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 54420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(69090);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ 84679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(64383),
    isKey = __webpack_require__(39668),
    stringToPath = __webpack_require__(30412),
    toString = __webpack_require__(12832);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 73911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(16846);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ 6064:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(37183);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ 63887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(73911);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ 31871:
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ 45938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(7187);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ 11671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(73911);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ 28601:
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ 26837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(72177),
    baseAssignValue = __webpack_require__(9142);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ 2881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(26837),
    getSymbols = __webpack_require__(19946);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ 26186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(26837),
    getSymbolsIn = __webpack_require__(51693);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ 85171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(37183);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 19835:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(19592);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ 37747:
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ 83733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 55237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(48869),
    arraySome = __webpack_require__(87938),
    cacheHas = __webpack_require__(37773);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 53728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(7187),
    Uint8Array = __webpack_require__(16846),
    eq = __webpack_require__(29830),
    equalArrays = __webpack_require__(55237),
    mapToArray = __webpack_require__(58887),
    setToArray = __webpack_require__(28629);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 45355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(53300);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 53300:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(59169),
    getSymbols = __webpack_require__(19946),
    keys = __webpack_require__(38420);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 44667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(59169),
    getSymbolsIn = __webpack_require__(51693),
    keysIn = __webpack_require__(53435);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ 18037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(65912);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 59406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(48938),
    keys = __webpack_require__(38420);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ 33188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(73829),
    getValue = __webpack_require__(91870);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 79637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(61429);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ 19946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(40836),
    stubArray = __webpack_require__(16499);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 51693:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(65862),
    getPrototype = __webpack_require__(79637),
    getSymbols = __webpack_require__(19946),
    stubArray = __webpack_require__(16499);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ 58355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(75178),
    Map = __webpack_require__(48561),
    Promise = __webpack_require__(1490),
    Set = __webpack_require__(96775),
    WeakMap = __webpack_require__(88985),
    baseGetTag = __webpack_require__(16990),
    toSource = __webpack_require__(70275);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 91870:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 53852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(84679),
    isArguments = __webpack_require__(95962),
    isArray = __webpack_require__(64383),
    isIndex = __webpack_require__(84683),
    isLength = __webpack_require__(31784),
    toKey = __webpack_require__(54671);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ 48342:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(21960);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 9184:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 7747:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(21960);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 74287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(21960);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 80007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(21960);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 86203:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ 57981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(73911),
    cloneDataView = __webpack_require__(63887),
    cloneRegExp = __webpack_require__(31871),
    cloneSymbol = __webpack_require__(45938),
    cloneTypedArray = __webpack_require__(11671);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ 50235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(61534),
    getPrototype = __webpack_require__(79637),
    isPrototype = __webpack_require__(88089);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ 84683:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 39668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(64383),
    isSymbol = __webpack_require__(63536);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 65912:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 67234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(85171);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 88089:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 48938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(46015);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ 57752:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(40435);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 57849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(40435);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 43957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(40435);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 50845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(40435);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 35674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(13615),
    ListCache = __webpack_require__(60789),
    Map = __webpack_require__(48561);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 11036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(18037);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 90031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(18037);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 21907:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(18037);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 60971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(18037);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 58887:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 76459:
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ 72110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(99098);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 21960:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(33188);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 6128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(61429);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 65567:
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ 43271:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(75194);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 61429:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 86810:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 75813:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 28629:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 88926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(60789);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 22680:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 73851:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 98423:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 3967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(60789),
    Map = __webpack_require__(48561),
    MapCache = __webpack_require__(91451);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 30412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(72110);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 54671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(63536);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 70275:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 81285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(69557);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ 29830:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 59741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(76895),
    castFunction = __webpack_require__(54420);

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

module.exports = forOwn;


/***/ }),

/***/ 29650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(92748);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 2993:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(71607),
    hasPath = __webpack_require__(53852);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ 69090:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 95962:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(23871),
    isObjectLike = __webpack_require__(46184);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 64383:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 19592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(94360),
    isLength = __webpack_require__(31784);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 78098:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(37183),
    stubFalse = __webpack_require__(11329);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 94360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(16990),
    isObject = __webpack_require__(46015);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 31784:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 4024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(10162),
    baseUnary = __webpack_require__(26143),
    nodeUtil = __webpack_require__(43271);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ 5229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(16990),
    getPrototype = __webpack_require__(79637),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ 88802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(18344),
    baseUnary = __webpack_require__(26143),
    nodeUtil = __webpack_require__(43271);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ 87561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(16990),
    isArray = __webpack_require__(64383),
    isObjectLike = __webpack_require__(46184);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ 63905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(84271),
    baseUnary = __webpack_require__(26143),
    nodeUtil = __webpack_require__(43271);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 38420:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(70661),
    baseKeys = __webpack_require__(29966),
    isArrayLike = __webpack_require__(19592);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 53435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(70661),
    baseKeysIn = __webpack_require__(7641),
    isArrayLike = __webpack_require__(19592);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ 764:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(26138),
    baseIteratee = __webpack_require__(94207),
    baseMap = __webpack_require__(35218),
    isArray = __webpack_require__(64383);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ 99098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(91451);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 46062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(55351),
    basePropertyDeep = __webpack_require__(54953),
    isKey = __webpack_require__(39668),
    toKey = __webpack_require__(54671);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ 16499:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 11329:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 12832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(84742);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 69175:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  xk: () => (/* reexport */ chrome_Chrome)
});

// UNUSED EXPORTS: AlphaPicker, BlockPicker, CirclePicker, CompactPicker, CustomPicker, GithubPicker, GooglePicker, HuePicker, MaterialPicker, PhotoshopPicker, SketchPicker, SliderPicker, SwatchesPicker, TwitterPicker, default

// EXTERNAL MODULE: ../../../node_modules/react/index.js
var react = __webpack_require__(86326);
// EXTERNAL MODULE: ../../../node_modules/reactcss/lib/index.js
var lib = __webpack_require__(56457);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/alpha.js
var calculateChange = function calculateChange(e, hsl, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (direction === 'vertical') {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }

    if (hsl.a !== a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: a,
        source: 'rgb'
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }

    if (initialA !== _a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a,
        source: 'rgb'
      };
    }
  }
  return null;
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/checkboard.js
var checkboardCache = {};

var render = function render(c1, c2, size, serverCanvas) {
  if (typeof document === 'undefined' && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext('2d');
  if (!ctx) {
    return null;
  } // If no context can be found, return early.
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};

var get = function get(c1, c2, size, serverCanvas) {
  var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');

  if (checkboardCache[key]) {
    return checkboardCache[key];
  }

  var checkboard = render(c1, c2, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Checkboard.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var Checkboard = function Checkboard(_ref) {
  var white = _ref.white,
      grey = _ref.grey,
      size = _ref.size,
      renderers = _ref.renderers,
      borderRadius = _ref.borderRadius,
      boxShadow = _ref.boxShadow,
      children = _ref.children;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      grid: {
        borderRadius: borderRadius,
        boxShadow: boxShadow,
        absolute: '0px 0px 0px 0px',
        background: 'url(' + get(white, grey, size, renderers.canvas) + ') center left'
      }
    }
  });
  return (0,react.isValidElement)(children) ? react.cloneElement(children, _extends({}, children.props, { style: _extends({}, children.props.style, styles.grid) })) : react.createElement('div', { style: styles.grid });
};

Checkboard.defaultProps = {
  size: 8,
  white: 'transparent',
  grey: 'rgba(0,0,0,.08)',
  renderers: {}
};

/* harmony default export */ const common_Checkboard = (Checkboard);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Alpha.js
var Alpha_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var Alpha = function (_ref) {
  _inherits(Alpha, _ref);

  function Alpha() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Alpha);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
      var change = calculateChange(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleChange);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Alpha, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var rgb = this.props.rgb;
      var styles = (0,lib/* default */.Ay)({
        'default': {
          alpha: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: '0px 0px 0px 0px',
            overflow: 'hidden',
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: 'relative',
            height: '100%',
            margin: '0 3px'
          },
          pointer: {
            position: 'absolute',
            left: rgb.a * 100 + '%'
          },
          slider: {
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            marginTop: '1px',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          gradient: {
            background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + '%'
          }
        },
        'overwrite': Alpha_extends({}, this.props.style)
      }, {
        vertical: this.props.direction === 'vertical',
        overwrite: true
      });

      return react.createElement(
        'div',
        { style: styles.alpha },
        react.createElement(
          'div',
          { style: styles.checkboard },
          react.createElement(common_Checkboard, { renderers: this.props.renderers })
        ),
        react.createElement('div', { style: styles.gradient }),
        react.createElement(
          'div',
          {
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          react.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? react.createElement(this.props.pointer, this.props) : react.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Alpha;
}(react.PureComponent || react.Component);

/* harmony default export */ const common_Alpha = (Alpha);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/EditableInput.js
var EditableInput_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function EditableInput_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function EditableInput_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function EditableInput_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var DEFAULT_ARROW_OFFSET = 1;

var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue(value) {
  return Number(String(value).replace(/%/g, ''));
};

var idCounter = 1;

var EditableInput = function (_ref) {
  EditableInput_inherits(EditableInput, _ref);

  function EditableInput(props) {
    EditableInput_classCallCheck(this, EditableInput);

    var _this = EditableInput_possibleConstructorReturn(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));

    _this.handleBlur = function () {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };

    _this.handleChange = function (e) {
      _this.setUpdatedValue(e.target.value, e);
    };

    _this.handleKeyDown = function (e) {
      // In case `e.target.value` is a percentage remove the `%` character
      // and update accordingly with a percentage
      // https://github.com/casesandberg/react-color/issues/383
      var value = getNumberValue(e.target.value);
      if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
        var offset = _this.getArrowOffset();
        var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset : value - offset;

        _this.setUpdatedValue(updatedValue, e);
      }
    };

    _this.handleDrag = function (e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
        }
      }
    };

    _this.handleMouseDown = function (e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener('mousemove', _this.handleDrag);
        window.addEventListener('mouseup', _this.handleMouseUp);
      }
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleDrag);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };

    _this.inputId = 'rc-editable-input-' + idCounter++;
    return _this;
  }

  EditableInput_createClass(EditableInput, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'getValueObjectWithLabel',
    value: function getValueObjectWithLabel(value) {
      return _defineProperty({}, this.props.label, value);
    }
  }, {
    key: 'getArrowOffset',
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: 'setUpdatedValue',
    value: function setUpdatedValue(value, e) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e);

      this.setState({ value: value });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0,lib/* default */.Ay)({
        'default': {
          wrap: {
            position: 'relative'
          }
        },
        'user-override': {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        'dragLabel-true': {
          label: {
            cursor: 'ew-resize'
          }
        }
      }, {
        'user-override': true
      }, this.props);

      return react.createElement(
        'div',
        { style: styles.wrap },
        react.createElement('input', {
          id: this.inputId,
          style: styles.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: 'false'
        }),
        this.props.label && !this.props.hideLabel ? react.createElement(
          'label',
          {
            htmlFor: this.inputId,
            style: styles.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);

  return EditableInput;
}(react.PureComponent || react.Component);

/* harmony default export */ const common_EditableInput = (EditableInput);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/hue.js
var hue_calculateChange = function calculateChange(e, direction, hsl, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (direction === 'vertical') {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }

    if (hsl.h !== h) {
      return {
        h: h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: 'hsl'
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }

    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: 'hsl'
      };
    }
  }
  return null;
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Hue.js
var Hue_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Hue_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Hue_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Hue_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Hue = function (_ref) {
  Hue_inherits(Hue, _ref);

  function Hue() {
    var _ref2;

    var _temp, _this, _ret;

    Hue_classCallCheck(this, Hue);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = Hue_possibleConstructorReturn(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e) {
      var change = hue_calculateChange(e, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === 'function' && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _temp), Hue_possibleConstructorReturn(_this, _ret);
  }

  Hue_createClass(Hue, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props$direction = this.props.direction,
          direction = _props$direction === undefined ? 'horizontal' : _props$direction;


      var styles = (0,lib/* default */.Ay)({
        'default': {
          hue: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: '0 2px',
            position: 'relative',
            height: '100%',
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            left: this.props.hsl.h * 100 / 360 + '%'
          },
          slider: {
            marginTop: '1px',
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          pointer: {
            left: '0px',
            top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
          }
        }
      }, { vertical: direction === 'vertical' });

      return react.createElement(
        'div',
        { style: styles.hue },
        react.createElement(
          'div',
          {
            className: 'hue-' + direction,
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          react.createElement(
            'style',
            null,
            '\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          '
          ),
          react.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? react.createElement(this.props.pointer, this.props) : react.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Hue;
}(react.PureComponent || react.Component);

/* harmony default export */ const common_Hue = (Hue);
// EXTERNAL MODULE: ../../../node_modules/prop-types/index.js
var prop_types = __webpack_require__(97598);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ const _listCacheClear = (listCacheClear);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ const lodash_es_eq = (eq);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_assocIndexOf.js


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ const _assocIndexOf = (assocIndexOf);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheDelete.js


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ const _listCacheDelete = (listCacheDelete);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheGet.js


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ const _listCacheGet = (listCacheGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheHas.js


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ const _listCacheHas = (listCacheHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_listCacheSet.js


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ const _listCacheSet = (listCacheSet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_ListCache.js






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

/* harmony default export */ const _ListCache = (ListCache);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackClear.js


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

/* harmony default export */ const _stackClear = (stackClear);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ const _stackDelete = (stackDelete);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ const _stackGet = (stackGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ const _stackHas = (stackHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_freeGlobal.js
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ const _freeGlobal = (freeGlobal);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_root.js


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

/* harmony default export */ const _root = (root);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Symbol.js


/** Built-in value references. */
var _Symbol_Symbol = _root.Symbol;

/* harmony default export */ const _Symbol = (_Symbol_Symbol);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getRawTag.js


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ const _getRawTag = (getRawTag);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ const _objectToString = (objectToString);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseGetTag.js




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

/* harmony default export */ const _baseGetTag = (baseGetTag);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ const lodash_es_isObject = (isObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isFunction.js



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ const lodash_es_isFunction = (isFunction);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_coreJsData.js


/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

/* harmony default export */ const _coreJsData = (coreJsData);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isMasked.js


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ const _isMasked = (isMasked);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ const _toSource = (toSource);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsNative.js





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;

/** Used to check objects for own properties. */
var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }
  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ const _baseIsNative = (baseIsNative);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ const _getValue = (getValue);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getNative.js



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ const _getNative = (getNative);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Map.js



/* Built-in method references that are verified to be native. */
var Map = _getNative(_root, 'Map');

/* harmony default export */ const _Map = (Map);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeCreate.js


/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

/* harmony default export */ const _nativeCreate = (nativeCreate);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashClear.js


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ const _hashClear = (hashClear);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const _hashDelete = (hashDelete);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashGet.js


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _hashGet_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ const _hashGet = (hashGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashHas.js


/** Used for built-in method references. */
var _hashHas_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ const _hashHas = (hashHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hashSet.js


/** Used to stand-in for `undefined` hash values. */
var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ const _hashSet = (hashSet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Hash.js






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

/* harmony default export */ const _Hash = (Hash);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheClear.js




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

/* harmony default export */ const _mapCacheClear = (mapCacheClear);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ const _isKeyable = (isKeyable);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getMapData.js


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ const _getMapData = (getMapData);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheDelete.js


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const _mapCacheDelete = (mapCacheDelete);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheGet.js


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ const _mapCacheGet = (mapCacheGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheHas.js


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ const _mapCacheHas = (mapCacheHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapCacheSet.js


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ const _mapCacheSet = (mapCacheSet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_MapCache.js






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

/* harmony default export */ const _MapCache = (MapCache);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stackSet.js




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ const _stackSet = (stackSet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Stack.js







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

/* harmony default export */ const _Stack = (Stack);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_defineProperty.js


var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ const lodash_es_defineProperty = (defineProperty);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseAssignValue.js


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && lodash_es_defineProperty) {
    lodash_es_defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ const _baseAssignValue = (baseAssignValue);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_assignMergeValue.js



/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !lodash_es_eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ const _assignMergeValue = (assignMergeValue);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_createBaseFor.js
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ const _createBaseFor = (createBaseFor);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseFor.js


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

/* harmony default export */ const _baseFor = (baseFor);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneBuffer.js


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ const _cloneBuffer = (cloneBuffer);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Uint8Array.js


/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

/* harmony default export */ const _Uint8Array = (Uint8Array);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneArrayBuffer.js


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

/* harmony default export */ const _cloneArrayBuffer = (cloneArrayBuffer);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cloneTypedArray.js


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ const _cloneTypedArray = (cloneTypedArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copyArray.js
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ const _copyArray = (copyArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseCreate.js


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!lodash_es_isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ const _baseCreate = (baseCreate);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ const _overArg = (overArg);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getPrototype.js


/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

/* harmony default export */ const _getPrototype = (getPrototype);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || _isPrototype_objectProto;

  return value === proto;
}

/* harmony default export */ const _isPrototype = (isPrototype);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_initCloneObject.js




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

/* harmony default export */ const _initCloneObject = (initCloneObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ const lodash_es_isObjectLike = (isObjectLike);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsArguments.js



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ const _baseIsArguments = (baseIsArguments);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArguments.js



/** Used for built-in method references. */
var isArguments_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ const lodash_es_isArguments = (isArguments);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ const lodash_es_isArray = (isArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ const lodash_es_isLength = (isLength);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArrayLike.js



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ const lodash_es_isArrayLike = (isArrayLike);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isArrayLikeObject.js



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isArrayLike(value);
}

/* harmony default export */ const lodash_es_isArrayLikeObject = (isArrayLikeObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/stubFalse.js
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ const lodash_es_stubFalse = (stubFalse);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isBuffer.js



/** Detect free variable `exports`. */
var isBuffer_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var isBuffer_freeModule = isBuffer_freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var isBuffer_moduleExports = isBuffer_freeModule && isBuffer_freeModule.exports === isBuffer_freeExports;

/** Built-in value references. */
var isBuffer_Buffer = isBuffer_moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = isBuffer_Buffer ? isBuffer_Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || lodash_es_stubFalse;

/* harmony default export */ const lodash_es_isBuffer = (isBuffer);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isPlainObject.js




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var isPlainObject_funcProto = Function.prototype,
    isPlainObject_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var isPlainObject_funcToString = isPlainObject_funcProto.toString;

/** Used to check objects for own properties. */
var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = isPlainObject_funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    isPlainObject_funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ const lodash_es_isPlainObject = (isPlainObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsTypedArray.js




/** `Object#toString` result references. */
var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    _baseIsTypedArray_objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) &&
    lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ const _baseIsTypedArray = (baseIsTypedArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ const _baseUnary = (baseUnary);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nodeUtil.js


/** Detect free variable `exports`. */
var _nodeUtil_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var _nodeUtil_freeModule = _nodeUtil_freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var _nodeUtil_moduleExports = _nodeUtil_freeModule && _nodeUtil_freeModule.exports === _nodeUtil_freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = _nodeUtil_moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = _nodeUtil_freeModule && _nodeUtil_freeModule.require && _nodeUtil_freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ const _nodeUtil = (nodeUtil);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isTypedArray.js




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

/* harmony default export */ const lodash_es_isTypedArray = (isTypedArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_safeGet.js
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ const _safeGet = (safeGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_assignValue.js



/** Used for built-in method references. */
var _assignValue_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ const _assignValue = (assignValue);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_copyObject.js



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ const _copyObject = (copyObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ const _baseTimes = (baseTimes);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var _isIndex_MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? _isIndex_MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ const _isIndex = (isIndex);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayLikeKeys.js







/** Used for built-in method references. */
var _arrayLikeKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && lodash_es_isBuffer(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const _arrayLikeKeys = (arrayLikeKeys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const _nativeKeysIn = (nativeKeysIn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseKeysIn.js




/** Used for built-in method references. */
var _baseKeysIn_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const _baseKeysIn = (baseKeysIn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/keysIn.js




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ const lodash_es_keysIn = (keysIn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/toPlainObject.js



/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, lodash_es_keysIn(value));
}

/* harmony default export */ const lodash_es_toPlainObject = (toPlainObject);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseMergeDeep.js
















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = lodash_es_isArray(srcValue),
        isBuff = !isArr && lodash_es_isBuffer(srcValue),
        isTyped = !isArr && !isBuff && lodash_es_isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (lodash_es_isArray(objValue)) {
        newValue = objValue;
      }
      else if (lodash_es_isArrayLikeObject(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (lodash_es_isPlainObject(srcValue) || lodash_es_isArguments(srcValue)) {
      newValue = objValue;
      if (lodash_es_isArguments(objValue)) {
        newValue = lodash_es_toPlainObject(objValue);
      }
      else if (!lodash_es_isObject(objValue) || lodash_es_isFunction(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

/* harmony default export */ const _baseMergeDeep = (baseMergeDeep);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseMerge.js








/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (lodash_es_isObject(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, lodash_es_keysIn);
}

/* harmony default export */ const _baseMerge = (baseMerge);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/identity.js
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ const lodash_es_identity = (identity);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_apply.js
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ const _apply = (apply);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_overRest.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

/* harmony default export */ const _overRest = (overRest);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/constant.js
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ const lodash_es_constant = (constant);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseSetToString.js




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !lodash_es_defineProperty ? lodash_es_identity : function(func, string) {
  return lodash_es_defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': lodash_es_constant(string),
    'writable': true
  });
};

/* harmony default export */ const _baseSetToString = (baseSetToString);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_shortOut.js
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ const _shortOut = (shortOut);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_setToString.js



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

/* harmony default export */ const _setToString = (setToString);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseRest.js




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, lodash_es_identity), func + '');
}

/* harmony default export */ const _baseRest = (baseRest);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isIterateeCall.js





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!lodash_es_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (lodash_es_isArrayLike(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return lodash_es_eq(object[index], value);
  }
  return false;
}

/* harmony default export */ const _isIterateeCall = (isIterateeCall);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_createAssigner.js



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ const _createAssigner = (createAssigner);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/merge.js



/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

/* harmony default export */ const lodash_es_merge = (merge);

;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Raised.js





var Raised = function Raised(_ref) {
  var zDepth = _ref.zDepth,
      radius = _ref.radius,
      background = _ref.background,
      children = _ref.children,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      wrap: {
        position: 'relative',
        display: 'inline-block'
      },
      content: {
        position: 'relative'
      },
      bg: {
        absolute: '0px 0px 0px 0px',
        boxShadow: '0 ' + zDepth + 'px ' + zDepth * 4 + 'px rgba(0,0,0,.24)',
        borderRadius: radius,
        background: background
      }
    },
    'zDepth-0': {
      bg: {
        boxShadow: 'none'
      }
    },

    'zDepth-1': {
      bg: {
        boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
      }
    },
    'zDepth-2': {
      bg: {
        boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
      }
    },
    'zDepth-3': {
      bg: {
        boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
      }
    },
    'zDepth-4': {
      bg: {
        boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
      }
    },
    'zDepth-5': {
      bg: {
        boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
      }
    },
    'square': {
      bg: {
        borderRadius: '0'
      }
    },
    'circle': {
      bg: {
        borderRadius: '50%'
      }
    }
  }, passedStyles), { 'zDepth-1': zDepth === 1 });

  return react.createElement(
    'div',
    { style: styles.wrap },
    react.createElement('div', { style: styles.bg }),
    react.createElement(
      'div',
      { style: styles.content },
      children
    )
  );
};

Raised.propTypes = {
  background: (prop_types_default()).string,
  zDepth: prop_types_default().oneOf([0, 1, 2, 3, 4, 5]),
  radius: (prop_types_default()).number,
  styles: (prop_types_default()).object
};

Raised.defaultProps = {
  background: '#fff',
  zDepth: 1,
  radius: 2,
  styles: {}
};

/* harmony default export */ const common_Raised = (Raised);
;// CONCATENATED MODULE: ../../../node_modules/lodash-es/now.js


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root.Date.now();
};

/* harmony default export */ const lodash_es_now = (now);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_trimmedEndIndex.js
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/* harmony default export */ const _trimmedEndIndex = (trimmedEndIndex);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseTrim.js


/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/* harmony default export */ const _baseTrim = (baseTrim);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isSymbol.js



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag);
}

/* harmony default export */ const lodash_es_isSymbol = (isSymbol);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/toNumber.js




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (lodash_es_isSymbol(value)) {
    return NAN;
  }
  if (lodash_es_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = lodash_es_isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ const lodash_es_toNumber = (toNumber);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/debounce.js




/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var debounce_nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = lodash_es_toNumber(wait) || 0;
  if (lodash_es_isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? debounce_nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = lodash_es_now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(lodash_es_now());
  }

  function debounced() {
    var time = lodash_es_now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ const lodash_es_debounce = (debounce);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/throttle.js



/** Error message constants. */
var throttle_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(throttle_FUNC_ERROR_TEXT);
  }
  if (lodash_es_isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return lodash_es_debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/* harmony default export */ const lodash_es_throttle = (throttle);

;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/saturation.js
var saturation_calculateChange = function calculateChange(e, hsl, container) {
  var _container$getBoundin = container.getBoundingClientRect(),
      containerWidth = _container$getBoundin.width,
      containerHeight = _container$getBoundin.height;

  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }

  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }

  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;

  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: 'hsv'
  };
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Saturation.js
var Saturation_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Saturation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Saturation_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Saturation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Saturation = function (_ref) {
  Saturation_inherits(Saturation, _ref);

  function Saturation(props) {
    Saturation_classCallCheck(this, Saturation);

    var _this = Saturation_possibleConstructorReturn(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));

    _this.handleChange = function (e) {
      typeof _this.props.onChange === 'function' && _this.throttle(_this.props.onChange, saturation_calculateChange(e, _this.props.hsl, _this.container), e);
    };

    _this.handleMouseDown = function (e) {
      _this.handleChange(e);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener('mousemove', _this.handleChange);
      renderWindow.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.throttle = lodash_es_throttle(function (fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }

  Saturation_createClass(Saturation, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: 'getContainerRenderWindow',
    value: function getContainerRenderWindow() {
      var container = this.container;

      var renderWindow = window;
      while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener('mousemove', this.handleChange);
      renderWindow.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _ref2 = this.props.style || {},
          color = _ref2.color,
          white = _ref2.white,
          black = _ref2.black,
          pointer = _ref2.pointer,
          circle = _ref2.circle;

      var styles = (0,lib/* default */.Ay)({
        'default': {
          color: {
            absolute: '0px 0px 0px 0px',
            background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
            borderRadius: this.props.radius
          },
          white: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          black: {
            absolute: '0px 0px 0px 0px',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: 'absolute',
            top: -(this.props.hsv.v * 100) + 100 + '%',
            left: this.props.hsv.s * 100 + '%',
            cursor: 'default'
          },
          circle: {
            width: '4px',
            height: '4px',
            boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
            borderRadius: '50%',
            cursor: 'hand',
            transform: 'translate(-2px, -2px)'
          }
        },
        'custom': {
          color: color,
          white: white,
          black: black,
          pointer: pointer,
          circle: circle
        }
      }, { 'custom': !!this.props.style });

      return react.createElement(
        'div',
        {
          style: styles.color,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        react.createElement(
          'style',
          null,
          '\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        '
        ),
        react.createElement(
          'div',
          { style: styles.white, className: 'saturation-white' },
          react.createElement('div', { style: styles.black, className: 'saturation-black' }),
          react.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? react.createElement(this.props.pointer, this.props) : react.createElement('div', { style: styles.circle })
          )
        )
      );
    }
  }]);

  return Saturation;
}(react.PureComponent || react.Component);

/* harmony default export */ const common_Saturation = (Saturation);
;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayEach.js
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/* harmony default export */ const _arrayEach = (arrayEach);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_nativeKeys.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

/* harmony default export */ const _nativeKeys = (nativeKeys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseKeys.js



/** Used for built-in method references. */
var _baseKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (_baseKeys_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const _baseKeys = (baseKeys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/keys.js




/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

/* harmony default export */ const lodash_es_keys = (keys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseForOwn.js



/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && _baseFor(object, iteratee, lodash_es_keys);
}

/* harmony default export */ const _baseForOwn = (baseForOwn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_createBaseEach.js


/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!lodash_es_isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/* harmony default export */ const _createBaseEach = (createBaseEach);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseEach.js



/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = _createBaseEach(_baseForOwn);

/* harmony default export */ const _baseEach = (baseEach);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_castFunction.js


/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : lodash_es_identity;
}

/* harmony default export */ const _castFunction = (castFunction);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/forEach.js





/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = lodash_es_isArray(collection) ? _arrayEach : _baseEach;
  return func(collection, _castFunction(iteratee));
}

/* harmony default export */ const lodash_es_forEach = (forEach);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/each.js


;// CONCATENATED MODULE: ../../../node_modules/tinycolor2/esm/tinycolor.js
// This file is autogenerated. It's used to publish ESM to npm.
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};

  // If input is already a tinycolor, return itself
  if (color instanceof tinycolor) {
    return color;
  }
  // If we are called as a function, call using new instead
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;

  // Don't let the range of [0,255] come back in [0,1].
  // Potentially lose a little bit of precision here, but will fix issues where
  // .5 gets interpreted as half of the total, instead of half of 1
  // If it was supposed to be 128, this was already taken care of by `inputToRgb`
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    //http://www.w3.org/TR/AERT#color-contrast
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  },
  getLuminance: function getLuminance() {
    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360),
      s = Math.round(hsv.s * 100),
      v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl.h * 360),
      s = Math.round(hsl.s * 100),
      l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function (color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a
  };
}

// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    l: l
  };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: h,
    s: s,
    v: v
  };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h),
    f = h - i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s),
    mod = i % 6,
    r = [v, q, p, p, t, v][mod],
    g = [t, v, v, q, p, p][mod],
    b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];

  // Return a 3 character hex if possible
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];

  // Return a 4 character hex if possible
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
  if (!color1 || !color2) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function () {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};

// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h = hsv.h,
    s = hsv.s,
    v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h,
      s: s,
      v: v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function (color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};

// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function (color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function (color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function (baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level: level,
    size: size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};

// Big List of Colors
// ------------------
// <https://www.w3.org/TR/css-color-4/#named-colors>
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);

// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));

  // Automatically convert percentage into number
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }

  // Handle floating point rounding errors
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }

  // Convert into [0, 1] range if it isn't already
  return n % max / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
  return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function () {
  // <http://www.w3.org/TR/css3-values/#integers>
  var CSS_INTEGER = "[-\\+]?\\d+%?";

  // <http://www.w3.org/TR/css3-values/#number-value>
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

  // Actual matching.
  // Parentheses and commas are optional, but not required.
  // Whitespace can take the place of commas or opening paren
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }

  // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  // return valid WCAG2 parms for isReadable.
  // If input parms are invalid, return {"level":"AA", "size":"small"}
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level: level,
    size: size
  };
}



;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/color.js



var simpleCheckForValidColor = function simpleCheckForValidColor(data) {
  var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
  var checked = 0;
  var passed = 0;
  lodash_es_forEach(keysToCheck, function (letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === 's' || letter === 'l') {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};

var toState = function toState(data, oldHue) {
  var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === '000000' && rgb.a === 0;

  return {
    hsl: hsl,
    hex: transparent ? 'transparent' : '#' + hex,
    rgb: rgb,
    hsv: hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};

var isValidHex = function isValidHex(hex) {
  if (hex === 'transparent') {
    return true;
  }
  // disable hex4 and hex8
  var lh = String(hex).charAt(0) === '#' ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};

var getContrastingColor = function getContrastingColor(data) {
  if (!data) {
    return '#fff';
  }
  var col = toState(data);
  if (col.hex === 'transparent') {
    return 'rgba(0,0,0,0.4)';
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
  return yiq >= 128 ? '#000' : '#fff';
};

var red = {
  hsl: { a: 1, h: 0, l: 0.5, s: 1 },
  hex: '#ff0000',
  rgb: { r: 255, g: 0, b: 0, a: 1 },
  hsv: { h: 0, s: 1, v: 1, a: 1 }
};

var isvalidColorString = function isvalidColorString(string, type) {
  var stringWithoutDegree = string.replace('', '');
  return tinycolor(type + ' (' + stringWithoutDegree + ')')._ok;
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/ColorWrap.js
var ColorWrap_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var ColorWrap_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function ColorWrap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ColorWrap_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ColorWrap_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var ColorWrap = function ColorWrap(Picker) {
  var ColorPicker = function (_ref) {
    ColorWrap_inherits(ColorPicker, _ref);

    function ColorPicker(props) {
      ColorWrap_classCallCheck(this, ColorPicker);

      var _this = ColorWrap_possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));

      _this.handleChange = function (data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };

      _this.handleSwatchHover = function (data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };

      _this.state = ColorWrap_extends({}, toState(props.color, 0));

      _this.debounce = lodash_es_debounce(function (fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }

    ColorWrap_createClass(ColorPicker, [{
      key: 'render',
      value: function render() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }

        return react.createElement(Picker, ColorWrap_extends({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(nextProps, state) {
        return ColorWrap_extends({}, toState(nextProps.color, state.oldHue));
      }
    }]);

    return ColorPicker;
  }(react.PureComponent || react.Component);

  ColorPicker.propTypes = ColorWrap_extends({}, Picker.propTypes);

  ColorPicker.defaultProps = ColorWrap_extends({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.50,
      l: 0.20,
      a: 1
    }
  });

  return ColorPicker;
};

/* harmony default export */ const common_ColorWrap = (ColorWrap);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/helpers/interaction.js
var interaction_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var interaction_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function interaction_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function interaction_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function interaction_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable no-invalid-this */


var handleFocus = function handleFocus(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';
  return function (_React$Component) {
    interaction_inherits(Focus, _React$Component);

    function Focus() {
      var _ref;

      var _temp, _this, _ret;

      interaction_classCallCheck(this, Focus);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = interaction_possibleConstructorReturn(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function () {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function () {
        return _this.setState({ focus: false });
      }, _temp), interaction_possibleConstructorReturn(_this, _ret);
    }

    interaction_createClass(Focus, [{
      key: 'render',
      value: function render() {
        return react.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          react.createElement(Component, interaction_extends({}, this.props, this.state))
        );
      }
    }]);

    return Focus;
  }(react.Component);
};
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/Swatch.js
var Swatch_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };







var ENTER = 13;

var Swatch = function Swatch(_ref) {
  var color = _ref.color,
      style = _ref.style,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onHover = _ref.onHover,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? color : _ref$title,
      children = _ref.children,
      focus = _ref.focus,
      _ref$focusStyle = _ref.focusStyle,
      focusStyle = _ref$focusStyle === undefined ? {} : _ref$focusStyle;

  var transparent = color === 'transparent';
  var styles = (0,lib/* default */.Ay)({
    default: {
      swatch: Swatch_extends({
        background: color,
        height: '100%',
        width: '100%',
        cursor: 'pointer',
        position: 'relative',
        outline: 'none'
      }, style, focus ? focusStyle : {})
    }
  });

  var handleClick = function handleClick(e) {
    return onClick(color, e);
  };
  var handleKeyDown = function handleKeyDown(e) {
    return e.keyCode === ENTER && onClick(color, e);
  };
  var handleHover = function handleHover(e) {
    return onHover(color, e);
  };

  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover;
  }

  return react.createElement(
    'div',
    Swatch_extends({
      style: styles.swatch,
      onClick: handleClick,
      title: title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && react.createElement(common_Checkboard, {
      borderRadius: styles.swatch.borderRadius,
      boxShadow: 'inset 0 0 0 1px rgba(0,0,0,0.1)'
    })
  );
};

/* harmony default export */ const common_Swatch = (handleFocus(Swatch));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/common/index.js








;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/alpha/AlphaPointer.js



var AlphaPointer = function AlphaPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const alpha_AlphaPointer = (AlphaPointer);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/alpha/Alpha.js
var alpha_Alpha_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };







var AlphaPicker = function AlphaPicker(_ref) {
  var rgb = _ref.rgb,
      hsl = _ref.hsl,
      width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      direction = _ref.direction,
      style = _ref.style,
      renderers = _ref.renderers,
      pointer = _ref.pointer,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      alpha: {
        radius: '2px',
        style: style
      }
    }
  });

  return react.createElement(
    'div',
    { style: styles.picker, className: 'alpha-picker ' + className },
    react.createElement(common_Alpha, alpha_Alpha_extends({}, styles.alpha, {
      rgb: rgb,
      hsl: hsl,
      pointer: pointer,
      renderers: renderers,
      onChange: onChange,
      direction: direction
    }))
  );
};

AlphaPicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: alpha_AlphaPointer
};

/* harmony default export */ const alpha_Alpha = (common_ColorWrap(AlphaPicker));
;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayMap.js
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ const _arrayMap = (arrayMap);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var _setCacheAdd_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, _setCacheAdd_HASH_UNDEFINED);
  return this;
}

/* harmony default export */ const _setCacheAdd = (setCacheAdd);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_setCacheHas.js
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ const _setCacheHas = (setCacheHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_SetCache.js




/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

/* harmony default export */ const _SetCache = (SetCache);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arraySome.js
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ const _arraySome = (arraySome);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_cacheHas.js
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ const _cacheHas = (cacheHas);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_equalArrays.js




/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const _equalArrays = (equalArrays);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_mapToArray.js
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ const _mapToArray = (mapToArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_setToArray.js
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ const _setToArray = (setToArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_equalByTag.js







/** Used to compose bitmasks for value comparisons. */
var _equalByTag_COMPARE_PARTIAL_FLAG = 1,
    _equalByTag_COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var _equalByTag_boolTag = '[object Boolean]',
    _equalByTag_dateTag = '[object Date]',
    _equalByTag_errorTag = '[object Error]',
    _equalByTag_mapTag = '[object Map]',
    _equalByTag_numberTag = '[object Number]',
    _equalByTag_regexpTag = '[object RegExp]',
    _equalByTag_setTag = '[object Set]',
    _equalByTag_stringTag = '[object String]',
    _equalByTag_symbolTag = '[object Symbol]';

var _equalByTag_arrayBufferTag = '[object ArrayBuffer]',
    _equalByTag_dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case _equalByTag_dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case _equalByTag_arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case _equalByTag_boolTag:
    case _equalByTag_dateTag:
    case _equalByTag_numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return lodash_es_eq(+object, +other);

    case _equalByTag_errorTag:
      return object.name == other.name && object.message == other.message;

    case _equalByTag_regexpTag:
    case _equalByTag_stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case _equalByTag_mapTag:
      var convert = _mapToArray;

    case _equalByTag_setTag:
      var isPartial = bitmask & _equalByTag_COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= _equalByTag_COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case _equalByTag_symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/* harmony default export */ const _equalByTag = (equalByTag);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayPush.js
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* harmony default export */ const _arrayPush = (arrayPush);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseGetAllKeys.js



/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));
}

/* harmony default export */ const _baseGetAllKeys = (baseGetAllKeys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_arrayFilter.js
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ const _arrayFilter = (arrayFilter);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/stubArray.js
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ const lodash_es_stubArray = (stubArray);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getSymbols.js



/** Used for built-in method references. */
var _getSymbols_objectProto = Object.prototype;

/** Built-in value references. */
var _getSymbols_propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return _getSymbols_propertyIsEnumerable.call(object, symbol);
  });
};

/* harmony default export */ const _getSymbols = (getSymbols);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getAllKeys.js




/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);
}

/* harmony default export */ const _getAllKeys = (getAllKeys);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_equalObjects.js


/** Used to compose bitmasks for value comparisons. */
var _equalObjects_COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var _equalObjects_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _equalObjects_hasOwnProperty = _equalObjects_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & _equalObjects_COMPARE_PARTIAL_FLAG,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : _equalObjects_hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const _equalObjects = (equalObjects);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_DataView.js



/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

/* harmony default export */ const _DataView = (DataView);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Promise.js



/* Built-in method references that are verified to be native. */
var Promise = _getNative(_root, 'Promise');

/* harmony default export */ const _Promise = (Promise);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_Set.js



/* Built-in method references that are verified to be native. */
var Set = _getNative(_root, 'Set');

/* harmony default export */ const _Set = (Set);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_WeakMap.js



/* Built-in method references that are verified to be native. */
var WeakMap = _getNative(_root, 'WeakMap');

/* harmony default export */ const _WeakMap = (WeakMap);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getTag.js








/** `Object#toString` result references. */
var _getTag_mapTag = '[object Map]',
    _getTag_objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    _getTag_setTag = '[object Set]',
    _getTag_weakMapTag = '[object WeakMap]';

var _getTag_dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag) ||
    (_Map && getTag(new _Map) != _getTag_mapTag) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != _getTag_setTag) ||
    (_WeakMap && getTag(new _WeakMap) != _getTag_weakMapTag)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == _getTag_objectTag ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return _getTag_dataViewTag;
        case mapCtorString: return _getTag_mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return _getTag_setTag;
        case weakMapCtorString: return _getTag_weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ const _getTag = (getTag);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsEqualDeep.js









/** Used to compose bitmasks for value comparisons. */
var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var _baseIsEqualDeep_argsTag = '[object Arguments]',
    _baseIsEqualDeep_arrayTag = '[object Array]',
    _baseIsEqualDeep_objectTag = '[object Object]';

/** Used for built-in method references. */
var _baseIsEqualDeep_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseIsEqualDeep_hasOwnProperty = _baseIsEqualDeep_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = lodash_es_isArray(object),
      othIsArr = lodash_es_isArray(other),
      objTag = objIsArr ? _baseIsEqualDeep_arrayTag : _getTag(object),
      othTag = othIsArr ? _baseIsEqualDeep_arrayTag : _getTag(other);

  objTag = objTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : objTag;
  othTag = othTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : othTag;

  var objIsObj = objTag == _baseIsEqualDeep_objectTag,
      othIsObj = othTag == _baseIsEqualDeep_objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && lodash_es_isBuffer(object)) {
    if (!lodash_es_isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || lodash_es_isTypedArray(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & _baseIsEqualDeep_COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && _baseIsEqualDeep_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _baseIsEqualDeep_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ const _baseIsEqualDeep = (baseIsEqualDeep);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsEqual.js



/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!lodash_es_isObjectLike(value) && !lodash_es_isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ const _baseIsEqual = (baseIsEqual);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIsMatch.js



/** Used to compose bitmasks for value comparisons. */
var _baseIsMatch_COMPARE_PARTIAL_FLAG = 1,
    _baseIsMatch_COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? _baseIsEqual(srcValue, objValue, _baseIsMatch_COMPARE_PARTIAL_FLAG | _baseIsMatch_COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/* harmony default export */ const _baseIsMatch = (baseIsMatch);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isStrictComparable.js


/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !lodash_es_isObject(value);
}

/* harmony default export */ const _isStrictComparable = (isStrictComparable);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_getMatchData.js



/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = lodash_es_keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}

/* harmony default export */ const _getMatchData = (getMatchData);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_matchesStrictComparable.js
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/* harmony default export */ const _matchesStrictComparable = (matchesStrictComparable);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseMatches.js




/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}

/* harmony default export */ const _baseMatches = (baseMatches);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_isKey.js



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (lodash_es_isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || lodash_es_isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ const _isKey = (isKey);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/memoize.js


/** Error message constants. */
var memoize_FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(memoize_FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

/* harmony default export */ const lodash_es_memoize = (memoize);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_memoizeCapped.js


/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = lodash_es_memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/* harmony default export */ const _memoizeCapped = (memoizeCapped);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_stringToPath.js


/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ const _stringToPath = (stringToPath);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseToString.js





/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var _baseToString_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = _baseToString_symbolProto ? _baseToString_symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (lodash_es_isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (lodash_es_isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ const _baseToString = (baseToString);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/toString.js


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString_toString(value) {
  return value == null ? '' : _baseToString(value);
}

/* harmony default export */ const lodash_es_toString = (toString_toString);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_castPath.js





/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (lodash_es_isArray(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(lodash_es_toString(value));
}

/* harmony default export */ const _castPath = (castPath);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_toKey.js


/** Used as references for various `Number` constants. */
var _toKey_INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || lodash_es_isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -_toKey_INFINITY) ? '-0' : result;
}

/* harmony default export */ const _toKey = (toKey);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseGet.js



/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ const _baseGet = (baseGet);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/get.js


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get_get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ const lodash_es_get = (get_get);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseHasIn.js
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/* harmony default export */ const _baseHasIn = (baseHasIn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_hasPath.js







/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && lodash_es_isLength(length) && _isIndex(key, length) &&
    (lodash_es_isArray(object) || lodash_es_isArguments(object));
}

/* harmony default export */ const _hasPath = (hasPath);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/hasIn.js



/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

/* harmony default export */ const lodash_es_hasIn = (hasIn);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseMatchesProperty.js








/** Used to compose bitmasks for value comparisons. */
var _baseMatchesProperty_COMPARE_PARTIAL_FLAG = 1,
    _baseMatchesProperty_COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = lodash_es_get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? lodash_es_hasIn(object, path)
      : _baseIsEqual(srcValue, objValue, _baseMatchesProperty_COMPARE_PARTIAL_FLAG | _baseMatchesProperty_COMPARE_UNORDERED_FLAG);
  };
}

/* harmony default export */ const _baseMatchesProperty = (baseMatchesProperty);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseProperty.js
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ const _baseProperty = (baseProperty);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_basePropertyDeep.js


/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}

/* harmony default export */ const _basePropertyDeep = (basePropertyDeep);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/property.js





/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}

/* harmony default export */ const lodash_es_property = (property);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseIteratee.js






/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return lodash_es_identity;
  }
  if (typeof value == 'object') {
    return lodash_es_isArray(value)
      ? _baseMatchesProperty(value[0], value[1])
      : _baseMatches(value);
  }
  return lodash_es_property(value);
}

/* harmony default export */ const _baseIteratee = (baseIteratee);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/_baseMap.js



/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = lodash_es_isArrayLike(collection) ? Array(collection.length) : [];

  _baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/* harmony default export */ const _baseMap = (baseMap);

;// CONCATENATED MODULE: ../../../node_modules/lodash-es/map.js





/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = lodash_es_isArray(collection) ? _arrayMap : _baseMap;
  return func(collection, _baseIteratee(iteratee, 3));
}

/* harmony default export */ const lodash_es_map = (map);

;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/block/BlockSwatches.js






var BlockSwatches = function BlockSwatches(_ref) {
  var colors = _ref.colors,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatches: {
        marginRight: '-10px'
      },
      swatch: {
        width: '22px',
        height: '22px',
        float: 'left',
        marginRight: '10px',
        marginBottom: '10px',
        borderRadius: '4px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return react.createElement(
    'div',
    { style: styles.swatches },
    lodash_es_map(colors, function (c) {
      return react.createElement(common_Swatch, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick: onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: '0 0 4px ' + c
        }
      });
    }),
    react.createElement('div', { style: styles.clear })
  );
};

/* harmony default export */ const block_BlockSwatches = (BlockSwatches);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/block/Block.js









var Block = function Block(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var transparent = hex === 'transparent';
  var handleChange = function handleChange(hexCode, e) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: 'hex'
    }, e);
  };

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      card: {
        width: width,
        background: '#fff',
        boxShadow: '0 1px rgba(0,0,0,.1)',
        borderRadius: '6px',
        position: 'relative'
      },
      head: {
        height: '110px',
        background: hex,
        borderRadius: '6px 6px 0 0',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative'
      },
      body: {
        padding: '10px'
      },
      label: {
        fontSize: '18px',
        color: getContrastingColor(hex),
        position: 'relative'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 10px 10px 10px',
        borderColor: 'transparent transparent ' + hex + ' transparent',
        position: 'absolute',
        top: '-10px',
        left: '50%',
        marginLeft: '-10px'
      },
      input: {
        width: '100%',
        fontSize: '12px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '22px',
        boxShadow: 'inset 0 0 0 1px #ddd',
        borderRadius: '4px',
        padding: '0 7px',
        boxSizing: 'border-box'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      }
    }
  }, passedStyles), { 'hide-triangle': triangle === 'hide' });

  return react.createElement(
    'div',
    { style: styles.card, className: 'block-picker ' + className },
    react.createElement('div', { style: styles.triangle }),
    react.createElement(
      'div',
      { style: styles.head },
      transparent && react.createElement(common_Checkboard, { borderRadius: '6px 6px 0 0' }),
      react.createElement(
        'div',
        { style: styles.label },
        hex
      )
    ),
    react.createElement(
      'div',
      { style: styles.body },
      react.createElement(block_BlockSwatches, { colors: colors, onClick: handleChange, onSwatchHover: onSwatchHover }),
      react.createElement(common_EditableInput, {
        style: { input: styles.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};

Block.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  colors: prop_types_default().arrayOf((prop_types_default()).string),
  triangle: prop_types_default().oneOf(['top', 'hide']),
  styles: (prop_types_default()).object
};

Block.defaultProps = {
  width: 170,
  colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
  triangle: 'top',
  styles: {}
};

/* harmony default export */ const block_Block = (common_ColorWrap(Block));
;// CONCATENATED MODULE: ../../../node_modules/material-colors/dist/colors.es2015.js
var colors_es2015_red = {"50":"#ffebee","100":"#ffcdd2","200":"#ef9a9a","300":"#e57373","400":"#ef5350","500":"#f44336","600":"#e53935","700":"#d32f2f","800":"#c62828","900":"#b71c1c","a100":"#ff8a80","a200":"#ff5252","a400":"#ff1744","a700":"#d50000"};
var pink = {"50":"#fce4ec","100":"#f8bbd0","200":"#f48fb1","300":"#f06292","400":"#ec407a","500":"#e91e63","600":"#d81b60","700":"#c2185b","800":"#ad1457","900":"#880e4f","a100":"#ff80ab","a200":"#ff4081","a400":"#f50057","a700":"#c51162"};
var purple = {"50":"#f3e5f5","100":"#e1bee7","200":"#ce93d8","300":"#ba68c8","400":"#ab47bc","500":"#9c27b0","600":"#8e24aa","700":"#7b1fa2","800":"#6a1b9a","900":"#4a148c","a100":"#ea80fc","a200":"#e040fb","a400":"#d500f9","a700":"#aa00ff"};
var deepPurple = {"50":"#ede7f6","100":"#d1c4e9","200":"#b39ddb","300":"#9575cd","400":"#7e57c2","500":"#673ab7","600":"#5e35b1","700":"#512da8","800":"#4527a0","900":"#311b92","a100":"#b388ff","a200":"#7c4dff","a400":"#651fff","a700":"#6200ea"};
var indigo = {"50":"#e8eaf6","100":"#c5cae9","200":"#9fa8da","300":"#7986cb","400":"#5c6bc0","500":"#3f51b5","600":"#3949ab","700":"#303f9f","800":"#283593","900":"#1a237e","a100":"#8c9eff","a200":"#536dfe","a400":"#3d5afe","a700":"#304ffe"};
var blue = {"50":"#e3f2fd","100":"#bbdefb","200":"#90caf9","300":"#64b5f6","400":"#42a5f5","500":"#2196f3","600":"#1e88e5","700":"#1976d2","800":"#1565c0","900":"#0d47a1","a100":"#82b1ff","a200":"#448aff","a400":"#2979ff","a700":"#2962ff"};
var lightBlue = {"50":"#e1f5fe","100":"#b3e5fc","200":"#81d4fa","300":"#4fc3f7","400":"#29b6f6","500":"#03a9f4","600":"#039be5","700":"#0288d1","800":"#0277bd","900":"#01579b","a100":"#80d8ff","a200":"#40c4ff","a400":"#00b0ff","a700":"#0091ea"};
var cyan = {"50":"#e0f7fa","100":"#b2ebf2","200":"#80deea","300":"#4dd0e1","400":"#26c6da","500":"#00bcd4","600":"#00acc1","700":"#0097a7","800":"#00838f","900":"#006064","a100":"#84ffff","a200":"#18ffff","a400":"#00e5ff","a700":"#00b8d4"};
var teal = {"50":"#e0f2f1","100":"#b2dfdb","200":"#80cbc4","300":"#4db6ac","400":"#26a69a","500":"#009688","600":"#00897b","700":"#00796b","800":"#00695c","900":"#004d40","a100":"#a7ffeb","a200":"#64ffda","a400":"#1de9b6","a700":"#00bfa5"};
var green = {"50":"#e8f5e9","100":"#c8e6c9","200":"#a5d6a7","300":"#81c784","400":"#66bb6a","500":"#4caf50","600":"#43a047","700":"#388e3c","800":"#2e7d32","900":"#1b5e20","a100":"#b9f6ca","a200":"#69f0ae","a400":"#00e676","a700":"#00c853"};
var lightGreen = {"50":"#f1f8e9","100":"#dcedc8","200":"#c5e1a5","300":"#aed581","400":"#9ccc65","500":"#8bc34a","600":"#7cb342","700":"#689f38","800":"#558b2f","900":"#33691e","a100":"#ccff90","a200":"#b2ff59","a400":"#76ff03","a700":"#64dd17"};
var lime = {"50":"#f9fbe7","100":"#f0f4c3","200":"#e6ee9c","300":"#dce775","400":"#d4e157","500":"#cddc39","600":"#c0ca33","700":"#afb42b","800":"#9e9d24","900":"#827717","a100":"#f4ff81","a200":"#eeff41","a400":"#c6ff00","a700":"#aeea00"};
var yellow = {"50":"#fffde7","100":"#fff9c4","200":"#fff59d","300":"#fff176","400":"#ffee58","500":"#ffeb3b","600":"#fdd835","700":"#fbc02d","800":"#f9a825","900":"#f57f17","a100":"#ffff8d","a200":"#ffff00","a400":"#ffea00","a700":"#ffd600"};
var amber = {"50":"#fff8e1","100":"#ffecb3","200":"#ffe082","300":"#ffd54f","400":"#ffca28","500":"#ffc107","600":"#ffb300","700":"#ffa000","800":"#ff8f00","900":"#ff6f00","a100":"#ffe57f","a200":"#ffd740","a400":"#ffc400","a700":"#ffab00"};
var orange = {"50":"#fff3e0","100":"#ffe0b2","200":"#ffcc80","300":"#ffb74d","400":"#ffa726","500":"#ff9800","600":"#fb8c00","700":"#f57c00","800":"#ef6c00","900":"#e65100","a100":"#ffd180","a200":"#ffab40","a400":"#ff9100","a700":"#ff6d00"};
var deepOrange = {"50":"#fbe9e7","100":"#ffccbc","200":"#ffab91","300":"#ff8a65","400":"#ff7043","500":"#ff5722","600":"#f4511e","700":"#e64a19","800":"#d84315","900":"#bf360c","a100":"#ff9e80","a200":"#ff6e40","a400":"#ff3d00","a700":"#dd2c00"};
var brown = {"50":"#efebe9","100":"#d7ccc8","200":"#bcaaa4","300":"#a1887f","400":"#8d6e63","500":"#795548","600":"#6d4c41","700":"#5d4037","800":"#4e342e","900":"#3e2723"};
var grey = {"50":"#fafafa","100":"#f5f5f5","200":"#eeeeee","300":"#e0e0e0","400":"#bdbdbd","500":"#9e9e9e","600":"#757575","700":"#616161","800":"#424242","900":"#212121"};
var blueGrey = {"50":"#eceff1","100":"#cfd8dc","200":"#b0bec5","300":"#90a4ae","400":"#78909c","500":"#607d8b","600":"#546e7a","700":"#455a64","800":"#37474f","900":"#263238"};
var darkText = {"primary":"rgba(0, 0, 0, 0.87)","secondary":"rgba(0, 0, 0, 0.54)","disabled":"rgba(0, 0, 0, 0.38)","dividers":"rgba(0, 0, 0, 0.12)"};
var lightText = {"primary":"rgba(255, 255, 255, 1)","secondary":"rgba(255, 255, 255, 0.7)","disabled":"rgba(255, 255, 255, 0.5)","dividers":"rgba(255, 255, 255, 0.12)"};
var darkIcons = {"active":"rgba(0, 0, 0, 0.54)","inactive":"rgba(0, 0, 0, 0.38)"};
var lightIcons = {"active":"rgba(255, 255, 255, 1)","inactive":"rgba(255, 255, 255, 0.5)"};
var white = "#ffffff";
var black = "#000000";

/* harmony default export */ const colors_es2015 = ({
  red: colors_es2015_red,
  pink: pink,
  purple: purple,
  deepPurple: deepPurple,
  indigo: indigo,
  blue: blue,
  lightBlue: lightBlue,
  cyan: cyan,
  teal: teal,
  green: green,
  lightGreen: lightGreen,
  lime: lime,
  yellow: yellow,
  amber: amber,
  orange: orange,
  deepOrange: deepOrange,
  brown: brown,
  grey: grey,
  blueGrey: blueGrey,
  darkText: darkText,
  lightText: lightText,
  darkIcons: darkIcons,
  lightIcons: lightIcons,
  white: white,
  black: black
});

;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/circle/CircleSwatch.js





var CircleSwatch = function CircleSwatch(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      hover = _ref.hover,
      active = _ref.active,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: 'scale(1)',
        transition: '100ms transform ease'
      },
      Swatch: {
        borderRadius: '50%',
        background: 'transparent',
        boxShadow: 'inset 0 0 0 ' + (circleSize / 2 + 1) + 'px ' + color,
        transition: '100ms box-shadow ease'
      }
    },
    'hover': {
      swatch: {
        transform: 'scale(1.2)'
      }
    },
    'active': {
      Swatch: {
        boxShadow: 'inset 0 0 0 3px ' + color
      }
    }
  }, { hover: hover, active: active });

  return react.createElement(
    'div',
    { style: styles.swatch },
    react.createElement(common_Swatch, {
      style: styles.Swatch,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles.Swatch.boxShadow + ', 0 0 5px ' + color }
    })
  );
};

CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};

/* harmony default export */ const circle_CircleSwatch = ((0,lib/* handleHover */.H8)(CircleSwatch));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/circle/Circle.js










var Circle = function Circle(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      circleSize = _ref.circleSize,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      circleSpacing = _ref.circleSpacing,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      card: {
        width: width,
        display: 'flex',
        flexWrap: 'wrap',
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(hexCode, e) {
    return onChange({ hex: hexCode, source: 'hex' }, e);
  };

  return react.createElement(
    'div',
    { style: styles.card, className: 'circle-picker ' + className },
    lodash_es_map(colors, function (c) {
      return react.createElement(circle_CircleSwatch, {
        key: c,
        color: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover,
        active: hex === c.toLowerCase(),
        circleSize: circleSize,
        circleSpacing: circleSpacing
      });
    })
  );
};

Circle.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  circleSize: (prop_types_default()).number,
  circleSpacing: (prop_types_default()).number,
  styles: (prop_types_default()).object
};

Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [colors_es2015_red['500'], pink['500'], purple['500'], deepPurple['500'], indigo['500'], blue['500'], lightBlue['500'], cyan['500'], teal['500'], green['500'], lightGreen['500'], lime['500'], yellow['500'], amber['500'], orange['500'], deepOrange['500'], brown['500'], blueGrey['500']],
  styles: {}
};

/* harmony default export */ const circle_Circle = (common_ColorWrap(Circle));
;// CONCATENATED MODULE: ../../../node_modules/lodash-es/isUndefined.js
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/* harmony default export */ const lodash_es_isUndefined = (isUndefined);

// EXTERNAL MODULE: ../../../node_modules/@icons/material/UnfoldMoreHorizontalIcon.js
var UnfoldMoreHorizontalIcon = __webpack_require__(69767);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/chrome/ChromeFields.js
var ChromeFields_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function ChromeFields_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ChromeFields_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ChromeFields_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable react/no-did-mount-set-state, no-param-reassign */









var ChromeFields = function (_React$Component) {
  ChromeFields_inherits(ChromeFields, _React$Component);

  function ChromeFields(props) {
    ChromeFields_classCallCheck(this, ChromeFields);

    var _this = ChromeFields_possibleConstructorReturn(this, (ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call(this));

    _this.toggleViews = function () {
      if (_this.state.view === 'hex') {
        _this.setState({ view: 'rgb' });
      } else if (_this.state.view === 'rgb') {
        _this.setState({ view: 'hsl' });
      } else if (_this.state.view === 'hsl') {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: 'hex' });
        } else {
          _this.setState({ view: 'rgb' });
        }
      }
    };

    _this.handleChange = function (data, e) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: 'hex'
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: 'rgb'
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }

        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: 'rgb'
        }, e);
      } else if (data.h || data.s || data.l) {
        // Remove any occurances of '%'.
        if (typeof data.s === 'string' && data.s.includes('%')) {
          data.s = data.s.replace('%', '');
        }
        if (typeof data.l === 'string' && data.l.includes('%')) {
          data.l = data.l.replace('%', '');
        }

        // We store HSL as a unit interval so we need to override the 1 input to 0.01
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }

        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!lodash_es_isUndefined(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!lodash_es_isUndefined(data.l) ? data.l : _this.props.hsl.l),
          source: 'hsl'
        }, e);
      }
    };

    _this.showHighlight = function (e) {
      e.currentTarget.style.background = '#eee';
    };

    _this.hideHighlight = function (e) {
      e.currentTarget.style.background = 'transparent';
    };

    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }

  ChromeFields_createClass(ChromeFields, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var styles = (0,lib/* default */.Ay)({
        'default': {
          wrap: {
            paddingTop: '16px',
            display: 'flex'
          },
          fields: {
            flex: '1',
            display: 'flex',
            marginLeft: '-6px'
          },
          field: {
            paddingLeft: '6px',
            width: '100%'
          },
          alpha: {
            paddingLeft: '6px',
            width: '100%'
          },
          toggle: {
            width: '32px',
            textAlign: 'right',
            position: 'relative'
          },
          icon: {
            marginRight: '-4px',
            marginTop: '12px',
            cursor: 'pointer',
            position: 'relative'
          },
          iconHighlight: {
            position: 'absolute',
            width: '24px',
            height: '28px',
            background: '#eee',
            borderRadius: '4px',
            top: '10px',
            left: '12px',
            display: 'none'
          },
          input: {
            fontSize: '11px',
            color: '#333',
            width: '100%',
            borderRadius: '2px',
            border: 'none',
            boxShadow: 'inset 0 0 0 1px #dadada',
            height: '21px',
            textAlign: 'center'
          },
          label: {
            textTransform: 'uppercase',
            fontSize: '11px',
            lineHeight: '11px',
            color: '#969696',
            textAlign: 'center',
            display: 'block',
            marginTop: '12px'
          },
          svg: {
            fill: '#333',
            width: '24px',
            height: '24px',
            border: '1px transparent solid',
            borderRadius: '5px'
          }
        },
        'disableAlpha': {
          alpha: {
            display: 'none'
          }
        }
      }, this.props, this.state);

      var fields = void 0;
      if (this.state.view === 'hex') {
        fields = react.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'hex', value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'rgb') {
        fields = react.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'r',
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'g',
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'b',
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.alpha },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'hsl') {
        fields = react.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'h',
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 's',
              value: Math.round(this.props.hsl.s * 100) + '%',
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.field },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'l',
              value: Math.round(this.props.hsl.l * 100) + '%',
              onChange: this.handleChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.alpha },
            react.createElement(common_EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }

      return react.createElement(
        'div',
        { style: styles.wrap, className: 'flexbox-fix' },
        fields,
        react.createElement(
          'div',
          { style: styles.toggle },
          react.createElement(
            'div',
            { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
                return _this2.icon = icon;
              } },
            react.createElement(UnfoldMoreHorizontalIcon/* default */.A, {
              style: styles.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === 'hex') {
        return { view: 'rgb' };
      }
      return null;
    }
  }]);

  return ChromeFields;
}(react.Component);

ChromeFields.defaultProps = {
  view: "hex"
};

/* harmony default export */ const chrome_ChromeFields = (ChromeFields);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/chrome/ChromePointer.js



var ChromePointer = function ChromePointer() {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        transform: 'translate(-6px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const chrome_ChromePointer = (ChromePointer);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/chrome/ChromePointerCircle.js



var ChromePointerCircle = function ChromePointerCircle() {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    }
  });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const chrome_ChromePointerCircle = (ChromePointerCircle);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/chrome/Chrome.js










var Chrome = function Chrome(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      disableAlpha = _ref.disableAlpha,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hsv = _ref.hsv,
      hex = _ref.hex,
      renderers = _ref.renderers,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className,
      defaultView = _ref.defaultView;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      picker: {
        width: width,
        background: '#fff',
        borderRadius: '2px',
        boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
        boxSizing: 'initial',
        fontFamily: 'Menlo'
      },
      saturation: {
        width: '100%',
        paddingBottom: '55%',
        position: 'relative',
        borderRadius: '2px 2px 0 0',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '2px 2px 0 0'
      },
      body: {
        padding: '16px 16px 12px'
      },
      controls: {
        display: 'flex'
      },
      color: {
        width: '32px'
      },
      swatch: {
        marginTop: '6px',
        width: '16px',
        height: '16px',
        borderRadius: '8px',
        position: 'relative',
        overflow: 'hidden'
      },
      active: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '8px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
        background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
        zIndex: '2'
      },
      toggles: {
        flex: '1'
      },
      hue: {
        height: '10px',
        position: 'relative',
        marginBottom: '8px'
      },
      Hue: {
        radius: '2px'
      },
      alpha: {
        height: '10px',
        position: 'relative'
      },
      Alpha: {
        radius: '2px'
      }
    },
    'disableAlpha': {
      color: {
        width: '22px'
      },
      alpha: {
        display: 'none'
      },
      hue: {
        marginBottom: '0px'
      },
      swatch: {
        width: '10px',
        height: '10px',
        marginTop: '0px'
      }
    }
  }, passedStyles), { disableAlpha: disableAlpha });

  return react.createElement(
    'div',
    { style: styles.picker, className: 'chrome-picker ' + className },
    react.createElement(
      'div',
      { style: styles.saturation },
      react.createElement(common_Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        pointer: chrome_ChromePointerCircle,
        onChange: onChange
      })
    ),
    react.createElement(
      'div',
      { style: styles.body },
      react.createElement(
        'div',
        { style: styles.controls, className: 'flexbox-fix' },
        react.createElement(
          'div',
          { style: styles.color },
          react.createElement(
            'div',
            { style: styles.swatch },
            react.createElement('div', { style: styles.active }),
            react.createElement(common_Checkboard, { renderers: renderers })
          )
        ),
        react.createElement(
          'div',
          { style: styles.toggles },
          react.createElement(
            'div',
            { style: styles.hue },
            react.createElement(common_Hue, {
              style: styles.Hue,
              hsl: hsl,
              pointer: chrome_ChromePointer,
              onChange: onChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.alpha },
            react.createElement(common_Alpha, {
              style: styles.Alpha,
              rgb: rgb,
              hsl: hsl,
              pointer: chrome_ChromePointer,
              renderers: renderers,
              onChange: onChange
            })
          )
        )
      ),
      react.createElement(chrome_ChromeFields, {
        rgb: rgb,
        hsl: hsl,
        hex: hex,
        view: defaultView,
        onChange: onChange,
        disableAlpha: disableAlpha
      })
    )
  );
};

Chrome.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  disableAlpha: (prop_types_default()).bool,
  styles: (prop_types_default()).object,
  defaultView: prop_types_default().oneOf(["hex", "rgb", "hsl"])
};

Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};

/* harmony default export */ const chrome_Chrome = (common_ColorWrap(Chrome));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/compact/CompactColor.js






var CompactColor = function CompactColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      active = _ref.active;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      color: {
        background: color,
        width: '15px',
        height: '15px',
        float: 'left',
        marginRight: '5px',
        marginBottom: '5px',
        position: 'relative',
        cursor: 'pointer'
      },
      dot: {
        absolute: '5px 5px 5px 5px',
        background: getContrastingColor(color),
        borderRadius: '50%',
        opacity: '0'
      }
    },
    'active': {
      dot: {
        opacity: '1'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      dot: {
        background: '#000'
      }
    },
    'transparent': {
      dot: {
        background: '#000'
      }
    }
  }, { active: active, 'color-#FFFFFF': color === '#FFFFFF', 'transparent': color === 'transparent' });

  return react.createElement(
    common_Swatch,
    {
      style: styles.color,
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    react.createElement('div', { style: styles.dot })
  );
};

/* harmony default export */ const compact_CompactColor = (CompactColor);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/compact/CompactFields.js





var CompactFields = function CompactFields(_ref) {
  var hex = _ref.hex,
      rgb = _ref.rgb,
      onChange = _ref.onChange;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      fields: {
        display: 'flex',
        paddingBottom: '6px',
        paddingRight: '5px',
        position: 'relative'
      },
      active: {
        position: 'absolute',
        top: '6px',
        left: '5px',
        height: '9px',
        width: '9px',
        background: hex
      },
      HEXwrap: {
        flex: '6',
        position: 'relative'
      },
      HEXinput: {
        width: '80%',
        padding: '0px',
        paddingLeft: '20%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      HEXlabel: {
        display: 'none'
      },
      RGBwrap: {
        flex: '3',
        position: 'relative'
      },
      RGBinput: {
        width: '70%',
        padding: '0px',
        paddingLeft: '30%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '3px',
        left: '0px',
        lineHeight: '16px',
        textTransform: 'uppercase',
        fontSize: '12px',
        color: '#999'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    }
  };

  return react.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    react.createElement('div', { style: styles.active }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: 'hex',
      value: hex,
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    })
  );
};

/* harmony default export */ const compact_CompactFields = (CompactFields);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/compact/Compact.js











var Compact = function Compact(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      Compact: {
        background: '#f6f6f6',
        radius: '4px'
      },
      compact: {
        paddingTop: '5px',
        paddingLeft: '5px',
        boxSizing: 'initial',
        width: '240px'
      },
      clear: {
        clear: 'both'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else {
      onChange(data, e);
    }
  };

  return react.createElement(
    common_Raised,
    { style: styles.Compact, styles: passedStyles },
    react.createElement(
      'div',
      { style: styles.compact, className: 'compact-picker ' + className },
      react.createElement(
        'div',
        null,
        lodash_es_map(colors, function (c) {
          return react.createElement(compact_CompactColor, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover: onSwatchHover
          });
        }),
        react.createElement('div', { style: styles.clear })
      ),
      react.createElement(compact_CompactFields, { hex: hex, rgb: rgb, onChange: handleChange })
    )
  );
};

Compact.propTypes = {
  colors: prop_types_default().arrayOf((prop_types_default()).string),
  styles: (prop_types_default()).object
};

Compact.defaultProps = {
  colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E'],
  styles: {}
};

/* harmony default export */ const compact_Compact = (common_ColorWrap(Compact));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/github/GithubSwatch.js





var GithubSwatch = function GithubSwatch(_ref) {
  var hover = _ref.hover,
      color = _ref.color,
      onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover;

  var hoverSwatch = {
    position: 'relative',
    zIndex: '2',
    outline: '2px solid #fff',
    boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
  };

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatch: {
        width: '25px',
        height: '25px',
        fontSize: '0'
      }
    },
    'hover': {
      swatch: hoverSwatch
    }
  }, { hover: hover });

  return react.createElement(
    'div',
    { style: styles.swatch },
    react.createElement(common_Swatch, {
      color: color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};

/* harmony default export */ const github_GithubSwatch = ((0,lib/* handleHover */.H8)(GithubSwatch));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/github/Github.js









var Github = function Github(_ref) {
  var width = _ref.width,
      colors = _ref.colors,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '1px solid rgba(0,0,0,0.2)',
        boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
        borderRadius: '4px',
        position: 'relative',
        padding: '5px',
        display: 'flex',
        flexWrap: 'wrap'
      },
      triangle: {
        position: 'absolute',
        border: '7px solid transparent',
        borderBottomColor: '#fff'
      },
      triangleShadow: {
        position: 'absolute',
        border: '8px solid transparent',
        borderBottomColor: 'rgba(0,0,0,0.15)'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-14px',
        left: '10px'
      },
      triangleShadow: {
        top: '-16px',
        left: '9px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-14px',
        right: '10px'
      },
      triangleShadow: {
        top: '-16px',
        right: '9px'
      }
    },
    'bottom-left-triangle': {
      triangle: {
        top: '35px',
        left: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        left: '9px',
        transform: 'rotate(180deg)'
      }
    },
    'bottom-right-triangle': {
      triangle: {
        top: '35px',
        right: '10px',
        transform: 'rotate(180deg)'
      },
      triangleShadow: {
        top: '37px',
        right: '9px',
        transform: 'rotate(180deg)'
      }
    }
  }, passedStyles), {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right',
    'bottom-left-triangle': triangle === 'bottom-left',
    'bottom-right-triangle': triangle === 'bottom-right'
  });

  var handleChange = function handleChange(hex, e) {
    return onChange({ hex: hex, source: 'hex' }, e);
  };

  return react.createElement(
    'div',
    { style: styles.card, className: 'github-picker ' + className },
    react.createElement('div', { style: styles.triangleShadow }),
    react.createElement('div', { style: styles.triangle }),
    lodash_es_map(colors, function (c) {
      return react.createElement(github_GithubSwatch, {
        color: c,
        key: c,
        onClick: handleChange,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

Github.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  colors: prop_types_default().arrayOf((prop_types_default()).string),
  triangle: prop_types_default().oneOf(['hide', 'top-left', 'top-right', 'bottom-left', 'bottom-right']),
  styles: (prop_types_default()).object
};

Github.defaultProps = {
  width: 200,
  colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
  triangle: 'top-left',
  styles: {}
};

/* harmony default export */ const github_Github = (common_ColorWrap(Github));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/hue/HuePointer.js



var SliderPointer = function SliderPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const HuePointer = (SliderPointer);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/hue/Hue.js
var Hue_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };









var HuePicker = function HuePicker(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      hsl = _ref.hsl,
      direction = _ref.direction,
      pointer = _ref.pointer,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      hue: {
        radius: '2px'
      }
    }
  }, passedStyles));

  // Overwrite to provide pure hue color
  var handleChange = function handleChange(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };

  return react.createElement(
    'div',
    { style: styles.picker, className: 'hue-picker ' + className },
    react.createElement(common_Hue, Hue_extends({}, styles.hue, {
      hsl: hsl,
      pointer: pointer,
      onChange: handleChange,
      direction: direction
    }))
  );
};

HuePicker.propTypes = {
  styles: (prop_types_default()).object
};
HuePicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: HuePointer,
  styles: {}
};

/* harmony default export */ const hue_Hue = (common_ColorWrap(HuePicker));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/material/Material.js







var Material = function Material(_ref) {
  var onChange = _ref.onChange,
      hex = _ref.hex,
      rgb = _ref.rgb,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      material: {
        width: '98px',
        height: '98px',
        padding: '16px',
        fontFamily: 'Roboto'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '2px solid ' + hex,
        outline: 'none',
        height: '30px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '1px solid #eee',
        outline: 'none',
        height: '30px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      split: {
        display: 'flex',
        marginRight: '-10px',
        paddingTop: '11px'
      },
      third: {
        flex: '1',
        paddingRight: '10px'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    }
  };

  return react.createElement(
    common_Raised,
    { styles: passedStyles },
    react.createElement(
      'div',
      { style: styles.material, className: 'material-picker ' + className },
      react.createElement(common_EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: 'hex',
        value: hex,
        onChange: handleChange
      }),
      react.createElement(
        'div',
        { style: styles.split, className: 'flexbox-fix' },
        react.createElement(
          'div',
          { style: styles.third },
          react.createElement(common_EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'r', value: rgb.r,
            onChange: handleChange
          })
        ),
        react.createElement(
          'div',
          { style: styles.third },
          react.createElement(common_EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })
        ),
        react.createElement(
          'div',
          { style: styles.third },
          react.createElement(common_EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};

/* harmony default export */ const material_Material = (common_ColorWrap(Material));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/PhotoshopFields.js






var PhotoshopPicker = function PhotoshopPicker(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsv = _ref.hsv,
      hex = _ref.hex;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      fields: {
        paddingTop: '5px',
        paddingBottom: '9px',
        width: '80px',
        position: 'relative'
      },
      divider: {
        height: '5px'
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        marginLeft: '40%',
        width: '40%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '5px',
        fontSize: '13px',
        paddingLeft: '3px',
        marginRight: '10px'
      },
      RGBlabel: {
        left: '0px',
        top: '0px',
        width: '34px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px',
        position: 'absolute'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        marginLeft: '20%',
        width: '80%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '6px',
        fontSize: '13px',
        paddingLeft: '3px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        width: '14px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px'
      },
      fieldSymbols: {
        position: 'absolute',
        top: '5px',
        right: '-7px',
        fontSize: '13px'
      },
      symbol: {
        height: '20px',
        lineHeight: '22px',
        paddingBottom: '7px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data['#']) {
      isValidHex(data['#']) && onChange({
        hex: data['#'],
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: 'hsv'
      }, e);
    }
  };

  return react.createElement(
    'div',
    { style: styles.fields },
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'h',
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 's',
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'v',
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    react.createElement('div', { style: styles.divider }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    }),
    react.createElement('div', { style: styles.divider }),
    react.createElement(common_EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: '#',
      value: hex.replace('#', ''),
      onChange: handleChange
    }),
    react.createElement(
      'div',
      { style: styles.fieldSymbols },
      react.createElement(
        'div',
        { style: styles.symbol },
        '\xB0'
      ),
      react.createElement(
        'div',
        { style: styles.symbol },
        '%'
      ),
      react.createElement(
        'div',
        { style: styles.symbol },
        '%'
      )
    )
  );
};

/* harmony default export */ const PhotoshopFields = (PhotoshopPicker);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/PhotoshopPointerCircle.js



var PhotoshopPointerCircle = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    },
    'black-outline': {
      picker: {
        boxShadow: 'inset 0 0 0 1px #000'
      }
    }
  }, { 'black-outline': hsl.l > 0.5 });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const photoshop_PhotoshopPointerCircle = (PhotoshopPointerCircle);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/PhotoshopPointer.js



var PhotoshopPointer_PhotoshopPointerCircle = function PhotoshopPointerCircle() {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '4px 0 4px 6px',
        borderColor: 'transparent transparent transparent #fff',
        position: 'absolute',
        top: '1px',
        left: '1px'
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '5px 0 5px 8px',
        borderColor: 'transparent transparent transparent #555'
      },

      left: {
        Extend: 'triangleBorder',
        transform: 'translate(-13px, -4px)'
      },
      leftInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      },

      right: {
        Extend: 'triangleBorder',
        transform: 'translate(20px, -14px) rotate(180deg)'
      },
      rightInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      }
    }
  });

  return react.createElement(
    'div',
    { style: styles.pointer },
    react.createElement(
      'div',
      { style: styles.left },
      react.createElement('div', { style: styles.leftInside })
    ),
    react.createElement(
      'div',
      { style: styles.right },
      react.createElement('div', { style: styles.rightInside })
    )
  );
};

/* harmony default export */ const PhotoshopPointer = (PhotoshopPointer_PhotoshopPointerCircle);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/PhotoshopButton.js



var PhotoshopButton = function PhotoshopButton(_ref) {
  var onClick = _ref.onClick,
      label = _ref.label,
      children = _ref.children,
      active = _ref.active;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      button: {
        backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
        border: '1px solid #878787',
        borderRadius: '2px',
        height: '20px',
        boxShadow: '0 1px 0 0 #EAEAEA',
        fontSize: '14px',
        color: '#000',
        lineHeight: '20px',
        textAlign: 'center',
        marginBottom: '10px',
        cursor: 'pointer'
      }
    },
    'active': {
      button: {
        boxShadow: '0 0 0 1px #878787'
      }
    }
  }, { active: active });

  return react.createElement(
    'div',
    { style: styles.button, onClick: onClick },
    label || children
  );
};

/* harmony default export */ const photoshop_PhotoshopButton = (PhotoshopButton);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/PhotoshopPreviews.js



var PhotoshopPreviews = function PhotoshopPreviews(_ref) {
  var rgb = _ref.rgb,
      currentColor = _ref.currentColor;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatches: {
        border: '1px solid #B3B3B3',
        borderBottom: '1px solid #F0F0F0',
        marginBottom: '2px',
        marginTop: '1px'
      },
      new: {
        height: '34px',
        background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
      },
      current: {
        height: '34px',
        background: currentColor,
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
      },
      label: {
        fontSize: '14px',
        color: '#000',
        textAlign: 'center'
      }
    }
  });

  return react.createElement(
    'div',
    null,
    react.createElement(
      'div',
      { style: styles.label },
      'new'
    ),
    react.createElement(
      'div',
      { style: styles.swatches },
      react.createElement('div', { style: styles.new }),
      react.createElement('div', { style: styles.current })
    ),
    react.createElement(
      'div',
      { style: styles.label },
      'current'
    )
  );
};

/* harmony default export */ const photoshop_PhotoshopPreviews = (PhotoshopPreviews);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/photoshop/Photoshop.js
var Photoshop_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function Photoshop_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Photoshop_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Photoshop_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













var Photoshop = function (_React$Component) {
  Photoshop_inherits(Photoshop, _React$Component);

  function Photoshop(props) {
    Photoshop_classCallCheck(this, Photoshop);

    var _this = Photoshop_possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));

    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }

  Photoshop_createClass(Photoshop, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          _props$styles = _props.styles,
          passedStyles = _props$styles === undefined ? {} : _props$styles,
          _props$className = _props.className,
          className = _props$className === undefined ? '' : _props$className;

      var styles = (0,lib/* default */.Ay)(lodash_es_merge({
        'default': {
          picker: {
            background: '#DCDCDC',
            borderRadius: '4px',
            boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
            boxSizing: 'initial',
            width: '513px'
          },
          head: {
            backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
            borderBottom: '1px solid #B1B1B1',
            boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
            height: '23px',
            lineHeight: '24px',
            borderRadius: '4px 4px 0 0',
            fontSize: '13px',
            color: '#4D4D4D',
            textAlign: 'center'
          },
          body: {
            padding: '15px 15px 0',
            display: 'flex'
          },
          saturation: {
            width: '256px',
            height: '256px',
            position: 'relative',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0',
            overflow: 'hidden'
          },
          hue: {
            position: 'relative',
            height: '256px',
            width: '19px',
            marginLeft: '10px',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0'
          },
          controls: {
            width: '180px',
            marginLeft: '10px'
          },
          top: {
            display: 'flex'
          },
          previews: {
            width: '60px'
          },
          actions: {
            flex: '1',
            marginLeft: '20px'
          }
        }
      }, passedStyles));

      return react.createElement(
        'div',
        { style: styles.picker, className: 'photoshop-picker ' + className },
        react.createElement(
          'div',
          { style: styles.head },
          this.props.header
        ),
        react.createElement(
          'div',
          { style: styles.body, className: 'flexbox-fix' },
          react.createElement(
            'div',
            { style: styles.saturation },
            react.createElement(common_Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: photoshop_PhotoshopPointerCircle,
              onChange: this.props.onChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.hue },
            react.createElement(common_Hue, {
              direction: 'vertical',
              hsl: this.props.hsl,
              pointer: PhotoshopPointer,
              onChange: this.props.onChange
            })
          ),
          react.createElement(
            'div',
            { style: styles.controls },
            react.createElement(
              'div',
              { style: styles.top, className: 'flexbox-fix' },
              react.createElement(
                'div',
                { style: styles.previews },
                react.createElement(photoshop_PhotoshopPreviews, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              react.createElement(
                'div',
                { style: styles.actions },
                react.createElement(photoshop_PhotoshopButton, { label: 'OK', onClick: this.props.onAccept, active: true }),
                react.createElement(photoshop_PhotoshopButton, { label: 'Cancel', onClick: this.props.onCancel }),
                react.createElement(PhotoshopFields, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);

  return Photoshop;
}(react.Component);

Photoshop.propTypes = {
  header: (prop_types_default()).string,
  styles: (prop_types_default()).object
};

Photoshop.defaultProps = {
  header: 'Color Picker',
  styles: {}
};

/* harmony default export */ const photoshop_Photoshop = (common_ColorWrap(Photoshop));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/sketch/SketchFields.js
/* eslint-disable no-param-reassign */







var SketchFields = function SketchFields(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hex = _ref.hex,
      disableAlpha = _ref.disableAlpha;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      fields: {
        display: 'flex',
        paddingTop: '4px'
      },
      single: {
        flex: '1',
        paddingLeft: '6px'
      },
      alpha: {
        flex: '1',
        paddingLeft: '6px'
      },
      double: {
        flex: '2'
      },
      input: {
        width: '80%',
        padding: '4px 10% 3px',
        border: 'none',
        boxShadow: 'inset 0 0 0 1px #ccc',
        fontSize: '11px'
      },
      label: {
        display: 'block',
        textAlign: 'center',
        fontSize: '11px',
        color: '#222',
        paddingTop: '3px',
        paddingBottom: '4px',
        textTransform: 'capitalize'
      }
    },
    'disableAlpha': {
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: 'rgb'
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }

      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: 'rgb'
      }, e);
    }
  };

  return react.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    react.createElement(
      'div',
      { style: styles.double },
      react.createElement(common_EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'hex',
        value: hex.replace('#', ''),
        onChange: handleChange
      })
    ),
    react.createElement(
      'div',
      { style: styles.single },
      react.createElement(common_EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'r',
        value: rgb.r,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    react.createElement(
      'div',
      { style: styles.single },
      react.createElement(common_EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'g',
        value: rgb.g,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    react.createElement(
      'div',
      { style: styles.single },
      react.createElement(common_EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'b',
        value: rgb.b,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    react.createElement(
      'div',
      { style: styles.alpha },
      react.createElement(common_EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'a',
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '100'
      })
    )
  );
};

/* harmony default export */ const sketch_SketchFields = (SketchFields);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/sketch/SketchPresetColors.js
var SketchPresetColors_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };







var SketchPresetColors = function SketchPresetColors(_ref) {
  var colors = _ref.colors,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      colors: {
        margin: '0 -10px',
        padding: '10px 0 0 10px',
        borderTop: '1px solid #eee',
        display: 'flex',
        flexWrap: 'wrap',
        position: 'relative'
      },
      swatchWrap: {
        width: '16px',
        height: '16px',
        margin: '0 10px 10px 0'
      },
      swatch: {
        borderRadius: '3px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
      }
    },
    'no-presets': {
      colors: {
        display: 'none'
      }
    }
  }, {
    'no-presets': !colors || !colors.length
  });

  var handleClick = function handleClick(hex, e) {
    onClick({
      hex: hex,
      source: 'hex'
    }, e);
  };

  return react.createElement(
    'div',
    { style: styles.colors, className: 'flexbox-fix' },
    colors.map(function (colorObjOrString) {
      var c = typeof colorObjOrString === 'string' ? { color: colorObjOrString } : colorObjOrString;
      var key = '' + c.color + (c.title || '');
      return react.createElement(
        'div',
        { key: key, style: styles.swatchWrap },
        react.createElement(common_Swatch, SketchPresetColors_extends({}, c, {
          style: styles.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ' + c.color
          }
        }))
      );
    })
  );
};

SketchPresetColors.propTypes = {
  colors: prop_types_default().arrayOf(prop_types_default().oneOfType([(prop_types_default()).string, prop_types_default().shape({
    color: (prop_types_default()).string,
    title: (prop_types_default()).string
  })])).isRequired
};

/* harmony default export */ const sketch_SketchPresetColors = (SketchPresetColors);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/sketch/Sketch.js
var Sketch_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };










var Sketch = function Sketch(_ref) {
  var width = _ref.width,
      rgb = _ref.rgb,
      hex = _ref.hex,
      hsv = _ref.hsv,
      hsl = _ref.hsl,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      disableAlpha = _ref.disableAlpha,
      presetColors = _ref.presetColors,
      renderers = _ref.renderers,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': Sketch_extends({
      picker: {
        width: width,
        padding: '10px 10px 0',
        boxSizing: 'initial',
        background: '#fff',
        borderRadius: '4px',
        boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
      },
      saturation: {
        width: '100%',
        paddingBottom: '75%',
        position: 'relative',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '3px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      controls: {
        display: 'flex'
      },
      sliders: {
        padding: '4px 0',
        flex: '1'
      },
      color: {
        width: '24px',
        height: '24px',
        position: 'relative',
        marginTop: '4px',
        marginLeft: '4px',
        borderRadius: '3px'
      },
      activeColor: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '2px',
        background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      hue: {
        position: 'relative',
        height: '10px',
        overflow: 'hidden'
      },
      Hue: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },

      alpha: {
        position: 'relative',
        height: '10px',
        marginTop: '4px',
        overflow: 'hidden'
      },
      Alpha: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      }
    }, passedStyles),
    'disableAlpha': {
      color: {
        height: '10px'
      },
      hue: {
        height: '10px'
      },
      alpha: {
        display: 'none'
      }
    }
  }, passedStyles), { disableAlpha: disableAlpha });

  return react.createElement(
    'div',
    { style: styles.picker, className: 'sketch-picker ' + className },
    react.createElement(
      'div',
      { style: styles.saturation },
      react.createElement(common_Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        onChange: onChange
      })
    ),
    react.createElement(
      'div',
      { style: styles.controls, className: 'flexbox-fix' },
      react.createElement(
        'div',
        { style: styles.sliders },
        react.createElement(
          'div',
          { style: styles.hue },
          react.createElement(common_Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })
        ),
        react.createElement(
          'div',
          { style: styles.alpha },
          react.createElement(common_Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          })
        )
      ),
      react.createElement(
        'div',
        { style: styles.color },
        react.createElement(common_Checkboard, null),
        react.createElement('div', { style: styles.activeColor })
      )
    ),
    react.createElement(sketch_SketchFields, {
      rgb: rgb,
      hsl: hsl,
      hex: hex,
      onChange: onChange,
      disableAlpha: disableAlpha
    }),
    react.createElement(sketch_SketchPresetColors, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover: onSwatchHover
    })
  );
};

Sketch.propTypes = {
  disableAlpha: (prop_types_default()).bool,
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  styles: (prop_types_default()).object
};

Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF']
};

/* harmony default export */ const sketch_Sketch = (common_ColorWrap(Sketch));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/slider/SliderSwatch.js



var SliderSwatch = function SliderSwatch(_ref) {
  var hsl = _ref.hsl,
      offset = _ref.offset,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      active = _ref.active,
      first = _ref.first,
      last = _ref.last;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatch: {
        height: '12px',
        background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
        cursor: 'pointer'
      }
    },
    'first': {
      swatch: {
        borderRadius: '2px 0 0 2px'
      }
    },
    'last': {
      swatch: {
        borderRadius: '0 2px 2px 0'
      }
    },
    'active': {
      swatch: {
        transform: 'scaleY(1.8)',
        borderRadius: '3.6px/2px'
      }
    }
  }, { active: active, first: first, last: last });

  var handleClick = function handleClick(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset,
      source: 'hsl'
    }, e);
  };

  return react.createElement('div', { style: styles.swatch, onClick: handleClick });
};

/* harmony default export */ const slider_SliderSwatch = (SliderSwatch);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/slider/SliderSwatches.js





var SliderSwatches = function SliderSwatches(_ref) {
  var onClick = _ref.onClick,
      hsl = _ref.hsl;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      swatches: {
        marginTop: '20px'
      },
      swatch: {
        boxSizing: 'border-box',
        width: '20%',
        paddingRight: '1px',
        float: 'left'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  // Acceptible difference in floating point equality
  var epsilon = 0.1;

  return react.createElement(
    'div',
    { style: styles.swatches },
    react.createElement(
      'div',
      { style: styles.swatch },
      react.createElement(slider_SliderSwatch, {
        hsl: hsl,
        offset: '.80',
        active: Math.abs(hsl.l - 0.80) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick,
        first: true
      })
    ),
    react.createElement(
      'div',
      { style: styles.swatch },
      react.createElement(slider_SliderSwatch, {
        hsl: hsl,
        offset: '.65',
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    react.createElement(
      'div',
      { style: styles.swatch },
      react.createElement(slider_SliderSwatch, {
        hsl: hsl,
        offset: '.50',
        active: Math.abs(hsl.l - 0.50) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    react.createElement(
      'div',
      { style: styles.swatch },
      react.createElement(slider_SliderSwatch, {
        hsl: hsl,
        offset: '.35',
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick
      })
    ),
    react.createElement(
      'div',
      { style: styles.swatch },
      react.createElement(slider_SliderSwatch, {
        hsl: hsl,
        offset: '.20',
        active: Math.abs(hsl.l - 0.20) < epsilon && Math.abs(hsl.s - 0.50) < epsilon,
        onClick: onClick,
        last: true
      })
    ),
    react.createElement('div', { style: styles.clear })
  );
};

/* harmony default export */ const slider_SliderSwatches = (SliderSwatches);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/slider/SliderPointer.js



var SliderPointer_SliderPointer = function SliderPointer() {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '14px',
        height: '14px',
        borderRadius: '6px',
        transform: 'translate(-7px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return react.createElement('div', { style: styles.picker });
};

/* harmony default export */ const slider_SliderPointer = (SliderPointer_SliderPointer);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/slider/Slider.js









var Slider = function Slider(_ref) {
  var hsl = _ref.hsl,
      onChange = _ref.onChange,
      pointer = _ref.pointer,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      hue: {
        height: '12px',
        position: 'relative'
      },
      Hue: {
        radius: '2px'
      }
    }
  }, passedStyles));

  return react.createElement(
    'div',
    { style: styles.wrap || {}, className: 'slider-picker ' + className },
    react.createElement(
      'div',
      { style: styles.hue },
      react.createElement(common_Hue, {
        style: styles.Hue,
        hsl: hsl,
        pointer: pointer,
        onChange: onChange
      })
    ),
    react.createElement(
      'div',
      { style: styles.swatches },
      react.createElement(slider_SliderSwatches, { hsl: hsl, onClick: onChange })
    )
  );
};

Slider.propTypes = {
  styles: (prop_types_default()).object
};
Slider.defaultProps = {
  pointer: slider_SliderPointer,
  styles: {}
};

/* harmony default export */ const slider_Slider = (common_ColorWrap(Slider));
// EXTERNAL MODULE: ../../../node_modules/@icons/material/CheckIcon.js
var CheckIcon = __webpack_require__(81810);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/swatches/SwatchesColor.js







var SwatchesColor = function SwatchesColor(_ref) {
  var color = _ref.color,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      onSwatchHover = _ref.onSwatchHover,
      first = _ref.first,
      last = _ref.last,
      active = _ref.active;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      color: {
        width: '40px',
        height: '24px',
        cursor: 'pointer',
        background: color,
        marginBottom: '1px'
      },
      check: {
        color: getContrastingColor(color),
        marginLeft: '8px',
        display: 'none'
      }
    },
    'first': {
      color: {
        overflow: 'hidden',
        borderRadius: '2px 2px 0 0'
      }
    },
    'last': {
      color: {
        overflow: 'hidden',
        borderRadius: '0 0 2px 2px'
      }
    },
    'active': {
      check: {
        display: 'block'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      check: {
        color: '#333'
      }
    },
    'transparent': {
      check: {
        color: '#333'
      }
    }
  }, {
    first: first,
    last: last,
    active: active,
    'color-#FFFFFF': color === '#FFFFFF',
    'transparent': color === 'transparent'
  });

  return react.createElement(
    common_Swatch,
    {
      color: color,
      style: styles.color,
      onClick: onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: '0 0 4px ' + color }
    },
    react.createElement(
      'div',
      { style: styles.check },
      react.createElement(CheckIcon/* default */.A, null)
    )
  );
};

/* harmony default export */ const swatches_SwatchesColor = (SwatchesColor);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/swatches/SwatchesGroup.js






var SwatchesGroup = function SwatchesGroup(_ref) {
  var onClick = _ref.onClick,
      onSwatchHover = _ref.onSwatchHover,
      group = _ref.group,
      active = _ref.active;

  var styles = (0,lib/* default */.Ay)({
    'default': {
      group: {
        paddingBottom: '10px',
        width: '40px',
        float: 'left',
        marginRight: '10px'
      }
    }
  });

  return react.createElement(
    'div',
    { style: styles.group },
    lodash_es_map(group, function (color, i) {
      return react.createElement(swatches_SwatchesColor, {
        key: color,
        color: color,
        active: color.toLowerCase() === active,
        first: i === 0,
        last: i === group.length - 1,
        onClick: onClick,
        onSwatchHover: onSwatchHover
      });
    })
  );
};

/* harmony default export */ const swatches_SwatchesGroup = (SwatchesGroup);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/swatches/Swatches.js










var Swatches = function Swatches(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      colors = _ref.colors,
      hex = _ref.hex,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      picker: {
        width: width,
        height: height
      },
      overflow: {
        height: height,
        overflowY: 'scroll'
      },
      body: {
        padding: '16px 0 6px 16px'
      },
      clear: {
        clear: 'both'
      }
    }
  }, passedStyles));

  var handleChange = function handleChange(data, e) {
    return onChange({ hex: data, source: 'hex' }, e);
  };

  return react.createElement(
    'div',
    { style: styles.picker, className: 'swatches-picker ' + className },
    react.createElement(
      common_Raised,
      null,
      react.createElement(
        'div',
        { style: styles.overflow },
        react.createElement(
          'div',
          { style: styles.body },
          lodash_es_map(colors, function (group) {
            return react.createElement(swatches_SwatchesGroup, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange,
              onSwatchHover: onSwatchHover
            });
          }),
          react.createElement('div', { style: styles.clear })
        )
      )
    )
  );
};

Swatches.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  height: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  colors: prop_types_default().arrayOf(prop_types_default().arrayOf((prop_types_default()).string)),
  styles: (prop_types_default()).object

  /* eslint-disable max-len */
};Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[colors_es2015_red['900'], colors_es2015_red['700'], colors_es2015_red['500'], colors_es2015_red['300'], colors_es2015_red['100']], [pink['900'], pink['700'], pink['500'], pink['300'], pink['100']], [purple['900'], purple['700'], purple['500'], purple['300'], purple['100']], [deepPurple['900'], deepPurple['700'], deepPurple['500'], deepPurple['300'], deepPurple['100']], [indigo['900'], indigo['700'], indigo['500'], indigo['300'], indigo['100']], [blue['900'], blue['700'], blue['500'], blue['300'], blue['100']], [lightBlue['900'], lightBlue['700'], lightBlue['500'], lightBlue['300'], lightBlue['100']], [cyan['900'], cyan['700'], cyan['500'], cyan['300'], cyan['100']], [teal['900'], teal['700'], teal['500'], teal['300'], teal['100']], ['#194D33', green['700'], green['500'], green['300'], green['100']], [lightGreen['900'], lightGreen['700'], lightGreen['500'], lightGreen['300'], lightGreen['100']], [lime['900'], lime['700'], lime['500'], lime['300'], lime['100']], [yellow['900'], yellow['700'], yellow['500'], yellow['300'], yellow['100']], [amber['900'], amber['700'], amber['500'], amber['300'], amber['100']], [orange['900'], orange['700'], orange['500'], orange['300'], orange['100']], [deepOrange['900'], deepOrange['700'], deepOrange['500'], deepOrange['300'], deepOrange['100']], [brown['900'], brown['700'], brown['500'], brown['300'], brown['100']], [blueGrey['900'], blueGrey['700'], blueGrey['500'], blueGrey['300'], blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']],
  styles: {}
};

/* harmony default export */ const swatches_Swatches = (common_ColorWrap(Swatches));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/twitter/Twitter.js









var Twitter = function Twitter(_ref) {
  var onChange = _ref.onChange,
      onSwatchHover = _ref.onSwatchHover,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '0 solid rgba(0,0,0,0.25)',
        boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
        borderRadius: '4px',
        position: 'relative'
      },
      body: {
        padding: '15px 9px 9px 15px'
      },
      label: {
        fontSize: '18px',
        color: '#fff'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent #fff transparent',
        position: 'absolute'
      },
      triangleShadow: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
        position: 'absolute'
      },
      hash: {
        background: '#F0F0F0',
        height: '30px',
        width: '30px',
        borderRadius: '4px 0 0 4px',
        float: 'left',
        color: '#98A1A4',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      input: {
        width: '100px',
        fontSize: '14px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '28px',
        boxShadow: 'inset 0 0 0 1px #F0F0F0',
        boxSizing: 'content-box',
        borderRadius: '0 4px 4px 0',
        float: 'left',
        paddingLeft: '8px'
      },
      swatch: {
        width: '30px',
        height: '30px',
        float: 'left',
        borderRadius: '4px',
        margin: '0 6px 6px 0'
      },
      clear: {
        clear: 'both'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-10px',
        left: '12px'
      },
      triangleShadow: {
        top: '-11px',
        left: '12px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-10px',
        right: '12px'
      },
      triangleShadow: {
        top: '-11px',
        right: '12px'
      }
    }
  }, passedStyles), {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right'
  });

  var handleChange = function handleChange(hexcode, e) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: 'hex'
    }, e);
  };

  return react.createElement(
    'div',
    { style: styles.card, className: 'twitter-picker ' + className },
    react.createElement('div', { style: styles.triangleShadow }),
    react.createElement('div', { style: styles.triangle }),
    react.createElement(
      'div',
      { style: styles.body },
      lodash_es_map(colors, function (c, i) {
        return react.createElement(common_Swatch, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: '0 0 4px ' + c
          }
        });
      }),
      react.createElement(
        'div',
        { style: styles.hash },
        '#'
      ),
      react.createElement(common_EditableInput, {
        label: null,
        style: { input: styles.input },
        value: hex.replace('#', ''),
        onChange: handleChange
      }),
      react.createElement('div', { style: styles.clear })
    )
  );
};

Twitter.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  triangle: prop_types_default().oneOf(['hide', 'top-left', 'top-right']),
  colors: prop_types_default().arrayOf((prop_types_default()).string),
  styles: (prop_types_default()).object
};

Twitter.defaultProps = {
  width: 276,
  colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
  triangle: 'top-left',
  styles: {}
};

/* harmony default export */ const twitter_Twitter = (common_ColorWrap(Twitter));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/google/GooglePointerCircle.js




var GooglePointerCircle = function GooglePointerCircle(props) {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '20px',
        height: '20px',
        borderRadius: '22px',
        border: '2px #fff solid',
        transform: 'translate(-12px, -13px)',
        background: 'hsl(' + Math.round(props.hsl.h) + ', ' + Math.round(props.hsl.s * 100) + '%, ' + Math.round(props.hsl.l * 100) + '%)'
      }
    }
  });

  return react.createElement('div', { style: styles.picker });
};

GooglePointerCircle.propTypes = {
  hsl: prop_types_default().shape({
    h: (prop_types_default()).number,
    s: (prop_types_default()).number,
    l: (prop_types_default()).number,
    a: (prop_types_default()).number
  })
};

GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.50 }
};

/* harmony default export */ const google_GooglePointerCircle = (GooglePointerCircle);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/google/GooglePointer.js




var GooglePointer = function GooglePointer(props) {
  var styles = (0,lib/* default */.Ay)({
    'default': {
      picker: {
        width: '20px',
        height: '20px',
        borderRadius: '22px',
        transform: 'translate(-10px, -7px)',
        background: 'hsl(' + Math.round(props.hsl.h) + ', 100%, 50%)',
        border: '2px white solid'
      }
    }
  });

  return react.createElement('div', { style: styles.picker });
};

GooglePointer.propTypes = {
  hsl: prop_types_default().shape({
    h: (prop_types_default()).number,
    s: (prop_types_default()).number,
    l: (prop_types_default()).number,
    a: (prop_types_default()).number
  })
};

GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.50 }
};

/* harmony default export */ const google_GooglePointer = (GooglePointer);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/google/GoogleFields.js





var GoogleFields = function GoogleFields(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hex = _ref.hex,
      hsv = _ref.hsv;


  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.rgb) {
      var values = data.rgb.split(',');
      isvalidColorString(data.rgb, 'rgb') && onChange({
        r: values[0],
        g: values[1],
        b: values[2],
        a: 1,
        source: 'rgb'
      }, e);
    } else if (data.hsv) {
      var _values = data.hsv.split(',');
      if (isvalidColorString(data.hsv, 'hsv')) {
        _values[2] = _values[2].replace('%', '');
        _values[1] = _values[1].replace('%', '');
        _values[0] = _values[0].replace('', '');
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: 'hsv'
        }, e);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(',');
      if (isvalidColorString(data.hsl, 'hsl')) {
        _values2[2] = _values2[2].replace('%', '');
        _values2[1] = _values2[1].replace('%', '');
        _values2[0] = _values2[0].replace('', '');
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: 'hsl'
        }, e);
      }
    }
  };

  var styles = (0,lib/* default */.Ay)({
    'default': {
      wrap: {
        display: 'flex',
        height: '100px',
        marginTop: '4px'
      },
      fields: {
        width: '100%'
      },
      column: {
        paddingTop: '10px',
        display: 'flex',
        justifyContent: 'space-between'
      },
      double: {
        padding: '0px 4.4px',
        boxSizing: 'border-box'
      },
      input: {
        width: '100%',
        height: '38px',
        boxSizing: 'border-box',
        padding: '4px 10% 3px',
        textAlign: 'center',
        border: '1px solid #dadce0',
        fontSize: '11px',
        textTransform: 'lowercase',
        borderRadius: '5px',
        outline: 'none',
        fontFamily: 'Roboto,Arial,sans-serif'
      },
      input2: {
        height: '38px',
        width: '100%',
        border: '1px solid #dadce0',
        boxSizing: 'border-box',
        fontSize: '11px',
        textTransform: 'lowercase',
        borderRadius: '5px',
        outline: 'none',
        paddingLeft: '10px',
        fontFamily: 'Roboto,Arial,sans-serif'
      },
      label: {
        textAlign: 'center',
        fontSize: '12px',
        background: '#fff',
        position: 'absolute',
        textTransform: 'uppercase',
        color: '#3c4043',
        width: '35px',
        top: '-6px',
        left: '0',
        right: '0',
        marginLeft: 'auto',
        marginRight: 'auto',
        fontFamily: 'Roboto,Arial,sans-serif'
      },
      label2: {
        left: '10px',
        textAlign: 'center',
        fontSize: '12px',
        background: '#fff',
        position: 'absolute',
        textTransform: 'uppercase',
        color: '#3c4043',
        width: '32px',
        top: '-6px',
        fontFamily: 'Roboto,Arial,sans-serif'
      },
      single: {
        flexGrow: '1',
        margin: '0px 4.4px'
      }
    }
  });

  var rgbValue = rgb.r + ', ' + rgb.g + ', ' + rgb.b;
  var hslValue = Math.round(hsl.h) + '\xB0, ' + Math.round(hsl.s * 100) + '%, ' + Math.round(hsl.l * 100) + '%';
  var hsvValue = Math.round(hsv.h) + '\xB0, ' + Math.round(hsv.s * 100) + '%, ' + Math.round(hsv.v * 100) + '%';

  return react.createElement(
    'div',
    { style: styles.wrap, className: 'flexbox-fix' },
    react.createElement(
      'div',
      { style: styles.fields },
      react.createElement(
        'div',
        { style: styles.double },
        react.createElement(common_EditableInput, {
          style: { input: styles.input, label: styles.label },
          label: 'hex',
          value: hex,
          onChange: handleChange
        })
      ),
      react.createElement(
        'div',
        { style: styles.column },
        react.createElement(
          'div',
          { style: styles.single },
          react.createElement(common_EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: 'rgb',
            value: rgbValue,
            onChange: handleChange
          })
        ),
        react.createElement(
          'div',
          { style: styles.single },
          react.createElement(common_EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: 'hsv',
            value: hsvValue,
            onChange: handleChange
          })
        ),
        react.createElement(
          'div',
          { style: styles.single },
          react.createElement(common_EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: 'hsl',
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};

/* harmony default export */ const google_GoogleFields = (GoogleFields);
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/components/google/Google.js










var Google = function Google(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hsv = _ref.hsv,
      hex = _ref.hex,
      header = _ref.header,
      _ref$styles = _ref.styles,
      passedStyles = _ref$styles === undefined ? {} : _ref$styles,
      _ref$className = _ref.className,
      className = _ref$className === undefined ? '' : _ref$className;

  var styles = (0,lib/* default */.Ay)(lodash_es_merge({
    'default': {
      picker: {
        width: width,
        background: '#fff',
        border: '1px solid #dfe1e5',
        boxSizing: 'initial',
        display: 'flex',
        flexWrap: 'wrap',
        borderRadius: '8px 8px 0px 0px'
      },
      head: {
        height: '57px',
        width: '100%',
        paddingTop: '16px',
        paddingBottom: '16px',
        paddingLeft: '16px',
        fontSize: '20px',
        boxSizing: 'border-box',
        fontFamily: 'Roboto-Regular,HelveticaNeue,Arial,sans-serif'
      },
      saturation: {
        width: '70%',
        padding: '0px',
        position: 'relative',
        overflow: 'hidden'
      },
      swatch: {
        width: '30%',
        height: '228px',
        padding: '0px',
        background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', 1)',
        position: 'relative',
        overflow: 'hidden'
      },
      body: {
        margin: 'auto',
        width: '95%'
      },
      controls: {
        display: 'flex',
        boxSizing: 'border-box',
        height: '52px',
        paddingTop: '22px'
      },
      color: {
        width: '32px'
      },
      hue: {
        height: '8px',
        position: 'relative',
        margin: '0px 16px 0px 16px',
        width: '100%'
      },
      Hue: {
        radius: '2px'
      }
    }
  }, passedStyles));
  return react.createElement(
    'div',
    { style: styles.picker, className: 'google-picker ' + className },
    react.createElement(
      'div',
      { style: styles.head },
      header
    ),
    react.createElement('div', { style: styles.swatch }),
    react.createElement(
      'div',
      { style: styles.saturation },
      react.createElement(common_Saturation, {
        hsl: hsl,
        hsv: hsv,
        pointer: google_GooglePointerCircle,
        onChange: onChange
      })
    ),
    react.createElement(
      'div',
      { style: styles.body },
      react.createElement(
        'div',
        { style: styles.controls, className: 'flexbox-fix' },
        react.createElement(
          'div',
          { style: styles.hue },
          react.createElement(common_Hue, {
            style: styles.Hue,
            hsl: hsl,
            radius: '4px',
            pointer: google_GooglePointer,
            onChange: onChange
          })
        )
      ),
      react.createElement(google_GoogleFields, {
        rgb: rgb,
        hsl: hsl,
        hex: hex,
        hsv: hsv,
        onChange: onChange
      })
    )
  );
};

Google.propTypes = {
  width: prop_types_default().oneOfType([(prop_types_default()).string, (prop_types_default()).number]),
  styles: (prop_types_default()).object,
  header: (prop_types_default()).string

};

Google.defaultProps = {
  width: 652,
  styles: {},
  header: 'Color picker'
};

/* harmony default export */ const google_Google = (common_ColorWrap(Google));
;// CONCATENATED MODULE: ../../../node_modules/react-color/es/index.js



















/***/ }),

/***/ 28271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _m: () => (/* binding */ VariableSizeList)
/* harmony export */ });
/* unused harmony exports FixedSizeGrid, FixedSizeList, VariableSizeGrid, areEqual, shouldComponentUpdate */
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77940);
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99805);
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51575);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(94717);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86326);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(61927);







// Animation frame based implementation of setTimeout.
// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js
var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
var now = hasNativePerformanceNow ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start = now();

  function tick() {
    if (now() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }

  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}

var size = -1; // This utility copied from "dom-helpers" package.

function getScrollbarSize(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }

  if (size === -1 || recalculate) {
    var div = document.createElement('div');
    var style = div.style;
    style.width = '50px';
    style.height = '50px';
    style.overflow = 'scroll';
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }

  return size;
}
var cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).
// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.
// The safest way to check this is to intentionally set a negative offset,
// and then verify that the subsequent "scroll" event matches the negative offset.
// If it does not match, then we can assume a non-standard RTL scroll implementation.

function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }

  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement('div');
    var outerStyle = outerDiv.style;
    outerStyle.width = '50px';
    outerStyle.height = '50px';
    outerStyle.overflow = 'scroll';
    outerStyle.direction = 'rtl';
    var innerDiv = document.createElement('div');
    var innerStyle = innerDiv.style;
    innerStyle.width = '100px';
    innerStyle.height = '100px';
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);

    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = 'positive-descending';
    } else {
      outerDiv.scrollLeft = 1;

      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = 'negative';
      } else {
        cachedRTLResult = 'positive-ascending';
      }
    }

    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }

  return cachedRTLResult;
}

var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;

var defaultItemKey = function defaultItemKey(_ref) {
  var columnIndex = _ref.columnIndex,
      data = _ref.data,
      rowIndex = _ref.rowIndex;
  return rowIndex + ":" + columnIndex;
}; // In DEV mode, this Set helps us only log a warning once per component instance.
// This avoids spamming the console every time a render happens.


var devWarningsOverscanCount = null;
var devWarningsOverscanRowsColumnsCount = null;
var devWarningsTagName = null;

if (false) {}

function createGridComponent(_ref2) {
  var _class;

  var getColumnOffset = _ref2.getColumnOffset,
      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,
      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,
      getColumnWidth = _ref2.getColumnWidth,
      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,
      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,
      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,
      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,
      getRowHeight = _ref2.getRowHeight,
      getRowOffset = _ref2.getRowOffset,
      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,
      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,
      initInstanceProps = _ref2.initInstanceProps,
      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,
      validateProps = _ref2.validateProps;
  return _class = /*#__PURE__*/function (_PureComponent) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(Grid, _PureComponent);

    // Always use explicit constructor for React components.
    // It produces less code after transpilation. (#26)
    // eslint-disable-next-line no-useless-constructor
    function Grid(props) {
      var _this;

      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_this));
      _this._resetIsScrollingTimeoutId = null;
      _this._outerRef = void 0;
      _this.state = {
        instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_this),
        isScrolling: false,
        horizontalScrollDirection: 'forward',
        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,
        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,
        scrollUpdateWasRequested: false,
        verticalScrollDirection: 'forward'
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {
        return _this.props.onItemsRendered({
          overscanColumnStartIndex: overscanColumnStartIndex,
          overscanColumnStopIndex: overscanColumnStopIndex,
          overscanRowStartIndex: overscanRowStartIndex,
          overscanRowStopIndex: overscanRowStopIndex,
          visibleColumnStartIndex: visibleColumnStartIndex,
          visibleColumnStopIndex: visibleColumnStopIndex,
          visibleRowStartIndex: visibleRowStartIndex,
          visibleRowStopIndex: visibleRowStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          horizontalScrollDirection: horizontalScrollDirection,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          verticalScrollDirection: verticalScrollDirection,
          scrollUpdateWasRequested: scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;

      _this._getItemStyle = function (rowIndex, columnIndex) {
        var _this$props = _this.props,
            columnWidth = _this$props.columnWidth,
            direction = _this$props.direction,
            rowHeight = _this$props.rowHeight;

        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);

        var key = rowIndex + ":" + columnIndex;
        var style;

        if (itemStyleCache.hasOwnProperty(key)) {
          style = itemStyleCache[key];
        } else {
          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);

          var isRtl = direction === 'rtl';
          itemStyleCache[key] = style = {
            position: 'absolute',
            left: isRtl ? undefined : _offset,
            right: isRtl ? _offset : undefined,
            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),
            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),
            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)
          };
        }

        return style;
      };

      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (_, __, ___) {
        return {};
      });

      _this._onScroll = function (event) {
        var _event$currentTarget = event.currentTarget,
            clientHeight = _event$currentTarget.clientHeight,
            clientWidth = _event$currentTarget.clientWidth,
            scrollLeft = _event$currentTarget.scrollLeft,
            scrollTop = _event$currentTarget.scrollTop,
            scrollHeight = _event$currentTarget.scrollHeight,
            scrollWidth = _event$currentTarget.scrollWidth;

        _this.setState(function (prevState) {
          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            // And we don't want to update state.isScrolling.
            return null;
          }

          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.
          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.

          var calculatedScrollLeft = scrollLeft;

          if (direction === 'rtl') {
            switch (getRTLOffsetType()) {
              case 'negative':
                calculatedScrollLeft = -scrollLeft;
                break;

              case 'positive-descending':
                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',
            scrollLeft: calculatedScrollLeft,
            scrollTop: calculatedScrollTop,
            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };

      _this._outerRefSetter = function (ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;

        if (typeof outerRef === 'function') {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
          outerRef.current = ref;
        }
      };

      _this._resetIsScrollingDebounced = function () {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }

        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
      };

      _this._resetIsScrolling = function () {
        _this._resetIsScrollingTimeoutId = null;

        _this.setState({
          isScrolling: false
        }, function () {
          // Clear style cache after state update has been committed.
          // This way we don't break pure sCU for items that don't use isScrolling param.
          _this._getItemStyleCache(-1);
        });
      };

      return _this;
    }

    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };

    var _proto = Grid.prototype;

    _proto.scrollTo = function scrollTo(_ref3) {
      var scrollLeft = _ref3.scrollLeft,
          scrollTop = _ref3.scrollTop;

      if (scrollLeft !== undefined) {
        scrollLeft = Math.max(0, scrollLeft);
      }

      if (scrollTop !== undefined) {
        scrollTop = Math.max(0, scrollTop);
      }

      this.setState(function (prevState) {
        if (scrollLeft === undefined) {
          scrollLeft = prevState.scrollLeft;
        }

        if (scrollTop === undefined) {
          scrollTop = prevState.scrollTop;
        }

        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {
          return null;
        }

        return {
          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          scrollUpdateWasRequested: true,
          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'
        };
      }, this._resetIsScrollingDebounced);
    };

    _proto.scrollToItem = function scrollToItem(_ref4) {
      var _ref4$align = _ref4.align,
          align = _ref4$align === void 0 ? 'auto' : _ref4$align,
          columnIndex = _ref4.columnIndex,
          rowIndex = _ref4.rowIndex;
      var _this$props2 = this.props,
          columnCount = _this$props2.columnCount,
          height = _this$props2.height,
          rowCount = _this$props2.rowCount,
          width = _this$props2.width;
      var _this$state = this.state,
          scrollLeft = _this$state.scrollLeft,
          scrollTop = _this$state.scrollTop;
      var scrollbarSize = getScrollbarSize();

      if (columnIndex !== undefined) {
        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
      }

      if (rowIndex !== undefined) {
        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
      }

      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,
      // to ensure it's fully visible.
      // But we only need to account for its size when it's actually visible.

      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;
      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;
      this.scrollTo({
        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,
        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop
      });
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props,
          initialScrollLeft = _this$props3.initialScrollLeft,
          initialScrollTop = _this$props3.initialScrollTop;

      if (this._outerRef != null) {
        var outerRef = this._outerRef;

        if (typeof initialScrollLeft === 'number') {
          outerRef.scrollLeft = initialScrollLeft;
        }

        if (typeof initialScrollTop === 'number') {
          outerRef.scrollTop = initialScrollTop;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      var direction = this.props.direction;
      var _this$state2 = this.state,
          scrollLeft = _this$state2.scrollLeft,
          scrollTop = _this$state2.scrollTop,
          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

      if (scrollUpdateWasRequested && this._outerRef != null) {
        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
        // So we need to determine which browser behavior we're dealing with, and mimic it.
        var outerRef = this._outerRef;

        if (direction === 'rtl') {
          switch (getRTLOffsetType()) {
            case 'negative':
              outerRef.scrollLeft = -scrollLeft;
              break;

            case 'positive-ascending':
              outerRef.scrollLeft = scrollLeft;
              break;

            default:
              var clientWidth = outerRef.clientWidth,
                  scrollWidth = outerRef.scrollWidth;
              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        } else {
          outerRef.scrollLeft = Math.max(0, scrollLeft);
        }

        outerRef.scrollTop = Math.max(0, scrollTop);
      }

      this._callPropsCallbacks();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };

    _proto.render = function render() {
      var _this$props4 = this.props,
          children = _this$props4.children,
          className = _this$props4.className,
          columnCount = _this$props4.columnCount,
          direction = _this$props4.direction,
          height = _this$props4.height,
          innerRef = _this$props4.innerRef,
          innerElementType = _this$props4.innerElementType,
          innerTagName = _this$props4.innerTagName,
          itemData = _this$props4.itemData,
          _this$props4$itemKey = _this$props4.itemKey,
          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,
          outerElementType = _this$props4.outerElementType,
          outerTagName = _this$props4.outerTagName,
          rowCount = _this$props4.rowCount,
          style = _this$props4.style,
          useIsScrolling = _this$props4.useIsScrolling,
          width = _this$props4.width;
      var isScrolling = this.state.isScrolling;

      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),
          columnStartIndex = _this$_getHorizontalR[0],
          columnStopIndex = _this$_getHorizontalR[1];

      var _this$_getVerticalRan = this._getVerticalRangeToRender(),
          rowStartIndex = _this$_getVerticalRan[0],
          rowStopIndex = _this$_getVerticalRan[1];

      var items = [];

      if (columnCount > 0 && rowCount) {
        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {
          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {
            items.push((0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(children, {
              columnIndex: _columnIndex,
              data: itemData,
              isScrolling: useIsScrolling ? isScrolling : undefined,
              key: itemKey({
                columnIndex: _columnIndex,
                data: itemData,
                rowIndex: _rowIndex
              }),
              rowIndex: _rowIndex,
              style: this._getItemStyle(_rowIndex, _columnIndex)
            }));
          }
        }
      } // Read this value AFTER items have been created,
      // So their actual sizes (if variable) are taken into consideration.


      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);
      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);
      return (0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(outerElementType || outerTagName || 'div', {
        className: className,
        onScroll: this._onScroll,
        ref: this._outerRefSetter,
        style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)({
          position: 'relative',
          height: height,
          width: width,
          overflow: 'auto',
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform',
          direction: direction
        }, style)
      }, (0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(innerElementType || innerTagName || 'div', {
        children: items,
        ref: innerRef,
        style: {
          height: estimatedTotalHeight,
          pointerEvents: isScrolling ? 'none' : undefined,
          width: estimatedTotalWidth
        }
      }));
    };

    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      var _this$props5 = this.props,
          columnCount = _this$props5.columnCount,
          onItemsRendered = _this$props5.onItemsRendered,
          onScroll = _this$props5.onScroll,
          rowCount = _this$props5.rowCount;

      if (typeof onItemsRendered === 'function') {
        if (columnCount > 0 && rowCount > 0) {
          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),
              _overscanColumnStartIndex = _this$_getHorizontalR2[0],
              _overscanColumnStopIndex = _this$_getHorizontalR2[1],
              _visibleColumnStartIndex = _this$_getHorizontalR2[2],
              _visibleColumnStopIndex = _this$_getHorizontalR2[3];

          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),
              _overscanRowStartIndex = _this$_getVerticalRan2[0],
              _overscanRowStopIndex = _this$_getVerticalRan2[1],
              _visibleRowStartIndex = _this$_getVerticalRan2[2],
              _visibleRowStopIndex = _this$_getVerticalRan2[3];

          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);
        }
      }

      if (typeof onScroll === 'function') {
        var _this$state3 = this.state,
            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,
            _scrollLeft = _this$state3.scrollLeft,
            _scrollTop = _this$state3.scrollTop,
            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,
            _verticalScrollDirection = _this$state3.verticalScrollDirection;

        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);
      }
    } // Lazily create and cache item styles while scrolling,
    // So that pure component sCU will prevent re-renders.
    // We maintain this cache, and pass a style prop rather than index,
    // So that List can clear cached styles and force item re-render if necessary.
    ;

    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {
      var _this$props6 = this.props,
          columnCount = _this$props6.columnCount,
          overscanColumnCount = _this$props6.overscanColumnCount,
          overscanColumnsCount = _this$props6.overscanColumnsCount,
          overscanCount = _this$props6.overscanCount,
          rowCount = _this$props6.rowCount;
      var _this$state4 = this.state,
          horizontalScrollDirection = _this$state4.horizontalScrollDirection,
          isScrolling = _this$state4.isScrolling,
          scrollLeft = _this$state4.scrollLeft;
      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;

      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);
      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {
      var _this$props7 = this.props,
          columnCount = _this$props7.columnCount,
          overscanCount = _this$props7.overscanCount,
          overscanRowCount = _this$props7.overscanRowCount,
          overscanRowsCount = _this$props7.overscanRowsCount,
          rowCount = _this$props7.rowCount;
      var _this$state5 = this.state,
          isScrolling = _this$state5.isScrolling,
          verticalScrollDirection = _this$state5.verticalScrollDirection,
          scrollTop = _this$state5.scrollTop;
      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;

      if (columnCount === 0 || rowCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);
      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;
      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    return Grid;
  }(react__WEBPACK_IMPORTED_MODULE_4__.PureComponent), _class.defaultProps = {
    direction: 'ltr',
    itemData: undefined,
    useIsScrolling: false
  }, _class;
}

var validateSharedProps = function validateSharedProps(_ref5, _ref6) {
  var children = _ref5.children,
      direction = _ref5.direction,
      height = _ref5.height,
      innerTagName = _ref5.innerTagName,
      outerTagName = _ref5.outerTagName,
      overscanColumnsCount = _ref5.overscanColumnsCount,
      overscanCount = _ref5.overscanCount,
      overscanRowsCount = _ref5.overscanRowsCount,
      width = _ref5.width;
  var instance = _ref6.instance;

  if (false) {}
};

var DEFAULT_ESTIMATED_ITEM_SIZE = 50;

var getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {
  var rowCount = _ref.rowCount;
  var rowMetadataMap = _ref2.rowMetadataMap,
      estimatedRowHeight = _ref2.estimatedRowHeight,
      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;
  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredRowIndex >= rowCount) {
    lastMeasuredRowIndex = rowCount - 1;
  }

  if (lastMeasuredRowIndex >= 0) {
    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};

var getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {
  var columnCount = _ref3.columnCount;
  var columnMetadataMap = _ref4.columnMetadataMap,
      estimatedColumnWidth = _ref4.estimatedColumnWidth,
      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;
  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredColumnIndex >= columnCount) {
    lastMeasuredColumnIndex = columnCount - 1;
  }

  if (lastMeasuredColumnIndex >= 0) {
    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];
    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;
  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;
};

var getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {
  var itemMetadataMap, itemSize, lastMeasuredIndex;

  if (itemType === 'column') {
    itemMetadataMap = instanceProps.columnMetadataMap;
    itemSize = props.columnWidth;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    itemSize = props.rowHeight;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }

  if (index > lastMeasuredIndex) {
    var offset = 0;

    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset = itemMetadata.offset + itemMetadata.size;
    }

    for (var i = lastMeasuredIndex + 1; i <= index; i++) {
      var size = itemSize(i);
      itemMetadataMap[i] = {
        offset: offset,
        size: size
      };
      offset += size;
    }

    if (itemType === 'column') {
      instanceProps.lastMeasuredColumnIndex = index;
    } else {
      instanceProps.lastMeasuredRowIndex = index;
    }
  }

  return itemMetadataMap[index];
};

var findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {
  var itemMetadataMap, lastMeasuredIndex;

  if (itemType === 'column') {
    itemMetadataMap = instanceProps.columnMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;
  } else {
    itemMetadataMap = instanceProps.rowMetadataMap;
    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;
  }

  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;

  if (lastMeasuredItemOffset >= offset) {
    // If we've already measured items within this range just use a binary search as it's faster.
    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);
  } else {
    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
    // The overall complexity for this approach is O(log n).
    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);
  }
};

var findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;

    if (currentOffset === offset) {
      return middle;
    } else if (currentOffset < offset) {
      low = middle + 1;
    } else if (currentOffset > offset) {
      high = middle - 1;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

var findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {
  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;
  var interval = 1;

  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {
    index += interval;
    interval *= 2;
  }

  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);
};

var getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {
  var size = itemType === 'column' ? props.width : props.height;
  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,
  // To ensure it reflects actual measurements instead of just estimates.

  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);
  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);

  if (align === 'smart') {
    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
      align = 'auto';
    } else {
      align = 'center';
    }
  }

  switch (align) {
    case 'start':
      return maxOffset;

    case 'end':
      return minOffset;

    case 'center':
      return Math.round(minOffset + (maxOffset - minOffset) / 2);

    case 'auto':
    default:
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        // Because we only take into account the scrollbar size when calculating minOffset
        // this value can be larger than maxOffset when at the end of the list
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }

  }
};

var VariableSizeGrid = /*#__PURE__*/createGridComponent({
  getColumnOffset: function getColumnOffset(props, index, instanceProps) {
    return getItemMetadata('column', props, index, instanceProps).offset;
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {
    return findNearestItem('column', props, instanceProps, scrollLeft);
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {
    var columnCount = props.columnCount,
        width = props.width;
    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);
    var maxOffset = scrollLeft + width;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < columnCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  getColumnWidth: function getColumnWidth(props, index, instanceProps) {
    return instanceProps.columnMetadataMap[index].size;
  },
  getEstimatedTotalHeight: getEstimatedTotalHeight,
  getEstimatedTotalWidth: getEstimatedTotalWidth,
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);
  },
  getRowOffset: function getRowOffset(props, index, instanceProps) {
    return getItemMetadata('row', props, index, instanceProps).offset;
  },
  getRowHeight: function getRowHeight(props, index, instanceProps) {
    return instanceProps.rowMetadataMap[index].size;
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {
    return findNearestItem('row', props, instanceProps, scrollTop);
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {
    var rowCount = props.rowCount,
        height = props.height;
    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);
    var maxOffset = scrollTop + height;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < rowCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref5 = props,
        estimatedColumnWidth = _ref5.estimatedColumnWidth,
        estimatedRowHeight = _ref5.estimatedRowHeight;
    var instanceProps = {
      columnMetadataMap: {},
      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,
      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,
      lastMeasuredColumnIndex: -1,
      lastMeasuredRowIndex: -1,
      rowMetadataMap: {}
    };

    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instance.resetAfterIndices({
        columnIndex: columnIndex,
        shouldForceUpdate: shouldForceUpdate
      });
    };

    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instance.resetAfterIndices({
        rowIndex: rowIndex,
        shouldForceUpdate: shouldForceUpdate
      });
    };

    instance.resetAfterIndices = function (_ref6) {
      var columnIndex = _ref6.columnIndex,
          rowIndex = _ref6.rowIndex,
          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,
          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;

      if (typeof columnIndex === 'number') {
        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);
      }

      if (typeof rowIndex === 'number') {
        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);
      } // We could potentially optimize further by only evicting styles after this index,
      // But since styles are only cached while scrolling is in progress-
      // It seems an unnecessary optimization.
      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.


      instance._getItemStyleCache(-1);

      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };

    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref7) {
    var columnWidth = _ref7.columnWidth,
        rowHeight = _ref7.rowHeight;

    if (false) {}
  }
});

var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;

var defaultItemKey$1 = function defaultItemKey(index, data) {
  return index;
}; // In DEV mode, this Set helps us only log a warning once per component instance.
// This avoids spamming the console every time a render happens.


var devWarningsDirection = null;
var devWarningsTagName$1 = null;

if (false) {}

function createListComponent(_ref) {
  var _class;

  var getItemOffset = _ref.getItemOffset,
      getEstimatedTotalSize = _ref.getEstimatedTotalSize,
      getItemSize = _ref.getItemSize,
      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,
      getStartIndexForOffset = _ref.getStartIndexForOffset,
      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,
      initInstanceProps = _ref.initInstanceProps,
      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,
      validateProps = _ref.validateProps;
  return _class = /*#__PURE__*/function (_PureComponent) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(List, _PureComponent);

    // Always use explicit constructor for React components.
    // It produces less code after transpilation. (#26)
    // eslint-disable-next-line no-useless-constructor
    function List(props) {
      var _this;

      _this = _PureComponent.call(this, props) || this;
      _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_this));
      _this._outerRef = void 0;
      _this._resetIsScrollingTimeoutId = null;
      _this.state = {
        instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_this),
        isScrolling: false,
        scrollDirection: 'forward',
        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this._callOnItemsRendered = void 0;
      _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this.props.onItemsRendered({
          overscanStartIndex: overscanStartIndex,
          overscanStopIndex: overscanStopIndex,
          visibleStartIndex: visibleStartIndex,
          visibleStopIndex: visibleStopIndex
        });
      });
      _this._callOnScroll = void 0;
      _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this.props.onScroll({
          scrollDirection: scrollDirection,
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: scrollUpdateWasRequested
        });
      });
      _this._getItemStyle = void 0;

      _this._getItemStyle = function (index) {
        var _this$props = _this.props,
            direction = _this$props.direction,
            itemSize = _this$props.itemSize,
            layout = _this$props.layout;

        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);

        var style;

        if (itemStyleCache.hasOwnProperty(index)) {
          style = itemStyleCache[index];
        } else {
          var _offset = getItemOffset(_this.props, index, _this._instanceProps);

          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction "horizontal"

          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
          var isRtl = direction === 'rtl';
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index] = style = {
            position: 'absolute',
            left: isRtl ? undefined : offsetHorizontal,
            right: isRtl ? offsetHorizontal : undefined,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size : '100%',
            width: isHorizontal ? size : '100%'
          };
        }

        return style;
      };

      _this._getItemStyleCache = void 0;
      _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(function (_, __, ___) {
        return {};
      });

      _this._onScrollHorizontal = function (event) {
        var _event$currentTarget = event.currentTarget,
            clientWidth = _event$currentTarget.clientWidth,
            scrollLeft = _event$currentTarget.scrollLeft,
            scrollWidth = _event$currentTarget.scrollWidth;

        _this.setState(function (prevState) {
          if (prevState.scrollOffset === scrollLeft) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            // And we don't want to update state.isScrolling.
            return null;
          }

          var direction = _this.props.direction;
          var scrollOffset = scrollLeft;

          if (direction === 'rtl') {
            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.
            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.
            switch (getRTLOffsetType()) {
              case 'negative':
                scrollOffset = -scrollLeft;
                break;

              case 'positive-descending':
                scrollOffset = scrollWidth - clientWidth - scrollLeft;
                break;
            }
          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
            scrollOffset: scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };

      _this._onScrollVertical = function (event) {
        var _event$currentTarget2 = event.currentTarget,
            clientHeight = _event$currentTarget2.clientHeight,
            scrollHeight = _event$currentTarget2.scrollHeight,
            scrollTop = _event$currentTarget2.scrollTop;

        _this.setState(function (prevState) {
          if (prevState.scrollOffset === scrollTop) {
            // Scroll position may have been updated by cDM/cDU,
            // In which case we don't need to trigger another render,
            // And we don't want to update state.isScrolling.
            return null;
          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.


          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
            scrollOffset: scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this._resetIsScrollingDebounced);
      };

      _this._outerRefSetter = function (ref) {
        var outerRef = _this.props.outerRef;
        _this._outerRef = ref;

        if (typeof outerRef === 'function') {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {
          outerRef.current = ref;
        }
      };

      _this._resetIsScrollingDebounced = function () {
        if (_this._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this._resetIsScrollingTimeoutId);
        }

        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };

      _this._resetIsScrolling = function () {
        _this._resetIsScrollingTimeoutId = null;

        _this.setState({
          isScrolling: false
        }, function () {
          // Clear style cache after state update has been committed.
          // This way we don't break pure sCU for items that don't use isScrolling param.
          _this._getItemStyleCache(-1, null);
        });
      };

      return _this;
    }

    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps(nextProps);
      return null;
    };

    var _proto = List.prototype;

    _proto.scrollTo = function scrollTo(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function (prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }

        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',
          scrollOffset: scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };

    _proto.scrollToItem = function scrollToItem(index, align) {
      if (align === void 0) {
        align = 'auto';
      }

      var _this$props2 = this.props,
          itemCount = _this$props2.itemCount,
          layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.
      // But we only need to account for its size when it's actually visible.
      // This is an edge case for lists; normally they only scroll in the dominant direction.

      var scrollbarSize = 0;

      if (this._outerRef) {
        var outerRef = this._outerRef;

        if (layout === 'vertical') {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;
        }
      }

      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));
    };

    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props,
          direction = _this$props3.direction,
          initialScrollOffset = _this$props3.initialScrollOffset,
          layout = _this$props3.layout;

      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props,
          direction = _this$props4.direction,
          layout = _this$props4.layout;
      var _this$state = this.state,
          scrollOffset = _this$state.scrollOffset,
          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;

      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef; // TODO Deprecate direction "horizontal"

        if (direction === 'horizontal' || layout === 'horizontal') {
          if (direction === 'rtl') {
            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.
            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).
            // So we need to determine which browser behavior we're dealing with, and mimic it.
            switch (getRTLOffsetType()) {
              case 'negative':
                outerRef.scrollLeft = -scrollOffset;
                break;

              case 'positive-ascending':
                outerRef.scrollLeft = scrollOffset;
                break;

              default:
                var clientWidth = outerRef.clientWidth,
                    scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }

      this._callPropsCallbacks();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };

    _proto.render = function render() {
      var _this$props5 = this.props,
          children = _this$props5.children,
          className = _this$props5.className,
          direction = _this$props5.direction,
          height = _this$props5.height,
          innerRef = _this$props5.innerRef,
          innerElementType = _this$props5.innerElementType,
          innerTagName = _this$props5.innerTagName,
          itemCount = _this$props5.itemCount,
          itemData = _this$props5.itemData,
          _this$props5$itemKey = _this$props5.itemKey,
          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,
          layout = _this$props5.layout,
          outerElementType = _this$props5.outerElementType,
          outerTagName = _this$props5.outerTagName,
          style = _this$props5.style,
          useIsScrolling = _this$props5.useIsScrolling,
          width = _this$props5.width;
      var isScrolling = this.state.isScrolling; // TODO Deprecate direction "horizontal"

      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;

      var _this$_getRangeToRend = this._getRangeToRender(),
          startIndex = _this$_getRangeToRend[0],
          stopIndex = _this$_getRangeToRend[1];

      var items = [];

      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push((0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : undefined,
            style: this._getItemStyle(_index)
          }));
        }
      } // Read this value AFTER items have been created,
      // So their actual sizes (if variable) are taken into consideration.


      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);
      return (0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(outerElementType || outerTagName || 'div', {
        className: className,
        onScroll: onScroll,
        ref: this._outerRefSetter,
        style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)({
          position: 'relative',
          height: height,
          width: width,
          overflow: 'auto',
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform',
          direction: direction
        }, style)
      }, (0,react__WEBPACK_IMPORTED_MODULE_4__.createElement)(innerElementType || innerTagName || 'div', {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? '100%' : estimatedTotalSize,
          pointerEvents: isScrolling ? 'none' : undefined,
          width: isHorizontal ? estimatedTotalSize : '100%'
        }
      }));
    };

    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === 'function') {
        var itemCount = this.props.itemCount;

        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(),
              _overscanStartIndex = _this$_getRangeToRend2[0],
              _overscanStopIndex = _this$_getRangeToRend2[1],
              _visibleStartIndex = _this$_getRangeToRend2[2],
              _visibleStopIndex = _this$_getRangeToRend2[3];

          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }

      if (typeof this.props.onScroll === 'function') {
        var _this$state2 = this.state,
            _scrollDirection = _this$state2.scrollDirection,
            _scrollOffset = _this$state2.scrollOffset,
            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;

        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    } // Lazily create and cache item styles while scrolling,
    // So that pure component sCU will prevent re-renders.
    // We maintain this cache, and pass a style prop rather than index,
    // So that List can clear cached styles and force item re-render if necessary.
    ;

    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props,
          itemCount = _this$props6.itemCount,
          overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state,
          isScrolling = _this$state3.isScrolling,
          scrollDirection = _this$state3.scrollDirection,
          scrollOffset = _this$state3.scrollOffset;

      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }

      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.
      // If there isn't at least one extra item, tab loops back around.

      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };

    return List;
  }(react__WEBPACK_IMPORTED_MODULE_4__.PureComponent), _class.defaultProps = {
    direction: 'ltr',
    itemData: undefined,
    layout: 'vertical',
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
} // NOTE: I considered further wrapping individual items with a pure ListItem component.
// This would avoid ever calling the render function for the same index more than once,
// But it would also add the overhead of a lot of components/fibers.
// I assume people already do this (render function returning a class component),
// So my doing it would just unnecessarily double the wrappers.

var validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {
  var children = _ref2.children,
      direction = _ref2.direction,
      height = _ref2.height,
      layout = _ref2.layout,
      innerTagName = _ref2.innerTagName,
      outerTagName = _ref2.outerTagName,
      width = _ref2.width;
  var instance = _ref3.instance;

  if (false) { var isHorizontal; }
};

var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;

var getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {
  var _ref = props,
      itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;

  if (index > lastMeasuredIndex) {
    var offset = 0;

    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset = itemMetadata.offset + itemMetadata.size;
    }

    for (var i = lastMeasuredIndex + 1; i <= index; i++) {
      var size = itemSize(i);
      itemMetadataMap[i] = {
        offset: offset,
        size: size
      };
      offset += size;
    }

    instanceProps.lastMeasuredIndex = index;
  }

  return itemMetadataMap[index];
};

var findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {
  var itemMetadataMap = instanceProps.itemMetadataMap,
      lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;

  if (lastMeasuredItemOffset >= offset) {
    // If we've already measured items within this range just use a binary search as it's faster.
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);
  } else {
    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
    // The overall complexity for this approach is O(log n).
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);
  }
};

var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;

    if (currentOffset === offset) {
      return middle;
    } else if (currentOffset < offset) {
      low = middle + 1;
    } else if (currentOffset > offset) {
      high = middle - 1;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {
  var itemCount = props.itemCount;
  var interval = 1;

  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {
    index += interval;
    interval *= 2;
  }

  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);
};

var getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap,
      estimatedItemSize = _ref3.estimatedItemSize,
      lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.
  // https://github.com/bvaughn/react-window/pull/138

  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }

  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }

  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};

var VariableSizeList = /*#__PURE__*/createListComponent({
  getItemOffset: function getItemOffset(props, index, instanceProps) {
    return getItemMetadata$1(props, index, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index, instanceProps) {
    return instanceProps.itemMetadataMap[index].size;
  },
  getEstimatedTotalSize: getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = props.direction,
        height = props.height,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,
    // To ensure it reflects actual measurements instead of just estimates.

    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);

    if (align === 'smart') {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        return Math.round(minOffset + (maxOffset - minOffset) / 2);

      case 'auto':
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction = props.direction,
        height = props.height,
        itemCount = props.itemCount,
        layout = props.layout,
        width = props.width; // TODO Deprecate direction "horizontal"

    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size;
    var offset = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;

    while (stopIndex < itemCount - 1 && offset < maxOffset) {
      stopIndex++;
      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }

    return stopIndex;
  },
  initInstanceProps: function initInstanceProps(props, instance) {
    var _ref4 = props,
        estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };

    instance.resetAfterIndex = function (index, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }

      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,
      // But since styles are only cached while scrolling is in progress-
      // It seems an unnecessary optimization.
      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.

      instance._getItemStyleCache(-1);

      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };

    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps(_ref5) {
    var itemSize = _ref5.itemSize;

    if (false) {}
  }
});

var FixedSizeGrid = /*#__PURE__*/createGridComponent({
  getColumnOffset: function getColumnOffset(_ref, index) {
    var columnWidth = _ref.columnWidth;
    return index * columnWidth;
  },
  getColumnWidth: function getColumnWidth(_ref2, index) {
    var columnWidth = _ref2.columnWidth;
    return columnWidth;
  },
  getRowOffset: function getRowOffset(_ref3, index) {
    var rowHeight = _ref3.rowHeight;
    return index * rowHeight;
  },
  getRowHeight: function getRowHeight(_ref4, index) {
    var rowHeight = _ref4.rowHeight;
    return rowHeight;
  },
  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {
    var rowCount = _ref5.rowCount,
        rowHeight = _ref5.rowHeight;
    return rowHeight * rowCount;
  },
  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {
    var columnCount = _ref6.columnCount,
        columnWidth = _ref6.columnWidth;
    return columnWidth * columnCount;
  },
  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {
    var columnCount = _ref7.columnCount,
        columnWidth = _ref7.columnWidth,
        width = _ref7.width;
    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);
    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);

    if (align === 'smart') {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        // "Centered" offset is usually the average of the min and max.
        // But near the edges of the list, this doesn't hold true.
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

        if (middleOffset < Math.ceil(width / 2)) {
          return 0; // near the beginning
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset; // near the end
        } else {
          return middleOffset;
        }

      case 'auto':
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          // Because we only take into account the scrollbar size when calculating minOffset
          // this value can be larger than maxOffset when at the end of the list
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {
    var rowHeight = _ref8.rowHeight,
        height = _ref8.height,
        rowCount = _ref8.rowCount;
    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);
    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);

    if (align === 'smart') {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        // "Centered" offset is usually the average of the min and max.
        // But near the edges of the list, this doesn't hold true.
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

        if (middleOffset < Math.ceil(height / 2)) {
          return 0; // near the beginning
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset; // near the end
        } else {
          return middleOffset;
        }

      case 'auto':
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          // Because we only take into account the scrollbar size when calculating minOffset
          // this value can be larger than maxOffset when at the end of the list
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {
    var columnWidth = _ref9.columnWidth,
        columnCount = _ref9.columnCount;
    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));
  },
  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {
    var columnWidth = _ref10.columnWidth,
        columnCount = _ref10.columnCount,
        width = _ref10.width;
    var left = startIndex * columnWidth;
    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);
    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive
    ));
  },
  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {
    var rowHeight = _ref11.rowHeight,
        rowCount = _ref11.rowCount;
    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));
  },
  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {
    var rowHeight = _ref12.rowHeight,
        rowCount = _ref12.rowCount,
        height = _ref12.height;
    var top = startIndex * rowHeight;
    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps(props) {// Noop
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref13) {
    var columnWidth = _ref13.columnWidth,
        rowHeight = _ref13.rowHeight;

    if (false) {}
  }
});

var FixedSizeList = /*#__PURE__*/createListComponent({
  getItemOffset: function getItemOffset(_ref, index) {
    var itemSize = _ref.itemSize;
    return index * itemSize;
  },
  getItemSize: function getItemSize(_ref2, index) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {
    var itemCount = _ref3.itemCount,
        itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = _ref4.direction,
        height = _ref4.height,
        itemCount = _ref4.itemCount,
        itemSize = _ref4.itemSize,
        layout = _ref4.layout,
        width = _ref4.width;
    // TODO Deprecate direction "horizontal"
    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var size = isHorizontal ? width : height;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size);
    var maxOffset = Math.min(lastItemOffset, index * itemSize);
    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);

    if (align === 'smart') {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        align = 'auto';
      } else {
        align = 'center';
      }
    }

    switch (align) {
      case 'start':
        return maxOffset;

      case 'end':
        return minOffset;

      case 'center':
        {
          // "Centered" offset is usually the average of the min and max.
          // But near the edges of the list, this doesn't hold true.
          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);

          if (middleOffset < Math.ceil(size / 2)) {
            return 0; // near the beginning
          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
            return lastItemOffset; // near the end
          } else {
            return middleOffset;
          }
        }

      case 'auto':
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }

    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {
    var itemCount = _ref5.itemCount,
        itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {
    var direction = _ref6.direction,
        height = _ref6.height,
        itemCount = _ref6.itemCount,
        itemSize = _ref6.itemSize,
        layout = _ref6.layout,
        width = _ref6.width;
    // TODO Deprecate direction "horizontal"
    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';
    var offset = startIndex * itemSize;
    var size = isHorizontal ? width : height;
    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);
    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps(props) {// Noop
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps(_ref7) {
    var itemSize = _ref7.itemSize;

    if (false) {}
  }
});

// Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349
function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
}

var _excluded = (/* unused pure expression or super */ null && (["style"])),
    _excluded2 = (/* unused pure expression or super */ null && (["style"]));
// It knows to compare individual style props and ignore the wrapper object.
// See https://reactjs.org/docs/react-api.html#reactmemo

function areEqual(prevProps, nextProps) {
  var prevStyle = prevProps.style,
      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);

  var nextStyle = nextProps.style,
      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);

  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);
}

// It knows to compare individual style props and ignore the wrapper object.
// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate

function shouldComponentUpdate(nextProps, nextState) {
  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);
}


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ 97002:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.autoprefix = undefined;

var _forOwn2 = __webpack_require__(59741);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },

  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },

  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },

  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(' ');
    return {
      position: 'absolute',
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      'extend': name
    };
  }
};

var autoprefix = exports.autoprefix = function autoprefix(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function (styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function (value, key) {
      var transform = transforms[key];
      if (transform) {
        expanded = _extends({}, expanded, transform(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};

exports["default"] = autoprefix;

/***/ }),

/***/ 2990:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.active = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(86326);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var active = exports.active = function active(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Active, _React$Component);

    function Active() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Active);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function () {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function () {
        return _this.setState({ active: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Active;
  }(_react2.default.Component);
};

exports["default"] = active;

/***/ }),

/***/ 77136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hover = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(86326);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hover = exports.hover = function hover(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Hover, _React$Component);

    function Hover() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Hover);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function () {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function () {
        return _this.setState({ hover: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Hover;
  }(_react2.default.Component);
};

exports["default"] = hover;

/***/ }),

/***/ 23003:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.flattenNames = undefined;

var _isString2 = __webpack_require__(87561);

var _isString3 = _interopRequireDefault(_isString2);

var _forOwn2 = __webpack_require__(59741);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _isPlainObject2 = __webpack_require__(5229);

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _map2 = __webpack_require__(764);

var _map3 = _interopRequireDefault(_map2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flattenNames = exports.flattenNames = function flattenNames() {
  var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var names = [];

  (0, _map3.default)(things, function (thing) {
    if (Array.isArray(thing)) {
      flattenNames(thing).map(function (name) {
        return names.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3.default)(thing, function (value, key) {
        value === true && names.push(key);
        names.push(key + '-' + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names.push(thing);
    }
  });

  return names;
};

exports["default"] = flattenNames;

/***/ }),

/***/ 56457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.H8 = __webpack_unused_export__ = undefined;

var _flattenNames = __webpack_require__(23003);

var _flattenNames2 = _interopRequireDefault(_flattenNames);

var _mergeClasses = __webpack_require__(70101);

var _mergeClasses2 = _interopRequireDefault(_mergeClasses);

var _autoprefix = __webpack_require__(97002);

var _autoprefix2 = _interopRequireDefault(_autoprefix);

var _hover2 = __webpack_require__(77136);

var _hover3 = _interopRequireDefault(_hover2);

var _active = __webpack_require__(2990);

var _active2 = _interopRequireDefault(_active);

var _loop2 = __webpack_require__(26431);

var _loop3 = _interopRequireDefault(_loop2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

__webpack_unused_export__ = _hover3.default;
exports.H8 = _hover3.default;
__webpack_unused_export__ = _active2.default;
__webpack_unused_export__ = _loop3.default;
var ReactCSS = __webpack_unused_export__ = function ReactCSS(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }

  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};

exports.Ay = ReactCSS;

/***/ }),

/***/ 26431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var loopable = function loopable(i, length) {
  var props = {};
  var setProp = function setProp(name) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    props[name] = value;
  };

  i === 0 && setProp('first-child');
  i === length - 1 && setProp('last-child');
  (i === 0 || i % 2 === 0) && setProp('even');
  Math.abs(i % 2) === 1 && setProp('odd');
  setProp('nth-child', i);

  return props;
};

exports["default"] = loopable;

/***/ }),

/***/ 70101:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mergeClasses = undefined;

var _forOwn2 = __webpack_require__(59741);

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _cloneDeep2 = __webpack_require__(81285);

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mergeClasses = exports.mergeClasses = function mergeClasses(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function (name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3.default)(toMerge, function (value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }

        styles[key] = _extends({}, styles[key], toMerge[key]);
      });
    }

    return name;
  });
  return styles;
};

exports["default"] = mergeClasses;

/***/ }),

/***/ 76785:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e=__webpack_require__(86326);function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k="function"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}
function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;


/***/ }),

/***/ 92462:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h=__webpack_require__(86326),n=__webpack_require__(73634);function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q="function"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;
exports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);
u(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};


/***/ }),

/***/ 73634:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(76785);
} else {}


/***/ }),

/***/ 61100:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(92462);
} else {}


/***/ }),

/***/ 78713:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  vt: () => (/* binding */ create)
});

// UNUSED EXPORTS: createStore, default, useStore

;// CONCATENATED MODULE: ../../../node_modules/zustand/esm/vanilla.mjs
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if (( false ? 0 : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};



// EXTERNAL MODULE: ../../../node_modules/react/index.js
var react = __webpack_require__(86326);
// EXTERNAL MODULE: ../../../node_modules/use-sync-external-store/shim/with-selector.js
var with_selector = __webpack_require__(61100);
;// CONCATENATED MODULE: ../../../node_modules/zustand/esm/index.mjs





const { useDebugValue } = react;
const { useSyncExternalStoreWithSelector } = with_selector;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if (( false ? 0 : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  if (( false ? 0 : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
var esm_react = (createState) => {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create(createState);
};




/***/ }),

/***/ 21978:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lt: () => (/* binding */ devtools)
/* harmony export */ });
/* unused harmony exports combine, createJSONStorage, persist, redux, subscribeWithSelector */
const reduxImpl = (reducer, initial) => (set, _get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action), false, action);
    return action;
  };
  api.dispatchFromDevtools = true;
  return { dispatch: (...a) => api.dispatch(...a), ...initial };
};
const redux = (/* unused pure expression or super */ null && (reduxImpl));

const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api) return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
const extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : ( false ? 0 : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (_e) {
  }
  if (!extensionConnector) {
    if (( false ? 0 : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording) return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if (( false ? 0 : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState) return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0) f(parsed);
};

const subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
const subscribeWithSelector = (/* unused pure expression or super */ null && (subscribeWithSelectorImpl));

const combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));

function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (_e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
const oldImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (_e) {
  }
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e) => {
      errorInSync = e;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
const newImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if (( false ? 0 : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
const persist = (/* unused pure expression or super */ null && (persistImpl));




/***/ })

}]);