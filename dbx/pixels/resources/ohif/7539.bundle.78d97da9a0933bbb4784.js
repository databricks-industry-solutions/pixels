"use strict";
(globalThis["webpackChunk"] = globalThis["webpackChunk"] || []).push([[7539],{

/***/ 75183:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["Interaction"] = "Interaction";
    ChangeTypes["HandlesUpdated"] = "HandlesUpdated";
    ChangeTypes["StatsUpdated"] = "StatsUpdated";
    ChangeTypes["InitialSetup"] = "InitialSetup";
    ChangeTypes["Completed"] = "Completed";
    ChangeTypes["InterpolationUpdated"] = "InterpolationUpdated";
    ChangeTypes["History"] = "History";
    ChangeTypes["MetadataReferenceModified"] = "MetadataReferenceModified";
    ChangeTypes["LabelChange"] = "LabelChange";
})(ChangeTypes || (ChangeTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChangeTypes);


/***/ }),

/***/ 94021:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["TOOL_ACTIVATED"] = "CORNERSTONE_TOOLS_TOOL_ACTIVATED";
    Events["TOOLGROUP_VIEWPORT_ADDED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED";
    Events["TOOLGROUP_VIEWPORT_REMOVED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED";
    Events["TOOL_MODE_CHANGED"] = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED";
    Events["CROSSHAIR_TOOL_CENTER_CHANGED"] = "CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED";
    Events["VOLUMECROPPINGCONTROL_TOOL_CHANGED"] = "CORNERSTONE_TOOLS_VOLUMECROPPINGCONTROL_TOOL_CHANGED";
    Events["VOLUMECROPPING_TOOL_CHANGED"] = "CORNERSTONE_TOOLS_VOLUMECROPPING_TOOL_CHANGED";
    Events["STACK_PREFETCH_COMPLETE"] = "CORNERSTONE_TOOLS_STACK_PREFETCH_COMPLETE";
    Events["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
    Events["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
    Events["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
    Events["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
    Events["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
    Events["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
    Events["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
    Events["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
    Events["ANNOTATION_CUT_MERGE_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_CUT_MERGE_PROCESS_COMPLETED";
    Events["ANNOTATION_INTERPOLATION_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED";
    Events["INTERPOLATED_ANNOTATIONS_REMOVED"] = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED";
    Events["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
    Events["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
    Events["SEGMENTATION_REPRESENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED";
    Events["SEGMENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED";
    Events["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
    Events["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
    Events["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
    Events["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
    Events["HISTORY_UNDO"] = "CORNERSTONE_TOOLS_HISTORY_UNDO";
    Events["HISTORY_REDO"] = "CORNERSTONE_TOOLS_HISTORY_REDO";
    Events["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
    Events["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
    Events["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
    Events["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
    Events["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
    Events["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
    Events["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
    Events["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
    Events["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
    Events["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
    Events["TOUCH_START"] = "CORNERSTONE_TOOLS_TOUCH_START";
    Events["TOUCH_START_ACTIVATE"] = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE";
    Events["TOUCH_PRESS"] = "CORNERSTONE_TOOLS_TOUCH_PRESS";
    Events["TOUCH_DRAG"] = "CORNERSTONE_TOOLS_TOUCH_DRAG";
    Events["TOUCH_END"] = "CORNERSTONE_TOOLS_TOUCH_END";
    Events["TOUCH_TAP"] = "CORNERSTONE_TOOLS_TAP";
    Events["TOUCH_SWIPE"] = "CORNERSTONE_TOOLS_SWIPE";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 18682:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SegmentationRepresentations;
(function (SegmentationRepresentations) {
    SegmentationRepresentations["Labelmap"] = "Labelmap";
    SegmentationRepresentations["Contour"] = "Contour";
    SegmentationRepresentations["Surface"] = "Surface";
})(SegmentationRepresentations || (SegmentationRepresentations = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentationRepresentations);


/***/ }),

/***/ 84093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var StrategyCallbacks;
(function (StrategyCallbacks) {
    StrategyCallbacks["OnInteractionStart"] = "onInteractionStart";
    StrategyCallbacks["OnInteractionEnd"] = "onInteractionEnd";
    StrategyCallbacks["Preview"] = "preview";
    StrategyCallbacks["RejectPreview"] = "rejectPreview";
    StrategyCallbacks["AcceptPreview"] = "acceptPreview";
    StrategyCallbacks["Fill"] = "fill";
    StrategyCallbacks["Interpolate"] = "interpolate";
    StrategyCallbacks["StrategyFunction"] = "strategyFunction";
    StrategyCallbacks["CreateIsInThreshold"] = "createIsInThreshold";
    StrategyCallbacks["Initialize"] = "initialize";
    StrategyCallbacks["INTERNAL_setValue"] = "setValue";
    StrategyCallbacks["AddPreview"] = "addPreview";
    StrategyCallbacks["ComputeInnerCircleRadius"] = "computeInnerCircleRadius";
    StrategyCallbacks["GetStatistics"] = "getStatistics";
    StrategyCallbacks["EnsureImageVolumeFor3DManipulation"] = "ensureImageVolumeFor3DManipulation";
    StrategyCallbacks["EnsureSegmentationVolumeFor3DManipulation"] = "ensureSegmentationVolumeFor3DManipulation";
})(StrategyCallbacks || (StrategyCallbacks = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StrategyCallbacks);


/***/ }),

/***/ 66452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ MouseBindings),
/* harmony export */   q: () => (/* binding */ KeyboardBindings)
/* harmony export */ });
var MouseBindings;
(function (MouseBindings) {
    MouseBindings[MouseBindings["Primary"] = 1] = "Primary";
    MouseBindings[MouseBindings["Secondary"] = 2] = "Secondary";
    MouseBindings[MouseBindings["Primary_And_Secondary"] = 3] = "Primary_And_Secondary";
    MouseBindings[MouseBindings["Auxiliary"] = 4] = "Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Auxiliary"] = 5] = "Primary_And_Auxiliary";
    MouseBindings[MouseBindings["Secondary_And_Auxiliary"] = 6] = "Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Secondary_And_Auxiliary"] = 7] = "Primary_And_Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Fourth_Button"] = 8] = "Fourth_Button";
    MouseBindings[MouseBindings["Fifth_Button"] = 16] = "Fifth_Button";
    MouseBindings[MouseBindings["Wheel"] = 524288] = "Wheel";
    MouseBindings[MouseBindings["Wheel_Primary"] = 524289] = "Wheel_Primary";
})(MouseBindings || (MouseBindings = {}));
var KeyboardBindings;
(function (KeyboardBindings) {
    KeyboardBindings[KeyboardBindings["Shift"] = 16] = "Shift";
    KeyboardBindings[KeyboardBindings["Ctrl"] = 17] = "Ctrl";
    KeyboardBindings[KeyboardBindings["Alt"] = 18] = "Alt";
    KeyboardBindings[KeyboardBindings["Meta"] = 91] = "Meta";
    KeyboardBindings[KeyboardBindings["ShiftCtrl"] = 1617] = "ShiftCtrl";
    KeyboardBindings[KeyboardBindings["ShiftAlt"] = 1618] = "ShiftAlt";
    KeyboardBindings[KeyboardBindings["ShiftMeta"] = 1691] = "ShiftMeta";
    KeyboardBindings[KeyboardBindings["CtrlAlt"] = 1718] = "CtrlAlt";
    KeyboardBindings[KeyboardBindings["CtrlMeta"] = 1791] = "CtrlMeta";
    KeyboardBindings[KeyboardBindings["AltMeta"] = 1891] = "AltMeta";
})(KeyboardBindings || (KeyboardBindings = {}));



/***/ }),

/***/ 49892:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ToolModes;
(function (ToolModes) {
    ToolModes["Active"] = "Active";
    ToolModes["Passive"] = "Passive";
    ToolModes["Enabled"] = "Enabled";
    ToolModes["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolModes);


/***/ }),

/***/ 10401:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ Swipe)
/* harmony export */ });
var Swipe;
(function (Swipe) {
    Swipe["UP"] = "UP";
    Swipe["DOWN"] = "DOWN";
    Swipe["LEFT"] = "LEFT";
    Swipe["RIGHT"] = "RIGHT";
})(Swipe || (Swipe = {}));



/***/ }),

/***/ 99737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationStyleStates: () => (/* reexport */ enums_AnnotationStyleStates),
  ChangeTypes: () => (/* reexport */ ChangeTypes/* default */.A),
  Events: () => (/* reexport */ Events/* default */.A),
  KeyboardBindings: () => (/* reexport */ ToolBindings/* KeyboardBindings */.q),
  MouseBindings: () => (/* reexport */ ToolBindings/* MouseBindings */.i),
  SegmentationRepresentations: () => (/* reexport */ SegmentationRepresentations/* default */.A),
  StrategyCallbacks: () => (/* reexport */ StrategyCallbacks/* default */.A),
  Swipe: () => (/* reexport */ Touch/* Swipe */.H),
  ToolModes: () => (/* reexport */ ToolModes/* default */.A),
  WorkerTypes: () => (/* reexport */ WorkerTypes)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js
var ToolBindings = __webpack_require__(66452);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js
var ToolModes = __webpack_require__(49892);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js
var AnnotationStyleStates;
(function (AnnotationStyleStates) {
    AnnotationStyleStates["Default"] = "";
    AnnotationStyleStates["Highlighted"] = "Highlighted";
    AnnotationStyleStates["Selected"] = "Selected";
    AnnotationStyleStates["Locked"] = "Locked";
    AnnotationStyleStates["AutoGenerated"] = "AutoGenerated";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
/* harmony default export */ const enums_AnnotationStyleStates = (AnnotationStyleStates);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js
var Touch = __webpack_require__(10401);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js
var StrategyCallbacks = __webpack_require__(84093);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js
var ChangeTypes = __webpack_require__(75183);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js
var WorkerTypes_ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["POLYSEG_CONTOUR_TO_LABELMAP"] = "Converting Contour to Labelmap";
    ChangeTypes["POLYSEG_SURFACE_TO_LABELMAP"] = "Converting Surfaces to Labelmap";
    ChangeTypes["POLYSEG_CONTOUR_TO_SURFACE"] = "Converting Contour to Surface";
    ChangeTypes["POLYSEG_LABELMAP_TO_SURFACE"] = "Converting Labelmap to Surface";
    ChangeTypes["SURFACE_CLIPPING"] = "Clipping Surfaces";
    ChangeTypes["COMPUTE_STATISTICS"] = "Computing Statistics";
    ChangeTypes["INTERPOLATE_LABELMAP"] = "Interpolating Labelmap";
    ChangeTypes["COMPUTE_LARGEST_BIDIRECTIONAL"] = "Computing Largest Bidirectional";
    ChangeTypes["GENERATE_CONTOUR_SETS"] = "Generating Contour Sets";
})(WorkerTypes_ChangeTypes || (WorkerTypes_ChangeTypes = {}));
/* harmony default export */ const WorkerTypes = (WorkerTypes_ChangeTypes);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js












/***/ }),

/***/ 12843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ image_redactor_src)
});

;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/package.json
const package_namespaceObject = /*#__PURE__*/JSON.parse('{"UU":"@ohif/extension-image-redactor"}');
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/id.js
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const id = package_namespaceObject.UU;

// EXTERNAL MODULE: ../../../node_modules/react/index.js
var react = __webpack_require__(86326);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/index.js
var dist_esm = __webpack_require__(4667);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/tools/RedactionRectangleTool.ts
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const {
  getAnnotations
} = dist_esm.annotation.state;

/**
 * RedactionRectangleTool - A custom tool for marking areas to be redacted
 * Extends RectangleROITool with custom styling for redaction visualization
 */
class RedactionRectangleTool extends dist_esm.RectangleROITool {
  constructor(toolProps = {}, defaultToolProps = {
    supportedInteractionTypes: ['Mouse', 'Touch'],
    configuration: {
      shadow: true,
      preventHandleOutsideImage: false,
      getTextLines: (data, targetId) => {
        return [];
      }
    }
  }) {
    super(toolProps, defaultToolProps);
  }

  /**
   * Override getStyle to apply red color when highlighted
   */
  getStyle(property, specs, annotation) {
    // Check if this annotation is highlighted
    const isHighlighted = annotation?.metadata?.highlighted;
    if (isHighlighted && property === 'color') {
      return 'rgb(255, 0, 0)'; // Red when highlighted
    }
    if (isHighlighted && property === 'lineWidth') {
      return 3; // Thicker when highlighted
    }

    // Fall back to parent implementation
    return super.getStyle(property, specs, annotation);
  }

  /**
   * Get the coordinates of all redaction rectangles in world coordinates
   */
  static getRedactionAreas(element) {
    const annotations = getAnnotations(RedactionRectangleTool.toolName, element);
    if (!annotations?.length) {
      return [];
    }
    return annotations.map(annotation => {
      const {
        points
      } = annotation.data.handles;

      // RectangleROI stores 4 corner points
      // Extract all X, Y, Z coordinates to find the bounding box
      const allX = points.map(p => p[0]);
      const allY = points.map(p => p[1]);
      const z = points[0][2]; // All points have the same Z coordinate

      // Calculate actual top-left and bottom-right from all corner points
      const topLeft = [Math.min(...allX), Math.min(...allY), z];
      const bottomRight = [Math.max(...allX), Math.max(...allY), z];
      return {
        annotationUID: annotation.annotationUID,
        topLeft: topLeft,
        bottomRight: bottomRight,
        worldCoordinates: points
      };
    });
  }

  /**
   * Convert world coordinates to image pixel coordinates
   */
  static worldToPixelCoordinates(worldCoords, viewport) {
    return worldCoords.map(coord => {
      const canvasCoord = viewport.worldToCanvas(coord);
      // Canvas coordinates are already in pixel space for 2D viewports
      // Just return the canvas coordinates as pixel coordinates
      return [Math.round(canvasCoord[0]), Math.round(canvasCoord[1])];
    });
  }

  /**
   * Clear all redaction areas
   */
  static clearAllRedactionAreas(element) {
    const annotationManager = dist_esm.annotation.state.getAnnotationManager();
    let annotations = getAnnotations(RedactionRectangleTool.toolName, element);
    if (annotations?.length) {
      // Create a copy of the array to avoid modification during iteration
      const annotationsCopy = [...annotations];

      // Remove all annotations
      annotationsCopy.forEach(ann => {
        try {
          annotationManager.removeAnnotation(ann.annotationUID);
        } catch (error) {
          console.error('Error removing annotation:', error);
        }
      });

      // Force re-render
      element.dispatchEvent(new CustomEvent('annotationsCleared'));
    }
  }

  /**
   * Delete a single redaction area by annotation UID
   */
  static deleteRedactionArea(annotationUID, element) {
    const annotationManager = dist_esm.annotation.state.getAnnotationManager();
    annotationManager.removeAnnotation(annotationUID);

    // Trigger re-render
    element.dispatchEvent(new CustomEvent('annotationRemoved', {
      detail: {
        annotationUID
      }
    }));
  }

  /**
   * Highlight a specific redaction area by setting metadata flag
   * The getStyle() method will read this flag and apply red color
   */
  static highlightRedactionArea(annotationUID, element, highlight = true) {
    const annotations = getAnnotations(RedactionRectangleTool.toolName, element);
    const targetAnnotation = annotations?.find(ann => ann.annotationUID === annotationUID);
    if (targetAnnotation) {
      // Store highlight state in metadata
      // The getStyle() method will read this and apply red color
      if (!targetAnnotation.metadata) {
        targetAnnotation.metadata = {
          toolName: RedactionRectangleTool.toolName
        };
      }
      targetAnnotation.metadata.highlighted = highlight;
    }
  }
}
RedactionRectangleTool.toolName = 'RedactionRectangle';
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/models/RedactionArea.js
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/



/**
 * RedactionArea - Represents a single redaction area with all its metadata
 * Fully self-contained with DICOM metadata and coordinate information
 */
class RedactionArea {
  constructor(annotationData, viewport, frameIndex = 0, isGlobal = false) {
    // Annotation data
    this.annotationUID = annotationData.annotationUID;
    this.topLeft = annotationData.topLeft;
    this.bottomRight = annotationData.bottomRight;
    this.worldCoordinates = annotationData.worldCoordinates;
    this.cornerstoneAnnotation = annotationData;

    // Frame information
    this.frameIndex = isGlobal ? null : frameIndex;
    this.isGlobal = isGlobal;

    // Extract DICOM metadata
    this.extractDICOMMetadata(viewport);

    // Timestamp
    this.timestamp = new Date().toISOString();
  }

  /**
   * Extract Databricks Volume path from imageId
   * Format: .../Volumes/{catalog}/{schema}/{volume}/{file_path}
   * Returns: /Volumes/{catalog}/{schema}/{volume}/{file_path}
   */
  extractVolumePath(imageId) {
    if (!imageId) return null;
    try {
      // Remove protocol prefix (dicomweb:, wadouri:, multiframe:, etc.)
      let cleanUrl = imageId;
      if (imageId.includes(':')) {
        cleanUrl = imageId.split(':').slice(1).join(':');
      }

      // For multiframe, remove frame parameter
      if (cleanUrl.includes('&frame=')) {
        cleanUrl = cleanUrl.split('&frame=')[0];
      }

      // Decode URL encoding
      cleanUrl = decodeURIComponent(cleanUrl);

      // Extract everything from /Volumes/ onwards
      const volumesIndex = cleanUrl.indexOf('/Volumes/');
      if (volumesIndex !== -1) {
        return cleanUrl.substring(volumesIndex);
      }
      return null;
    } catch (error) {
      console.error('Error extracting volume path:', error);
      return null;
    }
  }

  /**
   * Extract DICOM metadata from viewport
   */
  extractDICOMMetadata(viewport) {
    const imageId = viewport.getCurrentImageId();
    const image = esm.cache.getImage(imageId);

    // Extract imageId components
    this.imageId = imageId;
    this.fileName = 'unknown.dcm';
    this.filePath = null;
    if (imageId.startsWith('multiframe:')) {
      const parts = imageId.substring('multiframe:'.length).split('&frame=');
      const dicomUrl = parts[0];
      this.fileName = dicomUrl.split('/').pop().split('?')[0];
    } else if (imageId.startsWith('dicomweb:')) {
      const dicomUrl = imageId.substring('dicomweb:'.length);
      this.fileName = dicomUrl.split('/').pop().split('?')[0];
    } else if (imageId.startsWith('wadouri:')) {
      const dicomUrl = imageId.substring('wadouri:'.length);
      this.fileName = dicomUrl.split('/').pop().split('?')[0];
    }

    // Extract Databricks Volume path
    this.filePath = this.extractVolumePath(imageId);

    // Get DICOM metadata from cache
    const generalSeriesModule = esm.metaData.get('generalSeriesModule', imageId) || {};
    const sopCommonModule = esm.metaData.get('sopCommonModule', imageId) || {};
    const imagePixelModule = esm.metaData.get('imagePixelModule', imageId) || {};

    // Store DICOM identifiers
    this.studyInstanceUID = generalSeriesModule.studyInstanceUID || 'unknown';
    this.seriesInstanceUID = generalSeriesModule.seriesInstanceUID || 'unknown';
    this.sopInstanceUID = sopCommonModule.sopInstanceUID || 'unknown';
    this.sopClassUID = sopCommonModule.sopClassUID || 'unknown';
    this.modality = generalSeriesModule.modality || 'unknown';

    // Image dimensions
    this.rows = image?.height || image?.rows || imagePixelModule.rows || 0;
    this.columns = image?.width || image?.columns || imagePixelModule.columns || 0;
    this.numberOfFrames = esm.metaData.get('NumberOfFrames', imageId) || 1;
  }

  /**
   * Update coordinates from a new annotation (when user resizes/moves)
   */
  updateCoordinates(annotationData) {
    this.topLeft = annotationData.topLeft;
    this.bottomRight = annotationData.bottomRight;
    this.worldCoordinates = annotationData.worldCoordinates;
    this.cornerstoneAnnotation = annotationData;
    this.timestamp = new Date().toISOString(); // Update timestamp
  }

  /**
   * Check if coordinates have changed compared to another annotation
   */
  hasCoordinatesChanged(annotationData) {
    return this.topLeft[0] !== annotationData.topLeft[0] || this.topLeft[1] !== annotationData.topLeft[1] || this.topLeft[2] !== annotationData.topLeft[2] || this.bottomRight[0] !== annotationData.bottomRight[0] || this.bottomRight[1] !== annotationData.bottomRight[1] || this.bottomRight[2] !== annotationData.bottomRight[2];
  }

  /**
   * Get the Cornerstone annotation object for rendering
   */
  getCornerstoneAnnotation() {
    return this.cornerstoneAnnotation;
  }

  /**
   * Check if this area belongs to a specific frame
   */
  belongsToFrame(frameIndex) {
    if (this.isGlobal) return true;
    return this.frameIndex === frameIndex;
  }

  /**
   * Get a display label for this area
   */
  getDisplayLabel() {
    if (this.isGlobal) {
      return `Global - ${this.fileName}`;
    }
    return `Frame ${this.frameIndex + 1} - ${this.fileName}`;
  }

  /**
   * Get a short identifier for display
   */
  getShortUID() {
    return this.annotationUID.substring(0, 8);
  }

  /**
   * Export to JSON format with full metadata
   */
  toJSON() {
    return {
      annotationUID: this.annotationUID,
      imageId: this.imageId,
      fileName: this.fileName,
      filePath: this.filePath,
      studyInstanceUID: this.studyInstanceUID,
      seriesInstanceUID: this.seriesInstanceUID,
      sopInstanceUID: this.sopInstanceUID,
      sopClassUID: this.sopClassUID,
      modality: this.modality,
      frameIndex: this.frameIndex,
      numberOfFrames: this.numberOfFrames,
      rows: this.rows,
      columns: this.columns,
      isGlobal: this.isGlobal,
      topLeft: this.topLeft,
      bottomRight: this.bottomRight,
      worldCoordinates: this.worldCoordinates,
      timestamp: this.timestamp
    };
  }
}

/**
 * RedactionAreaManager - Manages all redaction areas across frames
 */
class RedactionAreaManager {
  constructor() {
    this.areas = new Map(); // Map<annotationUID, RedactionArea>
    this.frameIndex = new Map(); // Map<frameIndex, Set<annotationUID>>
    this.globalAreas = new Set(); // Set<annotationUID> for global areas
  }

  /**
   * Add a new redaction area
   */
  addArea(annotationData, viewport, frameIndex, isGlobal = false) {
    const area = new RedactionArea(annotationData, viewport, frameIndex, isGlobal);
    this.areas.set(area.annotationUID, area);
    if (isGlobal) {
      this.globalAreas.add(area.annotationUID);
    } else {
      if (!this.frameIndex.has(frameIndex)) {
        this.frameIndex.set(frameIndex, new Set());
      }
      this.frameIndex.get(frameIndex).add(area.annotationUID);
    }
    return area;
  }

  /**
   * Get a redaction area by its UID
   */
  getAreaByUID(annotationUID) {
    return this.areas.get(annotationUID);
  }

  /**
   * Update an existing redaction area's coordinates
   */
  updateArea(annotationUID, annotationData) {
    const area = this.areas.get(annotationUID);
    if (area) {
      area.updateCoordinates(annotationData);
      return true;
    }
    return false;
  }

  /**
   * Check if an area exists and if its coordinates have changed
   */
  hasAreaChanged(annotationUID, annotationData) {
    const area = this.areas.get(annotationUID);
    if (!area) return false;
    return area.hasCoordinatesChanged(annotationData);
  }

  /**
   * Remove a redaction area
   */
  removeArea(annotationUID) {
    const area = this.areas.get(annotationUID);
    if (!area) return false;
    this.areas.delete(annotationUID);
    if (area.isGlobal) {
      this.globalAreas.delete(annotationUID);
    } else if (area.frameIndex !== null) {
      const frameSet = this.frameIndex.get(area.frameIndex);
      if (frameSet) {
        frameSet.delete(annotationUID);
        if (frameSet.size === 0) {
          this.frameIndex.delete(area.frameIndex);
        }
      }
    }
    return true;
  }

  /**
   * Get all areas for a specific frame
   */
  getAreasForFrame(frameIndex) {
    const areas = [];

    // Add global areas
    for (const uid of this.globalAreas) {
      const area = this.areas.get(uid);
      if (area) areas.push(area);
    }

    // Add frame-specific areas
    const frameSet = this.frameIndex.get(frameIndex);
    if (frameSet) {
      for (const uid of frameSet) {
        const area = this.areas.get(uid);
        if (area) areas.push(area);
      }
    }
    return areas;
  }

  /**
   * Get all areas across all frames
   */
  getAllAreas() {
    return Array.from(this.areas.values());
  }

  /**
   * Get all frames that have redaction areas
   */
  getFramesWithAreas() {
    return Array.from(this.frameIndex.keys()).sort((a, b) => a - b);
  }

  /**
   * Clear all areas
   */
  clearAll() {
    this.areas.clear();
    this.frameIndex.clear();
    this.globalAreas.clear();
  }

  /**
   * Clear areas for a specific frame
   */
  clearFrame(frameIndex) {
    const frameSet = this.frameIndex.get(frameIndex);
    if (frameSet) {
      for (const uid of frameSet) {
        this.areas.delete(uid);
      }
      this.frameIndex.delete(frameIndex);
    }
  }

  /**
   * Clear global areas
   */
  clearGlobal() {
    for (const uid of this.globalAreas) {
      this.areas.delete(uid);
    }
    this.globalAreas.clear();
  }

  /**
   * Get statistics
   */
  getStats() {
    return {
      totalAreas: this.areas.size,
      globalAreas: this.globalAreas.size,
      framesWithAreas: this.frameIndex.size,
      framesList: this.getFramesWithAreas()
    };
  }

  /**
   * Export all areas to JSON
   */
  exportToJSON() {
    return {
      globalAreas: Array.from(this.globalAreas).map(uid => {
        const area = this.areas.get(uid);
        return area ? area.toJSON() : null;
      }).filter(a => a !== null),
      frameSpecificAreas: Array.from(this.frameIndex.entries()).map(([frameIdx, uids]) => ({
        frameIndex: frameIdx,
        areas: Array.from(uids).map(uid => {
          const area = this.areas.get(uid);
          return area ? area.toJSON() : null;
        }).filter(a => a !== null)
      }))
    };
  }
}
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/services/RedactionService.js
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/





const {
  ViewportType
} = esm.Enums;
class RedactionService {
  constructor() {
    this.areaManager = new RedactionAreaManager(); // Centralized area management
    this.viewportManagers = new Map(); // Map<viewportId, RedactionAreaManager>
    this.frameSpecificAreas = new Map(); // Map<viewportId, Map<frameIndex, Array<RedactionArea>>>
    this.globalRedactionAreas = []; // Array<RedactionArea>
  }

  /**
   * Get or create area manager for a viewport
   */
  getAreaManager(viewportId) {
    if (!this.viewportManagers.has(viewportId)) {
      this.viewportManagers.set(viewportId, new RedactionAreaManager());
    }
    return this.viewportManagers.get(viewportId);
  }

  /**
   * Get all frame-specific redaction areas across all frames
   * @param {string} viewportId - The viewport ID
   * @returns {Array} All redaction areas from all frames
   */
  getAllFrameSpecificAreas(viewportId) {
    const manager = this.getAreaManager(viewportId);
    return manager.getAllAreas().map(area => ({
      annotationUID: area.annotationUID,
      topLeft: area.topLeft,
      bottomRight: area.bottomRight,
      worldCoordinates: area.worldCoordinates,
      frameIndex: area.frameIndex,
      isGlobal: area.isGlobal
    }));
  }

  /**
   * Check if a specific frame has stored redaction areas
   * @param {string} viewportId - The viewport ID
   * @param {number} frameIndex - The frame index to check
   * @returns {boolean} True if frame has stored areas
   */
  hasFrameAreas(viewportId, frameIndex) {
    const manager = this.getAreaManager(viewportId);
    return manager.getAreasForFrame(frameIndex).length > 0;
  }

  /**
   * Get stored redaction areas for a specific frame
   * @param {string} viewportId - The viewport ID
   * @param {number} frameIndex - The frame index
   * @returns {Array} Stored areas for the frame
   */
  getStoredFrameAreas(viewportId, frameIndex) {
    const manager = this.getAreaManager(viewportId);
    return manager.getAreasForFrame(frameIndex).map(area => ({
      annotationUID: area.annotationUID,
      topLeft: area.topLeft,
      bottomRight: area.bottomRight,
      worldCoordinates: area.worldCoordinates,
      frameIndex: area.frameIndex,
      isGlobal: area.isGlobal
    }));
  }

  /**
   * Store specific redaction areas for a frame (without reading from element)
   * @param {string} viewportId - The viewport ID
   * @param {object} viewport - The viewport object
   * @param {Array} areas - The areas to store
   * @param {number} frameIndex - The frame index
   * @param {boolean} isGlobal - Whether areas should be global
   */
  storeSpecificAreas(viewportId, viewport, areas, frameIndex, isGlobal = false) {
    const manager = this.getAreaManager(viewportId);
    areas.forEach(annotationData => {
      manager.addArea(annotationData, viewport, frameIndex, isGlobal);
    });
    const stats = manager.getStats();
    console.log(`Stored ${areas.length} areas for frame ${frameIndex}. Total areas: ${stats.totalAreas}, Frames: ${stats.framesWithAreas}`);
    return areas;
  }

  /**
   * Update redaction areas for a specific frame
   * Checks each annotation and updates only if coordinates changed
   * @param {string} viewportId - The viewport ID
   * @param {object} viewport - The viewport object
   * @param {Array} areas - The current areas from viewport
   * @param {number} frameIndex - The frame index
   * @param {boolean} isGlobal - Whether areas should be global
   */
  updateFrameAreas(viewportId, viewport, areas, frameIndex, isGlobal = false) {
    const manager = this.getAreaManager(viewportId);
    let updatedCount = 0;
    areas.forEach(annotationData => {
      if (manager.hasAreaChanged(annotationData.annotationUID, annotationData)) {
        manager.updateArea(annotationData.annotationUID, annotationData);
        updatedCount++;
      }
    });
    console.log(`Updated ${updatedCount} modified area(s) for frame ${frameIndex}`);
    return areas;
  }

  /**
   * Get redaction areas from element and sync global annotations
   * @param {string} viewportId - The viewport ID
   * @param {HTMLElement} element - The viewport element
   * @param {object} viewport - The viewport object
   * @param {number} frameIndex - The current frame index
   * @param {boolean} includeGlobal - Whether to include and sync global areas
   * @returns {Array} All redaction areas (current frame + global if enabled)
   */
  getRedactionAreas(viewportId, element, viewport, frameIndex, includeGlobal = false) {
    // First, sync global annotations if needed
    if (includeGlobal && viewport) {
      this.syncGlobalAnnotationsToFrame(viewportId, element, viewport);
    }

    // Get all annotations from the element
    return RedactionRectangleTool.getRedactionAreas(element);
  }

  /**
   * Sync global redaction annotations to the current frame
   * Updates the z-coordinate of global annotations to match current frame
   * @param {string} viewportId - The viewport ID
   * @param {HTMLElement} element - The viewport element
   * @param {object} viewport - The viewport object
   */
  syncGlobalAnnotationsToFrame(viewportId, element, viewport) {
    const manager = this.getAreaManager(viewportId);

    // Get all global areas
    const globalAreas = manager.getAllAreas().filter(area => area.isGlobal);
    if (globalAreas.length === 0) {
      return;
    }

    // Get current imageId and calculate the z-index for this frame
    const currentImageId = viewport.getCurrentImageId ? viewport.getCurrentImageId() : '';
    const imageData = viewport.getImageData();
    if (!imageData) {
      return;
    }

    // Get the z-coordinate for the current slice/frame
    // Use the image's indexToWorld to get the current frame's z position
    const indexToWorld = imageData.imageData?.indexToWorld;
    if (!indexToWorld) {
      console.warn('Could not get indexToWorld transform');
      return;
    }

    // Get center of the current slice in world coordinates to extract z
    const centerIndex = [Math.floor(imageData.dimensions[0] / 2), Math.floor(imageData.dimensions[1] / 2), 0 // Current slice is always at index 0 in the viewport
    ];
    const centerWorld = indexToWorld(centerIndex);
    const currentZ = centerWorld[2];

    // Get all annotations from the element
    const annotations = RedactionRectangleTool.getRedactionAreas(element);
    if (!annotations || annotations.length === 0) {
      return;
    }

    // Get the full annotation objects from Cornerstone state
    // @ts-ignore - Element type is compatible at runtime
    const fullAnnotations = dist_esm.annotation.state.getAnnotations(RedactionRectangleTool.toolName, element);
    if (!fullAnnotations || fullAnnotations.length === 0) {
      return;
    }

    // Update z-coordinates of global annotations
    let updatedCount = 0;
    globalAreas.forEach(area => {
      // Find the annotation in the viewport
      const annotation = fullAnnotations.find(a => a.annotationUID === area.annotationUID);
      if (annotation && annotation.data?.handles?.points) {
        // Update the z-coordinate of all points to match current frame
        const points = annotation.data.handles.points;
        let needsUpdate = false;
        points.forEach((point, index) => {
          if (point[2] !== currentZ) {
            points[index] = [point[0], point[1], currentZ];
            needsUpdate = true;
          }
        });
        if (needsUpdate) {
          // Update the referenced imageId
          if (annotation.metadata) {
            annotation.metadata.referencedImageId = currentImageId;
          }

          // Mark as invalidated so it re-renders
          annotation.invalidated = true;
          updatedCount++;
        }
      }
    });
    if (updatedCount > 0) {
      console.log(`Updated z-coordinates for ${updatedCount} global annotation(s) to z=${currentZ.toFixed(3)}`);

      // Trigger render to show the updated annotations
      if (viewport.getRenderingEngine) {
        const renderingEngine = viewport.getRenderingEngine();
        if (renderingEngine) {
          renderingEngine.render();
        }
      }
    }
  }

  /**
   * Toggle a redaction area between global and frame-specific
   * @param {string} viewportId - The viewport ID
   * @param {string} annotationUID - The annotation UID to toggle
   * @param {HTMLElement} element - The viewport element
   * @param {object} viewport - The viewport object
   * @returns {boolean} - True if toggled successfully
   */
  toggleRedactionGlobal(viewportId, annotationUID, element, viewport) {
    const manager = this.getAreaManager(viewportId);
    const area = manager.getAreaByUID(annotationUID);
    if (!area) {
      console.warn(`Area with UID ${annotationUID} not found`);
      return false;
    }
    const previouslyGlobal = area.isGlobal;
    const frameIndex = area.frameIndex;

    // Toggle the isGlobal flag
    area.isGlobal = !area.isGlobal;

    // Update the manager's internal tracking
    if (area.isGlobal) {
      // Changing from frame-specific to global
      area.frameIndex = null;
      manager.globalAreas.add(annotationUID);

      // Remove from frame index
      if (frameIndex !== null && manager.frameIndex.has(frameIndex)) {
        manager.frameIndex.get(frameIndex).delete(annotationUID);
      }
      console.log(`Redaction ${annotationUID} is now global (applies to all frames)`);

      // Sync to all frames
      if (viewport && element) {
        this.syncGlobalAnnotationsToFrame(viewportId, element, viewport);
      }
    } else {
      // Changing from global to frame-specific
      // Set to current frame
      const currentFrameIndex = viewport && typeof viewport.getCurrentImageIdIndex === 'function' ? viewport.getCurrentImageIdIndex() : 0;
      area.frameIndex = currentFrameIndex;
      manager.globalAreas.delete(annotationUID);

      // Add to frame index
      if (!manager.frameIndex.has(currentFrameIndex)) {
        manager.frameIndex.set(currentFrameIndex, new Set());
      }
      manager.frameIndex.get(currentFrameIndex).add(annotationUID);
      console.log(`Redaction ${annotationUID} is now frame-specific (Frame ${currentFrameIndex + 1})`);
    }

    // Trigger re-render
    if (viewport && viewport.getRenderingEngine) {
      const renderingEngine = viewport.getRenderingEngine();
      if (renderingEngine) {
        renderingEngine.render();
      }
    }
    return true;
  }

  /**
   * Get the frame index for a specific annotation UID
   * @param {string} annotationUID - The annotation UID
   * @param {string} viewportId - The viewport ID
   * @returns {number|null} The frame index or null if not found
   */
  getFrameForAnnotation(viewportId, annotationUID) {
    const manager = this.getAreaManager(viewportId);
    const area = manager.areas.get(annotationUID);
    return area ? area.frameIndex : null;
  }

  /**
   * Convert world coordinates to pixel coordinates for redaction
   */
  worldToPixelBounds(worldCoords, viewport) {
    const pixelCoords = RedactionRectangleTool.worldToPixelCoordinates(worldCoords, viewport);
    const [topLeft, bottomRight] = pixelCoords;
    return {
      minX: Math.min(topLeft[0], bottomRight[0]),
      maxX: Math.max(topLeft[0], bottomRight[0]),
      minY: Math.min(topLeft[1], bottomRight[1]),
      maxY: Math.max(topLeft[1], bottomRight[1])
    };
  }

  /**
   * Apply redaction to image pixels (burn pixels to black)
   */
  async applyRedaction(redaction_metadata, serverHostname) {
    console.log('Applying redaction to image pixels');
    const endpoint_url = `${serverHostname.replace("/sqlwarehouse", "")}/api/redaction/insert`;
    const response = await fetch(endpoint_url, {
      method: 'POST',
      body: JSON.stringify(redaction_metadata)
    });
    const result = await response.json();
    console.log('Redaction metadata saved successfully!', result);
    return result;
  }

  /**
   * Clear all redaction areas for a viewport
   * @param {string} viewportId - The viewport ID
   * @param {HTMLElement} element - The viewport element
   */
  clearRedactionAreas(viewportId, element) {
    RedactionRectangleTool.clearAllRedactionAreas(element);
    const manager = this.getAreaManager(viewportId);
    manager.clearAll(); // Always clear all stored areas

    console.log('Cleared all redaction areas (global and frame-specific)');
  }

  /**
   * Delete a single redaction area by annotation UID
   */
  deleteRedactionArea(viewportId, annotationUID, element) {
    RedactionRectangleTool.deleteRedactionArea(annotationUID, element);
    const manager = this.getAreaManager(viewportId);
    manager.removeArea(annotationUID);
  }

  /**
   * Highlight a specific redaction area
   */
  highlightRedactionArea(annotationUID, element, highlight = true) {
    RedactionRectangleTool.highlightRedactionArea(annotationUID, element, highlight);
  }

  /**
   * Get viewport from ID (helper method)
   */
  getViewportFromId(viewportId) {
    // This would need to be implemented based on how OHIF manages viewports
    // For now, return null and handle in the calling code
    return null;
  }

  /**
   * Export redacted image data with redaction areas burned as black rectangles
   * Works directly with the image pixel data, independent of zoom/pan
   */
  async exportRedactedImage(viewportId, viewport, format = 'png') {
    const element = viewport.element;
    const redactionAreas = RedactionRectangleTool.getRedactionAreas(element);
    return this.exportRedactedImageWithAreas(viewportId, viewport, redactionAreas, format);
  }

  /**
   * Export redacted image with specific areas (not from element annotations)
   * @param {string} viewportId - The viewport ID
   * @param {object} viewport - The viewport object
   * @param {Array} redactionAreas - Specific redaction areas to apply
   * @param {string} format - Output format (default 'png')
   */
  async exportRedactedImageWithAreas(viewportId, viewport, redactionAreas, format = 'png') {
    const offscreenRenderingEngineId = 'redaction-export-rendering-engine';
    const offscreenViewportId = 'redaction-export-viewport';
    try {
      // Get the current imageId from the viewport
      const imageId = viewport.getCurrentImageId();
      if (!imageId) {
        throw new Error('No image loaded in viewport');
      }

      // Get the cached image to get dimensions
      const image = esm.cache.getImage(imageId);
      if (!image) {
        throw new Error('Failed to get image from cache');
      }
      const width = image.width;
      const height = image.height;

      // Create an off-screen div and canvas for rendering
      const offscreenDiv = document.createElement('div');
      offscreenDiv.style.width = `${width}px`;
      offscreenDiv.style.height = `${height}px`;
      offscreenDiv.style.position = 'absolute';
      offscreenDiv.style.left = '-10000px';
      document.body.appendChild(offscreenDiv);

      // Create or get the off-screen rendering engine
      let renderingEngine = (0,esm.getRenderingEngine)(offscreenRenderingEngineId);
      if (!renderingEngine) {
        renderingEngine = new esm.RenderingEngine(offscreenRenderingEngineId);
      }

      // Enable the viewport
      const viewportInput = {
        viewportId: offscreenViewportId,
        type: ViewportType.STACK,
        element: offscreenDiv,
        defaultOptions: {
          background: viewport.defaultOptions?.background || [0, 0, 0]
        }
      };

      // @ts-ignore - background type is correct at runtime
      renderingEngine.enableElement(viewportInput);
      const offscreenViewport = renderingEngine.getViewport(offscreenViewportId);

      // Load the image and copy properties from the original viewport
      if (offscreenViewport instanceof esm.StackViewport) {
        await offscreenViewport.setStack([imageId]);

        // Copy viewport properties (window/level, etc.) but not zoom/pan
        const properties = viewport.getProperties();
        offscreenViewport.setProperties({
          voiRange: properties.voiRange,
          invert: properties.invert
        });

        // Reset camera to 1:1 scale (no zoom/pan)
        offscreenViewport.resetCamera();
      }

      // Render the viewport
      renderingEngine.render();

      // Wait for the render to complete - give the GPU time to finish rendering
      await new Promise(resolve => {
        // Use requestAnimationFrame to wait for the next frame
        requestAnimationFrame(() => {
          // Wait one more frame to ensure rendering is complete
          requestAnimationFrame(resolve);
        });
      });

      // Get the rendered canvas
      const offscreenCanvas = offscreenDiv.querySelector('canvas');
      if (!offscreenCanvas) {
        throw new Error('Failed to get rendered canvas');
      }

      // Create export canvas and copy the rendered image
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = offscreenCanvas.width;
      exportCanvas.height = offscreenCanvas.height;
      const ctx = exportCanvas.getContext('2d');
      if (!ctx) {
        throw new Error('Failed to get canvas context');
      }

      // Copy the rendered image
      ctx.drawImage(offscreenCanvas, 0, 0);

      // Calculate scale factor between canvas and image (for device pixel ratio)
      const scaleX = offscreenCanvas.width / width;
      const scaleY = offscreenCanvas.height / height;
      if (redactionAreas.length === 0) {
        // Clean up - destroy the rendering engine completely
        renderingEngine.disableElement(offscreenViewportId);
        renderingEngine.destroy();
        document.body.removeChild(offscreenDiv);

        // No redaction areas, just export the original image
        const dataUrl = exportCanvas.toDataURL(`image/${format}`);
        return {
          success: true,
          dataUrl: dataUrl,
          format: format,
          message: 'No redaction areas found. Draw rectangles with the Redaction tool first.'
        };
      }

      // Draw white rectangles over redaction areas
      ctx.fillStyle = 'rgba(255, 255, 255, 1.0)'; // Solid white for redaction

      // Get canvas bounds for clamping
      const maxWidth = offscreenCanvas.width;
      const maxHeight = offscreenCanvas.height;

      // Store clamped rectangles for DICOM pixel burning
      const clampedRectangles = [];
      redactionAreas.forEach((area, index) => {
        // Use worldCoordinates array (4 corner points) if available, otherwise use topLeft/bottomRight
        const worldCoords = area.worldCoordinates || [area.topLeft, area.bottomRight];

        // Convert all world coordinates to offscreen canvas coordinates
        const canvasCoords = worldCoords.map(coord => offscreenViewport.worldToCanvas(coord));

        // Find bounding box in canvas space
        const allX = canvasCoords.map(coord => coord[0]);
        const allY = canvasCoords.map(coord => coord[1]);

        // Scale to actual canvas pixel space (accounting for device pixel ratio)
        let x = Math.round(Math.min(...allX) * scaleX);
        let y = Math.round(Math.min(...allY) * scaleY);
        let w = Math.round((Math.max(...allX) - Math.min(...allX)) * scaleX);
        let h = Math.round((Math.max(...allY) - Math.min(...allY)) * scaleY);

        // Store original values before clamping for reference
        const originalRect = {
          x,
          y,
          w,
          h
        };

        // Clamp rectangle to image bounds - CRITICAL for DICOM pixel burning
        // Ensure the rectangle is always within [0, 0, maxWidth, maxHeight]
        if (x < 0) {
          w += x; // Reduce width by the amount we're shifting
          x = 0;
        }
        if (y < 0) {
          h += y; // Reduce height by the amount we're shifting
          y = 0;
        }

        // Clamp width and height to not exceed image boundaries
        if (x + w > maxWidth) {
          w = maxWidth - x;
        }
        if (y + h > maxHeight) {
          h = maxHeight - y;
        }

        // Draw white rectangle at clamped coordinates
        // Only draw if the rectangle has valid dimensions after clamping
        if (w > 0 && h > 0) {
          ctx.fillRect(x, y, w, h);

          // Store clamped rectangle in image pixel coordinates (divide by scale to get original image coordinates)
          clampedRectangles.push({
            annotationUID: area.annotationUID,
            canvasCoords: {
              x,
              y,
              w,
              h
            },
            imageCoords: {
              x: Math.round(x / scaleX),
              y: Math.round(y / scaleY),
              w: Math.round(w / scaleX),
              h: Math.round(h / scaleY)
            },
            wasClamped: originalRect.x !== x || originalRect.y !== y || originalRect.w !== w || originalRect.h !== h
          });
        }
      });

      // Clean up - destroy the rendering engine completely to prevent it from trying to load frames later
      renderingEngine.disableElement(offscreenViewportId);
      renderingEngine.destroy();
      document.body.removeChild(offscreenDiv);

      // Convert to data URL
      const dataUrl = exportCanvas.toDataURL(`image/${format}`);
      return {
        success: true,
        dataUrl: dataUrl,
        format: format,
        redactedAreas: redactionAreas.length,
        clampedRectangles: clampedRectangles,
        // Clamped rectangles for DICOM pixel burning
        imageDimensions: {
          width: width,
          height: height
        }
      };
    } catch (error) {
      console.error('Error exporting redacted image:', error);

      // Clean up offscreen resources if they exist
      try {
        const renderingEngine = (0,esm.getRenderingEngine)(offscreenRenderingEngineId);
        if (renderingEngine) {
          renderingEngine.disableElement(offscreenViewportId);
          renderingEngine.destroy();
        }
        const offscreenDiv = document.querySelector(`div[style*="left: -10000px"]`);
        if (offscreenDiv && offscreenDiv.parentNode) {
          document.body.removeChild(offscreenDiv);
        }
      } catch (cleanupError) {
        console.error('Error cleaning up offscreen resources:', cleanupError);
      }
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get redaction statistics
   * @param {string} viewportId - The viewport ID
   * @param {boolean} isGlobal - Whether to include global areas
   */
  getRedactionStats(viewportId, isGlobal = false) {
    const manager = this.getAreaManager(viewportId);
    const allAreas = manager.getAllAreas();
    return {
      totalAreas: allAreas.length,
      areas: allAreas.map((area, index) => ({
        id: index + 1,
        annotationUID: area.annotationUID,
        coordinates: area.worldCoordinates,
        frameIndex: area.frameIndex,
        isGlobal: area.isGlobal
      }))
    };
  }

  /**
   * Export redaction metadata grouped by file
   * All metadata is already stored in RedactionArea objects
   * @param {string} viewportId - The viewport ID
   * @param {object} viewport - The viewport object
   */
  exportRedactionAreas(viewportId, viewport) {
    // Get all RedactionArea objects from the manager
    const manager = this.getAreaManager(viewportId);
    const allAreas = manager.getAllAreas();
    if (allAreas.length === 0) {
      console.log('No redaction areas to export');
      return;
    }

    // Group areas by file (sopInstanceUID is unique per file/frame)
    const fileGroups = new Map();
    allAreas.forEach(area => {
      const fileKey = area.sopInstanceUID || area.fileName;
      if (!fileGroups.has(fileKey)) {
        fileGroups.set(fileKey, {
          // Common file metadata
          filePath: area.filePath,
          imageId: area.imageId,
          studyInstanceUID: area.studyInstanceUID,
          seriesInstanceUID: area.seriesInstanceUID,
          sopInstanceUID: area.sopInstanceUID,
          sopClassUID: area.sopClassUID,
          modality: area.modality,
          numberOfFrames: area.numberOfFrames,
          rows: area.rows,
          columns: area.columns,
          redactionAreas: []
        });
      }

      // Add this area to the file's redaction list (store full area object, not JSON yet)
      fileGroups.get(fileKey).redactionAreas.push(area);
    });

    // Helper function to convert world coordinates to image pixel coordinates
    const worldCoordsToImagePixels = (worldCoords, imageId) => {
      try {
        // Get the image from cache
        const image = esm.cache.getImage(imageId);
        if (!image) return null;

        // Get viewport data
        const imageData = viewport.getImageData();
        if (!imageData?.imageData?.worldToIndex) return null;
        const worldToIndex = imageData.imageData.worldToIndex;

        // Convert world coordinates to image pixel indices
        const pixelCoords = worldCoords.map(coord => worldToIndex(coord));

        // Get bounding box
        const allX = pixelCoords.map(c => c[0]);
        const allY = pixelCoords.map(c => c[1]);
        return {
          topLeft: [Math.round(Math.min(...allX)), Math.round(Math.min(...allY))],
          bottomRight: [Math.round(Math.max(...allX)), Math.round(Math.max(...allY))],
          width: Math.round(Math.max(...allX) - Math.min(...allX)),
          height: Math.round(Math.max(...allY) - Math.min(...allY))
        };
      } catch (error) {
        console.warn('Failed to convert world coords to pixels:', error);
        return null;
      }
    };

    // Collect all global redactions (they apply to ALL files in the series)
    const globalAreas = allAreas.filter(a => a.isGlobal);
    const globalRedactions = globalAreas.map((area, index) => {
      // Convert world coordinates to image pixel coordinates
      const imagePixels = worldCoordsToImagePixels(area.worldCoordinates, area.imageId);
      return {
        id: index + 1,
        imagePixelCoordinates: imagePixels,
        annotationUID: area.annotationUID,
        timestamp: area.timestamp
      };
    });

    // Build files dictionary: filePath -> array of frame redactions
    const files = {};
    fileGroups.forEach(fileData => {
      const filePath = fileData.filePath;
      const frameRedactions = [];
      fileData.redactionAreas.forEach(area => {
        // Skip global redactions - they're at root level
        if (area.isGlobal) return;

        // Convert world coordinates to image pixel coordinates
        const imagePixels = worldCoordsToImagePixels(area.worldCoordinates, area.imageId);
        frameRedactions.push({
          frameIndex: area.frameIndex,
          imagePixelCoordinates: imagePixels,
          annotationUID: area.annotationUID,
          timestamp: area.timestamp
        });
      });

      // Sort by frame index
      frameRedactions.sort((a, b) => a.frameIndex - b.frameIndex);

      // Only add files that have frame-specific redactions
      if (frameRedactions.length > 0) {
        files[filePath] = frameRedactions;
      }
    });

    // Count totals
    const totalGlobalRedactions = globalAreas.length;
    const totalFrameSpecificRedactions = allAreas.filter(a => !a.isGlobal).length;
    return {
      totalGlobalRedactions: totalGlobalRedactions,
      totalFrameSpecificRedactions: totalFrameSpecificRedactions,
      frameRedactions: files,
      globalRedactions: globalRedactions
    };
  }

  /**
   * Store metadata redaction operations for a specific series/instance
   * @param {string} seriesInstanceUID - The series instance UID
   * @param {number} instanceNumber - The instance number
   * @param {Array} redactions - Array of tag redaction operations
   */
  storeMetadataRedactions(seriesInstanceUID, instanceNumber, redactions) {
    instanceNumber = 0; // FORCE GLOBAL 
    const key = `${seriesInstanceUID}_${instanceNumber}`;
    if (!this.metadataRedactions) {
      this.metadataRedactions = new Map();
    }

    // Store or update redactions for this instance
    this.metadataRedactions.set(key, {
      seriesInstanceUID,
      instanceNumber,
      redactions,
      timestamp: new Date().toISOString()
    });
    console.log(`Stored ${redactions.length} metadata redaction(s) for instance ${instanceNumber}`);
    return {
      success: true,
      count: redactions.length
    };
  }

  /**
   * Get metadata redactions for a specific series/instance
   * @param {string} seriesInstanceUID - The series instance UID
   * @param {number} instanceNumber - The instance number
   * @returns {Array} Array of redaction operations
   */
  getMetadataRedactions(seriesInstanceUID, instanceNumber) {
    instanceNumber = 0; // FORCE GLOBAL 
    const key = `${seriesInstanceUID}_${instanceNumber}`;
    if (!this.metadataRedactions) {
      return [];
    }
    const stored = this.metadataRedactions.get(key);
    return stored ? stored.redactions : [];
  }

  /**
   * Get all metadata redactions for a series
   * @param {string} seriesInstanceUID - The series instance UID
   * @returns {Array} Array of all redaction operations for the series
   */
  getAllMetadataRedactionsForSeries(seriesInstanceUID) {
    if (!this.metadataRedactions) {
      return [];
    }
    const allRedactions = [];
    this.metadataRedactions.forEach((value, key) => {
      if (value.seriesInstanceUID === seriesInstanceUID) {
        allRedactions.push(value);
      }
    });
    return allRedactions;
  }

  /**
   * Clear metadata redactions
   */
  clearMetadataRedactions() {
    if (!this.metadataRedactions) {
      return;
    }
    this.metadataRedactions.clear();
    console.log('Cleared all metadata redactions');
  }
  exportMetadata(viewport) {
    // Get all imageIds in the series from the viewport
    let allImageIds = [];
    if (viewport && typeof viewport.getImageIds === 'function') {
      allImageIds = viewport.getImageIds();
    } else if (viewport && viewport.imageIds) {
      allImageIds = viewport.imageIds;
    }
    console.log(`Found ${allImageIds.length} total images in series`);
    let filesToEdit = [];
    for (const imageId of allImageIds) {
      try {
        const metadata = esm.metaData.get('instance', imageId);
        if (metadata) {
          // Extract file name from imageId
          let filePath = 'unknown.dcm';
          // Files will always be part of /Volumes/...
          const match = imageId.match(/\/Volumes\/[^?]+/);
          if (match) {
            filePath = match[0].split("&")[0];
          }
          filesToEdit.push(filePath);
        }
      } catch (error) {
        console.warn(`Failed to get metadata for imageId: ${imageId}`, error);
      }
    }
    filesToEdit = [...new Set(filesToEdit)];

    // Build final JSON metadata with study/series info and global redactions at root level
    const jsonMetadata = {
      exportTimestamp: new Date().toISOString(),
      totalFilesInSeries: filesToEdit.length,
      // Total files in the series
      totalRedactionAreas: 0,
      totalGlobalRedactions: 0,
      totalFrameSpecificRedactions: 0,
      allFilesInSeries: filesToEdit // All files if global redactions exist, otherwise only files with frame-specific redactions
    };
    return jsonMetadata;
  }

  /**
   * Export combined redaction metadata (both image areas and tag redactions)
   * @param {object} viewportDetails - The viewport details object
   * @returns {object} Combined redaction metadata
   */
  exportCombinedRedactionMetadata(viewportDetails) {
    const {
      viewportId,
      viewport,
      seriesInstanceUID,
      studyInstanceUID,
      modality
    } = viewportDetails;

    // Get metadata for DICOM files
    const jsonMetadata = this.exportMetadata(viewport);
    jsonMetadata.seriesInstanceUID = seriesInstanceUID;
    jsonMetadata.studyInstanceUID = studyInstanceUID;
    jsonMetadata.modality = modality;

    // Get metadata for metadata redactions
    const metadataRedactions = this.metadataRedactions;
    if (metadataRedactions && metadataRedactions.size > 0) {
      jsonMetadata.metadataRedactions = [];
      metadataRedactions.forEach(value => {
        value.redactions.forEach(redaction => {
          jsonMetadata.metadataRedactions.push(redaction);
        });
      });
      jsonMetadata.totalMetadataRedactions = jsonMetadata.metadataRedactions.length;
    }

    // Get redaction areas
    const redactionAreas = this.exportRedactionAreas(viewportId, viewport);
    if (redactionAreas) {
      jsonMetadata.totalRedactionAreas = redactionAreas.totalGlobalRedactions + redactionAreas.totalFrameSpecificRedactions;
      jsonMetadata.totalGlobalRedactions = redactionAreas.totalGlobalRedactions;
      jsonMetadata.totalFrameSpecificRedactions = redactionAreas.totalFrameSpecificRedactions;
      jsonMetadata.frameRedactions = redactionAreas.frameRedactions;
      jsonMetadata.globalRedactions = redactionAreas.globalRedactions;
    }
    if (jsonMetadata.totalGlobalRedactions > 0 || jsonMetadata.totalMetadataRedactions > 0) {
      jsonMetadata.filesToEdit = jsonMetadata.allFilesInSeries;
    } else if (jsonMetadata.totalFrameSpecificRedactions > 0) {
      jsonMetadata.filesToEdit = jsonMetadata.frameRedactions.keys();
    } else {
      jsonMetadata.filesToEdit = [];
    }
    delete jsonMetadata.allFilesInSeries;
    return jsonMetadata;
  }

  /**
   * Get statistics about metadata redactions
   * @returns {object} Statistics object
   */
  getMetadataRedactionStats() {
    if (!this.metadataRedactions || this.metadataRedactions.size === 0) {
      return {
        totalInstances: 0,
        totalRedactions: 0,
        series: []
      };
    }
    const seriesMap = new Map();
    let totalRedactions = 0;
    this.metadataRedactions.forEach(value => {
      totalRedactions += value.redactions.length;
      if (!seriesMap.has(value.seriesInstanceUID)) {
        seriesMap.set(value.seriesInstanceUID, {
          seriesInstanceUID: value.seriesInstanceUID,
          instances: [],
          totalRedactions: 0
        });
      }
      const seriesData = seriesMap.get(value.seriesInstanceUID);
      seriesData.instances.push({
        instanceNumber: value.instanceNumber,
        redactionCount: value.redactions.length,
        redactions: value.redactions,
        // Include the actual redactions
        timestamp: value.timestamp
      });
      seriesData.totalRedactions += value.redactions.length;
    });
    return {
      totalInstances: this.metadataRedactions.size,
      totalRedactions: totalRedactions,
      series: Array.from(seriesMap.values())
    };
  }
}

// Export singleton instance
/* harmony default export */ const services_RedactionService = (new RedactionService());
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/ExportSettings.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const ExportSettings = ({
  enableFileOverwrite,
  onToggleFileOverwrite
}) => {
  return /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: '16px',
      padding: '12px',
      backgroundColor: '#f8f9fa',
      borderRadius: '4px'
    }
  }, /*#__PURE__*/react.createElement("h4", {
    style: {
      marginBottom: '8px',
      fontSize: '14px',
      color: '#495057',
      fontWeight: 'bold'
    }
  }, "Export Settings"), /*#__PURE__*/react.createElement("label", {
    style: {
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer',
      fontSize: '13px'
    }
  }, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    checked: enableFileOverwrite,
    onChange: e => onToggleFileOverwrite(e.target.checked),
    style: {
      marginRight: '8px',
      width: '16px',
      height: '16px'
    }
  }), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("strong", null, "Enable File Overwrite"), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '11px',
      color: '#6c757d',
      marginTop: '4px'
    }
  }, "Downloaded files will have unique timestamps to prevent overwrites"))));
};
/* harmony default export */ const components_ExportSettings = (ExportSettings);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/RedactionAreasList.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const RedactionAreasList = ({
  areas,
  currentFrameIndex,
  onAreaClick,
  onAreaHover,
  onToggleGlobal,
  onDeleteArea
}) => {
  const globalCount = areas.filter(a => a.isGlobal).length;
  const frameSpecificCount = areas.filter(a => !a.isGlobal).length;
  const sortedAreas = [...areas].sort((a, b) => {
    // Sort: global first, then frame-specific by frame index
    if (a.isGlobal && !b.isGlobal) return -1;
    if (!a.isGlobal && b.isGlobal) return 1;

    // Both are frame-specific, sort by frame index
    if (!a.isGlobal && !b.isGlobal) {
      if (a.frameIndex !== b.frameIndex) {
        return (a.frameIndex || 0) - (b.frameIndex || 0);
      }
    }

    // Same type and frame, sort by id
    return a.id - b.id;
  });
  return /*#__PURE__*/react.createElement("div", {
    style: {
      margin: '16px 0'
    }
  }, /*#__PURE__*/react.createElement("h4", {
    style: {
      marginBottom: '8px',
      fontSize: '14px',
      color: '#495057'
    }
  }, "Redaction Areas (", areas.length, ")"), areas.length > 0 && /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '11px',
      color: '#6c757d',
      marginBottom: '8px',
      marginLeft: '4px'
    }
  }, "\uD83C\uDF10 Global: ", globalCount, " | \uD83D\uDCCD Frame-specific: ", frameSpecificCount), sortedAreas.length > 0 ? /*#__PURE__*/react.createElement("div", {
    style: {
      maxHeight: '200px',
      overflow: 'auto',
      border: '1px solid #dee2e6',
      borderRadius: '4px'
    }
  }, sortedAreas.map(area => /*#__PURE__*/react.createElement("div", {
    key: area.id,
    style: {
      padding: '8px',
      borderBottom: '1px solid #f8f9fa',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      cursor: !area.isGlobal && area.frameIndex !== currentFrameIndex ? 'pointer' : 'default',
      transition: 'background-color 0.2s',
      backgroundColor: !area.isGlobal && area.frameIndex === currentFrameIndex ? '#e7f3ff' : area.isGlobal ? '#f0f9ff' : 'transparent'
    },
    onClick: () => onAreaClick(area),
    onMouseEnter: () => onAreaHover(area.annotationUID, true),
    onMouseLeave: () => onAreaHover(area.annotationUID, false),
    onMouseOver: e => {
      if (!area.isGlobal && area.frameIndex !== currentFrameIndex) {
        e.currentTarget.style.backgroundColor = '#fff3cd';
      } else if (area.isGlobal) {
        e.currentTarget.style.backgroundColor = '#e0f2fe';
      } else {
        e.currentTarget.style.backgroundColor = e.currentTarget.style.backgroundColor || '#f8f9fa';
      }
    },
    onMouseOut: e => {
      if (!area.isGlobal && area.frameIndex === currentFrameIndex) {
        e.currentTarget.style.backgroundColor = '#e7f3ff';
      } else if (area.isGlobal) {
        e.currentTarget.style.backgroundColor = '#f0f9ff';
      } else {
        e.currentTarget.style.backgroundColor = 'transparent';
      }
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '12px',
      color: '#495057',
      fontWeight: 'bold'
    }
  }, area.isGlobal ? /*#__PURE__*/react.createElement("span", null, "\uD83C\uDF10 Area ", area.id, " (Global)") : /*#__PURE__*/react.createElement("span", null, "\uD83D\uDCCD Frame ", area.frameIndex !== undefined ? area.frameIndex + 1 : '?', " - Area ", area.id, area.frameIndex === currentFrameIndex && ' ')), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '11px',
      color: '#6c757d',
      marginTop: '2px'
    }
  }, area.isGlobal ? /*#__PURE__*/react.createElement("span", null, "Applies to all frames") : /*#__PURE__*/react.createElement("span", null, area.frameIndex === currentFrameIndex ? 'Current frame only' : 'Click to navigate'))), /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'flex',
      gap: '4px'
    }
  }, /*#__PURE__*/react.createElement("button", {
    onClick: e => {
      e.stopPropagation();
      onToggleGlobal(area.annotationUID);
    },
    style: {
      padding: '4px 8px',
      backgroundColor: area.isGlobal ? '#0ea5e9' : '#64748b',
      color: 'white',
      border: 'none',
      borderRadius: '3px',
      cursor: 'pointer',
      fontSize: '11px',
      display: 'flex',
      alignItems: 'center',
      gap: '2px',
      whiteSpace: 'nowrap'
    },
    title: area.isGlobal ? 'Make frame-specific' : 'Make global'
  }, area.isGlobal ? '' : ''), /*#__PURE__*/react.createElement("button", {
    onClick: e => {
      e.stopPropagation();
      onDeleteArea(area.annotationUID);
    },
    style: {
      padding: '4px 8px',
      backgroundColor: '#dc3545',
      color: 'white',
      border: 'none',
      borderRadius: '3px',
      cursor: 'pointer',
      fontSize: '12px',
      display: 'flex',
      alignItems: 'center',
      gap: '4px'
    },
    title: "Delete this redaction area"
  }, "X"))))) : /*#__PURE__*/react.createElement("p", {
    style: {
      fontSize: '12px',
      color: '#6c757d',
      fontStyle: 'italic'
    }
  }, "No redaction areas defined. Use the redaction tool to draw rectangles."));
};
/* harmony default export */ const components_RedactionAreasList = (RedactionAreasList);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/MetadataRedactionsList.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const MetadataRedactionsList = ({
  redactions
}) => {
  return /*#__PURE__*/react.createElement("div", {
    style: {
      margin: '16px 0'
    }
  }, /*#__PURE__*/react.createElement("h4", {
    style: {
      marginBottom: '8px',
      fontSize: '14px',
      color: '#495057'
    }
  }, "Metadata Redactions (", redactions.length, ")"), redactions.length > 0 ? /*#__PURE__*/react.createElement("div", {
    style: {
      maxHeight: '200px',
      overflow: 'auto',
      border: '1px solid #dee2e6',
      borderRadius: '4px'
    }
  }, /*#__PURE__*/react.createElement("table", {
    style: {
      width: '100%',
      fontSize: '12px',
      borderCollapse: 'collapse'
    }
  }, /*#__PURE__*/react.createElement("thead", {
    style: {
      backgroundColor: '#f8f9fa',
      position: 'sticky',
      top: 0
    }
  }, /*#__PURE__*/react.createElement("tr", null, /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '8px',
      textAlign: 'left',
      borderBottom: '2px solid #dee2e6',
      fontWeight: 'bold',
      color: '#495057'
    }
  }, "Tag"), /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '8px',
      textAlign: 'left',
      borderBottom: '2px solid #dee2e6',
      fontWeight: 'bold',
      color: '#495057'
    }
  }, "Action"))), /*#__PURE__*/react.createElement("tbody", null, redactions.map((redaction, index) => /*#__PURE__*/react.createElement("tr", {
    key: index,
    style: {
      borderBottom: '1px solid #f8f9fa',
      backgroundColor: index % 2 === 0 ? 'white' : '#f8f9fa'
    }
  }, /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '8px',
      color: '#495057'
    }
  }, redaction.keyword || redaction.tag), /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '8px'
    }
  }, /*#__PURE__*/react.createElement("span", {
    style: {
      padding: '2px 8px',
      borderRadius: '3px',
      fontSize: '11px',
      fontWeight: 'bold',
      backgroundColor: redaction.action === 'redact' ? '#dc3545' : redaction.action === 'hash' ? '#0ea5e9' : redaction.action === 'modify' ? '#ffc107' : redaction.action === 'remove' ? '#6c757d' : '#28a745',
      color: 'white'
    }
  }, redaction.action.toUpperCase()))))))) : /*#__PURE__*/react.createElement("p", {
    style: {
      fontSize: '12px',
      color: '#6c757d',
      fontStyle: 'italic'
    }
  }, "No metadata redactions defined. Use the Tag Redactor to configure tag operations."));
};
/* harmony default export */ const components_MetadataRedactionsList = (MetadataRedactionsList);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/RedactionSummary.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const RedactionSummary = ({
  previewFrames,
  currentFrameIndex,
  onShowFramePreview
}) => {
  if (previewFrames.length === 0) return null;
  return /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: '16px',
      border: '2px solid #dee2e6',
      borderRadius: '4px',
      overflow: 'hidden',
      backgroundColor: '#f8f9fa'
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      padding: '12px',
      backgroundColor: '#e9ecef',
      borderBottom: '1px solid #dee2e6',
      fontSize: '14px',
      fontWeight: 'bold',
      color: '#495057'
    }
  }, "Redaction Summary"), /*#__PURE__*/react.createElement("div", {
    style: {
      maxHeight: '300px',
      overflow: 'auto',
      padding: '12px'
    }
  }, previewFrames.map(frame => /*#__PURE__*/react.createElement("div", {
    key: frame.isGlobal ? 'global' : `frame-${frame.frameIndex}`,
    style: {
      padding: '12px',
      marginBottom: '8px',
      backgroundColor: frame.isGlobal ? '#f0f9ff' : frame.isCurrentFrame ? '#fff3cd' : 'white',
      border: frame.isGlobal ? '2px solid #0ea5e9' : frame.isCurrentFrame ? '2px solid #ffc107' : '1px solid #dee2e6',
      borderRadius: '4px',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1
    }
  }, frame.isGlobal ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '14px',
      fontWeight: 'bold',
      color: '#0ea5e9'
    }
  }, "\uD83C\uDF10 Global Redactions"), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '12px',
      color: '#6c757d',
      marginTop: '4px'
    }
  }, frame.areaCount, " redaction", frame.areaCount > 1 ? 's' : '', " \u2022 Apply to all frames"), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '11px',
      color: '#6c757d',
      marginTop: '2px',
      fontStyle: 'italic'
    }
  }, "Preview shows current frame (Frame ", currentFrameIndex + 1, ")")) : /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '14px',
      fontWeight: 'bold',
      color: '#495057'
    }
  }, "\uD83D\uDCCD Frame ", frame.frameIndex + 1, frame.isCurrentFrame && '  (Current)'), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '12px',
      color: '#6c757d',
      marginTop: '4px'
    }
  }, frame.areaCount, " frame-specific redaction", frame.areaCount > 1 ? 's' : ''))), /*#__PURE__*/react.createElement("button", {
    onClick: () => onShowFramePreview(frame.frameIndex, frame.isGlobal),
    style: {
      padding: '8px 16px',
      backgroundColor: '#007bff',
      color: 'white',
      border: 'none',
      borderRadius: '4px',
      fontSize: '12px',
      fontWeight: 'bold',
      cursor: 'pointer'
    }
  }, "Preview")))));
};
/* harmony default export */ const components_RedactionSummary = (RedactionSummary);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/AreaRedactionsSummary.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const AreaRedactionsSummary = ({
  stats
}) => {
  if (stats.totalAreas === 0) return null;
  const globalCount = stats.areas.filter(a => a.isGlobal).length;
  const frameSpecificCount = stats.areas.filter(a => !a.isGlobal).length;
  const uniqueFrameCount = new Set(stats.areas.filter(a => !a.isGlobal).map(a => a.frameIndex)).size;
  return /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: '16px'
    }
  }, /*#__PURE__*/react.createElement("h5", {
    style: {
      fontSize: '13px',
      fontWeight: 'bold',
      marginBottom: '8px',
      color: '#495057'
    }
  }, "Image Area Redactions: ", /*#__PURE__*/react.createElement("strong", null, stats.totalAreas, " area(s)")), /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '12px',
      color: '#495057',
      marginBottom: '8px',
      padding: '8px',
      backgroundColor: '#f8f9fa',
      borderRadius: '4px'
    }
  }, /*#__PURE__*/react.createElement("div", null, "\uD83C\uDF10 ", /*#__PURE__*/react.createElement("strong", null, globalCount), " global redaction(s) (visible on all frames)"), /*#__PURE__*/react.createElement("div", null, "\uD83D\uDCCD ", /*#__PURE__*/react.createElement("strong", null, frameSpecificCount), " frame-specific redaction(s) across ", /*#__PURE__*/react.createElement("strong", null, uniqueFrameCount), " frame(s)")));
};
/* harmony default export */ const components_AreaRedactionsSummary = (AreaRedactionsSummary);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/MetadataRedactionsSummaryTable.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const MetadataRedactionsSummaryTable = ({
  redactions
}) => {
  if (redactions.length === 0) return null;
  return /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: '16px'
    }
  }, /*#__PURE__*/react.createElement("h5", {
    style: {
      fontSize: '13px',
      fontWeight: 'bold',
      marginBottom: '8px',
      color: '#495057'
    }
  }, "Metadata Tag Redactions: ", /*#__PURE__*/react.createElement("strong", null, redactions.length, " tag(s)")), /*#__PURE__*/react.createElement("div", {
    style: {
      maxHeight: '200px',
      overflow: 'auto',
      border: '1px solid #dee2e6',
      borderRadius: '4px',
      marginBottom: '8px'
    }
  }, /*#__PURE__*/react.createElement("table", {
    style: {
      width: '100%',
      fontSize: '11px',
      borderCollapse: 'collapse'
    }
  }, /*#__PURE__*/react.createElement("thead", {
    style: {
      backgroundColor: '#e9ecef',
      position: 'sticky',
      top: 0
    }
  }, /*#__PURE__*/react.createElement("tr", null, /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '6px',
      textAlign: 'left',
      borderBottom: '1px solid #dee2e6',
      fontWeight: 'bold'
    }
  }, "Tag"), /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '6px',
      textAlign: 'left',
      borderBottom: '1px solid #dee2e6',
      fontWeight: 'bold'
    }
  }, "Keyword"), /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '6px',
      textAlign: 'left',
      borderBottom: '1px solid #dee2e6',
      fontWeight: 'bold'
    }
  }, "Action"), /*#__PURE__*/react.createElement("th", {
    style: {
      padding: '6px',
      textAlign: 'left',
      borderBottom: '1px solid #dee2e6',
      fontWeight: 'bold'
    }
  }, "New Value"))), /*#__PURE__*/react.createElement("tbody", null, redactions.map((redaction, index) => /*#__PURE__*/react.createElement("tr", {
    key: index,
    style: {
      borderBottom: '1px solid #f8f9fa',
      backgroundColor: index % 2 === 0 ? 'white' : '#f8f9fa'
    }
  }, /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '6px',
      color: '#495057'
    }
  }, redaction.tag), /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '6px',
      color: '#495057'
    }
  }, redaction.keyword), /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '6px'
    }
  }, /*#__PURE__*/react.createElement("span", {
    style: {
      padding: '2px 6px',
      borderRadius: '3px',
      fontSize: '10px',
      fontWeight: 'bold',
      backgroundColor: redaction.action === 'redact' ? '#dc3545' : redaction.action === 'hash' ? '#0ea5e9' : redaction.action === 'modify' ? '#ffc107' : redaction.action === 'remove' ? '#6c757d' : '#28a745',
      color: 'white'
    }
  }, redaction.action.toUpperCase())), /*#__PURE__*/react.createElement("td", {
    style: {
      padding: '6px',
      color: '#6c757d',
      fontSize: '10px',
      maxWidth: '120px',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      cursor: redaction.action === 'modify' && redaction.newValue ? 'help' : 'default'
    },
    title: redaction.action === 'modify' && redaction.newValue ? redaction.newValue : ''
  }, redaction.action === 'modify' && redaction.newValue ? redaction.newValue : '')))))));
};
/* harmony default export */ const components_MetadataRedactionsSummaryTable = (MetadataRedactionsSummaryTable);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/PreviewPopup.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/


const PreviewPopup = ({
  isOpen,
  image,
  frameIndex,
  onClose
}) => {
  if (!isOpen || !image) return null;
  return /*#__PURE__*/react.createElement("div", {
    style: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.85)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 2000,
      padding: '20px'
    },
    onClick: onClose
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      backgroundColor: 'white',
      borderRadius: '8px',
      maxWidth: '90vw',
      maxHeight: '90vh',
      overflow: 'auto',
      position: 'relative'
    },
    onClick: e => e.stopPropagation()
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      padding: '16px',
      backgroundColor: '#e9ecef',
      borderBottom: '2px solid #dee2e6',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      borderTopLeftRadius: '8px',
      borderTopRightRadius: '8px'
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      fontSize: '16px',
      fontWeight: 'bold',
      color: '#495057'
    }
  }, "Preview: Frame ", frameIndex + 1), /*#__PURE__*/react.createElement("button", {
    onClick: onClose,
    style: {
      padding: '4px 12px',
      backgroundColor: '#dc3545',
      color: 'white',
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer',
      fontSize: '14px',
      fontWeight: 'bold'
    }
  }, "\u2715 Close")), /*#__PURE__*/react.createElement("div", {
    style: {
      padding: '20px',
      backgroundColor: '#000',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }
  }, /*#__PURE__*/react.createElement("img", {
    src: image,
    alt: `Frame ${frameIndex + 1} Preview`,
    style: {
      maxWidth: '100%',
      maxHeight: '70vh',
      objectFit: 'contain',
      display: 'block'
    }
  }))));
};
/* harmony default export */ const components_PreviewPopup = (PreviewPopup);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/ConfirmationDialog.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/






const ConfirmationDialog = ({
  isOpen,
  previewFrames,
  stats,
  metadataRedactions,
  currentFrameIndex,
  previewPopupOpen,
  previewPopupImage,
  previewPopupFrameIndex,
  onCancel,
  onConfirm,
  onShowFramePreview,
  onClosePreviewPopup
}) => {
  if (!isOpen) return null;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    style: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000,
      overflow: 'auto',
      padding: '20px'
    }
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      backgroundColor: 'white',
      padding: '24px',
      borderRadius: '8px',
      maxWidth: '800px',
      width: '100%',
      maxHeight: '90vh',
      overflow: 'auto'
    }
  }, /*#__PURE__*/react.createElement("h4", {
    style: {
      marginBottom: '16px',
      fontSize: '18px',
      fontWeight: 'bold'
    }
  }, "Confirm Redaction"), /*#__PURE__*/react.createElement(components_RedactionSummary, {
    previewFrames: previewFrames,
    currentFrameIndex: currentFrameIndex,
    onShowFramePreview: onShowFramePreview
  }), /*#__PURE__*/react.createElement("p", {
    style: {
      marginBottom: '8px',
      fontSize: '14px'
    }
  }, "Are you sure you want to apply the following redactions?"), /*#__PURE__*/react.createElement(components_AreaRedactionsSummary, {
    stats: stats
  }), /*#__PURE__*/react.createElement(components_MetadataRedactionsSummaryTable, {
    redactions: metadataRedactions
  }), /*#__PURE__*/react.createElement("p", {
    style: {
      fontSize: '12px',
      color: '#6c757d',
      marginBottom: '20px'
    }
  }, "Review the redactions above.", stats.totalAreas > 0 && /*#__PURE__*/react.createElement("p", null, "Click Preview to see how image areas will look."), metadataRedactions.length > 0 && /*#__PURE__*/react.createElement("p", null, "The metadata redactions will be applied to all frames in the series.")), /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'flex',
      gap: '8px',
      justifyContent: 'flex-end'
    }
  }, /*#__PURE__*/react.createElement("button", {
    onClick: onCancel,
    style: {
      padding: '10px 20px',
      backgroundColor: '#6c757d',
      color: 'white',
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer',
      fontSize: '14px'
    }
  }, "Cancel"), /*#__PURE__*/react.createElement("button", {
    onClick: onConfirm,
    style: {
      padding: '10px 20px',
      backgroundColor: '#28a745',
      color: 'white',
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer',
      fontWeight: 'bold',
      fontSize: '14px'
    }
  }, "Confirm")))), /*#__PURE__*/react.createElement(components_PreviewPopup, {
    isOpen: previewPopupOpen,
    image: previewPopupImage,
    frameIndex: previewPopupFrameIndex,
    onClose: onClosePreviewPopup
  }));
};
/* harmony default export */ const components_ConfirmationDialog = (ConfirmationDialog);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/RedactionPanel.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/








const RedactionPanel = ({
  servicesManager
}) => {
  const [redactionAreas, setRedactionAreas] = (0,react.useState)([]);
  const [confirmDialogOpen, setConfirmDialogOpen] = (0,react.useState)(false);
  const [previewFrames, setPreviewFrames] = (0,react.useState)([]);
  const [previewPopupOpen, setPreviewPopupOpen] = (0,react.useState)(false);
  const [previewPopupImage, setPreviewPopupImage] = (0,react.useState)(null);
  const [previewPopupFrameIndex, setPreviewPopupFrameIndex] = (0,react.useState)(0);
  const [stats, setStats] = (0,react.useState)({
    totalAreas: 0,
    areas: []
  });
  const [applyToAllFrames, setApplyToAllFrames] = (0,react.useState)(false);
  const [currentFrameIndex, setCurrentFrameIndex] = (0,react.useState)(0);
  const [enableFileOverwrite, setEnableFileOverwrite] = (0,react.useState)(false);
  const [metadataRedactions, setMetadataRedactions] = (0,react.useState)([]);

  // Track the number of annotations and frame index to detect changes
  const [previousAnnotationCount, setPreviousAnnotationCount] = (0,react.useState)(0);
  const [previousFrameIndex, setPreviousFrameIndex] = (0,react.useState)(0);
  const [currentSeriesUID, setCurrentSeriesUID] = (0,react.useState)(null);
  const [previousMetadataCount, setPreviousMetadataCount] = (0,react.useState)(0);
  const [previousMetadataTimestamp, setPreviousMetadataTimestamp] = (0,react.useState)('');
  const {
    viewportGridService,
    cornerstoneViewportService
  } = servicesManager.services;

  // Get current viewport info including series metadata
  const getCurrentViewport = () => {
    const {
      activeViewportId
    } = viewportGridService.getState();
    const cornerstoneViewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);

    // Extract frame index from imageId or viewport
    let frameIndex = 0;
    let seriesInstanceUID = null;
    let studyInstanceUID = null;
    let modality = null;
    if (cornerstoneViewport) {
      // Method 1: For stack viewports, use getCurrentImageIdIndex
      if (typeof cornerstoneViewport.getCurrentImageIdIndex === 'function') {
        frameIndex = cornerstoneViewport.getCurrentImageIdIndex();
      }
      // Method 2: For multiframe images, parse from imageId
      else {
        const imageId = cornerstoneViewport.getCurrentImageId();
        if (imageId && imageId.startsWith('multiframe:')) {
          const parts = imageId.substring('multiframe:'.length).split('&frame=');
          frameIndex = parseInt(parts[1]) || 0;
        }
      }

      // Get series metadata from the current imageId
      try {
        const imageId = cornerstoneViewport.getCurrentImageId();
        if (imageId) {
          const metadata = esm.metaData.get('instance', imageId);
          if (metadata) {
            seriesInstanceUID = metadata.SeriesInstanceUID;
            studyInstanceUID = metadata.StudyInstanceUID;
            modality = metadata.Modality;
          }
        }
      } catch (error) {
        console.warn('Failed to get series metadata:', error);
      }
    }
    return {
      viewportId: activeViewportId,
      viewport: cornerstoneViewport,
      element: cornerstoneViewport?.element,
      frameIndex: frameIndex,
      seriesInstanceUID: seriesInstanceUID,
      studyInstanceUID: studyInstanceUID,
      modality: modality
    };
  };

  // Update stats from stored areas
  const updateStats = () => {
    const {
      viewportId
    } = getCurrentViewport();
    const currentStats = services_RedactionService.getRedactionStats(viewportId, applyToAllFrames);
    setStats(currentStats);

    // Also update metadata redactions
    updateMetadataRedactions();
  };

  // Update metadata redactions
  const updateMetadataRedactions = () => {
    const metadataStats = services_RedactionService.getMetadataRedactionStats();
    const allRedactions = [];

    // Check if there are any metadata redactions
    if (metadataStats && metadataStats.series && Array.isArray(metadataStats.series)) {
      metadataStats.series.forEach(seriesInfo => {
        if (seriesInfo.instances && Array.isArray(seriesInfo.instances)) {
          seriesInfo.instances.forEach(instanceInfo => {
            if (instanceInfo.redactions && Array.isArray(instanceInfo.redactions)) {
              instanceInfo.redactions.forEach(redaction => {
                allRedactions.push({
                  seriesUID: seriesInfo.seriesInstanceUID,
                  instanceNumber: instanceInfo.instanceNumber,
                  ...redaction
                });
              });
            }
          });
        }
      });
    }
    setMetadataRedactions(allRedactions);
  };

  // Clear all redactions (both areas and metadata)
  const clearAll = () => {
    const {
      viewportId,
      element,
      viewport
    } = getCurrentViewport();
    if (element && viewport) {
      // Use unified clear method from RedactionService
      services_RedactionService.clearRedactionAreas(viewportId, element);
      services_RedactionService.clearMetadataRedactions();

      // Get rendering engine and force full re-render
      const renderingEngine = viewport.getRenderingEngine();
      if (renderingEngine) {
        renderingEngine.render();
      } else {
        viewport.render();
      }

      // Update stats
      updateStats();
    }
  };

  // Toggle redaction between global and frame-specific
  const toggleRedactionGlobal = annotationUID => {
    const {
      viewportId,
      element,
      viewport
    } = getCurrentViewport();
    if (element && viewport) {
      services_RedactionService.toggleRedactionGlobal(viewportId, annotationUID, element, viewport);
      updateStats();
    }
  };

  // Delete individual redaction area
  const deleteRedactionArea = annotationUID => {
    const {
      viewportId,
      element,
      viewport
    } = getCurrentViewport();
    if (element && viewport) {
      services_RedactionService.deleteRedactionArea(viewportId, annotationUID, element);
      viewport.render();
      updateStats();
    }
  };

  // Handle mouse enter on area item - highlight the annotation
  const handleAreaHover = (annotationUID, isHovering) => {
    const {
      element,
      viewport
    } = getCurrentViewport();
    if (element && viewport) {
      services_RedactionService.highlightRedactionArea(annotationUID, element, isHovering);
      viewport.render();
    }
  };

  // Navigate to a specific frame
  const navigateToFrame = targetFrameIndex => {
    const {
      viewport
    } = getCurrentViewport();
    if (!viewport || typeof viewport.setImageIdIndex !== 'function') return;
    viewport.setImageIdIndex(targetFrameIndex);
    viewport.render();
    setTimeout(() => {
      setCurrentFrameIndex(targetFrameIndex);
    }, 200);
  };

  // Handle clicking on a redaction area to navigate to its frame
  const handleAreaClick = area => {
    // Only navigate for frame-specific redactions that are not on the current frame
    if (!area.isGlobal && area.frameIndex !== undefined && area.frameIndex !== currentFrameIndex) {
      navigateToFrame(area.frameIndex);
    }
  };

  // Apply redaction with confirmation - generate preview for current frame only
  const handleApplyRedaction = async () => {
    if (stats.totalAreas === 0 && metadataRedactions.length === 0) {
      alert('No redaction areas or metadata redactions defined. Please draw redaction rectangles or apply metadata redactions first.');
      return;
    }
    const {
      viewportId,
      viewport
    } = getCurrentViewport();
    if (!viewport) return;
    try {
      // Separate global and frame-specific areas
      const globalAreas = stats.areas.filter(area => area.isGlobal);
      const frameSpecificAreas = stats.areas.filter(area => !area.isGlobal);

      // Create preview list: one row for global, individual rows for frame-specific
      const previews = [];

      // Add one row for all global redactions (if any)
      if (globalAreas.length > 0) {
        previews.push({
          frameIndex: null,
          // null indicates this is the global row
          areaCount: globalAreas.length,
          isGlobal: true,
          isCurrentFrame: false
        });
      }

      // Add individual rows for each frame with frame-specific redactions
      const framesWithAreas = new Map(); // frameIndex -> count
      frameSpecificAreas.forEach(area => {
        const frameIdx = area.frameIndex !== undefined ? area.frameIndex : 0;
        framesWithAreas.set(frameIdx, (framesWithAreas.get(frameIdx) || 0) + 1);
      });

      // Sort by frame index and add to previews
      for (const [frameIdx, count] of Array.from(framesWithAreas.entries()).sort((a, b) => a[0] - b[0])) {
        previews.push({
          frameIndex: frameIdx,
          areaCount: count,
          isGlobal: false,
          isCurrentFrame: frameIdx === currentFrameIndex
        });
      }
      if (previews.length > 0 || metadataRedactions.length > 0) {
        if (previews.length > 0) {
          setPreviewFrames(previews);
        }
        if (metadataRedactions.length > 0) {
          setMetadataRedactions(metadataRedactions);
        }
        setConfirmDialogOpen(true);
      } else {
        alert('No redaction areas or metadata redactions found');
      }
    } catch (error) {
      alert('Error preparing preview: ' + error.message);
    }
  };

  // Confirm and apply redaction - download metadata JSON only
  const confirmApplyRedaction = async () => {
    const viewportDetails = getCurrentViewport();
    if (!viewportDetails.viewport || !viewportDetails.element) return;
    setConfirmDialogOpen(false);
    try {
      // Export redaction metadata
      const redactionJson = await services_RedactionService.exportCombinedRedactionMetadata(viewportDetails);

      // Download metadata JSON
      redactionJson['enableFileOverwrite'] = enableFileOverwrite;

      // Retrieve serverHostname from config
      let serverHostname = '';
      serverHostname = window.config.dataSources.find(ds => ds.namespace.includes('databricksPixelsDicom'))?.configuration?.serverHostname || '';
      // Mark as applied in service
      const applyResult = await services_RedactionService.applyRedaction(redactionJson, serverHostname);
      if (applyResult.status === 'inserted') {
        alert(`Redaction metadata saved successfully!\n
          Total redacted areas: ${redactionJson.totalRedactionAreas}
          Total metadata redactions: ${redactionJson.totalMetadataRedactions}
          Total files to edit: ${redactionJson.totalFilesInSeries}
          Redaction ID: ${applyResult['redaction_id']}`);
        updateStats();
      } else {
        alert(`Error: ${applyResult.message}`);
      }

      // Clear preview
      setPreviewFrames([]);
    } catch (error) {
      console.error('Error applying redaction:', error);
      alert(`Error applying redaction: ${error.message}`);
      setPreviewFrames([]);
    }
  };

  // Cancel dialog and clear preview
  const cancelApplyRedaction = () => {
    setConfirmDialogOpen(false);
    setPreviewFrames([]);
  };

  // Show preview for a specific frame or global redactions
  const showFramePreview = async (frameIdx, isGlobal) => {
    const {
      viewportId,
      viewport,
      element
    } = getCurrentViewport();
    if (!viewport || !element) return;
    try {
      const originalFrameIndex = currentFrameIndex;

      // For global preview, use current frame; for frame-specific, navigate to that frame
      const targetFrameIndex = isGlobal ? currentFrameIndex : frameIdx;

      // Navigate to the target frame
      if (typeof viewport.setImageIdIndex === 'function') {
        viewport.setImageIdIndex(targetFrameIndex);
        await new Promise(resolve => setTimeout(resolve, 300)); // Wait for frame to load
      }
      let combinedAnnotations = [];
      if (isGlobal) {
        // For global preview, show only global annotations
        const allStoredAreas = services_RedactionService.getAreaManager(viewportId).getAllAreas();
        combinedAnnotations = allStoredAreas.filter(area => area.isGlobal).map(area => ({
          annotationUID: area.annotationUID,
          topLeft: area.topLeft,
          bottomRight: area.bottomRight,
          worldCoordinates: area.worldCoordinates
        }));
      } else {
        // For frame-specific preview, show frame-specific + global annotations
        const frameSpecificAnnotations = services_RedactionService.getStoredFrameAreas(viewportId, targetFrameIndex);
        const allStoredAreas = services_RedactionService.getAreaManager(viewportId).getAllAreas();
        const globalAnnotations = allStoredAreas.filter(area => area.isGlobal).map(area => ({
          annotationUID: area.annotationUID,
          topLeft: area.topLeft,
          bottomRight: area.bottomRight,
          worldCoordinates: area.worldCoordinates
        }));
        combinedAnnotations = [...frameSpecificAnnotations, ...globalAnnotations];
      }

      // Generate preview
      const result = await services_RedactionService.exportRedactedImageWithAreas(viewportId, viewport, combinedAnnotations);

      // Navigate back to original frame
      if (typeof viewport.setImageIdIndex === 'function') {
        viewport.setImageIdIndex(originalFrameIndex);
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Force viewport render
      viewport.render();
      if (result.success && result.dataUrl) {
        setPreviewPopupImage(result.dataUrl);
        setPreviewPopupFrameIndex(targetFrameIndex);
        setPreviewPopupOpen(true);
      } else {
        alert('Failed to generate preview: ' + (result.error || result.message));
      }
    } catch (error) {
      alert('Error generating preview: ' + error.message);
    }
  };

  // Close preview popup
  const closePreviewPopup = () => {
    setPreviewPopupOpen(false);
    setPreviewPopupImage(null);
  };

  // Watch for annotation and frame changes
  (0,react.useEffect)(() => {
    updateStats(); // Initial load

    // Sync global annotations on initial load
    const {
      element,
      viewport,
      viewportId,
      seriesInstanceUID
    } = getCurrentViewport();
    if (element && viewport) {
      services_RedactionService.syncGlobalAnnotationsToFrame(viewportId, element, viewport);
    }

    // Initialize series UID tracking
    if (seriesInstanceUID && !currentSeriesUID) {
      setCurrentSeriesUID(seriesInstanceUID);
    }
    const intervalId = setInterval(() => {
      const {
        element,
        frameIndex,
        viewportId,
        viewport,
        seriesInstanceUID
      } = getCurrentViewport();
      if (!element || !viewport) return;

      // Detect series change (different DICOM series loaded)
      if (seriesInstanceUID && seriesInstanceUID !== currentSeriesUID) {
        console.log(`Series changed: ${currentSeriesUID}  ${seriesInstanceUID}`);
        clearAll();

        // Update series UID
        setCurrentSeriesUID(seriesInstanceUID);
        setPreviousFrameIndex(0);
        setCurrentFrameIndex(0);
        setPreviousAnnotationCount(0);
        setPreviousMetadataCount(0);
        setPreviousMetadataTimestamp('');
        setMetadataRedactions([]);
        updateStats();
        return;
      }

      // Detect frame change
      if (frameIndex !== previousFrameIndex) {
        console.log(`Frame changed: ${previousFrameIndex}  ${frameIndex}`);
        setPreviousFrameIndex(frameIndex);
        setCurrentFrameIndex(frameIndex);

        // Always sync global annotations on frame change (updates z-coordinates)
        services_RedactionService.syncGlobalAnnotationsToFrame(viewportId, element, viewport);
        const areas = services_RedactionService.getRedactionAreas(viewportId, element, viewport, frameIndex, applyToAllFrames);
        setPreviousAnnotationCount(areas.length);
        updateStats();
        return;
      }

      // Detect annotation changes
      const areas = services_RedactionService.getRedactionAreas(viewportId, element, viewport, frameIndex, applyToAllFrames);
      const currentCount = areas.length;
      if (currentCount > previousAnnotationCount) {
        // New annotations added
        const newAnnotations = areas.slice(-(currentCount - previousAnnotationCount));
        console.log(`Storing ${newAnnotations.length} new annotation(s) for frame ${frameIndex}`);
        services_RedactionService.storeSpecificAreas(viewportId, viewport, newAnnotations, frameIndex, applyToAllFrames);
        setPreviousAnnotationCount(currentCount);
        updateStats();
      } else if (currentCount < previousAnnotationCount) {
        // Annotation deleted
        console.log(`Annotation deleted on frame ${frameIndex}`);
        setPreviousAnnotationCount(currentCount);
        updateStats();
      } else if (currentCount > 0) {
        // Check for modifications on current frame's annotations only
        const storedAreas = services_RedactionService.getStoredFrameAreas(viewportId, frameIndex);
        if (storedAreas.length > 0) {
          const storedUIDs = new Set(storedAreas.map(a => a.annotationUID));
          const currentFrameAreas = areas.filter(a => storedUIDs.has(a.annotationUID));

          // Check if any coordinates changed
          const hasChanges = currentFrameAreas.some(area => {
            const stored = storedAreas.find(s => s.annotationUID === area.annotationUID);
            return stored && (area.topLeft[0] !== stored.topLeft[0] || area.topLeft[1] !== stored.topLeft[1] || area.bottomRight[0] !== stored.bottomRight[0] || area.bottomRight[1] !== stored.bottomRight[1]);
          });
          if (hasChanges) {
            console.log(`Annotation(s) modified on frame ${frameIndex}`);
            services_RedactionService.updateFrameAreas(viewportId, viewport, currentFrameAreas, frameIndex, applyToAllFrames);
            updateStats();
          }
        }
      }

      // Check for metadata redaction changes (check both count AND timestamp)
      const metadataStats = services_RedactionService.getMetadataRedactionStats();
      const currentMetadataCount = metadataStats.totalRedactions || 0;

      // Get the latest timestamp from all redactions
      let latestTimestamp = '';
      if (metadataStats && metadataStats.series && Array.isArray(metadataStats.series)) {
        metadataStats.series.forEach(seriesInfo => {
          if (seriesInfo.instances && Array.isArray(seriesInfo.instances)) {
            seriesInfo.instances.forEach(instanceInfo => {
              if (instanceInfo.timestamp && instanceInfo.timestamp > latestTimestamp) {
                latestTimestamp = instanceInfo.timestamp;
              }
            });
          }
        });
      }

      // Update if count OR timestamp changed
      if (currentMetadataCount !== previousMetadataCount || latestTimestamp !== previousMetadataTimestamp) {
        setPreviousMetadataCount(currentMetadataCount);
        setPreviousMetadataTimestamp(latestTimestamp);
        updateMetadataRedactions();
      }
    }, 300);
    return () => clearInterval(intervalId);
  }, [previousAnnotationCount, previousFrameIndex, applyToAllFrames, currentSeriesUID, stats.totalAreas, previousMetadataCount, previousMetadataTimestamp]);
  return /*#__PURE__*/react.createElement("div", {
    className: "redaction-panel",
    style: {
      padding: '16px',
      fontFamily: 'Arial, sans-serif'
    }
  }, /*#__PURE__*/react.createElement("h3", {
    style: {
      marginBottom: '16px',
      color: '#333'
    }
  }, "Redactor"), /*#__PURE__*/react.createElement(components_ExportSettings, {
    enableFileOverwrite: enableFileOverwrite,
    onToggleFileOverwrite: setEnableFileOverwrite
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      marginBottom: '16px'
    }
  }, /*#__PURE__*/react.createElement("button", {
    onClick: clearAll,
    disabled: stats.totalAreas === 0 && metadataRedactions.length === 0,
    style: {
      width: '100%',
      padding: '10px',
      backgroundColor: stats.totalAreas === 0 && metadataRedactions.length === 0 ? '#e9ecef' : '#dc3545',
      color: stats.totalAreas === 0 && metadataRedactions.length === 0 ? '#6c757d' : 'white',
      border: 'none',
      borderRadius: '4px',
      cursor: stats.totalAreas === 0 && metadataRedactions.length === 0 ? 'not-allowed' : 'pointer',
      fontSize: '14px'
    }
  }, "Clear All (Areas: ", stats.totalAreas, ", Metadata: ", metadataRedactions.length, ")")), /*#__PURE__*/react.createElement("hr", {
    style: {
      margin: '16px 0',
      border: 'none',
      borderTop: '1px solid #dee2e6'
    }
  }), /*#__PURE__*/react.createElement(components_RedactionAreasList, {
    areas: stats.areas,
    currentFrameIndex: currentFrameIndex,
    onAreaClick: handleAreaClick,
    onAreaHover: handleAreaHover,
    onToggleGlobal: toggleRedactionGlobal,
    onDeleteArea: deleteRedactionArea
  }), /*#__PURE__*/react.createElement("hr", {
    style: {
      margin: '16px 0',
      border: 'none',
      borderTop: '1px solid #dee2e6'
    }
  }), /*#__PURE__*/react.createElement(components_MetadataRedactionsList, {
    redactions: metadataRedactions
  }), /*#__PURE__*/react.createElement("hr", {
    style: {
      margin: '16px 0',
      border: 'none',
      borderTop: '1px solid #dee2e6'
    }
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      marginTop: '16px'
    }
  }, /*#__PURE__*/react.createElement("button", {
    onClick: handleApplyRedaction,
    disabled: stats.totalAreas === 0 && metadataRedactions.length === 0,
    style: {
      width: '100%',
      padding: '12px',
      marginBottom: '8px',
      backgroundColor: stats.totalAreas === 0 && metadataRedactions.length === 0 ? '#e9ecef' : '#28a745',
      color: stats.totalAreas === 0 && metadataRedactions.length === 0 ? '#6c757d' : 'white',
      border: 'none',
      borderRadius: '4px',
      cursor: stats.totalAreas === 0 && metadataRedactions.length === 0 ? 'not-allowed' : 'pointer',
      fontSize: '14px',
      fontWeight: 'bold'
    }
  }, "Apply Redaction (", stats.totalAreas, " areas, ", metadataRedactions.length, " tags)")), /*#__PURE__*/react.createElement(components_ConfirmationDialog, {
    isOpen: confirmDialogOpen,
    previewFrames: previewFrames,
    stats: stats,
    metadataRedactions: metadataRedactions,
    currentFrameIndex: currentFrameIndex,
    previewPopupOpen: previewPopupOpen,
    previewPopupImage: previewPopupImage,
    previewPopupFrameIndex: previewPopupFrameIndex,
    onCancel: cancelApplyRedaction,
    onConfirm: confirmApplyRedaction,
    onShowFramePreview: showFramePreview,
    onClosePreviewPopup: closePreviewPopup
  }));
};
/* harmony default export */ const components_RedactionPanel = (RedactionPanel);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/getPanelModule.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/



function getPanelModule({
  commandsManager,
  extensionManager,
  servicesManager
}) {
  const WrappedRedactionPanel = () => {
    return /*#__PURE__*/react.createElement(components_RedactionPanel, {
      commandsManager: commandsManager,
      servicesManager: servicesManager,
      extensionManager: extensionManager
    });
  };
  return [{
    name: 'redactionPanel',
    iconName: 'icon-tool-rectangle',
    iconLabel: 'Redactor',
    label: 'Redactor',
    secondaryLabel: 'Redactor',
    component: WrappedRedactionPanel
  }];
}
/* harmony default export */ const src_getPanelModule = (getPanelModule);
// EXTERNAL MODULE: ../../../node_modules/dcmjs/build/dcmjs.es.js
var dcmjs_es = __webpack_require__(5842);
// EXTERNAL MODULE: ../../core/src/index.ts + 68 modules
var src = __webpack_require__(15871);
// EXTERNAL MODULE: ../../ui-next/src/index.ts + 3073 modules
var ui_next_src = __webpack_require__(17130);
// EXTERNAL MODULE: ../../../node_modules/react-window/dist/index.esm.js
var index_esm = __webpack_require__(28271);
// EXTERNAL MODULE: ../../../node_modules/classnames/index.js
var classnames = __webpack_require__(55530);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ../../../node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(62051);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/DicomTagRedactorTable.tsx





const lineHeightPx = 5;
const lineHeightClassName = `leading-[${lineHeightPx}px]`;
const rowVerticalPaddingPx = 10;
const rowBottomBorderPx = 1;
const rowVerticalPaddingStyle = {
  padding: `${rowVerticalPaddingPx}px 0`
};
const rowStyle = {
  borderBottomWidth: `${rowBottomBorderPx}px`,
  ...rowVerticalPaddingStyle
};
const indentationPadding = 8;
const RowComponent = ({
  row,
  style,
  keyPrefix,
  onToggle,
  selectedAction,
  onActionChange,
  modifiedValue,
  onValueChange,
  isSelected,
  onSelectChange
}) => {
  const inputRef = (0,react.useRef)(null);
  const [localValue, setLocalValue] = (0,react.useState)(modifiedValue);
  const handleToggle = (0,react.useCallback)(() => {
    onToggle(!row.areChildrenVisible);
  }, [row.areChildrenVisible, onToggle]);
  const hasChildren = row.children && row.children.length > 0;
  const isChildOrParent = hasChildren || row.depth > 0;
  const padding = indentationPadding * (1 + 2 * row.depth);
  const handleActionChange = e => {
    onActionChange(e.target.value);
  };
  const handleReset = () => {
    setLocalValue(row.value);
    onValueChange(row.value); // Update parent immediately
    onActionChange('none');
  };
  const handleShowOriginal = () => {
    alert(`Original Value: ${row.value}\n\nNew Value: ${localValue}`);
  };
  const handleBlur = () => {
    // Save the current value when focus is lost
    onValueChange(localValue);
  };

  // Update local value when modified value changes externally (e.g., loading existing redactions)
  (0,react.useEffect)(() => {
    setLocalValue(modifiedValue);
  }, [modifiedValue]);
  const actionButtonStyle = "text-xs px-2 py-1 rounded";
  return /*#__PURE__*/react.createElement("div", {
    style: {
      ...style,
      ...rowStyle
    },
    className: classnames_default()('hover:bg-secondary-main border-secondary-light text-foreground flex w-full flex-row items-center break-all bg-black text-base transition duration-300', lineHeightClassName, {
      'bg-primary/10': isSelected
    }),
    key: keyPrefix
  }, /*#__PURE__*/react.createElement("div", {
    className: "w-1/24 px-2 flex items-center justify-center"
  }, /*#__PURE__*/react.createElement("input", {
    type: "checkbox",
    checked: isSelected,
    onChange: e => onSelectChange(e.target.checked),
    className: "cursor-pointer w-4 h-4"
  })), isChildOrParent && /*#__PURE__*/react.createElement("div", {
    style: {
      paddingLeft: `${padding}px`,
      opacity: onToggle ? 1 : 0
    }
  }, row.areChildrenVisible ? /*#__PURE__*/react.createElement("div", {
    className: "cursor-pointer p-1",
    onClick: handleToggle
  }, /*#__PURE__*/react.createElement(ui_next_src/* Icons */.FI1.ChevronDown, null)) : /*#__PURE__*/react.createElement("div", {
    className: "cursor-pointer p-1",
    onClick: handleToggle
  }, /*#__PURE__*/react.createElement(ui_next_src/* Icons */.FI1.ChevronRight, null))), /*#__PURE__*/react.createElement("div", {
    className: "w-3/24 px-3"
  }, row.tag), /*#__PURE__*/react.createElement("div", {
    className: "w-2/24 px-3"
  }, row.valueRepresentation), /*#__PURE__*/react.createElement("div", {
    className: "w-5/24 px-3"
  }, row.keyword), /*#__PURE__*/react.createElement("div", {
    className: "w-5/24 grow px-3"
  }, selectedAction === 'modify' ? /*#__PURE__*/react.createElement("div", {
    className: "flex items-center gap-1"
  }, /*#__PURE__*/react.createElement("input", {
    ref: inputRef,
    type: "text",
    value: localValue,
    onChange: e => setLocalValue(e.target.value),
    onBlur: handleBlur,
    onKeyDown: e => {
      if (e.key === 'Escape') {
        e.preventDefault();
        handleReset();
      }
    },
    className: "flex-1 bg-black border border-gray-600 rounded px-2 py-1 text-sm text-white",
    placeholder: row.value
  }), /*#__PURE__*/react.createElement("button", {
    onMouseDown: e => {
      // Prevent blur on input when clicking the button
      e.preventDefault();
    },
    onClick: handleReset,
    className: "px-2 py-1 bg-gray-600 hover:bg-gray-700 text-white rounded text-xs",
    title: "Reset to original value"
  }, "\u21BA"), /*#__PURE__*/react.createElement("button", {
    onMouseDown: e => {
      // Prevent blur on input when clicking the button
      e.preventDefault();
    },
    onClick: handleShowOriginal,
    className: "px-2 py-1 bg-gray-600 hover:bg-gray-700 text-white rounded text-xs",
    title: "Show original value"
  }, "\u2139")) : /*#__PURE__*/react.createElement("span", null, row.value)), /*#__PURE__*/react.createElement("div", {
    className: "w-4/24 px-3"
  }, /*#__PURE__*/react.createElement("select", {
    value: selectedAction,
    onChange: handleActionChange,
    className: "w-full bg-black border border-gray-600 rounded px-2 py-1 text-sm text-white cursor-pointer"
  }, /*#__PURE__*/react.createElement("option", {
    value: "none"
  }, "No Action"), /*#__PURE__*/react.createElement("option", {
    value: "redact"
  }, "Redact"), /*#__PURE__*/react.createElement("option", {
    value: "hash"
  }, "Hash"), /*#__PURE__*/react.createElement("option", {
    value: "modify"
  }, "Modify"), /*#__PURE__*/react.createElement("option", {
    value: "remove"
  }, "Remove"))));
};
function ColumnHeaders({
  selectRef,
  tagRef,
  vrRef,
  keywordRef,
  valueRef,
  actionRef,
  onSelectAll,
  allSelected
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()('bg-secondary-dark ohif-scrollbar flex w-full flex-row overflow-y-scroll'),
    style: rowVerticalPaddingStyle
  }, /*#__PURE__*/react.createElement("div", {
    className: "w-1/24 px-2 flex items-center justify-center"
  }, /*#__PURE__*/react.createElement("input", {
    ref: selectRef,
    type: "checkbox",
    checked: allSelected,
    onChange: e => onSelectAll(e.target.checked),
    className: "cursor-pointer w-4 h-4"
  })), /*#__PURE__*/react.createElement("div", {
    className: "w-3/24 px-3"
  }, /*#__PURE__*/react.createElement("label", {
    ref: tagRef,
    className: "flex flex-1 select-none flex-col pl-1 text-lg text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "flex flex-row items-center focus:outline-none"
  }, "Tag"))), /*#__PURE__*/react.createElement("div", {
    className: "w-2/24 px-3"
  }, /*#__PURE__*/react.createElement("label", {
    ref: vrRef,
    className: "flex flex-1 select-none flex-col pl-1 text-lg text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "flex flex-row items-center focus:outline-none"
  }, "VR"))), /*#__PURE__*/react.createElement("div", {
    className: "w-5/24 px-3"
  }, /*#__PURE__*/react.createElement("label", {
    ref: keywordRef,
    className: "flex flex-1 select-none flex-col pl-1 text-lg text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "flex flex-row items-center focus:outline-none"
  }, "Keyword"))), /*#__PURE__*/react.createElement("div", {
    className: "w-5/24 grow px-3"
  }, /*#__PURE__*/react.createElement("label", {
    ref: valueRef,
    className: "flex flex-1 select-none flex-col pl-1 text-lg text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "flex flex-row items-center focus:outline-none"
  }, "Value"))), /*#__PURE__*/react.createElement("div", {
    className: "w-4/24 px-3"
  }, /*#__PURE__*/react.createElement("label", {
    ref: actionRef,
    className: "flex flex-1 select-none flex-col pl-1 text-lg text-white"
  }, /*#__PURE__*/react.createElement("span", {
    className: "flex flex-row items-center focus:outline-none"
  }, "Action"))));
}
function DicomTagRedactorTable({
  rows,
  onApplyRedactions,
  showOnlySelected = false,
  existingRedactions = [],
  shortcutRedactions = [],
  clearAllTrigger = 0
}) {
  const listRef = (0,react.useRef)();
  const canvasRef = (0,react.useRef)(null);
  const containerRef = (0,react.useRef)(null);
  const [selectHeaderElem, setSelectHeaderElem] = (0,react.useState)(null);
  const [tagHeaderElem, setTagHeaderElem] = (0,react.useState)(null);
  const [vrHeaderElem, setVrHeaderElem] = (0,react.useState)(null);
  const [keywordHeaderElem, setKeywordHeaderElem] = (0,react.useState)(null);
  const [valueHeaderElem, setValueHeaderElem] = (0,react.useState)(null);
  const [actionHeaderElem, setActionHeaderElem] = (0,react.useState)(null);
  const [internalRows, setInternalRows] = (0,react.useState)(rows);
  const [listHeight, setListHeight] = (0,react.useState)(600);

  // Store redaction actions for each row
  const [rowActions, setRowActions] = (0,react.useState)(new Map());
  const [rowModifiedValues, setRowModifiedValues] = (0,react.useState)(new Map());
  const [selectedRows, setSelectedRows] = (0,react.useState)(new Set());
  const selectRef = elem => {
    if (elem) setSelectHeaderElem(elem);
  };
  const tagRef = elem => {
    if (elem) setTagHeaderElem(elem);
  };
  const vrRef = elem => {
    if (elem) setVrHeaderElem(elem);
  };
  const keywordRef = elem => {
    if (elem) setKeywordHeaderElem(elem);
  };
  const valueRef = elem => {
    if (elem) setValueHeaderElem(elem);
  };
  const actionRef = elem => {
    if (elem) setActionHeaderElem(elem);
  };
  (0,react.useEffect)(() => {
    setInternalRows(rows);
  }, [rows]);

  // Apply existing redactions when they are provided
  (0,react.useEffect)(() => {
    if (existingRedactions && existingRedactions.length > 0) {
      console.log('Applying existing redactions:', existingRedactions);
      const newRowActions = new Map();
      const newRowModifiedValues = new Map();
      const newSelectedRows = new Set();
      existingRedactions.forEach(redaction => {
        // Find the matching row by tag
        const matchingRow = rows.find(row => row.tag === redaction.tag);
        if (matchingRow) {
          console.log('Found matching row for tag:', redaction.tag, matchingRow);
          newRowActions.set(matchingRow.uid, redaction.action);
          if (redaction.action === 'modify' && redaction.newValue) {
            newRowModifiedValues.set(matchingRow.uid, redaction.newValue);
          }

          // Select the row if it has an action
          if (redaction.action !== 'none') {
            newSelectedRows.add(matchingRow.uid);
          }
        }
      });
      setRowActions(newRowActions);
      setRowModifiedValues(newRowModifiedValues);
      setSelectedRows(newSelectedRows);
      console.log('Applied actions:', newRowActions);
      console.log('Applied values:', newRowModifiedValues);
      console.log('Selected rows:', newSelectedRows);
    }
  }, [existingRedactions, rows]);

  // Apply shortcut redactions when they are provided
  (0,react.useEffect)(() => {
    if (shortcutRedactions && shortcutRedactions.length > 0) {
      console.log('Applying shortcut redactions:', shortcutRedactions);
      setRowActions(prev => {
        const newRowActions = new Map(prev);
        shortcutRedactions.forEach(redaction => {
          // Find the matching row by tag or keyword
          const matchingRow = rows.find(row => row.tag === redaction.tag || row.keyword === redaction.keyword);
          if (matchingRow) {
            console.log('Found matching row for shortcut:', redaction.tag, matchingRow);
            newRowActions.set(matchingRow.uid, redaction.action);
          }
        });
        return newRowActions;
      });
      setRowModifiedValues(prev => {
        const newRowModifiedValues = new Map(prev);
        shortcutRedactions.forEach(redaction => {
          const matchingRow = rows.find(row => row.tag === redaction.tag || row.keyword === redaction.keyword);
          if (matchingRow && (redaction.action === 'modify' || redaction.action === 'redact') && redaction.value !== undefined) {
            newRowModifiedValues.set(matchingRow.uid, redaction.value);
          }
        });
        return newRowModifiedValues;
      });
      setSelectedRows(prev => {
        const newSelectedRows = new Set(prev);
        shortcutRedactions.forEach(redaction => {
          const matchingRow = rows.find(row => row.tag === redaction.tag || row.keyword === redaction.keyword);
          if (matchingRow && redaction.action !== 'none') {
            newSelectedRows.add(matchingRow.uid);
          }
        });
        return newSelectedRows;
      });
    }
  }, [shortcutRedactions, rows]);

  // Clear all actions when clearAllTrigger changes
  (0,react.useEffect)(() => {
    if (clearAllTrigger > 0) {
      console.log('Clearing all actions');
      setRowActions(new Map());
      setRowModifiedValues(new Map());
      setSelectedRows(new Set());
    }
  }, [clearAllTrigger]);
  const visibleRows = (0,react.useMemo)(() => {
    let filtered = internalRows.filter(row => row.isVisible);

    // If showOnlySelected is true, filter to only show selected rows
    if (showOnlySelected) {
      filtered = filtered.filter(row => selectedRows.has(row.uid));
    }
    return filtered;
  }, [internalRows, showOnlySelected, selectedRows]);
  const allSelected = (0,react.useMemo)(() => {
    return visibleRows.length > 0 && visibleRows.every(row => selectedRows.has(row.uid));
  }, [visibleRows, selectedRows]);
  const handleSelectAll = (0,react.useCallback)(selected => {
    if (selected) {
      setSelectedRows(new Set(visibleRows.map(row => row.uid)));
    } else {
      setSelectedRows(new Set());
    }
  }, [visibleRows]);
  const handleSelectRow = (0,react.useCallback)((uid, selected) => {
    setSelectedRows(prev => {
      const newSet = new Set(prev);
      if (selected) {
        newSet.add(uid);
      } else {
        newSet.delete(uid);
      }
      return newSet;
    });
  }, []);
  const handleActionChange = (0,react.useCallback)((uid, action) => {
    setRowActions(prev => {
      const newMap = new Map(prev);
      newMap.set(uid, action);
      return newMap;
    });

    // Automatically select/deselect the row based on action
    setSelectedRows(prev => {
      const newSet = new Set(prev);
      if (action !== 'none') {
        newSet.add(uid);
      } else {
        newSet.delete(uid);
      }
      return newSet;
    });
  }, []);
  const handleValueChange = (0,react.useCallback)((uid, value) => {
    setRowModifiedValues(prev => {
      const newMap = new Map(prev);
      newMap.set(uid, value);
      return newMap;
    });
  }, []);
  const handleApplyRedactions = (0,react.useCallback)(() => {
    // Blur any focused input to ensure its value is saved
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }

    // Delay to ensure blur event completes
    setTimeout(() => {
      const redactions = visibleRows.filter(row => {
        const action = rowActions.get(row.uid) || 'none';
        return action !== 'none';
      }).map(row => {
        const action = rowActions.get(row.uid) || 'none';
        const modifiedValue = rowModifiedValues.get(row.uid) || row.value;
        return {
          uid: row.uid,
          tag: row.tag,
          keyword: row.keyword,
          vr: row.valueRepresentation,
          originalValue: row.value,
          action: action,
          newValue: action === 'modify' ? modifiedValue : action === 'remove' ? '' : null
        };
      });

      // Always call onApplyRedactions, even with empty array (will just close the modal)
      onApplyRedactions(redactions);
    }, 100);
  }, [visibleRows, rowActions, rowModifiedValues, onApplyRedactions]);
  (0,react.useEffect)(() => {
    if (!listRef?.current) {
      return;
    }
    listRef.current.scrollTo(0);
    listRef.current.resetAfterIndex(0);
  }, [rows]);
  (0,react.useEffect)(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const height = containerRef.current.clientHeight;
        setListHeight(height);
      }
      listRef.current?.resetAfterIndex(0);
    };
    const debouncedResize = lodash_debounce_default()(updateHeight, 100);

    // Initial height calculation
    updateHeight();
    window.addEventListener('resize', debouncedResize);
    return () => {
      debouncedResize.cancel();
      window.removeEventListener('resize', debouncedResize);
    };
  }, []);
  const getOneRowHeight = (0,react.useCallback)(row => {
    if (!tagHeaderElem || !vrHeaderElem || !keywordHeaderElem || !valueHeaderElem || !actionHeaderElem || !selectHeaderElem) {
      return 50; // Default height
    }
    const headerWidths = [selectHeaderElem.offsetWidth, tagHeaderElem.offsetWidth, vrHeaderElem.offsetWidth, keywordHeaderElem.offsetWidth, valueHeaderElem.offsetWidth, actionHeaderElem.offsetWidth];
    const context = canvasRef.current?.getContext('2d');
    if (!context) return 50;
    context.font = getComputedStyle(canvasRef.current).font;
    const propertiesToCheck = ['', 'tag', 'valueRepresentation', 'keyword', 'value', ''];
    return Object.entries(row).filter(([key]) => propertiesToCheck.includes(key)).map(([, colText], index) => {
      const colOneLineWidth = context.measureText(String(colText)).width;
      const numLines = Math.ceil(colOneLineWidth / headerWidths[index]);
      return numLines * lineHeightPx + 2 * rowVerticalPaddingPx + rowBottomBorderPx;
    }).reduce((maxHeight, colHeight) => Math.max(maxHeight, colHeight), 0);
  }, [keywordHeaderElem, tagHeaderElem, valueHeaderElem, vrHeaderElem, actionHeaderElem, selectHeaderElem]);
  const getItemSize = (0,react.useCallback)(rows => index => {
    const row = rows[index];
    const height = getOneRowHeight(row);
    return height;
  }, [getOneRowHeight]);
  const onToggle = (0,react.useCallback)(sourceRow => {
    if (!sourceRow.children) {
      return undefined;
    }
    return areChildrenVisible => {
      const newInternalRows = internalRows.map(internalRow => {
        if (sourceRow.uid === internalRow.uid) {
          return {
            ...internalRow,
            areChildrenVisible
          };
        }
        if (sourceRow.children.includes(internalRow.uid)) {
          return {
            ...internalRow,
            isVisible: areChildrenVisible,
            areChildrenVisible
          };
        }
        return internalRow;
      });
      setInternalRows(newInternalRows);
      listRef?.current?.resetAfterIndex(0);
    };
  }, [internalRows, listRef]);
  const getRowComponent = (0,react.useCallback)(({
    rows
  }) => function RowList({
    index,
    style
  }) {
    const row = (0,react.useMemo)(() => rows[index], [index]);
    return /*#__PURE__*/react.createElement(RowComponent, {
      style: style,
      row: row,
      keyPrefix: `DICOMTagRedactorRow-${index}`,
      onToggle: onToggle(row),
      selectedAction: rowActions.get(row.uid) || 'none',
      onActionChange: action => handleActionChange(row.uid, action),
      modifiedValue: rowModifiedValues.get(row.uid) || row.value,
      onValueChange: value => handleValueChange(row.uid, value),
      isSelected: selectedRows.has(row.uid),
      onSelectChange: selected => handleSelectRow(row.uid, selected)
    });
  }, [onToggle, rowActions, handleActionChange, rowModifiedValues, handleValueChange, selectedRows, handleSelectRow]);
  const isHeaderRendered = (0,react.useCallback)(() => tagHeaderElem !== null, [tagHeaderElem]);
  return /*#__PURE__*/react.createElement("div", {
    style: {
      height: '100%',
      display: 'flex',
      flexDirection: 'column',
      overflow: 'hidden'
    }
  }, /*#__PURE__*/react.createElement("canvas", {
    style: {
      visibility: 'hidden',
      position: 'absolute'
    },
    className: "text-base",
    ref: canvasRef
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      flexShrink: 0
    }
  }, /*#__PURE__*/react.createElement(ColumnHeaders, {
    selectRef: selectRef,
    tagRef: tagRef,
    vrRef: vrRef,
    keywordRef: keywordRef,
    valueRef: valueRef,
    actionRef: actionRef,
    onSelectAll: handleSelectAll,
    allSelected: allSelected
  })), /*#__PURE__*/react.createElement("div", {
    ref: containerRef,
    className: "relative border-2 border-black bg-black",
    style: {
      flex: 1,
      minHeight: '400px',
      overflow: 'hidden'
    }
  }, isHeaderRendered() && listHeight > 0 && visibleRows.length > 0 && /*#__PURE__*/react.createElement(index_esm/* VariableSizeList */._m, {
    ref: listRef,
    height: listHeight,
    itemCount: visibleRows.length,
    itemSize: getItemSize(visibleRows),
    width: '100%',
    className: "ohif-scrollbar text-foreground"
  }, getRowComponent({
    rows: visibleRows
  })), isHeaderRendered() && visibleRows.length === 0 && showOnlySelected && /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      color: '#888',
      fontSize: '14px',
      textAlign: 'center',
      padding: '20px'
    }
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", {
    style: {
      marginBottom: '10px'
    }
  }, "No tags selected"), /*#__PURE__*/react.createElement("p", {
    style: {
      fontSize: '12px'
    }
  }, "Select tags by choosing an action or checking the checkbox")))), /*#__PURE__*/react.createElement("div", {
    className: "mt-4 flex justify-between items-center gap-2 px-1",
    style: {
      flexShrink: 0,
      paddingBottom: '1rem'
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-sm text-muted-foreground"
  }, selectedRows.size > 0 ? `${selectedRows.size} tag(s) selected` : 'No tags selected'), /*#__PURE__*/react.createElement(ui_next_src/* Button */.$nd, {
    onClick: handleApplyRedactions,
    className: "bg-primary hover:bg-primary/80 text-white px-4 py-2 rounded"
  }, "Save Tag Redactions")));
}
/* harmony default export */ const components_DicomTagRedactorTable = (/*#__PURE__*/react.memo(DicomTagRedactorTable));
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/models/MetadataShortcutTag.ts
/**
 * Represents a single DICOM tag within a metadata shortcut group
 */

/**
 * Represents a group of related DICOM tags that can be applied together
 */

/**
 * Class to handle metadata shortcut operations
 */
class MetadataShortcutTag {
  constructor(group) {
    this.group = void 0;
    this.group = group;
  }

  /**
   * Get the shortcut group
   */
  getGroup() {
    return this.group;
  }

  /**
   * Get the shortcut group ID
   */
  getId() {
    return this.group.id;
  }

  /**
   * Get the shortcut group name
   */
  getName() {
    return this.group.name;
  }

  /**
   * Get the shortcut group description
   */
  getDescription() {
    return this.group.description;
  }

  /**
   * Get the priority level
   */
  getPriority() {
    return this.group.priority;
  }

  /**
   * Get all tags in this shortcut group
   */
  getTags() {
    return this.group.tags;
  }

  /**
   * Apply regex pattern to a value for redact action
   * @param value - The original value
   * @param pattern - The regex pattern to match
   * @returns The value with matched patterns redacted with [REDACTED]
   */
  applyRedactPattern(value, pattern) {
    if (!pattern || !value) {
      return value;
    }
    try {
      const regex = new RegExp(pattern, 'g');
      return value.replace(regex, '[REDACTED]');
    } catch (error) {
      console.error(`Invalid regex pattern: ${pattern}`, error);
      return value;
    }
  }

  /**
   * Process a tag based on its action and return the result
   * @param tagConfig - The tag configuration
   * @param originalValue - The original value from DICOM
   * @returns An object containing the action and processed value
   */
  processTag(tagConfig, originalValue) {
    switch (tagConfig.action) {
      case 'remove':
        return {
          action: 'remove',
          value: ''
        };
      case 'hash':
        return {
          action: 'hash',
          value: originalValue
        };
      case 'redact':
        if (tagConfig.pattern) {
          const redactedValue = this.applyRedactPattern(originalValue, tagConfig.pattern);
          return {
            action: 'modify',
            value: redactedValue
          };
        }
        // If no pattern, treat as remove
        return {
          action: 'remove',
          value: ''
        };
      case 'modify':
        return {
          action: 'modify',
          value: originalValue
        };
      default:
        return {
          action: 'none',
          value: originalValue
        };
    }
  }

  /**
   * Find matching tag configuration by tag string
   * @param tag - The DICOM tag string (e.g., "(0010,0010)")
   * @returns The matching tag configuration or undefined
   */
  findTagByString(tag) {
    return this.group.tags.find(t => t.tag === tag);
  }

  /**
   * Find matching tag configuration by keyword
   * @param keyword - The DICOM keyword (e.g., "PatientName")
   * @returns The matching tag configuration or undefined
   */
  findTagByKeyword(keyword) {
    return this.group.tags.find(t => t.keyword === keyword);
  }

  /**
   * Get a color class based on priority
   * @returns CSS color class name
   */
  getPriorityColorClass() {
    switch (this.group.priority) {
      case 'high':
        return 'bg-red-600 hover:bg-red-700';
      case 'medium':
        return 'bg-yellow-600 hover:bg-yellow-700';
      case 'low':
        return 'bg-blue-600 hover:bg-blue-700';
      default:
        return 'bg-gray-600 hover:bg-gray-700';
    }
  }

  /**
   * Get a border color class based on priority
   * @returns CSS border color class name
   */
  getPriorityBorderClass() {
    switch (this.group.priority) {
      case 'high':
        return 'border-red-500';
      case 'medium':
        return 'border-yellow-500';
      case 'low':
        return 'border-blue-500';
      default:
        return 'border-gray-500';
    }
  }
}

/**
 * Service class to manage metadata shortcuts
 */
class MetadataShortcutService {
  constructor(apiEndpoint = '/redaction/metadata_shortcuts') {
    this.shortcuts = [];
    this.apiEndpoint = void 0;
    this.apiEndpoint = apiEndpoint;
  }

  /**
   * Fetch metadata shortcuts from the API
   * @returns Promise resolving to array of MetadataShortcutTag instances
   */
  async fetchShortcuts() {
    try {
      const response = await fetch(this.apiEndpoint);
      if (!response.ok) {
        throw new Error(`Failed to fetch metadata shortcuts: ${response.statusText}`);
      }
      const data = await response.json();
      this.shortcuts = data.map(group => new MetadataShortcutTag(group));
      return this.shortcuts;
    } catch (error) {
      console.error('Error fetching metadata shortcuts:', error);
      return [];
    }
  }

  /**
   * Get all loaded shortcuts
   */
  getShortcuts() {
    return this.shortcuts;
  }

  /**
   * Get a shortcut by ID
   * @param id - The shortcut group ID
   * @returns The matching shortcut or undefined
   */
  getShortcutById(id) {
    return this.shortcuts.find(shortcut => shortcut.getId() === id);
  }

  /**
   * Get shortcuts filtered by priority
   * @param priority - The priority level to filter by
   * @returns Array of matching shortcuts
   */
  getShortcutsByPriority(priority) {
    return this.shortcuts.filter(shortcut => shortcut.getPriority() === priority);
  }

  /**
   * Sort shortcuts by priority (high -> medium -> low)
   * @returns Sorted array of shortcuts
   */
  getSortedShortcuts() {
    const priorityOrder = {
      high: 0,
      medium: 1,
      low: 2
    };
    return [...this.shortcuts].sort((a, b) => {
      const priorityA = priorityOrder[a.getPriority()] ?? 3;
      const priorityB = priorityOrder[b.getPriority()] ?? 3;
      return priorityA - priorityB;
    });
  }
}
/* harmony default export */ const models_MetadataShortcutTag = ((/* unused pure expression or super */ null && (MetadataShortcutTag)));
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/MetadataShortcuts.css
// extracted by mini-css-extract-plugin

;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/MetadataShortcuts.tsx



const MetadataShortcuts = ({
  onShortcutClick,
  apiEndpoint = '/redaction/metadata_shortcuts'
}) => {
  const [shortcuts, setShortcuts] = (0,react.useState)([]);
  const [loading, setLoading] = (0,react.useState)(true);
  const [error, setError] = (0,react.useState)(null);
  const [expanded, setExpanded] = (0,react.useState)(false);
  (0,react.useEffect)(() => {
    const loadShortcuts = async () => {
      try {
        setLoading(true);
        // Get configuration from window.config
        const getConfig = () => {
          return window.config || {};
        };
        const config = getConfig();
        const dataSource = config.dataSources?.find(ds => ds.sourceName === 'databricksPixelsDicom');
        const serverHostname = dataSource?.configuration?.serverHostname || 'http://localhost:8010';
        const apiEndpoint = `${serverHostname.replace("/sqlwarehouse", "")}/redaction/metadata_shortcuts`;
        const service = new MetadataShortcutService(apiEndpoint);
        const loadedShortcuts = await service.fetchShortcuts();
        const sortedShortcuts = new MetadataShortcutService(apiEndpoint);
        sortedShortcuts['shortcuts'] = loadedShortcuts;
        setShortcuts(sortedShortcuts.getSortedShortcuts());
        setError(null);
      } catch (err) {
        console.error('Failed to load metadata shortcuts:', err);
        setError('Failed to load shortcuts');
      } finally {
        setLoading(false);
      }
    };
    loadShortcuts();
  }, [apiEndpoint]);
  const handleShortcutClick = shortcut => {
    onShortcutClick(shortcut);
  };
  if (loading) {
    return /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-container"
    }, /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-header"
    }, /*#__PURE__*/react.createElement("h3", {
      className: "text-lg font-semibold text-white"
    }, "Quick Redaction Groups")), /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-loading"
    }, "Loading shortcuts..."));
  }
  if (error) {
    return /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-container"
    }, /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-header"
    }, /*#__PURE__*/react.createElement("h3", {
      className: "text-lg font-semibold text-white"
    }, "Quick Redaction Groups")), /*#__PURE__*/react.createElement("div", {
      className: "metadata-shortcuts-error"
    }, error));
  }
  if (shortcuts.length === 0) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcuts-container"
  }, /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcuts-header"
  }, /*#__PURE__*/react.createElement("h3", {
    className: "text-lg font-semibold text-white"
  }, "Quick Redaction Groups"), /*#__PURE__*/react.createElement("button", {
    onClick: () => setExpanded(!expanded),
    className: "metadata-shortcuts-toggle",
    "aria-label": expanded ? 'Collapse' : 'Expand'
  }, expanded ? '' : '')), expanded && /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcuts-content"
  }, /*#__PURE__*/react.createElement("p", {
    className: "text-sm text-gray-400 mb-3"
  }, "Click a group to automatically select and apply actions to related tags"), /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcuts-grid"
  }, shortcuts.map(shortcut => /*#__PURE__*/react.createElement("button", {
    key: shortcut.getId(),
    onClick: () => handleShortcutClick(shortcut),
    className: `metadata-shortcut-button ${shortcut.getPriorityBorderClass()}`,
    title: shortcut.getDescription()
  }, /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcut-header"
  }, /*#__PURE__*/react.createElement("span", {
    className: "metadata-shortcut-name"
  }, shortcut.getName()), /*#__PURE__*/react.createElement("span", {
    className: `metadata-shortcut-priority priority-${shortcut.getPriority()}`
  }, shortcut.getPriority().toUpperCase())), /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcut-description"
  }, shortcut.getDescription()), /*#__PURE__*/react.createElement("div", {
    className: "metadata-shortcut-count"
  }, shortcut.getTags().length, " tag", shortcut.getTags().length !== 1 ? 's' : ''))))));
};
/* harmony default export */ const components_MetadataShortcuts = (MetadataShortcuts);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/DicomTagRedactor.css
// extracted by mini-css-extract-plugin

;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/DicomTagRedactor.tsx









let rowCounter = 0;
const generateRowId = () => `row_${++rowCounter}`;
const {
  ImageSet
} = src.classes;
const {
  DicomMetaDictionary
} = dcmjs_es/* default.data */.Ay.data;
const {
  nameMap
} = DicomMetaDictionary;
const DicomTagRedactor = ({
  displaySets,
  displaySetInstanceUID,
  seriesInstanceUID,
  onApplyRedactions,
  onClose
}) => {
  const [instanceNumber, setInstanceNumber] = (0,react.useState)(1);
  const [shouldShowInstanceList, setShouldShowInstanceList] = (0,react.useState)(false);
  const [filterValue, setFilterValue] = (0,react.useState)('');
  const [showOnlySelected, setShowOnlySelected] = (0,react.useState)(false);
  const [existingRedactions, setExistingRedactions] = (0,react.useState)([]);
  const [shortcutRedactions, setShortcutRedactions] = (0,react.useState)([]);
  const [clearAllTrigger, setClearAllTrigger] = (0,react.useState)(0);
  const [isAIRedacting, setIsAIRedacting] = (0,react.useState)(false);

  // Load existing redactions when series or instance changes
  (0,react.useEffect)(() => {
    if (seriesInstanceUID && instanceNumber) {
      const redactions = services_RedactionService.getMetadataRedactions(seriesInstanceUID, instanceNumber);
      console.log('Loading existing redactions for series:', seriesInstanceUID, 'instance:', instanceNumber, redactions);
      setExistingRedactions(redactions);
    }
  }, [seriesInstanceUID, instanceNumber]);

  // Find the active display set using the displaySetInstanceUID prop
  const activeDisplaySet = displaySets.find(ds => ds.displaySetInstanceUID === displaySetInstanceUID);
  const getMetadata = (0,react.useCallback)(isImageStack => {
    if (isImageStack) {
      return activeDisplaySet.images[instanceNumber - 1];
    }
    return activeDisplaySet.instance || activeDisplaySet;
  }, [activeDisplaySet, instanceNumber]);
  const rows = (0,react.useMemo)(() => {
    console.log('DicomTagRedactor: Generating rows...');
    console.log('Active display set:', activeDisplaySet);
    if (!activeDisplaySet) {
      console.log('No active display set, returning empty rows');
      return [];
    }
    const isImageStack = activeDisplaySet instanceof ImageSet;
    console.log('Is image stack:', isImageStack);
    const metadata = getMetadata(isImageStack);
    console.log('Metadata for rows:', metadata);
    setShouldShowInstanceList(isImageStack && activeDisplaySet.images.length > 1);
    const tags = getSortedTags(metadata);
    console.log('Sorted tags:', tags);
    const rows = getFormattedRowsFromTags({
      tags,
      metadata
    });
    console.log('Generated rows:', rows.length, rows);
    return rows;
  }, [getMetadata, activeDisplaySet]);
  const filteredRows = (0,react.useMemo)(() => {
    if (!filterValue) {
      return rows;
    }
    const matchedRowIds = new Set();
    const propertiesToCheck = ['tag', 'valueRepresentation', 'keyword', 'value'];
    const setIsMatched = row => {
      const isDirectMatch = propertiesToCheck.some(propertyName => row[propertyName]?.toLowerCase().includes(filterValueLowerCase));
      if (!isDirectMatch) {
        return;
      }
      matchedRowIds.add(row.uid);
      [...(row.parents ?? []), ...(row.children ?? [])].forEach(uid => matchedRowIds.add(uid));
    };
    const filterValueLowerCase = filterValue.toLowerCase();
    rows.forEach(setIsMatched);
    return rows.filter(row => matchedRowIds.has(row.uid));
  }, [rows, filterValue]);
  const handleApplyRedactions = (0,react.useCallback)(redactions => {
    onApplyRedactions(redactions, displaySetInstanceUID, instanceNumber);
  }, [onApplyRedactions, displaySetInstanceUID, instanceNumber]);
  const handleShortcutClick = (0,react.useCallback)(shortcut => {
    console.log('Shortcut clicked:', shortcut.getName());
    const newRedactions = [];

    // Process each tag in the shortcut
    shortcut.getTags().forEach(tagConfig => {
      // Find the matching row in current rows
      const matchingRow = rows.find(row => row.tag === tagConfig.tag || row.keyword === tagConfig.keyword);
      if (matchingRow) {
        const processedResult = shortcut.processTag(tagConfig, matchingRow.value);
        newRedactions.push({
          tag: matchingRow.tag,
          keyword: matchingRow.keyword,
          action: processedResult.action,
          value: processedResult.value
        });
      }
    });
    console.log('Applying shortcut redactions:', newRedactions);
    setShortcutRedactions(newRedactions);
  }, [rows]);
  const handleAIRedact = (0,react.useCallback)(async () => {
    setIsAIRedacting(true);
    try {
      // Get configuration from window.config
      const getConfig = () => {
        return window.config || {};
      };
      const config = getConfig();
      const dataSource = config.dataSources?.find(ds => ds.sourceName === 'databricksPixelsDicom');
      const serverHostname = dataSource?.configuration?.serverHostname || 'http://localhost:8010';
      const apiEndpoint = `${serverHostname.replace("/sqlwarehouse", "")}/redaction/ai_redaction`;

      // Prepare metadata payload
      const metadata = rows.map(row => ({
        tag: row.tag,
        keyword: row.keyword,
        vr: row.valueRepresentation,
        value: row.value
      }));
      console.log('Calling AI redaction endpoint:', apiEndpoint);
      const response = await fetch(apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          metadata
        })
      });
      if (!response.ok) {
        throw new Error(`AI redaction failed: ${response.statusText}`);
      }
      const result = await response.json();

      // Process the AI response - expecting {summary: string, tags: [{tag, action, value}]}
      const aiRedactions = [];
      if (result && result.summary) {
        console.log('AI Redaction Summary:', result.summary);
      }
      if (result && Array.isArray(result.tags)) {
        result.tags.forEach(aiTag => {
          const matchingRow = rows.find(row => row.tag === aiTag.tag);
          if (matchingRow) {
            aiRedactions.push({
              tag: matchingRow.tag,
              keyword: matchingRow.keyword,
              action: aiTag.action,
              value: aiTag.value !== undefined ? aiTag.value : matchingRow.value
            });
          }
        });
      }
      setShortcutRedactions(aiRedactions);
    } catch (error) {
      console.error('Error calling AI redaction:', error);
      alert(`AI Redaction failed: ${error.message}`);
    } finally {
      setIsAIRedacting(false);
    }
  }, [rows]);
  return /*#__PURE__*/react.createElement("div", {
    className: "dicom-tag-redactor-content"
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flexShrink: 0
    }
  }, /*#__PURE__*/react.createElement(components_MetadataShortcuts, {
    onShortcutClick: handleShortcutClick
  })), /*#__PURE__*/react.createElement("div", {
    className: "mb-6 flex flex-row items-start pl-1",
    style: {
      flexShrink: 0
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "flex w-full flex-row items-start gap-4"
  }, shouldShowInstanceList && /*#__PURE__*/react.createElement("div", {
    className: "mx-auto mt-0.5 flex w-1/4 flex-col"
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-muted-foreground flex h-6 items-center pb-2 text-base"
  }, "Instance Number (", instanceNumber, " of ", activeDisplaySet?.images?.length, ")"), /*#__PURE__*/react.createElement(ui_next_src/* Slider */.Apm, {
    value: [instanceNumber],
    onValueChange: ([value]) => {
      setInstanceNumber(value);
    },
    min: 1,
    max: activeDisplaySet?.images?.length,
    step: 1,
    className: "pt-4"
  })), /*#__PURE__*/react.createElement("div", {
    className: "flex flex-row gap-2"
  }, /*#__PURE__*/react.createElement("button", {
    onClick: () => setShowOnlySelected(!showOnlySelected),
    style: {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginTop: '20px'
    },
    className: `px-4 py-2 rounded text-sm font-medium transition-colors ${showOnlySelected ? 'bg-primary text-white' : 'bg-secondary border border-primary text-white hover:bg-primary'}`
  }, showOnlySelected ? ' Showing Selected Only' : 'Show Selected Only'), /*#__PURE__*/react.createElement("button", {
    onClick: () => setClearAllTrigger(prev => prev + 1),
    style: {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginTop: '20px'
    },
    className: "px-4 py-2 rounded text-sm font-medium transition-colors border border-red-500 clear-all-action"
  }, "Clear All Actions"), /*#__PURE__*/react.createElement("button", {
    onClick: handleAIRedact,
    disabled: isAIRedacting,
    style: {
      marginLeft: 'auto',
      marginRight: 'auto',
      marginTop: '20px'
    },
    className: `px-4 py-2 rounded text-sm font-medium transition-colors ai-redact-btn ${isAIRedacting ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-secondary border border-green-500 text-white hover:bg-green-600'}`
  }, isAIRedacting ? 'AI Processing...' : 'AI Redact')), /*#__PURE__*/react.createElement("div", {
    className: "ml-auto mr-1 flex w-1/3 flex-col"
  }, /*#__PURE__*/react.createElement("span", {
    className: "text-muted-foreground flex h-6 items-center pb-2 text-base"
  }, "Search metadata"), /*#__PURE__*/react.createElement(ui_next_src/* InputFilter */.zbB, {
    className: "text-muted-foreground",
    onChange: setFilterValue
  }, /*#__PURE__*/react.createElement(ui_next_src/* InputFilter */.zbB.SearchIcon, null), /*#__PURE__*/react.createElement(ui_next_src/* InputFilter */.zbB.Input, {
    placeholder: "Search metadata",
    className: "pl-9 pr-9"
  }), /*#__PURE__*/react.createElement(ui_next_src/* InputFilter */.zbB.ClearButton, {
    className: "text-primary mr-0.5 p-0.5"
  }))))), /*#__PURE__*/react.createElement("div", {
    style: {
      flex: 1,
      minHeight: 0,
      overflow: 'hidden'
    }
  }, /*#__PURE__*/react.createElement(components_DicomTagRedactorTable, {
    rows: filteredRows,
    onApplyRedactions: handleApplyRedactions,
    showOnlySelected: showOnlySelected,
    existingRedactions: existingRedactions,
    shortcutRedactions: shortcutRedactions,
    clearAllTrigger: clearAllTrigger
  })));
};
function getFormattedRowsFromTags({
  tags,
  metadata
}) {
  const rows = [];
  const stack = [{
    tags,
    depth: 0,
    parents: null,
    index: 0,
    children: []
  }];
  const parentChildMap = new Map();
  while (stack.length > 0) {
    const current = stack.pop();
    const {
      tags,
      depth,
      parents,
      index,
      children
    } = current;
    for (let i = index; i < tags.length; i++) {
      const tagInfo = tags[i];
      const uid = tagInfo.uid ?? generateRowId();
      if (parents?.length > 0) {
        parents.forEach(parent => {
          parentChildMap.get(parent).push(uid);
        });
      }
      if (tagInfo.vr === 'SQ') {
        const row = {
          uid,
          tag: tagInfo.tag,
          valueRepresentation: tagInfo.vr,
          keyword: tagInfo.keyword,
          value: '',
          depth,
          isVisible: true,
          areChildrenVisible: true,
          children: [],
          parents: parents || undefined
        };
        rows.push(row);
        parentChildMap.set(uid, row.children);
        const newParents = parents ? [...parents, uid] : [uid];
        if (tagInfo.values.length > 0) {
          stack.push({
            tags,
            depth,
            parents,
            index: i + 1,
            children
          });
          for (let j = tagInfo.values.length - 1, values = tagInfo.values[j]; j >= 0; values = tagInfo.values[--j]) {
            const itemUid = generateRowId();
            stack.push({
              tags: values,
              depth: depth + 2,
              parents: [...newParents, itemUid],
              index: 0,
              children: []
            });
            const itemTagInfo = {
              tags: [{
                tag: '(FFFE,E000)',
                vr: '',
                keyword: `Item #${j}`,
                value: '',
                uid: itemUid
              }],
              depth: depth + 1,
              parents: newParents,
              index: 0,
              children: []
            };
            stack.push(itemTagInfo);
            parentChildMap.set(itemUid, itemTagInfo.children);
          }
          break;
        }
      } else {
        if (tagInfo.vr === 'xs') {
          try {
            const tag = dcmjs_es/* default.data */.Ay.data.Tag.fromPString(tagInfo.tag).toCleanString();
            const originalTagInfo = metadata[tag];
            tagInfo.vr = originalTagInfo.vr;
          } catch (error) {
            console.warn(`Failed to parse value representation for tag '${tagInfo.keyword}'`);
          }
        }
        const row = {
          uid,
          tag: tagInfo.tag,
          valueRepresentation: tagInfo.vr,
          keyword: tagInfo.keyword,
          value: tagInfo.value,
          depth,
          isVisible: true,
          parents: parents || undefined
        };
        rows.push(row);
        if (row.tag === '(FFFE,E000)') {
          row.areChildrenVisible = true;
          row.children = [];
        }
      }
    }
  }
  return rows;
}
function getSortedTags(metadata) {
  const tagList = getRows(metadata);

  // Sort top level tags, sequence groups are sorted when created.
  _sortTagList(tagList);
  return tagList;
}
function getRows(metadata, depth = 0) {
  // Tag, Type, Value, Keyword

  const keywords = Object.keys(metadata);
  const rows = [];
  for (let i = 0; i < keywords.length; i++) {
    let keyword = keywords[i];
    if (keyword === '_vrMap') {
      continue;
    }
    const tagInfo = nameMap[keyword];
    let value = metadata[keyword];
    if (tagInfo && tagInfo.vr === 'SQ') {
      const sequenceAsArray = toArray(value);

      // Push line defining the sequence

      const sequence = {
        tag: tagInfo.tag,
        vr: tagInfo.vr,
        keyword,
        values: []
      };
      rows.push(sequence);
      if (value === null) {
        // Type 2 Sequence
        continue;
      }
      sequenceAsArray.forEach(item => {
        const sequenceRows = getRows(item, depth + 1);
        if (sequenceRows.length) {
          // Sort the sequence group.
          _sortTagList(sequenceRows);
          sequence.values.push(sequenceRows);
        }
      });
      continue;
    }
    if (Array.isArray(value)) {
      if (value.length > 0 && typeof value[0] != 'object') {
        value = value.join('\\');
      }
    }
    if (typeof value === 'number') {
      value = value.toString();
    }
    if (typeof value !== 'string') {
      if (value === null) {
        value = ' ';
      } else {
        if (typeof value === 'object') {
          if (value.InlineBinary) {
            value = 'Inline Binary';
          } else if (value.BulkDataURI) {
            value = `Bulk Data URI`; //: ${value.BulkDataURI}`;
          } else if (value.Alphabetic) {
            value = value.Alphabetic;
          } else {
            console.warn(`Unrecognised Value: ${value} for ${keyword}:`);
            console.warn(value);
            value = ' ';
          }
        } else {
          console.warn(`Unrecognised Value: ${value} for ${keyword}:`);
          value = ' ';
        }
      }
    }

    // tag / vr/ keyword/ value

    // Remove retired tags
    keyword = keyword.replace('RETIRED_', '');
    if (tagInfo) {
      rows.push({
        tag: tagInfo.tag,
        vr: tagInfo.vr,
        keyword,
        value
      });
    } else {
      // skip properties without hex tag numbers
      const regex = /[0-9A-Fa-f]{6}/g;
      if (keyword.match(regex)) {
        const tag = `(${keyword.substring(0, 4)},${keyword.substring(4, 8)})`;
        rows.push({
          tag,
          vr: '',
          keyword: 'Private Tag',
          value
        });
      }
    }
  }
  return rows;
}
function toArray(objectOrArray) {
  return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
}
function _sortTagList(tagList) {
  tagList.sort((a, b) => {
    if (a.tag < b.tag) {
      return -1;
    }
    return 1;
  });
}
/* harmony default export */ const components_DicomTagRedactor = (DicomTagRedactor);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/components/DicomTagRedactorModal.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/





const DicomTagRedactorModal = ({
  servicesManager,
  onClose
}) => {
  const [displaySets, setDisplaySets] = (0,react.useState)([]);
  const [currentDisplaySetInstanceUID, setCurrentDisplaySetInstanceUID] = (0,react.useState)('');
  const [currentSeriesInstanceUID, setCurrentSeriesInstanceUID] = (0,react.useState)('');
  const {
    viewportGridService,
    cornerstoneViewportService,
    displaySetService
  } = servicesManager.services;
  (0,react.useEffect)(() => {
    console.log('DicomTagRedactorModal: Loading display sets...');

    // Get active display sets when modal opens
    const {
      activeViewportId
    } = viewportGridService.getState();
    console.log('Active viewport ID:', activeViewportId);
    const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
    console.log('Viewport:', viewport);
    if (viewport) {
      // Get current imageId to find the display set
      const imageId = viewport.getCurrentImageId();
      console.log('Image ID:', imageId);
      if (imageId) {
        const metadata = esm.metaData.get('instance', imageId);
        console.log('Metadata:', metadata);
        if (metadata) {
          const seriesInstanceUID = metadata.SeriesInstanceUID;
          console.log('Series Instance UID:', seriesInstanceUID);

          // Get all display sets from the displaySetService
          const allDisplaySets = displaySetService.getActiveDisplaySets();
          console.log('All display sets:', allDisplaySets);

          // Find the current display set (only for the current series)
          const currentDisplaySet = allDisplaySets.find(ds => ds.SeriesInstanceUID === seriesInstanceUID);
          console.log('Current display set:', currentDisplaySet);
          if (currentDisplaySet) {
            // Only pass the current display set (not all study display sets)
            setDisplaySets([currentDisplaySet]);
            setCurrentDisplaySetInstanceUID(currentDisplaySet.displaySetInstanceUID);
            setCurrentSeriesInstanceUID(seriesInstanceUID);
            console.log('Set current display set UID:', currentDisplaySet.displaySetInstanceUID);
            console.log('Set current series UID:', seriesInstanceUID);
          }
        }
      }
    }
  }, [viewportGridService, cornerstoneViewportService, displaySetService]);
  const handleApplyRedactions = (redactions, selectedDisplaySetInstanceUID, instanceNumber) => {
    // Find the series instance UID for the selected display set
    const selectedDisplaySet = displaySets.find(ds => ds.displaySetInstanceUID === selectedDisplaySetInstanceUID);
    if (!selectedDisplaySet) {
      alert('Error: Could not find selected display set');
      return;
    }
    const seriesInstanceUID = selectedDisplaySet.SeriesInstanceUID;

    // Store the tag redactions in the RedactionService (global for entire series)
    const result = services_RedactionService.storeMetadataRedactions(seriesInstanceUID, instanceNumber, redactions);
    if (result.success) {
      // Get stats for display
      const stats = services_RedactionService.getMetadataRedactionStats();
      console.log(`Successfully stored ${result.count} metadata redaction(s) for series ${seriesInstanceUID}`);
      console.log('Current metadata redaction stats:', stats);

      // Close the modal after successful save
      if (onClose) {
        onClose();
      }
    } else {
      console.error('Error storing metadata redactions');
      alert('Error storing metadata redactions');
    }
  };
  if (!displaySets.length || !currentDisplaySetInstanceUID) {
    return /*#__PURE__*/react.createElement("div", {
      style: {
        padding: '40px',
        textAlign: 'center',
        minHeight: '400px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }
    }, /*#__PURE__*/react.createElement("p", {
      style: {
        fontSize: '18px',
        color: '#888'
      }
    }, "Loading DICOM metadata..."));
  }
  return /*#__PURE__*/react.createElement("div", {
    style: {
      width: '100%',
      height: '100%',
      display: 'flex',
      flexDirection: 'column',
      overflow: 'hidden'
    }
  }, /*#__PURE__*/react.createElement(components_DicomTagRedactor, {
    displaySets: displaySets,
    displaySetInstanceUID: currentDisplaySetInstanceUID,
    seriesInstanceUID: currentSeriesInstanceUID,
    onApplyRedactions: handleApplyRedactions
  }));
};
/* harmony default export */ const components_DicomTagRedactorModal = (DicomTagRedactorModal);
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/getCommandsModule.ts
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/



function getCommandsModule({
  servicesManager
}) {
  const {
    viewportGridService,
    cornerstoneViewportService,
    uiModalService
  } = servicesManager.services;
  const actions = {
    activateRedactionTool: () => {
      const {
        activeViewportId
      } = viewportGridService.getState();
      const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
      if (viewport) {
        const toolGroupId = viewport.viewportOptions?.toolGroupId || 'default';
        servicesManager.services.toolGroupService.setToolActive(toolGroupId, 'RedactionRectangle', {
          bindings: [{
            mouseButton: 1
          }]
        });
      }
    },
    deactivateRedactionTool: () => {
      const {
        activeViewportId
      } = viewportGridService.getState();
      const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
      if (viewport) {
        const toolGroupId = viewport.viewportOptions?.toolGroupId || 'default';
        servicesManager.services.toolGroupService.setToolPassive(toolGroupId, 'RedactionRectangle');
      }
    },
    applyRedaction: async ({
      redaction_metadata,
      serverHostname
    }) => {
      if (!redaction_metadata || !serverHostname) {
        return {
          success: false,
          error: 'Missing required parameters'
        };
      }
      return await services_RedactionService.applyRedaction(redaction_metadata, serverHostname);
    },
    clearRedactionAreas: () => {
      const {
        activeViewportId
      } = viewportGridService.getState();
      const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
      if (viewport && viewport.element) {
        services_RedactionService.clearRedactionAreas(activeViewportId, viewport.element);
      }
    },
    exportRedactedImage: async () => {
      const {
        activeViewportId
      } = viewportGridService.getState();
      const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
      if (viewport) {
        return await services_RedactionService.exportRedactedImage(activeViewportId, viewport);
      }
      return {
        success: false,
        error: 'No active viewport found'
      };
    },
    openTagRedactor: () => {
      if (uiModalService) {
        uiModalService.show({
          content: components_DicomTagRedactorModal,
          title: 'DICOM Tag Redaction',
          contentProps: {
            servicesManager,
            onClose: () => {
              uiModalService.hide();
            }
          },
          shouldCloseOnEsc: true,
          shouldCloseOnOverlayClick: false,
          containerClassName: 'max-width-tag-redactor'
        });
      }
    },
    closeTagRedactor: () => {
      if (uiModalService) {
        uiModalService.hide();
      }
    },
    exportCombinedRedactionMetadata: async () => {
      const {
        activeViewportId
      } = viewportGridService.getState();
      const viewport = cornerstoneViewportService.getCornerstoneViewport(activeViewportId);
      if (viewport) {
        return await services_RedactionService.exportCombinedRedactionMetadata(activeViewportId, viewport);
      }
      return {
        success: false,
        error: 'No active viewport found'
      };
    },
    getMetadataRedactionStats: () => {
      return services_RedactionService.getMetadataRedactionStats();
    }
  };
  const definitions = {
    activateRedactionTool: {
      commandFn: actions.activateRedactionTool,
      storeContexts: [],
      options: {}
    },
    deactivateRedactionTool: {
      commandFn: actions.deactivateRedactionTool,
      storeContexts: [],
      options: {}
    },
    applyRedaction: {
      commandFn: actions.applyRedaction,
      storeContexts: [],
      options: {}
    },
    clearRedactionAreas: {
      commandFn: actions.clearRedactionAreas,
      storeContexts: [],
      options: {}
    },
    exportRedactedImage: {
      commandFn: actions.exportRedactedImage,
      storeContexts: [],
      options: {}
    },
    openTagRedactor: {
      commandFn: actions.openTagRedactor,
      storeContexts: [],
      options: {}
    },
    closeTagRedactor: {
      commandFn: actions.closeTagRedactor,
      storeContexts: [],
      options: {}
    },
    exportCombinedRedactionMetadata: {
      commandFn: actions.exportCombinedRedactionMetadata,
      storeContexts: [],
      options: {}
    },
    getMetadataRedactionStats: {
      commandFn: actions.getMetadataRedactionStats,
      storeContexts: [],
      options: {}
    }
  };
  return {
    actions,
    definitions,
    defaultContext: 'ACTIVE_VIEWPORT::CORNERSTONE'
  };
}
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/init.ts
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/




/**
 * @param {object} configuration
 */
function init({
  servicesManager,
  configuration = {}
}) {
  (0,dist_esm.addTool)(RedactionRectangleTool);
}
;// ../../../../../../../plugins/ohifv3/extensions/image-redactor/src/index.tsx
/*
OHIF Image Redactor Extension Copyright (2025) Databricks, Inc.
Author: Emanuele Rinaldi <emanuele.rinaldi@databricks.com>

This library (the "Software") may not be used except in connection with the Licensee's use of the Databricks Platform Services pursuant to an Agreement (defined below) between Licensee (defined below) and Databricks, Inc. ("Databricks"). The Object Code version of the Software shall be deemed part of the Downloadable Services under the Agreement, or if the Agreement does not define Downloadable Services, Subscription Services, or if neither are defined then the term in such Agreement that refers to the applicable Databricks Platform Services (as defined below) shall be substituted herein for "Downloadable Services." Licensee's use of the Software must comply at all times with any restrictions applicable to the Downlodable Services and Subscription Services, generally, and must be used in accordance with any applicable documentation. For the avoidance of doubt, the Software constitutes Databricks Confidential Information under the Agreement. Additionally, and notwithstanding anything in the Agreement to the contrary:
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* you may view, make limited copies of, and may compile the Source Code version of the Software into an Object Code version of the Software. For the avoidance of doubt, you may not make derivative works of Software (or make any any changes to the Source Code version of the unless you have agreed to separate terms with Databricks permitting such modifications (e.g., a contribution license agreement)).
If you have not agreed to an Agreement or otherwise do not agree to these terms, you may not use the Software or view, copy or compile the Source Code of the Software. This license terminates automatically upon the termination of the Agreement or Licensee's breach of these terms. Additionally, Databricks may terminate this license at any time on notice. Upon termination, you must permanently delete the Software and all copies thereof (including the Source Code).
*/





/* harmony default export */ const image_redactor_src = ({
  id: id,
  preRegistration: init,
  getPanelModule: src_getPanelModule,
  getCommandsModule: getCommandsModule
});

/***/ })

}]);