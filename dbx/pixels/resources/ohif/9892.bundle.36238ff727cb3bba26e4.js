(globalThis["webpackChunk"] = globalThis["webpackChunk"] || []).push([[9892,5400],{

/***/ 5057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rendering_now__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53586);
/* harmony import */ var _rendering_renderColorImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48080);
/* harmony import */ var _rendering_renderGrayscaleImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92885);
/* harmony import */ var _rendering_renderPseudoColorImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71209);




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, invalidated) {
    const image = enabledElement.image;
    if (!enabledElement.canvas || !enabledElement.image) {
        return;
    }
    const start = (0,_rendering_now__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)();
    image.stats = {
        lastGetPixelDataTime: -1.0,
        lastStoredPixelDataToCanvasImageDataTime: -1.0,
        lastPutImageDataTime: -1.0,
        lastRenderTime: -1.0,
        lastLutGenerateTime: -1.0,
    };
    if (image) {
        let render = image.render;
        if (!render) {
            if (enabledElement.viewport.colormap) {
                render = _rendering_renderPseudoColorImage__WEBPACK_IMPORTED_MODULE_3__/* .renderPseudoColorImage */ .l;
            }
            else if (image.color) {
                render = _rendering_renderColorImage__WEBPACK_IMPORTED_MODULE_1__/* .renderColorImage */ .f;
            }
            else {
                render = _rendering_renderGrayscaleImage__WEBPACK_IMPORTED_MODULE_2__/* .renderGrayscaleImage */ .j;
            }
        }
        render(enabledElement, invalidated);
    }
    const renderTimeInMs = (0,_rendering_now__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)() - start;
    image.stats.lastRenderTime = renderTimeInMs;
    enabledElement.invalid = false;
    enabledElement.needsRedraw = false;
}


/***/ }),

/***/ 7808:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45354);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, scale) {
    const transform = new _transform__WEBPACK_IMPORTED_MODULE_0__/* .Transform */ .d();
    if (!enabledElement.viewport.displayedArea) {
        return transform;
    }
    transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);
    const angle = enabledElement.viewport.rotation;
    if (angle !== 0) {
        transform.rotate((angle * Math.PI) / 180);
    }
    let widthScale = enabledElement.viewport.scale;
    let heightScale = enabledElement.viewport.scale;
    const width = enabledElement.viewport.displayedArea.brhc.x -
        (enabledElement.viewport.displayedArea.tlhc.x - 1);
    const height = enabledElement.viewport.displayedArea.brhc.y -
        (enabledElement.viewport.displayedArea.tlhc.y - 1);
    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {
        if (enabledElement.image.rowPixelSpacing <
            enabledElement.image.columnPixelSpacing) {
            widthScale *=
                enabledElement.image.columnPixelSpacing /
                    enabledElement.image.rowPixelSpacing;
        }
        else if (enabledElement.image.columnPixelSpacing <
            enabledElement.image.rowPixelSpacing) {
            heightScale *=
                enabledElement.image.rowPixelSpacing /
                    enabledElement.image.columnPixelSpacing;
        }
    }
    else {
        widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;
        heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;
        if (enabledElement.viewport.displayedArea.presentationSizeMode ===
            'SCALE TO FIT') {
            const verticalScale = enabledElement.canvas.height / (height * heightScale);
            const horizontalScale = enabledElement.canvas.width / (width * widthScale);
            widthScale = heightScale = Math.min(horizontalScale, verticalScale);
            if (enabledElement.viewport.displayedArea.rowPixelSpacing <
                enabledElement.viewport.displayedArea.columnPixelSpacing) {
                widthScale *=
                    enabledElement.viewport.displayedArea.columnPixelSpacing /
                        enabledElement.viewport.displayedArea.rowPixelSpacing;
            }
            else if (enabledElement.viewport.displayedArea.columnPixelSpacing <
                enabledElement.viewport.displayedArea.rowPixelSpacing) {
                heightScale *=
                    enabledElement.viewport.displayedArea.rowPixelSpacing /
                        enabledElement.viewport.displayedArea.columnPixelSpacing;
            }
        }
    }
    transform.scale(widthScale, heightScale);
    if (angle !== 0) {
        transform.rotate((-angle * Math.PI) / 180);
    }
    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);
    if (angle !== 0) {
        transform.rotate((angle * Math.PI) / 180);
    }
    if (scale !== undefined) {
        transform.scale(scale, scale);
    }
    if (enabledElement.viewport.hflip) {
        transform.scale(-1, 1);
    }
    if (enabledElement.viewport.vflip) {
        transform.scale(1, -1);
    }
    transform.translate(-width / 2, -height / 2);
    return transform;
}


/***/ }),

/***/ 36931:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12132);
/* harmony import */ var _getImageFitScale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57162);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(canvas, image, modality, colormap) {
    if (canvas === undefined) {
        throw new Error('getDefaultViewport: parameter canvas must not be undefined');
    }
    if (image === undefined) {
        return (0,_createViewport__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)();
    }
    const scale = (0,_getImageFitScale__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(canvas, image, 0).scaleFactor;
    let voi;
    if (modality === 'PT' && image.isPreScaled) {
        voi = {
            windowWidth: 5,
            windowCenter: 2.5,
        };
    }
    else if (image.windowWidth !== undefined &&
        image.windowCenter !== undefined) {
        voi = {
            windowWidth: Array.isArray(image.windowWidth)
                ? image.windowWidth[0]
                : image.windowWidth,
            windowCenter: Array.isArray(image.windowCenter)
                ? image.windowCenter[0]
                : image.windowCenter,
        };
    }
    return {
        scale,
        translation: {
            x: 0,
            y: 0,
        },
        voi,
        invert: image.invert,
        pixelReplication: false,
        rotation: 0,
        hflip: false,
        vflip: false,
        modalityLUT: image.modalityLUT,
        modality,
        voiLUT: image.voiLUT,
        colormap: colormap !== undefined ? colormap : image.colormap,
        displayedArea: {
            tlhc: {
                x: 1,
                y: 1,
            },
            brhc: {
                x: image.columns,
                y: image.rows,
            },
            rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,
            columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,
            presentationSizeMode: 'NONE',
        },
    };
}


/***/ }),

/***/ 50584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   QV: () => (/* reexport safe */ _classes_ImageVolume__WEBPACK_IMPORTED_MODULE_1__.A)
/* harmony export */ });
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49038);
/* harmony import */ var _classes_ImageVolume__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86252);
/* harmony import */ var _classes_Surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90808);
/* harmony import */ var _classes_Mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29625);
/* harmony import */ var _classes_StreamingImageVolume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50180);
/* harmony import */ var _classes_StreamingDynamicImageVolume__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1271);









/***/ }),

/***/ 71851:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BlendModes: () => (/* reexport */ BlendModes/* default */.A),
  CalibrationTypes: () => (/* reexport */ CalibrationTypes/* default */.A),
  Events: () => (/* reexport */ Events/* default */.A),
  GenerateImageType: () => (/* reexport */ GenerateImageType),
  GeometryType: () => (/* reexport */ GeometryType/* default */.A),
  ImageQualityStatus: () => (/* reexport */ ImageQualityStatus/* default */.A),
  InterpolationType: () => (/* reexport */ InterpolationType/* default */.A),
  MeshType: () => (/* reexport */ MeshType/* default */.A),
  MetadataModules: () => (/* reexport */ MetadataModules/* default */.A),
  OrientationAxis: () => (/* reexport */ OrientationAxis/* default */.A),
  RenderingEngineModeEnum: () => (/* reexport */ RenderingEngineModeEnum/* default */.A),
  RequestType: () => (/* reexport */ RequestType/* default */.A),
  VOILUTFunctionType: () => (/* reexport */ VOILUTFunctionType/* default */.A),
  VideoEnums: () => (/* reexport */ VideoEnums),
  ViewportStatus: () => (/* reexport */ ViewportStatus/* default */.A),
  ViewportType: () => (/* reexport */ ViewportType/* default */.A)
});

// UNUSED EXPORTS: ContourType, DynamicOperatorType, VoxelManagerEnum

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events = __webpack_require__(32643);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/RequestType.js
var RequestType = __webpack_require__(43213);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportType.js
var ViewportType = __webpack_require__(41864);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/InterpolationType.js
var InterpolationType = __webpack_require__(29310);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/BlendModes.js
var BlendModes = __webpack_require__(63591);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/OrientationAxis.js
var OrientationAxis = __webpack_require__(18735);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/GeometryType.js
var GeometryType = __webpack_require__(91346);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ContourType.js
var ContourType = __webpack_require__(86066);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/MeshType.js
var MeshType = __webpack_require__(32731);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/VOILUTFunctionType.js
var VOILUTFunctionType = __webpack_require__(82501);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/DynamicOperatorType.js
var DynamicOperatorType = __webpack_require__(91369);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/CalibrationTypes.js
var CalibrationTypes = __webpack_require__(38059);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportStatus.js
var ViewportStatus = __webpack_require__(1814);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ImageQualityStatus.js
var ImageQualityStatus = __webpack_require__(77474);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/VideoEnums.js
var VideoEnums = __webpack_require__(13545);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/MetadataModules.js
var MetadataModules = __webpack_require__(69850);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js
var GenerateImageType;
(function (GenerateImageType) {
    GenerateImageType["SUM"] = "SUM";
    GenerateImageType["SUBTRACT"] = "SUBTRACT";
    GenerateImageType["AVERAGE"] = "AVERAGE";
})(GenerateImageType || (GenerateImageType = {}));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/VoxelManagerEnum.js
var VoxelManagerEnum = __webpack_require__(6796);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/RenderingEngineModeEnum.js
var RenderingEngineModeEnum = __webpack_require__(8128);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js






















/***/ }),

/***/ 15327:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BaseVolumeViewport: () => (/* reexport */ BaseVolumeViewport/* default */.A),
  CONSTANTS: () => (/* reexport */ constants),
  EPSILON: () => (/* reexport */ getOrCreateCanvas/* EPSILON */.p8),
  Enums: () => (/* reexport */ enums),
  ImageVolume: () => (/* reexport */ cache/* ImageVolume */.QV),
  Settings: () => (/* reexport */ Settings),
  StackViewport: () => (/* reexport */ StackViewport/* default */.A),
  VolumeViewport: () => (/* reexport */ VolumeViewport/* default */.A),
  addImageSlicesToViewports: () => (/* reexport */ helpers/* addImageSlicesToViewports */.ge),
  addVolumesToViewports: () => (/* reexport */ helpers/* addVolumesToViewports */.x),
  cache: () => (/* reexport */ cache_cache/* default */.Ay),
  convertMapperToNotSharedMapper: () => (/* reexport */ createVolumeMapper/* convertMapperToNotSharedMapper */.h),
  createVolumeActor: () => (/* reexport */ createVolumeActor/* default */.A),
  eventTarget: () => (/* reexport */ eventTarget/* default */.A),
  getConfiguration: () => (/* reexport */ init/* getConfiguration */.D0),
  getEnabledElement: () => (/* reexport */ getEnabledElement/* default */.Ay),
  getEnabledElementByIds: () => (/* reexport */ getEnabledElement/* getEnabledElementByIds */.b1),
  getEnabledElementByViewportId: () => (/* reexport */ getEnabledElement/* getEnabledElementByViewportId */.yj),
  getEnabledElements: () => (/* reexport */ getEnabledElement/* getEnabledElements */.zb),
  getRenderingEngine: () => (/* reexport */ getRenderingEngine/* getRenderingEngine */.lD),
  getRenderingEngines: () => (/* reexport */ getRenderingEngine/* getRenderingEngines */.qO),
  getWebWorkerManager: () => (/* reexport */ init/* getWebWorkerManager */.G_),
  imageLoadPoolManager: () => (/* reexport */ imageLoadPoolManager/* default */.A),
  imageLoader: () => (/* reexport */ imageLoader),
  metaData: () => (/* reexport */ metaData),
  triggerEvent: () => (/* reexport */ triggerEvent/* default */.A),
  utilities: () => (/* reexport */ utilities),
  volumeLoader: () => (/* reexport */ volumeLoader)
});

// UNUSED EXPORTS: BaseRenderingEngine, ContextPoolRenderingEngine, EVENTS, ProgressiveRetrieveImages, RenderingEngine, StreamingDynamicImageVolume, StreamingImageVolume, Surface, TiledRenderingEngine, VideoViewport, Viewport, VolumeViewport3D, WSIViewport, canRenderFloatTextures, cornerstoneMeshLoader, cornerstoneStreamingDynamicImageVolumeLoader, cornerstoneStreamingImageVolumeLoader, createCanvas, createViewportElement, createVolumeMapper, geometryLoader, getOrCreateCanvas, getShouldUseCPURendering, imageRetrievalPoolManager, init, isCornerstoneInitialized, peerImport, registerImageLoader, requestPoolManager, resetInitialization, resetUseCPURendering, setCanvasCreator, setConfiguration, setPreferSizeOverAccuracy, setUseCPURendering, setVolumesForViewports, version

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 4 modules
var constants = __webpack_require__(76491);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/index.js + 3 modules
var RenderingEngine = __webpack_require__(90340);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeActor.js + 2 modules
var createVolumeActor = __webpack_require__(61640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeMapper.js
var createVolumeMapper = __webpack_require__(92099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js + 1 modules
var VolumeViewport = __webpack_require__(94155);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport3D.js
var VolumeViewport3D = __webpack_require__(40893);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js + 1 modules
var BaseVolumeViewport = __webpack_require__(95205);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js + 14 modules
var StackViewport = __webpack_require__(79720);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js + 3 modules
var VideoViewport = __webpack_require__(32501);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js + 1 modules
var WSIViewport = __webpack_require__(81466);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/version.js
var version = __webpack_require__(78337);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
var getRenderingEngine = __webpack_require__(39536);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/index.js
var cache = __webpack_require__(50584);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache_cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageRetrievalPoolManager.js
var imageRetrievalPoolManager = __webpack_require__(91073);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/getEnabledElement.js
var getEnabledElement = __webpack_require__(86846);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 2 modules
var init = __webpack_require__(26896);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/Settings.js
const DEFAULT_SETTINGS = Symbol('DefaultSettings');
const RUNTIME_SETTINGS = Symbol('RuntimeSettings');
const OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');
const DICTIONARY = Symbol('Dictionary');
class Settings {
    constructor(base) {
        const dictionary = Object.create((base instanceof Settings && DICTIONARY in base
            ? base[DICTIONARY]
            : null));
        Object.seal(Object.defineProperty(this, DICTIONARY, {
            value: dictionary,
        }));
    }
    set(key, value) {
        return set(this[DICTIONARY], key, value, null);
    }
    get(key) {
        return get(this[DICTIONARY], key);
    }
    unset(key) {
        return unset(this[DICTIONARY], key + '');
    }
    forEach(callback) {
        iterate(this[DICTIONARY], callback);
    }
    extend() {
        return new Settings(this);
    }
    import(root) {
        if (isPlainObject(root)) {
            Object.keys(root).forEach((key) => {
                set(this[DICTIONARY], key, root[key], null);
            });
        }
    }
    dump() {
        const context = {};
        iterate(this[DICTIONARY], (key, value) => {
            if (typeof value !== 'undefined') {
                deepSet(context, key, value);
            }
        });
        return context;
    }
    static assert(subject) {
        return subject instanceof Settings
            ? subject
            : Settings.getRuntimeSettings();
    }
    static getDefaultSettings(subfield = null) {
        let defaultSettings = Settings[DEFAULT_SETTINGS];
        if (!(defaultSettings instanceof Settings)) {
            defaultSettings = new Settings();
            Settings[DEFAULT_SETTINGS] = defaultSettings;
        }
        if (subfield) {
            const settingObj = {};
            defaultSettings.forEach((name) => {
                if (name.startsWith(subfield)) {
                    const setting = name.split(`${subfield}.`)[1];
                    settingObj[setting] = defaultSettings.get(name);
                }
            });
            return settingObj;
        }
        return defaultSettings;
    }
    static getRuntimeSettings() {
        let runtimeSettings = Settings[RUNTIME_SETTINGS];
        if (!(runtimeSettings instanceof Settings)) {
            runtimeSettings = new Settings(Settings.getDefaultSettings());
            Settings[RUNTIME_SETTINGS] = runtimeSettings;
        }
        return runtimeSettings;
    }
    static getObjectSettings(subject, from) {
        let settings = null;
        if (subject instanceof Settings) {
            settings = subject;
        }
        else if (typeof subject === 'object' && subject !== null) {
            let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];
            if (!(objectSettingsMap instanceof WeakMap)) {
                objectSettingsMap = new WeakMap();
                Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;
            }
            settings = objectSettingsMap.get(subject);
            if (!(settings instanceof Settings)) {
                settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));
                objectSettingsMap.set(subject, settings);
            }
        }
        return settings;
    }
    static extendRuntimeSettings() {
        return Settings.getRuntimeSettings().extend();
    }
}
function unset(dictionary, name) {
    if (name.endsWith('.')) {
        let deleteCount = 0;
        const namespace = name;
        const base = namespace.slice(0, -1);
        const deleteAll = base.length === 0;
        for (const key in dictionary) {
            if (Object.prototype.hasOwnProperty.call(dictionary, key) &&
                (deleteAll || key.startsWith(namespace) || key === base)) {
                delete dictionary[key];
                ++deleteCount;
            }
        }
        return deleteCount > 0;
    }
    return delete dictionary[name];
}
function iterate(dictionary, callback) {
    for (const key in dictionary) {
        callback(key, dictionary[key]);
    }
}
function setAll(dictionary, prefix, record, references) {
    let failCount;
    if (references.has(record)) {
        return set(dictionary, prefix, null, references);
    }
    references.add(record);
    failCount = 0;
    for (const field in record) {
        if (Object.prototype.hasOwnProperty.call(record, field)) {
            const key = field.length === 0 ? prefix : `${prefix}.${field}`;
            if (!set(dictionary, key, record[field], references)) {
                ++failCount;
            }
        }
    }
    references.delete(record);
    return failCount === 0;
}
function set(dictionary, key, value, references) {
    if (isValidKey(key)) {
        if (isPlainObject(value)) {
            return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet());
        }
        dictionary[key] = value;
        return true;
    }
    return false;
}
function get(dictionary, key) {
    return dictionary[key];
}
function isValidKey(key) {
    let last, current, previous;
    if (typeof key !== 'string' || (last = key.length - 1) < 0) {
        return false;
    }
    previous = -1;
    while ((current = key.indexOf('.', previous + 1)) >= 0) {
        if (current - previous < 2 || current === last) {
            return false;
        }
        previous = current;
    }
    return true;
}
function isPlainObject(subject) {
    if (typeof subject === 'object' && subject !== null) {
        const prototype = Object.getPrototypeOf(subject);
        if (prototype === Object.prototype || prototype === null) {
            return true;
        }
    }
    return false;
}
function deepSet(context, key, value) {
    const separator = key.indexOf('.');
    if (separator >= 0) {
        const subKey = key.slice(0, separator);
        let subContext = context[subKey];
        if (typeof subContext !== 'object' || subContext === null) {
            const subContextValue = subContext;
            subContext = {};
            if (typeof subContextValue !== 'undefined') {
                subContext[''] = subContextValue;
            }
            context[subKey] = subContext;
        }
        deepSet(subContext, key.slice(separator + 1, key.length), value);
    }
    else {
        context[key] = value;
    }
}
Settings.getDefaultSettings().set('useCursors', true);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js + 10 modules
var volumeLoader = __webpack_require__(87142);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/geometryLoader.js + 26 modules
var geometryLoader = __webpack_require__(89926);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js + 4 modules
var ProgressiveRetrieveImages = __webpack_require__(36822);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js + 46 modules
var utilities = __webpack_require__(33592);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneStreamingImageVolumeLoader.js
var cornerstoneStreamingImageVolumeLoader = __webpack_require__(55500);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneStreamingDynamicImageVolumeLoader.js
var cornerstoneStreamingDynamicImageVolumeLoader = __webpack_require__(55509);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneMeshLoader.js
var cornerstoneMeshLoader = __webpack_require__(56074);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 3 modules
var helpers = __webpack_require__(40661);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/index.js







































/***/ }),

/***/ 80068:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cancelLoadAll: () => (/* binding */ cancelLoadAll),
/* harmony export */   cancelLoadImage: () => (/* binding */ cancelLoadImage),
/* harmony export */   cancelLoadImages: () => (/* binding */ cancelLoadImages),
/* harmony export */   createAndCacheDerivedImage: () => (/* binding */ createAndCacheDerivedImage),
/* harmony export */   createAndCacheDerivedImages: () => (/* binding */ createAndCacheDerivedImages),
/* harmony export */   createAndCacheDerivedLabelmapImage: () => (/* binding */ createAndCacheDerivedLabelmapImage),
/* harmony export */   createAndCacheDerivedLabelmapImages: () => (/* binding */ createAndCacheDerivedLabelmapImages),
/* harmony export */   createAndCacheLocalImage: () => (/* binding */ createAndCacheLocalImage),
/* harmony export */   loadAndCacheImage: () => (/* binding */ loadAndCacheImage),
/* harmony export */   loadAndCacheImages: () => (/* binding */ loadAndCacheImages),
/* harmony export */   loadImage: () => (/* binding */ loadImage),
/* harmony export */   registerImageLoader: () => (/* binding */ registerImageLoader),
/* harmony export */   registerUnknownImageLoader: () => (/* binding */ registerUnknownImageLoader),
/* harmony export */   unregisterAllImageLoaders: () => (/* binding */ unregisterAllImageLoaders)
/* harmony export */ });
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49038);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32643);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27119);
/* harmony import */ var _utilities_getBufferConfiguration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99576);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69372);
/* harmony import */ var _utilities_uuidv4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(80221);
/* harmony import */ var _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24623);
/* harmony import */ var _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(51159);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(74876);
/* harmony import */ var _enums_VoxelManagerEnum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6796);











const imageLoaders = {};
let unknownImageLoader;
function loadImageFromImageLoader(imageId, options) {
    const cachedImageLoadObject = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImageLoadObject(imageId);
    if (cachedImageLoadObject) {
        handleImageLoadPromise(cachedImageLoadObject.promise, imageId);
        return cachedImageLoadObject;
    }
    const scheme = imageId.split(':')[0];
    const loader = imageLoaders[scheme] || unknownImageLoader;
    if (!loader) {
        throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);
    }
    const imageLoadObject = loader(imageId, options);
    handleImageLoadPromise(imageLoadObject.promise, imageId);
    return imageLoadObject;
}
function handleImageLoadPromise(imagePromise, imageId) {
    Promise.resolve(imagePromise)
        .then((image) => {
        ensureVoxelManager(image);
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.IMAGE_LOADED, { image });
    })
        .catch((error) => {
        const errorDetails = {
            imageId,
            error,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.IMAGE_LOAD_FAILED, errorDetails);
    });
}
function ensureVoxelManager(image) {
    if (!image.voxelManager) {
        const { width, height, numberOfComponents } = image;
        const voxelManager = _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.createImageVoxelManager({
            scalarData: image.getPixelData(),
            width,
            height,
            numberOfComponents,
        });
        image.voxelManager = voxelManager;
        image.getPixelData = () => voxelManager.getScalarData();
        delete image.imageFrame.pixelData;
    }
}
function loadImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {
    if (imageId === undefined) {
        throw new Error('loadImage: parameter imageId must not be undefined');
    }
    return loadImageFromImageLoader(imageId, options).promise;
}
function loadAndCacheImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {
    if (imageId === undefined) {
        throw new Error('loadAndCacheImage: parameter imageId must not be undefined');
    }
    const imageLoadObject = loadImageFromImageLoader(imageId, options);
    if (!_cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImageLoadObject(imageId)) {
        _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.putImageLoadObject(imageId, imageLoadObject);
    }
    return imageLoadObject.promise;
}
function loadAndCacheImages(imageIds, options = { priority: 0, requestType: 'prefetch' }) {
    if (!imageIds || imageIds.length === 0) {
        throw new Error('loadAndCacheImages: parameter imageIds must be list of image Ids');
    }
    const allPromises = imageIds.map((imageId) => {
        return loadAndCacheImage(imageId, options);
    });
    return allPromises;
}
function createAndCacheDerivedImage(referencedImageId, options = {}) {
    if (referencedImageId === undefined) {
        throw new Error('createAndCacheDerivedImage: parameter imageId must not be undefined');
    }
    if (options.imageId === undefined) {
        options.imageId = `derived:${(0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)()}`;
    }
    const { imageId, skipCreateBuffer, onCacheAdd, voxelRepresentation } = options;
    const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_9__.get('imagePlaneModule', referencedImageId);
    const length = imagePlaneModule.rows * imagePlaneModule.columns;
    const { TypedArrayConstructor } = (0,_utilities_getBufferConfiguration__WEBPACK_IMPORTED_MODULE_4__/* .getBufferConfiguration */ .h)(options.targetBuffer?.type, length);
    const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length);
    const derivedImageId = imageId;
    const referencedImagePlaneMetadata = _metaData__WEBPACK_IMPORTED_MODULE_9__.get('imagePlaneModule', referencedImageId);
    _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.add(derivedImageId, {
        type: 'imagePlaneModule',
        metadata: referencedImagePlaneMetadata,
    });
    const referencedImageGeneralSeriesMetadata = _metaData__WEBPACK_IMPORTED_MODULE_9__.get('generalSeriesModule', referencedImageId);
    _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.add(derivedImageId, {
        type: 'generalSeriesModule',
        metadata: referencedImageGeneralSeriesMetadata,
    });
    _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.add(derivedImageId, {
        type: 'generalImageModule',
        metadata: {
            instanceNumber: options.instanceNumber,
        },
    });
    const imagePixelModule = _metaData__WEBPACK_IMPORTED_MODULE_9__.get('imagePixelModule', referencedImageId);
    _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.add(derivedImageId, {
        type: 'imagePixelModule',
        metadata: {
            ...imagePixelModule,
            bitsAllocated: 8,
            bitsStored: 8,
            highBit: 7,
            samplesPerPixel: 1,
            pixelRepresentation: 0,
        },
    });
    const localImage = createAndCacheLocalImage(imageId, {
        scalarData: imageScalarData,
        onCacheAdd,
        skipCreateBuffer,
        targetBuffer: {
            type: imageScalarData.constructor.name,
        },
        voxelRepresentation,
        dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],
        spacing: [
            imagePlaneModule.columnPixelSpacing,
            imagePlaneModule.rowPixelSpacing,
        ],
        origin: imagePlaneModule.imagePositionPatient,
        direction: imagePlaneModule.imageOrientationPatient,
        frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,
        referencedImageId: referencedImageId,
    });
    localImage.referencedImageId = referencedImageId;
    if (!_cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImageLoadObject(imageId)) {
        _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.putImageSync(imageId, localImage);
    }
    return localImage;
}
function createAndCacheDerivedImages(referencedImageIds, options = {}) {
    if (referencedImageIds.length === 0) {
        throw new Error('createAndCacheDerivedImages: parameter imageIds must be list of image Ids');
    }
    const derivedImageIds = [];
    const images = referencedImageIds.map((referencedImageId, index) => {
        const newOptions = {
            imageId: options?.getDerivedImageId?.(referencedImageId) ||
                `derived:${(0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)()}`,
            ...options,
        };
        derivedImageIds.push(newOptions.imageId);
        return createAndCacheDerivedImage(referencedImageId, {
            ...newOptions,
            instanceNumber: index + 1,
        });
    });
    return images;
}
function createAndCacheLocalImage(imageId, options) {
    const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, voxelRepresentation, referencedImageId, } = options;
    const dimensions = options.dimensions;
    const spacing = options.spacing;
    if (!dimensions || !spacing) {
        throw new Error('createAndCacheLocalImage: dimensions and spacing are required');
    }
    const width = dimensions[0];
    const height = dimensions[1];
    const columnPixelSpacing = spacing[0];
    const rowPixelSpacing = spacing[1];
    const imagePlaneModule = {
        frameOfReferenceUID,
        rows: height,
        columns: width,
        imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],
        rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],
        columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],
        imagePositionPatient: origin ?? [0, 0, 0],
        pixelSpacing: [rowPixelSpacing, columnPixelSpacing],
        rowPixelSpacing: rowPixelSpacing,
        columnPixelSpacing: columnPixelSpacing,
    };
    const length = width * height;
    const numberOfComponents = scalarData.length / length;
    let scalarDataToUse;
    if (scalarData) {
        if (!(scalarData instanceof Uint8Array ||
            scalarData instanceof Float32Array ||
            scalarData instanceof Uint16Array ||
            scalarData instanceof Int16Array)) {
            throw new Error('createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array');
        }
        scalarDataToUse = scalarData;
    }
    else if (!skipCreateBuffer) {
        const { TypedArrayConstructor } = (0,_utilities_getBufferConfiguration__WEBPACK_IMPORTED_MODULE_4__/* .getBufferConfiguration */ .h)(targetBuffer?.type, length);
        const imageScalarData = new TypedArrayConstructor(length);
        scalarDataToUse = imageScalarData;
    }
    let bitsAllocated, bitsStored, highBit;
    if (scalarDataToUse instanceof Uint8Array) {
        bitsAllocated = 8;
        bitsStored = 8;
        highBit = 7;
    }
    else if (scalarDataToUse instanceof Uint16Array) {
        bitsAllocated = 16;
        bitsStored = 16;
        highBit = 15;
    }
    else if (scalarDataToUse instanceof Int16Array) {
        bitsAllocated = 16;
        bitsStored = 16;
        highBit = 15;
    }
    else if (scalarDataToUse instanceof Float32Array) {
        bitsAllocated = 32;
        bitsStored = 32;
        highBit = 31;
    }
    else {
        throw new Error('Unsupported scalarData type');
    }
    const imagePixelModule = {
        samplesPerPixel: 1,
        photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1]
            ? 'RGB'
            : 'MONOCHROME2',
        rows: height,
        columns: width,
        bitsAllocated,
        bitsStored,
        highBit,
    };
    const metadata = {
        imagePlaneModule,
        imagePixelModule,
    };
    ['imagePlaneModule', 'imagePixelModule'].forEach((type) => {
        _utilities_genericMetadataProvider__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.add(imageId, {
            type,
            metadata: metadata[type] || {},
        });
    });
    const id = imageId;
    const voxelManager = (voxelRepresentation === _enums_VoxelManagerEnum__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A.RLE &&
        _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.createRLEImageVoxelManager({ dimensions, id })) ||
        _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.createImageVoxelManager({
            height,
            width,
            numberOfComponents,
            scalarData: scalarDataToUse,
            id,
        });
    let minPixelValue = scalarDataToUse[0];
    let maxPixelValue = scalarDataToUse[0];
    for (let i = 1; i < scalarDataToUse.length; i++) {
        if (scalarDataToUse[i] < minPixelValue) {
            minPixelValue = scalarDataToUse[i];
        }
        if (scalarDataToUse[i] > maxPixelValue) {
            maxPixelValue = scalarDataToUse[i];
        }
    }
    const image = {
        imageId: imageId,
        intercept: 0,
        windowCenter: 0,
        windowWidth: 0,
        color: imagePixelModule.photometricInterpretation === 'RGB',
        numberOfComponents: imagePixelModule.samplesPerPixel,
        dataType: targetBuffer?.type,
        slope: 1,
        minPixelValue,
        maxPixelValue,
        rows: imagePixelModule.rows,
        columns: imagePixelModule.columns,
        getCanvas: undefined,
        height: imagePixelModule.rows,
        width: imagePixelModule.columns,
        rgba: undefined,
        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,
        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,
        FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,
        invert: false,
        getPixelData: () => voxelManager.getScalarData(),
        voxelManager,
        sizeInBytes: scalarData.byteLength,
        referencedImageId,
    };
    onCacheAdd?.(image);
    _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.putImageSync(image.imageId, image);
    return image;
}
function cancelLoadImage(imageId) {
    const filterFunction = ({ additionalDetails }) => {
        if (additionalDetails.imageId) {
            return additionalDetails.imageId !== imageId;
        }
        return true;
    };
    _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.filterRequests(filterFunction);
    const imageLoadObject = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImageLoadObject(imageId);
    if (imageLoadObject) {
        imageLoadObject.cancelFn();
    }
}
function cancelLoadImages(imageIds) {
    imageIds.forEach((imageId) => {
        cancelLoadImage(imageId);
    });
}
function cancelLoadAll() {
    const requestPool = _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.getRequestPool();
    Object.keys(requestPool).forEach((type) => {
        const requests = requestPool[type];
        Object.keys(requests).forEach((priority) => {
            const requestDetails = requests[priority].pop();
            if (!requestDetails) {
                return;
            }
            const additionalDetails = requestDetails.additionalDetails;
            const { imageId, volumeId } = additionalDetails;
            let loadObject;
            if (imageId) {
                loadObject = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImageLoadObject(imageId);
            }
            else if (volumeId) {
                loadObject = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getVolumeLoadObject(volumeId);
            }
            if (loadObject) {
                loadObject.cancel();
            }
        });
        _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.clearRequestStack(type);
    });
}
function registerImageLoader(scheme, imageLoader) {
    imageLoaders[scheme] = imageLoader;
}
function registerUnknownImageLoader(imageLoader) {
    const oldImageLoader = unknownImageLoader;
    unknownImageLoader = imageLoader;
    return oldImageLoader;
}
function unregisterAllImageLoaders() {
    Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);
    unknownImageLoader = undefined;
}
function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {
    return createAndCacheDerivedImages(referencedImageIds, {
        ...options,
        targetBuffer: { type: 'Uint8Array' },
    });
}
function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {
    return createAndCacheDerivedImage(referencedImageId, {
        ...options,
        targetBuffer: { type: 'Uint8Array' },
    });
}


/***/ }),

/***/ 56750:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ FrameRange)
/* harmony export */ });
class FrameRange {
    static { this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i; }
    static imageIdToFrames(imageId) {
        const match = imageId.match(this.frameRangeExtractor);
        if (!match || !match[2]) {
            return null;
        }
        const range = match[2].split('-').map((it) => Number(it));
        if (range.length === 1) {
            return range[0];
        }
        return range;
    }
    static imageIdToFrameEnd(imageId) {
        const range = this.imageIdToFrames(imageId);
        return Array.isArray(range) ? range[1] : range;
    }
    static imageIdToFrameStart(imageId) {
        const range = this.imageIdToFrames(imageId);
        return Array.isArray(range) ? range[0] : range;
    }
    static framesToString(range) {
        if (Array.isArray(range)) {
            return `${range[0]}-${range[1]}`;
        }
        return String(range);
    }
    static framesToImageId(imageId, range) {
        const match = imageId.match(this.frameRangeExtractor);
        if (!match || !match[2]) {
            return null;
        }
        const newRangeString = this.framesToString(range);
        return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);
    }
}


/***/ }),

/***/ 13876:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ PointsManager)
/* harmony export */ });
class PointsManager {
    constructor(configuration = {}) {
        this._dimensions = 3;
        this._length = 0;
        this._byteSize = 4;
        this.growSize = 128;
        const { initialSize = 1024, dimensions = 3, growSize = 128, } = configuration;
        const itemLength = initialSize * dimensions;
        this.growSize = growSize;
        this.array = new ArrayBuffer(itemLength * this._byteSize);
        this.data = new Float32Array(this.array);
        this._dimensions = dimensions;
    }
    forEach(func) {
        for (let i = 0; i < this._length; i++) {
            func(this.getPoint(i), i);
        }
    }
    get length() {
        return this._length;
    }
    get dimensions() {
        return this._dimensions;
    }
    get dimensionLength() {
        return this._length * this._dimensions;
    }
    getPoint(index) {
        if (index < 0) {
            index += this._length;
        }
        if (index < 0 || index >= this._length) {
            return;
        }
        const offset = this._dimensions * index;
        return this.data.subarray(offset, offset + this._dimensions);
    }
    getPointArray(index) {
        const array = [];
        if (index < 0) {
            index += this._length;
        }
        if (index < 0 || index >= this._length) {
            return;
        }
        const offset = this._dimensions * index;
        for (let i = 0; i < this._dimensions; i++) {
            array.push(this.data[i + offset]);
        }
        return array;
    }
    grow(additionalSize = 1, growSize = this.growSize) {
        if (this.dimensionLength + additionalSize * this._dimensions <=
            this.data.length) {
            return;
        }
        const newSize = this.data.length + growSize;
        const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);
        const newData = new Float32Array(newArray);
        newData.set(this.data);
        this.data = newData;
        this.array = newArray;
    }
    reverse() {
        const midLength = Math.floor(this._length / 2);
        for (let i = 0; i < midLength; i++) {
            const indexStart = i * this._dimensions;
            const indexEnd = (this._length - 1 - i) * this._dimensions;
            for (let dimension = 0; dimension < this._dimensions; dimension++) {
                const valueStart = this.data[indexStart + dimension];
                this.data[indexStart + dimension] = this.data[indexEnd + dimension];
                this.data[indexEnd + dimension] = valueStart;
            }
        }
    }
    getTypedArray() {
        return this.data;
    }
    push(point) {
        this.grow(1);
        const offset = this.length * this._dimensions;
        for (let i = 0; i < this._dimensions; i++) {
            this.data[i + offset] = point[i];
        }
        this._length++;
    }
    map(f) {
        const mapData = [];
        for (let i = 0; i < this._length; i++) {
            mapData.push(f(this.getPoint(i), i));
        }
        return mapData;
    }
    get points() {
        return this.map((p) => p);
    }
    toXYZ() {
        const xyz = { x: [], y: [] };
        if (this._dimensions >= 3) {
            xyz.z = [];
        }
        const { x, y, z } = xyz;
        this.forEach((p) => {
            x.push(p[0]);
            y.push(p[1]);
            if (z) {
                z.push(p[2]);
            }
        });
        return xyz;
    }
    static fromXYZ({ x, y, z }) {
        const array = PointsManager.create3(x.length);
        let offset = 0;
        for (let i = 0; i < x.length; i++) {
            array.data[offset++] = x[i];
            array.data[offset++] = y[i];
            array.data[offset++] = z ? z[i] : 0;
        }
        array._length = x.length;
        return array;
    }
    subselect(count = 10, offset = 0) {
        const selected = new PointsManager({
            initialSize: count,
            dimensions: this._dimensions,
        });
        for (let i = 0; i < count; i++) {
            const index = (offset + Math.floor((this.length * i) / count)) % this.length;
            selected.push(this.getPoint(index));
        }
        return selected;
    }
    static create3(initialSize = 128, points) {
        initialSize = Math.max(initialSize, points?.length || 0);
        const newPoints = new PointsManager({ initialSize, dimensions: 3 });
        if (points) {
            points.forEach((point) => newPoints.push(point));
        }
        return newPoints;
    }
    static create2(initialSize = 128) {
        return new PointsManager({ initialSize, dimensions: 2 });
    }
}


/***/ }),

/***/ 22191:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ProgressiveIterator)
/* harmony export */ });
/* unused harmony export PromiseIterator */
class PromiseIterator extends (/* unused pure expression or super */ null && (Promise)) {
}
class ProgressiveIterator {
    constructor(name) {
        this.name = name || 'unknown';
    }
    static as(promise) {
        if (promise.iterator) {
            return promise.iterator;
        }
        const iterator = new ProgressiveIterator('as iterator');
        promise.then((v) => {
            try {
                iterator.add(v, true);
            }
            catch (e) {
                iterator.reject(e);
            }
        }, (reason) => {
            iterator.reject(reason);
        });
        return iterator;
    }
    add(x, done = false) {
        this.nextValue = x;
        this.done ||= done;
        if (this.waiting) {
            this.waiting.resolve(x);
            this.waiting = undefined;
        }
    }
    resolve() {
        this.done = true;
        if (this.waiting) {
            this.waiting.resolve(this.nextValue);
            this.waiting = undefined;
        }
    }
    reject(reason) {
        this.rejectReason = reason;
        this.waiting?.reject(reason);
    }
    getRecent() {
        if (this.rejectReason) {
            throw this.rejectReason;
        }
        return this.nextValue;
    }
    async *[Symbol.asyncIterator]() {
        while (!this.done) {
            if (this.rejectReason) {
                throw this.rejectReason;
            }
            if (this.nextValue !== undefined) {
                yield this.nextValue;
                if (this.done) {
                    break;
                }
            }
            if (!this.waiting) {
                this.waiting = {};
                this.waiting.promise = new Promise((resolve, reject) => {
                    this.waiting.resolve = resolve;
                    this.waiting.reject = reject;
                });
            }
            await this.waiting.promise;
        }
        yield this.nextValue;
    }
    async forEach(callback, errorCallback) {
        let index = 0;
        try {
            for await (const value of this) {
                const { done } = this;
                try {
                    await callback(value, done, index);
                    index++;
                }
                catch (e) {
                    if (!done) {
                        console.warn('Caught exception in intermediate value', e);
                        continue;
                    }
                    if (errorCallback) {
                        errorCallback(e, done);
                    }
                    else {
                        throw e;
                    }
                }
            }
        }
        catch (e) {
            if (errorCallback) {
                errorCallback(e, true);
            }
            else {
                throw e;
            }
        }
    }
    generate(processFunction, errorCallback) {
        return processFunction(this, this.reject.bind(this)).then(() => {
            if (!this.done) {
                this.resolve();
            }
        }, (reason) => {
            this.reject(reason);
            if (errorCallback) {
                errorCallback(reason);
            }
            else {
                console.warn("Couldn't process because", reason);
            }
        });
    }
    async nextPromise() {
        for await (const i of this) {
            if (i) {
                return i;
            }
        }
        return this.nextValue;
    }
    async donePromise() {
        for await (const i of this) {
        }
        return this.nextValue;
    }
    getNextPromise() {
        const promise = this.nextPromise();
        promise.iterator = this;
        return promise;
    }
    getDonePromise() {
        const promise = this.donePromise();
        promise.iterator = this;
        return promise;
    }
}


/***/ }),

/***/ 67645:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ RLEVoxelMap)
/* harmony export */ });
const ADJACENT_ALL = [
    [0, -1, 0],
    [0, 1, 0],
    [0, 0, -1],
    [0, 0, 1],
];
const ADJACENT_SINGLE_PLANE = [
    [0, -1, 0],
    [0, 1, 0],
];
const ADJACENT_IN = [
    [0, -1, 0],
    [0, 1, 0],
    [0, 0, -1],
];
const ADJACENT_OUT = [
    [0, -1, 0],
    [0, 1, 0],
    [0, 0, 1],
];
class RLEVoxelMap {
    static copyMap(destination, source) {
        for (const [index, row] of source.rows) {
            destination.rows.set(index, structuredClone(row));
        }
    }
    constructor(width, height, depth = 1) {
        this.rows = new Map();
        this.height = 1;
        this.width = 1;
        this.depth = 1;
        this.jMultiple = 1;
        this.kMultiple = 1;
        this.numComps = 1;
        this.pixelDataConstructor = Uint8Array;
        this.updateScalarData = function (scalarData) {
            scalarData.fill(0);
            const callback = (index, rle, row) => {
                const { start, end, value } = rle;
                for (let i = start; i < end; i++) {
                    scalarData[index + i] = value;
                }
            };
            this.forEach(callback);
        };
        this.get = (index) => {
            const i = index % this.jMultiple;
            const j = (index - i) / this.jMultiple;
            const rle = this.getRLE(i, j);
            return rle?.value ?? this.defaultValue;
        };
        this.getRun = (j, k) => {
            const runIndex = j + k * this.height;
            return this.rows.get(runIndex);
        };
        this.set = (index, value) => {
            if (value === undefined) {
                return;
            }
            const i = index % this.width;
            const j = (index - i) / this.width;
            const row = this.rows.get(j);
            if (!row) {
                this.rows.set(j, [{ start: i, end: i + 1, value }]);
                return;
            }
            const rleIndex = this.findIndex(row, i);
            const rle1 = row[rleIndex];
            const rle0 = row[rleIndex - 1];
            if (!rle1) {
                if (!rle0 || rle0.value !== value || rle0.end !== i) {
                    row[rleIndex] = { start: i, end: i + 1, value };
                    return;
                }
                rle0.end++;
                return;
            }
            const { start, end, value: oldValue } = rle1;
            if (value === oldValue && i >= start) {
                return;
            }
            const rleInsert = { start: i, end: i + 1, value };
            const isAfter = i > start;
            const insertIndex = isAfter ? rleIndex + 1 : rleIndex;
            const rlePrev = isAfter ? rle1 : rle0;
            let rleNext = isAfter ? row[rleIndex + 1] : rle1;
            if (rlePrev?.value === value && rlePrev?.end === i) {
                rlePrev.end++;
                if (rleNext?.value === value && rleNext.start === i + 1) {
                    rlePrev.end = rleNext.end;
                    row.splice(rleIndex, 1);
                }
                else if (rleNext?.start === i) {
                    rleNext.start++;
                    if (rleNext.start === rleNext.end) {
                        row.splice(rleIndex, 1);
                        rleNext = row[rleIndex];
                        if (rleNext?.start === i + 1 && rleNext.value === value) {
                            rlePrev.end = rleNext.end;
                            row.splice(rleIndex, 1);
                        }
                    }
                }
                return;
            }
            if (rleNext?.value === value && rleNext.start === i + 1) {
                rleNext.start--;
                if (rlePrev?.end > i) {
                    rlePrev.end = i;
                    if (rlePrev.end === rlePrev.start) {
                        row.splice(rleIndex, 1);
                    }
                }
                return;
            }
            if (rleNext?.start === i && rleNext.end === i + 1) {
                rleNext.value = value;
                const nextnext = row[rleIndex + 1];
                if (nextnext?.start == i + 1 && nextnext.value === value) {
                    row.splice(rleIndex + 1, 1);
                    rleNext.end = nextnext.end;
                }
                return;
            }
            if (i === rleNext?.start) {
                rleNext.start++;
            }
            if (isAfter && end > i + 1) {
                row.splice(insertIndex, 0, rleInsert, {
                    start: i + 1,
                    end: rlePrev.end,
                    value: rlePrev.value,
                });
            }
            else {
                row.splice(insertIndex, 0, rleInsert);
            }
            if (rlePrev?.end > i) {
                rlePrev.end = i;
            }
        };
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.jMultiple = width;
        this.kMultiple = this.jMultiple * height;
    }
    static { this.getScalarData = function (ArrayType = Uint8ClampedArray) {
        const scalarData = new ArrayType(this.frameSize);
        this.map.updateScalarData(scalarData);
        return scalarData;
    }; }
    toIJK(index) {
        const i = index % this.jMultiple;
        const j = ((index - i) / this.jMultiple) % this.height;
        const k = Math.floor(index / this.kMultiple);
        return [i, j, k];
    }
    toIndex([i, j, k]) {
        return i + k * this.kMultiple + j * this.jMultiple;
    }
    getRLE(i, j, k = 0) {
        const row = this.rows.get(j + k * this.height);
        if (!row) {
            return;
        }
        const index = this.findIndex(row, i);
        const rle = row[index];
        return i >= rle?.start ? rle : undefined;
    }
    has(index) {
        const i = index % this.jMultiple;
        const j = (index - i) / this.jMultiple;
        const rle = this.getRLE(i, j);
        return rle?.value !== undefined;
    }
    delete(index) {
        const i = index % this.width;
        const j = (index - i) / this.width;
        const row = this.rows.get(j);
        if (!row) {
            return;
        }
        const rleIndex = this.findIndex(row, i);
        const rle = row[rleIndex];
        if (!rle || rle.start > i) {
            return;
        }
        if (rle.end === i + 1) {
            rle.end--;
            if (rle.start >= rle.end) {
                row.splice(rleIndex, 1);
                if (!row.length) {
                    this.rows.delete(j);
                }
            }
            return;
        }
        if (rle.start === i) {
            rle.start++;
            return;
        }
        const newRle = {
            value: rle.value,
            start: i + 1,
            end: rle.end,
        };
        rle.end = i;
        row.splice(rleIndex + 1, 0, newRle);
    }
    findIndex(row, i) {
        for (let index = 0; index < row.length; index++) {
            const { end: iEnd } = row[index];
            if (i < iEnd) {
                return index;
            }
        }
        return row.length;
    }
    forEach(callback, options) {
        const rowModified = options?.rowModified;
        for (const [baseIndex, row] of this.rows) {
            const rowToUse = rowModified ? [...row] : row;
            for (const rle of rowToUse) {
                callback(baseIndex * this.width, rle, row);
            }
        }
    }
    forEachRow(callback) {
        for (const [baseIndex, row] of this.rows) {
            callback(baseIndex * this.width, row);
        }
    }
    clear() {
        this.rows.clear();
    }
    keys() {
        return [...this.rows.keys()];
    }
    getPixelData(k = 0, pixelData) {
        if (!pixelData) {
            pixelData = new this.pixelDataConstructor(this.width * this.height * this.numComps);
        }
        else {
            pixelData.fill(0);
        }
        const { width, height, numComps } = this;
        for (let j = 0; j < height; j++) {
            const row = this.getRun(j, k);
            if (!row) {
                continue;
            }
            if (numComps === 1) {
                for (const rle of row) {
                    const rowOffset = j * width;
                    const { start, end, value } = rle;
                    for (let i = start; i < end; i++) {
                        pixelData[rowOffset + i] = value;
                    }
                }
            }
            else {
                for (const rle of row) {
                    const rowOffset = j * width * numComps;
                    const { start, end, value } = rle;
                    for (let i = start; i < end; i += numComps) {
                        for (let comp = 0; comp < numComps; comp++) {
                            pixelData[rowOffset + i + comp] = value[comp];
                        }
                    }
                }
            }
        }
        return pixelData;
    }
    floodFill(i, j, k, value, options) {
        const rle = this.getRLE(i, j, k);
        if (!rle) {
            throw new Error(`Initial point ${i},${j},${k} isn't in the RLE`);
        }
        const stack = [[rle, j, k]];
        const replaceValue = rle.value;
        if (replaceValue === value) {
            throw new Error(`source (${replaceValue}) and destination (${value}) are identical`);
        }
        return this.flood(stack, replaceValue, value, options);
    }
    flood(stack, sourceValue, value, options) {
        let sum = 0;
        const { planar = true, diagonals = true, singlePlane = false, } = options || {};
        const childOptions = { planar, diagonals, singlePlane };
        while (stack.length) {
            const top = stack.pop();
            const [current] = top;
            if (current.value !== sourceValue) {
                continue;
            }
            current.value = value;
            sum += current.end - current.start;
            const adjacents = this.findAdjacents(top, childOptions).filter((adjacent) => adjacent && adjacent[0].value === sourceValue);
            stack.push(...adjacents);
        }
        return sum;
    }
    fillFrom(getter, boundsIJK) {
        for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {
            for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {
                let rle;
                let row;
                for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {
                    const value = getter(i, j, k);
                    if (value === undefined) {
                        rle = undefined;
                        continue;
                    }
                    if (!row) {
                        row = [];
                        this.rows.set(j + k * this.height, row);
                    }
                    if (rle && rle.value !== value) {
                        rle = undefined;
                    }
                    if (!rle) {
                        rle = { start: i, end: i, value };
                        row.push(rle);
                    }
                    rle.end++;
                }
            }
        }
    }
    findAdjacents(item, { diagonals = true, planar = true, singlePlane = false }) {
        const [rle, j, k, adjacentsDelta] = item;
        const { start, end } = rle;
        const leftRle = start > 0 && this.getRLE(start - 1, j, k);
        const rightRle = end < this.width && this.getRLE(end, j, k);
        const range = diagonals
            ? [start > 0 ? start - 1 : start, end < this.width ? end + 1 : end]
            : [start, end];
        const adjacents = [];
        if (leftRle) {
            adjacents.push([leftRle, j, k]);
        }
        if (rightRle) {
            adjacents.push([rightRle, j, k]);
        }
        for (const delta of adjacentsDelta ||
            (singlePlane ? ADJACENT_SINGLE_PLANE : ADJACENT_ALL)) {
            const [, delta1, delta2] = delta;
            const testJ = delta1 + j;
            const testK = delta2 + k;
            if (testJ < 0 || testJ >= this.height) {
                continue;
            }
            if (testK < 0 || testK >= this.depth) {
                continue;
            }
            const row = this.getRun(testJ, testK);
            if (!row) {
                continue;
            }
            for (const testRle of row) {
                const newAdjacentDelta = adjacentsDelta ||
                    (singlePlane && ADJACENT_SINGLE_PLANE) ||
                    (planar && delta2 > 0 && ADJACENT_OUT) ||
                    (planar && delta2 < 0 && ADJACENT_IN) ||
                    ADJACENT_ALL;
                if (!(testRle.end <= range[0] || testRle.start >= range[1])) {
                    adjacents.push([testRle, testJ, testK, newAdjacentDelta]);
                }
            }
        }
        return adjacents;
    }
}


/***/ }),

/***/ 98039:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ actorIsA),
/* harmony export */   e: () => (/* binding */ isImageActor)
/* harmony export */ });
function isImageActor(actorEntry) {
    return (actorIsA(actorEntry, 'vtkVolume') || actorIsA(actorEntry, 'vtkImageSlice'));
}
function actorIsA(actorEntry, actorType) {
    const actorToCheck = 'isA' in actorEntry ? actorEntry : actorEntry.actor;
    if (!actorToCheck) {
        return false;
    }
    return !!actorToCheck.isA(actorType);
}


/***/ }),

/***/ 96833:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ applyPreset)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99341);


function applyPreset(actor, preset) {
    const colorTransferArray = preset.colorTransfer
        .split(' ')
        .splice(1)
        .map(parseFloat);
    const { shiftRange } = getShiftRange(colorTransferArray);
    const min = shiftRange[0];
    const width = shiftRange[1] - shiftRange[0];
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
    const normColorTransferValuePoints = [];
    for (let i = 0; i < colorTransferArray.length; i += 4) {
        let value = colorTransferArray[i];
        const r = colorTransferArray[i + 1];
        const g = colorTransferArray[i + 2];
        const b = colorTransferArray[i + 3];
        value = (value - min) / width;
        normColorTransferValuePoints.push([value, r, g, b]);
    }
    applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);
    actor.getProperty().setRGBTransferFunction(0, cfun);
    const scalarOpacityArray = preset.scalarOpacity
        .split(' ')
        .splice(1)
        .map(parseFloat);
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    const normPoints = [];
    for (let i = 0; i < scalarOpacityArray.length; i += 2) {
        let value = scalarOpacityArray[i];
        const opacity = scalarOpacityArray[i + 1];
        value = (value - min) / width;
        normPoints.push([value, opacity]);
    }
    applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);
    const property = actor.getProperty();
    property.setScalarOpacity(0, ofun);
    const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity,] = preset.gradientOpacity.split(' ').splice(1).map(parseFloat);
    property.setUseGradientOpacity(0, true);
    property.setGradientOpacityMinimumValue(0, gradientMinValue);
    property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);
    property.setGradientOpacityMaximumValue(0, gradientMaxValue);
    property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);
    if (preset.interpolation === '1') {
        property.setInterpolationTypeToFastLinear();
    }
    property.setShade(preset.shade === '1');
    const ambient = parseFloat(preset.ambient);
    const diffuse = parseFloat(preset.diffuse);
    const specular = parseFloat(preset.specular);
    const specularPower = parseFloat(preset.specularPower);
    property.setAmbient(ambient);
    property.setDiffuse(diffuse);
    property.setSpecular(specular);
    property.setSpecularPower(specularPower);
}
function getShiftRange(colorTransferArray) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0; i < colorTransferArray.length; i += 4) {
        min = Math.min(min, colorTransferArray[i]);
        max = Math.max(max, colorTransferArray[i]);
    }
    const center = (max - min) / 2;
    return {
        shiftRange: [-center, center],
        min,
        max,
    };
}
function applyPointsToRGBFunction(points, range, cfun) {
    const width = range[1] - range[0];
    const rescaled = points.map(([x, r, g, b]) => [
        x * width + range[0],
        r,
        g,
        b,
    ]);
    cfun.removeAllPoints();
    rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));
    return rescaled;
}
function applyPointsToPiecewiseFunction(points, range, pwf) {
    const width = range[1] - range[0];
    const rescaled = points.map(([x, y]) => [x * width + range[0], y]);
    pwf.removeAllPoints();
    rescaled.forEach(([x, y]) => pwf.addPoint(x, y));
    return rescaled;
}


/***/ }),

/***/ 91979:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39536);
/* harmony import */ var _getViewportsWithVolumeId__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24724);


const autoLoad = (volumeId) => {
    const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);
    if (!renderingEngineAndViewportIds?.length) {
        return;
    }
    renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {
        if (!renderingEngine.hasBeenDestroyed) {
            renderingEngine.renderViewports(viewportIds);
        }
    });
};
function getRenderingEngineAndViewportsContainingVolume(volumeId) {
    const renderingEnginesArray = (0,_RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .getRenderingEngines */ .qO)();
    const renderingEngineAndViewportIds = [];
    renderingEnginesArray.forEach((renderingEngine) => {
        const viewports = (0,_getViewportsWithVolumeId__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(volumeId);
        if (viewports.length) {
            renderingEngineAndViewportIds.push({
                renderingEngine,
                viewportIds: viewports.map((viewport) => viewport.id),
            });
        }
    });
    return renderingEngineAndViewportIds;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (autoLoad);


/***/ }),

/***/ 89131:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KP: () => (/* binding */ buildMetadata),
/* harmony export */   SJ: () => (/* binding */ getImagePlaneModule)
/* harmony export */ });
/* unused harmony exports getValidVOILUTFunction, calibrateImagePlaneModule */
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71851);


function getValidVOILUTFunction(voiLUTFunction) {
    if (!Object.values(_enums__WEBPACK_IMPORTED_MODULE_1__.VOILUTFunctionType).includes(voiLUTFunction)) {
        return _enums__WEBPACK_IMPORTED_MODULE_1__.VOILUTFunctionType.LINEAR;
    }
    return voiLUTFunction;
}
function getImagePlaneModule(imageId) {
    const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get(_enums__WEBPACK_IMPORTED_MODULE_1__.MetadataModules.IMAGE_PLANE, imageId);
    const newImagePlaneModule = {
        ...imagePlaneModule,
    };
    if (!newImagePlaneModule.columnPixelSpacing) {
        newImagePlaneModule.columnPixelSpacing = 1;
    }
    if (!newImagePlaneModule.rowPixelSpacing) {
        newImagePlaneModule.rowPixelSpacing = 1;
    }
    if (!newImagePlaneModule.columnCosines) {
        newImagePlaneModule.columnCosines = [0, 1, 0];
    }
    if (!newImagePlaneModule.rowCosines) {
        newImagePlaneModule.rowCosines = [1, 0, 0];
    }
    if (!newImagePlaneModule.imagePositionPatient) {
        newImagePlaneModule.imagePositionPatient = [0, 0, 0];
    }
    if (!newImagePlaneModule.imageOrientationPatient) {
        newImagePlaneModule.imageOrientationPatient = new Float32Array([
            1, 0, 0, 0, 1, 0,
        ]);
    }
    return newImagePlaneModule;
}
function calibrateImagePlaneModule(imageId, imagePlaneModule, currentCalibration) {
    const calibration = metaData.get('calibratedPixelSpacing', imageId);
    const isUpdated = currentCalibration !== calibration;
    const { scale } = calibration || {};
    const hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;
    imagePlaneModule.calibration = calibration;
    if (!isUpdated) {
        return { imagePlaneModule, hasPixelSpacing };
    }
    return {
        imagePlaneModule,
        hasPixelSpacing,
        calibrationEvent: {
            scale,
            calibration,
        },
    };
}
function buildMetadata(image) {
    const imageId = image.imageId;
    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('imagePixelModule', imageId);
    const { windowWidth, windowCenter, voiLUTFunction } = image;
    const { modality } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('generalSeriesModule', imageId);
    const imageIdScalingFactor = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('scalingModule', imageId);
    const calibration = _metaData__WEBPACK_IMPORTED_MODULE_0__.get(_enums__WEBPACK_IMPORTED_MODULE_1__.MetadataModules.CALIBRATION, imageId);
    const voiLUTFunctionEnum = getValidVOILUTFunction(voiLUTFunction);
    const imagePlaneModule = getImagePlaneModule(imageId);
    return {
        calibration,
        scalingFactor: imageIdScalingFactor,
        voiLUTFunction: voiLUTFunctionEnum,
        modality,
        imagePlaneModule,
        imagePixelModule: {
            bitsAllocated,
            bitsStored,
            samplesPerPixel,
            highBit,
            photometricInterpretation,
            pixelRepresentation,
            windowWidth: windowWidth,
            windowCenter: windowCenter,
            modality,
            voiLUTFunction: voiLUTFunctionEnum,
        },
    };
}


/***/ }),

/***/ 42384:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ calculateSpacingBetweenImageIds)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74876);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26896);



function calculateSpacingBetweenImageIds(imageIds) {
    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageIds[0]);
    const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
    const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
    const scanAxisNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    const refIppVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);
    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';
    let spacing;
    function getDistance(imageId) {
        const { imagePositionPatient } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageId);
        const positionVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        const ippVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imagePositionPatient[0], imagePositionPatient[1], imagePositionPatient[2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(positionVector, refIppVec, ippVec);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(positionVector, scanAxisNormal);
    }
    if (!usingWadoUri) {
        const distanceImagePairs = imageIds.map((imageId) => {
            const distance = getDistance(imageId);
            return {
                distance,
                imageId,
            };
        });
        distanceImagePairs.sort((a, b) => b.distance - a.distance);
        const numImages = distanceImagePairs.length;
        spacing =
            Math.abs(distanceImagePairs[numImages - 1].distance -
                distanceImagePairs[0].distance) /
                (numImages - 1);
    }
    else {
        const prefetchedImageIds = [
            imageIds[0],
            imageIds[Math.floor(imageIds.length / 2)],
        ];
        const firstImageDistance = getDistance(prefetchedImageIds[0]);
        const middleImageDistance = getDistance(prefetchedImageIds[1]);
        const metadataForMiddleImage = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', prefetchedImageIds[1]);
        if (!metadataForMiddleImage) {
            throw new Error('Incomplete metadata required for volume construction.');
        }
        const positionVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        const middleIppVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(metadataForMiddleImage.imagePositionPatient[0], metadataForMiddleImage.imagePositionPatient[1], metadataForMiddleImage.imagePositionPatient[2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(positionVector, refIppVec, middleIppVec);
        const distanceBetweenFirstAndMiddleImages = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(positionVector, scanAxisNormal);
        spacing =
            Math.abs(distanceBetweenFirstAndMiddleImages) /
                Math.floor(imageIds.length / 2);
    }
    const { sliceThickness, spacingBetweenSlices } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageIds[0]);
    const { strictZSpacingForVolumeViewport } = (0,_init__WEBPACK_IMPORTED_MODULE_2__/* .getConfiguration */ .D0)().rendering;
    if ((spacing === 0 || isNaN(spacing)) && !strictZSpacingForVolumeViewport) {
        if (spacingBetweenSlices) {
            console.debug('Could not calculate spacing. Using spacingBetweenSlices');
            spacing = spacingBetweenSlices;
        }
        else if (sliceThickness) {
            console.debug('Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness');
            spacing = sliceThickness;
        }
        else {
            console.debug('Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render');
            spacing = 1;
        }
    }
    return spacing;
}


/***/ }),

/***/ 84061:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ clamp),
/* harmony export */   q: () => (/* binding */ clamp)
/* harmony export */ });
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}



/***/ }),

/***/ 13859:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findMatchingColormap: () => (/* binding */ findMatchingColormap),
/* harmony export */   getColormap: () => (/* binding */ getColormap),
/* harmony export */   getColormapNames: () => (/* binding */ getColormapNames),
/* harmony export */   getMaxOpacity: () => (/* binding */ getMaxOpacity),
/* harmony export */   getThresholdValue: () => (/* binding */ getThresholdValue),
/* harmony export */   registerColormap: () => (/* binding */ registerColormap),
/* harmony export */   setColorMapTransferFunctionForVolumeActor: () => (/* binding */ setColorMapTransferFunctionForVolumeActor),
/* harmony export */   updateOpacity: () => (/* binding */ updateOpacity),
/* harmony export */   updateThreshold: () => (/* binding */ updateThreshold)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99341);
/* harmony import */ var _isEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74638);
/* harmony import */ var _actorCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98039);





const _colormaps = new Map();
function registerColormap(colormap) {
    colormap.name = colormap.name || colormap.Name;
    _colormaps.set(colormap.name, colormap);
}
function getColormap(name) {
    return _colormaps.get(name);
}
function getColormapNames() {
    return Array.from(_colormaps.keys());
}
function findMatchingColormap(rgbPoints, actor) {
    const colormapsVTK = _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.rgbPresetNames.map((presetName) => _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getPresetByName(presetName));
    const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));
    const colormaps = colormapsVTK.concat(colormapsCS3D);
    const matchedColormap = colormaps.find((colormap) => {
        const { RGBPoints: presetRGBPoints } = colormap;
        if (presetRGBPoints.length !== rgbPoints.length) {
            return false;
        }
        for (let i = 0; i < presetRGBPoints.length; i += 4) {
            if (!(0,_isEqual__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay)(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {
                return false;
            }
        }
        return true;
    });
    if (!matchedColormap) {
        return null;
    }
    const opacity = [];
    if ((0,_actorCheck__WEBPACK_IMPORTED_MODULE_4__/* .actorIsA */ .N)(actor, 'vtkVolume')) {
        const opacityPoints = actor
            .getProperty()
            .getScalarOpacity(0)
            .getDataPointer();
        if (!opacityPoints) {
            return {
                name: matchedColormap.Name,
            };
        }
        for (let i = 0; i < opacityPoints.length; i += 2) {
            opacity.push({
                value: opacityPoints[i],
                opacity: opacityPoints[i + 1],
            });
        }
    }
    const result = {
        name: matchedColormap.Name,
        ...(Array.isArray(opacity) && opacity.length > 0 && { opacity }),
        ...(typeof opacity === 'number' && { opacity }),
    };
    return result;
}
function setColorMapTransferFunctionForVolumeActor(volumeInfo) {
    const { volumeActor, preset, opacity = 0.9, threshold = null, colorRange = [0, 5], } = volumeInfo;
    const mapper = volumeActor.getMapper();
    mapper.setSampleDistance(1.0);
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    const presetToUse = preset || _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getPresetByName('hsv');
    cfun.applyColorMap(presetToUse);
    cfun.setMappingRange(colorRange[0], colorRange[1]);
    volumeActor.getProperty().setRGBTransferFunction(0, cfun);
    updateOpacityWithThreshold(volumeActor, opacity, threshold);
}
function updateOpacity(volumeActor, newOpacity) {
    const currentThreshold = getThresholdValue(volumeActor);
    updateOpacityWithThreshold(volumeActor, newOpacity, currentThreshold);
}
function updateThreshold(volumeActor, newThreshold) {
    const currentOpacity = getMaxOpacity(volumeActor);
    updateOpacityWithThreshold(volumeActor, currentOpacity, newThreshold);
}
function updateOpacityWithThreshold(volumeActor, opacity, threshold) {
    const meta = volumeActor.getMapper().getInputData().get('voxelManager');
    if (!meta?.voxelManager) {
        throw new Error('No voxel manager was found for the volume actor, or you cannot yet update opacity with a threshold using stacked images');
    }
    const range = meta.voxelManager.getRange();
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    if (threshold !== null) {
        const delta = Math.abs(range[1] - range[0]) * 0.001;
        const thresholdValue = Math.max(range[0], Math.min(range[1], threshold));
        ofun.addPoint(range[0], 0);
        ofun.addPoint(thresholdValue - delta, 0);
        ofun.addPoint(thresholdValue, opacity);
        ofun.addPoint(range[1], opacity);
    }
    else {
        ofun.addPoint(range[0], opacity);
        ofun.addPoint(range[1], opacity);
    }
    volumeActor.getProperty().setScalarOpacity(0, ofun);
}
function getThresholdValue(volumeActor) {
    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);
    if (!opacityFunction) {
        return null;
    }
    const dataArray = opacityFunction.getDataPointer();
    if (!dataArray || dataArray.length <= 4) {
        return null;
    }
    for (let i = 0; i < dataArray.length - 2; i += 2) {
        const x1 = dataArray[i];
        const y1 = dataArray[i + 1];
        const x2 = dataArray[i + 2];
        const y2 = dataArray[i + 3];
        if (y1 === 0 && y2 > 0) {
            return x2;
        }
    }
    return null;
}
function getMaxOpacity(volumeActor) {
    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);
    if (!opacityFunction) {
        return 1.0;
    }
    const dataArray = opacityFunction.getDataPointer();
    if (!dataArray || dataArray.length === 0) {
        return 1.0;
    }
    let maxOpacity = 0;
    for (let i = 1; i < dataArray.length; i += 2) {
        if (dataArray[i] > maxOpacity) {
            maxOpacity = dataArray[i];
        }
    }
    return maxOpacity;
}



/***/ }),

/***/ 74657:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createLinearRGBTransferFunction)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642);

function createLinearRGBTransferFunction(voiRange) {
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
    let lower = 0;
    let upper = 1024;
    if (voiRange.lower !== undefined && voiRange.upper !== undefined) {
        lower = voiRange.lower;
        upper = voiRange.upper;
    }
    cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);
    cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);
    return cfun;
}


/***/ }),

/***/ 40256:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createSigmoidRGBTransferFunction)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _windowLevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68136);
/* harmony import */ var _logit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58977);




function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {
    const { windowWidth, windowCenter } = _windowLevel__WEBPACK_IMPORTED_MODULE_2__.toWindowLevel(voiRange.lower, voiRange.upper);
    const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));
    const table = range.flatMap((y) => {
        const x = (0,_logit__WEBPACK_IMPORTED_MODULE_3__/* .logit */ .i)(y, windowCenter, windowWidth);
        return [x, y, y, y, 0.5, 0.0];
    });
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
    cfun.buildFunctionFromArray(_kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
        values: table,
        numberOfComponents: 6,
    }));
    return cfun;
}


/***/ }),

/***/ 63470:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ decimate)
/* harmony export */ });
function decimate(list, interleave, offset = 0) {
    const interleaveIndices = [];
    for (let i = offset; i < list.length; i += interleave) {
        interleaveIndices.push(i);
    }
    return interleaveIndices;
}


/***/ }),

/***/ 99949:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ deepClone)
/* harmony export */ });
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (typeof obj === 'function') {
        return obj;
    }
    if (typeof structuredClone === 'function') {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(deepClone);
    }
    else {
        const clonedObj = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                clonedObj[key] = deepClone(obj[key]);
            }
        }
        return clonedObj;
    }
}


/***/ }),

/***/ 20286:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ fnv1aHash)
/* harmony export */ });
function fnv1aHash(str) {
    let hash = 0x811c9dc5;
    for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash +=
            (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return (hash >>> 0).toString(36);
}


/***/ }),

/***/ 88619:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getClosestImageId)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74876);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7608);
/* harmony import */ var _getSpacingInNormalDirection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85008);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(76491);





const log = _logger__WEBPACK_IMPORTED_MODULE_2__.coreLog.getLogger('utilities', 'getClosestImageId');
function getClosestImageId(imageVolume, worldPos, viewPlaneNormal, options) {
    const { direction, spacing, imageIds } = imageVolume;
    const { ignoreSpacing = false } = options || {};
    if (!imageIds?.length) {
        return;
    }
    const kVector = direction.slice(6, 9);
    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(kVector, viewPlaneNormal);
    if (Math.abs(dotProduct) < 1 - _constants__WEBPACK_IMPORTED_MODULE_4__.EPSILON) {
        return;
    }
    let halfSpacingInNormalDirection;
    if (!ignoreSpacing) {
        const spacingInNormalDirection = (0,_getSpacingInNormalDirection__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)({ direction, spacing }, viewPlaneNormal);
        halfSpacingInNormalDirection = spacingInNormalDirection / 2;
    }
    let closestImageId;
    let minDistance = Infinity;
    for (let i = 0; i < imageIds.length; i++) {
        const imageId = imageIds[i];
        const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageId);
        if (!imagePlaneModule?.imagePositionPatient) {
            log.warn(`Missing imagePositionPatient for imageId: ${imageId}`);
            continue;
        }
        const { imagePositionPatient } = imagePlaneModule;
        const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(dir, worldPos, imagePositionPatient);
        const distance = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(dir, viewPlaneNormal));
        if (ignoreSpacing) {
            if (distance < minDistance) {
                minDistance = distance;
                closestImageId = imageId;
            }
        }
        else {
            if (distance < halfSpacingInNormalDirection && distance < minDistance) {
                minDistance = distance;
                closestImageId = imageId;
            }
        }
    }
    if (closestImageId === undefined) {
        log.warn('No imageId found within the specified criteria (half spacing or absolute closest).');
    }
    return closestImageId;
}


/***/ }),

/***/ 53932:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getImageDataMetadata)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76491);
/* harmony import */ var _buildMetadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89131);



function getImageDataMetadata(image) {
    const { imagePlaneModule, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = (0,_buildMetadata__WEBPACK_IMPORTED_MODULE_2__/* .buildMetadata */ .KP)(image);
    let { rowCosines, columnCosines } = imagePlaneModule;
    if (rowCosines == null || columnCosines == null) {
        rowCosines = [1, 0, 0];
        columnCosines = [0, 1, 0];
    }
    const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
    const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
    const scanAxisNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    let origin = imagePlaneModule.imagePositionPatient;
    if (origin == null) {
        origin = [0, 0, 0];
    }
    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;
    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;
    const xVoxels = image.columns;
    const yVoxels = image.rows;
    const zSpacing = _constants__WEBPACK_IMPORTED_MODULE_1__.EPSILON;
    const zVoxels = 1;
    if (!imagePixelModule.photometricInterpretation &&
        image.sizeInBytes === 3 * image.width * image.height) {
        image.numberOfComponents = 3;
    }
    const numberOfComponents = image.numberOfComponents ||
        _getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);
    return {
        numberOfComponents,
        origin,
        direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
        dimensions: [xVoxels, yVoxels, zVoxels],
        spacing: [xSpacing, ySpacing, zSpacing],
        numVoxels: xVoxels * yVoxels * zVoxels,
        imagePlaneModule,
        imagePixelModule,
        bitsAllocated: imagePixelModule.bitsAllocated,
        voiLUTFunction,
        modality,
        scalingFactor,
        calibration,
        scanAxisNormal: scanAxisNormal,
    };
}
function _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {
    let numberOfComponents = 1;
    if (photometricInterpretation === 'RGB' ||
        photometricInterpretation?.includes('YBR') ||
        photometricInterpretation === 'PALETTE COLOR') {
        numberOfComponents = 3;
    }
    return numberOfComponents;
}


/***/ }),

/***/ 47476:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getSliceRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20537);
/* harmony import */ var _getTargetVolumeAndSpacingInNormalDir__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65292);


function getImageSliceDataForVolumeViewport(viewport) {
    const camera = viewport.getCamera();
    const { spacingInNormalDirection, imageVolume } = (0,_getTargetVolumeAndSpacingInNormalDir__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport, camera);
    if (!imageVolume) {
        return;
    }
    const { viewPlaneNormal, focalPoint } = camera;
    const actorEntry = viewport
        .getActors()
        .find((a) => a.referencedId === imageVolume.volumeId ||
        a.uid === imageVolume.volumeId);
    if (!actorEntry) {
        console.warn('No actor found for with actorUID of', imageVolume.volumeId);
    }
    const volumeActor = actorEntry.actor;
    const sliceRange = (0,_getSliceRange__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(volumeActor, viewPlaneNormal, focalPoint);
    const { min, max, current } = sliceRange;
    const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;
    let imageIndex = ((current - min) / (max - min)) * numberOfSlices;
    imageIndex = Math.floor(imageIndex);
    if (imageIndex > numberOfSlices - 1) {
        imageIndex = numberOfSlices - 1;
    }
    else if (imageIndex < 0) {
        imageIndex = 0;
    }
    return {
        numberOfSlices,
        imageIndex,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getImageSliceDataForVolumeViewport);


/***/ }),

/***/ 32173:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getScalingParameters)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);

function getScalingParameters(imageId) {
    const modalityLutModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('modalityLutModule', imageId) || {};
    const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('generalSeriesModule', imageId) || {};
    const { modality } = generalSeriesModule;
    const scalingParameters = {
        rescaleSlope: modalityLutModule.rescaleSlope || 1,
        rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,
        modality,
    };
    const scalingModules = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('scalingModule', imageId) || {};
    return {
        ...scalingParameters,
        ...(modality === 'PT' && {
            suvbw: scalingModules.suvbw,
            suvbsa: scalingModules.suvbsa,
            suvlbm: scalingModules.suvlbm,
        }),
        ...(modality === 'RTDOSE' && {
            doseGridScaling: scalingModules.DoseGridScaling,
            doseSummation: scalingModules.DoseSummation,
            doseType: scalingModules.DoseType,
            doseUnit: scalingModules.DoseUnit,
        }),
    };
}


/***/ }),

/***/ 20537:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getSliceRange)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89265);
/* harmony import */ var _getVolumeActorCorners__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15105);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76491);



const SMALL_EPSILON = _constants__WEBPACK_IMPORTED_MODULE_2__.EPSILON * _constants__WEBPACK_IMPORTED_MODULE_2__.EPSILON;
const isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;
const isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);
const isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);
function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {
    const imageData = volumeActor.getMapper().getInputData();
    let corners;
    const direction = imageData.getDirection();
    if (isOrthonormal(direction)) {
        corners = (0,_getVolumeActorCorners__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(volumeActor);
    }
    else {
        const [dx, dy, dz] = imageData.getDimensions();
        const cornersIdx = [
            [0, 0, 0],
            [dx - 1, 0, 0],
            [0, dy - 1, 0],
            [dx - 1, dy - 1, 0],
            [0, 0, dz - 1],
            [dx - 1, 0, dz - 1],
            [0, dy - 1, dz - 1],
            [dx - 1, dy - 1, dz - 1],
        ];
        corners = cornersIdx.map((it) => imageData.indexToWorld(it));
    }
    const transform = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
        .buildFromDegree()
        .identity()
        .rotateFromDirections(viewPlaneNormal, [1, 0, 0]);
    corners.forEach((pt) => transform.apply(pt));
    const transformedFocalPoint = [...focalPoint];
    transform.apply(transformedFocalPoint);
    const currentSlice = transformedFocalPoint[0];
    let minX = Infinity;
    let maxX = -Infinity;
    for (let i = 0; i < 8; i++) {
        const x = corners[i][0];
        if (x > maxX) {
            maxX = x;
        }
        if (x < minX) {
            minX = x;
        }
    }
    return {
        min: minX,
        max: maxX,
        current: currentSlice,
        actor: volumeActor,
        viewPlaneNormal,
        focalPoint,
    };
}


/***/ }),

/***/ 85008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getSpacingInNormalDirection)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {
    const { direction, spacing } = imageVolume;
    const iVector = direction.slice(0, 3);
    const jVector = direction.slice(3, 6);
    const kVector = direction.slice(6, 9);
    const dotProducts = [
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(iVector, viewPlaneNormal),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(jVector, viewPlaneNormal),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(kVector, viewPlaneNormal),
    ];
    const projectedSpacing = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);
    const spacingInNormalDirection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(projectedSpacing);
    return spacingInNormalDirection;
}


/***/ }),

/***/ 65292:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getTargetVolumeAndSpacingInNormalDir)
/* harmony export */ });
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49038);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76491);
/* harmony import */ var _getSpacingInNormalDirection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85008);
/* harmony import */ var _loaders_volumeLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87142);
/* harmony import */ var _getVolumeId__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12437);





const EPSILON_PART = 1 + _constants__WEBPACK_IMPORTED_MODULE_1__.EPSILON;
const startsWith = (str, starts) => starts === str.substring(0, Math.min(str.length, starts.length));
const isPrimaryVolume = (volume) => !!(0,_loaders_volumeLoader__WEBPACK_IMPORTED_MODULE_3__.getVolumeLoaderSchemes)().find((scheme) => startsWith(volume.volumeId, scheme));
function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {
    const { viewPlaneNormal } = camera;
    const volumeActors = viewport.getActors();
    if (!volumeActors.length) {
        return {
            spacingInNormalDirection: null,
            imageVolume: null,
            actorUID: null,
        };
    }
    const imageVolumes = volumeActors
        .map((va) => {
        const actorUID = va.referencedId ?? va.uid;
        return _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getVolume(actorUID);
    })
        .filter((iv) => !!iv);
    if (targetId) {
        const targetVolumeId = (0,_getVolumeId__WEBPACK_IMPORTED_MODULE_4__/* .getVolumeId */ .A)(targetId);
        const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));
        const imageVolume = imageVolumes[imageVolumeIndex];
        const { uid: actorUID } = volumeActors[imageVolumeIndex];
        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);
        return { imageVolume, spacingInNormalDirection, actorUID };
    }
    if (!imageVolumes.length) {
        return {
            spacingInNormalDirection: null,
            imageVolume: null,
            actorUID: null,
        };
    }
    const smallest = {
        spacingInNormalDirection: Infinity,
        imageVolume: null,
        actorUID: null,
    };
    const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);
    for (let i = 0; i < imageVolumes.length; i++) {
        const imageVolume = imageVolumes[i];
        if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {
            continue;
        }
        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);
        if (spacingInNormalDirection * EPSILON_PART <
            smallest.spacingInNormalDirection) {
            smallest.spacingInNormalDirection = spacingInNormalDirection;
            smallest.imageVolume = imageVolume;
            smallest.actorUID = volumeActors[i].uid;
        }
    }
    return smallest;
}
function getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {
    const { slabThickness } = viewport.getProperties();
    let spacingInNormalDirection = slabThickness;
    if (!slabThickness || !useSlabThickness) {
        spacingInNormalDirection = (0,_getSpacingInNormalDirection__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(imageVolume, viewPlaneNormal);
    }
    return spacingInNormalDirection;
}


/***/ }),

/***/ 24724:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39536);

function getViewportsWithVolumeId(volumeId) {
    const renderingEngines = (0,_RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .getRenderingEngines */ .qO)();
    const targetViewports = [];
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getVolumeViewports();
        const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));
        targetViewports.push(...filteredViewports);
    });
    return targetViewports;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getViewportsWithVolumeId);


/***/ }),

/***/ 70210:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getVoiFromSigmoidRGBTransferFunction)
/* harmony export */ });
function getVoiFromSigmoidRGBTransferFunction(cfun) {
    let cfunRange = [];
    const [lower, upper] = cfun.getRange();
    cfun.getTable(lower, upper, 1024, cfunRange);
    cfunRange = cfunRange.filter((v, k) => k % 3 === 0);
    const cfunDomain = [...Array(1024).keys()].map((v, k) => {
        return lower + ((upper - lower) / (1024 - 1)) * k;
    });
    const y1 = cfunRange[256];
    const logy1 = Math.log((1 - y1) / y1);
    const x1 = cfunDomain[256];
    const y2 = cfunRange[256 * 3];
    const logy2 = Math.log((1 - y2) / y2);
    const x2 = cfunDomain[256 * 3];
    const ww = Math.round((4 * (x2 - x1)) / (logy1 - logy2));
    const wc = Math.round(x1 + (ww * logy1) / 4);
    return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];
}


/***/ }),

/***/ 15105:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getVolumeActorCorners)
/* harmony export */ });
function getVolumeActorCorners(volumeActor) {
    const imageData = volumeActor.getMapper().getInputData();
    const bounds = imageData.extentToBounds(imageData.getExtent());
    return [
        [bounds[0], bounds[2], bounds[4]],
        [bounds[0], bounds[2], bounds[5]],
        [bounds[0], bounds[3], bounds[4]],
        [bounds[0], bounds[3], bounds[5]],
        [bounds[1], bounds[2], bounds[4]],
        [bounds[1], bounds[2], bounds[5]],
        [bounds[1], bounds[3], bounds[4]],
        [bounds[1], bounds[3], bounds[5]],
    ];
}


/***/ }),

/***/ 12437:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getVolumeId)
/* harmony export */ });
const getVolumeId = (targetId) => {
    const prefix = 'volumeId:';
    const str = targetId.includes(prefix)
        ? targetId.substring(prefix.length)
        : targetId;
    const index = str.indexOf('sliceIndex=');
    return index === -1 ? str : str.substring(0, index - 1);
};


/***/ }),

/***/ 4031:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getSliceRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20537);
/* harmony import */ var _getTargetVolumeAndSpacingInNormalDir__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65292);


function getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {
    const camera = viewport.getCamera();
    const { focalPoint, viewPlaneNormal } = camera;
    const { spacingInNormalDirection, actorUID } = (0,_getTargetVolumeAndSpacingInNormalDir__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport, camera, volumeId, useSlabThickness);
    if (!actorUID) {
        throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);
    }
    const actorEntry = viewport.getActor(actorUID);
    if (!actorEntry) {
        console.warn('No actor found for with actorUID of', actorUID);
        return null;
    }
    const volumeActor = actorEntry.actor;
    const sliceRange = (0,_getSliceRange__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(volumeActor, viewPlaneNormal, focalPoint);
    return {
        sliceRange,
        spacingInNormalDirection,
        camera,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getVolumeSliceRangeInfo);


/***/ }),

/***/ 61375:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getVolumeSliceRangeInfo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4031);

function getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {
    const { sliceRange, spacingInNormalDirection, camera } = (0,_getVolumeSliceRangeInfo__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(viewport, volumeId, useSlabThickness);
    const { min, max, current } = sliceRange;
    const numScrollSteps = Math.round((max - min) / spacingInNormalDirection);
    const fraction = (current - min) / (max - min);
    const floatingStepNumber = fraction * numScrollSteps;
    const currentStepIndex = Math.round(floatingStepNumber);
    return {
        numScrollSteps,
        currentStepIndex,
        sliceRangeInfo: {
            sliceRange,
            spacingInNormalDirection,
            camera,
        },
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getVolumeViewportScrollInfo);


/***/ }),

/***/ 30169:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ hasFloatScalingParameters)
/* harmony export */ });
const hasFloatScalingParameters = (scalingParameters) => {
    const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === 'number' && !Number.isInteger(value));
    return hasFloatRescale;
};


/***/ }),

/***/ 38883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ hasNaNValues)
/* harmony export */ });
function hasNaNValues(input) {
    if (Array.isArray(input)) {
        return input.some((value) => Number.isNaN(value));
    }
    return Number.isNaN(input);
}


/***/ }),

/***/ 39537:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ imageIdToURI)
/* harmony export */ });
function imageIdToURI(imageId) {
    const colonIndex = imageId.indexOf(':');
    return imageId.substring(colonIndex + 1);
}


/***/ }),

/***/ 17791:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);

const retrieveConfigurationState = new Map();
const IMAGE_RETRIEVE_CONFIGURATION = 'imageRetrieveConfiguration';
const imageRetrieveMetadataProvider = {
    IMAGE_RETRIEVE_CONFIGURATION,
    clear: () => {
        retrieveConfigurationState.clear();
    },
    add: (key, payload) => {
        retrieveConfigurationState.set(key, payload);
    },
    clone: () => {
        return new Map(retrieveConfigurationState);
    },
    restore: (state) => {
        retrieveConfigurationState.clear();
        state.forEach((value, key) => {
            retrieveConfigurationState.set(key, value);
        });
    },
    get: (type, ...queries) => {
        if (type === IMAGE_RETRIEVE_CONFIGURATION) {
            return queries
                .map((query) => retrieveConfigurationState.get(query))
                .find((it) => it !== undefined);
        }
    },
};
(0,_metaData__WEBPACK_IMPORTED_MODULE_0__.addProvider)(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageRetrieveMetadataProvider);


/***/ }),

/***/ 33592:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  FrameRange: () => (/* reexport */ FrameRange/* default */.A),
  HistoryMemo: () => (/* reexport */ historyMemo_namespaceObject),
  PointsManager: () => (/* reexport */ PointsManager/* default */.A),
  ProgressiveIterator: () => (/* reexport */ ProgressiveIterator/* default */.A),
  RLEVoxelMap: () => (/* reexport */ RLEVoxelMap/* default */.A),
  VoxelManager: () => (/* reexport */ VoxelManager/* default */.A),
  actorIsA: () => (/* reexport */ actorCheck/* actorIsA */.N),
  applyPreset: () => (/* reexport */ applyPreset/* default */.A),
  asArray: () => (/* reexport */ asArray),
  autoLoad: () => (/* reexport */ autoLoad/* default */.A),
  buildMetadata: () => (/* reexport */ buildMetadata/* buildMetadata */.KP),
  calculateNeighborhoodStats: () => (/* reexport */ calculateNeighborhoodStats),
  calculateSpacingBetweenImageIds: () => (/* reexport */ calculateSpacingBetweenImageIds/* default */.A),
  calculateViewportsSpatialRegistration: () => (/* reexport */ utilities_calculateViewportsSpatialRegistration),
  calibratedPixelSpacingMetadataProvider: () => (/* reexport */ calibratedPixelSpacingMetadataProvider),
  clamp: () => (/* reexport */ clamp/* default */.A),
  clip: () => (/* reexport */ utilities_clip),
  color: () => (/* reexport */ color_namespaceObject),
  colormap: () => (/* reexport */ colormap),
  convertStackToVolumeViewport: () => (/* reexport */ convertStackToVolumeViewport),
  convertToGrayscale: () => (/* reexport */ convertToGrayscale),
  convertVolumeToStackViewport: () => (/* reexport */ convertVolumeToStackViewport),
  createLinearRGBTransferFunction: () => (/* reexport */ createLinearRGBTransferFunction/* default */.A),
  createSigmoidRGBTransferFunction: () => (/* reexport */ createSigmoidRGBTransferFunction/* default */.A),
  createSubVolume: () => (/* reexport */ createSubVolume),
  decimate: () => (/* reexport */ decimate/* default */.A),
  deepClone: () => (/* reexport */ deepClone/* deepClone */.G),
  deepEqual: () => (/* reexport */ deepEqual),
  deepMerge: () => (/* reexport */ deepMerge/* default */.A),
  eventListener: () => (/* reexport */ eventListener_namespaceObject),
  fnv1aHash: () => (/* reexport */ fnv1aHash/* default */.A),
  generateVolumePropsFromImageIds: () => (/* reexport */ generateVolumePropsFromImageIds/* generateVolumePropsFromImageIds */.D),
  genericMetadataProvider: () => (/* reexport */ genericMetadataProvider/* default */.A),
  getBufferConfiguration: () => (/* reexport */ getBufferConfiguration/* getBufferConfiguration */.h),
  getClosestImageId: () => (/* reexport */ getClosestImageId/* default */.A),
  getClosestStackImageIndexForPoint: () => (/* reexport */ getClosestStackImageIndexForPoint),
  getCurrentVolumeViewportSlice: () => (/* reexport */ getCurrentVolumeViewportSlice),
  getDynamicVolumeInfo: () => (/* reexport */ utilities_getDynamicVolumeInfo),
  getImageDataMetadata: () => (/* reexport */ getImageDataMetadata/* getImageDataMetadata */.T),
  getImageLegacy: () => (/* reexport */ utilities_getImageLegacy),
  getImageSliceDataForVolumeViewport: () => (/* reexport */ getImageSliceDataForVolumeViewport/* default */.A),
  getMinMax: () => (/* reexport */ getMinMax),
  getPixelSpacingInformation: () => (/* reexport */ getPixelSpacingInformation),
  getRandomSampleFromArray: () => (/* reexport */ getRandomSampleFromArray),
  getRuntimeId: () => (/* reexport */ getRuntimeId),
  getScalingParameters: () => (/* reexport */ getScalingParameters/* default */.A),
  getSliceRange: () => (/* reexport */ getSliceRange/* default */.A),
  getSpacingInNormalDirection: () => (/* reexport */ getSpacingInNormalDirection/* default */.A),
  getTargetVolumeAndSpacingInNormalDir: () => (/* reexport */ getTargetVolumeAndSpacingInNormalDir/* default */.A),
  getViewportImageCornersInWorld: () => (/* reexport */ getViewportImageCornersInWorld),
  getViewportImageIds: () => (/* reexport */ utilities_getViewportImageIds),
  getViewportModality: () => (/* binding */ getViewportModality),
  getViewportsWithImageURI: () => (/* reexport */ getViewportsWithImageURI),
  getViewportsWithVolumeId: () => (/* reexport */ getViewportsWithVolumeId/* default */.A),
  getVoiFromSigmoidRGBTransferFunction: () => (/* reexport */ getVoiFromSigmoidRGBTransferFunction/* default */.A),
  getVolumeActorCorners: () => (/* reexport */ getVolumeActorCorners/* default */.A),
  getVolumeDirectionVectors: () => (/* reexport */ getVolumeDirectionVectors),
  getVolumeId: () => (/* reexport */ getVolumeId/* getVolumeId */.A),
  getVolumeSliceRangeInfo: () => (/* reexport */ getVolumeSliceRangeInfo/* default */.A),
  getVolumeViewportScrollInfo: () => (/* reexport */ getVolumeViewportScrollInfo/* default */.A),
  getVolumeViewportsContainingSameVolumes: () => (/* reexport */ utilities_getVolumeViewportsContainingSameVolumes),
  hasFloatScalingParameters: () => (/* reexport */ hasFloatScalingParameters/* hasFloatScalingParameters */.a),
  hasNaNValues: () => (/* reexport */ hasNaNValues/* default */.A),
  imageIdToURI: () => (/* reexport */ imageIdToURI/* default */.A),
  imageRetrieveMetadataProvider: () => (/* reexport */ imageRetrieveMetadataProvider/* default */.A),
  imageToWorldCoords: () => (/* reexport */ imageToWorldCoords),
  indexWithinDimensions: () => (/* reexport */ indexWithinDimensions),
  invertRgbTransferFunction: () => (/* reexport */ invertRgbTransferFunction/* default */.A),
  isEqual: () => (/* reexport */ isEqual/* isEqual */.n4),
  isEqualAbs: () => (/* reexport */ isEqual/* isEqualAbs */.Ph),
  isEqualNegative: () => (/* reexport */ isEqual/* isEqualNegative */.WC),
  isImageActor: () => (/* reexport */ actorCheck/* isImageActor */.e),
  isNumber: () => (/* reexport */ isEqual/* isNumber */.Et),
  isOpposite: () => (/* reexport */ isOpposite),
  isPTPrescaledWithSUV: () => (/* reexport */ utilities_isPTPrescaledWithSUV),
  isValidVolume: () => (/* reexport */ isValidVolume),
  isVideoTransferSyntax: () => (/* reexport */ isVideoTransferSyntax),
  jumpToSlice: () => (/* reexport */ jumpToSlice),
  loadImageToCanvas: () => (/* reexport */ loadImageToCanvas),
  logger: () => (/* reexport */ logger),
  makeVolumeMetadata: () => (/* reexport */ makeVolumeMetadata/* default */.A),
  planar: () => (/* reexport */ planar),
  pointInShapeCallback: () => (/* reexport */ pointInShapeCallback/* pointInShapeCallback */.ii),
  renderToCanvasCPU: () => (/* reexport */ renderToCanvasCPU),
  renderToCanvasGPU: () => (/* reexport */ renderToCanvasGPU),
  roundNumber: () => (/* reexport */ utilities_roundNumber),
  roundToPrecision: () => (/* reexport */ roundToPrecision),
  scaleArray: () => (/* reexport */ scaleArray),
  scaleRgbTransferFunction: () => (/* reexport */ scaleRGBTransferFunction),
  scroll: () => (/* reexport */ scroll_scroll),
  snapFocalPointToSlice: () => (/* reexport */ snapFocalPointToSlice/* default */.A),
  sortImageIdsAndGetSpacing: () => (/* reexport */ sortImageIdsAndGetSpacing/* default */.A),
  spatialRegistrationMetadataProvider: () => (/* reexport */ utilities_spatialRegistrationMetadataProvider),
  splitImageIdsBy4DTags: () => (/* reexport */ utilities_splitImageIdsBy4DTags),
  transferFunctionUtils: () => (/* reexport */ transferFunctionUtils),
  transformIndexToWorld: () => (/* reexport */ transformIndexToWorld/* default */.A),
  transformWorldToIndex: () => (/* reexport */ transformWorldToIndex/* default */.A),
  transformWorldToIndexContinuous: () => (/* reexport */ transformWorldToIndex/* transformWorldToIndexContinuous */.p),
  triggerEvent: () => (/* reexport */ triggerEvent/* default */.A),
  updatePlaneRestriction: () => (/* reexport */ updatePlaneRestriction/* updatePlaneRestriction */.O),
  updateVTKImageDataWithCornerstoneImage: () => (/* reexport */ updateVTKImageDataWithCornerstoneImage/* updateVTKImageDataWithCornerstoneImage */.J),
  uuidv4: () => (/* reexport */ uuidv4/* default */.A),
  windowLevel: () => (/* reexport */ windowLevel),
  worldToImageCoords: () => (/* reexport */ utilities_worldToImageCoords)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/index.js
var eventListener_namespaceObject = {};
__webpack_require__.r(eventListener_namespaceObject);
__webpack_require__.d(eventListener_namespaceObject, {
  MultiTargetEventListenerManager: () => (MultiTargetEventListenerManager),
  TargetEventListeners: () => (TargetEventListeners)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js
var historyMemo_namespaceObject = {};
__webpack_require__.r(historyMemo_namespaceObject);
__webpack_require__.d(historyMemo_namespaceObject, {
  DefaultHistoryMemo: () => (DefaultHistoryMemo),
  HistoryMemo: () => (HistoryMemo)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js
var color_namespaceObject = {};
__webpack_require__.r(color_namespaceObject);
__webpack_require__.d(color_namespaceObject, {
  hexToRgb: () => (hexToRgb),
  rgbToHex: () => (rgbToHex)
});

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js
var EventListenerPhases;
(function (EventListenerPhases) {
    EventListenerPhases[EventListenerPhases["None"] = 0] = "None";
    EventListenerPhases[EventListenerPhases["Capture"] = 1] = "Capture";
    EventListenerPhases[EventListenerPhases["Bubble"] = 2] = "Bubble";
})(EventListenerPhases || (EventListenerPhases = {}));
class TargetEventListeners {
    constructor(target) {
        this._eventListeners = new Map();
        this._children = new Map();
        this._target = target;
    }
    get isEmpty() {
        return this._eventListeners.size === 0 && this._children.size === 0;
    }
    addEventListener(type, callback, options) {
        const dotIndex = type.indexOf('.');
        const isNamespace = dotIndex !== -1;
        if (isNamespace) {
            const namespaceToken = type.substring(0, dotIndex);
            let childElementEventListener = this._children.get(namespaceToken);
            if (!childElementEventListener) {
                childElementEventListener = new TargetEventListeners(this._target);
                this._children.set(namespaceToken, childElementEventListener);
            }
            type = type.substring(dotIndex + 1);
            childElementEventListener.addEventListener(type, callback, options);
        }
        else {
            this._addEventListener(type, callback, options);
        }
    }
    removeEventListener(type, callback, options) {
        const dotIndex = type.indexOf('.');
        const isNamespace = dotIndex !== -1;
        if (isNamespace) {
            const namespaceToken = type.substring(0, dotIndex);
            const childElementEventListener = this._children.get(namespaceToken);
            if (!childElementEventListener) {
                return;
            }
            type = type.substring(dotIndex + 1);
            childElementEventListener.removeEventListener(type, callback, options);
            if (childElementEventListener.isEmpty) {
                this._children.delete(namespaceToken);
            }
        }
        else {
            this._removeEventListener(type, callback, options);
        }
    }
    reset() {
        Array.from(this._children.entries()).forEach(([namespace, child]) => {
            child.reset();
            if (child.isEmpty) {
                this._children.delete(namespace);
            }
            else {
                throw new Error('Child is not empty and cannot be removed');
            }
        });
        this._unregisterAllEvents();
    }
    _addEventListener(type, callback, options) {
        let listenersMap = this._eventListeners.get(type);
        if (!listenersMap) {
            listenersMap = new Map();
            this._eventListeners.set(type, listenersMap);
        }
        const useCapture = options?.capture ?? false;
        const listenerPhase = useCapture
            ? EventListenerPhases.Capture
            : EventListenerPhases.Bubble;
        const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;
        if (registeredPhases & listenerPhase) {
            console.warn('A listener is already registered for this phase');
            return;
        }
        listenersMap.set(callback, registeredPhases | listenerPhase);
        this._target.addEventListener(type, callback, options);
    }
    _removeEventListener(type, callback, options) {
        const useCapture = options?.capture ?? false;
        const listenerPhase = useCapture
            ? EventListenerPhases.Capture
            : EventListenerPhases.Bubble;
        const listenersMap = this._eventListeners.get(type);
        if (!listenersMap) {
            return;
        }
        const callbacks = callback ? [callback] : Array.from(listenersMap.keys());
        callbacks.forEach((callbackItem) => {
            const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;
            const phaseRegistered = !!(registeredPhases & listenerPhase);
            if (!phaseRegistered) {
                return;
            }
            this._target.removeEventListener(type, callbackItem, options);
            const newListenerPhase = registeredPhases ^ listenerPhase;
            if (newListenerPhase === EventListenerPhases.None) {
                listenersMap.delete(callbackItem);
            }
            else {
                listenersMap.set(callbackItem, newListenerPhase);
            }
        });
        if (!listenersMap.size) {
            this._eventListeners.delete(type);
        }
    }
    _unregisterAllListeners(type, listenersMap) {
        Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {
            const startPhase = EventListenerPhases.Capture;
            for (let currentPhase = startPhase; eventPhases; currentPhase <<= 1) {
                if (!(eventPhases & currentPhase)) {
                    continue;
                }
                const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;
                this.removeEventListener(type, listener, { capture: useCapture });
                eventPhases ^= currentPhase;
            }
        });
    }
    _unregisterAllEvents() {
        Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {
            this._unregisterAllListeners(type, listenersMap);
        });
    }
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js

class MultiTargetEventListenerManager {
    constructor() {
        this._targetsEventListeners = new Map();
    }
    addEventListener(target, type, callback, options) {
        let eventListeners = this._targetsEventListeners.get(target);
        if (!eventListeners) {
            eventListeners = new TargetEventListeners(target);
            this._targetsEventListeners.set(target, eventListeners);
        }
        eventListeners.addEventListener(type, callback, options);
    }
    removeEventListener(target, type, callback, options) {
        const eventListeners = this._targetsEventListeners.get(target);
        if (!eventListeners) {
            return;
        }
        eventListeners.removeEventListener(type, callback, options);
        if (eventListeners.isEmpty) {
            this._targetsEventListeners.delete(target);
        }
    }
    reset() {
        Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {
            targetEventListeners.reset();
            this._targetsEventListeners.delete(target);
        });
    }
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/index.js



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js
var invertRgbTransferFunction = __webpack_require__(50134);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js
var createSigmoidRGBTransferFunction = __webpack_require__(40256);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js
var getVoiFromSigmoidRGBTransferFunction = __webpack_require__(70210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js
var createLinearRGBTransferFunction = __webpack_require__(74657);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js
function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {
    const size = rgbTransferFunction.getSize();
    for (let index = 0; index < size; index++) {
        const nodeValue1 = [];
        rgbTransferFunction.getNodeValue(index, nodeValue1);
        nodeValue1[1] = nodeValue1[1] * scalingFactor;
        nodeValue1[2] = nodeValue1[2] * scalingFactor;
        nodeValue1[3] = nodeValue1[3] * scalingFactor;
        rgbTransferFunction.setNodeValue(index, nodeValue1);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js
function getMinMax(storedPixelData) {
    let min = storedPixelData[0];
    let max = storedPixelData[0];
    let storedPixel;
    const numPixels = storedPixelData.length;
    for (let index = 1; index < numPixels; index++) {
        storedPixel = storedPixelData[index];
        min = Math.min(min, storedPixel);
        max = Math.max(max, storedPixel);
    }
    return {
        min,
        max,
    };
}

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js
const LAST_RUNTIME_ID = Symbol('LastRuntimeId');
const GLOBAL_CONTEXT = {};
const DEFAULT_MAX = 0xffffffff;
const DEFAULT_SEPARATOR = '-';
function getRuntimeId(context, separator, max) {
    return getNextRuntimeId(context !== null && typeof context === 'object' ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max === 'number' && max > 0 ? max : DEFAULT_MAX) >>> 0).join(typeof separator === 'string' ? separator : DEFAULT_SEPARATOR);
}
function getNextRuntimeId(context, symbol, max) {
    let idComponents = context[symbol];
    if (!(idComponents instanceof Array)) {
        idComponents = [0];
        Object.defineProperty(context, symbol, { value: idComponents });
    }
    for (let carry = true, i = 0; carry && i < idComponents.length; ++i) {
        let n = idComponents[i] | 0;
        if (n < max) {
            carry = false;
            n = n + 1;
        }
        else {
            n = 0;
            if (i + 1 === idComponents.length) {
                idComponents.push(0);
            }
        }
        idComponents[i] = n;
    }
    return idComponents;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js
var imageIdToURI = __webpack_require__(39537);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js

const state = {};
const metadataProvider = {
    add: (imageId, payload) => {
        const imageURI = (0,imageIdToURI/* default */.A)(imageId);
        state[imageURI] = payload;
    },
    get: (type, imageId) => {
        if (type === 'calibratedPixelSpacing') {
            const imageURI = (0,imageIdToURI/* default */.A)(imageId);
            return state[imageURI];
        }
    },
};
/* harmony default export */ const calibratedPixelSpacingMetadataProvider = (metadataProvider);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js
var clamp = __webpack_require__(84061);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js
function isOpposite(v1, v2, tolerance = 1e-5) {
    return (Math.abs(v1[0] + v2[0]) < tolerance &&
        Math.abs(v1[1] + v2[1]) < tolerance &&
        Math.abs(v1[2] + v2[2]) < tolerance);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
var getClosestImageId = __webpack_require__(88619);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
var getSpacingInNormalDirection = __webpack_require__(85008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js
var getTargetVolumeAndSpacingInNormalDir = __webpack_require__(65292);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js
var getVolumeActorCorners = __webpack_require__(15105);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js
function indexWithinDimensions(index, dimensions) {
    if (index[0] < 0 ||
        index[0] >= dimensions[0] ||
        index[1] < 0 ||
        index[1] >= dimensions[1] ||
        index[2] < 0 ||
        index[2] >= dimensions[2]) {
        return false;
    }
    return true;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
var getRenderingEngine = __webpack_require__(39536);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js

function getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {
    let renderingEngines;
    if (renderingEngineId) {
        renderingEngines = [(0,getRenderingEngine/* getRenderingEngine */.lD)(renderingEngineId)];
    }
    else {
        renderingEngines = (0,getRenderingEngine/* getRenderingEngines */.qO)();
    }
    const sameVolumesViewports = [];
    renderingEngines.forEach((renderingEngine) => {
        const targetActors = targetViewport.getActors();
        const viewports = renderingEngine.getVolumeViewports();
        for (const vp of viewports) {
            const vpActors = vp.getActors();
            if (vpActors.length !== targetActors.length) {
                continue;
            }
            const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));
            if (sameVolumes) {
                sameVolumesViewports.push(vp);
            }
        }
    });
    return sameVolumesViewports;
}
/* harmony default export */ const utilities_getVolumeViewportsContainingSameVolumes = (getVolumeViewportsContainingSameVolumes);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js
var getViewportsWithVolumeId = __webpack_require__(24724);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js
var transformWorldToIndex = __webpack_require__(38669);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js
var transformIndexToWorld = __webpack_require__(94741);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/TiledRenderingEngine.js
var TiledRenderingEngine = __webpack_require__(54072);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js
const isPTPrescaledWithSUV = (image) => {
    return image.preScale.scaled && image.preScale.scalingParameters.suvbw;
};
/* harmony default export */ const utilities_isPTPrescaledWithSUV = (isPTPrescaledWithSUV);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js






function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = '_thumbnails', viewportOptions = {
    displayArea: { imageArea: [1, 1] },
}) {
    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
        throw new Error('canvas element is required');
    }
    const isVolume = !imageOrVolume.imageId;
    const image = !isVolume && imageOrVolume;
    const volume = isVolume && imageOrVolume;
    const imageIdToPrint = image.imageId || volume.volumeId;
    const viewportId = `renderGPUViewport-${imageIdToPrint}`;
    const element = document.createElement('div');
    const devicePixelRatio = window.devicePixelRatio || 1;
    if (!viewportOptions.displayArea) {
        viewportOptions.displayArea = { imageArea: [1, 1] };
    }
    const originalWidth = canvas.width;
    const originalHeight = canvas.height;
    element.style.width = `${originalWidth / devicePixelRatio + getOrCreateCanvas/* EPSILON */.p8}px`;
    element.style.height = `${originalHeight / devicePixelRatio + getOrCreateCanvas/* EPSILON */.p8}px`;
    element.style.visibility = 'hidden';
    element.style.position = 'absolute';
    document.body.appendChild(element);
    const uniqueId = viewportId.split(':').join('-');
    element.setAttribute('viewport-id-for-remove', uniqueId);
    const temporaryCanvas = (0,getOrCreateCanvas/* default */.Ay)(element);
    const renderingEngine = (0,getRenderingEngine/* getRenderingEngine */.lD)(renderingEngineId) ||
        new TiledRenderingEngine/* default */.A(renderingEngineId);
    let viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
        const viewportInput = {
            viewportId,
            type: isVolume ? enums.ViewportType.ORTHOGRAPHIC : enums.ViewportType.STACK,
            element,
            defaultOptions: {
                ...viewportOptions,
                suppressEvents: true,
            },
        };
        renderingEngine.enableElement(viewportInput);
        viewport = renderingEngine.getViewport(viewportId);
    }
    return new Promise((resolve) => {
        let elementRendered = false;
        let { viewReference } = viewportOptions;
        const onImageRendered = (eventDetail) => {
            if (elementRendered) {
                return;
            }
            if (viewReference) {
                const useViewRef = viewReference;
                viewReference = null;
                viewport.setViewReference(useViewRef);
                viewport.render();
                return;
            }
            const context = canvas.getContext('2d');
            context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);
            const origin = viewport.canvasToWorld([0, 0]);
            const topRight = viewport.canvasToWorld([
                temporaryCanvas.width / devicePixelRatio,
                0,
            ]);
            const bottomLeft = viewport.canvasToWorld([
                0,
                temporaryCanvas.height / devicePixelRatio,
            ]);
            const rightVector = esm/* vec3.sub */.eR.sub([0, 0, 0], viewport.canvasToWorld([1 / devicePixelRatio, 0]), origin);
            const downVector = esm/* vec3.sub */.eR.sub([0, 0, 0], viewport.canvasToWorld([0, 1 / devicePixelRatio]), origin);
            const thicknessMm = 1;
            elementRendered = true;
            element.removeEventListener(enums.Events.IMAGE_RENDERED, onImageRendered);
            setTimeout(() => {
                renderingEngine.disableElement(viewportId);
                const elements = document.querySelectorAll(`[viewport-id-for-remove="${uniqueId}"]`);
                elements.forEach((element) => {
                    element.remove();
                });
            }, 0);
            resolve({
                origin,
                bottomLeft,
                topRight,
                thicknessMm,
                rightVector,
                downVector,
            });
        };
        element.addEventListener(enums.Events.IMAGE_RENDERED, onImageRendered);
        if (isVolume) {
            viewport.setVolumes([volume], false, true);
        }
        else {
            viewport.renderImageObject(imageOrVolume);
        }
        viewport.resetCamera();
        if (modality === 'PT' && !utilities_isPTPrescaledWithSUV(image)) {
            viewport.setProperties({
                voiRange: {
                    lower: image.minPixelValue,
                    upper: image.maxPixelValue,
                },
            });
        }
        viewport.render();
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js
var getDefaultViewport = __webpack_require__(36931);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js
var calculateTransform = __webpack_require__(7808);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js
var drawImageSync = __webpack_require__(5057);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js



function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {
    const volume = imageOrVolume;
    if (volume.volumeId) {
        throw new Error('Unsupported volume rendering for CPU');
    }
    const image = imageOrVolume;
    const viewport = (0,getDefaultViewport/* default */.A)(canvas, image, modality);
    const enabledElement = {
        canvas,
        viewport,
        image,
        renderingTools: {},
    };
    enabledElement.transform = (0,calculateTransform/* default */.A)(enabledElement);
    const invalidated = true;
    return new Promise((resolve, reject) => {
        (0,drawImageSync/* default */.A)(enabledElement, invalidated);
        resolve(null);
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js







function loadImageToCanvas(options) {
    const { canvas, imageId, viewReference, requestType = enums.RequestType.Thumbnail, priority = -5, renderingEngineId = '_thumbnails', useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions, } = options;
    const volumeId = viewReference?.volumeId;
    const isVolume = volumeId && !imageId;
    const viewportOptions = viewReference && baseViewportOptions
        ? { ...baseViewportOptions, viewReference }
        : baseViewportOptions;
    const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;
    return new Promise((resolve, reject) => {
        function successCallback(imageOrVolume, imageId) {
            const { modality } = metaData.get('generalSeriesModule', imageId) || {};
            const image = !isVolume && imageOrVolume;
            const volume = isVolume && imageOrVolume;
            if (image) {
                image.isPreScaled = image.isPreScaled || image.preScale?.scaled;
            }
            if (thumbnail) {
                canvas.height = 256;
                canvas.width = 256;
            }
            if (imageAspect && image) {
                canvas.width = image && (canvas.height * image.width) / image.height;
            }
            canvas.style.width = `${canvas.width / devicePixelRatio}px`;
            canvas.style.height = `${canvas.height / devicePixelRatio}px`;
            if (volume && useCPURendering) {
                reject(new Error('CPU rendering of volume not supported'));
            }
            renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);
        }
        function errorCallback(error, imageId) {
            console.error(error, imageId);
            reject(error);
        }
        function sendRequest(imageId, imageIdIndex, options) {
            return (0,imageLoader.loadAndCacheImage)(imageId, options).then((image) => {
                successCallback.call(this, image, imageId);
            }, (error) => {
                errorCallback.call(this, error, imageId);
            });
        }
        const options = {
            useRGBA: !!useCPURendering,
            requestType,
        };
        if (volumeId) {
            const volume = cache/* default */.Ay.getVolume(volumeId);
            if (!volume) {
                reject(new Error(`Volume id ${volumeId} not found in cache`));
            }
            const useImageId = volume.imageIds[0];
            successCallback(volume, useImageId);
        }
        else {
            imageLoadPoolManager/* default */.A.addRequest(sendRequest.bind(null, imageId, null, options), requestType, { imageId }, priority);
        }
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/asArray.js
function asArray(item) {
    if (Array.isArray(item)) {
        return item;
    }
    return [item];
}

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js


const Events = {
    HISTORY_UNDO: 'CORNERSTONE_TOOLS_HISTORY_UNDO',
    HISTORY_REDO: 'CORNERSTONE_TOOLS_HISTORY_REDO',
};
class HistoryMemo {
    constructor(label = 'Tools', size = 50) {
        this.position = -1;
        this.redoAvailable = 0;
        this.undoAvailable = 0;
        this.ring = new Array();
        this.isRecordingGrouped = false;
        this.label = label;
        this._size = size;
    }
    get size() {
        return this._size;
    }
    set size(newSize) {
        this.ring = new Array(newSize);
        this._size = newSize;
        this.position = -1;
        this.redoAvailable = 0;
        this.undoAvailable = 0;
    }
    get canUndo() {
        return this.undoAvailable > 0;
    }
    get canRedo() {
        return this.redoAvailable > 0;
    }
    undo(items = 1) {
        while (items > 0 && this.undoAvailable > 0) {
            const item = this.ring[this.position];
            for (const subitem of asArray(item).reverse()) {
                subitem.restoreMemo(true);
                this.dispatchHistoryEvent({ item: subitem, isUndo: true });
            }
            items--;
            this.redoAvailable++;
            this.undoAvailable--;
            this.position = (this.position - 1 + this.size) % this.size;
        }
    }
    undoIf(condition) {
        if (this.undoAvailable > 0 && condition(this.ring[this.position])) {
            this.undo();
            return true;
        }
        return false;
    }
    dispatchHistoryEvent({ item, isUndo }) {
        if (item.id) {
            eventTarget/* default */.A.dispatchEvent(new CustomEvent(isUndo ? Events.HISTORY_UNDO : Events.HISTORY_REDO, {
                detail: {
                    isUndo,
                    id: item.id,
                    operationType: item.operationType || 'annotation',
                    memo: item,
                },
            }));
        }
    }
    redo(items = 1) {
        while (items > 0 && this.redoAvailable > 0) {
            const newPosition = (this.position + 1) % this.size;
            const item = this.ring[newPosition];
            for (const subitem of asArray(item).reverse()) {
                subitem.restoreMemo(false);
                this.dispatchHistoryEvent({ item: subitem, isUndo: false });
            }
            items--;
            this.position = newPosition;
            this.undoAvailable++;
            this.redoAvailable--;
        }
    }
    initializeGroupItem() {
        this.redoAvailable = 0;
        if (this.undoAvailable < this._size) {
            this.undoAvailable++;
        }
        this.position = (this.position + 1) % this._size;
        this.ring[this.position] = [];
    }
    startGroupRecording() {
        this.isRecordingGrouped = true;
        this.initializeGroupItem();
    }
    rollbackUnusedGroupItem() {
        this.ring[this.position] = undefined;
        this.position = (this.position - 1) % this._size;
        this.undoAvailable--;
    }
    endGroupRecording() {
        this.isRecordingGrouped = false;
        const lastItem = this.ring[this.position];
        const lastItemIsEmpty = Array.isArray(lastItem) && lastItem.length === 0;
        if (lastItemIsEmpty) {
            this.rollbackUnusedGroupItem();
        }
    }
    pushGrouped(memo) {
        const lastMemo = this.ring[this.position];
        if (Array.isArray(lastMemo)) {
            lastMemo.push(memo);
            return memo;
        }
        throw new Error('Last item should be an array for grouped memos.');
    }
    push(item) {
        if (!item) {
            return;
        }
        const memo = item.restoreMemo
            ? item
            : item.createMemo?.();
        if (!memo) {
            return;
        }
        if (this.isRecordingGrouped) {
            return this.pushGrouped(memo);
        }
        this.redoAvailable = 0;
        if (this.undoAvailable < this._size) {
            this.undoAvailable++;
        }
        this.position = (this.position + 1) % this._size;
        this.ring[this.position] = memo;
        return memo;
    }
}
const DefaultHistoryMemo = new HistoryMemo();


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js


function worldToImageCoords(imageId, worldCoords) {
    const imagePlaneModule = (0,metaData.get)('imagePlaneModule', imageId);
    if (!imagePlaneModule) {
        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);
    }
    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;
    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;
    columnPixelSpacing ||= 1;
    rowPixelSpacing ||= 1;
    const newOrigin = esm/* vec3.create */.eR.create();
    esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);
    esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);
    const sub = esm/* vec3.create */.eR.create();
    esm/* vec3.sub */.eR.sub(sub, worldCoords, newOrigin);
    const rowDistance = esm/* vec3.dot */.eR.dot(sub, rowCosines);
    const columnDistance = esm/* vec3.dot */.eR.dot(sub, columnCosines);
    const imageCoords = [
        rowDistance / rowPixelSpacing,
        columnDistance / columnPixelSpacing,
    ];
    return imageCoords;
}
/* harmony default export */ const utilities_worldToImageCoords = (worldToImageCoords);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js


function imageToWorldCoords(imageId, imageCoords) {
    const imagePlaneModule = (0,metaData.get)('imagePlaneModule', imageId);
    if (!imagePlaneModule) {
        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);
    }
    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;
    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;
    columnPixelSpacing ||= 1;
    rowPixelSpacing ||= 1;
    const imageCoordsInWorld = esm/* vec3.create */.eR.create();
    esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));
    esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));
    return Array.from(imageCoordsInWorld);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js
var getVolumeSliceRangeInfo = __webpack_require__(4031);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js
var getVolumeViewportScrollInfo = __webpack_require__(61375);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js
var getSliceRange = __webpack_require__(20537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js
var snapFocalPointToSlice = __webpack_require__(80500);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js
var getImageSliceDataForVolumeViewport = __webpack_require__(47476);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
var actorCheck = __webpack_require__(98039);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js

function getViewportsWithImageURI(imageURI) {
    const renderingEngines = (0,getRenderingEngine/* getRenderingEngines */.qO)();
    const viewports = [];
    renderingEngines.forEach((renderingEngine) => {
        const viewportsForRenderingEngine = renderingEngine.getViewports();
        viewportsForRenderingEngine.forEach((viewport) => {
            if (viewport.hasImageURI(imageURI)) {
                viewports.push(viewport);
            }
        });
    });
    return viewports;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js
var planar = __webpack_require__(52268);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js



function getClosestStackImageIndexForPoint(point, viewport) {
    const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);
    return minimalDistance ? minimalDistance.index : null;
}
function calculateMinimalDistanceForStackViewport(point, viewport) {
    const imageIds = viewport.getImageIds();
    const currentImageIdIndex = viewport.getCurrentImageIdIndex();
    if (imageIds.length === 0) {
        return null;
    }
    const getDistance = (imageId) => {
        const planeMetadata = getPlaneMetadata(imageId);
        if (!planeMetadata) {
            return null;
        }
        const plane = planar.planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);
        const distance = planar.planeDistanceToPoint(plane, point);
        return distance;
    };
    const closestStack = {
        distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,
        index: currentImageIdIndex,
    };
    const higherImageIds = imageIds.slice(currentImageIdIndex + 1);
    for (let i = 0; i < higherImageIds.length; i++) {
        const id = higherImageIds[i];
        const distance = getDistance(id);
        if (distance === null) {
            continue;
        }
        if (distance <= closestStack.distance) {
            closestStack.distance = distance;
            closestStack.index = i + currentImageIdIndex + 1;
        }
        else {
            break;
        }
    }
    const lowerImageIds = imageIds.slice(0, currentImageIdIndex);
    for (let i = lowerImageIds.length - 1; i >= 0; i--) {
        const id = lowerImageIds[i];
        const distance = getDistance(id);
        if (distance === null || distance === closestStack.distance) {
            continue;
        }
        if (distance < closestStack.distance) {
            closestStack.distance = distance;
            closestStack.index = i;
        }
        else {
            break;
        }
    }
    return closestStack.distance === Infinity ? null : closestStack;
}
function getPlaneMetadata(imageId) {
    const targetImagePlane = metaData.get('imagePlaneModule', imageId);
    if (!targetImagePlane ||
        !(targetImagePlane.rowCosines instanceof Array &&
            targetImagePlane.rowCosines.length === 3) ||
        !(targetImagePlane.columnCosines instanceof Array &&
            targetImagePlane.columnCosines.length === 3) ||
        !(targetImagePlane.imagePositionPatient instanceof Array &&
            targetImagePlane.imagePositionPatient.length === 3)) {
        return null;
    }
    const { rowCosines, columnCosines, imagePositionPatient, } = targetImagePlane;
    const rowVec = esm/* vec3.set */.eR.set(esm/* vec3.create */.eR.create(), ...rowCosines);
    const colVec = esm/* vec3.set */.eR.set(esm/* vec3.create */.eR.create(), ...columnCosines);
    const planeNormal = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), rowVec, colVec);
    return { rowCosines, columnCosines, imagePositionPatient, planeNormal };
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js
var transformCanvasToIJK = __webpack_require__(51919);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js


function getCurrentVolumeViewportSlice(viewport) {
    const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();
    const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();
    const ijkOriginPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(viewport, [0, 0]);
    const ijkRowPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(viewport, [canvasWidth - 1, 0]);
    const ijkColPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(viewport, [0, canvasHeight - 1]);
    const ijkRowVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkRowPoint, ijkOriginPoint);
    const ijkColVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkColPoint, ijkOriginPoint);
    const ijkSliceVec = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), ijkRowVec, ijkColVec);
    esm/* vec3.normalize */.eR.normalize(ijkRowVec, ijkRowVec);
    esm/* vec3.normalize */.eR.normalize(ijkColVec, ijkColVec);
    esm/* vec3.normalize */.eR.normalize(ijkSliceVec, ijkSliceVec);
    const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));
    const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));
    if (!esm/* glMatrix.equals */.Fd.equals(1, maxIJKRowVec) || !esm/* glMatrix.equals */.Fd.equals(1, maxIJKColVec)) {
        throw new Error('Livewire is not available for rotate/oblique viewports');
    }
    const { voxelManager } = viewport.getImageData();
    const sliceViewInfo = viewport.getSliceViewInfo();
    const scalarData = voxelManager.getSliceData(sliceViewInfo);
    return {
        width: sliceViewInfo.width,
        height: sliceViewInfo.height,
        scalarData,
        sliceToIndexMatrix,
        indexToSliceMatrix,
    };
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js


const spatialRegistrationMetadataProvider_state = {};
const spatialRegistrationMetadataProvider = {
    add: (query, payload) => {
        const [viewportId1, viewportId2] = query;
        const entryId = `${viewportId1}_${viewportId2}`;
        if (!spatialRegistrationMetadataProvider_state[entryId]) {
            spatialRegistrationMetadataProvider_state[entryId] = {};
        }
        spatialRegistrationMetadataProvider_state[entryId] = payload;
    },
    get: (type, viewportId1, viewportId2) => {
        if (type !== 'spatialRegistrationModule') {
            return;
        }
        const entryId = `${viewportId1}_${viewportId2}`;
        if (spatialRegistrationMetadataProvider_state[entryId]) {
            return spatialRegistrationMetadataProvider_state[entryId];
        }
        const entryIdReverse = `${viewportId2}_${viewportId1}`;
        if (spatialRegistrationMetadataProvider_state[entryIdReverse]) {
            return esm/* mat4.invert */.pB.invert(esm/* mat4.create */.pB.create(), spatialRegistrationMetadataProvider_state[entryIdReverse]);
        }
    },
};
(0,metaData.addProvider)(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));
/* harmony default export */ const utilities_spatialRegistrationMetadataProvider = (spatialRegistrationMetadataProvider);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js



const ALLOWED_DELTA = 0.05;
function calculateViewportsSpatialRegistration(viewport1, viewport2) {
    const imageId1 = viewport1.getSliceIndex();
    const imageId2 = viewport2.getSliceIndex();
    const imagePlaneModule1 = (0,metaData.get)('imagePlaneModule', imageId1.toString());
    const imagePlaneModule2 = (0,metaData.get)('imagePlaneModule', imageId2.toString());
    if (!imagePlaneModule1 || !imagePlaneModule2) {
        console.log('Viewport spatial registration requires image plane module');
        return;
    }
    const { imageOrientationPatient: iop2 } = imagePlaneModule2;
    const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);
    if (!isSameImagePlane) {
        console.log('Viewport spatial registration only supported for same orientation (hence translation only) for now', imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);
        return;
    }
    const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;
    const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;
    const translation = esm/* vec3.subtract */.eR.subtract(esm/* vec3.create */.eR.create(), imagePositionPatient1, imagePositionPatient2);
    const mat = esm/* mat4.fromTranslation */.pB.fromTranslation(esm/* mat4.create */.pB.create(), translation);
    utilities_spatialRegistrationMetadataProvider.add([viewport1.id, viewport2.id], mat);
}
/* harmony default export */ const utilities_calculateViewportsSpatialRegistration = (calculateViewportsSpatialRegistration);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js
function getViewportImageCornersInWorld(viewport) {
    const { imageData, dimensions } = viewport.getImageData() || {};
    if (!imageData || !dimensions) {
        return [];
    }
    const { canvas } = viewport;
    const ratio = window.devicePixelRatio;
    const topLeftCanvas = [0, 0];
    const topRightCanvas = [canvas.width / ratio, 0];
    const bottomRightCanvas = [
        canvas.width / ratio,
        canvas.height / ratio,
    ];
    const bottomLeftCanvas = [0, canvas.height / ratio];
    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
    const topRightWorld = viewport.canvasToWorld(topRightCanvas);
    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
    const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);
    const topLeftImage = imageData.worldToIndex(topLeftWorld);
    const topRightImage = imageData.worldToIndex(topRightWorld);
    const bottomRightImage = imageData.worldToIndex(bottomRightWorld);
    const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);
    return _getStackViewportImageCorners({
        dimensions,
        imageData,
        topLeftImage,
        topRightImage,
        bottomRightImage,
        bottomLeftImage,
        topLeftWorld,
        topRightWorld,
        bottomRightWorld,
        bottomLeftWorld,
    });
}
function _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld, }) {
    const topLeftImageWorld = _isInBounds(topLeftImage, dimensions)
        ? topLeftWorld
        : imageData.indexToWorld([0, 0, 0]);
    const topRightImageWorld = _isInBounds(topRightImage, dimensions)
        ? topRightWorld
        : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);
    const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions)
        ? bottomRightWorld
        : imageData.indexToWorld([
            dimensions[0] - 1,
            dimensions[1] - 1,
            0,
        ]);
    const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions)
        ? bottomLeftWorld
        : imageData.indexToWorld([0, dimensions[1] - 1, 0]);
    return [
        topLeftImageWorld,
        topRightImageWorld,
        bottomLeftImageWorld,
        bottomRightImageWorld,
    ];
}
function _isInBounds(imageCoord, dimensions) {
    return (imageCoord[0] > 0 ||
        imageCoord[0] < dimensions[0] - 1 ||
        imageCoord[1] > 0 ||
        imageCoord[1] < dimensions[1] - 1 ||
        imageCoord[2] > 0 ||
        imageCoord[2] < dimensions[2] - 1);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js
var hasNaNValues = __webpack_require__(38883);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js
var applyPreset = __webpack_require__(96833);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js
var PointsManager = __webpack_require__(13876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepMerge.js
var deepMerge = __webpack_require__(74268);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js
var getScalingParameters = __webpack_require__(32173);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js + 14 modules
var StackViewport = __webpack_require__(79720);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/getEnabledElement.js
var getEnabledElement = __webpack_require__(86846);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js


function getImageLegacy(element) {
    const enabledElement = (0,getEnabledElement/* default */.Ay)(element);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    if (!(viewport instanceof StackViewport/* default */.A)) {
        throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);
    }
    return viewport.getCornerstoneImage();
}
/* harmony default export */ const utilities_getImageLegacy = (getImageLegacy);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js
var sortImageIdsAndGetSpacing = __webpack_require__(90537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js
var makeVolumeMetadata = __webpack_require__(1865);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/genericMetadataProvider.js
var genericMetadataProvider = __webpack_require__(27119);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js
var isEqual = __webpack_require__(74638);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js


function isValidVolume(imageIds) {
    if (imageIds.length <= 1) {
        return false;
    }
    const imageId0 = imageIds[0];
    const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId0);
    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, usingDefaultValues, } = metaData.get('imagePlaneModule', imageId0);
    if (usingDefaultValues) {
        return false;
    }
    const baseMetadata = {
        modality,
        imageOrientationPatient,
        pixelSpacing,
        frameOfReferenceUID,
        columns,
        rows,
        seriesInstanceUID,
    };
    let validVolume = true;
    for (let i = 0; i < imageIds.length; i++) {
        const imageId = imageIds[i];
        const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId);
        const { imageOrientationPatient, pixelSpacing, columns, rows } = metaData.get('imagePlaneModule', imageId);
        if (seriesInstanceUID !== baseMetadata.seriesInstanceUID) {
            validVolume = false;
            break;
        }
        if (modality !== baseMetadata.modality) {
            validVolume = false;
            break;
        }
        if (columns !== baseMetadata.columns) {
            validVolume = false;
            break;
        }
        if (rows !== baseMetadata.rows) {
            validVolume = false;
            break;
        }
        if (!(0,isEqual/* default */.Ay)(imageOrientationPatient, baseMetadata.imageOrientationPatient)) {
            validVolume = false;
            break;
        }
        if (!(0,isEqual/* default */.Ay)(pixelSpacing, baseMetadata.pixelSpacing)) {
            validVolume = false;
            break;
        }
    }
    return validVolume;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js
var updateVTKImageDataWithCornerstoneImage = __webpack_require__(45278);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js
var ProgressiveIterator = __webpack_require__(22191);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js
var decimate = __webpack_require__(63470);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js
var imageRetrieveMetadataProvider = __webpack_require__(17791);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js
const videoUIDs = new Set([
    '1.2.840.10008.1.2.4.100',
    '1.2.840.10008.1.2.4.100.1',
    '1.2.840.10008.1.2.4.101',
    '1.2.840.10008.1.2.4.101.1',
    '1.2.840.10008.1.2.4.102',
    '1.2.840.10008.1.2.4.102.1',
    '1.2.840.10008.1.2.4.103',
    '1.2.840.10008.1.2.4.103.1',
    '1.2.840.10008.1.2.4.104',
    '1.2.840.10008.1.2.4.104.1',
    '1.2.840.10008.1.2.4.105',
    '1.2.840.10008.1.2.4.105.1',
    '1.2.840.10008.1.2.4.106',
    '1.2.840.10008.1.2.4.106.1',
    '1.2.840.10008.1.2.4.107',
    '1.2.840.10008.1.2.4.108',
]);
function isVideoTransferSyntax(uidOrUids) {
    if (!uidOrUids) {
        return false;
    }
    const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];
    return uids.find((uid) => videoUIDs.has(uid));
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getBufferConfiguration.js
var getBufferConfiguration = __webpack_require__(99576);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/generateVolumePropsFromImageIds.js
var generateVolumePropsFromImageIds = __webpack_require__(9734);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 3 modules
var helpers = __webpack_require__(40661);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js + 10 modules
var volumeLoader = __webpack_require__(87142);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js




async function convertStackToVolumeViewport({ viewport, options = {}, }) {
    const renderingEngine = viewport.getRenderingEngine();
    let volumeId = options.volumeId || `${(0,uuidv4/* default */.A)()}`;
    if (volumeId.split(':').length === 0) {
        const schema = (0,volumeLoader.getUnknownVolumeLoaderSchema)();
        volumeId = `${schema}:${volumeId}`;
    }
    const { id, element } = viewport;
    const viewportId = options.viewportId || id;
    const imageIds = viewport.getImageIds();
    const prevViewPresentation = viewport.getViewPresentation();
    const prevViewReference = viewport.getViewReference();
    renderingEngine.enableElement({
        viewportId,
        type: enums.ViewportType.ORTHOGRAPHIC,
        element,
        defaultOptions: {
            background: options.background,
            orientation: options.orientation,
        },
    });
    const volume = (await (0,volumeLoader.createAndCacheVolume)(volumeId, {
        imageIds,
    }));
    volume.load();
    const volumeViewport = renderingEngine.getViewport(viewportId);
    await (0,helpers/* setVolumesForViewports */.A7)(renderingEngine, [
        {
            volumeId,
        },
    ], [viewportId]);
    const volumeViewportNewVolumeHandler = () => {
        volumeViewport.render();
        element.removeEventListener(enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);
    };
    const addVolumeViewportNewVolumeListener = () => {
        element.addEventListener(enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);
    };
    addVolumeViewportNewVolumeListener();
    volumeViewport.setViewPresentation(prevViewPresentation);
    volumeViewport.setViewReference(prevViewReference);
    volumeViewport.render();
    return volumeViewport;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ImageVolume.js
var ImageVolume = __webpack_require__(86252);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js



async function convertVolumeToStackViewport({ viewport, options, }) {
    const volumeViewport = viewport;
    const { id, element } = volumeViewport;
    const renderingEngine = viewport.getRenderingEngine();
    const { background } = options;
    const viewportId = options.viewportId || id;
    const volume = cache/* default */.Ay.getVolume(volumeViewport.getVolumeId());
    if (!(volume instanceof ImageVolume/* ImageVolume */.Q)) {
        throw new Error('Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.');
    }
    const viewportInput = {
        viewportId,
        type: enums.ViewportType.STACK,
        element,
        defaultOptions: {
            background,
        },
    };
    const prevView = volumeViewport.getViewReference();
    renderingEngine.enableElement(viewportInput);
    const stackViewport = renderingEngine.getViewport(viewportId);
    await stackViewport.setStack(volume.imageIds);
    stackViewport.setViewReference(prevView);
    stackViewport.render();
    return stackViewport;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/VoxelManager.js
var VoxelManager = __webpack_require__(24623);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js
var RLEVoxelMap = __webpack_require__(67645);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 4 modules
var constants = __webpack_require__(76491);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js

function roundNumber(value, precision = 2) {
    if (Array.isArray(value)) {
        return value.map((v) => roundNumber(v, precision)).join(', ');
    }
    if (value === undefined || value === null || value === '') {
        return 'NaN';
    }
    value = Number(value);
    const absValue = Math.abs(value);
    if (absValue < 0.0001) {
        return `${value}`;
    }
    const fixedPrecision = absValue >= 100
        ? precision - 2
        : absValue >= 10
            ? precision - 1
            : absValue >= 1
                ? precision
                : absValue >= 0.1
                    ? precision + 1
                    : absValue >= 0.01
                        ? precision + 2
                        : absValue >= 0.001
                            ? precision + 3
                            : precision + 4;
    return value.toFixed(fixedPrecision);
}
function roundToPrecision(value) {
    return Math.round(value / constants.EPSILON) * constants.EPSILON;
}

/* harmony default export */ const utilities_roundNumber = (roundNumber);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js
function convertToGrayscale(scalarData, width, height) {
    const isRGBA = scalarData.length === width * height * 4;
    const isRGB = scalarData.length === width * height * 3;
    if (isRGBA || isRGB) {
        const newScalarData = new Float32Array(width * height);
        let offset = 0;
        let destOffset = 0;
        const increment = isRGBA ? 4 : 3;
        for (let x = 0; x < width; x++) {
            for (let y = 0; y < height; y++) {
                const r = scalarData[offset];
                const g = scalarData[offset + 1];
                const b = scalarData[offset + 2];
                newScalarData[destOffset] = (r + g + b) / 3;
                offset += increment;
                destOffset++;
            }
        }
        return newScalarData;
    }
    else {
        return scalarData;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/index.js + 3 modules
var RenderingEngine = __webpack_require__(90340);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js


function getViewportImageIds(viewport) {
    if (viewport instanceof RenderingEngine/* VolumeViewport */.PX) {
        const volume = cache/* default */.Ay.getVolume(viewport.getVolumeId());
        return volume.imageIds;
    }
    else if (viewport.getImageIds) {
        return viewport.getImageIds();
    }
}
/* harmony default export */ const utilities_getViewportImageIds = (getViewportImageIds);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js
function getRandomSampleFromArray(array, size) {
    const clonedArray = [...array];
    if (size >= clonedArray.length) {
        shuffleArray(clonedArray);
        return clonedArray;
    }
    shuffleArray(clonedArray);
    return clonedArray.slice(0, size);
}
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js
var getVolumeId = __webpack_require__(12437);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js
var hasFloatScalingParameters = __webpack_require__(30169);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
var pointInShapeCallback = __webpack_require__(56577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js
var windowLevel = __webpack_require__(68136);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js
var colormap = __webpack_require__(13859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var transferFunctionUtils = __webpack_require__(8126);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js
function componentToHex(c) {
    const hex = c.toString(16);
    return hex.length == 1 ? '0' + hex : hex;
}
function rgbToHex(r, g, b) {
    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        }
        : null;
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js
function deepEqual(obj1, obj2) {
    if (obj1 === obj2) {
        return true;
    }
    if (obj1 == null || obj2 == null) {
        return false;
    }
    try {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }
    catch (error) {
        console.debug('Error in JSON.stringify during deep comparison:', error);
        return obj1 === obj2;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js
var FrameRange = __webpack_require__(56750);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/fnv1aHash.js
var fnv1aHash = __webpack_require__(20286);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageDataMetadata.js
var getImageDataMetadata = __webpack_require__(53932);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/buildMetadata.js
var buildMetadata = __webpack_require__(89131);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js
function _getViewportModality(viewport, volumeId, getVolume) {
    if (!getVolume) {
        throw new Error('getVolume is required, use the utilities export instead ');
    }
    if (viewport.modality) {
        return viewport.modality;
    }
    if (viewport.setVolumes) {
        volumeId = volumeId ?? viewport.getVolumeId();
        if (!volumeId || !getVolume) {
            return;
        }
        const volume = getVolume(volumeId);
        return volume.metadata.Modality;
    }
    throw new Error('Invalid viewport type');
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js

const groupBy = (array, key) => {
    return array.reduce((rv, x) => {
        (rv[x[key]] = rv[x[key]] || []).push(x);
        return rv;
    }, {});
};
function getIPPGroups(imageIds) {
    const ippMetadata = imageIds.map((imageId) => {
        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId) || {};
        return { imageId, imagePositionPatient };
    });
    if (!ippMetadata.every((item) => item.imagePositionPatient)) {
        return null;
    }
    const positionGroups = groupBy(ippMetadata, 'imagePositionPatient');
    const positions = Object.keys(positionGroups);
    const frame_count = positionGroups[positions[0]].length;
    if (frame_count === 1) {
        return null;
    }
    const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);
    if (!frame_count_equal) {
        return null;
    }
    return positionGroups;
}
function test4DTag(IPPGroups, value_getter) {
    const frame_groups = {};
    let first_frame_value_set = [];
    const positions = Object.keys(IPPGroups);
    for (let i = 0; i < positions.length; i++) {
        const frame_value_set = new Set();
        const frames = IPPGroups[positions[i]];
        for (let j = 0; j < frames.length; j++) {
            const frame_value = value_getter(frames[j].imageId) || 0;
            frame_groups[frame_value] = frame_groups[frame_value] || [];
            frame_groups[frame_value].push({ imageId: frames[j].imageId });
            frame_value_set.add(frame_value);
            if (frame_value_set.size - 1 < j) {
                return undefined;
            }
        }
        if (i == 0) {
            first_frame_value_set = Array.from(frame_value_set);
        }
        else if (!setEquals(first_frame_value_set, frame_value_set)) {
            return undefined;
        }
    }
    return frame_groups;
}
function getTagValue(imageId, tag) {
    const value = metaData.get(tag, imageId);
    try {
        return parseFloat(value);
    }
    catch {
        return undefined;
    }
}
function getPhilipsPrivateBValue(imageId) {
    const value = metaData.get('20011003', imageId);
    try {
        const { InlineBinary } = value;
        if (InlineBinary) {
            const value_bytes = atob(InlineBinary);
            const ary_buf = new ArrayBuffer(value_bytes.length);
            const dv = new DataView(ary_buf);
            for (let i = 0; i < value_bytes.length; i++) {
                dv.setUint8(i, value_bytes.charCodeAt(i));
            }
            return new Float32Array(ary_buf)[0];
        }
        return parseFloat(value);
    }
    catch {
        return undefined;
    }
}
function getSiemensPrivateBValue(imageId) {
    let value = metaData.get('0019100c', imageId) || metaData.get('0019100C', imageId);
    try {
        const { InlineBinary } = value;
        if (InlineBinary) {
            value = atob(InlineBinary);
        }
        return parseFloat(value);
    }
    catch {
        return undefined;
    }
}
function getGEPrivateBValue(imageId) {
    let value = metaData.get('00431039', imageId);
    try {
        const { InlineBinary } = value;
        if (InlineBinary) {
            value = atob(InlineBinary).split('//');
        }
        return parseFloat(value[0]) % 100000;
    }
    catch {
        return undefined;
    }
}
function setEquals(set_a, set_b) {
    if (set_a.length != set_b.size) {
        return false;
    }
    for (let i = 0; i < set_a.length; i++) {
        if (!set_b.has(set_a[i])) {
            return false;
        }
    }
    return true;
}
function getPetFrameReferenceTime(imageId) {
    const moduleInfo = metaData.get('petImageModule', imageId);
    return moduleInfo ? moduleInfo['frameReferenceTime'] : 0;
}
function splitImageIdsBy4DTags(imageIds) {
    const positionGroups = getIPPGroups(imageIds);
    if (!positionGroups) {
        return { imageIdGroups: [imageIds], splittingTag: null };
    }
    const tags = [
        'TemporalPositionIdentifier',
        'DiffusionBValue',
        'TriggerTime',
        'EchoTime',
        'EchoNumber',
        'PhilipsPrivateBValue',
        'SiemensPrivateBValue',
        'GEPrivateBValue',
        'PetFrameReferenceTime',
    ];
    const fncList2 = [
        (imageId) => getTagValue(imageId, tags[0]),
        (imageId) => getTagValue(imageId, tags[1]),
        (imageId) => getTagValue(imageId, tags[2]),
        (imageId) => getTagValue(imageId, tags[3]),
        (imageId) => getTagValue(imageId, tags[4]),
        getPhilipsPrivateBValue,
        getSiemensPrivateBValue,
        getGEPrivateBValue,
        getPetFrameReferenceTime,
    ];
    for (let i = 0; i < fncList2.length; i++) {
        const frame_groups = test4DTag(positionGroups, fncList2[i]);
        if (frame_groups) {
            const sortedKeys = Object.keys(frame_groups)
                .map(Number.parseFloat)
                .sort((a, b) => a - b);
            const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));
            return { imageIdGroups, splittingTag: tags[i] };
        }
    }
    return { imageIdGroups: [imageIds], splittingTag: null };
}
/* harmony default export */ const utilities_splitImageIdsBy4DTags = (splitImageIdsBy4DTags);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js

function getDynamicVolumeInfo(imageIds) {
    const { imageIdGroups: timePoints, splittingTag } = utilities_splitImageIdsBy4DTags(imageIds);
    const isDynamicVolume = timePoints.length > 1;
    return { isDynamicVolume, timePoints, splittingTag };
}
/* harmony default export */ const utilities_getDynamicVolumeInfo = (getDynamicVolumeInfo);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js
var autoLoad = __webpack_require__(91979);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js
function scaleArray(array, scalingParameters) {
    const arrayLength = array.length;
    const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;
    if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {
        for (let i = 0; i < arrayLength; i++) {
            array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);
        }
    }
    else {
        for (let i = 0; i < arrayLength; i++) {
            array[i] = array[i] * rescaleSlope + rescaleIntercept;
        }
    }
    return array;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js
var deepClone = __webpack_require__(99949);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js
function clip(val, low, high) {
    return Math.min(Math.max(low, val), high);
}
function clipToBox(point, box) {
    point.x = clip(point.x, 0, box.width);
    point.y = clip(point.y, 0, box.height);
}
/* harmony default export */ const utilities_clip = (clip);

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js







function scroll_scroll(viewport, options) {
    const enabledElement = (0,getEnabledElement/* default */.Ay)(viewport.element);
    if (!enabledElement) {
        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');
    }
    if (viewport instanceof RenderingEngine/* StackViewport */.hS &&
        viewport.getImageIds().length === 0) {
        throw new Error('Scroll::Stack Viewport has no images');
    }
    const { volumeId, delta, scrollSlabs } = options;
    if (viewport instanceof RenderingEngine/* VolumeViewport */.PX) {
        scrollVolume(viewport, volumeId, delta, scrollSlabs);
    }
    else {
        const imageIdIndex = viewport.getCurrentImageIdIndex();
        if (imageIdIndex + delta >
            viewport.getImageIds().length - 1 ||
            imageIdIndex + delta < 0) {
            const eventData = {
                imageIdIndex,
                direction: delta,
            };
            (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.STACK_SCROLL_OUT_OF_BOUNDS, eventData);
        }
        viewport.scroll(delta, options.debounceLoading, options.loop);
    }
}
function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {
    const useSlabThickness = scrollSlabs;
    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = (0,getVolumeViewportScrollInfo/* default */.A)(viewport, volumeId, useSlabThickness);
    if (!sliceRangeInfo) {
        return;
    }
    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
    const { focalPoint, viewPlaneNormal, position } = camera;
    const { newFocalPoint, newPosition } = (0,snapFocalPointToSlice/* default */.A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
    viewport.setCamera({
        focalPoint: newFocalPoint,
        position: newPosition,
    });
    viewport.render();
    const desiredStepIndex = currentStepIndex + delta;
    const VolumeScrollEventDetail = {
        volumeId,
        viewport,
        delta,
        desiredStepIndex,
        currentStepIndex,
        numScrollSteps,
        currentImageId: viewport.getCurrentImageId(),
    };
    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&
        viewport.getCurrentImageId()) {
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);
    }
    else {
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);
    }
}

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js




async function jumpToSlice(element, options = {}) {
    const { imageIndex, debounceLoading, volumeId } = options;
    const enabledElement = (0,getEnabledElement/* default */.Ay)(element);
    if (!enabledElement) {
        throw new Error('Element has been disabled');
    }
    const { viewport } = enabledElement;
    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);
    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);
    const delta = imageIndexToJump - currentImageIndex;
    scroll_scroll(viewport, { delta, debounceLoading, volumeId });
}
function _getImageSliceData(viewport, debounceLoading) {
    if (viewport instanceof StackViewport/* default */.A) {
        return {
            numberOfSlices: viewport.getImageIds().length,
            imageIndex: debounceLoading
                ? viewport.getTargetImageIdIndex()
                : viewport.getCurrentImageIdIndex(),
        };
    }
    return {
        numberOfSlices: viewport.getNumberOfSlices(),
        imageIndex: viewport.getSliceIndex(),
    };
}
function _getImageIndexToJump(numberOfSlices, imageIndex) {
    const lastSliceIndex = numberOfSlices - 1;
    return utilities_clip(imageIndex, 0, lastSliceIndex);
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSubVolume.js





function createSubVolume(referencedVolumeId, boundsIJK, options = {}) {
    const referencedVolume = cache/* default */.Ay.getVolume(referencedVolumeId);
    if (!referencedVolume) {
        throw new Error(`Referenced volume with id ${referencedVolumeId} does not exist.`);
    }
    const { metadata, spacing, direction, dimensions: refVolumeDim, } = referencedVolume;
    const { minX, maxX, minY, maxY, minZ, maxZ } = boundsIJK;
    const ijkTopLeft = [
        Math.min(minX, maxX),
        Math.min(minY, maxY),
        Math.min(minZ, maxZ),
    ];
    const boundingBoxOriginWorld = (0,transformIndexToWorld/* default */.A)(referencedVolume.imageData, ijkTopLeft);
    const dimensions = [
        Math.abs(maxX - minX) + 1,
        Math.abs(maxY - minY) + 1,
        Math.abs(maxZ - minZ) + 1,
    ];
    const { targetBuffer } = options;
    const subVolumeOptions = {
        metadata,
        dimensions,
        spacing,
        origin: boundingBoxOriginWorld,
        direction,
        targetBuffer,
        scalarData: targetBuffer?.type === 'Float32Array'
            ? new Float32Array(dimensions[0] * dimensions[1] * dimensions[2])
            : undefined,
    };
    const subVolume = (0,volumeLoader.createLocalVolume)((0,uuidv4/* default */.A)(), subVolumeOptions);
    const subVolumeData = subVolume.voxelManager.getCompleteScalarDataArray();
    const subVolumeSliceSize = dimensions[0] * dimensions[1];
    const refVolumeSliceSize = refVolumeDim[0] * refVolumeDim[1];
    const refVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    for (let z = 0; z < dimensions[2]; z++) {
        for (let y = 0; y < dimensions[1]; y++) {
            const rowStartWorld = (0,transformIndexToWorld/* default */.A)(subVolume.imageData, [
                0,
                y,
                z,
            ]);
            const refVolumeRowStartIJK = (0,transformWorldToIndex/* default */.A)(referencedVolume.imageData, rowStartWorld);
            const refVolumeRowStartOffset = refVolumeRowStartIJK[2] * refVolumeSliceSize +
                refVolumeRowStartIJK[1] * refVolumeDim[0] +
                refVolumeRowStartIJK[0];
            const rowData = refVolumeData.slice(refVolumeRowStartOffset, refVolumeRowStartOffset + dimensions[0]);
            const subVolumeLineStartOffset = z * subVolumeSliceSize + y * dimensions[0];
            subVolumeData.set(rowData, subVolumeLineStartOffset);
        }
    }
    subVolume.voxelManager.setCompleteScalarDataArray(subVolumeData);
    return subVolume;
}


;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeDirectionVectors.js


function getVolumeDirectionVectors(imageData, camera) {
    const { viewUp, viewPlaneNormal } = camera;
    const ijkOrigin = (0,transformWorldToIndex/* transformWorldToIndexContinuous */.p)(imageData, [0, 0, 0]);
    const worldVecColDir = esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), viewUp);
    const worldVecSliceDir = esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), viewPlaneNormal);
    const worldVecRowDir = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), worldVecColDir, worldVecSliceDir);
    const ijkVecColDir = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), (0,transformWorldToIndex/* transformWorldToIndexContinuous */.p)(imageData, worldVecColDir), ijkOrigin);
    const ijkVecSliceDir = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), (0,transformWorldToIndex/* transformWorldToIndexContinuous */.p)(imageData, worldVecSliceDir), ijkOrigin);
    esm/* vec3.normalize */.eR.normalize(ijkVecColDir, ijkVecColDir);
    esm/* vec3.normalize */.eR.normalize(ijkVecSliceDir, ijkVecSliceDir);
    const ijkVecRowDir = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), ijkVecColDir, ijkVecSliceDir);
    return {
        worldVecRowDir,
        worldVecColDir,
        worldVecSliceDir,
        ijkVecRowDir,
        ijkVecColDir,
        ijkVecSliceDir,
    };
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateSpacingBetweenImageIds.js
var calculateSpacingBetweenImageIds = __webpack_require__(42384);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/logger.js
var logger = __webpack_require__(7608);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateNeighborhoodStats.js
function calculateNeighborhoodStats(scalarData, dimensions, centerIjk, radius) {
    const [width, height, numSlices] = dimensions;
    const numPixelsPerSlice = width * height;
    let sum = 0;
    let sumSq = 0;
    let count = 0;
    const [cx, cy, cz] = centerIjk.map(Math.round);
    for (let z = cz - radius; z <= cz + radius; z++) {
        if (z < 0 || z >= numSlices) {
            continue;
        }
        for (let y = cy - radius; y <= cy + radius; y++) {
            if (y < 0 || y >= height) {
                continue;
            }
            for (let x = cx - radius; x <= cx + radius; x++) {
                if (x < 0 || x >= width) {
                    continue;
                }
                const index = z * numPixelsPerSlice + y * width + x;
                const value = scalarData[index];
                sum += value;
                sumSq += value * value;
                count++;
            }
        }
    }
    if (count === 0) {
        const centerIndex = cz * numPixelsPerSlice + cy * width + cx;
        if (centerIndex >= 0 && centerIndex < scalarData.length) {
            const centerValue = scalarData[centerIndex];
            return { mean: centerValue, stdDev: 0, count: 1 };
        }
        else {
            return { mean: 0, stdDev: 0, count: 0 };
        }
    }
    const mean = sum / count;
    const variance = sumSq / count - mean * mean;
    const stdDev = Math.sqrt(Math.max(0, variance));
    return { mean, stdDev, count };
}

;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getPixelSpacingInformation.js


const projectionRadiographSOPClassUIDs = new Set([
    '1.2.840.10008.5.1.4.1.1.1',
    '1.2.840.10008.5.1.4.1.1.1.1',
    '1.2.840.10008.5.1.4.1.1.1.1.1',
    '1.2.840.10008.5.1.4.1.1.1.2',
    '1.2.840.10008.5.1.4.1.1.1.2.1',
    '1.2.840.10008.5.1.4.1.1.1.3',
    '1.2.840.10008.5.1.4.1.1.1.3.1',
    '1.2.840.10008.5.1.4.1.1.12.1',
    '1.2.840.10008.5.1.4.1.1.12.1.1',
    '1.2.840.10008.5.1.4.1.1.12.2',
    '1.2.840.10008.5.1.4.1.1.12.2.1',
    '1.2.840.10008.5.1.4.1.1.12.3',
]);
function calculateRadiographicPixelSpacing(instance) {
    const { PixelSpacing, ImagerPixelSpacing, EstimatedRadiographicMagnificationFactor, PixelSpacingCalibrationType, PixelSpacingCalibrationDescription, } = instance;
    const isProjection = true;
    if (!ImagerPixelSpacing) {
        return {
            PixelSpacing,
            type: enums.CalibrationTypes.UNKNOWN,
            isProjection,
        };
    }
    if (!PixelSpacing) {
        if (!EstimatedRadiographicMagnificationFactor) {
            console.warn('EstimatedRadiographicMagnificationFactor was not present. Unable to correct ImagerPixelSpacing.');
            return {
                PixelSpacing: ImagerPixelSpacing,
                type: enums.CalibrationTypes.PROJECTION,
                isProjection,
            };
        }
        const correctedPixelSpacing = ImagerPixelSpacing.map((pixelSpacing) => pixelSpacing / EstimatedRadiographicMagnificationFactor);
        return {
            PixelSpacing: correctedPixelSpacing,
            type: enums.CalibrationTypes.ERMF,
            isProjection,
        };
    }
    if ((0,isEqual/* isEqual */.n4)(PixelSpacing, ImagerPixelSpacing)) {
        return {
            PixelSpacing,
            type: enums.CalibrationTypes.PROJECTION,
            isProjection,
        };
    }
    if (PixelSpacingCalibrationType || PixelSpacingCalibrationDescription) {
        return {
            PixelSpacing,
            type: enums.CalibrationTypes.CALIBRATED,
            isProjection,
            PixelSpacingCalibrationType,
            PixelSpacingCalibrationDescription,
        };
    }
    return {
        PixelSpacing,
        type: enums.CalibrationTypes.UNKNOWN,
        isProjection,
    };
}
function calculateUSPixelSpacing(instance) {
    const { SequenceOfUltrasoundRegions } = instance;
    const isArrayOfSequences = Array.isArray(SequenceOfUltrasoundRegions);
    if (isArrayOfSequences && SequenceOfUltrasoundRegions.length > 1) {
        console.warn('Sequence of Ultrasound Regions > one entry. This is not yet implemented, all measurements will be shown in pixels.');
        return;
    }
    const { PhysicalDeltaX, PhysicalDeltaY } = isArrayOfSequences
        ? SequenceOfUltrasoundRegions[0]
        : SequenceOfUltrasoundRegions;
    const USPixelSpacing = [
        Math.abs(PhysicalDeltaX) * 10,
        Math.abs(PhysicalDeltaY) * 10,
    ];
    return {
        PixelSpacing: USPixelSpacing,
    };
}
function getPixelSpacingInformation(instance) {
    const { PixelSpacing, SOPClassUID, SequenceOfUltrasoundRegions } = instance;
    if (SequenceOfUltrasoundRegions) {
        return calculateUSPixelSpacing(instance);
    }
    const isProjection = projectionRadiographSOPClassUIDs.has(SOPClassUID);
    if (isProjection) {
        return calculateRadiographicPixelSpacing(instance);
    }
    return {
        PixelSpacing,
        type: enums.CalibrationTypes.NOT_APPLICABLE,
        isProjection: false,
    };
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updatePlaneRestriction.js
var updatePlaneRestriction = __webpack_require__(41365);
;// ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js


































































































const getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache/* default */.Ay.getVolume);




/***/ }),

/***/ 50134:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ invertRgbTransferFunction)
/* harmony export */ });
function invertRgbTransferFunction(rgbTransferFunction) {
    if (!rgbTransferFunction) {
        return;
    }
    const size = rgbTransferFunction.getSize();
    for (let index = 0; index < size; index++) {
        const nodeValue1 = [];
        rgbTransferFunction.getNodeValue(index, nodeValue1);
        nodeValue1[1] = 1 - nodeValue1[1];
        nodeValue1[2] = 1 - nodeValue1[2];
        nodeValue1[3] = 1 - nodeValue1[3];
        rgbTransferFunction.setNodeValue(index, nodeValue1);
    }
}


/***/ }),

/***/ 74638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   Et: () => (/* binding */ isNumber),
/* harmony export */   Ph: () => (/* binding */ isEqualAbs),
/* harmony export */   WC: () => (/* binding */ isEqualNegative),
/* harmony export */   n4: () => (/* binding */ isEqual)
/* harmony export */ });
function areNumbersEqualWithTolerance(num1, num2, tolerance) {
    return Math.abs(num1 - num2) <= tolerance;
}
function areArraysEqual(arr1, arr2, tolerance = 1e-5) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {
            return false;
        }
    }
    return true;
}
function isNumberType(value) {
    return typeof value === 'number';
}
function isNumberArrayLike(value) {
    return (value &&
        typeof value === 'object' &&
        'length' in value &&
        typeof value.length === 'number' &&
        value.length > 0 &&
        typeof value[0] === 'number');
}
function isEqual(v1, v2, tolerance = 1e-5) {
    if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {
        return false;
    }
    if (isNumberType(v1) && isNumberType(v2)) {
        return areNumbersEqualWithTolerance(v1, v2, tolerance);
    }
    if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {
        return areArraysEqual(v1, v2, tolerance);
    }
    return false;
}
const negative = (v) => typeof v === 'number' ? -v : v?.map ? v.map(negative) : !v;
const abs = (v) => typeof v === 'number' ? Math.abs(v) : v?.map ? v.map(abs) : v;
const isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);
const isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);
function isNumber(n) {
    if (Array.isArray(n)) {
        return isNumber(n[0]);
    }
    return isFinite(n) && !isNaN(n);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEqual);


/***/ }),

/***/ 7608:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aiLog: () => (/* binding */ aiLog),
/* harmony export */   coreLog: () => (/* binding */ coreLog),
/* harmony export */   cs3dLog: () => (/* binding */ cs3dLog),
/* harmony export */   dicomConsistencyLog: () => (/* binding */ dicomConsistencyLog),
/* harmony export */   examplesLog: () => (/* binding */ examplesLog),
/* harmony export */   getLogger: () => (/* binding */ getLogger),
/* harmony export */   getRootLogger: () => (/* binding */ getRootLogger),
/* harmony export */   imageConsistencyLog: () => (/* binding */ imageConsistencyLog),
/* harmony export */   loaderLog: () => (/* binding */ loaderLog),
/* harmony export */   toolsLog: () => (/* binding */ toolsLog)
/* harmony export */ });
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4367);
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);

const loglevel = loglevel__WEBPACK_IMPORTED_MODULE_0___default().noConflict();
if (typeof window !== 'undefined') {
    window.log = loglevel;
}
function getRootLogger(name) {
    const logger = loglevel.getLogger(name[0]);
    logger.getLogger = (...names) => {
        return getRootLogger(`${name}.${names.join('.')}`);
    };
    return logger;
}
function getLogger(...name) {
    return getRootLogger(name.join('.'));
}
const cs3dLog = getRootLogger('cs3d');
const coreLog = cs3dLog.getLogger('core');
const toolsLog = cs3dLog.getLogger('tools');
const loaderLog = cs3dLog.getLogger('dicomImageLoader');
const aiLog = cs3dLog.getLogger('ai');
const examplesLog = cs3dLog.getLogger('examples');
const dicomConsistencyLog = getLogger('consistency', 'dicom');
const imageConsistencyLog = getLogger('consistency', 'image');


/***/ }),

/***/ 1865:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ makeVolumeMetadata)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);

function makeVolumeMetadata(imageIds) {
    const imageId0 = imageIds[0];
    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = (0,_metaData__WEBPACK_IMPORTED_MODULE_0__.get)('imagePixelModule', imageId0);
    const voiLut = [];
    const voiLutModule = (0,_metaData__WEBPACK_IMPORTED_MODULE_0__.get)('voiLutModule', imageId0);
    let voiLUTFunction;
    if (voiLutModule) {
        const { windowWidth, windowCenter } = voiLutModule;
        voiLUTFunction = voiLutModule?.voiLUTFunction;
        if (Array.isArray(windowWidth)) {
            for (let i = 0; i < windowWidth.length; i++) {
                voiLut.push({
                    windowWidth: windowWidth[i],
                    windowCenter: windowCenter[i],
                });
            }
        }
        else {
            voiLut.push({
                windowWidth: windowWidth,
                windowCenter: windowCenter,
            });
        }
    }
    else {
        voiLut.push({
            windowWidth: undefined,
            windowCenter: undefined,
        });
    }
    const { modality, seriesInstanceUID } = (0,_metaData__WEBPACK_IMPORTED_MODULE_0__.get)('generalSeriesModule', imageId0);
    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = (0,_metaData__WEBPACK_IMPORTED_MODULE_0__.get)('imagePlaneModule', imageId0);
    return {
        BitsAllocated: bitsAllocated,
        BitsStored: bitsStored,
        SamplesPerPixel: samplesPerPixel,
        HighBit: highBit,
        PhotometricInterpretation: photometricInterpretation,
        PixelRepresentation: pixelRepresentation,
        Modality: modality,
        ImageOrientationPatient: imageOrientationPatient,
        PixelSpacing: pixelSpacing,
        FrameOfReferenceUID: frameOfReferenceUID,
        Columns: columns,
        Rows: rows,
        voiLut,
        VOILUTFunction: voiLUTFunction,
        SeriesInstanceUID: seriesInstanceUID,
    };
}


/***/ }),

/***/ 52268:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPointOnPlane: () => (/* binding */ isPointOnPlane),
/* harmony export */   linePlaneIntersection: () => (/* binding */ linePlaneIntersection),
/* harmony export */   planeDistanceToPoint: () => (/* binding */ planeDistanceToPoint),
/* harmony export */   planeEquation: () => (/* binding */ planeEquation),
/* harmony export */   threePlaneIntersection: () => (/* binding */ threePlaneIntersection)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76491);


function linePlaneIntersection(p0, p1, plane) {
    const [x0, y0, z0] = p0;
    const [x1, y1, z1] = p1;
    const [A, B, C, D] = plane;
    const a = x1 - x0;
    const b = y1 - y0;
    const c = z1 - z0;
    const t = (-1 * (A * x0 + B * y0 + C * z0 - D)) / (A * a + B * b + C * c);
    const X = a * t + x0;
    const Y = b * t + y0;
    const Z = c * t + z0;
    return [X, Y, Z];
}
function planeEquation(normal, point, normalized = false) {
    const [A, B, C] = normal;
    const D = A * point[0] + B * point[1] + C * point[2];
    if (normalized) {
        const length = Math.sqrt(A * A + B * B + C * C);
        return [A / length, B / length, C / length, D / length];
    }
    return [A, B, C, D];
}
function threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {
    const [A1, B1, C1, D1] = firstPlane;
    const [A2, B2, C2, D2] = secondPlane;
    const [A3, B3, C3, D3] = thirdPlane;
    const m0 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromValues */ .w0.fromValues(A1, A2, A3, B1, B2, B3, C1, C2, C3);
    const m1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromValues */ .w0.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);
    const m2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromValues */ .w0.fromValues(A1, A2, A3, D1, D2, D3, C1, C2, C3);
    const m3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromValues */ .w0.fromValues(A1, A2, A3, B1, B2, B3, D1, D2, D3);
    const x = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m1) / gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m0);
    const y = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m2) / gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m0);
    const z = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m3) / gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.determinant */ .w0.determinant(m0);
    return [x, y, z];
}
function planeDistanceToPoint(plane, point, signed = false) {
    const [A, B, C, D] = plane;
    const [x, y, z] = point;
    const numerator = A * x + B * y + C * z - D;
    const distance = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);
    const sign = signed ? Math.sign(numerator) : 1;
    return sign * distance;
}
function isPointOnPlane(point, plane, tolerance = _constants__WEBPACK_IMPORTED_MODULE_1__.EPSILON) {
    return planeDistanceToPoint(plane, point) < tolerance;
}



/***/ }),

/***/ 56577:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X6: () => (/* binding */ iterateOverPointsInShapeVoxelManager),
/* harmony export */   ii: () => (/* binding */ pointInShapeCallback)
/* harmony export */ });
/* unused harmony export iterateOverPointsInShape */
/* harmony import */ var _createPositionCallback__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87784);

function pointInShapeCallback(imageData, options) {
    const { pointInShapeFn, callback, boundsIJK, returnPoints = false } = options;
    let scalarData;
    if (imageData.getScalarData) {
        scalarData = imageData.getScalarData();
    }
    else {
        const scalars = imageData.getPointData().getScalars();
        if (scalars) {
            scalarData = scalars.getData();
        }
        else {
            const { voxelManager } = imageData.get('voxelManager') || {};
            if (voxelManager) {
                scalarData = voxelManager.getCompleteScalarDataArray();
            }
        }
    }
    const dimensions = imageData.getDimensions();
    const defaultBoundsIJK = [
        [0, dimensions[0]],
        [0, dimensions[1]],
        [0, dimensions[2]],
    ];
    const bounds = boundsIJK || defaultBoundsIJK;
    const pointsInShape = iterateOverPointsInShape({
        imageData,
        bounds,
        scalarData,
        pointInShapeFn,
        callback,
    });
    return returnPoints ? pointsInShape : undefined;
}
function iterateOverPointsInShape({ imageData, bounds, scalarData, pointInShapeFn, callback, }) {
    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;
    const { numComps } = imageData;
    const dimensions = imageData.getDimensions();
    const indexToWorld = (0,_createPositionCallback__WEBPACK_IMPORTED_MODULE_0__/* .createPositionCallback */ .P)(imageData);
    const pointIJK = [0, 0, 0];
    const xMultiple = numComps ||
        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];
    const yMultiple = dimensions[0] * xMultiple;
    const zMultiple = dimensions[1] * yMultiple;
    const pointsInShape = [];
    for (let k = kMin; k <= kMax; k++) {
        pointIJK[2] = k;
        const indexK = k * zMultiple;
        for (let j = jMin; j <= jMax; j++) {
            pointIJK[1] = j;
            const indexJK = indexK + j * yMultiple;
            for (let i = iMin; i <= iMax; i++) {
                pointIJK[0] = i;
                const pointLPS = indexToWorld(pointIJK);
                if (pointInShapeFn(pointLPS, pointIJK)) {
                    const index = indexJK + i * xMultiple;
                    let value;
                    if (xMultiple > 2) {
                        value = [
                            scalarData[index],
                            scalarData[index + 1],
                            scalarData[index + 2],
                        ];
                    }
                    else {
                        value = scalarData[index];
                    }
                    pointsInShape.push({
                        value,
                        index,
                        pointIJK,
                        pointLPS: pointLPS.slice(),
                    });
                    callback({ value, index, pointIJK, pointLPS });
                }
            }
        }
    }
    return pointsInShape;
}
function iterateOverPointsInShapeVoxelManager({ voxelManager, bounds, imageData, pointInShapeFn, callback, returnPoints, }) {
    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;
    const indexToWorld = (0,_createPositionCallback__WEBPACK_IMPORTED_MODULE_0__/* .createPositionCallback */ .P)(imageData);
    const pointIJK = [0, 0, 0];
    const pointsInShape = [];
    for (let k = kMin; k <= kMax; k++) {
        pointIJK[2] = k;
        for (let j = jMin; j <= jMax; j++) {
            pointIJK[1] = j;
            for (let i = iMin; i <= iMax; i++) {
                pointIJK[0] = i;
                const pointLPS = indexToWorld(pointIJK);
                if (pointInShapeFn(pointLPS, pointIJK)) {
                    const index = voxelManager.toIndex(pointIJK);
                    const value = voxelManager.getAtIndex(index);
                    if (returnPoints) {
                        pointsInShape.push({
                            value,
                            index,
                            pointIJK: [...pointIJK],
                            pointLPS: pointLPS.slice(),
                        });
                    }
                    callback?.({ value, index, pointIJK, pointLPS });
                }
            }
        }
    }
    return pointsInShape;
}


/***/ }),

/***/ 80500:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ snapFocalPointToSlice)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {
    const { min, max, current } = sliceRange;
    const posDiffFromFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(posDiffFromFocalPoint, position, focalPoint);
    const steps = Math.round((max - min) / spacingInNormalDirection);
    const fraction = (current - min) / (max - min);
    const floatingStepNumber = fraction * steps;
    let frameIndex = Math.round(floatingStepNumber);
    let newFocalPoint = [
        focalPoint[0] -
            viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,
        focalPoint[1] -
            viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,
        focalPoint[2] -
            viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection,
    ];
    frameIndex += deltaFrames;
    if (frameIndex > steps) {
        frameIndex = steps;
    }
    else if (frameIndex < 0) {
        frameIndex = 0;
    }
    const newSlicePosFromMin = frameIndex * spacingInNormalDirection;
    newFocalPoint = [
        newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,
        newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,
        newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin,
    ];
    const newPosition = [
        newFocalPoint[0] + posDiffFromFocalPoint[0],
        newFocalPoint[1] + posDiffFromFocalPoint[1],
        newFocalPoint[2] + posDiffFromFocalPoint[2],
    ];
    return { newFocalPoint, newPosition };
}


/***/ }),

/***/ 90537:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ sortImageIdsAndGetSpacing)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74876);
/* harmony import */ var _calculateSpacingBetweenImageIds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42384);



function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {
    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageIds[0]);
    if (!scanAxisNormal) {
        const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
        const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
        scanAxisNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    }
    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';
    const zSpacing = (0,_calculateSpacingBetweenImageIds__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(imageIds);
    let sortedImageIds;
    function getDistance(imageId) {
        const { imagePositionPatient } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', imageId);
        const positionVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.sub */ .eR.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);
        return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(positionVector, scanAxisNormal);
    }
    if (!usingWadoUri) {
        const distanceImagePairs = imageIds.map((imageId) => {
            const distance = getDistance(imageId);
            return {
                distance,
                imageId,
            };
        });
        distanceImagePairs.sort((a, b) => b.distance - a.distance);
        sortedImageIds = distanceImagePairs.map((a) => a.imageId);
    }
    else {
        const prefetchedImageIds = [
            imageIds[0],
            imageIds[Math.floor(imageIds.length / 2)],
        ];
        sortedImageIds = imageIds;
        const firstImageDistance = getDistance(prefetchedImageIds[0]);
        const middleImageDistance = getDistance(prefetchedImageIds[1]);
        if (firstImageDistance - middleImageDistance < 0) {
            sortedImageIds.reverse();
        }
    }
    const { imagePositionPatient: origin } = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('imagePlaneModule', sortedImageIds[0]);
    const result = {
        zSpacing,
        origin,
        sortedImageIds,
    };
    return result;
}


/***/ }),

/***/ 8126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTransferFunctionNodes: () => (/* binding */ getTransferFunctionNodes),
/* harmony export */   setTransferFunctionNodes: () => (/* binding */ setTransferFunctionNodes)
/* harmony export */ });
function getTransferFunctionNodes(transferFunction) {
    const size = transferFunction.getSize();
    const values = [];
    for (let index = 0; index < size; index++) {
        const nodeValue1 = [];
        transferFunction.getNodeValue(index, nodeValue1);
        values.push(nodeValue1);
    }
    return values;
}
function setTransferFunctionNodes(transferFunction, nodes) {
    if (!nodes?.length) {
        return;
    }
    transferFunction.removeAllPoints();
    nodes.forEach((node) => {
        transferFunction.addRGBPoint(...node);
    });
}



/***/ }),

/***/ 51919:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ transformCanvasToIJK)
/* harmony export */ });
/* harmony import */ var _transformWorldToIndex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38669);

function transformCanvasToIJK(viewport, canvasPoint) {
    const { imageData: vtkImageData } = viewport.getImageData();
    const worldPoint = viewport.canvasToWorld(canvasPoint);
    return (0,_transformWorldToIndex__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(vtkImageData, worldPoint);
}


/***/ }),

/***/ 94741:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ transformIndexToWorld)
/* harmony export */ });
function transformIndexToWorld(imageData, voxelPos) {
    return imageData.indexToWorld(voxelPos);
}


/***/ }),

/***/ 38669:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ transformWorldToIndex),
/* harmony export */   p: () => (/* binding */ transformWorldToIndexContinuous)
/* harmony export */ });
function transformWorldToIndex(imageData, worldPos) {
    const continuousIndex = imageData.worldToIndex(worldPos);
    const index = continuousIndex.map(Math.round);
    return index;
}
function transformWorldToIndexContinuous(imageData, worldPos) {
    return imageData.worldToIndex(worldPos);
}


/***/ }),

/***/ 41365:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ updatePlaneRestriction)
/* harmony export */ });
/* harmony import */ var _utilities_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74638);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);


const ORTHOGONAL_TEST_VALUE = 0.95;
function updatePlaneRestriction(points, reference) {
    if (!points?.length || !reference.FrameOfReferenceUID) {
        return;
    }
    reference.planeRestriction ||= {
        FrameOfReferenceUID: reference.FrameOfReferenceUID,
        point: points[0],
        inPlaneVector1: null,
        inPlaneVector2: null,
    };
    const { planeRestriction } = reference;
    if (points.length === 1) {
        planeRestriction.inPlaneVector1 = null;
        planeRestriction.inPlaneVector2 = null;
        return planeRestriction;
    }
    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), points[0], points[Math.floor(points.length / 2)]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.normalize */ .eR.normalize(v1, v1);
    planeRestriction.inPlaneVector1 = v1;
    planeRestriction.inPlaneVector2 = null;
    const n = points.length;
    if (n > 2) {
        for (let i = Math.floor(n / 3); i < n; i++) {
            const testVector = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), points[i], points[0]);
            const length = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.length */ .eR.length(testVector);
            if ((0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_0__/* .isEqual */ .n4)(length, 0)) {
                continue;
            }
            if (gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.dot */ .eR.dot(testVector, planeRestriction.inPlaneVector1) <
                length * ORTHOGONAL_TEST_VALUE) {
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.normalize */ .eR.normalize(testVector, testVector);
                planeRestriction.inPlaneVector2 = testVector;
                return planeRestriction;
            }
        }
    }
    return planeRestriction;
}


/***/ }),

/***/ 45278:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ updateVTKImageDataWithCornerstoneImage)
/* harmony export */ });
function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {
    const pixelData = image.voxelManager.getScalarData();
    if (!sourceImageData.getPointData) {
        return;
    }
    const scalarData = sourceImageData
        .getPointData()
        .getScalars()
        .getData();
    if (image.color && image.rgba) {
        const newPixelData = new Uint8Array(image.columns * image.rows * 3);
        for (let i = 0; i < image.columns * image.rows; i++) {
            newPixelData[i * 3] = pixelData[i * 4];
            newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];
            newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];
        }
        image.rgba = false;
        image.getPixelData = () => newPixelData;
        scalarData.set(newPixelData);
    }
    else {
        scalarData.set(pixelData);
    }
    sourceImageData.modified();
}



/***/ }),

/***/ 68136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toLowHighRange: () => (/* binding */ toLowHighRange),
/* harmony export */   toWindowLevel: () => (/* binding */ toWindowLevel)
/* harmony export */ });
/* harmony import */ var _enums_VOILUTFunctionType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82501);
/* harmony import */ var _logit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58977);


function toWindowLevel(low, high) {
    const windowWidth = Math.abs(high - low) + 1;
    const windowCenter = (low + high + 1) / 2;
    return { windowWidth, windowCenter };
}
function toLowHighRange(windowWidth, windowCenter, voiLUTFunction = _enums_VOILUTFunctionType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.LINEAR) {
    if (voiLUTFunction === _enums_VOILUTFunctionType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.LINEAR ||
        voiLUTFunction === _enums_VOILUTFunctionType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.SAMPLED_SIGMOID) {
        return {
            lower: windowCenter - 0.5 - (windowWidth - 1) / 2,
            upper: windowCenter - 0.5 + (windowWidth - 1) / 2,
        };
    }
    else if (voiLUTFunction === _enums_VOILUTFunctionType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.LINEAR_EXACT) {
        return {
            lower: windowCenter - windowWidth / 2,
            upper: windowCenter + windowWidth / 2,
        };
    }
    else {
        throw new Error('Invalid VOI LUT function');
    }
}



/***/ }),

/***/ 94350:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js
var utils_namespaceObject = {};
__webpack_require__.r(utils_namespaceObject);
__webpack_require__.d(utils_namespaceObject, {
  getPoint: () => (getPoint),
  getPolyDataPointIndexes: () => (getPolyDataPointIndexes),
  getPolyDataPoints: () => (getPolyDataPoints)
});

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js
var utilities_namespaceObject = {};
__webpack_require__.r(utilities_namespaceObject);
__webpack_require__.d(utilities_namespaceObject, {
  boundingBox: () => (boundingBox),
  geometricSurfaceUtils: () => (geometricSurfaceUtils),
  getCalibratedLengthUnitsAndScale: () => (getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op),
  math: () => (math),
  planar: () => (planar),
  polyDataUtils: () => (utils_namespaceObject),
  setAnnotationLabel: () => (setAnnotationLabel),
  throttle: () => (throttle/* default */.A),
  triggerAnnotationRenderForViewportIds: () => (triggerAnnotationRenderForViewportIds/* default */.A)
});

// EXTERNAL MODULE: ../../../node_modules/comlink/dist/esm/comlink.mjs
var comlink = __webpack_require__(99178);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js
var addTool = __webpack_require__(68040);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js + 18 modules
var eventListeners = __webpack_require__(21418);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js
var triggerAnnotationRender = __webpack_require__(56069);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js


const onImageRendered = function (evt) {
    (0,triggerAnnotationRender/* default */.A)(evt.detail.element);
};
const enable = function (element) {
    element.addEventListener(esm.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
const disable = function (element) {
    element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, onImageRendered);
};
/* harmony default export */ const eventDispatchers_imageRenderedEventDispatcher = ({
    enable,
    disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var enums_Events = __webpack_require__(94021);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js + 11 modules
var mouseEventHandlers = __webpack_require__(40100);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js


const mouseToolEventDispatcher_enable = function (element) {
    element.addEventListener(enums_Events/* default */.A.MOUSE_CLICK, mouseEventHandlers/* mouseClick */.q_);
    element.addEventListener(enums_Events/* default */.A.MOUSE_DOWN, mouseEventHandlers/* mouseDown */.cT);
    element.addEventListener(enums_Events/* default */.A.MOUSE_DOWN_ACTIVATE, mouseEventHandlers/* mouseDownActivate */.Xd);
    element.addEventListener(enums_Events/* default */.A.MOUSE_DOUBLE_CLICK, mouseEventHandlers/* mouseDoubleClick */.LM);
    element.addEventListener(enums_Events/* default */.A.MOUSE_DRAG, mouseEventHandlers/* mouseDrag */.al);
    element.addEventListener(enums_Events/* default */.A.MOUSE_MOVE, mouseEventHandlers/* mouseMove */.tG);
    element.addEventListener(enums_Events/* default */.A.MOUSE_UP, mouseEventHandlers/* mouseUp */.Je);
    element.addEventListener(enums_Events/* default */.A.MOUSE_WHEEL, mouseEventHandlers/* mouseWheel */.rO);
};
const mouseToolEventDispatcher_disable = function (element) {
    element.removeEventListener(enums_Events/* default */.A.MOUSE_CLICK, mouseEventHandlers/* mouseClick */.q_);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_DOWN, mouseEventHandlers/* mouseDown */.cT);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_DOWN_ACTIVATE, mouseEventHandlers/* mouseDownActivate */.Xd);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_DOUBLE_CLICK, mouseEventHandlers/* mouseDoubleClick */.LM);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_DRAG, mouseEventHandlers/* mouseDrag */.al);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_MOVE, mouseEventHandlers/* mouseMove */.tG);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_UP, mouseEventHandlers/* mouseUp */.Je);
    element.removeEventListener(enums_Events/* default */.A.MOUSE_WHEEL, mouseEventHandlers/* mouseWheel */.rO);
};
const mouseToolEventDispatcher_mouseToolEventDispatcher = {
    enable: mouseToolEventDispatcher_enable,
    disable: mouseToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_mouseToolEventDispatcher = ((/* unused pure expression or super */ null && (mouseToolEventDispatcher_mouseToolEventDispatcher)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js + 4 modules
var keyboardEventHandlers = __webpack_require__(74690);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js


const keyboardToolEventDispatcher_enable = function (element) {
    element.addEventListener(enums_Events/* default */.A.KEY_DOWN, keyboardEventHandlers/* keyDown */.u);
    element.addEventListener(enums_Events/* default */.A.KEY_UP, keyboardEventHandlers/* keyUp */.L);
};
const keyboardToolEventDispatcher_disable = function (element) {
    element.removeEventListener(enums_Events/* default */.A.KEY_DOWN, keyboardEventHandlers/* keyDown */.u);
    element.removeEventListener(enums_Events/* default */.A.KEY_UP, keyboardEventHandlers/* keyUp */.L);
};
const keyboardToolEventDispatcher_keyboardToolEventDispatcher = {
    enable: keyboardToolEventDispatcher_enable,
    disable: keyboardToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_keyboardToolEventDispatcher = ((/* unused pure expression or super */ null && (keyboardToolEventDispatcher_keyboardToolEventDispatcher)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js
var getToolsWithModesForMouseEvent = __webpack_require__(70333);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js



const { Active, Passive, Enabled } = enums.ToolModes;
const onCameraModified = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        Active,
        Passive,
        Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onCameraModified) {
            tool.onCameraModified(evt);
        }
    });
};
const cameraModifiedEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
const cameraModifiedEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.CAMERA_MODIFIED, onCameraModified);
};
/* harmony default export */ const eventDispatchers_cameraModifiedEventDispatcher = ({
    enable: cameraModifiedEventDispatcher_enable,
    disable: cameraModifiedEventDispatcher_disable,
});

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js



const { Active: imageSpacingCalibratedEventDispatcher_Active, Passive: imageSpacingCalibratedEventDispatcher_Passive, Enabled: imageSpacingCalibratedEventDispatcher_Enabled } = enums.ToolModes;
const onImageSpacingCalibrated = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        imageSpacingCalibratedEventDispatcher_Active,
        imageSpacingCalibratedEventDispatcher_Passive,
        imageSpacingCalibratedEventDispatcher_Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onImageSpacingCalibrated) {
            tool.onImageSpacingCalibrated(evt);
        }
    });
};
const imageSpacingCalibratedEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
const imageSpacingCalibratedEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);
};
/* harmony default export */ const eventDispatchers_imageSpacingCalibratedEventDispatcher = ({
    enable: imageSpacingCalibratedEventDispatcher_enable,
    disable: imageSpacingCalibratedEventDispatcher_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js + 8 modules
var touchEventHandlers = __webpack_require__(84971);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js


const touchToolEventDispatcher_enable = function (element) {
    element.addEventListener(enums_Events/* default */.A.TOUCH_START, touchEventHandlers/* touchStart */.gX);
    element.addEventListener(enums_Events/* default */.A.TOUCH_START_ACTIVATE, touchEventHandlers/* touchStartActivate */.$F);
    element.addEventListener(enums_Events/* default */.A.TOUCH_DRAG, touchEventHandlers/* touchDrag */.Oz);
    element.addEventListener(enums_Events/* default */.A.TOUCH_END, touchEventHandlers/* touchEnd */.ls);
    element.addEventListener(enums_Events/* default */.A.TOUCH_TAP, touchEventHandlers/* touchTap */.lI);
    element.addEventListener(enums_Events/* default */.A.TOUCH_PRESS, touchEventHandlers/* touchPress */.x5);
};
const touchToolEventDispatcher_disable = function (element) {
    element.removeEventListener(enums_Events/* default */.A.TOUCH_START, touchEventHandlers/* touchStart */.gX);
    element.removeEventListener(enums_Events/* default */.A.TOUCH_START_ACTIVATE, touchEventHandlers/* touchStartActivate */.$F);
    element.removeEventListener(enums_Events/* default */.A.TOUCH_DRAG, touchEventHandlers/* touchDrag */.Oz);
    element.removeEventListener(enums_Events/* default */.A.TOUCH_END, touchEventHandlers/* touchEnd */.ls);
    element.removeEventListener(enums_Events/* default */.A.TOUCH_PRESS, touchEventHandlers/* touchPress */.x5);
};
const touchToolEventDispatcher_touchToolEventDispatcher = {
    enable: touchToolEventDispatcher_enable,
    disable: touchToolEventDispatcher_disable,
};
/* harmony default export */ const eventDispatchers_touchToolEventDispatcher = ((/* unused pure expression or super */ null && (touchToolEventDispatcher_touchToolEventDispatcher)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js
var InterpolationManager = __webpack_require__(27740);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js



const annotationInterpolationEventDispatcher_enable = function () {
    esm.eventTarget.addEventListener(enums_Events/* default */.A.ANNOTATION_COMPLETED, InterpolationManager/* default */.A.handleAnnotationCompleted);
    esm.eventTarget.addEventListener(enums_Events/* default */.A.ANNOTATION_MODIFIED, InterpolationManager/* default */.A.handleAnnotationUpdate);
    esm.eventTarget.addEventListener(enums_Events/* default */.A.ANNOTATION_REMOVED, InterpolationManager/* default */.A.handleAnnotationDelete);
};
const annotationInterpolationEventDispatcher_disable = function () {
    esm.eventTarget.removeEventListener(enums_Events/* default */.A.ANNOTATION_COMPLETED, InterpolationManager/* default */.A.handleAnnotationCompleted);
    esm.eventTarget.removeEventListener(enums_Events/* default */.A.ANNOTATION_MODIFIED, InterpolationManager/* default */.A.handleAnnotationUpdate);
    esm.eventTarget.removeEventListener(enums_Events/* default */.A.ANNOTATION_REMOVED, InterpolationManager/* default */.A.handleAnnotationDelete);
};
/* harmony default export */ const eventDispatchers_annotationInterpolationEventDispatcher = ({
    enable: annotationInterpolationEventDispatcher_enable,
    disable: annotationInterpolationEventDispatcher_disable,
});

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js



const { Active: cameraResetEventDispatcher_Active, Passive: cameraResetEventDispatcher_Passive, Enabled: cameraResetEventDispatcher_Enabled } = enums.ToolModes;
const onCameraReset = function (evt) {
    const enabledTools = (0,getToolsWithModesForMouseEvent/* default */.A)(evt, [
        cameraResetEventDispatcher_Active,
        cameraResetEventDispatcher_Passive,
        cameraResetEventDispatcher_Enabled,
    ]);
    enabledTools.forEach((tool) => {
        if (tool.onResetCamera) {
            tool.onResetCamera(evt);
        }
    });
};
const cameraResetEventDispatcher_enable = function (element) {
    element.addEventListener(esm.Enums.Events.CAMERA_RESET, onCameraReset);
};
const cameraResetEventDispatcher_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.CAMERA_RESET, onCameraReset);
};
/* harmony default export */ const eventDispatchers_cameraResetEventDispatcher = ({
    enable: cameraResetEventDispatcher_enable,
    disable: cameraResetEventDispatcher_disable,
});

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js










// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var store_state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js
var AnnotationRenderingEngine = __webpack_require__(39011);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js




function addEnabledElement_addEnabledElement(evt) {
    const { element, viewportId } = evt.detail;
    const svgLayer = _createSvgAnnotationLayer(viewportId);
    _setSvgNodeCache(element);
    _appendChild(svgLayer, element);
    annotationRenderingEngine.addViewportElement(viewportId, element);
    mouseEventListeners.enable(element);
    wheelEventListener.enable(element);
    touchEventListeners.enable(element);
    keyEventListener.enable(element);
    imageChangeEventListener.enable(element);
    imageRenderedEventDispatcher.enable(element);
    cameraModifiedEventDispatcher.enable(element);
    imageSpacingCalibratedEventDispatcher.enable(element);
    cameraResetEventDispatcher.enable(element);
    mouseToolEventDispatcher.enable(element);
    keyboardToolEventDispatcher.enable(element);
    touchToolEventDispatcher.enable(element);
    state.enabledElements.push(element);
}
function _createSvgAnnotationLayer(viewportId) {
    const svgns = 'http://www.w3.org/2000/svg';
    const svgLayer = document.createElementNS(svgns, 'svg');
    const svgLayerId = `svg-layer-${viewportId}`;
    svgLayer.classList.add('svg-layer');
    svgLayer.setAttribute('id', svgLayerId);
    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svgLayer.style.width = '100%';
    svgLayer.style.height = '100%';
    svgLayer.style.pointerEvents = 'none';
    svgLayer.style.position = 'absolute';
    const defs = document.createElementNS(svgns, 'defs');
    const filter = document.createElementNS(svgns, 'filter');
    const feOffset = document.createElementNS(svgns, 'feOffset');
    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');
    const feBlend = document.createElementNS(svgns, 'feBlend');
    filter.setAttribute('id', `shadow-${svgLayerId}`);
    filter.setAttribute('filterUnits', 'userSpaceOnUse');
    feOffset.setAttribute('result', 'offOut');
    feOffset.setAttribute('in', 'SourceGraphic');
    feOffset.setAttribute('dx', '0.5');
    feOffset.setAttribute('dy', '0.5');
    feColorMatrix.setAttribute('result', 'matrixOut');
    feColorMatrix.setAttribute('in', 'offOut');
    feColorMatrix.setAttribute('in2', 'matrix');
    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');
    feBlend.setAttribute('in', 'SourceGraphic');
    feBlend.setAttribute('in2', 'matrixOut');
    feBlend.setAttribute('mode', 'normal');
    filter.appendChild(feOffset);
    filter.appendChild(feColorMatrix);
    filter.appendChild(feBlend);
    defs.appendChild(filter);
    svgLayer.appendChild(defs);
    return svgLayer;
}
function _setSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    state.svgNodeCache[elementHash] = {};
}
function _appendChild(newNode, referenceNode) {
    referenceNode.querySelector('div.viewport-element').appendChild(newNode);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js
var store_filterToolsWithAnnotationsForElement = __webpack_require__(57725);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js
var utilities_getToolsWithModesForElement = __webpack_require__(39848);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js
var stateManagement = __webpack_require__(6802);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js

function getSynchronizersForViewport_getSynchronizersForViewport(viewportId, renderingEngineId) {
    const synchronizersFilteredByIds = [];
    if (!renderingEngineId && !viewportId) {
        throw new Error('At least one of renderingEngineId or viewportId should be given');
    }
    for (let i = 0; i < state.synchronizers.length; i++) {
        const synchronizer = state.synchronizers[i];
        const notDisabled = !synchronizer.isDisabled();
        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);
        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);
        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {
            synchronizersFilteredByIds.push(synchronizer);
        }
    }
    return synchronizersFilteredByIds;
}
/* harmony default export */ const SynchronizerManager_getSynchronizersForViewport = ((/* unused pure expression or super */ null && (getSynchronizersForViewport_getSynchronizersForViewport)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
var ToolGroupManager_getToolGroupForViewport = __webpack_require__(65136);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js











const VIEWPORT_ELEMENT = 'viewport-element';
function removeEnabledElement_removeEnabledElement(elementDisabledEvt) {
    const { element, viewportId } = elementDisabledEvt.detail;
    _resetSvgNodeCache(element);
    _removeSvgNode(element);
    annotationRenderingEngine.removeViewportElement(viewportId, element);
    mouseEventListeners.disable(element);
    wheelEventListener.disable(element);
    touchEventListeners.disable(element);
    keyEventListener.disable(element);
    imageChangeEventListener.disable(element);
    imageRenderedEventDispatcher.disable(element);
    cameraModifiedEventDispatcher.disable(element);
    imageSpacingCalibratedEventDispatcher.disable(element);
    cameraResetEventDispatcher.disable(element);
    mouseToolEventDispatcher.disable(element);
    keyboardToolEventDispatcher.disable(element);
    touchToolEventDispatcher.disable(element);
    _removeViewportFromSynchronizers(element);
    _removeViewportFromToolGroup(element);
    _removeEnabledElement(element);
}
const _removeViewportFromSynchronizers = (element) => {
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
        return;
    }
    const synchronizers = getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);
    synchronizers.forEach((sync) => {
        sync.remove(enabledElement);
    });
};
const _removeViewportFromToolGroup = (element) => {
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
        return;
    }
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);
    if (toolGroup) {
        toolGroup.removeViewports(renderingEngineId, viewportId);
    }
};
const _removeAllToolsForElement = function (element) {
    const tools = getToolsWithModesForElement(element, [
        ToolModes.Active,
        ToolModes.Passive,
    ]);
    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);
    toolsWithData.forEach(({ annotations }) => {
        annotations.forEach((annotation) => {
            removeAnnotation(annotation.annotationUID);
        });
    });
};
function _resetSvgNodeCache(element) {
    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;
    const elementHash = `${viewportId}:${renderingEngineId}`;
    delete state.svgNodeCache[elementHash];
}
function _removeSvgNode(element) {
    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);
    const svgLayer = internalViewportNode.querySelector('svg');
    if (svgLayer) {
        internalViewportNode.removeChild(svgLayer);
    }
}
const _removeEnabledElement = function (element) {
    const foundElementIndex = state.enabledElements.findIndex((el) => el === element);
    if (foundElementIndex > -1) {
        state.enabledElements.splice(foundElementIndex, 1);
    }
};
/* harmony default export */ const store_removeEnabledElement = ((/* unused pure expression or super */ null && (removeEnabledElement_removeEnabledElement)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js



function cancelActiveManipulations(element) {
    const tools = getToolsWithModesForElement(element, [
        ToolModes.Active,
        ToolModes.Passive,
    ]);
    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);
    for (const { tool } of toolsWithData) {
        const annotationUID = tool.cancel(element);
        if (annotationUID) {
            return annotationUID;
        }
    }
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js

class Synchronizer_Synchronizer {
    constructor(synchronizerId, eventName, eventHandler, options) {
        this._viewportOptions = {};
        this._onEvent = (evt) => {
            if (this._ignoreFiredEvents === true) {
                return;
            }
            if (!this._targetViewports.length) {
                return;
            }
            const enabledElement = this._eventSource === 'element'
                ? getEnabledElement(evt.currentTarget)
                : getEnabledElementByViewportId(evt.detail?.viewportId);
            if (!enabledElement) {
                return;
            }
            const { renderingEngineId, viewportId } = enabledElement;
            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {
                return;
            }
            this.fireEvent({
                renderingEngineId,
                viewportId,
            }, evt);
        };
        this._enabled = true;
        this._eventName = eventName;
        this._eventHandler = eventHandler;
        this._ignoreFiredEvents = false;
        this._sourceViewports = [];
        this._targetViewports = [];
        this._options = options || {};
        this._eventSource = this._options.eventSource || 'element';
        this._auxiliaryEvents = this._options.auxiliaryEvents || [];
        this.id = synchronizerId;
    }
    isDisabled() {
        return !this._enabled || !this._hasSourceElements();
    }
    setOptions(viewportId, options = {}) {
        this._viewportOptions[viewportId] = options;
    }
    setEnabled(enabled) {
        this._enabled = enabled;
    }
    getOptions(viewportId) {
        return this._viewportOptions[viewportId];
    }
    add(viewportInfo) {
        this.addTarget(viewportInfo);
        this.addSource(viewportInfo);
    }
    addSource(viewportInfo) {
        if (_containsViewport(this._sourceViewports, viewportInfo)) {
            return;
        }
        const { renderingEngineId, viewportId } = viewportInfo;
        const viewport = getRenderingEngine(renderingEngineId).getViewport(viewportId);
        if (!viewport) {
            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);
            return;
        }
        const eventSource = this._eventSource === 'element' ? viewport.element : eventTarget;
        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element' ? viewport.element : eventTarget;
            target.addEventListener(name, this._onEvent.bind(this));
        });
        this._updateDisableHandlers();
        this._sourceViewports.push(viewportInfo);
    }
    addTarget(viewportInfo) {
        if (_containsViewport(this._targetViewports, viewportInfo)) {
            return;
        }
        this._targetViewports.push(viewportInfo);
        this._updateDisableHandlers();
    }
    getSourceViewports() {
        return this._sourceViewports;
    }
    getTargetViewports() {
        return this._targetViewports;
    }
    destroy() {
        this._sourceViewports.forEach((s) => this.removeSource(s));
        this._targetViewports.forEach((t) => this.removeTarget(t));
    }
    remove(viewportInfo) {
        this.removeTarget(viewportInfo);
        this.removeSource(viewportInfo);
    }
    removeSource(viewportInfo) {
        const index = _getViewportIndex(this._sourceViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        const eventSource = this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : eventTarget;
        this._sourceViewports.splice(index, 1);
        eventSource.removeEventListener(this._eventName, this._eventHandler);
        this._auxiliaryEvents.forEach(({ name, source }) => {
            const target = source === 'element'
                ? this.getViewportElement(viewportInfo)
                : eventTarget;
            target.removeEventListener(name, this._eventHandler);
        });
        this._updateDisableHandlers();
    }
    removeTarget(viewportInfo) {
        const index = _getViewportIndex(this._targetViewports, viewportInfo);
        if (index === -1) {
            return;
        }
        this._targetViewports.splice(index, 1);
        this._updateDisableHandlers();
    }
    hasSourceViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._sourceViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    hasTargetViewport(renderingEngineId, viewportId) {
        return _containsViewport(this._targetViewports, {
            renderingEngineId,
            viewportId,
        });
    }
    fireEvent(sourceViewport, sourceEvent) {
        if (this.isDisabled() || this._ignoreFiredEvents) {
            return;
        }
        this._ignoreFiredEvents = true;
        const promises = [];
        try {
            for (let i = 0; i < this._targetViewports.length; i++) {
                const targetViewport = this._targetViewports[i];
                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;
                if (targetIsSource) {
                    continue;
                }
                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
        }
        catch (ex) {
            console.warn(`Synchronizer, for: ${this._eventName}`, ex);
        }
        finally {
            if (promises.length) {
                Promise.allSettled(promises).then(() => {
                    this._ignoreFiredEvents = false;
                });
            }
            else {
                this._ignoreFiredEvents = false;
            }
        }
    }
    _hasSourceElements() {
        return this._sourceViewports.length !== 0;
    }
    _updateDisableHandlers() {
        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);
        const _remove = this.remove.bind(this);
        const disableHandler = (elementDisabledEvent) => {
            _remove(elementDisabledEvent.detail.element);
        };
        viewports.forEach((vp) => {
            const eventSource = this.getEventSource(vp);
            if (!eventSource) {
                return;
            }
            eventSource.removeEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);
            eventSource.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);
        });
    }
    getEventSource(viewportInfo) {
        return this._eventSource === 'element'
            ? this.getViewportElement(viewportInfo)
            : eventTarget;
    }
    getViewportElement(viewportInfo) {
        const { renderingEngineId, viewportId } = viewportInfo;
        const renderingEngine = getRenderingEngine(renderingEngineId);
        if (!renderingEngine) {
            return null;
        }
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            return null;
        }
        return viewport.element;
    }
}
function _getUniqueViewports(vp1, vp2) {
    const unique = [];
    const vps = vp1.concat(vp2);
    for (let i = 0; i < vps.length; i++) {
        const vp = vps[i];
        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&
            vp.viewportId === u.viewportId)) {
            unique.push(vp);
        }
    }
    return unique;
}
function _getViewportIndex(arr, vp) {
    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&
        vp.viewportId === ar.viewportId);
}
function _containsViewport(arr, vp) {
    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&
        ar.viewportId === vp.viewportId);
}
/* harmony default export */ const SynchronizerManager_Synchronizer = ((/* unused pure expression or super */ null && (Synchronizer_Synchronizer)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js
var svgNodeCache = __webpack_require__(48145);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js + 6 modules
var store_ToolGroupManager = __webpack_require__(77609);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js


function createSynchronizer_createSynchronizer(synchronizerId, eventName, eventHandler, options) {
    const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);
    if (synchronizerWithSameIdExists) {
        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);
    }
    const synchronizer = new Synchronizer(synchronizerId, eventName, eventHandler, options);
    state.synchronizers.push(synchronizer);
    return synchronizer;
}
/* harmony default export */ const SynchronizerManager_createSynchronizer = ((/* unused pure expression or super */ null && (createSynchronizer_createSynchronizer)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js

function destroy() {
    while (state.synchronizers.length > 0) {
        const synchronizer = state.synchronizers.pop();
        synchronizer.destroy();
    }
}
/* harmony default export */ const SynchronizerManager_destroy = ((/* unused pure expression or super */ null && (destroy)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js

function getSynchronizer(synchronizerId) {
    return state.synchronizers.find((s) => s.id === synchronizerId);
}
/* harmony default export */ const SynchronizerManager_getSynchronizer = ((/* unused pure expression or super */ null && (getSynchronizer)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js

function getAllSynchronizers() {
    return state.synchronizers;
}
/* harmony default export */ const SynchronizerManager_getAllSynchronizers = ((/* unused pure expression or super */ null && (getAllSynchronizers)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js

function destroySynchronizer(synchronizerId) {
    const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);
    if (synchronizerIndex > -1) {
        const synchronizer = state.synchronizers[synchronizerIndex];
        synchronizer.destroy();
        state.synchronizers.splice(synchronizerIndex, 1);
    }
}
/* harmony default export */ const SynchronizerManager_destroySynchronizer = ((/* unused pure expression or super */ null && (destroySynchronizer)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js








;// ../../../node_modules/@cornerstonejs/tools/dist/esm/store/index.js











// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js

const segmentationRepresentationModifiedListener_segmentationRepresentationModifiedListener = function (evt) {
    const { viewportId } = evt.detail;
    triggerSegmentationRender(viewportId);
};
/* harmony default export */ const segmentation_segmentationRepresentationModifiedListener = ((/* unused pure expression or super */ null && (segmentationRepresentationModifiedListener_segmentationRepresentationModifiedListener)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/config.js
var config = __webpack_require__(36625);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/init.js











let csToolsInitialized = false;
function init(defaultConfiguration = {}) {
    if (csToolsInitialized) {
        return;
    }
    setConfig(defaultConfiguration);
    _addCornerstoneEventListeners();
    _addCornerstoneToolsEventListeners();
    csToolsInitialized = true;
}
function init_destroy() {
    _removeCornerstoneEventListeners();
    _removeCornerstoneToolsEventListeners();
    ToolGroupManager.destroy();
    resetCornerstoneToolsState();
    const annotationManager = getAnnotationManager();
    const segmentationStateManager = defaultSegmentationStateManager;
    annotationManager.restoreAnnotations({});
    segmentationStateManager.resetState();
    csToolsInitialized = false;
}
function _addCornerstoneEventListeners() {
    _removeCornerstoneEventListeners();
    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;
    eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);
    eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);
    annotationInterpolationEventDispatcher.enable();
}
function _removeCornerstoneEventListeners() {
    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;
    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;
    eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);
    eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);
    annotationInterpolationEventDispatcher.disable();
}
function _addCornerstoneToolsEventListeners() {
    _removeCornerstoneToolsEventListeners();
    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);
    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);
    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);
    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);
    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_REMOVED, annotationRemovedListener);
    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);
    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);
    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);
    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);
}
function _removeCornerstoneToolsEventListeners() {
    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);
    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);
}
/* harmony default export */ const esm_init = ((/* unused pure expression or super */ null && (init)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js
var COLOR_LUT = __webpack_require__(93952);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/constants/index.js



;// ../../../node_modules/@cornerstonejs/tools/dist/esm/version.js
const version = '4.5.13';

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js

function cameraSyncCallback_cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {
    const { camera } = cameraModifiedEvent.detail;
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    tViewport.setCamera(camera);
    tViewport.render();
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js



const { CAMERA_MODIFIED } = esm.Enums.Events;
function createCameraPositionSynchronizer(synchronizerName) {
    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);
    return cameraPositionSynchronizer;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js

function presentationViewSyncCallback_presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const presentationView = sViewport.getViewPresentation(options);
    tViewport.setViewPresentation(presentationView);
    tViewport.render();
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js



const { CAMERA_MODIFIED: createPresentationViewSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createPresentationViewSynchronizer(synchronizerName, options) {
    const presentationView = createSynchronizer(synchronizerName, createPresentationViewSynchronizer_CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });
    return presentationView;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js

function voiSyncCallback_voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {
    const eventDetail = modifiedEvent.detail;
    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const tProperties = {
        voiRange: range,
    };
    if (options?.syncInvertState && invertStateChanged) {
        tProperties.invert = invert;
    }
    if (options?.syncColormap && colormap) {
        tProperties.colormap = colormap;
    }
    if (tViewport instanceof BaseVolumeViewport) {
        const isFusion = tViewport._actors && tViewport._actors.size > 1;
        if (isFusion) {
            tViewport.setProperties(tProperties, volumeId);
        }
        else {
            tViewport.setProperties(tProperties);
        }
    }
    else if (tViewport instanceof StackViewport) {
        tViewport.setProperties(tProperties);
    }
    else {
        throw new Error('Viewport type not supported.');
    }
    tViewport.render();
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js



function createVOISynchronizer(synchronizerName, options) {
    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);
    const VOISynchronizer = createSynchronizer(synchronizerName, Enums.Events.VOI_MODIFIED, voiSyncCallback, {
        auxiliaryEvents: [
            {
                name: Enums.Events.COLORMAP_MODIFIED,
            },
        ],
        ...options,
    });
    return VOISynchronizer;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js

function zoomPanSyncCallback_zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    if (options?.syncZoom !== false) {
        const srcZoom = sViewport.getZoom();
        tViewport.setZoom(srcZoom);
    }
    if (options?.syncPan !== false) {
        const srcPan = sViewport.getPan();
        tViewport.setPan(srcPan);
    }
    tViewport.render();
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js



const { CAMERA_MODIFIED: createZoomPanSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createZoomPanSynchronizer(synchronizerName) {
    const zoomPanSynchronizer = createSynchronizer(synchronizerName, createZoomPanSynchronizer_CAMERA_MODIFIED, zoomPanSyncCallback);
    return zoomPanSynchronizer;
}

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var gl_matrix_esm = __webpack_require__(3823);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js

function areViewportsCoplanar_areViewportsCoplanar(viewport1, viewport2) {
    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();
    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();
    const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);
    return Math.abs(dotProducts) > 0.9;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js



const getSpatialRegistration = (targetId, sourceId) => utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);
async function imageSliceSyncCallback_imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const options = synchronizerInstance.getOptions(targetViewport.viewportId);
    if (options?.disabled) {
        return;
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const imageId1 = sViewport.getCurrentImageId();
    const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);
    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;
    const targetImageIds = tViewport.getImageIds();
    if (!areViewportsCoplanar(sViewport, tViewport)) {
        return;
    }
    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
    if (!registrationMatrixMat4) {
        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();
        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();
        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&
            options?.useInitialPosition !== false) {
            registrationMatrixMat4 = mat4.identity(mat4.create());
        }
        else {
            utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);
            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);
        }
        if (!registrationMatrixMat4) {
            return;
        }
    }
    const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);
    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);
    let imageIndexToSet = closestImageIdIndex2.index;
    if (tViewport instanceof VolumeViewport) {
        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;
    }
    if (closestImageIdIndex2.index !== -1 &&
        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {
        await utilities.jumpToSlice(tViewport.element, {
            imageIndex: imageIndexToSet,
        });
    }
}
function _getClosestImageIdIndex(targetPoint, imageIds) {
    return imageIds.reduce((closestImageIdIndex, imageId, index) => {
        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);
        const distance = vec3.distance(imagePositionPatient, targetPoint);
        if (distance < closestImageIdIndex.distance) {
            return {
                distance,
                index,
            };
        }
        return closestImageIdIndex;
    }, {
        distance: Infinity,
        index: -1,
    });
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js



const { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = esm.Enums.Events;
function createImageSliceSynchronizer_createImageSliceSynchronizer(synchronizerName) {
    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {
        auxiliaryEvents: [
            {
                name: 'VOLUME_NEW_IMAGE',
            },
        ],
    });
    return stackImageSynchronizer;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js

function slabThicknessSyncCallback_slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {
    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);
    if (!renderingEngine) {
        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);
    }
    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);
    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);
    const slabThickness = sViewport.getSlabThickness?.();
    if (!slabThickness) {
        return;
    }
    tViewport.setSlabThickness?.(slabThickness);
    tViewport.render();
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js



const { CAMERA_MODIFIED: createSlabThicknessSynchronizer_CAMERA_MODIFIED } = esm.Enums.Events;
function createSlabThicknessSynchronizer_createPresentationViewSynchronizer(synchronizerName) {
    const presentationView = createSynchronizer(synchronizerName, createSlabThicknessSynchronizer_CAMERA_MODIFIED, slabThicknessSyncCallback);
    return presentationView;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js






const createStackImageSynchronizer = (/* unused pure expression or super */ null && (createImageSliceSynchronizer));


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js + 4 modules
var drawingSvg = __webpack_require__(74347);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js



function getAnnotationNearPoint(element, canvasPoint, proximity = 5) {
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
        throw new Error('getAnnotationNearPoint: enabledElement not found');
    }
    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);
}
function getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {
    const { renderingEngineId, viewportId } = enabledElement;
    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);
    if (!toolGroup) {
        return null;
    }
    const { _toolInstances: tools } = toolGroup;
    for (const name in tools) {
        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);
        if (found) {
            return found;
        }
    }
    return null;
}
function findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {
    const { viewport } = enabledElement;
    const annotations = getAnnotations(tool.constructor.toolName, viewport?.element);
    const currentId = viewport?.getCurrentImageId?.();
    if (annotations?.length) {
        const { element } = enabledElement.viewport;
        for (const annotation of annotations) {
            const referencedImageId = annotation.metadata?.referencedImageId;
            if ((currentId && referencedImageId && currentId !== referencedImageId) ||
                !tool.isPointNearTool) {
                continue;
            }
            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||
                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {
                return annotation;
            }
        }
    }
    return null;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js
var debounce = __webpack_require__(52905);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js
var throttle = __webpack_require__(27730);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js
var isObject = __webpack_require__(45217);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js

const { calibratedPixelSpacingMetadataProvider } = esm.utilities;
function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {
    if (typeof calibrationOrScale === 'number') {
        calibrationOrScale = {
            type: Enums.CalibrationTypes.USER,
            scale: calibrationOrScale,
        };
    }
    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);
    const viewports = renderingEngine.getStackViewports();
    viewports.forEach((viewport) => {
        const imageIds = viewport.getImageIds();
        if (imageIds.includes(imageId)) {
            viewport.calibrateSpacing(imageId);
        }
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js
var getCalibratedUnits = __webpack_require__(4096);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js
var triggerAnnotationRenderForToolGroupIds = __webpack_require__(94779);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js
var getSphereBoundsInfo = __webpack_require__(4296);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js
function pointToString(point, decimals = 5) {
    return (parseFloat(point[0]).toFixed(decimals) +
        ',' +
        parseFloat(point[1]).toFixed(decimals) +
        ',' +
        parseFloat(point[2]).toFixed(decimals) +
        ',');
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js



class AnnotationMultiSlice {
    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, startRange);
    }
    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, undefined, endRange);
    }
    static setRange(viewport, annotation, startRange, endRange) {
        const { metadata } = annotation;
        if (startRange === undefined) {
            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;
            if (endRange === undefined) {
                endRange = viewport.getNumberOfSlices() - 1;
            }
        }
        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);
        if (endRange === undefined) {
            endRange =
                rangeEndSliceIndex >= startRange
                    ? rangeEndSliceIndex
                    : viewport.getNumberOfSlices() - 1;
        }
        endRange = Math.max(startRange, endRange);
        metadata.sliceIndex = Math.min(startRange, endRange);
        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);
        metadata.referencedImageURI = undefined;
        if (endRange === metadata.sliceIndex) {
            metadata.multiSliceReference = undefined;
        }
        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {
            metadata.multiSliceReference = {
                referencedImageId: viewport.getCurrentImageId(endRange),
                sliceIndex: endRange,
            };
        }
        const eventDetail = {
            viewportId: viewport.id,
            renderingEngineId: viewport.renderingEngineId,
            changeType: ChangeTypes.MetadataReferenceModified,
            annotation,
        };
        triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);
        this.setViewportFrameRange(viewport, metadata);
    }
    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {
        this.setRange(viewport, annotation, current, current);
    }
    static getFrameRange(annotation) {
        const { metadata } = annotation;
        const { sliceIndex, multiSliceReference } = metadata;
        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;
        return rangeEndSliceIndex
            ? [sliceIndex + 1, rangeEndSliceIndex + 1]
            : sliceIndex + 1;
    }
    static getFrameRangeStr(annotation) {
        const range = this.getFrameRange(annotation);
        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);
    }
    static setViewportFrameRange(viewport, specifier) {
        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {
            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);
        }
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js
var getViewportForAnnotation = __webpack_require__(40133);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js
var annotationHydration = __webpack_require__(64485);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js + 6 modules
var contours = __webpack_require__(6936);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js
var segmentation = __webpack_require__(93759);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js
var drawing = __webpack_require__(473);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js
var math = __webpack_require__(95527);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js
var planar = __webpack_require__(13165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js
var viewportFilters = __webpack_require__(60810);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js
function getOrientationStringLPS(vector) {
    let orientation = '';
    const orientationX = vector[0] < 0 ? 'R' : 'L';
    const orientationY = vector[1] < 0 ? 'A' : 'P';
    const orientationZ = vector[2] < 0 ? 'F' : 'H';
    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];
    const MIN = 0.0001;
    for (let i = 0; i < 3; i++) {
        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {
            orientation += orientationX;
            abs[0] = 0;
        }
        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {
            orientation += orientationY;
            abs[1] = 0;
        }
        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {
            orientation += orientationZ;
            abs[2] = 0;
        }
        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {
            orientation += orientationX + orientationY;
            abs[0] = 0;
            abs[1] = 0;
        }
        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {
            orientation += orientationX + orientationZ;
            abs[0] = 0;
            abs[2] = 0;
        }
        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {
            orientation += orientationY + orientationZ;
            abs[1] = 0;
            abs[2] = 0;
        }
        else {
            break;
        }
    }
    return orientation;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js
function invertOrientationStringLPS(orientationString) {
    let inverted = orientationString.replace('H', 'f');
    inverted = inverted.replace('F', 'h');
    inverted = inverted.replace('R', 'l');
    inverted = inverted.replace('L', 'r');
    inverted = inverted.replace('A', 'p');
    inverted = inverted.replace('P', 'a');
    inverted = inverted.toUpperCase();
    return inverted;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js




;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js
var events_Events;
(function (Events) {
    Events["CLIP_STOPPED"] = "CORNERSTONE_CINE_TOOL_STOPPED";
    Events["CLIP_STARTED"] = "CORNERSTONE_CINE_TOOL_STARTED";
})(events_Events || (events_Events = {}));
/* harmony default export */ const events = ((/* unused pure expression or super */ null && (events_Events)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js

const state_state = {};
function state_addToolState(element, data) {
    const enabledElement = getEnabledElement(element);
    const { viewportId } = enabledElement;
    state_state[viewportId] = data;
}
function state_getToolState(element) {
    const enabledElement = getEnabledElement(element);
    const { viewportId } = enabledElement;
    return state_state[viewportId];
}
function state_getToolStateByViewportId(viewportId) {
    return state_state[viewportId];
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js




const { ViewportStatus } = esm.Enums;
const { triggerEvent: playClip_triggerEvent } = esm.utilities;
const debounced = true;
const dynamicVolumesPlayingMap = new Map();
function playClip(element, playClipOptions) {
    let playClipTimeouts;
    let playClipIsTimeVarying;
    if (element === undefined) {
        throw new Error('playClip: element must not be undefined');
    }
    const enabledElement = getEnabledElement(element);
    if (!enabledElement) {
        throw new Error('playClip: element must be a valid Cornerstone enabled element');
    }
    if (!playClipOptions) {
        playClipOptions = {};
    }
    playClipOptions.dynamicCineEnabled =
        playClipOptions.dynamicCineEnabled ?? true;
    const { viewport } = enabledElement;
    const playClipContext = _createCinePlayContext(viewport, playClipOptions);
    let playClipData = getToolState(element);
    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;
    if (isDynamicCinePlaying) {
        _stopDynamicVolumeCine(element);
    }
    if (!playClipData) {
        playClipData = {
            intervalId: undefined,
            framesPerSecond: 30,
            lastFrameTimeStamp: undefined,
            ignoreFrameTimeVector: false,
            usingFrameTimeVector: false,
            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,
            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,
            reverse: playClipOptions.reverse ?? false,
            loop: playClipOptions.loop ?? true,
            bounce: playClipOptions.bounce ?? false,
        };
        addToolState(element, playClipData);
    }
    else {
        _stopClip(element, {
            stopDynamicCine: !isDynamicCinePlaying,
            viewportId: viewport.id,
        });
    }
    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;
    if (playClipOptions.framesPerSecond < 0 ||
        playClipOptions.framesPerSecond > 0) {
        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);
        playClipData.reverse = playClipData.framesPerSecond < 0;
        playClipData.ignoreFrameTimeVector = true;
    }
    if (playClipData.ignoreFrameTimeVector !== true &&
        playClipData.frameTimeVector &&
        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&
        playClipContext.frameTimeVectorEnabled) {
        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);
        playClipTimeouts = timeouts;
        playClipIsTimeVarying = isTimeVarying;
    }
    if (playClipOptions.bounce !== undefined) {
        playClipData.bounce = playClipOptions.bounce;
    }
    const playClipAction = () => {
        const { numScrollSteps, currentStepIndex } = playClipContext;
        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;
        if (outOfRange) {
            if (playClipData.bounce) {
                playClipData.reverse = !playClipData.reverse;
                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);
                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));
            }
            else if (!playClipData.loop) {
                _stopClip(element, {
                    stopDynamicCine: !isDynamicCinePlaying,
                    viewportId: viewport.id,
                });
                playClip_triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });
                return;
            }
            else {
                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;
            }
        }
        const delta = newStepIndex - currentStepIndex;
        if (delta) {
            try {
                playClipContext.scroll(delta);
            }
            catch (e) {
                console.warn('Play clip not scrolling', e);
                _stopClipWithData(playClipData);
                playClip_triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });
            }
        }
    };
    if (isDynamicCinePlaying) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume) {
            dynamicVolumesPlayingMap.set(volume.volumeId, element);
        }
    }
    if (playClipContext.play) {
        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);
    }
    else if (playClipTimeouts &&
        playClipTimeouts.length > 0 &&
        playClipIsTimeVarying) {
        playClipData.usingFrameTimeVector = true;
        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {
            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);
            playClipAction();
        }, 0);
    }
    else {
        playClipData.usingFrameTimeVector = false;
        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));
    }
    const eventDetail = {
        element,
    };
    playClip_triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);
}
function stopClip(element, options = {}) {
    _stopClip(element, {
        stopDynamicCine: true,
        ...options,
    });
}
function _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {
    const { stopDynamicCine, viewportId } = options;
    const enabledElement = getEnabledElement(element);
    let toolState;
    const viewport = enabledElement?.viewport;
    if (!enabledElement) {
        if (viewportId) {
            toolState = getToolStateByViewportId(viewportId);
        }
        else {
            return;
        }
    }
    else {
        const { viewport } = enabledElement;
        toolState = getToolState(viewport.element);
    }
    if (toolState) {
        _stopClipWithData(toolState);
    }
    if (viewport instanceof VideoViewport) {
        viewport.pause();
    }
    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {
        _stopDynamicVolumeCine(element);
    }
}
function _stopDynamicVolumeCine(element) {
    const { viewport } = getEnabledElement(element);
    if (viewport instanceof VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (volume?.isDynamicVolume()) {
            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);
            dynamicVolumesPlayingMap.delete(volume.volumeId);
            if (dynamicCineElement && dynamicCineElement !== element) {
                stopClip(dynamicCineElement);
            }
        }
    }
}
function _getPlayClipTimeouts(vector, speed) {
    let i;
    let sample;
    let delay;
    let sum = 0;
    const limit = vector.length;
    const timeouts = [];
    let isTimeVarying = false;
    if (typeof speed !== 'number' || speed <= 0) {
        speed = 1;
    }
    for (i = 1; i < limit; i++) {
        delay = (Number(vector[i]) / speed) | 0;
        timeouts.push(delay);
        if (i === 1) {
            sample = delay;
        }
        else if (delay !== sample) {
            isTimeVarying = true;
        }
        sum += delay;
    }
    if (timeouts.length > 0) {
        if (isTimeVarying) {
            delay = (sum / timeouts.length) | 0;
        }
        else {
            delay = timeouts[0];
        }
        timeouts.push(delay);
    }
    return { timeouts, isTimeVarying };
}
function _stopClipWithData(playClipData) {
    const id = playClipData.intervalId;
    if (typeof id !== 'undefined') {
        playClipData.intervalId = undefined;
        if (playClipData.usingFrameTimeVector) {
            clearTimeout(id);
        }
        else {
            clearInterval(id);
        }
    }
}
function _getVolumeFromViewport(viewport) {
    if (!(viewport instanceof VolumeViewport)) {
        return undefined;
    }
    const volumeIds = viewport.getAllVolumeIds();
    if (!volumeIds?.length) {
        return undefined;
    }
    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());
    const volumeId = dynamicVolumeId ?? volumeIds[0];
    return cache.getVolume(volumeId);
}
function _createStackViewportCinePlayContext(viewport, waitForRendered) {
    const imageIds = viewport.getImageIds();
    return {
        get numScrollSteps() {
            return imageIds.length;
        },
        get currentStepIndex() {
            return viewport.getTargetImageIdIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            csUtils.scroll(viewport, { delta, debounceLoading: debounced });
        },
    };
}
function _createVideoViewportCinePlayContext(viewport, waitForRendered) {
    return {
        get numScrollSteps() {
            return viewport.getNumberOfSlices();
        },
        get currentStepIndex() {
            return viewport.getSliceIndex();
        },
        get frameTimeVectorEnabled() {
            return true;
        },
        waitForRenderedCount: 0,
        scroll(delta) {
            if (this.waitForRenderedCount <= waitForRendered &&
                viewport.viewportStatus !== ViewportStatus.RENDERED) {
                this.waitForRenderedCount++;
                return;
            }
            this.waitForRenderedCount = 0;
            csUtils.scroll(viewport, { delta, debounceLoading: debounced });
        },
        play(fps) {
            if (fps) {
                viewport.setPlaybackRate(fps / 24);
            }
            viewport.play();
            return viewport.getFrameRate();
        },
    };
}
function _createVolumeViewportCinePlayContext(viewport, volume) {
    const { volumeId } = volume;
    const cachedScrollInfo = {
        viewPlaneNormal: vec3.create(),
        scrollInfo: null,
    };
    const getScrollInfo = () => {
        const camera = viewport.getCamera();
        const updateCache = !cachedScrollInfo.scrollInfo ||
            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);
        if (updateCache) {
            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);
            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;
            cachedScrollInfo.scrollInfo = scrollInfo;
        }
        return cachedScrollInfo.scrollInfo;
    };
    return {
        get numScrollSteps() {
            return getScrollInfo().numScrollSteps;
        },
        get currentStepIndex() {
            return getScrollInfo().currentStepIndex;
        },
        get frameTimeVectorEnabled() {
            const camera = viewport.getCamera();
            const volumeViewPlaneNormal = volume.direction
                .slice(6, 9)
                .map((x) => -x);
            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);
            return glMatrix.equals(dot, 1);
        },
        scroll(delta) {
            getScrollInfo().currentStepIndex += delta;
            csUtils.scroll(viewport, { delta });
        },
    };
}
function _createDynamicVolumeViewportCinePlayContext(volume) {
    return {
        get numScrollSteps() {
            return volume.numDimensionGroups;
        },
        get currentStepIndex() {
            return volume.dimensionGroupNumber - 1;
        },
        get frameTimeVectorEnabled() {
            return false;
        },
        scroll(delta) {
            volume.scroll(delta);
        },
    };
}
function _createCinePlayContext(viewport, playClipOptions) {
    if (viewport instanceof StackViewport) {
        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    if (viewport instanceof VolumeViewport) {
        const volume = _getVolumeFromViewport(viewport);
        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {
            return _createDynamicVolumeViewportCinePlayContext(volume);
        }
        return _createVolumeViewportCinePlayContext(viewport, volume);
    }
    if (viewport instanceof VideoViewport) {
        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);
    }
    throw new Error('Unknown viewport type');
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js
var boundingBox = __webpack_require__(72282);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothAnnotation.js
var smoothAnnotation = __webpack_require__(61587);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js

/* harmony default export */ const planarFreehandROITool = ({
    smoothAnnotation: smoothAnnotation/* default */.A,
});


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js
var getBoundsIJKFromRectangleAnnotations = __webpack_require__(37162);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js


const { isEqual } = esm.utilities;
const iAxis = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(1, 0, 0);
const jAxis = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 1, 0);
const kAxis = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 0, 1);
const axisList = [iAxis, jAxis, kAxis];
function isAxisAlignedRectangle(rectangleCornersIJK) {
    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);
    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);
    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);
    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);
    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||
        isEqual(angle, 90) ||
        isEqual(angle, 180) ||
        isEqual(angle, 270));
    return isAligned;
}
function calculateAnglesWithAxes(vec, axes) {
    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js




// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js
var stackPrefetch_state = __webpack_require__(30045);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetchUtils.js
var stackPrefetchUtils = __webpack_require__(94762);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js




const { imageRetrieveMetadataProvider } = esm.utilities;
let configuration = {
    maxImagesToPrefetch: Infinity,
    preserveExistingPool: true,
};
let resetPrefetchTimeout;
const resetPrefetchDelay = 10;
function prefetch(element) {
    const stackPrefetchData = (0,stackPrefetch_state/* getToolState */.k)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    const stack = (0,stackPrefetchUtils/* getStackData */.bV)(element);
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    indicesToRequestCopy.forEach(function (imageIdIndex) {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? esm.cache.getImageLoadObject(imageId)
            : esm.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!configuration.preserveExistingPool) {
        esm.imageLoadPoolManager.clearRequestStack(stackPrefetchUtils/* requestType */.y9);
    }
    const nearest = (0,stackPrefetchUtils/* nearestIndex */.zo)(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);
    let imageId;
    let nextImageIdIndex;
    const preventCache = false;
    function doneCallback(imageId) {
        console.log('prefetch done: %s', imageId);
        const imageIdIndex = stack.imageIds.indexOf(imageId);
        removeFromList(imageIdIndex);
        if (stackPrefetch.indicesToRequest.length === 0) {
            const eventDetail = {
                element: element,
                lastPrefetchedImageId: imageId,
            };
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.STACK_PREFETCH_COMPLETE, eventDetail);
        }
    }
    let lowerIndex = nearest.low;
    let higherIndex = nearest.high;
    const imageIdsToPrefetch = [];
    while (lowerIndex >= 0 ||
        higherIndex < stackPrefetch.indicesToRequest.length) {
        const currentIndex = stack.currentImageIdIndex;
        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >
            configuration.maxImagesToPrefetch;
        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >
            configuration.maxImagesToPrefetch;
        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;
        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;
        if (!shouldLoadHigher && !shouldLoadLower) {
            break;
        }
        if (shouldLoadLower) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
        if (shouldLoadHigher) {
            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];
            imageId = stack.imageIds[nextImageIdIndex];
            imageIdsToPrefetch.push(imageId);
        }
    }
    const requestFn = (imageId, options) => {
        const { retrieveOptions = {} } = esm.metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};
        options.retrieveOptions = {
            ...options.retrieveOptions,
            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),
        };
        return esm.imageLoader.loadAndCacheImage(imageId, options)
            .then(() => doneCallback(imageId));
    };
    imageIdsToPrefetch.forEach((imageId) => {
        const options = {
            requestType: stackPrefetchUtils/* requestType */.y9,
        };
        esm.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), stackPrefetchUtils/* requestType */.y9, {
            imageId,
        }, stackPrefetchUtils/* priority */.Lr);
    });
}
function onImageUpdated(e) {
    clearTimeout(resetPrefetchTimeout);
    resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            prefetch(element);
        }
        catch (error) {
            return;
        }
    }, resetPrefetchDelay);
}
function stackPrefetch_enable(element) {
    const stack = (0,stackPrefetchUtils/* getStackData */.bV)(element);
    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = {
        indicesToRequest: (0,stackPrefetchUtils/* range */.y1)(0, stack.imageIds.length - 1),
        enabled: true,
        direction: 1,
    };
    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);
    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);
    (0,stackPrefetch_state/* addToolState */.P)(element, stackPrefetchData);
    prefetch(element);
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    element.addEventListener(esm.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,stackPrefetchUtils/* getPromiseRemovedHandler */.m0)(element);
    esm.eventTarget.removeEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    esm.eventTarget.addEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
}
function stackPrefetch_disable(element) {
    clearTimeout(resetPrefetchTimeout);
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, onImageUpdated);
    const promiseRemovedHandler = (0,stackPrefetchUtils/* getPromiseRemovedHandler */.m0)(element);
    esm.eventTarget.removeEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,stackPrefetch_state/* getToolState */.k)(element);
    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {
        stackPrefetchData.enabled = false;
        esm.imageLoadPoolManager.clearRequestStack(stackPrefetchUtils/* requestType */.y9);
    }
}
function getConfiguration() {
    return configuration;
}
function setConfiguration(config) {
    configuration = config;
}
const stackPrefetch = { enable: stackPrefetch_enable, disable: stackPrefetch_disable, getConfiguration, setConfiguration };
/* harmony default export */ const stackPrefetch_stackPrefetch = ((/* unused pure expression or super */ null && (stackPrefetch)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js




const { imageRetrieveMetadataProvider: stackContextPrefetch_imageRetrieveMetadataProvider } = esm.utilities;
let stackContextPrefetch_configuration = {
    maxImagesToPrefetch: Infinity,
    minBefore: 2,
    maxAfter: 2,
    directionExtraImages: 10,
    preserveExistingPool: false,
};
let stackContextPrefetch_resetPrefetchTimeout;
const stackContextPrefetch_resetPrefetchDelay = 5;
const priorities = {};
const stackContextPrefetch_enable = (element, priority = 0) => {
    const stack = (0,stackPrefetchUtils/* getStackData */.bV)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    updateToolState(element);
    priorities[element] = priority;
    stackContextPrefetch_prefetch(element, priority);
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, stackContextPrefetch_onImageUpdated);
    element.addEventListener(esm.Enums.Events.STACK_NEW_IMAGE, stackContextPrefetch_onImageUpdated);
    const promiseRemovedHandler = (0,stackPrefetchUtils/* getPromiseRemovedHandler */.m0)(element);
    esm.eventTarget.removeEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    esm.eventTarget.addEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
};
function stackContextPrefetch_prefetch(element, priority = 0) {
    const stack = (0,stackPrefetchUtils/* getStackData */.bV)(element);
    if (!stack) {
        return;
    }
    if (!stack?.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const stackPrefetchData = (0,stackPrefetch_state/* getToolState */.k)(element);
    if (!stackPrefetchData) {
        return;
    }
    const stackPrefetch = (stackPrefetchData || {});
    stackPrefetch.enabled =
        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;
    if (stackPrefetch.enabled === false) {
        return;
    }
    function removeFromList(imageIdIndex) {
        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);
        if (index > -1) {
            stackPrefetch.indicesToRequest.splice(index, 1);
        }
    }
    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();
    const { currentImageIdIndex } = stack;
    indicesToRequestCopy.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        if (!imageId) {
            return;
        }
        const distance = Math.abs(currentImageIdIndex - imageIdIndex);
        const imageCached = distance < 6
            ? esm.cache.getImageLoadObject(imageId)
            : esm.cache.isLoaded(imageId);
        if (imageCached) {
            removeFromList(imageIdIndex);
        }
    });
    if (!stackPrefetch.indicesToRequest.length) {
        return;
    }
    if (!stackContextPrefetch_configuration.preserveExistingPool) {
        esm.imageLoadPoolManager.filterRequests((0,stackPrefetchUtils/* clearFromImageIds */.Pg)(stack));
    }
    function doneCallback(imageId) {
        const imageIdIndex = stack.imageIds.indexOf(imageId);
        removeFromList(imageIdIndex);
        const image = esm.cache.getCachedImageBasedOnImageURI(imageId);
        const { stats } = stackPrefetch;
        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;
        if (decodeTimeInMS) {
            stats.imageIds.set(imageId, decodeTimeInMS);
            stats.decodeTimeInMS += decodeTimeInMS;
            const loadTimeInMS = image?.image?.loadTimeInMS || 0;
            stats.loadTimeInMS += loadTimeInMS;
        }
        if (!stackPrefetch.indicesToRequest.length) {
            if (image?.sizeInBytes) {
                const { sizeInBytes } = image;
                const usage = esm.cache.getMaxCacheSize() / 4 / sizeInBytes;
                if (!stackPrefetch.cacheFill) {
                    stats.initialTime = Date.now() - stats.start;
                    stats.initialSize = stats.imageIds.size;
                    updateToolState(element, usage);
                    stackContextPrefetch_prefetch(element, priority);
                }
                else if (stats.imageIds.size) {
                    stats.fillTime = Date.now() - stats.start;
                    const { size } = stats.imageIds;
                    stats.fillSize = size;
                }
            }
        }
        if (stackPrefetch.indicesToRequest.length === 0) {
            const eventDetail = {
                element: element,
                lastPrefetchedImageId: imageId,
            };
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.STACK_PREFETCH_COMPLETE, eventDetail);
        }
    }
    const requestFn = (imageId, options) => {
        const { retrieveOptions = {} } = esm.metaData.get(stackContextPrefetch_imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};
        options.retrieveOptions = {
            ...options.retrieveOptions,
            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),
        };
        return esm.imageLoader.loadAndCacheImage(imageId, options)
            .then(() => doneCallback(imageId));
    };
    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {
        const imageId = stack.imageIds[imageIdIndex];
        const options = {
            requestType: stackPrefetchUtils/* requestType */.y9,
        };
        esm.imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), stackPrefetchUtils/* requestType */.y9, {
            imageId,
        }, priority);
    });
}
function stackContextPrefetch_onImageUpdated(e) {
    clearTimeout(stackContextPrefetch_resetPrefetchTimeout);
    stackContextPrefetch_resetPrefetchTimeout = setTimeout(function () {
        const element = e.target;
        try {
            updateToolState(element);
            stackContextPrefetch_prefetch(element, priorities[element]);
        }
        catch (error) {
            return;
        }
    }, stackContextPrefetch_resetPrefetchDelay);
}
const signum = (x) => (x < 0 ? -1 : 1);
const updateToolState = (element, usage) => {
    const stack = (0,stackPrefetchUtils/* getStackData */.bV)(element);
    if (!stack) {
        return;
    }
    if (!stack.imageIds?.length) {
        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');
        return;
    }
    const { currentImageIdIndex } = stack;
    let { maxAfter = 2, minBefore = 2 } = stackContextPrefetch_configuration;
    const { directionExtraImages = 10 } = stackContextPrefetch_configuration;
    const stackPrefetchData = (0,stackPrefetch_state/* getToolState */.k)(element) ||
        {
            indicesToRequest: [],
            currentImageIdIndex,
            stackCount: 0,
            enabled: true,
            direction: 1,
            stats: {
                start: Date.now(),
                imageIds: new Map(),
                decodeTimeInMS: 0,
                loadTimeInMS: 0,
                totalBytes: 0,
            },
        };
    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;
    stackPrefetchData.direction = signum(delta);
    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;
    stackPrefetchData.enabled = true;
    if (stackPrefetchData.stackCount < 100) {
        stackPrefetchData.stackCount += directionExtraImages;
    }
    if (Math.abs(delta) > maxAfter || !delta) {
        stackPrefetchData.stackCount = 0;
        if (usage) {
            const positionFraction = currentImageIdIndex / stack.imageIds.length;
            minBefore = Math.ceil(usage * positionFraction);
            maxAfter = Math.ceil(usage * (1 - positionFraction));
            stackPrefetchData.cacheFill = true;
        }
        else {
            stackPrefetchData.cacheFill = false;
        }
    }
    else if (delta < 0) {
        minBefore += stackPrefetchData.stackCount;
        maxAfter = 0;
    }
    else {
        maxAfter += stackPrefetchData.stackCount;
        minBefore = 0;
    }
    const minIndex = Math.max(0, currentImageIdIndex - minBefore);
    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);
    const indicesToRequest = [];
    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {
        indicesToRequest.push(i);
    }
    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {
        indicesToRequest.push(i);
    }
    stackPrefetchData.indicesToRequest = indicesToRequest;
    (0,stackPrefetch_state/* addToolState */.P)(element, stackPrefetchData);
};
function stackContextPrefetch_disable(element) {
    clearTimeout(stackContextPrefetch_resetPrefetchTimeout);
    element.removeEventListener(esm.Enums.Events.STACK_NEW_IMAGE, stackContextPrefetch_onImageUpdated);
    const promiseRemovedHandler = (0,stackPrefetchUtils/* getPromiseRemovedHandler */.m0)(element);
    esm.eventTarget.removeEventListener(esm.Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);
    const stackPrefetchData = (0,stackPrefetch_state/* getToolState */.k)(element);
    if (stackPrefetchData) {
        stackPrefetchData.enabled = false;
    }
}
function stackContextPrefetch_getConfiguration() {
    return stackContextPrefetch_configuration;
}
function stackContextPrefetch_setConfiguration(config) {
    stackContextPrefetch_configuration = config;
}
const stackContextPrefetch = {
    enable: stackContextPrefetch_enable,
    disable: stackContextPrefetch_disable,
    getConfiguration: stackContextPrefetch_getConfiguration,
    setConfiguration: stackContextPrefetch_setConfiguration,
};
/* harmony default export */ const stackPrefetch_stackContextPrefetch = ((/* unused pure expression or super */ null && (stackContextPrefetch)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js




// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js
var viewport = __webpack_require__(19027);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js
var touch = __webpack_require__(76260);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js
var segmentation_utilities = __webpack_require__(64063);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js


function getDataInTime(dynamicVolume, options) {
    let dataInTime;
    const dimensionGroups = options.dimensionGroupNumbers ||
        options.frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (options.frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    if (!options.maskVolumeId && !options.worldCoordinate) {
        throw new Error('You should provide either maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId && options.worldCoordinate) {
        throw new Error('You can only use one of maskVolumeId or imageCoordinate');
    }
    if (options.maskVolumeId) {
        const segmentationVolume = cache.getVolume(options.maskVolumeId);
        if (!segmentationVolume) {
            throw new Error('Segmentation volume not found');
        }
        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);
        return [dataInTime, ijkCoords];
    }
    if (options.worldCoordinate) {
        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);
        return dataInTime;
    }
    return dataInTime;
}
function _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {
    const { dimensions, imageData } = volume;
    const index = imageData.worldToIndex(coordinate);
    index[0] = Math.floor(index[0]);
    index[1] = Math.floor(index[1]);
    index[2] = Math.floor(index[2]);
    if (!utilities.indexWithinDimensions(index, dimensions)) {
        throw new Error('outside bounds');
    }
    const yMultiple = dimensions[0];
    const zMultiple = dimensions[0] * dimensions[1];
    const value = [];
    dimensionGroups.forEach((dimensionGroupNumber) => {
        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];
        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));
    });
    return value;
}
function _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {
    const { imageData: maskImageData } = segmentationVolume;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    const nonZeroVoxelIndices = [];
    nonZeroVoxelIndices.length = scalarDataLength;
    let actualLen = 0;
    for (let i = 0, len = scalarDataLength; i < len; i++) {
        if (segVoxelManager.getAtIndex(i) !== 0) {
            nonZeroVoxelIndices[actualLen++] = i;
        }
    }
    nonZeroVoxelIndices.length = actualLen;
    const nonZeroVoxelValuesInTime = [];
    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&
        JSON.stringify(dynamicVolume.spacing) ===
            JSON.stringify(segmentationVolume.spacing);
    const ijkCoords = [];
    if (isSameVolume) {
        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {
            const valuesInTime = [];
            const index = nonZeroVoxelIndices[i];
            for (let j = 0; j < dimensionGroups.length; j++) {
                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));
            }
            nonZeroVoxelValuesInTime.push(valuesInTime);
            ijkCoords.push(segVoxelManager.toIJK(index));
        }
        return [nonZeroVoxelValuesInTime, ijkCoords];
    }
    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {
        if (segValue === 0) {
            return;
        }
        const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);
        let count = 0;
        const perDimensionGroupSum = new Map();
        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));
        const averageCallback = ({ index }) => {
            for (let i = 0; i < dimensionGroups.length; i++) {
                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);
                const dimensionGroupNumber = dimensionGroups[i];
                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);
            }
            count++;
        };
        dynamicVolume.voxelManager.forEach(averageCallback, {
            imageData: dynamicVolume.imageData,
            boundsIJK: overlapIJKMinMax,
        });
        const averageValues = [];
        perDimensionGroupSum.forEach((sum) => {
            averageValues.push(sum / count);
        });
        ijkCoords.push(segPointIJK);
        nonZeroVoxelValuesInTime.push(averageValues);
    };
    segmentationVolume.voxelManager.forEach(callback, {
        imageData: maskImageData,
    });
    return [nonZeroVoxelValuesInTime, ijkCoords];
}
/* harmony default export */ const dynamicVolume_getDataInTime = ((/* unused pure expression or super */ null && (getDataInTime)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js

function sumOverDimensionGroups(voxelManager, dimensionGroups) {
    const arrayLength = voxelManager.getScalarDataLength();
    const resultArray = new Float32Array(arrayLength);
    for (const dimensionGroupNumber of dimensionGroups) {
        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);
        for (let i = 0; i < arrayLength; i++) {
            resultArray[i] += scalarData[i];
        }
    }
    return resultArray;
}
function averageOverDimensionGroups(voxelManager, dimensionGroups) {
    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
    const numDimensionGroups = dimensionGroups.length;
    for (let i = 0; i < sumArray.length; i++) {
        sumArray[i] /= numDimensionGroups;
    }
    return sumArray;
}
const operationFunctions = {
    [esm.Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [esm.Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {
        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);
        for (let i = 0; i < resultArray.length; i++) {
            callback(i, resultArray[i]);
        }
    },
    [esm.Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {
        if (dimensionGroups.length !== 2) {
            throw new Error('Please provide only 2 dimension groups for subtraction.');
        }
        const arrayLength = voxelManager.getScalarDataLength();
        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);
        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);
        for (let i = 0; i < arrayLength; i++) {
            const difference = scalarData1[i] - scalarData2[i];
            callback(i, difference);
        }
    },
};
function generateImageFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers } = options;
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const arrayLength = voxelManager.getScalarDataLength();
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    const resultArray = new Float32Array(arrayLength);
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        resultArray[index] = value;
    });
    return resultArray;
}
function updateVolumeFromTimeData(dynamicVolume, operation, options) {
    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;
    if (!targetVolume) {
        throw new Error('A target volume must be provided');
    }
    if (frameNumbers) {
        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');
    }
    const dimensionGroups = dimensionGroupNumbers ||
        frameNumbers ||
        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);
    if (dimensionGroups.length <= 1) {
        throw new Error('Please provide two or more dimension groups');
    }
    const voxelManager = dynamicVolume.voxelManager;
    const targetVoxelManager = targetVolume.voxelManager;
    const operationFunction = operationFunctions[operation];
    if (!operationFunction) {
        throw new Error(`Unsupported operation: ${operation}`);
    }
    operationFunction(voxelManager, dimensionGroups, (index, value) => {
        targetVoxelManager.setAtIndex(index, value);
    });
    targetVoxelManager.resetModifiedSlices();
    for (let k = 0; k < targetVolume.dimensions[2]; k++) {
        targetVoxelManager.modifiedSlices.add(k);
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js





;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js

function getPoint(points, idx) {
    const idx3 = idx * 3;
    if (idx3 < points.length) {
        return gl_matrix_esm/* vec3.fromValues */.eR.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);
    }
}
function getPolyDataPointIndexes(polyData) {
    const linesData = polyData.getLines().getData();
    let idx = 0;
    const lineSegments = new Map();
    while (idx < linesData.length) {
        const segmentSize = linesData[idx++];
        const segment = [];
        for (let i = 0; i < segmentSize; i++) {
            segment.push(linesData[idx + i]);
        }
        lineSegments.set(segment[0], segment);
        idx += segmentSize;
    }
    const contours = [];
    const findStartingPoint = (map) => {
        for (const [key, value] of map.entries()) {
            if (value !== undefined) {
                return key;
            }
        }
        return -1;
    };
    let startPoint = findStartingPoint(lineSegments);
    while (startPoint !== -1) {
        const contour = [startPoint];
        while (lineSegments.has(startPoint)) {
            const nextPoint = lineSegments.get(startPoint)[1];
            if (lineSegments.has(nextPoint)) {
                contour.push(nextPoint);
            }
            lineSegments.delete(startPoint);
            startPoint = nextPoint;
        }
        contours.push(contour);
        startPoint = findStartingPoint(lineSegments);
    }
    return contours.length ? contours : undefined;
}
function getPolyDataPoints(polyData) {
    const contoursIndexes = getPolyDataPointIndexes(polyData);
    if (!contoursIndexes) {
        return;
    }
    const rawPointsData = polyData.getPoints().getData();
    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/index.js
var colorbar_enums = __webpack_require__(51807);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/index.js + 4 modules
var common = __webpack_require__(57227);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js
var ColorbarRangeTextPosition = __webpack_require__(20646);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarCanvas.js + 1 modules
var ColorbarCanvas = __webpack_require__(33517);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ColorbarTicks.js
var ColorbarTicks = __webpack_require__(62184);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/common/isRangeTextPositionValid.js
var isRangeTextPositionValid = __webpack_require__(79457);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/widgets/Widget.js
var Widget = __webpack_require__(44845);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js








const DEFAULTS = {
    MULTIPLIER: 1,
    RANGE_TEXT_POSITION: ColorbarRangeTextPosition/* ColorbarRangeTextPosition */.U.Right,
    TICKS_BAR_SIZE: 50,
};
class Colorbar extends Widget/* default */.A {
    constructor(props) {
        super(props);
        this._isMouseOver = false;
        this._isInteracting = false;
        this._mouseOverCallback = (evt) => {
            this._isMouseOver = true;
            this.showTicks();
            evt.stopPropagation();
        };
        this._mouseOutCallback = (evt) => {
            this._isMouseOver = false;
            this.hideTicks();
            evt.stopPropagation();
        };
        this._mouseDownCallback = (evt) => {
            this._isInteracting = true;
            this.showTicks();
            this._addVOIEventListeners(evt);
            evt.stopPropagation();
        };
        this._mouseDragCallback = (evt, initialState) => {
            const multipliers = this.getVOIMultipliers();
            const currentPoints = this._getPointsFromMouseEvent(evt);
            const { points: startPoints, voiRange: startVOIRange } = initialState;
            const canvasDelta = gl_matrix_esm/* vec2.sub */.Zc.sub(gl_matrix_esm/* vec2.create */.Zc.create(), currentPoints.local, startPoints.local);
            const wwDelta = canvasDelta[0] * multipliers[0];
            const wcDelta = canvasDelta[1] * multipliers[1];
            if (!wwDelta && !wcDelta) {
                return;
            }
            const { lower: voiLower, upper: voiUpper } = startVOIRange;
            let { windowWidth, windowCenter } = esm.utilities.windowLevel.toWindowLevel(voiLower, voiUpper);
            windowWidth = Math.max(windowWidth + wwDelta, 1);
            windowCenter += wcDelta;
            const newVoiRange = esm.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);
            this.voiRange = newVoiRange;
            evt.stopPropagation();
            evt.preventDefault();
        };
        this._mouseUpCallback = (evt) => {
            this._isInteracting = false;
            this.hideTicks();
            this._removeVOIEventListeners();
            evt.stopPropagation();
        };
        this._eventListenersManager =
            new esm.utilities.eventListener.MultiTargetEventListenerManager();
        this._colormaps = Colorbar.getColormapsMap(props);
        this._activeColormapName = Colorbar.getInitialColormapName(props);
        this._canvas = this._createCanvas(props);
        this._ticksBar = this._createTicksBar(props);
        this._rangeTextPosition =
            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;
        this._canvas.appendTo(this.rootElement);
        this._ticksBar.appendTo(this.rootElement);
        this._addRootElementEventListeners();
    }
    get activeColormapName() {
        return this._activeColormapName;
    }
    set activeColormapName(colormapName) {
        if (colormapName === this._activeColormapName) {
            return;
        }
        const colormap = this._colormaps.get(colormapName);
        if (!colormap) {
            console.warn(`Invalid colormap name (${colormapName})`);
            return;
        }
        this._activeColormapName = colormapName;
        this._canvas.colormap = colormap;
    }
    get imageRange() {
        return this._canvas.imageRange;
    }
    set imageRange(imageRange) {
        this._canvas.imageRange = imageRange;
        this._ticksBar.imageRange = imageRange;
    }
    get voiRange() {
        return this._canvas.voiRange;
    }
    set voiRange(voiRange) {
        const { voiRange: currentVoiRange } = this._canvas;
        if (!(0,common/* isRangeValid */.kB)(voiRange) ||
            (0,common/* areColorbarRangesEqual */.bh)(voiRange, currentVoiRange)) {
            return;
        }
        this._canvas.voiRange = voiRange;
        this._ticksBar.voiRange = voiRange;
        this.onVoiChange(voiRange);
    }
    get showFullImageRange() {
        return this._canvas.showFullImageRange;
    }
    set showFullImageRange(value) {
        this._canvas.showFullImageRange = value;
        this._ticksBar.showFullPixelValueRange = value;
    }
    destroy() {
        super.destroy();
        this._eventListenersManager.reset();
    }
    createRootElement() {
        const rootElement = document.createElement('div');
        Object.assign(rootElement.style, {
            position: 'relative',
            fontSize: '0',
            width: '100%',
            height: '100%',
        });
        return rootElement;
    }
    onContainerResize() {
        super.onContainerResize();
        this.updateTicksBar();
        this._canvas.size = this.containerSize;
    }
    getVOIMultipliers() {
        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];
    }
    onVoiChange(voiRange) {
    }
    showTicks() {
        this.updateTicksBar();
        this._ticksBar.visible = true;
    }
    hideTicks() {
        if (this._isInteracting || this._isMouseOver) {
            return;
        }
        this._ticksBar.visible = false;
    }
    static getColormapsMap(props) {
        const { colormaps } = props;
        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());
    }
    static getInitialColormapName(props) {
        const { activeColormapName, colormaps } = props;
        const colormapExists = !!activeColormapName &&
            colormaps.some((cm) => cm.Name === activeColormapName);
        return colormapExists ? activeColormapName : colormaps[0].Name;
    }
    _createCanvas(props) {
        const { imageRange, voiRange, showFullPixelValueRange } = props;
        const colormap = this._colormaps.get(this._activeColormapName);
        return new ColorbarCanvas/* ColorbarCanvas */.n({
            colormap,
            imageRange,
            voiRange: voiRange,
            showFullPixelValueRange,
        });
    }
    _createTicksBar(props) {
        const ticksProps = props.ticks;
        return new ColorbarTicks/* ColorbarTicks */.f({
            imageRange: props.imageRange,
            voiRange: props.voiRange,
            ticks: ticksProps,
            showFullPixelValueRange: props.showFullPixelValueRange,
        });
    }
    _getPointsFromMouseEvent(evt) {
        const { rootElement: element } = this;
        const clientPoint = [evt.clientX, evt.clientY];
        const pagePoint = [evt.pageX, evt.pageY];
        const rect = element.getBoundingClientRect();
        const localPoints = [
            pagePoint[0] - rect.left - window.pageXOffset,
            pagePoint[1] - rect.top - window.pageYOffset,
        ];
        return { client: clientPoint, page: pagePoint, local: localPoints };
    }
    updateTicksBar() {
        const { width: containerWidth, height: containerHeight } = this.containerSize;
        if (containerWidth === 0 && containerHeight === 0) {
            return;
        }
        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;
        const isHorizontal = containerWidth >= containerHeight;
        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;
        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;
        if (!(0,isRangeTextPositionValid/* default */.A)(containerWidth, containerHeight, rangeTextPosition)) {
            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');
        }
        let ticksBarTop;
        let ticksBarLeft;
        ticksBar.size = { width, height };
        if (isHorizontal) {
            ticksBarLeft = 0;
            ticksBarTop =
                rangeTextPosition === ColorbarRangeTextPosition/* ColorbarRangeTextPosition */.U.Top
                    ? -height
                    : containerHeight;
        }
        else {
            ticksBarTop = 0;
            ticksBarLeft =
                rangeTextPosition === ColorbarRangeTextPosition/* ColorbarRangeTextPosition */.U.Left
                    ? -width
                    : containerWidth;
        }
        ticksBar.top = ticksBarTop;
        ticksBar.left = ticksBarLeft;
    }
    _addRootElementEventListeners() {
        const { _eventListenersManager: manager } = this;
        const { rootElement: element } = this;
        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);
        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);
        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);
    }
    _addVOIEventListeners(evt) {
        const { _eventListenersManager: manager } = this;
        const points = this._getPointsFromMouseEvent(evt);
        const voiRange = { ...this._canvas.voiRange };
        const initialDragState = { points, voiRange };
        this._removeVOIEventListeners();
        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);
        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));
    }
    _removeVOIEventListeners() {
        const { _eventListenersManager: manager } = this;
        manager.removeEventListener(document, 'voi.mouseup');
        manager.removeEventListener(document, 'voi.mousemove');
    }
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getVOIMultipliers.js
var getVOIMultipliers = __webpack_require__(22658);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js



const { Events: ViewportColorbar_Events } = esm.Enums;
const defaultImageRange = { lower: -1000, upper: 1000 };
class ViewportColorbar extends Colorbar {
    constructor(props) {
        const { element, volumeId } = props;
        const imageRange = ViewportColorbar._getImageRange(element, volumeId);
        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);
        super({ ...props, imageRange, voiRange });
        this.autoHideTicks = () => {
            if (this._hideTicksTimeoutId) {
                return;
            }
            const timeLeft = this._hideTicksTime - Date.now();
            if (timeLeft <= 0) {
                this.hideTicks();
            }
            else {
                this._hideTicksTimeoutId = window.setTimeout(() => {
                    this._hideTicksTimeoutId = 0;
                    this.autoHideTicks();
                }, timeLeft);
            }
        };
        this._stackNewImageCallback = () => {
            this.imageRange = ViewportColorbar._getImageRange(this._element);
        };
        this._imageVolumeModifiedCallback = (evt) => {
            const { volumeId } = evt.detail;
            if (volumeId !== this._volumeId) {
                return;
            }
            const { _element: element } = this;
            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);
        };
        this._viewportVOIModifiedCallback = (evt) => {
            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.voiRange = voiRange;
            if (colormap) {
                this.activeColormapName = colormap.name;
            }
            this.showAndAutoHideTicks();
        };
        this._viewportColormapModifiedCallback = (evt) => {
            const { viewportId, colormap, volumeId } = evt.detail;
            const { viewport } = this.enabledElement;
            if (viewportId !== viewport.id || volumeId !== this._volumeId) {
                return;
            }
            this.activeColormapName = colormap.name;
        };
        this._element = element;
        this._volumeId = volumeId;
        this._addCornerstoneEventListener();
    }
    get element() {
        return this._element;
    }
    get enabledElement() {
        return (0,esm.getEnabledElement)(this._element);
    }
    getVOIMultipliers() {
        const { viewport } = this.enabledElement;
        return (0,getVOIMultipliers/* getVOIMultipliers */.j)(viewport, this._volumeId);
    }
    onVoiChange(voiRange) {
        super.onVoiChange(voiRange);
        const { viewport } = this.enabledElement;
        if (viewport instanceof esm.StackViewport) {
            viewport.setProperties({
                voiRange: voiRange,
            });
            viewport.render();
        }
        else if (viewport instanceof esm.VolumeViewport) {
            const { _volumeId: volumeId } = this;
            const viewportsContainingVolumeUID = esm.utilities.getViewportsWithVolumeId(volumeId);
            viewport.setProperties({ voiRange }, volumeId);
            viewportsContainingVolumeUID.forEach((vp) => vp.render());
        }
    }
    static _getImageRange(element, volumeId) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const imageData = actor.getMapper().getInputData();
        const scalarData = imageData.getPointData().getScalars();
        let imageRange;
        if (!scalarData) {
            if (!volumeId) {
                throw new Error('volumeId is required when scalarData is not available');
            }
            const volume = esm.cache.getVolume(volumeId);
            const [minValue, maxValue] = volume.voxelManager.getRange();
            imageRange = [minValue, maxValue];
        }
        else {
            imageRange = scalarData.getRange();
        }
        return imageRange[0] === 0 && imageRange[1] === 0
            ? defaultImageRange
            : { lower: imageRange[0], upper: imageRange[1] };
    }
    static _getVOIRange(element, volumeId) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const actor = viewport.getImageActor(volumeId);
        if (!actor) {
            return defaultImageRange;
        }
        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();
        return voiRange[0] === 0 && voiRange[1] === 0
            ? defaultImageRange
            : { lower: voiRange[0], upper: voiRange[1] };
    }
    showAndAutoHideTicks(interval = 1000) {
        this._hideTicksTime = Date.now() + interval;
        this.showTicks();
        this.autoHideTicks();
    }
    _addCornerstoneEventListener() {
        const { _element: element } = this;
        esm.eventTarget.addEventListener(ViewportColorbar_Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.addEventListener(ViewportColorbar_Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.addEventListener(ViewportColorbar_Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.addEventListener(ViewportColorbar_Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
    destroy() {
        super.destroy();
        const { _element: element } = this;
        esm.eventTarget.removeEventListener(ViewportColorbar_Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);
        element.removeEventListener(ViewportColorbar_Events.STACK_NEW_IMAGE, this._stackNewImageCallback);
        element.removeEventListener(ViewportColorbar_Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);
        element.removeEventListener(ViewportColorbar_Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/index.js





;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js
function getLuminanceFromRegion(imageData, x, y, width, height) {
    const luminance = [];
    let index = 0;
    const pixelData = imageData.scalarData;
    let spIndex, row, column;
    if (imageData.color) {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;
                const red = pixelData[spIndex];
                const green = pixelData[spIndex + 1];
                const blue = pixelData[spIndex + 2];
                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
            }
        }
    }
    else {
        for (row = 0; row < height; row++) {
            for (column = 0; column < width; column++) {
                spIndex = (row + y) * imageData.columns + (column + x);
                luminance[index++] = pixelData[spIndex];
            }
        }
    }
    return luminance;
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js
function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {
    const numPixels = pixelLuminance.length;
    let min = globalMax;
    let max = globalMin;
    let sum = 0;
    if (numPixels < 2) {
        return {
            min,
            max,
            mean: (globalMin + globalMax) / 2,
        };
    }
    for (let index = 0; index < numPixels; index++) {
        const spv = pixelLuminance[index];
        min = Math.min(min, spv);
        max = Math.max(max, spv);
        sum += spv;
    }
    return {
        min,
        max,
        mean: sum / numPixels,
    };
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js

function extractWindowLevelRegionToolData(viewport) {
    if (viewport instanceof esm.VolumeViewport) {
        return extractImageDataVolume(viewport);
    }
    if (viewport instanceof esm.StackViewport) {
        return extractImageDataStack(viewport);
    }
    throw new Error('Viewport not supported');
}
function extractImageDataVolume(viewport) {
    const { scalarData, width, height } = esm.utilities.getCurrentVolumeViewportSlice(viewport);
    const { min: minPixelValue, max: maxPixelValue } = esm.utilities.getMinMax(scalarData);
    return {
        scalarData,
        minPixelValue,
        maxPixelValue,
        width,
        height,
        rows: width,
        columns: height,
    };
}
function extractImageDataStack(viewport) {
    const imageData = viewport.getImageData();
    const { scalarData } = imageData;
    const { min: minPixelValue, max: maxPixelValue } = esm.utilities.getMinMax(scalarData);
    const width = imageData.dimensions[0];
    const height = imageData.dimensions[1];
    const { rows, columns, color } = viewport.getCornerstoneImage();
    return {
        scalarData,
        width,
        height,
        minPixelValue,
        maxPixelValue,
        rows,
        columns,
        color,
    };
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/index.js





;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/index.js




// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js + 1 modules
var contourSegmentation = __webpack_require__(56534);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js + 1 modules
var sphere = __webpack_require__(62783);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js




const { transformWorldToIndex } = esm.utilities;
function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {
    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);
    const sphereObj = {
        center: centerWorld,
        radius: radiusWorld,
    };
    const dimensions = imageData.getDimensions();
    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({
        dimensions: dimensions,
        scalarData: imageData.getPointData().getScalars().getData(),
    });
    voxelManager.forEach(callback, {
        boundsIJK,
        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),
        imageData,
    });
}
function _getBounds(circlePoints, imageData, viewport) {
    const [bottom, top] = circlePoints;
    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = vec3.distance(bottom, top) / 2;
    let boundsIJK;
    if (!viewport) {
        const centerIJK = transformWorldToIndex(imageData, centerWorld);
        const spacings = imageData.getSpacing();
        const minSpacing = Math.min(...spacings);
        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);
        boundsIJK = [
            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],
            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],
            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],
        ];
        return {
            boundsIJK,
            centerWorld: centerWorld,
            radiusWorld,
        };
    }
    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
    };
}
function _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {
    const [bottom, top] = circlePoints;
    const dimensions = imageData.getDimensions();
    const camera = viewport.getCamera();
    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = vec3.create();
    vec3.cross(viewRight, viewUp, viewPlaneNormal);
    const topLeftWorld = vec3.create();
    const bottomRightWorld = vec3.create();
    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);
    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);
    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);
    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);
    const sphereCornersIJK = [
        transformWorldToIndex(imageData, topLeftWorld),
        (transformWorldToIndex(imageData, bottomRightWorld)),
    ];
    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);
    return boundsIJK;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js
var normalizeViewportPlane = __webpack_require__(27963);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js
var islandRemoval = __webpack_require__(67912);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js
var getPixelValueUnits = __webpack_require__(40634);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/geometricSurfaceUtils.js
var geometricSurfaceUtils = __webpack_require__(5565);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
var helpers_state = __webpack_require__(44049);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js


function setAnnotationLabel(annotation, element, updatedLabel) {
    annotation.data.label = updatedLabel;
    (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.LabelChange);
}

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/vec3.js
var esm_vec3 = __webpack_require__(9175);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js


function moveAnnotationToViewPlane(annotation, viewport) {
    const { data } = annotation;
    const { points } = data.handles;
    const { focalPoint, viewPlaneNormal } = viewport.getCamera();
    const projectedDistance = vec3.dot(vec3.sub(vec3.create(), points[0], focalPoint), viewPlaneNormal);
    points.forEach((point) => {
        vec3.add(point, point, vec3.scale(vec3.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));
    });
    if (viewport instanceof StackViewport) {
        annotation.metadata.referencedImageId = viewport.getCurrentImageId();
    }
    return annotation;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js
var getOrCreateImageVolume = __webpack_require__(83075);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/segmentLargestUSOutlineFromBuffer.js

function segmentLargestUSOutlineFromBuffer(buffer, width, height) {
    const totalPixels = width * height;
    const channelCount = buffer.length / totalPixels;
    if (![1, 3, 4].includes(channelCount)) {
        throw new Error('Buffer must be 1, 3, or 4 channels per pixel');
    }
    const mask = Array.from({ length: height }, () => new Array(width).fill(false));
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const pixelIndex = y * width + x;
            const base = pixelIndex * channelCount;
            let isForeground = false;
            for (let c = 0; c < Math.min(3, channelCount); c++) {
                if (buffer[base + c] > 0) {
                    isForeground = true;
                    break;
                }
            }
            mask[y][x] = isForeground;
        }
    }
    const labels = Array.from({ length: height }, () => new Array(width).fill(0));
    let currentLabel = 0;
    const regionSizes = {};
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (mask[y][x] && labels[y][x] === 0) {
                currentLabel++;
                const getter = (px, py) => {
                    if (px < 0 || px >= width || py < 0 || py >= height) {
                        return false;
                    }
                    return mask[py][px] && labels[py][px] === 0;
                };
                let pixelCount = 0;
                const options = {
                    onFlood: (px, py) => {
                        labels[py][px] = currentLabel;
                        pixelCount++;
                    },
                    diagonals: false,
                };
                (0,segmentation.floodFill)(getter, [x, y], options);
                regionSizes[currentLabel] = pixelCount;
            }
        }
    }
    if (currentLabel === 0) {
        return [];
    }
    const largestLabel = Object.keys(regionSizes).reduce((a, b) => regionSizes[a] > regionSizes[b] ? a : b);
    function isBorder(x, y) {
        if (labels[y][x] !== +largestLabel) {
            return false;
        }
        for (const [dx, dy] of [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
        ]) {
            const nx = x + dx, ny = y + dy;
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                labels[ny][nx] !== +largestLabel) {
                return true;
            }
        }
        return false;
    }
    let start = null;
    outer: for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (isBorder(x, y)) {
                start = [x, y];
                break outer;
            }
        }
    }
    if (!start) {
        return [];
    }
    const dirs = [
        [1, 0],
        [1, 1],
        [0, 1],
        [-1, 1],
        [-1, 0],
        [-1, -1],
        [0, -1],
        [1, -1],
    ];
    const contour = [];
    let current = start;
    let prev = [start[0] - 1, start[1]];
    do {
        contour.push([current[0], current[1]]);
        const dx0 = prev[0] - current[0], dy0 = prev[1] - current[1];
        let startDir = dirs.findIndex((d) => d[0] === dx0 && d[1] === dy0);
        if (startDir < 0) {
            startDir = 0;
        }
        let nextPt = null;
        for (let k = 1; k <= 8; k++) {
            const [dx, dy] = dirs[(startDir + k) % 8];
            const nx = current[0] + dx, ny = current[1] + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height && isBorder(nx, ny)) {
                nextPt = [nx, ny];
                const [bdx, bdy] = dirs[(startDir + k - 1 + 8) % 8];
                prev = [current[0] + bdx, current[1] + bdy];
                break;
            }
        }
        if (!nextPt) {
            break;
        }
        current = nextPt;
    } while (current[0] !== start[0] || current[1] !== start[1]);
    return contour;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/generateConvexHullFromContour.js

function generateConvexHullFromContour(contour) {
    const simplified = math.polyline.decimate(contour, 2);
    const hull = math.polyline.convexHull(simplified);
    return { simplified, hull };
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/calculateFanShapeCorners.js
function pickPoints(hull, slack = 7) {
    if (!hull.length) {
        throw new Error('Convex hull is empty');
    }
    const n = hull.length;
    const next = (i) => (i + 1) % n;
    const walk = (from, to) => {
        const idx = [];
        for (let i = from;; i = next(i)) {
            idx.push(i);
            if (i === to) {
                break;
            }
        }
        return idx;
    };
    let i2 = 0, i3 = 0;
    for (let i = 1; i < n; i++) {
        if (hull[i][0] < hull[i2][0]) {
            i2 = i;
        }
        if (hull[i][0] > hull[i3][0]) {
            i3 = i;
        }
    }
    const P2 = hull[i2];
    const P3 = hull[i3];
    const pathA = walk(i2, i3);
    const pathB = walk(i3, i2);
    const globalYmin = Math.min(...hull.map((p) => p[1]));
    const upperPath = pathA.some((i) => hull[i][1] === globalYmin)
        ? pathA
        : pathB;
    const topY = Math.min(...upperPath.map((i) => hull[i][1]));
    let arcPts = upperPath
        .map((i) => hull[i])
        .filter((p) => Math.abs(p[1] - topY) <= slack);
    if (arcPts.length < 2) {
        arcPts = upperPath
            .map((i) => hull[i])
            .sort((a, b) => a[1] - b[1])
            .slice(0, 2);
    }
    const P1 = arcPts.reduce((best, p) => (p[0] < best[0] ? p : best), arcPts[0]);
    const P4 = arcPts.reduce((best, p) => (p[0] > best[0] ? p : best), arcPts[0]);
    return { P1, P2, P3, P4 };
}
function computeEdgeBuffer(buffer, width, height) {
    const total = width * height;
    const channels = buffer.length / total;
    if (![1, 3, 4].includes(channels)) {
        throw new Error('Buffer must be 1,3 or 4 channels per pixel');
    }
    const gray = new Float32Array(total);
    for (let i = 0; i < total; i++) {
        if (channels === 1) {
            gray[i] = buffer[i];
        }
        else {
            const base = i * channels;
            const r = buffer[base];
            const g = buffer[base + 1];
            const b = buffer[base + 2];
            gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
        }
    }
    const edgeBuf = new Float32Array(total);
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            const i00 = idx - width - 1;
            const i01 = idx - width;
            const i02 = idx - width + 1;
            const i10 = idx - 1;
            const i11 = idx;
            const i12 = idx + 1;
            const i20 = idx + width - 1;
            const i21 = idx + width;
            const i22 = idx + width + 1;
            const gx = -gray[i00] +
                gray[i02] +
                -2 * gray[i10] +
                2 * gray[i12] +
                -gray[i20] +
                gray[i22];
            const gy = gray[i00] +
                2 * gray[i01] +
                gray[i02] -
                gray[i20] -
                2 * gray[i21] -
                gray[i22];
            edgeBuf[idx] = Math.hypot(gx, gy);
        }
    }
    return edgeBuf;
}
function refineCornersDirectional(edgeBuf, width, height, rough, contour, opts = {}) {
    const { maxDist = 15, slack = 2 } = opts;
    const directions = {
        P1: { dx: -1, dy: -1 },
        P2: { dx: -1, dy: +1 },
        P3: { dx: +1, dy: +1 },
        P4: { dx: +1, dy: -1 },
    };
    function snapQuadrant(pt, { dx, dy }, threshold = 5) {
        const xmin = dx < 0 ? pt[0] - maxDist : pt[0] - slack;
        const xmax = dx < 0 ? pt[0] + slack : pt[0] + maxDist;
        const ymin = dy < 0 ? pt[1] - maxDist : pt[1] - slack;
        const ymax = dy < 0 ? pt[1] + slack : pt[1] + maxDist;
        let best = pt;
        for (const [cx, cy] of contour) {
            if (cx < xmin || cx > xmax || cy < ymin || cy > ymax) {
                continue;
            }
            const xi = Math.round(cx);
            const yi = Math.round(cy);
            if (xi < 0 || xi >= width || yi < 0 || yi >= height) {
                continue;
            }
            const xAlign = (xi - best[0]) * dx;
            const yAlign = (yi - best[0]) * dy;
            const v = edgeBuf[yi * width + xi];
            if (v > threshold && (xAlign > 0 || yAlign > 0)) {
                best = [cx, cy];
            }
        }
        return best;
    }
    return {
        P1: snapQuadrant(rough.P1, directions.P1),
        P2: snapQuadrant(rough.P2, directions.P2),
        P3: snapQuadrant(rough.P3, directions.P3),
        P4: snapQuadrant(rough.P4, directions.P4),
    };
}
function calculateFanShapeCorners(imageBuffer, width, height, hull, roughContour) {
    const rough = pickPoints(hull);
    const refined = refineCornersDirectional(imageBuffer, width, height, rough, roughContour, {
        maxDist: 20,
        step: 0.5,
    });
    return refined;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js
var math_line = __webpack_require__(93258);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/deriveFanGeometry.js

function angleRad(center, p) {
    return Math.atan2(p[1] - center[1], p[0] - center[0]);
}
function deriveFanGeometry(params) {
    const { P1, P2, P3, P4 } = params;
    const centerResult = (0,math_line.intersectLine)(P1, P2, P4, P3, true);
    if (!centerResult) {
        throw new Error('Fan edges appear parallel  no apex found');
    }
    const center = centerResult;
    let startAngle = angleRad(center, P1) * (180 / Math.PI);
    let endAngle = angleRad(center, P4) * (180 / Math.PI);
    if (endAngle <= startAngle) {
        const tempAngle = startAngle;
        startAngle = endAngle;
        endAngle = tempAngle;
    }
    const d1 = Math.hypot(P1[0] - center[0], P1[1] - center[1]);
    const d4 = Math.hypot(P4[0] - center[0], P4[1] - center[1]);
    const d2 = Math.hypot(P2[0] - center[0], P2[1] - center[1]);
    const d3 = Math.hypot(P3[0] - center[0], P3[1] - center[1]);
    const innerRadius = Math.min(d1, d4);
    const outerRadius = Math.max(d2, d3);
    return {
        center,
        startAngle,
        endAngle,
        innerRadius,
        outerRadius,
    };
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction.js





function exportContourJpeg(pixelData, width, height, contour, opts = {}) {
    const { strokeStyle = '#f00', lineWidth = 2, quality = 0.92 } = opts;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const totalPixels = width * height;
    const channels = pixelData.length / totalPixels;
    const imgData = ctx.createImageData(width, height);
    const out = imgData.data;
    for (let i = 0; i < totalPixels; i++) {
        const baseIn = i * channels;
        const baseOut = i * 4;
        if (channels === 1) {
            const v = pixelData[baseIn];
            out[baseOut] = v;
            out[baseOut + 1] = v;
            out[baseOut + 2] = v;
            out[baseOut + 3] = 255;
        }
        else {
            out[baseOut] = pixelData[baseIn];
            out[baseOut + 1] = pixelData[baseIn + 1];
            out[baseOut + 2] = pixelData[baseIn + 2];
            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;
        }
    }
    ctx.putImageData(imgData, 0, 0);
    if (contour.length > 0) {
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(contour[0][0] + 0.5, contour[0][1] + 0.5);
        for (let i = 1; i < contour.length; i++) {
            ctx.lineTo(contour[i][0] + 0.5, contour[i][1] + 0.5);
        }
        ctx.closePath();
        ctx.stroke();
    }
    return canvas.toDataURL('image/jpeg', quality);
}
function getPixelData(imageId) {
    const image = esm.cache.getImage(imageId);
    if (!image) {
        return;
    }
    const width = image.width;
    const height = image.height;
    const pixelData = image.getPixelData();
    return {
        pixelData,
        width,
        height,
    };
}
function saveBinaryData(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.style.display = 'none';
    a.click();
    a.remove();
}
function exportFanJpeg(pixelData, width, height, fan, opts = {}) {
    const { center, startAngle: startAngleInDegrees, endAngle: endAngleInDegrees, innerRadius, outerRadius, } = fan;
    const { strokeStyle = '#0ff', lineWidth = 2, quality = 0.92 } = opts;
    const startAngle = (startAngleInDegrees * Math.PI) / 180;
    const endAngle = (endAngleInDegrees * Math.PI) / 180;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const total = width * height;
    const channels = pixelData.length / total;
    const imgData = ctx.createImageData(width, height);
    const out = imgData.data;
    for (let i = 0; i < total; i++) {
        const baseOut = i * 4;
        if (channels === 1) {
            const v = pixelData[i];
            out[baseOut] = v;
            out[baseOut + 1] = v;
            out[baseOut + 2] = v;
            out[baseOut + 3] = 255;
        }
        else {
            const baseIn = i * channels;
            out[baseOut] = pixelData[baseIn];
            out[baseOut + 1] = pixelData[baseIn + 1];
            out[baseOut + 2] = pixelData[baseIn + 2];
            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;
        }
    }
    ctx.putImageData(imgData, 0, 0);
    ctx.beginPath();
    for (let a = startAngle; a <= endAngle; a += 0.01) {
        const x = center[0] + innerRadius * Math.cos(a);
        const y = center[1] + innerRadius * Math.sin(a);
        if (a === startAngle) {
            ctx.moveTo(x, y);
        }
        else {
            ctx.lineTo(x, y);
        }
    }
    for (let a = endAngle; a >= startAngle; a -= 0.01) {
        const x = center[0] + outerRadius * Math.cos(a);
        const y = center[1] + outerRadius * Math.sin(a);
        ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
    return canvas.toDataURL('image/jpeg', quality);
}
function downloadFanJpeg(imageId, contourType = 5) {
    const { contour, simplified, hull, refined, fanGeometry } = calculateFanGeometry(imageId);
    const { pixelData, width, height } = getPixelData(imageId) || {};
    if (!pixelData) {
        return;
    }
    let jpegDataUrl;
    if (contourType === 1) {
        jpegDataUrl = exportContourJpeg(pixelData, width, height, contour);
    }
    else if (contourType === 2) {
        jpegDataUrl = exportContourJpeg(pixelData, width, height, simplified);
    }
    else if (contourType === 3) {
        jpegDataUrl = exportContourJpeg(pixelData, width, height, hull);
    }
    else if (contourType === 4) {
        jpegDataUrl = exportContourJpeg(pixelData, width, height, [
            refined.P1,
            refined.P2,
            refined.P3,
            refined.P4,
        ]);
    }
    else {
        jpegDataUrl = exportFanJpeg(pixelData, width, height, fanGeometry, {
            strokeStyle: '#f00',
            lineWidth: 3,
            quality: 0.95,
        });
    }
    saveBinaryData(jpegDataUrl, 'contour.jpg');
}
function calculateFanGeometry(imageId) {
    const { pixelData, width, height } = getPixelData(imageId) || {};
    if (!pixelData) {
        return;
    }
    const contour = segmentLargestUSOutlineFromBuffer(pixelData, width, height);
    const { simplified, hull } = generateConvexHullFromContour(contour);
    const refined = calculateFanShapeCorners(pixelData, width, height, hull, simplified);
    const fanGeometry = deriveFanGeometry({
        P1: refined.P1,
        P2: refined.P2,
        P3: refined.P3,
        P4: refined.P4,
    });
    return { contour, simplified, hull, refined, fanGeometry };
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js


































const roundNumber = esm.utilities.roundNumber;










// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js + 4 modules
var cursors = __webpack_require__(79475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/types/index.js
var types = __webpack_require__(13369);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js + 1 modules
var annotation = __webpack_require__(47807);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js + 9 modules
var stateManagement_segmentation = __webpack_require__(55126);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js

class Spline_Spline {
    constructor(props) {
        this._controlPoints = [];
        this._invalidated = false;
        this._length = 0;
        this._controlPoints = [];
        this._resolution = props?.resolution ?? 20;
        this._fixedResolution = props?.fixedResolution ?? false;
        this._closed = props?.closed ?? false;
        this._invalidated = true;
    }
    get controlPoints() {
        return this._controlPoints;
    }
    get numControlPoints() {
        return this._controlPoints.length;
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        if (this._fixedResolution || this._resolution === resolution) {
            return;
        }
        this._resolution = resolution;
        this.invalidated = true;
    }
    get fixedResolution() {
        return this._fixedResolution;
    }
    get closed() {
        return this._closed;
    }
    set closed(closed) {
        if (this._closed === closed) {
            return;
        }
        this._closed = closed;
        this.invalidated = true;
    }
    get aabb() {
        this._update();
        return this._aabb;
    }
    get length() {
        this._update();
        return this._length;
    }
    get invalidated() {
        return this._invalidated;
    }
    set invalidated(invalidated) {
        this._invalidated = invalidated;
    }
    hasTangentPoints() {
        return false;
    }
    addControlPoint(point) {
        this._controlPoints.push([point[0], point[1]]);
        this.invalidated = true;
    }
    addControlPoints(points) {
        points.forEach((point) => this.addControlPoint(point));
    }
    addControlPointAtU(u) {
        const lineSegment = this._getLineSegmentAt(u);
        const { start: startPoint, end: endPoint } = lineSegment.points;
        const curveSegmentIndex = Math.floor(u);
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const t = u - Math.floor(curveSegmentIndex);
        const controlPointPos = [
            startPoint[0] + t * (endPoint[0] - startPoint[0]),
            startPoint[1] + t * (endPoint[1] - startPoint[1]),
        ];
        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;
        this._controlPoints.splice(insertIndex, 0, controlPointPos);
        this.invalidated = true;
        return {
            index: insertIndex,
            point: controlPointPos,
        };
    }
    deleteControlPointByIndex(index) {
        const minControlPoints = this._closed ? 3 : 1;
        const canDelete = index >= 0 &&
            index < this._controlPoints.length &&
            this._controlPoints.length > minControlPoints;
        if (!canDelete) {
            return false;
        }
        this._controlPoints.splice(index, 1);
        this.invalidated = true;
        return true;
    }
    clearControlPoints() {
        this._controlPoints = [];
        this.invalidated = true;
    }
    setControlPoints(points) {
        this.clearControlPoints();
        this.addControlPoints(points);
    }
    updateControlPoint(index, newControlPoint) {
        if (index < 0 || index >= this._controlPoints.length) {
            throw new Error('Index out of bounds');
        }
        this._controlPoints[index] = [...newControlPoint];
        this.invalidated = true;
    }
    getControlPoints() {
        return this._controlPoints.map((controlPoint) => [
            controlPoint[0],
            controlPoint[1],
        ]);
    }
    getClosestControlPoint(point) {
        const controlPoints = this._controlPoints;
        let minSquaredDist = Infinity;
        let closestPointIndex = -1;
        for (let i = 0, len = controlPoints.length; i < len; i++) {
            const controlPoint = controlPoints[i];
            const dx = point[0] - controlPoint[0];
            const dy = point[1] - controlPoint[1];
            const squaredDist = dx * dx + dy * dy;
            if (squaredDist < minSquaredDist) {
                minSquaredDist = squaredDist;
                closestPointIndex = i;
            }
        }
        return {
            index: closestPointIndex,
            point: closestPointIndex === -1
                ? undefined
                : [...controlPoints[closestPointIndex]],
            distance: Math.sqrt(minSquaredDist),
        };
    }
    getClosestControlPointWithinDistance(point, maxDist) {
        const closestControlPoint = this.getClosestControlPoint(point);
        return closestControlPoint.distance <= maxDist
            ? closestControlPoint
            : undefined;
    }
    getClosestPoint(point) {
        this._update();
        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);
        if (!curveSegmentsDistInfo.length) {
            return;
        }
        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);
        let closestPoint;
        let closestPointCurveSegmentIndex = -1;
        let minDistSquared = Infinity;
        let minDistCurveSegment;
        let minDistLineSegment;
        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {
            const curveSegmentDistInfo = curveSegmentsDistInfo[i];
            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {
                continue;
            }
            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;
            const { lineSegments } = curveSegment;
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);
                if (lineSegDistSquared < minDistSquared) {
                    minDistLineSegment = lineSegment;
                    closestPointCurveSegmentIndex = curveSegmentIndex;
                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;
                    closestPoint = lineSegPoint;
                    minDistSquared = lineSegDistSquared;
                }
            }
        }
        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +
            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);
        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;
        const u = closestPointCurveSegmentIndex + t;
        return {
            point: closestPoint,
            uValue: u,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getClosestPointOnControlPointLines(point) {
        const linePoints = [...this._controlPoints];
        if (this._closed) {
            linePoints.push(this._controlPoints[0]);
        }
        if (!linePoints.length) {
            return;
        }
        let closestPoint;
        let minDistSquared = Infinity;
        let startPoint = linePoints[0];
        for (let i = 1, len = linePoints.length; i < len; i++) {
            const endPoint = linePoints[i];
            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);
            if (lineSegDistSquared < minDistSquared) {
                closestPoint = lineSegPoint;
                minDistSquared = lineSegDistSquared;
            }
            startPoint = endPoint;
        }
        return {
            point: closestPoint,
            distance: Math.sqrt(minDistSquared),
        };
    }
    getPolylinePoints() {
        this._update();
        return this._convertCurveSegmentsToPolyline(this._curveSegments);
    }
    getPreviewPolylinePoints(controlPointPreview, closeDistance) {
        if (this._closed) {
            return [];
        }
        this._update();
        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);
        const closeSpline = closestControlPoint?.index === 0;
        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);
        return previewCurveSegments?.length
            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)
            : [];
    }
    isPointNearCurve(point, maxDist) {
        this._update();
        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);
        const maxDistSquared = maxDist * maxDist;
        for (let i = 0; i < curveSegments.length; i++) {
            const { lineSegments } = curveSegments[i];
            for (let j = 0; j < lineSegments.length; j++) {
                const lineSegment = lineSegments[j];
                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);
                if (lineDistSquared <= maxDistSquared) {
                    return true;
                }
            }
        }
        return false;
    }
    containsPoint(point) {
        this._update();
        const controlPoints = this._controlPoints;
        if (controlPoints.length < 3) {
            return false;
        }
        const curveSegments = [...this._curveSegments];
        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();
        if (closingCurveSegment) {
            curveSegments.push(closingCurveSegment);
        }
        let numIntersections = 0;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const { aabb: curveSegAABB } = curveSegment;
            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&
                point[1] >= curveSegAABB.minY &&
                point[1] < curveSegAABB.maxY;
            if (!mayIntersectCurveSegment) {
                continue;
            }
            const { lineSegments } = curveSegment;
            for (let i = 0; i < lineSegments.length; i++) {
                const lineSegment = lineSegments[i];
                const { aabb: lineSegmentAABB } = lineSegment;
                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&
                    point[1] >= lineSegmentAABB.minY &&
                    point[1] < lineSegmentAABB.maxY;
                if (mayIntersectLineSegment) {
                    const { start: p1, end: p2 } = lineSegment.points;
                    const isVerticalLine = p1[0] === p2[0];
                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];
                    numIntersections +=
                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;
                }
            }
        }
        return numIntersections % 2 === 1;
    }
    _update() {
        if (!this._invalidated) {
            return;
        }
        const curveSegments = this.getSplineCurves();
        let length = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0, len = curveSegments.length; i < len; i++) {
            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];
            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;
            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;
            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;
            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;
            length += curveSegLength;
        }
        this._curveSegments = curveSegments;
        this._aabb = { minX, minY, maxX, maxY };
        this._length = length;
        this._invalidated = false;
    }
    _convertCurveSegmentsToPolyline(curveSegments) {
        this._update();
        const polylinePoints = [];
        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {
            lineSegments.forEach((lineSegment, lineSegIndex) => {
                if (curveSegIndex === 0 && lineSegIndex === 0) {
                    polylinePoints.push([...lineSegment.points.start]);
                }
                polylinePoints.push([...lineSegment.points.end]);
            });
        });
        return polylinePoints;
    }
    _getCurveSegmmentsDistanceSquaredInfo(point) {
        this._update();
        const curveSegmentsDistanceSquared = [];
        const { _curveSegments: curveSegments } = this;
        for (let i = 0; i < curveSegments.length; i++) {
            const curveSegment = curveSegments[i];
            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);
            curveSegmentsDistanceSquared.push({
                curveSegmentIndex: i,
                curveSegment,
                distanceSquared,
            });
        }
        return curveSegmentsDistanceSquared;
    }
    _getCurveSegmmentsWithinDistance(point, maxDist) {
        this._update();
        const maxDistSquared = maxDist * maxDist;
        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {
            return [];
        }
        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);
        const curveSegmentsWithinRange = [];
        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {
            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];
            if (curveSegmentDistSquared <= maxDistSquared) {
                curveSegmentsWithinRange.push(curveSegment);
            }
        }
        return curveSegmentsWithinRange;
    }
    _getLineSegmentAt(u) {
        this._update();
        const curveSegmentIndex = Math.floor(u);
        const t = u - curveSegmentIndex;
        const curveSegment = this._curveSegments[curveSegmentIndex];
        const { lineSegments } = curveSegment;
        const pointLength = curveSegment.length * t;
        for (let i = 0; i < lineSegments.length; i++) {
            const lineSegment = lineSegments[i];
            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;
            if (pointLength >= lineSegment.previousLineSegmentsLength &&
                pointLength <= lengthEnd) {
                return lineSegment;
            }
        }
    }
    _getClosingCurveSegmentWithStraightLineSegment() {
        if (this.closed) {
            return;
        }
        const controlPoints = this._controlPoints;
        const startControlPoint = controlPoints[0];
        const endControlPoint = controlPoints[controlPoints.length - 1];
        const closingLineSegment = {
            points: {
                start: [...startControlPoint],
                end: [...endControlPoint],
            },
            aabb: {
                minX: Math.min(startControlPoint[0], endControlPoint[0]),
                minY: Math.min(startControlPoint[1], endControlPoint[1]),
                maxX: Math.max(startControlPoint[0], endControlPoint[0]),
                maxY: Math.max(startControlPoint[1], endControlPoint[1]),
            },
        };
        return {
            aabb: {
                minX: closingLineSegment.aabb.minX,
                minY: closingLineSegment.aabb.minY,
                maxX: closingLineSegment.aabb.maxX,
                maxY: closingLineSegment.aabb.maxY,
            },
            lineSegments: [closingLineSegment],
        };
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js



const MAX_U_ERROR = 1e-8;
class CubicSpline extends Spline_Spline {
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        const previewNumCurveSegments = this._getNumCurveSegments() + 1;
        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);
        const endCurveSegIndex = closeSpline
            ? previewNumCurveSegments
            : previewNumCurveSegments - 1;
        const transformMatrix = this.getTransformMatrix();
        const controlPoints = [...this.controlPoints];
        const curveSegments = [];
        if (!closeSpline) {
            controlPoints.push(controlPointPreview);
        }
        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);
            curveSegments.push(curveSegment);
        }
        return curveSegments;
    }
    getSplineCurves() {
        const numCurveSegments = this._getNumCurveSegments();
        const curveSegments = new Array(numCurveSegments);
        if (numCurveSegments <= 0) {
            return [];
        }
        const transformMatrix = this.getTransformMatrix();
        let previousCurveSegmentsLength = 0;
        for (let i = 0; i < numCurveSegments; i++) {
            const curveSegment = this._getCurveSegment(i, transformMatrix);
            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;
            curveSegments[i] = curveSegment;
            previousCurveSegmentsLength += curveSegment.length;
        }
        return curveSegments;
    }
    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {
        return closed
            ? controlPoints.length
            : Math.max(0, controlPoints.length - 1);
    }
    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const uInt = Math.floor(u);
        let curveSegmentIndex = uInt % numCurveSegments;
        const t = u - uInt;
        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;
        if (curveSegmentIndexOutOfBounds) {
            if (this.closed) {
                curveSegmentIndex =
                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;
            }
            else {
                return;
            }
        }
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const tt = t * t;
        const ttt = tt * t;
        const tValues = gl_matrix_esm/* vec4.fromValues */.ln.fromValues(1, t, tt, ttt);
        const qValues = gl_matrix_esm/* vec4.transformMat4 */.ln.transformMat4(gl_matrix_esm/* vec4.create */.ln.create(), tValues, transformMatrix);
        return [
            gl_matrix_esm/* vec4.dot */.ln.dot(qValues, gl_matrix_esm/* vec4.fromValues */.ln.fromValues(p0[0], p1[0], p2[0], p3[0])),
            gl_matrix_esm/* vec4.dot */.ln.dot(qValues, gl_matrix_esm/* vec4.fromValues */.ln.fromValues(p0[1], p1[1], p2[1], p3[1])),
        ];
    }
    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const p1Index = curveSegmentIndex;
        const p0Index = p1Index - 1;
        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;
        const p3Index = p2Index + 1;
        const p1 = controlPoints[p1Index];
        const p2 = controlPoints[p2Index];
        let p0;
        let p3;
        if (p0Index >= 0) {
            p0 = controlPoints[p0Index];
        }
        else {
            p0 = closed
                ? controlPoints[controlPoints.length - 1]
                : math.point.mirror(p2, p1);
        }
        if (p3Index < controlPoints.length) {
            p3 = controlPoints[p3Index];
        }
        else {
            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);
        }
        return { p0, p1, p2, p3 };
    }
    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {
        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);
        const numLineSegments = this.resolution + 1;
        const inc = 1 / numLineSegments;
        const minU = curveSegmentIndex;
        let maxU = minU + 1;
        if (!closed && curveSegmentIndex === numCurveSegments - 1) {
            maxU -= MAX_U_ERROR;
        }
        const lineSegments = [];
        let startPoint;
        let endPoint;
        let previousLineSegmentsLength = 0;
        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {
            u = u > maxU ? maxU : u;
            const point = this._getPoint(u, transformMatrix, controlPoints, closed);
            if (!i) {
                startPoint = point;
                continue;
            }
            endPoint = point;
            const dx = endPoint[0] - startPoint[0];
            const dy = endPoint[1] - startPoint[1];
            const length = Math.sqrt(dx ** 2 + dy ** 2);
            const aabb = {
                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],
                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],
                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],
                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],
            };
            lineSegments.push({
                points: {
                    start: startPoint,
                    end: endPoint,
                },
                aabb,
                length,
                previousLineSegmentsLength,
            });
            startPoint = endPoint;
            previousLineSegmentsLength += length;
        }
        return lineSegments;
    }
    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {
        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);
        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);
        let curveSegmentLength = 0;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {
            minX = Math.min(minX, lineSegAABB.minX);
            minY = Math.min(minY, lineSegAABB.minY);
            maxX = Math.max(maxX, lineSegAABB.maxX);
            maxY = Math.max(maxY, lineSegAABB.maxY);
            curveSegmentLength += lineSegLength;
        });
        return {
            controlPoints: { p0, p1, p2, p3 },
            aabb: { minX, minY, maxX, maxY },
            length: curveSegmentLength,
            previousCurveSegmentsLength: 0,
            lineSegments,
        };
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js


const TRANSFORM_MATRIX = gl_matrix_esm/* mat4.multiplyScalar */.pB.multiplyScalar(gl_matrix_esm/* mat4.create */.pB.create(), gl_matrix_esm/* mat4.fromValues */.pB.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);
class BSpline extends CubicSpline {
    getTransformMatrix() {
        return TRANSFORM_MATRIX;
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js

class CardinalSpline extends CubicSpline {
    constructor(props) {
        super(props);
        this._scale = props?.scale ?? 0.5;
        this._fixedScale = props?.fixedScale ?? false;
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        if (this._fixedScale || this._scale === scale) {
            return;
        }
        this._scale = scale;
        this.invalidated = true;
    }
    get fixedScale() {
        return this._fixedScale;
    }
    getTransformMatrix() {
        const { scale: s } = this;
        const s2 = 2 * s;
        return [
            0, 1, 0, 0,
            -s, 0, s, 0,
            s2, s - 3, 3 - s2, -s,
            -s, 2 - s, s - 2, s
        ];
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js

class CatmullRomSpline extends CardinalSpline {
    constructor() {
        super({ scale: 0.5, fixedScale: true });
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js

class LinearSpline extends CardinalSpline {
    constructor() {
        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js

class QuadraticSpline_QuadraticSpline extends (/* unused pure expression or super */ null && (Spline)) {
    getSplineCurves() {
        return [];
    }
    getLineSegments() {
        return [];
    }
    getPreviewCurveSegments(controlPointPreview, closeSpline) {
        return [];
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js

const QuadraticBezier_TRANSFORM_MATRIX = (/* unused pure expression or super */ null && ([
    1, 0, 0,
    -2, 2, 0,
    1, -2, 1,
]));
class QuadraticBezier extends (/* unused pure expression or super */ null && (QuadraticSpline)) {
    hasTangentPoints() {
        return true;
    }
    getTransformMatrix() {
        return QuadraticBezier_TRANSFORM_MATRIX;
    }
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/index.js










// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js
var base = __webpack_require__(85817);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js


class PanTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            limitToViewport: false,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    _checkImageInViewport(viewport, deltaPointsCanvas) {
        const { canvas } = viewport;
        const ratio = window.devicePixelRatio;
        const viewportLeft = 0;
        const viewportRight = canvas.width / ratio;
        const viewportTop = 0;
        const viewportBottom = canvas.height / ratio;
        const defaultActor = viewport.getDefaultActor();
        const renderer = viewport.getRenderer();
        let bounds;
        if (defaultActor && esm.utilities.isImageActor(defaultActor)) {
            const imageData = defaultActor.actor.getMapper().getInputData();
            bounds = imageData.getBounds();
        }
        else {
            bounds = renderer.computeVisiblePropBounds();
        }
        const [imageLeft, imageTop] = viewport.worldToCanvas([
            bounds[0],
            bounds[2],
            bounds[4],
        ]);
        const [imageRight, imageBottom] = viewport.worldToCanvas([
            bounds[1],
            bounds[3],
            bounds[5],
        ]);
        const zoom = viewport.getZoom();
        if (zoom <= 1) {
            if ((imageLeft + deltaPointsCanvas[0] < viewportLeft &&
                deltaPointsCanvas[0] < 0) ||
                (imageRight + deltaPointsCanvas[0] > viewportRight &&
                    deltaPointsCanvas[0] > 0) ||
                (imageTop + deltaPointsCanvas[1] < viewportTop &&
                    deltaPointsCanvas[1] < 0) ||
                (imageBottom + deltaPointsCanvas[1] > viewportBottom &&
                    deltaPointsCanvas[1] > 0)) {
                return false;
            }
        }
        else {
            if ((imageLeft + deltaPointsCanvas[0] > viewportLeft &&
                deltaPointsCanvas[0] > 0) ||
                (imageRight + deltaPointsCanvas[0] < viewportRight &&
                    deltaPointsCanvas[0] < 0) ||
                (imageTop + deltaPointsCanvas[1] > viewportTop &&
                    deltaPointsCanvas[1] > 0) ||
                (imageBottom + deltaPointsCanvas[1] < viewportBottom &&
                    deltaPointsCanvas[1] < 0)) {
                return false;
            }
        }
        return true;
    }
    _dragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        const deltaPointsCanvas = deltaPoints.canvas;
        if (deltaPointsWorld[0] === 0 &&
            deltaPointsWorld[1] === 0 &&
            deltaPointsWorld[2] === 0) {
            return;
        }
        const viewport = enabledElement.viewport;
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        if (this.configuration.limitToViewport &&
            !this._checkImageInViewport(viewport, deltaPointsCanvas)) {
            return;
        }
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
}
PanTool.toolName = 'Pan';
/* harmony default export */ const tools_PanTool = ((/* unused pure expression or super */ null && (PanTool)));

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math.js
var Core_Math = __webpack_require__(84607);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js






class TrackballRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            rotateIncrementDegrees: 2,
            rotateSampleDistanceFactor: 2,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this._hasResolutionChanged = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const actorEntry = viewport.getDefaultActor();
            const actor = actorEntry.actor;
            const mapper = actor.getMapper();
            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;
            if (!hasSampleDistance) {
                return true;
            }
            const originalSampleDistance = mapper.getSampleDistance();
            if (!this._hasResolutionChanged) {
                const { rotateSampleDistanceFactor } = this.configuration;
                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);
                this._hasResolutionChanged = true;
                if (this.cleanUp !== null) {
                    document.removeEventListener('mouseup', this.cleanUp);
                }
                this.cleanUp = () => {
                    mapper.setSampleDistance(originalSampleDistance);
                    viewport.render();
                    this._hasResolutionChanged = false;
                };
                document.addEventListener('mouseup', this.cleanUp, { once: true });
            }
            return true;
        };
        this._getViewportsInfo = () => {
            const viewports = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.onSetToolActive = () => {
            const subscribeToElementResize = () => {
                const viewportsInfo = this._getViewportsInfo();
                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                    if (!this._resizeObservers.has(viewportId)) {
                        const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId) || { viewport: null };
                        if (!viewport) {
                            return;
                        }
                        const { element } = viewport;
                        const resizeObserver = new ResizeObserver(() => {
                            const element = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                            if (!element) {
                                return;
                            }
                            const { viewport } = element;
                            const viewPresentation = viewport.getViewPresentation();
                            viewport.resetCamera();
                            viewport.setViewPresentation(viewPresentation);
                            viewport.render();
                        });
                        resizeObserver.observe(element);
                        this._resizeObservers.set(viewportId, resizeObserver);
                    }
                });
            };
            subscribeToElementResize();
            this._viewportAddedListener = (evt) => {
                if (evt.detail.toolGroupId === this.toolGroupId) {
                    subscribeToElementResize();
                }
            };
            esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
        };
        this.onSetToolDisabled = () => {
            this._resizeObservers.forEach((resizeObserver, viewportId) => {
                resizeObserver.disconnect();
                this._resizeObservers.delete(viewportId);
            });
            if (this._viewportAddedListener) {
                esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
                this._viewportAddedListener = null;
            }
        };
        this.rotateCamera = (viewport, centerWorld, axis, angle) => {
            const vtkCamera = viewport.getVtkActiveCamera();
            const viewUp = vtkCamera.getViewUp();
            const focalPoint = vtkCamera.getFocalPoint();
            const position = vtkCamera.getPosition();
            const newPosition = [0, 0, 0];
            const newFocalPoint = [0, 0, 0];
            const newViewUp = [0, 0, 0];
            const transform = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, centerWorld);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [
                -centerWorld[0],
                -centerWorld[1],
                -centerWorld[2],
            ]);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newPosition, position, transform);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newFocalPoint, focalPoint, transform);
            gl_matrix_esm/* mat4.identity */.pB.identity(transform);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newViewUp, viewUp, transform);
            viewport.setCamera({
                position: newPosition,
                viewUp: newViewUp,
                focalPoint: newFocalPoint,
            });
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, lastPoints } = evt.detail;
        const currentPointsCanvas = currentPoints.canvas;
        const lastPointsCanvas = lastPoints.canvas;
        const { rotateIncrementDegrees } = this.configuration;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const normalizedPosition = [
            currentPointsCanvas[0] / width,
            currentPointsCanvas[1] / height,
        ];
        const normalizedPreviousPosition = [
            lastPointsCanvas[0] / width,
            lastPointsCanvas[1] / height,
        ];
        const center = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(center);
        const normalizedCenter = [0.5, 0.5];
        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;
        const op = [normalizedPreviousPosition[0], 0, 0];
        const oe = [normalizedPosition[0], 0, 0];
        const opsq = op[0] ** 2;
        const oesq = oe[0] ** 2;
        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
        const nop = [op[0], 0, lop];
        Core_Math/* default.normalize */.Ay.normalize(nop);
        const noe = [oe[0], 0, loe];
        Core_Math/* default.normalize */.Ay.normalize(noe);
        const dot = Core_Math/* default.dot */.Ay.dot(nop, noe);
        if (Math.abs(dot) > 0.0001) {
            const angleX = -2 *
                Math.acos(Core_Math/* default.clampValue */.Ay.clampValue(dot, -1.0, 1.0)) *
                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *
                rotateIncrementDegrees;
            const upVec = camera.viewUp;
            const atV = camera.viewPlaneNormal;
            const rightV = [0, 0, 0];
            const forwardV = [0, 0, 0];
            Core_Math/* default.cross */.Ay.cross(upVec, atV, rightV);
            Core_Math/* default.normalize */.Ay.normalize(rightV);
            Core_Math/* default.cross */.Ay.cross(atV, rightV, forwardV);
            Core_Math/* default.normalize */.Ay.normalize(forwardV);
            Core_Math/* default.normalize */.Ay.normalize(upVec);
            this.rotateCamera(viewport, centerWorld, forwardV, angleX);
            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *
                rotateIncrementDegrees;
            this.rotateCamera(viewport, centerWorld, rightV, angleY);
            viewport.render();
        }
    }
}
TrackballRotateTool.toolName = 'TrackballRotate';
/* harmony default export */ const tools_TrackballRotateTool = ((/* unused pure expression or super */ null && (TrackballRotateTool)));

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var CellArray = __webpack_require__(35056);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Sources/SphereSource.js
var SphereSource = __webpack_require__(1060);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingTool.js













const PLANEINDEX = {
    XMIN: 0,
    XMAX: 1,
    YMIN: 2,
    YMAX: 3,
    ZMIN: 4,
    ZMAX: 5,
};
const SPHEREINDEX = {
    XMIN: 0,
    XMAX: 1,
    YMIN: 2,
    YMAX: 3,
    ZMIN: 4,
    ZMAX: 5,
    XMIN_YMIN_ZMIN: 6,
    XMIN_YMIN_ZMAX: 7,
    XMIN_YMAX_ZMIN: 8,
    XMIN_YMAX_ZMAX: 9,
    XMAX_YMIN_ZMIN: 10,
    XMAX_YMIN_ZMAX: 11,
    XMAX_YMAX_ZMIN: 12,
    XMAX_YMAX_ZMAX: 13,
};
class VolumeCroppingTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            showCornerSpheres: true,
            showHandles: true,
            showClippingPlanes: true,
            mobile: {
                enabled: false,
                opacity: 0.8,
            },
            initialCropFactor: 0.08,
            sphereColors: {
                SAGITTAL: [1.0, 1.0, 0.0],
                CORONAL: [0.0, 1.0, 0.0],
                AXIAL: [1.0, 0.0, 0.0],
                CORNERS: [0.0, 0.0, 1.0],
            },
            sphereRadius: 8,
            grabSpherePixelDistance: 20,
            rotateIncrementDegrees: 2,
            rotateSampleDistanceFactor: 2,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this._hasResolutionChanged = false;
        this.originalClippingPlanes = [];
        this.draggingSphereIndex = null;
        this.toolCenter = [0, 0, 0];
        this.cornerDragOffset = null;
        this.faceDragOffset = null;
        this.sphereStates = [];
        this.edgeLines = {};
        this.onSetToolConfiguration = () => {
            console.debug('Setting tool settoolconfiguration : volumeCropping');
        };
        this.onSetToolEnabled = () => {
            console.debug('Setting tool enabled: volumeCropping');
        };
        this.onCameraModified = (evt) => {
            const { element } = evt.currentTarget
                ? { element: evt.currentTarget }
                : evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            this._updateClippingPlanes(enabledElement.viewport);
            enabledElement.viewport.render();
        };
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const actorEntry = viewport.getDefaultActor();
            const actor = actorEntry.actor;
            const mapper = actor.getMapper();
            const mouseCanvas = [
                evt.detail.currentPoints.canvas[0],
                evt.detail.currentPoints.canvas[1],
            ];
            this.draggingSphereIndex = null;
            this.cornerDragOffset = null;
            this.faceDragOffset = null;
            for (let i = 0; i < this.sphereStates.length; ++i) {
                const sphereCanvas = viewport.worldToCanvas(this.sphereStates[i].point);
                const dist = Math.sqrt(Math.pow(mouseCanvas[0] - sphereCanvas[0], 2) +
                    Math.pow(mouseCanvas[1] - sphereCanvas[1], 2));
                if (dist < this.configuration.grabSpherePixelDistance) {
                    this.draggingSphereIndex = i;
                    element.style.cursor = 'grabbing';
                    const sphereState = this.sphereStates[i];
                    const mouseWorld = viewport.canvasToWorld(mouseCanvas);
                    if (sphereState.isCorner) {
                        this.cornerDragOffset = [
                            sphereState.point[0] - mouseWorld[0],
                            sphereState.point[1] - mouseWorld[1],
                            sphereState.point[2] - mouseWorld[2],
                        ];
                        this.faceDragOffset = null;
                    }
                    else {
                        const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];
                        this.faceDragOffset =
                            sphereState.point[axisIdx] - mouseWorld[axisIdx];
                        this.cornerDragOffset = null;
                    }
                    return true;
                }
            }
            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;
            if (!hasSampleDistance) {
                return true;
            }
            const originalSampleDistance = mapper.getSampleDistance();
            if (!this._hasResolutionChanged) {
                const { rotateSampleDistanceFactor } = this.configuration;
                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);
                this._hasResolutionChanged = true;
                if (this.cleanUp !== null) {
                    document.removeEventListener('mouseup', this.cleanUp);
                }
                this.cleanUp = () => {
                    mapper.setSampleDistance(originalSampleDistance);
                    evt.target.style.cursor = '';
                    if (this.draggingSphereIndex !== null) {
                        const sphereState = this.sphereStates[this.draggingSphereIndex];
                        const [viewport3D] = this._getViewportsInfo();
                        const renderingEngine = (0,esm.getRenderingEngine)(viewport3D.renderingEngineId);
                        const viewport = renderingEngine.getViewport(viewport3D.viewportId);
                        if (sphereState.isCorner) {
                            this._updateCornerSpheres();
                            this._updateFaceSpheresFromCorners();
                            this._updateClippingPlanesFromFaceSpheres(viewport);
                        }
                    }
                    this.draggingSphereIndex = null;
                    this.cornerDragOffset = null;
                    this.faceDragOffset = null;
                    viewport.render();
                    this._hasResolutionChanged = false;
                };
                document.addEventListener('mouseup', this.cleanUp, { once: true });
            }
            return true;
        };
        this._onMouseMoveSphere = (evt) => {
            if (this.draggingSphereIndex === null) {
                return false;
            }
            const sphereState = this.sphereStates[this.draggingSphereIndex];
            if (!sphereState) {
                return false;
            }
            const { viewport, world } = this._getViewportAndWorldCoords(evt);
            if (!viewport || !world) {
                return false;
            }
            if (sphereState.isCorner) {
                const newCorner = this._calculateNewCornerPosition(world);
                this._updateSpherePosition(sphereState, newCorner);
                const axisFlags = this._parseCornerKey(sphereState.uid);
                this._updateRelatedCorners(sphereState, newCorner, axisFlags);
                this._updateFaceSpheresFromCorners();
                this._updateCornerSpheres();
            }
            else {
                const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];
                let newValue = world[axisIdx];
                if (this.faceDragOffset !== null) {
                    newValue += this.faceDragOffset;
                }
                sphereState.point[axisIdx] = newValue;
                sphereState.sphereSource.setCenter(...sphereState.point);
                sphereState.sphereSource.modified();
                this._updateCornerSpheresFromFaces();
                this._updateFaceSpheresFromCorners();
                this._updateCornerSpheres();
            }
            this._updateClippingPlanesFromFaceSpheres(viewport);
            viewport.render();
            this._triggerToolChangedEvent(sphereState);
            return true;
        };
        this._onControlToolChange = (evt) => {
            const viewport = this._getViewport();
            if (!evt.detail.toolCenter) {
                (0,esm.triggerEvent)(esm.eventTarget, enums.Events.VOLUMECROPPING_TOOL_CHANGED, {
                    originalClippingPlanes: this.originalClippingPlanes,
                    viewportId: viewport.id,
                    renderingEngineId: viewport.renderingEngineId,
                    seriesInstanceUID: this.seriesInstanceUID,
                });
            }
            else {
                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {
                    return;
                }
                const isMin = evt.detail.handleType === 'min';
                const toolCenter = isMin
                    ? evt.detail.toolCenterMin
                    : evt.detail.toolCenterMax;
                const normals = isMin
                    ? [
                        [1, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1],
                    ]
                    : [
                        [-1, 0, 0],
                        [0, -1, 0],
                        [0, 0, -1],
                    ];
                const planeIndices = isMin
                    ? [PLANEINDEX.XMIN, PLANEINDEX.YMIN, PLANEINDEX.ZMIN]
                    : [PLANEINDEX.XMAX, PLANEINDEX.YMAX, PLANEINDEX.ZMAX];
                const sphereIndices = isMin
                    ? [SPHEREINDEX.XMIN, SPHEREINDEX.YMIN, SPHEREINDEX.ZMIN]
                    : [SPHEREINDEX.XMAX, SPHEREINDEX.YMAX, SPHEREINDEX.ZMAX];
                const axes = ['x', 'y', 'z'];
                const orientationAxes = [
                    esm.Enums.OrientationAxis.SAGITTAL,
                    esm.Enums.OrientationAxis.CORONAL,
                    esm.Enums.OrientationAxis.AXIAL,
                ];
                for (let i = 0; i < 3; ++i) {
                    const origin = [0, 0, 0];
                    origin[i] = toolCenter[i];
                    const plane = Plane/* default.newInstance */.Ay.newInstance({
                        origin,
                        normal: normals[i],
                    });
                    this.originalClippingPlanes[planeIndices[i]].origin = plane.getOrigin();
                    this.sphereStates[sphereIndices[i]].point[i] = plane.getOrigin()[i];
                    this.sphereStates[sphereIndices[i]].sphereSource.setCenter(...this.sphereStates[sphereIndices[i]].point);
                    this.sphereStates[sphereIndices[i]].sphereSource.modified();
                    const otherSphere = this.sphereStates.find((s, idx) => s.axis === axes[i] && idx !== sphereIndices[i]);
                    const newCenter = (otherSphere.point[i] + plane.getOrigin()[i]) / 2;
                    this.sphereStates.forEach((state) => {
                        if (!state.isCorner &&
                            state.axis !== axes[i] &&
                            !evt.detail.viewportOrientation.includes(orientationAxes[i])) {
                            state.point[i] = newCenter;
                            state.sphereSource.setCenter(state.point);
                            state.sphereActor.getProperty().setColor(state.color);
                            state.sphereSource.modified();
                        }
                    });
                    const volumeActor = viewport.getDefaultActor()?.actor;
                    if (volumeActor) {
                        const mapper = volumeActor.getMapper();
                        const clippingPlanes = mapper.getClippingPlanes();
                        if (clippingPlanes) {
                            clippingPlanes[planeIndices[i]].setOrigin(plane.getOrigin());
                        }
                    }
                }
                this._updateCornerSpheres();
                viewport.render();
            }
        };
        this._getViewportsInfo = () => {
            const viewports = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this._initialize3DViewports = (viewportsInfo) => {
            if (!viewportsInfo || !viewportsInfo.length || !viewportsInfo[0]) {
                console.warn('VolumeCroppingTool: No viewportsInfo available for initialization of volumecroppingtool.');
                return;
            }
            const viewport = this._getViewport();
            const volumeActors = viewport.getActors();
            if (!volumeActors || volumeActors.length === 0) {
                console.warn('VolumeCroppingTool: No volume actors found in the viewport.');
                return;
            }
            const imageData = volumeActors[0].actor.getMapper().getInputData();
            if (!imageData) {
                console.warn('VolumeCroppingTool: No image data found for volume actor.');
                return;
            }
            this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';
            const worldBounds = imageData.getBounds();
            const cropFactor = this.configuration.initialCropFactor || 0.1;
            const xRange = worldBounds[1] - worldBounds[0];
            const yRange = worldBounds[3] - worldBounds[2];
            const zRange = worldBounds[5] - worldBounds[4];
            const xMin = worldBounds[0] + cropFactor * xRange;
            const xMax = worldBounds[1] - cropFactor * xRange;
            const yMin = worldBounds[2] + cropFactor * yRange;
            const yMax = worldBounds[3] - cropFactor * yRange;
            const zMin = worldBounds[4] + cropFactor * zRange;
            const zMax = worldBounds[5] - cropFactor * zRange;
            const planes = [];
            const planeXmin = Plane/* default.newInstance */.Ay.newInstance({
                origin: [xMin, 0, 0],
                normal: [1, 0, 0],
            });
            const planeXmax = Plane/* default.newInstance */.Ay.newInstance({
                origin: [xMax, 0, 0],
                normal: [-1, 0, 0],
            });
            const planeYmin = Plane/* default.newInstance */.Ay.newInstance({
                origin: [0, yMin, 0],
                normal: [0, 1, 0],
            });
            const planeYmax = Plane/* default.newInstance */.Ay.newInstance({
                origin: [0, yMax, 0],
                normal: [0, -1, 0],
            });
            const planeZmin = Plane/* default.newInstance */.Ay.newInstance({
                origin: [0, 0, zMin],
                normal: [0, 0, 1],
            });
            const planeZmax = Plane/* default.newInstance */.Ay.newInstance({
                origin: [0, 0, zMax],
                normal: [0, 0, -1],
            });
            const mapper = viewport
                .getDefaultActor()
                .actor.getMapper();
            planes.push(planeXmin);
            planes.push(planeXmax);
            planes.push(planeYmin);
            planes.push(planeYmax);
            planes.push(planeZmin);
            planes.push(planeZmax);
            const originalPlanes = planes.map((plane) => ({
                origin: [...plane.getOrigin()],
                normal: [...plane.getNormal()],
            }));
            this.originalClippingPlanes = originalPlanes;
            const sphereXminPoint = [xMin, (yMax + yMin) / 2, (zMax + zMin) / 2];
            const sphereXmaxPoint = [xMax, (yMax + yMin) / 2, (zMax + zMin) / 2];
            const sphereYminPoint = [(xMax + xMin) / 2, yMin, (zMax + zMin) / 2];
            const sphereYmaxPoint = [(xMax + xMin) / 2, yMax, (zMax + zMin) / 2];
            const sphereZminPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMin];
            const sphereZmaxPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMax];
            const adaptiveRadius = this._calculateAdaptiveSphereRadius(Math.sqrt(xRange * xRange + yRange * yRange + zRange * zRange));
            this._addSphere(viewport, sphereXminPoint, 'x', 'min', null, adaptiveRadius);
            this._addSphere(viewport, sphereXmaxPoint, 'x', 'max', null, adaptiveRadius);
            this._addSphere(viewport, sphereYminPoint, 'y', 'min', null, adaptiveRadius);
            this._addSphere(viewport, sphereYmaxPoint, 'y', 'max', null, adaptiveRadius);
            this._addSphere(viewport, sphereZminPoint, 'z', 'min', null, adaptiveRadius);
            this._addSphere(viewport, sphereZmaxPoint, 'z', 'max', null, adaptiveRadius);
            const corners = [
                [xMin, yMin, zMin],
                [xMin, yMin, zMax],
                [xMin, yMax, zMin],
                [xMin, yMax, zMax],
                [xMax, yMin, zMin],
                [xMax, yMin, zMax],
                [xMax, yMax, zMin],
                [xMax, yMax, zMax],
            ];
            const cornerKeys = [
                'XMIN_YMIN_ZMIN',
                'XMIN_YMIN_ZMAX',
                'XMIN_YMAX_ZMIN',
                'XMIN_YMAX_ZMAX',
                'XMAX_YMIN_ZMIN',
                'XMAX_YMIN_ZMAX',
                'XMAX_YMAX_ZMIN',
                'XMAX_YMAX_ZMAX',
            ];
            for (let i = 0; i < corners.length; i++) {
                this._addSphere(viewport, corners[i], 'corner', null, cornerKeys[i], adaptiveRadius);
            }
            const edgeCornerPairs = [
                ['XMIN_YMIN_ZMIN', 'XMAX_YMIN_ZMIN'],
                ['XMIN_YMIN_ZMAX', 'XMAX_YMIN_ZMAX'],
                ['XMIN_YMAX_ZMIN', 'XMAX_YMAX_ZMIN'],
                ['XMIN_YMAX_ZMAX', 'XMAX_YMAX_ZMAX'],
                ['XMIN_YMIN_ZMIN', 'XMIN_YMAX_ZMIN'],
                ['XMIN_YMIN_ZMAX', 'XMIN_YMAX_ZMAX'],
                ['XMAX_YMIN_ZMIN', 'XMAX_YMAX_ZMIN'],
                ['XMAX_YMIN_ZMAX', 'XMAX_YMAX_ZMAX'],
                ['XMIN_YMIN_ZMIN', 'XMIN_YMIN_ZMAX'],
                ['XMIN_YMAX_ZMIN', 'XMIN_YMAX_ZMAX'],
                ['XMAX_YMIN_ZMIN', 'XMAX_YMIN_ZMAX'],
                ['XMAX_YMAX_ZMIN', 'XMAX_YMAX_ZMAX'],
            ];
            edgeCornerPairs.forEach(([key1, key2], i) => {
                const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);
                const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);
                if (state1 && state2) {
                    const uid = `edge_${key1}_${key2}`;
                    const { actor, source } = this._addLine3DBetweenPoints(viewport, state1.point, state2.point, [0.7, 0.7, 0.7], uid);
                    this.edgeLines[uid] = { actor, source, key1, key2 };
                }
            });
            mapper.addClippingPlane(planeXmin);
            mapper.addClippingPlane(planeXmax);
            mapper.addClippingPlane(planeYmin);
            mapper.addClippingPlane(planeYmax);
            mapper.addClippingPlane(planeZmin);
            mapper.addClippingPlane(planeZmax);
            esm.eventTarget.addEventListener(enums.Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, (evt) => {
                this._onControlToolChange(evt);
            });
            viewport.render();
        };
        this._getViewportAndWorldCoords = (evt) => {
            const viewport = this._getViewport();
            const x = evt.detail.currentPoints.canvas[0];
            const y = evt.detail.currentPoints.canvas[1];
            const world = viewport.canvasToWorld([x, y]);
            return { viewport, world };
        };
        this._getViewport = () => {
            const [viewport3D] = this._getViewportsInfo();
            const renderingEngine = (0,esm.getRenderingEngine)(viewport3D.renderingEngineId);
            return renderingEngine.getViewport(viewport3D.viewportId);
        };
        this._handleCornerSphereMovement = (sphereState, world, viewport) => {
            const newCorner = this._calculateNewCornerPosition(world);
            this._updateSpherePosition(sphereState, newCorner);
            const axisFlags = this._parseCornerKey(sphereState.uid);
            this._updateRelatedCorners(sphereState, newCorner, axisFlags);
            this._updateAfterCornerMovement(viewport);
        };
        this._handleFaceSphereMovement = (sphereState, world, viewport) => {
            const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];
            let newValue = world[axisIdx];
            if (this.faceDragOffset !== null) {
                newValue += this.faceDragOffset;
            }
            sphereState.point[axisIdx] = newValue;
            sphereState.sphereSource.setCenter(...sphereState.point);
            sphereState.sphereSource.modified();
            this._updateAfterFaceMovement(viewport);
        };
        this._calculateNewCornerPosition = (world) => {
            let newCorner = [world[0], world[1], world[2]];
            if (this.cornerDragOffset) {
                newCorner = [
                    world[0] + this.cornerDragOffset[0],
                    world[1] + this.cornerDragOffset[1],
                    world[2] + this.cornerDragOffset[2],
                ];
            }
            return newCorner;
        };
        this._parseCornerKey = (uid) => {
            const cornerKey = uid.replace('corner_', '');
            return {
                isXMin: cornerKey.includes('XMIN'),
                isXMax: cornerKey.includes('XMAX'),
                isYMin: cornerKey.includes('YMIN'),
                isYMax: cornerKey.includes('YMAX'),
                isZMin: cornerKey.includes('ZMIN'),
                isZMax: cornerKey.includes('ZMAX'),
            };
        };
        this._updateSpherePosition = (sphereState, newPosition) => {
            sphereState.point = newPosition;
            sphereState.sphereSource.setCenter(...newPosition);
            sphereState.sphereSource.modified();
        };
        this._updateRelatedCorners = (draggedSphere, newCorner, axisFlags) => {
            this.sphereStates.forEach((state) => {
                if (!state.isCorner || state === draggedSphere) {
                    return;
                }
                const key = state.uid.replace('corner_', '');
                const shouldUpdate = this._shouldUpdateCorner(key, axisFlags);
                if (shouldUpdate) {
                    this._updateCornerCoordinates(state, newCorner, key, axisFlags);
                }
            });
        };
        this._shouldUpdateCorner = (cornerKey, axisFlags) => {
            return ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||
                (axisFlags.isXMax && cornerKey.includes('XMAX')) ||
                (axisFlags.isYMin && cornerKey.includes('YMIN')) ||
                (axisFlags.isYMax && cornerKey.includes('YMAX')) ||
                (axisFlags.isZMin && cornerKey.includes('ZMIN')) ||
                (axisFlags.isZMax && cornerKey.includes('ZMAX')));
        };
        this._updateCornerCoordinates = (state, newCorner, cornerKey, axisFlags) => {
            if ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||
                (axisFlags.isXMax && cornerKey.includes('XMAX'))) {
                state.point[0] = newCorner[0];
            }
            if ((axisFlags.isYMin && cornerKey.includes('YMIN')) ||
                (axisFlags.isYMax && cornerKey.includes('YMAX'))) {
                state.point[1] = newCorner[1];
            }
            if ((axisFlags.isZMin && cornerKey.includes('ZMIN')) ||
                (axisFlags.isZMax && cornerKey.includes('ZMAX'))) {
                state.point[2] = newCorner[2];
            }
            state.sphereSource.setCenter(...state.point);
            state.sphereSource.modified();
        };
        this._updateAfterCornerMovement = (viewport) => {
            this._updateFaceSpheresFromCorners();
            this._updateCornerSpheres();
            this._updateClippingPlanesFromFaceSpheres(viewport);
        };
        this._updateAfterFaceMovement = (viewport) => {
            this._updateCornerSpheresFromFaces();
            this._updateClippingPlanesFromFaceSpheres(viewport);
        };
        this._triggerToolChangedEvent = (sphereState) => {
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.VOLUMECROPPING_TOOL_CHANGED, {
                toolCenter: sphereState.point,
                axis: sphereState.isCorner ? 'corner' : sphereState.axis,
                draggingSphereIndex: this.draggingSphereIndex,
                seriesInstanceUID: this.seriesInstanceUID,
            });
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            this.originalClippingPlanes = [];
            this.sphereStates = [];
            this.edgeLines = {};
            this._initialize3DViewports(viewportsInfo);
        };
        this._rotateCamera = (viewport, centerWorld, axis, angle) => {
            const vtkCamera = viewport.getVtkActiveCamera();
            const viewUp = vtkCamera.getViewUp();
            const focalPoint = vtkCamera.getFocalPoint();
            const position = vtkCamera.getPosition();
            const newPosition = [0, 0, 0];
            const newFocalPoint = [0, 0, 0];
            const newViewUp = [0, 0, 0];
            const transform = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, centerWorld);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [
                -centerWorld[0],
                -centerWorld[1],
                -centerWorld[2],
            ]);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newPosition, position, transform);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newFocalPoint, focalPoint, transform);
            gl_matrix_esm/* mat4.identity */.pB.identity(transform);
            gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, axis);
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newViewUp, viewUp, transform);
            viewport.setCamera({
                position: newPosition,
                viewUp: newViewUp,
                focalPoint: newFocalPoint,
            });
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    onSetToolActive() {
        if (this.sphereStates && this.sphereStates.length > 0) {
            if (this.configuration.showHandles) {
                this.setHandlesVisible(false);
                this.setClippingPlanesVisible(false);
            }
            else {
                this.setHandlesVisible(true);
                this.setClippingPlanesVisible(true);
            }
        }
        else {
            const viewportsInfo = this._getViewportsInfo();
            const subscribeToElementResize = () => {
                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                    if (!this._resizeObservers.has(viewportId)) {
                        const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId) || { viewport: null };
                        if (!viewport) {
                            return;
                        }
                        const { element } = viewport;
                        const resizeObserver = new ResizeObserver(() => {
                            const element = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                            if (!element) {
                                return;
                            }
                            const { viewport } = element;
                            const viewPresentation = viewport.getViewPresentation();
                            viewport.resetCamera();
                            viewport.setViewPresentation(viewPresentation);
                            viewport.render();
                        });
                        resizeObserver.observe(element);
                        this._resizeObservers.set(viewportId, resizeObserver);
                    }
                });
            };
            subscribeToElementResize();
            this._viewportAddedListener = (evt) => {
                if (evt.detail.toolGroupId === this.toolGroupId) {
                    subscribeToElementResize();
                }
            };
            esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
            this._subscribeToViewportNewVolumeSet(viewportsInfo);
            this._initialize3DViewports(viewportsInfo);
            if (this.sphereStates && this.sphereStates.length > 0) {
                this.setHandlesVisible(true);
            }
            else {
                this.originalClippingPlanes = [];
                this._initialize3DViewports(viewportsInfo);
            }
        }
    }
    onSetToolDisabled() {
        this._resizeObservers.forEach((resizeObserver, viewportId) => {
            resizeObserver.disconnect();
            this._resizeObservers.delete(viewportId);
        });
        if (this._viewportAddedListener) {
            esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);
            this._viewportAddedListener = null;
        }
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
    }
    setHandlesVisible(visible) {
        this.configuration.showHandles = visible;
        if (visible) {
            this.sphereStates[SPHEREINDEX.XMIN].point[0] =
                this.originalClippingPlanes[PLANEINDEX.XMIN].origin[0];
            this.sphereStates[SPHEREINDEX.XMAX].point[0] =
                this.originalClippingPlanes[PLANEINDEX.XMAX].origin[0];
            this.sphereStates[SPHEREINDEX.YMIN].point[1] =
                this.originalClippingPlanes[PLANEINDEX.YMIN].origin[1];
            this.sphereStates[SPHEREINDEX.YMAX].point[1] =
                this.originalClippingPlanes[PLANEINDEX.YMAX].origin[1];
            this.sphereStates[SPHEREINDEX.ZMIN].point[2] =
                this.originalClippingPlanes[PLANEINDEX.ZMIN].origin[2];
            this.sphereStates[SPHEREINDEX.ZMAX].point[2] =
                this.originalClippingPlanes[PLANEINDEX.ZMAX].origin[2];
            [
                SPHEREINDEX.XMIN,
                SPHEREINDEX.XMAX,
                SPHEREINDEX.YMIN,
                SPHEREINDEX.YMAX,
                SPHEREINDEX.ZMIN,
                SPHEREINDEX.ZMAX,
            ].forEach((idx) => {
                const s = this.sphereStates[idx];
                s.sphereSource.setCenter(...s.point);
                s.sphereSource.modified();
            });
            this._updateCornerSpheres();
        }
        this._updateHandlesVisibility();
        const viewportsInfo = this._getViewportsInfo();
        const [viewport3D] = viewportsInfo;
        const renderingEngine = (0,esm.getRenderingEngine)(viewport3D.renderingEngineId);
        const viewport = renderingEngine.getViewport(viewport3D.viewportId);
        viewport.render();
    }
    getHandlesVisible() {
        return this.configuration.showHandles;
    }
    getClippingPlanesVisible() {
        return this.configuration.showClippingPlanes;
    }
    setClippingPlanesVisible(visible) {
        this.configuration.showClippingPlanes = visible;
        const viewport = this._getViewport();
        this._updateClippingPlanes(viewport);
        viewport.render();
    }
    _dragCallback(evt) {
        const { element, currentPoints, lastPoints } = evt.detail;
        if (this.draggingSphereIndex !== null) {
            this._onMouseMoveSphere(evt);
        }
        else {
            const currentPointsCanvas = currentPoints.canvas;
            const lastPointsCanvas = lastPoints.canvas;
            const { rotateIncrementDegrees } = this.configuration;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const width = element.clientWidth;
            const height = element.clientHeight;
            const normalizedPosition = [
                currentPointsCanvas[0] / width,
                currentPointsCanvas[1] / height,
            ];
            const normalizedPreviousPosition = [
                lastPointsCanvas[0] / width,
                lastPointsCanvas[1] / height,
            ];
            const center = [width * 0.5, height * 0.5];
            const centerWorld = viewport.canvasToWorld(center);
            const normalizedCenter = [0.5, 0.5];
            const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;
            const op = [normalizedPreviousPosition[0], 0, 0];
            const oe = [normalizedPosition[0], 0, 0];
            const opsq = op[0] ** 2;
            const oesq = oe[0] ** 2;
            const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);
            const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);
            const nop = [op[0], 0, lop];
            Core_Math/* default.normalize */.Ay.normalize(nop);
            const noe = [oe[0], 0, loe];
            Core_Math/* default.normalize */.Ay.normalize(noe);
            const dot = Core_Math/* default.dot */.Ay.dot(nop, noe);
            if (Math.abs(dot) > 0.0001) {
                const angleX = -2 *
                    Math.acos(Core_Math/* default.clampValue */.Ay.clampValue(dot, -1.0, 1.0)) *
                    Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *
                    rotateIncrementDegrees;
                const upVec = camera.viewUp;
                const atV = camera.viewPlaneNormal;
                const rightV = [0, 0, 0];
                const forwardV = [0, 0, 0];
                Core_Math/* default.cross */.Ay.cross(upVec, atV, rightV);
                Core_Math/* default.normalize */.Ay.normalize(rightV);
                Core_Math/* default.cross */.Ay.cross(atV, rightV, forwardV);
                Core_Math/* default.normalize */.Ay.normalize(forwardV);
                Core_Math/* default.normalize */.Ay.normalize(upVec);
                this._rotateCamera(viewport, centerWorld, forwardV, angleX);
                const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *
                    rotateIncrementDegrees;
                this._rotateCamera(viewport, centerWorld, rightV, angleY);
            }
            viewport.render();
        }
    }
    _updateClippingPlanes(viewport) {
        const actorEntry = viewport.getDefaultActor();
        if (!actorEntry || !actorEntry.actor) {
            if (!viewport._missingActorWarned) {
                console.warn('VolumeCroppingTool._updateClippingPlanes: No default actor found in viewport.');
                viewport._missingActorWarned = true;
            }
            return;
        }
        const actor = actorEntry.actor;
        const mapper = actor.getMapper();
        const matrix = actor.getMatrix();
        if (!this.configuration.showClippingPlanes) {
            mapper.removeAllClippingPlanes();
            return;
        }
        const rot = gl_matrix_esm/* mat3.create */.w0.create();
        gl_matrix_esm/* mat3.fromMat4 */.w0.fromMat4(rot, matrix);
        const normalMatrix = gl_matrix_esm/* mat3.create */.w0.create();
        gl_matrix_esm/* mat3.invert */.w0.invert(normalMatrix, rot);
        gl_matrix_esm/* mat3.transpose */.w0.transpose(normalMatrix, normalMatrix);
        const originalPlanes = this.originalClippingPlanes;
        if (!originalPlanes || !originalPlanes.length) {
            return;
        }
        mapper.removeAllClippingPlanes();
        const transformedOrigins = [];
        const transformedNormals = [];
        for (let i = 0; i < originalPlanes.length; ++i) {
            const plane = originalPlanes[i];
            const oVec = gl_matrix_esm/* vec3.create */.eR.create();
            gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(oVec, new Float32Array(plane.origin), matrix);
            const o = [oVec[0], oVec[1], oVec[2]];
            const nVec = gl_matrix_esm/* vec3.create */.eR.create();
            gl_matrix_esm/* vec3.transformMat3 */.eR.transformMat3(nVec, new Float32Array(plane.normal), normalMatrix);
            gl_matrix_esm/* vec3.normalize */.eR.normalize(nVec, nVec);
            const n = [nVec[0], nVec[1], nVec[2]];
            transformedOrigins.push(o);
            transformedNormals.push(n);
        }
        for (let i = 0; i < transformedOrigins.length; ++i) {
            const planeInstance = Plane/* default.newInstance */.Ay.newInstance({
                origin: transformedOrigins[i],
                normal: transformedNormals[i],
            });
            mapper.addClippingPlane(planeInstance);
        }
    }
    _updateHandlesVisibility() {
        this.sphereStates.forEach((state) => {
            if (state.sphereActor) {
                state.sphereActor.setVisibility(this.configuration.showHandles);
            }
        });
        Object.values(this.edgeLines).forEach(({ actor }) => {
            if (actor) {
                actor.setVisibility(this.configuration.showHandles);
            }
        });
    }
    _addLine3DBetweenPoints(viewport, point1, point2, color = [0.7, 0.7, 0.7], uid = '') {
        if (point1[0] === point2[0] &&
            point1[1] === point2[1] &&
            point1[2] === point2[2]) {
            return { actor: null, source: null };
        }
        const points = Points/* default.newInstance */.Ay.newInstance();
        points.setNumberOfPoints(2);
        points.setPoint(0, point1[0], point1[1], point1[2]);
        points.setPoint(1, point2[0], point2[1], point2[2]);
        const lines = CellArray/* default.newInstance */.Ay.newInstance({ values: [2, 0, 1] });
        const polyData = PolyData/* default.newInstance */.Ay.newInstance();
        polyData.setPoints(points);
        polyData.setLines(lines);
        const mapper = Mapper/* default.newInstance */.Ay.newInstance();
        mapper.setInputData(polyData);
        const actor = Actor/* default.newInstance */.Ay.newInstance();
        actor.setMapper(mapper);
        actor.getProperty().setColor(...color);
        actor.getProperty().setLineWidth(0.5);
        actor.getProperty().setOpacity(1.0);
        actor.getProperty().setInterpolationToFlat();
        actor.getProperty().setAmbient(1.0);
        actor.getProperty().setDiffuse(0.0);
        actor.getProperty().setSpecular(0.0);
        actor.setVisibility(this.configuration.showHandles);
        viewport.addActor({ actor, uid });
        return { actor, source: polyData };
    }
    _addSphere(viewport, point, axis, position, cornerKey = null, adaptiveRadius) {
        const uid = cornerKey ? `corner_${cornerKey}` : `${axis}_${position}`;
        const sphereState = this.sphereStates.find((s) => s.uid === uid);
        if (sphereState) {
            return;
        }
        const sphereSource = SphereSource/* default.newInstance */.Ay.newInstance();
        sphereSource.setCenter(point);
        sphereSource.setRadius(adaptiveRadius);
        const sphereMapper = Mapper/* default.newInstance */.Ay.newInstance();
        sphereMapper.setInputConnection(sphereSource.getOutputPort());
        const sphereActor = Actor/* default.newInstance */.Ay.newInstance();
        sphereActor.setMapper(sphereMapper);
        let color = [0.0, 1.0, 0.0];
        const sphereColors = this.configuration.sphereColors || {};
        if (cornerKey) {
            color = sphereColors.CORNERS || [0.0, 0.0, 1.0];
        }
        else if (axis === 'z') {
            color = sphereColors.AXIAL || [1.0, 0.0, 0.0];
        }
        else if (axis === 'x') {
            color = sphereColors.SAGITTAL || [1.0, 1.0, 0.0];
        }
        else if (axis === 'y') {
            color = sphereColors.CORONAL || [0.0, 1.0, 0.0];
        }
        const idx = this.sphereStates.findIndex((s) => s.uid === uid);
        if (idx === -1) {
            this.sphereStates.push({
                point: point.slice(),
                axis,
                uid,
                sphereSource,
                sphereActor,
                isCorner: !!cornerKey,
                color,
            });
        }
        else {
            this.sphereStates[idx].point = point.slice();
            this.sphereStates[idx].sphereSource = sphereSource;
        }
        const existingActors = viewport.getActors();
        const existing = existingActors.find((a) => a.uid === uid);
        if (existing) {
            return;
        }
        sphereActor.getProperty().setColor(color);
        sphereActor.setVisibility(this.configuration.showHandles);
        viewport.addActor({ actor: sphereActor, uid: uid });
    }
    _calculateAdaptiveSphereRadius(diagonal) {
        const baseRadius = this.configuration.sphereRadius !== undefined
            ? this.configuration.sphereRadius
            : 8;
        const scaleFactor = this.configuration.sphereRadiusScale || 0.01;
        const adaptiveRadius = diagonal * scaleFactor;
        const minRadius = this.configuration.minSphereRadius || 2;
        const maxRadius = this.configuration.maxSphereRadius || 50;
        return Math.max(minRadius, Math.min(maxRadius, adaptiveRadius));
    }
    _updateClippingPlanesFromFaceSpheres(viewport) {
        const mapper = viewport.getDefaultActor().actor.getMapper();
        this.originalClippingPlanes[0].origin = [
            ...this.sphereStates[SPHEREINDEX.XMIN].point,
        ];
        this.originalClippingPlanes[1].origin = [
            ...this.sphereStates[SPHEREINDEX.XMAX].point,
        ];
        this.originalClippingPlanes[2].origin = [
            ...this.sphereStates[SPHEREINDEX.YMIN].point,
        ];
        this.originalClippingPlanes[3].origin = [
            ...this.sphereStates[SPHEREINDEX.YMAX].point,
        ];
        this.originalClippingPlanes[4].origin = [
            ...this.sphereStates[SPHEREINDEX.ZMIN].point,
        ];
        this.originalClippingPlanes[5].origin = [
            ...this.sphereStates[SPHEREINDEX.ZMAX].point,
        ];
        mapper.removeAllClippingPlanes();
        for (let i = 0; i < 6; ++i) {
            const origin = this.originalClippingPlanes[i].origin;
            const normal = this.originalClippingPlanes[i].normal;
            const plane = Plane/* default.newInstance */.Ay.newInstance({
                origin,
                normal,
            });
            mapper.addClippingPlane(plane);
        }
    }
    _updateCornerSpheresFromFaces() {
        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];
        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];
        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];
        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];
        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];
        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];
        const corners = [
            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },
            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },
            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },
            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },
            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },
            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },
            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },
            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },
        ];
        for (const corner of corners) {
            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);
            if (state) {
                state.point[0] = corner.pos[0];
                state.point[1] = corner.pos[1];
                state.point[2] = corner.pos[2];
                state.sphereSource.setCenter(...state.point);
                state.sphereSource.modified();
            }
        }
    }
    _updateFaceSpheresFromCorners() {
        const corners = [
            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMIN].point,
            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMAX].point,
            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMIN].point,
            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMAX].point,
            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMIN].point,
            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMAX].point,
            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMIN].point,
            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMAX].point,
        ];
        const xs = corners.map((p) => p[0]);
        const ys = corners.map((p) => p[1]);
        const zs = corners.map((p) => p[2]);
        const xMin = Math.min(...xs), xMax = Math.max(...xs);
        const yMin = Math.min(...ys), yMax = Math.max(...ys);
        const zMin = Math.min(...zs), zMax = Math.max(...zs);
        this.sphereStates[SPHEREINDEX.XMIN].point = [
            xMin,
            (yMin + yMax) / 2,
            (zMin + zMax) / 2,
        ];
        this.sphereStates[SPHEREINDEX.XMAX].point = [
            xMax,
            (yMin + yMax) / 2,
            (zMin + zMax) / 2,
        ];
        this.sphereStates[SPHEREINDEX.YMIN].point = [
            (xMin + xMax) / 2,
            yMin,
            (zMin + zMax) / 2,
        ];
        this.sphereStates[SPHEREINDEX.YMAX].point = [
            (xMin + xMax) / 2,
            yMax,
            (zMin + zMax) / 2,
        ];
        this.sphereStates[SPHEREINDEX.ZMIN].point = [
            (xMin + xMax) / 2,
            (yMin + yMax) / 2,
            zMin,
        ];
        this.sphereStates[SPHEREINDEX.ZMAX].point = [
            (xMin + xMax) / 2,
            (yMin + yMax) / 2,
            zMax,
        ];
        [
            SPHEREINDEX.XMIN,
            SPHEREINDEX.XMAX,
            SPHEREINDEX.YMIN,
            SPHEREINDEX.YMAX,
            SPHEREINDEX.ZMIN,
            SPHEREINDEX.ZMAX,
        ].forEach((idx) => {
            const s = this.sphereStates[idx];
            s.sphereSource.setCenter(...s.point);
            s.sphereSource.modified();
        });
    }
    _updateCornerSpheres() {
        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];
        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];
        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];
        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];
        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];
        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];
        const corners = [
            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },
            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },
            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },
            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },
            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },
            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },
            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },
            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },
        ];
        for (const corner of corners) {
            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);
            if (state) {
                state.point[0] = corner.pos[0];
                state.point[1] = corner.pos[1];
                state.point[2] = corner.pos[2];
                state.sphereSource.setCenter(...state.point);
                state.sphereSource.modified();
            }
        }
        Object.values(this.edgeLines).forEach(({ source, key1, key2 }) => {
            const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);
            const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);
            if (state1 && state2) {
                const points = source.getPoints();
                points.setPoint(0, state1.point[0], state1.point[1], state1.point[2]);
                points.setPoint(1, state2.point[0], state2.point[1], state2.point[2]);
                points.modified();
                source.modified();
            }
        });
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
}
VolumeCroppingTool.toolName = 'VolumeCropping';
/* harmony default export */ const tools_VolumeCroppingTool = ((/* unused pure expression or super */ null && (VolumeCroppingTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js
var liangBarksyClip = __webpack_require__(35381);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingControlTool.js















const { RENDERING_DEFAULTS } = esm.CONSTANTS;
function defaultReferenceLineColor() {
    return 'rgb(0, 200, 0)';
}
function defaultReferenceLineControllable() {
    return true;
}
const OPERATION = {
    DRAG: 1,
    ROTATE: 2,
    SLAB: 3,
};
class VolumeCroppingControlTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse'],
        configuration: {
            viewportIndicators: false,
            viewportIndicatorsConfig: {
                radius: 5,
                x: null,
                y: null,
            },
            extendReferenceLines: true,
            initialCropFactor: 0.2,
            mobile: {
                enabled: false,
                opacity: 0.8,
            },
            lineColors: {
                AXIAL: [1.0, 0.0, 0.0],
                CORONAL: [0.0, 1.0, 0.0],
                SAGITTAL: [1.0, 1.0, 0.0],
                UNKNOWN: [0.0, 0.0, 1.0],
            },
            lineWidth: 1.5,
            lineWidthActive: 2.5,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._virtualAnnotations = [];
        this.sphereStates = [];
        this.draggingSphereIndex = null;
        this.toolCenter = [0, 0, 0];
        this.toolCenterMin = [0, 0, 0];
        this.toolCenterMax = [0, 0, 0];
        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {
            if (!renderingEngineId || !viewportId) {
                console.warn('VolumeCroppingControlTool: Missing renderingEngineId or viewportId');
                return;
            }
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            this._updateToolCentersFromViewport(viewport);
            const { element } = viewport;
            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
            let annotations = this._getAnnotations(enabledElement);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (annotations?.length) {
                (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
            }
            const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);
            const annotation = {
                highlighted: false,
                metadata: {
                    cameraPosition: [...position],
                    cameraFocalPoint: [...focalPoint],
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        toolCenter: this.toolCenter,
                        toolCenterMin: this.toolCenterMin,
                        toolCenterMax: this.toolCenterMax,
                    },
                    activeOperation: null,
                    activeViewportIds: [],
                    viewportId,
                    referenceLines: [],
                    orientation,
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            return {
                normal: viewPlaneNormal,
                point: viewport.canvasToWorld([100, 100]),
            };
        };
        this._getViewportsInfo = () => {
            const viewports = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resetCroppingSpheres = () => {
            const viewportsInfo = this._getViewportsInfo();
            for (const viewportInfo of viewportsInfo) {
                const { viewportId, renderingEngineId } = viewportInfo;
                const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const viewport = enabledElement.viewport;
                const resetPan = true;
                const resetZoom = true;
                const resetToCenter = true;
                const resetRotation = true;
                const suppressEvents = true;
                viewport.resetCamera({
                    resetPan,
                    resetZoom,
                    resetToCenter,
                    resetRotation,
                    suppressEvents,
                });
                viewport.resetSlabThickness();
                const { element } = viewport;
                let annotations = this._getAnnotations(enabledElement);
                annotations = this.filterInteractableAnnotationsForElement(element, annotations);
                if (annotations.length) {
                    (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
                }
                viewport.render();
            }
            this._computeToolCenter(viewportsInfo);
        };
        this.computeToolCenter = () => {
            const viewportsInfo = this._getViewportsInfo();
        };
        this._computeToolCenter = (viewportsInfo) => {
            if (!viewportsInfo || !viewportsInfo[0]) {
                console.warn('  _computeToolCenter : No valid viewportsInfo for computeToolCenter.');
                return;
            }
            const orientationIds = ['AXIAL', 'CORONAL', 'SAGITTAL'];
            const presentOrientations = viewportsInfo
                .map((vp) => {
                if (vp.renderingEngineId) {
                    const renderingEngine = (0,esm.getRenderingEngine)(vp.renderingEngineId);
                    const viewport = renderingEngine.getViewport(vp.viewportId);
                    if (viewport && viewport.getCamera) {
                        const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);
                        if (orientation) {
                            return orientation;
                        }
                    }
                }
                return null;
            })
                .filter(Boolean);
            const missingOrientation = orientationIds.find((id) => !presentOrientations.includes(id));
            const presentNormals = [];
            const presentCenters = [];
            const presentViewportInfos = viewportsInfo.filter((vp) => {
                let orientation = null;
                if (vp.renderingEngineId) {
                    const renderingEngine = (0,esm.getRenderingEngine)(vp.renderingEngineId);
                    const viewport = renderingEngine.getViewport(vp.viewportId);
                    if (viewport && viewport.getCamera) {
                        orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);
                    }
                }
                return orientation && orientationIds.includes(orientation);
            });
            presentViewportInfos.forEach((vpInfo) => {
                const { normal, point } = this.initializeViewport(vpInfo);
                presentNormals.push(normal);
                presentCenters.push(point);
            });
            if (presentViewportInfos.length === 2 && missingOrientation) {
                const virtualNormal = [0, 0, 0];
                gl_matrix_esm/* vec3.cross */.eR.cross(virtualNormal, presentNormals[0], presentNormals[1]);
                gl_matrix_esm/* vec3.normalize */.eR.normalize(virtualNormal, virtualNormal);
                const virtualCenter = [
                    (presentCenters[0][0] + presentCenters[1][0]) / 2,
                    (presentCenters[0][1] + presentCenters[1][1]) / 2,
                    (presentCenters[0][2] + presentCenters[1][2]) / 2,
                ];
                const orientation = null;
                const virtualAnnotation = {
                    highlighted: false,
                    metadata: {
                        cameraPosition: [...virtualCenter],
                        cameraFocalPoint: [...virtualCenter],
                        toolName: this.getToolName(),
                    },
                    data: {
                        handles: {
                            activeOperation: null,
                            toolCenter: this.toolCenter,
                            toolCenterMin: this.toolCenterMin,
                            toolCenterMax: this.toolCenterMax,
                        },
                        activeViewportIds: [],
                        viewportId: missingOrientation,
                        referenceLines: [],
                        orientation,
                    },
                    isVirtual: true,
                    virtualNormal,
                };
                this._virtualAnnotations = [virtualAnnotation];
            }
            else if (presentViewportInfos.length === 1) {
                let presentOrientation = null;
                const vpInfo = presentViewportInfos[0];
                if (vpInfo.renderingEngineId) {
                    const renderingEngine = (0,esm.getRenderingEngine)(vpInfo.renderingEngineId);
                    const viewport = renderingEngine.getViewport(vpInfo.viewportId);
                    if (viewport && viewport.getCamera) {
                        presentOrientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);
                    }
                }
                const presentCenter = presentCenters[0];
                const canonicalNormals = {
                    AXIAL: [0, 0, 1],
                    CORONAL: [0, 1, 0],
                    SAGITTAL: [1, 0, 0],
                };
                const missingIds = orientationIds.filter((id) => id !== presentOrientation);
                const virtualAnnotations = missingIds.map((orientation) => {
                    const normal = canonicalNormals[orientation];
                    const virtualAnnotation = {
                        highlighted: false,
                        metadata: {
                            cameraPosition: [...presentCenter],
                            cameraFocalPoint: [...presentCenter],
                            toolName: this.getToolName(),
                        },
                        data: {
                            handles: {
                                activeOperation: null,
                                toolCenter: this.toolCenter,
                                toolCenterMin: this.toolCenterMin,
                                toolCenterMax: this.toolCenterMax,
                            },
                            activeViewportIds: [],
                            viewportId: orientation,
                            referenceLines: [],
                            orientation,
                        },
                        isVirtual: true,
                        virtualNormal: normal,
                    };
                    return virtualAnnotation;
                });
                this._virtualAnnotations = virtualAnnotations;
            }
            if (viewportsInfo && viewportsInfo.length) {
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
            }
        };
        this.cancel = () => {
            console.log('Not implemented yet');
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.onResetCamera = (evt) => {
            this.resetCroppingSpheres();
        };
        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
            if (!filteredToolAnnotations) {
                return;
            }
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let imageNeedsUpdate = false;
            for (let i = 0; i < filteredToolAnnotations.length; i++) {
                const annotation = filteredToolAnnotations[i];
                if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
                    continue;
                }
                const { data, highlighted } = annotation;
                if (!data.handles) {
                    continue;
                }
                const previousActiveOperation = data.handles.activeOperation;
                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0
                    ? [...data.activeViewportIds]
                    : [];
                data.activeViewportIds = [];
                let near = false;
                near = this._pointNearTool(element, annotation, canvasCoords, 6);
                const nearToolAndNotMarkedActive = near && !highlighted;
                const notNearToolAndMarkedActive = !near && highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !highlighted;
                    imageNeedsUpdate = true;
                }
            }
            return imageNeedsUpdate;
        };
        this.filterInteractableAnnotationsForElement = (element, annotations) => {
            if (!annotations || !annotations.length) {
                return [];
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            let orientation = null;
            if (enabledElement.viewport && enabledElement.viewport.getCamera) {
                orientation = this._getOrientationFromNormal(enabledElement.viewport.getCamera().viewPlaneNormal);
            }
            const filtered = annotations.filter((annotation) => {
                if (annotation.isVirtual) {
                    return true;
                }
                if (annotation.data.orientation &&
                    orientation &&
                    annotation.data.orientation === orientation) {
                    return true;
                }
                return false;
            });
            return filtered;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            function lineIntersection2D(p1, p2, q1, q2) {
                const s1_x = p2[0] - p1[0];
                const s1_y = p2[1] - p1[1];
                const s2_x = q2[0] - q1[0];
                const s2_y = q2[1] - q1[1];
                const denom = -s2_x * s1_y + s1_x * s2_y;
                if (Math.abs(denom) < 1e-8) {
                    return null;
                }
                const s = (-s1_y * (p1[0] - q1[0]) + s1_x * (p1[1] - q1[1])) / denom;
                const t = (s2_x * (p1[1] - q1[1]) - s2_y * (p1[0] - q1[0])) / denom;
                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                    return [p1[0] + t * s1_x, p1[1] + t * s1_y];
                }
                return null;
            }
            const viewportsInfo = this._getViewportsInfo();
            if (!viewportsInfo || viewportsInfo.length === 0) {
                return false;
            }
            let renderStatus = false;
            const { viewport, renderingEngine } = enabledElement;
            const { element } = viewport;
            let annotations = this._getAnnotations(enabledElement);
            if (this._virtualAnnotations && this._virtualAnnotations.length) {
                annotations = annotations.concat(this._virtualAnnotations);
            }
            const camera = viewport.getCamera();
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation || !viewportAnnotation.data) {
                return renderStatus;
            }
            const annotationUID = viewportAnnotation.annotationUID;
            const { clientWidth, clientHeight } = viewport.canvas;
            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
            const data = viewportAnnotation.data;
            const otherViewportAnnotations = annotations;
            const volumeCroppingCenterCanvasMin = viewport.worldToCanvas(this.toolCenterMin);
            const volumeCroppingCenterCanvasMax = viewport.worldToCanvas(this.toolCenterMax);
            const referenceLines = [];
            const canvasBox = [0, 0, clientWidth, clientHeight];
            otherViewportAnnotations.forEach((annotation) => {
                const data = annotation.data;
                const isVirtual = 'isVirtual' in annotation &&
                    annotation.isVirtual === true;
                data.handles.toolCenter = this.toolCenter;
                let otherViewport, otherCamera, clientWidth, clientHeight, otherCanvasDiagonalLength, otherCanvasCenter, otherViewportCenterWorld;
                if (isVirtual) {
                    const realViewports = viewportsInfo.filter((vp) => vp.viewportId !== data.viewportId);
                    if (realViewports.length === 2) {
                        const vp1 = renderingEngine.getViewport(realViewports[0].viewportId);
                        const vp2 = renderingEngine.getViewport(realViewports[1].viewportId);
                        const normal1 = vp1.getCamera().viewPlaneNormal;
                        const normal2 = vp2.getCamera().viewPlaneNormal;
                        const virtualNormal = gl_matrix_esm/* vec3.create */.eR.create();
                        gl_matrix_esm/* vec3.cross */.eR.cross(virtualNormal, normal1, normal2);
                        gl_matrix_esm/* vec3.normalize */.eR.normalize(virtualNormal, virtualNormal);
                        otherCamera = {
                            viewPlaneNormal: virtualNormal,
                            position: data.handles.toolCenter,
                            focalPoint: data.handles.toolCenter,
                            viewUp: [0, 1, 0],
                        };
                        clientWidth = viewport.canvas.clientWidth;
                        clientHeight = viewport.canvas.clientHeight;
                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];
                        otherViewportCenterWorld = data.handles.toolCenter;
                        otherViewport = {
                            id: data.viewportId,
                            canvas: viewport.canvas,
                            canvasToWorld: () => data.handles.toolCenter,
                        };
                    }
                    else {
                        const virtualNormal = annotation
                            .virtualNormal ?? [0, 0, 1];
                        otherCamera = {
                            viewPlaneNormal: virtualNormal,
                            position: data.handles.toolCenter,
                            focalPoint: data.handles.toolCenter,
                            viewUp: [0, 1, 0],
                        };
                        clientWidth = viewport.canvas.clientWidth;
                        clientHeight = viewport.canvas.clientHeight;
                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];
                        otherViewportCenterWorld = data.handles.toolCenter;
                        otherViewport = {
                            id: data.viewportId,
                            canvas: viewport.canvas,
                            canvasToWorld: () => data.handles.toolCenter,
                        };
                    }
                }
                else {
                    otherViewport = renderingEngine.getViewport(data.viewportId);
                    otherCamera = otherViewport.getCamera();
                    clientWidth = otherViewport.canvas.clientWidth;
                    clientHeight = otherViewport.canvas.clientHeight;
                    otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                    otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];
                    otherViewportCenterWorld =
                        otherViewport.canvasToWorld(otherCanvasCenter);
                }
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const direction = [0, 0, 0];
                Core_Math/* default.cross */.Ay.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
                Core_Math/* default.normalize */.Ay.normalize(direction);
                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(direction, otherCanvasDiagonalLength);
                const pointWorld0 = [0, 0, 0];
                Core_Math/* default.add */.Ay.add(otherViewportCenterWorld, direction, pointWorld0);
                const pointWorld1 = [0, 0, 0];
                Core_Math/* default.subtract */.Ay.subtract(otherViewportCenterWorld, direction, pointWorld1);
                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
                const otherViewportCenterCanvas = viewport.worldToCanvas([
                    otherViewportCenterWorld[0] ?? 0,
                    otherViewportCenterWorld[1] ?? 0,
                    otherViewportCenterWorld[2] ?? 0,
                ]);
                const canvasUnitVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
                gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
                const canvasVectorFromCenterLong = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
                const refLinesCenterMin = otherViewportControllable
                    ? gl_matrix_esm/* vec2.clone */.Zc.clone(volumeCroppingCenterCanvasMin)
                    : gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                const refLinePointMinOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointMinTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointMinOne, refLinesCenterMin, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointMinTwo, refLinesCenterMin, canvasVectorFromCenterLong);
                (0,liangBarksyClip/* default */.A)(refLinePointMinOne, refLinePointMinTwo, canvasBox);
                referenceLines.push([
                    otherViewport,
                    refLinePointMinOne,
                    refLinePointMinTwo,
                    'min',
                ]);
                const refLinesCenterMax = otherViewportControllable
                    ? gl_matrix_esm/* vec2.clone */.Zc.clone(volumeCroppingCenterCanvasMax)
                    : gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                const refLinePointMaxOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointMaxTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointMaxOne, refLinesCenterMax, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointMaxTwo, refLinesCenterMax, canvasVectorFromCenterLong);
                (0,liangBarksyClip/* default */.A)(refLinePointMaxOne, refLinePointMaxTwo, canvasBox);
                referenceLines.push([
                    otherViewport,
                    refLinePointMaxOne,
                    refLinePointMaxTwo,
                    'max',
                ]);
            });
            data.referenceLines = referenceLines;
            const viewportColor = this._getReferenceLineColor(viewport.id);
            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
            referenceLines.forEach((line, lineIndex) => {
                const intersections = [];
                for (let j = 0; j < referenceLines.length; ++j) {
                    if (j === lineIndex) {
                        continue;
                    }
                    const otherLine = referenceLines[j];
                    const intersection = lineIntersection2D(line[1], line[2], otherLine[1], otherLine[2]);
                    if (intersection) {
                        intersections.push({
                            with: otherLine[3],
                            point: intersection,
                        });
                    }
                }
                const otherViewport = line[0];
                let orientation = null;
                if (otherViewport && otherViewport.id) {
                    const annotationForViewport = annotations.find((a) => a.data.viewportId === otherViewport.id);
                    if (annotationForViewport && annotationForViewport.data.orientation) {
                        orientation = String(annotationForViewport.data.orientation).toUpperCase();
                    }
                    else {
                        const idUpper = otherViewport.id.toUpperCase();
                        if (idUpper.includes('AXIAL')) {
                            orientation = 'AXIAL';
                        }
                        else if (idUpper.includes('CORONAL')) {
                            orientation = 'CORONAL';
                        }
                        else if (idUpper.includes('SAGITTAL')) {
                            orientation = 'SAGITTAL';
                        }
                    }
                }
                const lineColors = this.configuration.lineColors || {};
                const colorArr = lineColors[orientation] ||
                    lineColors.unknown || [1.0, 0.0, 0.0];
                const color = Array.isArray(colorArr)
                    ? `rgb(${colorArr.map((v) => Math.round(v * 255)).join(',')})`
                    : colorArr;
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
                let lineWidth = this.configuration.lineWidth ?? 1.5;
                const lineActive = data.handles.activeOperation !== null &&
                    data.handles.activeOperation === OPERATION.DRAG &&
                    selectedViewportId;
                if (lineActive) {
                    lineWidth = this.configuration.activeLineWidth ?? 2.5;
                }
                const lineUID = `${lineIndex}`;
                if (viewportControllable) {
                    if (intersections.length === 2) {
                        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, intersections[0].point, intersections[1].point, {
                            color,
                            lineWidth,
                        });
                    }
                    if (this.configuration.extendReferenceLines &&
                        intersections.length === 2) {
                        if (this.configuration.extendReferenceLines &&
                            intersections.length === 2) {
                            const sortedIntersections = intersections
                                .map((intersection) => ({
                                ...intersection,
                                distance: gl_matrix_esm/* vec2.distance */.Zc.distance(line[1], intersection.point),
                            }))
                                .sort((a, b) => a.distance - b.distance);
                            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID + '_dashed_before', line[1], sortedIntersections[0].point, { color, lineWidth, lineDash: [4, 4] });
                            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID + '_dashed_after', sortedIntersections[1].point, line[2], { color, lineWidth, lineDash: [4, 4] });
                        }
                    }
                }
            });
            renderStatus = true;
            if (this.configuration.viewportIndicators) {
                const { viewportIndicatorsConfig } = this.configuration;
                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;
                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;
                const referenceColorCoordinates = [
                    clientWidth * xOffset,
                    clientHeight * yOffset,
                ];
                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
            }
            return renderStatus;
        };
        this._getAnnotations = (enabledElement) => {
            const { viewport } = enabledElement;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element) || [];
            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
            const toolGroupAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                return viewportIds.includes(data.viewportId);
            });
            return toolGroupAnnotations;
        };
        this._onSphereMoved = (evt) => {
            if (evt.detail.originalClippingPlanes) {
                this._syncWithVolumeCroppingTool(evt.detail.originalClippingPlanes);
            }
            else {
                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {
                    return;
                }
                const { draggingSphereIndex, toolCenter } = evt.detail;
                const newMin = [...this.toolCenterMin];
                const newMax = [...this.toolCenterMax];
                if (draggingSphereIndex >= 0 && draggingSphereIndex <= 5) {
                    const axis = Math.floor(draggingSphereIndex / 2);
                    const isMin = draggingSphereIndex % 2 === 0;
                    (isMin ? newMin : newMax)[axis] = toolCenter[axis];
                    this.setToolCenter(newMin, 'min');
                    this.setToolCenter(newMax, 'max');
                    return;
                }
                if (draggingSphereIndex >= 6 && draggingSphereIndex <= 13) {
                    const idx = draggingSphereIndex;
                    if (idx < 10) {
                        newMin[0] = toolCenter[0];
                    }
                    else {
                        newMax[0] = toolCenter[0];
                    }
                    if ([6, 7, 10, 11].includes(idx)) {
                        newMin[1] = toolCenter[1];
                    }
                    else {
                        newMax[1] = toolCenter[1];
                    }
                    if (idx % 2 === 0) {
                        newMin[2] = toolCenter[2];
                    }
                    else {
                        newMax[2] = toolCenter[2];
                    }
                    this.setToolCenter(newMin, 'min');
                    this.setToolCenter(newMax, 'max');
                }
            }
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            if (viewportsInfo && viewportsInfo.length > 0) {
                const { viewportId, renderingEngineId } = viewportsInfo[0];
                const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
                const viewport = renderingEngine.getViewport(viewportId);
                const volumeActors = viewport.getActors();
                if (volumeActors.length > 0) {
                    const imageData = volumeActors[0].actor.getMapper().getInputData();
                    if (imageData) {
                        this.seriesInstanceUID = imageData.seriesInstanceUID;
                        this._updateToolCentersFromViewport(viewport);
                        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewportId) || [];
                        annotations.forEach((annotation) => {
                            if (annotation.data && annotation.data.handles) {
                                annotation.data.handles.toolCenter = [...this.toolCenter];
                            }
                        });
                    }
                }
            }
            this._computeToolCenter(viewportsInfo);
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {
                toolGroupId: this.toolGroupId,
                viewportsInfo: viewportsInfo,
                seriesInstanceUID: this.seriesInstanceUID,
            });
        };
        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
            const { viewportId, renderingEngine, viewport } = enabledElement;
            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const { viewPlaneNormal, position } = camera;
            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const targetViewport = renderingEngine.getViewport(viewportId);
                const cameraOfTarget = targetViewport.getCamera();
                return !(esm.utilities.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && esm.utilities.isEqual(cameraOfTarget.position, position, 1));
            });
            return viewportsWithDifferentCameras;
        };
        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
            const { renderingEngine } = enabledElement;
            const { data } = referenceAnnotation;
            const viewport = renderingEngine.getViewport(data.viewportId);
            const linkedViewportAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return otherViewportControllable === true;
            });
            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            Core_Math/* default.normalize */.Ay.normalize(viewPlaneNormal);
            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                return (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&
                    esm.utilities.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));
            });
            return otherViewportsAnnotationsWithSameCameraDirection;
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = !this.configuration.mobile?.enabled;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this.editData.annotation.data.handles.activeOperation = null;
            this.editData.annotation.data.activeViewportIds = [];
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const delta = eventDetail.deltaPoints.world;
            if (Math.abs(delta[0]) < 1e-3 &&
                Math.abs(delta[1]) < 1e-3 &&
                Math.abs(delta[2]) < 1e-3) {
                return;
            }
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            if (viewport.type === esm.Enums.ViewportType.VOLUME_3D) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const { handles } = viewportAnnotation.data;
            if (handles.activeOperation === OPERATION.DRAG) {
                if (handles.activeType === 'min') {
                    this.toolCenterMin[0] += delta[0];
                    this.toolCenterMin[1] += delta[1];
                    this.toolCenterMin[2] += delta[2];
                }
                else if (handles.activeType === 'max') {
                    this.toolCenterMax[0] += delta[0];
                    this.toolCenterMax[1] += delta[1];
                    this.toolCenterMax[2] += delta[2];
                }
                else {
                    this.toolCenter[0] += delta[0];
                    this.toolCenter[1] += delta[1];
                    this.toolCenter[2] += delta[2];
                }
                const viewportsInfo = this._getViewportsInfo();
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
                (0,esm.triggerEvent)(esm.eventTarget, enums.Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {
                    toolGroupId: this.toolGroupId,
                    toolCenter: this.toolCenter,
                    toolCenterMin: this.toolCenterMin,
                    toolCenterMax: this.toolCenterMax,
                    handleType: handles.activeType,
                    viewportOrientation: [],
                    seriesInstanceUID: this.seriesInstanceUID,
                });
            }
        };
        this._getReferenceLineColor =
            toolProps.configuration?.getReferenceLineColor ||
                defaultReferenceLineColor;
        this._getReferenceLineControllable =
            toolProps.configuration?.getReferenceLineControllable ||
                defaultReferenceLineControllable;
        const viewportsInfo = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId)?.viewportsInfo;
        esm.eventTarget.addEventListener(enums.Events.VOLUMECROPPING_TOOL_CHANGED, this._onSphereMoved);
        if (viewportsInfo && viewportsInfo.length > 0) {
            const { viewportId, renderingEngineId } = viewportsInfo[0];
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
            const viewport = renderingEngine.getViewport(viewportId);
            const volumeActors = viewport.getActors();
            if (!volumeActors || !volumeActors.length) {
                console.warn(`VolumeCroppingControlTool: No volume actors found in viewport ${viewportId}.`);
                return;
            }
            const imageData = volumeActors[0].actor.getMapper().getInputData();
            if (imageData) {
                const dimensions = imageData.getDimensions();
                const spacing = imageData.getSpacing();
                const origin = imageData.getOrigin();
                this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';
                const cropFactor = this.configuration.initialCropFactor ?? 0.2;
                this.toolCenter = [
                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],
                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],
                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],
                ];
                const maxCropFactor = 1 - cropFactor;
                this.toolCenterMin = [
                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],
                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],
                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],
                ];
                this.toolCenterMax = [
                    origin[0] + maxCropFactor * (dimensions[0] - 1) * spacing[0],
                    origin[1] + maxCropFactor * (dimensions[1] - 1) * spacing[1],
                    origin[2] + maxCropFactor * (dimensions[2] - 1) * spacing[2],
                ];
            }
        }
    }
    _updateToolCentersFromViewport(viewport) {
        const volumeActors = viewport.getActors();
        if (!volumeActors || !volumeActors.length) {
            return;
        }
        const imageData = volumeActors[0].actor.getMapper().getInputData();
        if (!imageData) {
            return;
        }
        this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';
        const dimensions = imageData.getDimensions();
        const spacing = imageData.getSpacing();
        const origin = imageData.getOrigin();
        const cropFactor = this.configuration.initialCropFactor ?? 0.2;
        const cropStart = cropFactor / 2;
        const cropEnd = 1 - cropFactor / 2;
        this.toolCenter = [
            origin[0] +
                ((cropStart + cropEnd) / 2) * (dimensions[0] - 1) * spacing[0],
            origin[1] +
                ((cropStart + cropEnd) / 2) * (dimensions[1] - 1) * spacing[1],
            origin[2] +
                ((cropStart + cropEnd) / 2) * (dimensions[2] - 1) * spacing[2],
        ];
        this.toolCenterMin = [
            origin[0] + cropStart * (dimensions[0] - 1) * spacing[0],
            origin[1] + cropStart * (dimensions[1] - 1) * spacing[1],
            origin[2] + cropStart * (dimensions[2] - 1) * spacing[2],
        ];
        this.toolCenterMax = [
            origin[0] + cropEnd * (dimensions[0] - 1) * spacing[0],
            origin[1] + cropEnd * (dimensions[1] - 1) * spacing[1],
            origin[2] + cropEnd * (dimensions[2] - 1) * spacing[2],
        ];
    }
    onSetToolInactive() {
        console.debug(`VolumeCroppingControlTool: onSetToolInactive called for tool ${this.getToolName()}`);
    }
    onSetToolActive() {
        const viewportsInfo = this._getViewportsInfo();
        let anyAnnotationExists = false;
        for (const vpInfo of viewportsInfo) {
            const enabledElement = (0,esm.getEnabledElementByIds)(vpInfo.viewportId, vpInfo.renderingEngineId);
            const annotations = this._getAnnotations(enabledElement);
            if (annotations && annotations.length > 0) {
                anyAnnotationExists = true;
                break;
            }
        }
        if (!anyAnnotationExists) {
            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
            this._subscribeToViewportNewVolumeSet(viewportsInfo);
            this._computeToolCenter(viewportsInfo);
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {
                toolGroupId: this.toolGroupId,
                viewportsInfo: viewportsInfo,
                seriesInstanceUID: this.seriesInstanceUID,
            });
        }
        else {
            for (const vpInfo of viewportsInfo) {
                const enabledElement = (0,esm.getEnabledElementByIds)(vpInfo.viewportId, vpInfo.renderingEngineId);
                if (!enabledElement) {
                    continue;
                }
                const annotations = this._getAnnotations(enabledElement);
                if (annotations && annotations.length > 0) {
                    annotations.forEach((annotation) => {
                        (0,annotationState.removeAnnotation)(annotation.annotationUID);
                    });
                }
                enabledElement.viewport.render();
            }
        }
    }
    onSetToolEnabled() {
        console.debug(`VolumeCroppingControlTool: onSetToolEnabled called for tool ${this.getToolName()}`);
        const viewportsInfo = this._getViewportsInfo();
    }
    onSetToolDisabled() {
        console.debug(`VolumeCroppingControlTool: onSetToolDisabled called for tool ${this.getToolName()}`);
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            if (annotations?.length) {
                annotations.forEach((annotation) => {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                });
            }
        });
    }
    _getOrientationFromNormal(normal) {
        if (!normal) {
            return null;
        }
        const canonical = {
            AXIAL: [0, 0, 1],
            CORONAL: [0, 1, 0],
            SAGITTAL: [1, 0, 0],
        };
        const tol = 1e-2;
        for (const [key, value] of Object.entries(canonical)) {
            if (Math.abs(normal[0] - value[0]) < tol &&
                Math.abs(normal[1] - value[1]) < tol &&
                Math.abs(normal[2] - value[2]) < tol) {
                return key;
            }
            if (Math.abs(normal[0] + value[0]) < tol &&
                Math.abs(normal[1] + value[1]) < tol &&
                Math.abs(normal[2] + value[2]) < tol) {
                return key;
            }
        }
        return null;
    }
    _syncWithVolumeCroppingTool(originalClippingPlanes) {
        const planes = originalClippingPlanes;
        if (planes.length >= 6) {
            this.toolCenterMin = [
                planes[0].origin[0],
                planes[2].origin[1],
                planes[4].origin[2],
            ];
            this.toolCenterMax = [
                planes[1].origin[0],
                planes[3].origin[1],
                planes[5].origin[2],
            ];
            this.toolCenter = [
                (this.toolCenterMin[0] + this.toolCenterMax[0]) / 2,
                (this.toolCenterMin[1] + this.toolCenterMax[1]) / 2,
                (this.toolCenterMin[2] + this.toolCenterMax[2]) / 2,
            ];
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                if (enabledElement) {
                    const annotations = this._getAnnotations(enabledElement);
                    annotations.forEach((annotation) => {
                        if (annotation.data &&
                            annotation.data.handles &&
                            annotation.data.orientation) {
                            const orientation = annotation.data.orientation;
                            if (orientation === 'AXIAL') {
                                annotation.data.handles.toolCenterMin = [
                                    planes[0].origin[0],
                                    planes[2].origin[1],
                                    annotation.data.handles.toolCenterMin[2],
                                ];
                                annotation.data.handles.toolCenterMax = [
                                    planes[1].origin[0],
                                    planes[3].origin[1],
                                    annotation.data.handles.toolCenterMax[2],
                                ];
                            }
                            else if (orientation === 'CORONAL') {
                                annotation.data.handles.toolCenterMin = [
                                    planes[0].origin[0],
                                    annotation.data.handles.toolCenterMin[1],
                                    planes[4].origin[2],
                                ];
                                annotation.data.handles.toolCenterMax = [
                                    planes[1].origin[0],
                                    annotation.data.handles.toolCenterMax[1],
                                    planes[5].origin[2],
                                ];
                            }
                            else if (orientation === 'SAGITTAL') {
                                annotation.data.handles.toolCenterMin = [
                                    annotation.data.handles.toolCenterMin[0],
                                    planes[2].origin[1],
                                    planes[4].origin[2],
                                ];
                                annotation.data.handles.toolCenterMax = [
                                    annotation.data.handles.toolCenterMax[0],
                                    planes[3].origin[1],
                                    planes[5].origin[2],
                                ];
                            }
                            annotation.data.handles.toolCenter = [
                                (annotation.data.handles.toolCenterMin[0] +
                                    annotation.data.handles.toolCenterMax[0]) /
                                    2,
                                (annotation.data.handles.toolCenterMin[1] +
                                    annotation.data.handles.toolCenterMax[1]) /
                                    2,
                                (annotation.data.handles.toolCenterMin[2] +
                                    annotation.data.handles.toolCenterMax[2]) /
                                    2,
                            ];
                        }
                    });
                }
            });
            if (this._virtualAnnotations && this._virtualAnnotations.length > 0) {
                this._virtualAnnotations.forEach((annotation) => {
                    if (annotation.data &&
                        annotation.data.handles &&
                        annotation.data.orientation) {
                        const orientation = annotation.data.orientation.toUpperCase();
                        if (orientation === 'AXIAL') {
                            annotation.data.handles.toolCenterMin = [
                                planes[0].origin[0],
                                planes[2].origin[1],
                                annotation.data.handles.toolCenterMin[2],
                            ];
                            annotation.data.handles.toolCenterMax = [
                                planes[1].origin[0],
                                planes[3].origin[1],
                                annotation.data.handles.toolCenterMax[2],
                            ];
                        }
                        else if (orientation === 'CORONAL') {
                            annotation.data.handles.toolCenterMin = [
                                planes[0].origin[0],
                                annotation.data.handles.toolCenterMin[1],
                                planes[4].origin[2],
                            ];
                            annotation.data.handles.toolCenterMax = [
                                planes[1].origin[0],
                                annotation.data.handles.toolCenterMax[1],
                                planes[5].origin[2],
                            ];
                        }
                        else if (orientation === 'SAGITTAL') {
                            annotation.data.handles.toolCenterMin = [
                                annotation.data.handles.toolCenterMin[0],
                                planes[2].origin[1],
                                planes[4].origin[2],
                            ];
                            annotation.data.handles.toolCenterMax = [
                                annotation.data.handles.toolCenterMax[0],
                                planes[3].origin[1],
                                planes[5].origin[2],
                            ];
                        }
                        annotation.data.handles.toolCenter = [
                            (annotation.data.handles.toolCenterMin[0] +
                                annotation.data.handles.toolCenterMax[0]) /
                                2,
                            (annotation.data.handles.toolCenterMin[1] +
                                annotation.data.handles.toolCenterMax[1]) /
                                2,
                            (annotation.data.handles.toolCenterMin[2] +
                                annotation.data.handles.toolCenterMax[2]) /
                                2,
                        ];
                    }
                });
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        }
    }
    setToolCenter(toolCenter, handleType) {
        if (handleType === 'min') {
            this.toolCenterMin = [...toolCenter];
        }
        else if (handleType === 'max') {
            this.toolCenterMax = [...toolCenter];
        }
        const viewportsInfo = this._getViewportsInfo();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const annotations = this._getAnnotations(enabledElement);
        const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
        if (!filteredAnnotations ||
            filteredAnnotations.length === 0 ||
            !filteredAnnotations[0]) {
            return null;
        }
        const { data } = filteredAnnotations[0];
        const viewportIdArray = [];
        const referenceLines = data.referenceLines || [];
        for (let i = 0; i < referenceLines.length; ++i) {
            const otherViewport = referenceLines[i][0];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            viewportIdArray.push(otherViewport.id);
            i++;
        }
        data.activeViewportIds = [...viewportIdArray];
        data.handles.activeOperation = OPERATION.DRAG;
        evt.preventDefault();
        (0,elementCursor.hideElementCursor)(element);
        this._activateModify(element);
        return filteredAnnotations[0];
    }
    handleSelectedCallback(evt, annotation, handle, interactionType) {
        this.toolSelectedCallback(evt, annotation, interactionType);
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
        viewportsAnnotationsToUpdate.forEach((annotation) => {
            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
        });
    }
    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
        const { data } = annotation;
        const viewport = renderingEngine.getViewport(data.viewportId);
        const camera = viewport.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = Core_Math/* default.dot */.Ay.dot(delta, normal);
        const projectedDelta = [...normal];
        Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            Core_Math/* default.add */.Ay.add(camera.focalPoint, projectedDelta, newFocalPoint);
            Core_Math/* default.add */.Ay.add(camera.position, projectedDelta, newPosition);
            viewport.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            viewport.render();
        }
    }
    _pointNearTool(element, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const referenceLines = data.referenceLines;
        const viewportIdArray = [];
        if (referenceLines) {
            for (let i = 0; i < referenceLines.length; ++i) {
                const otherViewport = referenceLines[i][0];
                const start1 = referenceLines[i][1];
                const end1 = referenceLines[i][2];
                const type = referenceLines[i][3];
                const distance1 = math_line.distanceToPoint(start1, end1, [
                    canvasCoords[0],
                    canvasCoords[1],
                ]);
                if (distance1 <= proximity) {
                    viewportIdArray.push(otherViewport.id);
                    data.handles.activeOperation = 1;
                    data.handles.activeType = type;
                }
            }
        }
        data.activeViewportIds = [...viewportIdArray];
        this.editData = {
            annotation,
        };
        return data.handles.activeOperation === 1 ? true : false;
    }
}
VolumeCroppingControlTool.toolName = 'VolumeCroppingControl';
/* harmony default export */ const tools_VolumeCroppingControlTool = ((/* unused pure expression or super */ null && (VolumeCroppingControlTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js


const DEFAULT_MULTIPLIER = 4;
const DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;
const PT = 'PT';
class WindowLevelTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            const frameLength = dimensions[0] * dimensions[1];
            let bytesPerVoxel;
            let TypedArrayConstructor;
            if (scalarData instanceof Float32Array) {
                bytesPerVoxel = 4;
                TypedArrayConstructor = Float32Array;
            }
            else if (scalarData instanceof Uint8Array) {
                bytesPerVoxel = 1;
                TypedArrayConstructor = Uint8Array;
            }
            else if (scalarData instanceof Uint16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Uint16Array;
            }
            else if (scalarData instanceof Int16Array) {
                bytesPerVoxel = 2;
                TypedArrayConstructor = Int16Array;
            }
            const buffer = scalarData.buffer;
            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;
            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);
            const { max, min } = this._getMinMax(frame, frameLength);
            return max - min;
        };
    }
    touchDragCallback(evt) {
        this.mouseDragCallback(evt);
    }
    mouseDragCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;
        let isPreScaled = false;
        const properties = viewport.getProperties();
        if (viewport instanceof esm.VolumeViewport) {
            volumeId = viewport.getVolumeId();
            viewportsContainingVolumeUID =
                esm.utilities.getViewportsWithVolumeId(volumeId);
            ({ lower, upper } = properties.voiRange);
            const volume = esm.cache.getVolume(volumeId);
            if (!volume) {
                throw new Error('Volume not found ' + volumeId);
            }
            modality = volume.metadata.Modality;
            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;
        }
        else if (properties.voiRange) {
            modality = viewport.modality;
            ({ lower, upper } = properties.voiRange);
            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};
            isPreScaled =
                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;
        }
        else {
            throw new Error('Viewport is not a valid type');
        }
        if (modality === PT && isPreScaled) {
            newRange = this.getPTScaledNewRange({
                deltaPointsCanvas: deltaPoints.canvas,
                lower,
                upper,
                clientHeight: element.clientHeight,
                isPreScaled,
                viewport,
                volumeId,
            });
        }
        else {
            newRange = this.getNewRange({
                viewport,
                deltaPointsCanvas: deltaPoints.canvas,
                volumeId,
                lower,
                upper,
            });
        }
        if (newRange.lower >= newRange.upper) {
            return;
        }
        viewport.setProperties({
            voiRange: newRange,
        });
        viewport.render();
        if (viewport instanceof esm.VolumeViewport) {
            viewportsContainingVolumeUID.forEach((vp) => {
                if (viewport !== vp) {
                    vp.render();
                }
            });
            return;
        }
    }
    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {
        let multiplier = DEFAULT_MULTIPLIER;
        if (isPreScaled) {
            multiplier = 5 / clientHeight;
        }
        else {
            multiplier =
                this._getMultiplierFromDynamicRange(viewport, volumeId) ||
                    DEFAULT_MULTIPLIER;
        }
        const deltaY = deltaPointsCanvas[1];
        const wcDelta = deltaY * multiplier;
        upper -= wcDelta;
        upper = isPreScaled ? Math.max(upper, 0.1) : upper;
        return { lower, upper };
    }
    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {
        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||
            DEFAULT_MULTIPLIER;
        const wwDelta = deltaPointsCanvas[0] * multiplier;
        const wcDelta = deltaPointsCanvas[1] * multiplier;
        let { windowWidth, windowCenter } = esm.utilities.windowLevel.toWindowLevel(lower, upper);
        windowWidth += wwDelta;
        windowCenter += wcDelta;
        windowWidth = Math.max(windowWidth, 1);
        const voiLutFunction = viewport.getProperties().VOILUTFunction;
        return esm.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
    }
    _getMultiplierFromDynamicRange(viewport, volumeId) {
        let imageDynamicRange;
        if (volumeId) {
            const imageVolume = esm.cache.getVolume(volumeId);
            const { voxelManager } = viewport.getImageData();
            const middleSlicePixelData = voxelManager.getMiddleSliceData();
            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {
                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];
            }, [Infinity, -Infinity]);
            const BitsStored = imageVolume?.metadata?.BitsStored;
            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;
            const calculatedRange = calculatedDynamicRange[1] - calculatedDynamicRange[0];
            imageDynamicRange = !Number.isFinite(calculatedRange)
                ? metadataDynamicRange
                : Math.min(calculatedRange, metadataDynamicRange);
        }
        else {
            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);
        }
        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;
        return !Number.isFinite(ratio)
            ? DEFAULT_IMAGE_DYNAMIC_RANGE
            : ratio > 1
                ? Math.round(ratio)
                : ratio;
    }
    _getImageDynamicRangeFromViewport(viewport) {
        const { imageData, voxelManager } = viewport.getImageData();
        if (voxelManager?.getRange) {
            const range = voxelManager.getRange();
            return range[1] - range[0];
        }
        const dimensions = imageData.getDimensions();
        if (imageData.getRange) {
            const imageDataRange = imageData.getRange();
            return imageDataRange[1] - imageDataRange[0];
        }
        let scalarData;
        if (imageData.getScalarData) {
            scalarData = imageData.getScalarData();
        }
        else {
            scalarData = imageData.getPointData().getScalars().getData();
        }
        if (dimensions[2] !== 1) {
            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);
        }
        let range;
        if (scalarData.getRange) {
            range = scalarData.getRange();
        }
        else {
            const { min, max } = this._getMinMax(scalarData, scalarData.length);
            range = [min, max];
        }
        return range[1] - range[0];
    }
    _getMinMax(frame, frameLength) {
        let min = Infinity;
        let max = -Infinity;
        for (let i = 0; i < frameLength; i++) {
            const voxel = frame[i];
            if (voxel < min) {
                min = voxel;
            }
            if (voxel > max) {
                max = voxel;
            }
        }
        return { max, min };
    }
}
WindowLevelTool.toolName = 'WindowLevel';
/* harmony default export */ const tools_WindowLevelTool = ((/* unused pure expression or super */ null && (WindowLevelTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js











class WindowLevelRegionTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minWindowWidth: 10,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                    cachedStats: {},
                },
            };
            (0,stateManagement/* addAnnotation */.lC)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,stateManagement/* removeAnnotation */.O8)(annotation.annotationUID);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            (0,helpers_state.triggerAnnotationCompleted)(annotation);
            this.applyWindowLevelRegion(annotation, element);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            const DEFAULT_HANDLE_INDEX = 3;
            points[DEFAULT_HANDLE_INDEX] = [...worldPos];
            const bottomLeftCanvas = worldToCanvas(points[0]);
            const topRightCanvas = worldToCanvas(points[3]);
            const bottomRightCanvas = [
                topRightCanvas[0],
                bottomLeftCanvas[1],
            ];
            const topLeftCanvas = [
                bottomLeftCanvas[0],
                topRightCanvas[1],
            ];
            const bottomRightWorld = canvasToWorld(bottomRightCanvas);
            const topLeftWorld = canvasToWorld(topLeftCanvas);
            points[1] = bottomRightWorld;
            points[2] = topLeftWorld;
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,stateManagement/* getAnnotations */.Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,drawingSvg.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
            }
            return renderStatus;
        };
        this.applyWindowLevelRegion = (annotation, element) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const imageData = extractWindowLevelRegionToolData(viewport);
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const startCanvas = canvasCoordinates[0];
            const endCanvas = canvasCoordinates[3];
            let left = Math.min(startCanvas[0], endCanvas[0]);
            let top = Math.min(startCanvas[1], endCanvas[1]);
            let width = Math.abs(startCanvas[0] - endCanvas[0]);
            let height = Math.abs(startCanvas[1] - endCanvas[1]);
            left = esm.utilities.clip(left, 0, imageData.width);
            top = esm.utilities.clip(top, 0, imageData.height);
            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));
            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));
            const pixelLuminanceData = getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);
            const minMaxMean = calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);
            if (this.configuration.minWindowWidth === undefined) {
                this.configuration.minWindowWidth = 10;
            }
            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);
            const windowCenter = minMaxMean.mean;
            const voiLutFunction = viewport.getProperties().VOILUTFunction;
            const voiRange = esm.utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);
            viewport.setProperties({ voiRange });
            viewport.render();
        };
        this.cancel = () => {
            return null;
        };
        this.isPointNearTool = () => {
            return null;
        };
        this.toolSelectedCallback = () => {
            return null;
        };
        this.handleSelectedCallback = () => {
            return null;
        };
        this._activateModify = () => {
            return null;
        };
        this._deactivateModify = () => {
            return null;
        };
    }
}
WindowLevelRegionTool.toolName = 'WindowLevelRegion';
/* harmony default export */ const tools_WindowLevelRegionTool = ((/* unused pure expression or super */ null && (WindowLevelRegionTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js


class StackScrollTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            invert: false,
            debounceIfNotLoaded: true,
            loop: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.deltaY = 1;
    }
    mouseWheelCallback(evt) {
        this._scroll(evt);
    }
    mouseDragCallback(evt) {
        this._dragCallback(evt);
    }
    touchDragCallback(evt) {
        this._dragCallback(evt);
    }
    _dragCallback(evt) {
        this._scrollDrag(evt);
    }
    _scrollDrag(evt) {
        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;
        const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
        const { debounceIfNotLoaded, invert, loop } = this.configuration;
        const deltaPointY = deltaPoints.canvas[1];
        let volumeId;
        if (viewport instanceof esm.VolumeViewport) {
            volumeId = viewport.getVolumeId();
        }
        const pixelsPerImage = this._getPixelPerImage(viewport);
        const deltaY = deltaPointY + this.deltaY;
        if (!pixelsPerImage) {
            return;
        }
        if (Math.abs(deltaY) >= pixelsPerImage) {
            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);
            esm.utilities.scroll(viewport, {
                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,
                volumeId,
                debounceLoading: debounceIfNotLoaded,
                loop: loop,
            });
            this.deltaY = deltaY % pixelsPerImage;
        }
        else {
            this.deltaY = deltaY;
        }
    }
    _scroll(evt) {
        const { wheel, element } = evt.detail;
        const { direction } = wheel;
        const { invert } = this.configuration;
        const { viewport } = (0,esm.getEnabledElement)(element);
        const delta = direction * (invert ? -1 : 1);
        esm.utilities.scroll(viewport, {
            delta,
            debounceLoading: this.configuration.debounceIfNotLoaded,
            loop: this.configuration.loop,
            volumeId: viewport instanceof esm.BaseVolumeViewport
                ? viewport.getVolumeId()
                : undefined,
            scrollSlabs: this.configuration.scrollSlabs,
        });
    }
    _getPixelPerImage(viewport) {
        const { element } = viewport;
        const numberOfSlices = viewport.getNumberOfSlices();
        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));
    }
}
StackScrollTool.toolName = 'StackScroll';
/* harmony default export */ const tools_StackScrollTool = ((/* unused pure expression or super */ null && (StackScrollTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js
var angleBetweenLines = __webpack_require__(25963);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js




class PlanarRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.mouseWheelCallback = (evt) => {
            const { element, wheel } = evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { invert } = this.configuration;
            const angle = wheel.direction * 10 * (invert ? -1 : 1);
            this.setAngle(viewport, angle);
        };
        this.touchDragCallback = this._dragCallback.bind(this);
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    _dragCallback(evt) {
        const { element, currentPoints, startPoints } = evt.detail;
        const currentPointWorld = currentPoints.world;
        const startPointWorld = startPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const width = element.clientWidth;
        const height = element.clientHeight;
        const centerCanvas = [width * 0.5, height * 0.5];
        const centerWorld = viewport.canvasToWorld(centerCanvas);
        let angle = (0,angleBetweenLines/* default */.A)([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);
        const { viewPlaneNormal } = camera;
        const v1 = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), centerWorld, startPointWorld);
        const v2 = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), centerWorld, currentPointWorld);
        const cross = gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), v1, v2);
        if (gl_matrix_esm/* vec3.dot */.eR.dot(viewPlaneNormal, cross) > 0) {
            angle = -angle;
        }
        if (Number.isNaN(angle)) {
            return;
        }
        this.setAngle(viewport, angle);
    }
    setAngle(viewport, angle) {
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        if (viewport instanceof esm.BaseVolumeViewport) {
            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;
            const rotMat = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
            gl_matrix_esm/* mat4.rotate */.pB.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);
            const rotatedViewUp = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(gl_matrix_esm/* vec3.create */.eR.create(), viewUp, rotMat);
            viewport.setCamera({ viewUp: rotatedViewUp });
        }
        else {
            const { rotation } = viewport.getViewPresentation();
            viewport.setViewPresentation({
                rotation: (rotation + angle + 360) % 360,
            });
        }
        viewport.render();
    }
}
PlanarRotateTool.toolName = 'PlanarRotate';
/* harmony default export */ const tools_PlanarRotateTool = ((/* unused pure expression or super */ null && (PlanarRotateTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js






class ZoomTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            zoomToCenter: false,
            minZoomScale: 0.001,
            maxZoomScale: 3000,
            pinchToZoom: true,
            pan: true,
            invert: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const camera = enabledElement.viewport.getCamera();
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), dirVec);
            this.dirVec = dirVec;
            return false;
        };
        this.preTouchStartCallback = (evt) => {
            if (!this.configuration.pinchToZoom) {
                return this.preMouseDownCallback(evt);
            }
        };
        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { parallelScale, focalPoint, position } = camera;
            const zoomScale = 5 / size[1];
            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);
            const parallelScaleToSet = (1.0 - k) * parallelScale;
            let focalPointToSet = focalPoint;
            let positionToSet = position;
            if (!this.configuration.zoomToCenter) {
                const distanceToCanvasCenter = gl_matrix_esm/* vec3.distance */.eR.distance(focalPoint, this.initialMousePosWorld);
                positionToSet = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), position, this.dirVec, -distanceToCanvasCenter * k);
                focalPointToSet = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);
            }
            const imageData = viewport.getImageData();
            let spacing = [1, 1, 1];
            let cappedParallelScale = parallelScaleToSet;
            let thresholdExceeded = false;
            if (imageData) {
                spacing = imageData.spacing;
                const { dimensions } = imageData;
                const imageWidth = dimensions[0] * spacing[0];
                const imageHeight = dimensions[1] * spacing[1];
                const canvasAspect = size[0] / size[1];
                const insetImageMultiplier = (0,esm.getConfiguration)().rendering
                    ?.useLegacyCameraFOV
                    ? 1.1
                    : 1;
                const displayArea = viewport.options?.displayArea;
                const imageAreaScaleX = displayArea?.imageArea?.[0] ?? insetImageMultiplier;
                const imageAreaScaleY = displayArea?.imageArea?.[1] ?? insetImageMultiplier;
                const scaledImageWidth = imageWidth * imageAreaScaleX;
                const scaledImageHeight = imageHeight * imageAreaScaleY;
                const scaledImageAspect = scaledImageWidth / scaledImageHeight;
                let minParallelScaleRequired;
                if (scaledImageAspect > canvasAspect) {
                    minParallelScaleRequired = (scaledImageWidth / canvasAspect) * 0.5;
                }
                else {
                    minParallelScaleRequired = scaledImageHeight * 0.5;
                }
                const { minZoomScale, maxZoomScale } = this.configuration;
                const minScaleInWorld = minParallelScaleRequired / maxZoomScale;
                const maxScaleInWorld = minParallelScaleRequired / minZoomScale;
                if (parallelScaleToSet < minScaleInWorld) {
                    cappedParallelScale = minScaleInWorld;
                    thresholdExceeded = true;
                }
                else if (parallelScaleToSet > maxScaleInWorld) {
                    cappedParallelScale = maxScaleInWorld;
                    thresholdExceeded = true;
                }
            }
            viewport.setCamera({
                parallelScale: cappedParallelScale,
                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,
                position: thresholdExceeded ? position : positionToSet,
            });
        };
        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {
            const { element, deltaPoints } = evt.detail;
            const deltaY = pinch
                ? evt.detail.deltaDistance.canvas
                : deltaPoints.canvas[1];
            const size = [element.clientWidth, element.clientHeight];
            const { position, focalPoint, viewPlaneNormal } = camera;
            const distance = Core_Math/* default.distance2BetweenPoints */.Ay.distance2BetweenPoints(position, focalPoint);
            const zoomScale = Math.sqrt(distance) / size[1];
            const directionOfProjection = [
                -viewPlaneNormal[0],
                -viewPlaneNormal[1],
                -viewPlaneNormal[2],
            ];
            const k = this.configuration.invert
                ? deltaY / zoomScale
                : deltaY * zoomScale;
            let tmp = k * directionOfProjection[0];
            position[0] += tmp;
            focalPoint[0] += tmp;
            tmp = k * directionOfProjection[1];
            position[1] += tmp;
            focalPoint[1] += tmp;
            tmp = k * directionOfProjection[2];
            position[2] += tmp;
            focalPoint[2] += tmp;
            viewport.setCamera({ position, focalPoint });
        };
        this.initialMousePosWorld = [0, 0, 0];
        this.dirVec = [0, 0, 0];
        if (this.configuration.pinchToZoom) {
            this.touchDragCallback = this._pinchCallback.bind(this);
        }
        else {
            this.touchDragCallback = this._dragCallback.bind(this);
        }
        this.mouseDragCallback = this._dragCallback.bind(this);
    }
    mouseWheelCallback(evt) {
        this._zoom(evt);
    }
    _pinchCallback(evt) {
        const pointsList = evt.detail
            .currentPointsList;
        if (pointsList.length > 1) {
            const { element, currentPoints } = evt.detail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const worldPos = currentPoints.world;
            const { focalPoint } = camera;
            this.initialMousePosWorld = worldPos;
            let dirVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);
            dirVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), dirVec);
            this.dirVec = dirVec;
            if (camera.parallelProjection) {
                this._dragParallelProjection(evt, viewport, camera, true);
            }
            else {
                this._dragPerspectiveProjection(evt, viewport, camera, true);
            }
            viewport.render();
        }
        if (this.configuration.pan) {
            this._panCallback(evt);
        }
    }
    _dragCallback(evt) {
        const { element } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        if (camera.parallelProjection) {
            this._dragParallelProjection(evt, viewport, camera);
        }
        else {
            this._dragPerspectiveProjection(evt, viewport, camera);
        }
        viewport.render();
    }
    _zoom(evt) {
        const { element, points } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const wheelData = evt.detail.wheel;
        const direction = wheelData.direction;
        const eventDetails = {
            detail: {
                element,
                eventName: enums.Events.MOUSE_WHEEL,
                renderingEngineId: enabledElement.renderingEngineId,
                viewportId: viewport.id,
                camera: {},
                deltaPoints: {
                    page: points.page,
                    client: points.client,
                    world: points.world,
                    canvas: [0, -direction * 5],
                },
                startPoints: points,
                lastPoints: points,
                currentPoints: points,
            },
        };
        if (viewport.type === esm.Enums.ViewportType.STACK) {
            this.preMouseDownCallback(eventDetails);
        }
        this._dragCallback(eventDetails);
    }
    _panCallback(evt) {
        const { element, deltaPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const deltaPointsWorld = deltaPoints.world;
        const camera = enabledElement.viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        enabledElement.viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        enabledElement.viewport.render();
    }
}
ZoomTool.toolName = 'Zoom';
/* harmony default export */ const tools_ZoomTool = ((/* unused pure expression or super */ null && (ZoomTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js





class MIPJumpToClickTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            targetViewportIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseClickCallback(evt) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const volumeId = viewport.getVolumeId();
        if (!volumeId) {
            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);
        }
        let maxIntensity = -Infinity;
        const maxFn = (intensity, point) => {
            if (intensity > maxIntensity) {
                maxIntensity = intensity;
                return point;
            }
        };
        const brightestPoint = (0,planar.getPointInLineOfSightWithCriteria)(viewport, currentPoints.world, volumeId, maxFn);
        if (!brightestPoint || !brightestPoint.length) {
            return;
        }
        const { targetViewportIds, toolGroupId } = this.configuration;
        const viewports = renderingEngine.getViewports().filter((vp) => {
            if (targetViewportIds?.indexOf(vp.id) >= 0) {
                return true;
            }
            const foundToolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(vp.id, renderingEngine.id);
            if (toolGroupId && toolGroupId === foundToolGroup?.id) {
                return true;
            }
            return false;
        });
        viewports.forEach((viewport) => {
            if (viewport instanceof esm.VolumeViewport) {
                viewport.jumpToWorld(brightestPoint);
            }
            else {
                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');
            }
        });
    }
}
MIPJumpToClickTool.toolName = 'MIPJumpToClickTool';
/* harmony default export */ const tools_MIPJumpToClickTool = ((/* unused pure expression or super */ null && (MIPJumpToClickTool)));

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var MatrixBuilder = __webpack_require__(89265);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js
















const { RENDERING_DEFAULTS: CrosshairsTool_RENDERING_DEFAULTS } = esm.CONSTANTS;
function CrosshairsTool_defaultReferenceLineColor() {
    return 'rgb(0, 200, 0)';
}
function CrosshairsTool_defaultReferenceLineControllable() {
    return true;
}
function defaultReferenceLineDraggableRotatable() {
    return true;
}
function defaultReferenceLineSlabThicknessControlsOn() {
    return true;
}
const CrosshairsTool_OPERATION = {
    DRAG: 1,
    ROTATE: 2,
    SLAB: 3,
};
class CrosshairsTool extends base/* AnnotationTool */.EC {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse'],
        configuration: {
            shadow: true,
            viewportIndicators: false,
            viewportIndicatorsConfig: {
                radius: 5,
                x: null,
                y: null,
            },
            autoPan: {
                enabled: false,
                panSize: 10,
            },
            handleRadius: 3,
            enableHDPIHandles: false,
            referenceLinesCenterGapRadius: 20,
            referenceLinesCenterGapRatio: null,
            filterActorUIDsToSetSlabThickness: [],
            slabThicknessBlendMode: esm.Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,
            mobile: {
                enabled: false,
                opacity: 0.8,
                handleRadius: 9,
                referenceLinesCenterGapRatio: 0.05,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.toolCenter = [0, 0, 0];
        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { FrameOfReferenceUID, viewport } = enabledElement;
            const { element } = viewport;
            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();
            let annotations = this._getAnnotations(enabledElement);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (annotations?.length) {
                (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
            }
            const annotation = {
                highlighted: false,
                metadata: {
                    cameraPosition: [...position],
                    cameraFocalPoint: [...focalPoint],
                    FrameOfReferenceUID,
                    toolName: this.getToolName(),
                },
                data: {
                    handles: {
                        rotationPoints: [],
                        slabThicknessPoints: [],
                        toolCenter: this.toolCenter,
                    },
                    activeOperation: null,
                    activeViewportIds: [],
                    viewportId,
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            return {
                normal: viewPlaneNormal,
                point: viewport.canvasToWorld([
                    viewport.canvas.clientWidth / 2,
                    viewport.canvas.clientHeight / 2,
                ]),
            };
        };
        this._getViewportsInfo = () => {
            const viewports = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resetCrosshairs = () => {
            const viewportsInfo = this._getViewportsInfo();
            for (const viewportInfo of viewportsInfo) {
                const { viewportId, renderingEngineId } = viewportInfo;
                const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const viewport = enabledElement.viewport;
                const resetPan = true;
                const resetZoom = true;
                const resetToCenter = true;
                const resetRotation = true;
                const suppressEvents = true;
                viewport.resetCamera({
                    resetPan,
                    resetZoom,
                    resetToCenter,
                    resetRotation,
                    suppressEvents,
                });
                viewport.resetSlabThickness();
                const { element } = viewport;
                let annotations = this._getAnnotations(enabledElement);
                annotations = this.filterInteractableAnnotationsForElement(element, annotations);
                if (annotations.length) {
                    (0,annotationState.removeAnnotation)(annotations[0].annotationUID);
                }
                viewport.render();
            }
            this._computeToolCenter(viewportsInfo);
        };
        this.computeToolCenter = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._computeToolCenter = (viewportsInfo) => {
            if (!viewportsInfo.length || viewportsInfo.length === 1) {
                console.warn('For crosshairs to operate, at least two viewports must be given.');
                return;
            }
            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;
            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);
            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);
            let normal3 = [0, 0, 0];
            let point3 = gl_matrix_esm/* vec3.create */.eR.create();
            if (thirdViewport) {
                ({ normal: normal3, point: point3 } =
                    this.initializeViewport(thirdViewport));
            }
            else {
                gl_matrix_esm/* vec3.add */.eR.add(point3, point1, point2);
                gl_matrix_esm/* vec3.scale */.eR.scale(point3, point3, 0.5);
                gl_matrix_esm/* vec3.cross */.eR.cross(normal3, normal1, normal2);
            }
            const firstPlane = esm.utilities.planar.planeEquation(normal1, point1);
            const secondPlane = esm.utilities.planar.planeEquation(normal2, point2);
            const thirdPlane = esm.utilities.planar.planeEquation(normal3, point3);
            const toolCenter = esm.utilities.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);
            this.setToolCenter(toolCenter);
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const jumpWorld = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this._jump(enabledElement, jumpWorld);
            const annotations = this._getAnnotations(enabledElement);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);
            const { data } = filteredAnnotations[0];
            const { rotationPoints } = data.handles;
            const viewportIdArray = [];
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                if (!viewportControllable || !viewportDraggableRotatable) {
                    continue;
                }
                viewportIdArray.push(otherViewport.id);
                i++;
            }
            data.activeViewportIds = [...viewportIdArray];
            data.handles.activeOperation = CrosshairsTool_OPERATION.DRAG;
            evt.preventDefault();
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            return filteredAnnotations[0];
        };
        this.cancel = () => {
            console.log('Not implemented yet');
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const viewport = enabledElement.viewport;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const currentCamera = viewport.getCamera();
            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;
            const deltaCameraPosition = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);
            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);
            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];
            viewportAnnotation.metadata.cameraFocalPoint = [
                ...currentCamera.focalPoint,
            ];
            const viewportControllable = this._getReferenceLineControllable(viewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);
            if (!esm.utilities.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&
                viewportControllable &&
                viewportDraggableRotatable) {
                let isRotation = false;
                const cameraModifiedSameForPosAndFocalPoint = esm.utilities.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);
                if (!cameraModifiedSameForPosAndFocalPoint) {
                    isRotation = true;
                }
                const cameraModifiedInPlane = Math.abs(Core_Math/* default.dot */.Ay.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;
                if (!isRotation && !cameraModifiedInPlane) {
                    this.toolCenter[0] += deltaCameraPosition[0];
                    this.toolCenter[1] += deltaCameraPosition[1];
                    this.toolCenter[2] += deltaCameraPosition[2];
                    (0,esm.triggerEvent)(esm.eventTarget, enums.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                        toolGroupId: this.toolGroupId,
                        toolCenter: this.toolCenter,
                    });
                }
            }
            if (this.configuration.autoPan?.enabled) {
                const toolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(viewport.id, renderingEngine.id);
                const otherViewportIds = toolGroup
                    .getViewportIds()
                    .filter((id) => id !== viewport.id);
                otherViewportIds.forEach((viewportId) => {
                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);
                });
            }
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.onResetCamera = (evt) => {
            this.resetCrosshairs();
        };
        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {
            const { element, currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            let imageNeedsUpdate = false;
            for (let i = 0; i < filteredToolAnnotations.length; i++) {
                const annotation = filteredToolAnnotations[i];
                if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
                    continue;
                }
                const { data, highlighted } = annotation;
                if (!data.handles) {
                    continue;
                }
                const previousActiveOperation = data.handles.activeOperation;
                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0
                    ? [...data.activeViewportIds]
                    : [];
                data.activeViewportIds = [];
                data.handles.activeOperation = null;
                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);
                let near = false;
                if (handleNearImagePoint) {
                    near = true;
                }
                else {
                    near = this._pointNearTool(element, annotation, canvasCoords, 6);
                }
                const nearToolAndNotMarkedActive = near && !highlighted;
                const notNearToolAndMarkedActive = !near && highlighted;
                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {
                    annotation.highlighted = !highlighted;
                    imageNeedsUpdate = true;
                }
                else if (data.handles.activeOperation !== previousActiveOperation ||
                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {
                    imageNeedsUpdate = true;
                }
            }
            return imageNeedsUpdate;
        };
        this.filterInteractableAnnotationsForElement = (element, annotations) => {
            if (!annotations || !annotations.length) {
                return [];
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewportId } = enabledElement;
            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);
            return viewportUIDSpecificCrosshairs;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, renderingEngine } = enabledElement;
            const { element } = viewport;
            const annotations = this._getAnnotations(enabledElement);
            const camera = viewport.getCamera();
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!annotations?.length || !viewportAnnotation?.data) {
                return renderStatus;
            }
            const annotationUID = viewportAnnotation.annotationUID;
            const { clientWidth, clientHeight } = viewport.canvas;
            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);
            const data = viewportAnnotation.data;
            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);
            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);
            const referenceLines = [];
            const canvasBox = [0, 0, clientWidth, clientHeight];
            otherViewportAnnotations.forEach((annotation) => {
                const { data } = annotation;
                data.handles.toolCenter = this.toolCenter;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                const { clientWidth, clientHeight } = otherViewport.canvas;
                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
                const otherCanvasCenter = [
                    clientWidth * 0.5,
                    clientHeight * 0.5,
                ];
                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);
                const direction = [0, 0, 0];
                Core_Math/* default.cross */.Ay.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);
                Core_Math/* default.normalize */.Ay.normalize(direction);
                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(direction, otherCanvasDiagonalLength);
                const pointWorld0 = [0, 0, 0];
                Core_Math/* default.add */.Ay.add(otherViewportCenterWorld, direction, pointWorld0);
                const pointWorld1 = [0, 0, 0];
                Core_Math/* default.subtract */.Ay.subtract(otherViewportCenterWorld, direction, pointWorld1);
                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);
                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);
                const canvasUnitVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);
                gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
                const canvasVectorFromCenterLong = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);
                const canvasVectorFromCenterMid = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);
                const canvasVectorFromCenterShort = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);
                const canvasVectorFromCenterStart = gl_matrix_esm/* vec2.create */.Zc.create();
                const mobileConfig = this.configuration.mobile;
                const { referenceLinesCenterGapRatio } = mobileConfig?.enabled
                    ? mobileConfig
                    : this.configuration;
                const centerGap = referenceLinesCenterGapRatio > 0
                    ? canvasMinDimensionLength * referenceLinesCenterGapRatio
                    : this.configuration.referenceLinesCenterGapRadius;
                gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);
                const refLinePointOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointThree = gl_matrix_esm/* vec2.create */.Zc.create();
                const refLinePointFour = gl_matrix_esm/* vec2.create */.Zc.create();
                let refLinesCenter = gl_matrix_esm/* vec2.clone */.Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable || !otherViewportControllable) {
                    refLinesCenter = gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                }
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix_esm/* vec2.add */.Zc.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);
                (0,liangBarksyClip/* default */.A)(refLinePointOne, refLinePointTwo, canvasBox);
                (0,liangBarksyClip/* default */.A)(refLinePointThree, refLinePointFour, canvasBox);
                const rotHandleOne = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);
                const rotHandleTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);
                let stHandlesCenterCanvas = gl_matrix_esm/* vec2.clone */.Zc.clone(crosshairCenterCanvas);
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterCanvas = gl_matrix_esm/* vec2.clone */.Zc.clone(otherViewportCenterCanvas);
                }
                let stHandlesCenterWorld = [...this.toolCenter];
                if (!otherViewportDraggableRotatable &&
                    otherViewportSlabThicknessControlsOn) {
                    stHandlesCenterWorld = [...otherViewportCenterWorld];
                }
                const worldUnitVectorFromCenter = [0, 0, 0];
                Core_Math/* default.subtract */.Ay.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);
                Core_Math/* default.normalize */.Ay.normalize(worldUnitVectorFromCenter);
                const { viewPlaneNormal } = camera;
                const { matrix } = MatrixBuilder/* default */.A
                    .buildFromDegree()
                    .rotate(90, viewPlaneNormal);
                const worldUnitOrthoVectorFromCenter = [0, 0, 0];
                gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);
                const slabThicknessValue = otherViewport.getSlabThickness();
                const worldOrthoVectorFromCenter = [
                    ...worldUnitOrthoVectorFromCenter,
                ];
                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);
                const worldVerticalRefPoint = [0, 0, 0];
                Core_Math/* default.add */.Ay.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);
                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);
                const canvasOrthoVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);
                const stLinePointOne = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);
                const stLinePointTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);
                (0,liangBarksyClip/* default */.A)(stLinePointOne, stLinePointTwo, canvasBox);
                const stLinePointThree = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.add */.Zc.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);
                const stLinePointFour = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);
                (0,liangBarksyClip/* default */.A)(stLinePointThree, stLinePointFour, canvasBox);
                const stHandleOne = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleTwo = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleThree = gl_matrix_esm/* vec2.create */.Zc.create();
                const stHandleFour = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);
                gl_matrix_esm/* vec2.add */.Zc.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);
                gl_matrix_esm/* vec2.subtract */.Zc.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);
                referenceLines.push([
                    otherViewport,
                    refLinePointOne,
                    refLinePointTwo,
                    refLinePointThree,
                    refLinePointFour,
                    stLinePointOne,
                    stLinePointTwo,
                    stLinePointThree,
                    stLinePointFour,
                    rotHandleOne,
                    rotHandleTwo,
                    stHandleOne,
                    stHandleTwo,
                    stHandleThree,
                    stHandleFour,
                ]);
            });
            const newRtpoints = [];
            const newStpoints = [];
            const viewportColor = this._getReferenceLineColor(viewport.id);
            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
            referenceLines.forEach((line, lineIndex) => {
                const otherViewport = line[0];
                const viewportColor = this._getReferenceLineColor(otherViewport.id);
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||
                    this.configuration.mobile?.enabled;
                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);
                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                let lineWidth = 1;
                const lineActive = data.handles.activeOperation !== null &&
                    data.handles.activeOperation === CrosshairsTool_OPERATION.DRAG &&
                    selectedViewportId;
                if (lineActive) {
                    lineWidth = 2.5;
                }
                let lineUID = `${lineIndex}`;
                if (viewportControllable && viewportDraggableRotatable) {
                    lineUID = `${lineIndex}One`;
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {
                        color,
                        lineWidth,
                    });
                    lineUID = `${lineIndex}Two`;
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {
                        color,
                        lineWidth,
                    });
                }
                else {
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {
                        color,
                        lineWidth,
                    });
                }
                if (viewportControllable) {
                    color =
                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';
                    const rotHandlesActive = data.handles.activeOperation === CrosshairsTool_OPERATION.ROTATE;
                    const rotationHandles = [line[9], line[10]];
                    const rotHandleWorldOne = [
                        viewport.canvasToWorld(line[9]),
                        otherViewport,
                        line[1],
                        line[2],
                    ];
                    const rotHandleWorldTwo = [
                        viewport.canvasToWorld(line[10]),
                        otherViewport,
                        line[3],
                        line[4],
                    ];
                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);
                    const slabThicknessHandlesActive = data.handles.activeOperation === CrosshairsTool_OPERATION.SLAB;
                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];
                    const slabThicknessHandleWorldOne = [
                        viewport.canvasToWorld(line[11]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldTwo = [
                        viewport.canvasToWorld(line[12]),
                        otherViewport,
                        line[5],
                        line[6],
                    ];
                    const slabThicknessHandleWorldThree = [
                        viewport.canvasToWorld(line[13]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    const slabThicknessHandleWorldFour = [
                        viewport.canvasToWorld(line[14]),
                        otherViewport,
                        line[7],
                        line[8],
                    ];
                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);
                    let handleRadius = this.configuration.handleRadius *
                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);
                    let opacity = 1;
                    if (this.configuration.mobile?.enabled) {
                        handleRadius = this.configuration.mobile.handleRadius;
                        opacity = this.configuration.mobile.opacity;
                    }
                    if ((lineActive || this.configuration.mobile?.enabled) &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable &&
                        viewportSlabThicknessControlsOn) {
                        let handleUID = `${lineIndex}One`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                        handleUID = `${lineIndex}Two`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (lineActive &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'circle',
                        });
                    }
                    else if (selectedViewportId &&
                        !rotHandlesActive &&
                        !slabThicknessHandlesActive &&
                        viewportSlabThicknessControlsOn) {
                        const handleUID = `${lineIndex}`;
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            opacity,
                            type: 'rect',
                        });
                    }
                    else if (rotHandlesActive && viewportDraggableRotatable) {
                        const handleUID = `${lineIndex}`;
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'circle',
                        });
                    }
                    else if (slabThicknessHandlesActive &&
                        selectedViewportId &&
                        viewportSlabThicknessControlsOn) {
                        const handleRadius = this.configuration.handleRadius *
                            (this.configuration.enableHDPIHandles
                                ? window.devicePixelRatio
                                : 1);
                        (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {
                            color,
                            handleRadius,
                            fill: color,
                            type: 'rect',
                        });
                    }
                    const slabThicknessValue = otherViewport.getSlabThickness();
                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {
                        lineUID = `${lineIndex}STOne`;
                        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {
                            color,
                            width: 1,
                            lineDash: [2, 3],
                        });
                        lineUID = `${lineIndex}STTwo`;
                        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {
                            color,
                            width: line,
                            lineDash: [2, 3],
                        });
                    }
                }
            });
            renderStatus = true;
            data.handles.rotationPoints = newRtpoints;
            data.handles.slabThicknessPoints = newStpoints;
            if (this.configuration.viewportIndicators) {
                const { viewportIndicatorsConfig } = this.configuration;
                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;
                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;
                const referenceColorCoordinates = [
                    clientWidth * xOffset,
                    clientHeight * yOffset,
                ];
                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });
            }
            return renderStatus;
        };
        this._getAnnotations = (enabledElement) => {
            const { viewport } = enabledElement;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element) || [];
            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);
            const toolGroupAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                return viewportIds.includes(data.viewportId);
            });
            return toolGroupAnnotations;
        };
        this._onNewVolume = () => {
            const viewportsInfo = this._getViewportsInfo();
            this._computeToolCenter(viewportsInfo);
        };
        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {
            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {
                return false;
            }
            viewportIdArrayOne.forEach((id) => {
                let itemFound = false;
                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {
                    if (id === viewportIdArrayTwo[i]) {
                        itemFound = true;
                        break;
                    }
                }
                if (itemFound === false) {
                    return false;
                }
            });
            return true;
        };
        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {
            const { viewportId, renderingEngine, viewport } = enabledElement;
            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);
            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const { viewPlaneNormal, position } = camera;
            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const targetViewport = renderingEngine.getViewport(viewportId);
                const cameraOfTarget = targetViewport.getCamera();
                return !(esm.utilities.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && esm.utilities.isEqual(cameraOfTarget.position, position, 1));
            });
            return viewportsWithDifferentCameras;
        };
        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {
            const { renderingEngine } = enabledElement;
            const { data } = referenceAnnotation;
            const viewport = renderingEngine.getViewport(data.viewportId);
            const linkedViewportAnnotations = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return otherViewportControllable === true;
            });
            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {
                return [];
            }
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            Core_Math/* default.normalize */.Ay.normalize(viewPlaneNormal);
            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                return (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&
                    esm.utilities.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));
            });
            return otherViewportsAnnotationsWithSameCameraDirection;
        };
        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {
            const { renderingEngine, viewport } = enabledElement;
            const camera = viewport.getCamera();
            const viewPlaneNormal = camera.viewPlaneNormal;
            Core_Math/* default.normalize */.Ay.normalize(viewPlaneNormal);
            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable === true);
            });
            const otherViewportsAnnotationsWithUniqueCameras = [];
            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                return (viewport !== otherViewport &&
                    otherViewportControllable !== true);
            });
            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {
                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            for (let i = 0; i < otherViewportAnnotations.length; ++i) {
                const annotation = otherViewportAnnotations[i];
                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {
                    continue;
                }
                const { viewportId } = annotation.data;
                const otherViewport = renderingEngine.getViewport(viewportId);
                const otherCamera = otherViewport.getCamera();
                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;
                Core_Math/* default.normalize */.Ay.normalize(otherViewPlaneNormal);
                if (esm.utilities.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||
                    esm.utilities.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {
                    continue;
                }
                let cameraFound = false;
                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {
                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];
                    const { viewportId } = annotation.data;
                    const stockedViewport = renderingEngine.getViewport(viewportId);
                    const cameraOfStocked = stockedViewport.getCamera();
                    if (esm.utilities.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&
                        esm.utilities.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {
                        cameraFound = true;
                    }
                }
                if (!cameraFound) {
                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);
                }
            }
            return otherViewportsAnnotationsWithUniqueCameras;
        };
        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {
            const volumeIds = viewport.getAllVolumeIds();
            const otherVolumeIds = otherViewport.getAllVolumeIds();
            return (volumeIds.length === otherVolumeIds.length &&
                volumeIds.every((id) => otherVolumeIds.includes(id)));
        };
        this._jump = (enabledElement, jumpWorld) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            const { viewport, renderingEngine } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const delta = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(jumpWorld, this.toolCenter, delta);
            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                const { data } = annotation;
                const otherViewport = renderingEngine.getViewport(data.viewportId);
                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);
                return (this._getReferenceLineControllable(otherViewport.id) &&
                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&
                    sameScene);
            });
            if (viewportsAnnotationsToUpdate.length === 0) {
                store_state/* state */.wk.isInteractingWithTool = false;
                return false;
            }
            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            store_state/* state */.wk.isInteractingWithTool = false;
            return true;
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = !this.configuration.mobile?.enabled;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            this.editData.annotation.data.handles.activeOperation = null;
            this.editData.annotation.data.activeViewportIds = [];
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            const requireSameOrientation = false;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), requireSameOrientation);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const delta = eventDetail.deltaPoints.world;
            if (Math.abs(delta[0]) < 1e-3 &&
                Math.abs(delta[1]) < 1e-3 &&
                Math.abs(delta[2]) < 1e-3) {
                return;
            }
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const annotations = this._getAnnotations(enabledElement);
            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const viewportAnnotation = filteredToolAnnotations[0];
            if (!viewportAnnotation) {
                return;
            }
            const { handles } = viewportAnnotation.data;
            const { currentPoints } = evt.detail;
            const canvasCoords = currentPoints.canvas;
            if (handles.activeOperation === CrosshairsTool_OPERATION.DRAG) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);
            }
            else if (handles.activeOperation === CrosshairsTool_OPERATION.ROTATE) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportDraggableRotatable === true);
                });
                const dir1 = gl_matrix_esm/* vec2.create */.Zc.create();
                const dir2 = gl_matrix_esm/* vec2.create */.Zc.create();
                const center = [
                    this.toolCenter[0],
                    this.toolCenter[1],
                    this.toolCenter[2],
                ];
                const centerCanvas = viewport.worldToCanvas(center);
                const finalPointCanvas = eventDetail.currentPoints.canvas;
                const originalPointCanvas = gl_matrix_esm/* vec2.create */.Zc.create();
                gl_matrix_esm/* vec2.sub */.Zc.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);
                gl_matrix_esm/* vec2.sub */.Zc.sub(dir1, originalPointCanvas, centerCanvas);
                gl_matrix_esm/* vec2.sub */.Zc.sub(dir2, finalPointCanvas, centerCanvas);
                let angle = gl_matrix_esm/* vec2.angle */.Zc.angle(dir1, dir2);
                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {
                    angle *= -1;
                }
                angle = Math.round(angle * 100) / 100;
                const rotationAxis = viewport.getCamera().viewPlaneNormal;
                const { matrix } = MatrixBuilder/* default */.A
                    .buildFromRadian()
                    .translate(center[0], center[1], center[2])
                    .rotate(angle, rotationAxis)
                    .translate(-center[0], -center[1], -center[2]);
                const otherViewportsIds = [];
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    data.handles.toolCenter = center;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const { viewUp, position, focalPoint } = camera;
                    viewUp[0] += position[0];
                    viewUp[1] += position[1];
                    viewUp[2] += position[2];
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(focalPoint, focalPoint, matrix);
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(position, position, matrix);
                    gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(viewUp, viewUp, matrix);
                    viewUp[0] -= position[0];
                    viewUp[1] -= position[1];
                    viewUp[2] -= position[2];
                    otherViewport.setCamera({
                        position,
                        viewUp,
                        focalPoint,
                    });
                    otherViewportsIds.push(otherViewport.id);
                });
                renderingEngine.renderViewports(otherViewportsIds);
            }
            else if (handles.activeOperation === CrosshairsTool_OPERATION.SLAB) {
                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);
                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);
                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
                    return (otherViewportControllable === true &&
                        otherViewportSlabThicknessControlsOn === true &&
                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));
                });
                if (referenceAnnotations.length === 0) {
                    return;
                }
                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);
                const viewportsIds = [];
                viewportsIds.push(viewport.id);
                viewportsAnnotationsToUpdate.forEach((annotation) => {
                    const { data } = annotation;
                    const otherViewport = renderingEngine.getViewport(data.viewportId);
                    const camera = otherViewport.getCamera();
                    const normal = camera.viewPlaneNormal;
                    const dotProd = Core_Math/* default.dot */.Ay.dot(delta, normal);
                    const projectedDelta = [...normal];
                    Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDelta, dotProd);
                    if (Math.abs(projectedDelta[0]) > 1e-3 ||
                        Math.abs(projectedDelta[1]) > 1e-3 ||
                        Math.abs(projectedDelta[2]) > 1e-3) {
                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +
                            projectedDelta[1] * projectedDelta[1] +
                            projectedDelta[2] * projectedDelta[2]);
                        const currentPoint = eventDetail.lastPoints.world;
                        const direction = [0, 0, 0];
                        const currentCenter = [
                            this.toolCenter[0],
                            this.toolCenter[1],
                            this.toolCenter[2],
                        ];
                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
                        if (!viewportDraggableRotatable) {
                            const { rotationPoints } = (this.editData.annotation.data).handles;
                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);
                            if (otherViewportRotationPoints.length === 2) {
                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);
                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);
                                Core_Math/* default.add */.Ay.add(point1, point2, currentCenter);
                                Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(currentCenter, 0.5);
                            }
                        }
                        Core_Math/* default.subtract */.Ay.subtract(currentPoint, currentCenter, direction);
                        const dotProdDirection = Core_Math/* default.dot */.Ay.dot(direction, normal);
                        const projectedDirection = [...normal];
                        Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDirection, dotProdDirection);
                        const normalizedProjectedDirection = [
                            projectedDirection[0],
                            projectedDirection[1],
                            projectedDirection[2],
                        ];
                        gl_matrix_esm/* vec3.normalize */.eR.normalize(normalizedProjectedDirection, normalizedProjectedDirection);
                        const normalizedProjectedDelta = [
                            projectedDelta[0],
                            projectedDelta[1],
                            projectedDelta[2],
                        ];
                        gl_matrix_esm/* vec3.normalize */.eR.normalize(normalizedProjectedDelta, normalizedProjectedDelta);
                        let slabThicknessValue = otherViewport.getSlabThickness();
                        if (esm.utilities.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {
                            slabThicknessValue -= mod;
                        }
                        else {
                            slabThicknessValue += mod;
                        }
                        slabThicknessValue = Math.abs(slabThicknessValue);
                        slabThicknessValue = Math.max(CrosshairsTool_RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);
                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);
                        if (near) {
                            slabThicknessValue = CrosshairsTool_RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                        }
                        const toolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(otherViewport.id, renderingEngine.id);
                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());
                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);
                        viewportsIds.push(otherViewport.id);
                    }
                });
                renderingEngine.renderViewports(viewportsIds);
            }
        };
        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {
            const { data } = annotation;
            const { rotationPoints } = data.handles;
            for (let i = 0; i < rotationPoints.length - 1; ++i) {
                const otherViewport = rotationPoints[i][1];
                if (otherViewport.id !== lineViewport.id) {
                    continue;
                }
                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
                if (!viewportControllable) {
                    continue;
                }
                const lineSegment1 = {
                    start: {
                        x: rotationPoints[i][2][0],
                        y: rotationPoints[i][2][1],
                    },
                    end: {
                        x: rotationPoints[i][3][0],
                        y: rotationPoints[i][3][1],
                    },
                };
                const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
                const lineSegment2 = {
                    start: {
                        x: rotationPoints[i + 1][2][0],
                        y: rotationPoints[i + 1][2][1],
                    },
                    end: {
                        x: rotationPoints[i + 1][3][0],
                        y: rotationPoints[i + 1][3][1],
                    },
                };
                const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                    return true;
                }
                i++;
            }
            return false;
        };
        this._getReferenceLineColor =
            toolProps.configuration?.getReferenceLineColor ||
                CrosshairsTool_defaultReferenceLineColor;
        this._getReferenceLineControllable =
            toolProps.configuration?.getReferenceLineControllable ||
                CrosshairsTool_defaultReferenceLineControllable;
        this._getReferenceLineDraggableRotatable =
            toolProps.configuration?.getReferenceLineDraggableRotatable ||
                defaultReferenceLineDraggableRotatable;
        this._getReferenceLineSlabThicknessControlsOn =
            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||
                defaultReferenceLineSlabThicknessControlsOn;
    }
    onSetToolActive() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        this._subscribeToViewportNewVolumeSet(viewportsInfo);
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolPassive() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolEnabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._computeToolCenter(viewportsInfo);
    }
    onSetToolDisabled() {
        const viewportsInfo = this._getViewportsInfo();
        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);
        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const annotations = this._getAnnotations(enabledElement);
            if (annotations?.length) {
                annotations.forEach((annotation) => {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                });
            }
        });
    }
    setToolCenter(toolCenter, suppressEvents = false) {
        this.toolCenter = toolCenter;
        const viewportsInfo = this._getViewportsInfo();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        if (!suppressEvents) {
            (0,esm.triggerEvent)(esm.eventTarget, enums.Events.CROSSHAIR_TOOL_CENTER_CHANGED, {
                toolGroupId: this.toolGroupId,
                toolCenter: this.toolCenter,
            });
        }
    }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);
        if (point !== null) {
            return point;
        }
    }
    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {
        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _subscribeToViewportNewVolumeSet(viewports) {
        viewports.forEach(({ viewportId, renderingEngineId }) => {
            const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
            const { element } = viewport;
            element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);
        });
    }
    _autoPanViewportIfNecessary(viewportId, renderingEngine) {
        const viewport = renderingEngine.getViewport(viewportId);
        const { clientWidth, clientHeight } = viewport.canvas;
        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);
        const pan = this.configuration.autoPan.panSize;
        const visiblePointCanvas = [
            toolCenterCanvas[0],
            toolCenterCanvas[1],
        ];
        if (toolCenterCanvas[0] < 0) {
            visiblePointCanvas[0] = pan;
        }
        else if (toolCenterCanvas[0] > clientWidth) {
            visiblePointCanvas[0] = clientWidth - pan;
        }
        if (toolCenterCanvas[1] < 0) {
            visiblePointCanvas[1] = pan;
        }
        else if (toolCenterCanvas[1] > clientHeight) {
            visiblePointCanvas[1] = clientHeight - pan;
        }
        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&
            visiblePointCanvas[1] === toolCenterCanvas[1]) {
            return;
        }
        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);
        const deltaPointsWorld = [
            visiblePointWorld[0] - this.toolCenter[0],
            visiblePointWorld[1] - this.toolCenter[1],
            visiblePointWorld[2] - this.toolCenter[2],
        ];
        const camera = viewport.getCamera();
        const { focalPoint, position } = camera;
        const updatedPosition = [
            position[0] - deltaPointsWorld[0],
            position[1] - deltaPointsWorld[1],
            position[2] - deltaPointsWorld[2],
        ];
        const updatedFocalPoint = [
            focalPoint[0] - deltaPointsWorld[0],
            focalPoint[1] - deltaPointsWorld[1],
            focalPoint[2] - deltaPointsWorld[2],
        ];
        viewport.setCamera({
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
        viewport.render();
    }
    setSlabThickness(viewport, slabThickness) {
        let actorUIDs;
        const { filterActorUIDsToSetSlabThickness } = this.configuration;
        if (filterActorUIDsToSetSlabThickness &&
            filterActorUIDsToSetSlabThickness.length > 0) {
            actorUIDs = filterActorUIDsToSetSlabThickness;
        }
        let blendModeToUse = this.configuration.slabThicknessBlendMode;
        if (slabThickness === CrosshairsTool_RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {
            blendModeToUse = esm.Enums.BlendModes.COMPOSITE;
        }
        const immediate = false;
        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);
        viewport.setSlabThickness(slabThickness, actorUIDs);
    }
    _isClockWise(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;
    }
    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {
        viewportsAnnotationsToUpdate.forEach((annotation) => {
            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);
        });
    }
    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {
        const { data } = annotation;
        const viewport = renderingEngine.getViewport(data.viewportId);
        const camera = viewport.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = Core_Math/* default.dot */.Ay.dot(delta, normal);
        const projectedDelta = [...normal];
        Core_Math/* default.multiplyScalar */.Ay.multiplyScalar(projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            Core_Math/* default.add */.Ay.add(camera.focalPoint, projectedDelta, newFocalPoint);
            Core_Math/* default.add */.Ay.add(camera.position, projectedDelta, newPosition);
            viewport.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            viewport.render();
        }
    }
    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        for (let i = 0; i < rotationPoints.length; i++) {
            const point = rotationPoints[i][0];
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportDraggableRotatable) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = CrosshairsTool_OPERATION.ROTATE;
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {
        const { data } = annotation;
        const { slabThicknessPoints } = data.handles;
        for (let i = 0; i < slabThicknessPoints.length; i++) {
            const point = slabThicknessPoints[i][0];
            const otherViewport = slabThicknessPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            if (!viewportControllable) {
                continue;
            }
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportSlabThicknessControlsOn) {
                continue;
            }
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            if (gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {
                data.handles.activeOperation = CrosshairsTool_OPERATION.SLAB;
                data.activeViewportIds = [otherViewport.id];
                this.editData = {
                    annotation,
                };
                return point;
            }
        }
        return null;
    }
    _pointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { clientWidth, clientHeight } = viewport.canvas;
        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);
        const { data } = annotation;
        const { rotationPoints } = data.handles;
        const { slabThicknessPoints } = data.handles;
        const viewportIdArray = [];
        for (let i = 0; i < rotationPoints.length - 1; ++i) {
            const otherViewport = rotationPoints[i][1];
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);
            if (!viewportControllable || !viewportDraggableRotatable) {
                continue;
            }
            const lineSegment1 = {
                start: {
                    x: rotationPoints[i][2][0],
                    y: rotationPoints[i][2][1],
                },
                end: {
                    x: rotationPoints[i][3][0],
                    y: rotationPoints[i][3][1],
                },
            };
            const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: rotationPoints[i + 1][2][0],
                    y: rotationPoints[i + 1][2][1],
                },
                end: {
                    x: rotationPoints[i + 1][3][0],
                    y: rotationPoints[i + 1][3][1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = CrosshairsTool_OPERATION.DRAG;
            }
            i++;
        }
        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {
            const otherViewport = slabThicknessPoints[i][1];
            if (viewportIdArray.find((id) => id === otherViewport.id)) {
                continue;
            }
            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);
            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);
            if (!viewportControllable || !viewportSlabThicknessControlsOn) {
                continue;
            }
            const stPointLineCanvas1 = slabThicknessPoints[i][2];
            const stPointLineCanvas2 = slabThicknessPoints[i][3];
            const centerCanvas = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.add */.Zc.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);
            gl_matrix_esm/* vec2.scale */.Zc.scale(centerCanvas, centerCanvas, 0.5);
            const canvasUnitVectorFromCenter = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.subtract */.Zc.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);
            gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);
            const canvasVectorFromCenterStart = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.scale */.Zc.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);
            const stPointLineCanvas1Start = gl_matrix_esm/* vec2.create */.Zc.create();
            const stPointLineCanvas2Start = gl_matrix_esm/* vec2.create */.Zc.create();
            gl_matrix_esm/* vec2.add */.Zc.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);
            gl_matrix_esm/* vec2.subtract */.Zc.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);
            const lineSegment1 = {
                start: {
                    x: stPointLineCanvas1Start[0],
                    y: stPointLineCanvas1Start[1],
                },
                end: {
                    x: stPointLineCanvas1[0],
                    y: stPointLineCanvas1[1],
                },
            };
            const distanceToPoint1 = math_line.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const lineSegment2 = {
                start: {
                    x: stPointLineCanvas2Start[0],
                    y: stPointLineCanvas2Start[1],
                },
                end: {
                    x: stPointLineCanvas2[0],
                    y: stPointLineCanvas2[1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {
                viewportIdArray.push(otherViewport.id);
                data.handles.activeOperation = null;
            }
            i++;
        }
        data.activeViewportIds = [...viewportIdArray];
        this.editData = {
            annotation,
        };
        return data.handles.activeOperation === CrosshairsTool_OPERATION.DRAG ? true : false;
    }
}
CrosshairsTool.toolName = 'Crosshairs';
/* harmony default export */ const tools_CrosshairsTool = ((/* unused pure expression or super */ null && (CrosshairsTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js







const MAGNIFY_VIEWPORT_ID = 'magnify-viewport';
class MagnifyTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            magnifySize: 10,
            magnifyWidth: 250,
            magnifyHeight: 250,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._hasBeenRemoved = false;
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            if (!(viewport instanceof esm.StackViewport)) {
                throw new Error('MagnifyTool only works on StackViewports');
            }
            const referencedImageId = this._getReferencedImageId(viewport);
            if (!referencedImageId) {
                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                referencedImageId,
                viewportIdsToRender,
                enabledElement,
                renderingEngine,
                currentPoints,
            };
            this._createMagnificationViewport();
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this.preTouchStartCallback = (evt) => {
            this.preMouseDownCallback(evt);
        };
        this._createMagnificationViewport = () => {
            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportProperties = viewport.getProperties();
            const { rotation: originalViewportRotation } = viewport.getViewPresentation();
            const { canvas: canvasPos, world: worldPos } = currentPoints;
            let magnifyToolElement;
            magnifyToolElement = element.querySelector('.magnifyTool');
            if (magnifyToolElement === null) {
                const magnifyElement = document.createElement('div');
                magnifyElement.classList.add('magnifyTool');
                magnifyElement.style.display = 'block';
                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;
                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;
                magnifyElement.style.position = 'absolute';
                magnifyToolElement = magnifyElement;
                const viewportElement = element.querySelector('.viewport-element');
                viewportElement.appendChild(magnifyElement);
                const viewportInput = {
                    viewportId: MAGNIFY_VIEWPORT_ID,
                    type: esm.Enums.ViewportType.STACK,
                    element: magnifyToolElement,
                };
                renderingEngine.enableElement(viewportInput);
            }
            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            magnifyViewport.setStack([referencedImageId]).then(() => {
                if (this._hasBeenRemoved) {
                    return;
                }
                magnifyViewport.setProperties(viewportProperties);
                magnifyViewport.setViewPresentation({
                    rotation: originalViewportRotation,
                });
                const { parallelScale } = viewport.getCamera();
                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
                    Math.pow(focalPoint[1] - position[1], 2) +
                    Math.pow(focalPoint[2] - position[2], 2));
                const updatedFocalPoint = [
                    worldPos[0],
                    worldPos[1],
                    worldPos[2],
                ];
                const updatedPosition = [
                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],
                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],
                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],
                ];
                magnifyViewport.setCamera({
                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),
                    focalPoint: updatedFocalPoint,
                    position: updatedPosition,
                });
                magnifyViewport.render();
            });
            magnifyToolElement.style.display = 'block';
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._cancelCallback = (evt) => {
            evt.preventDefault();
            evt.stopPropagation();
            this._dragEndCallback(evt);
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { deltaPoints, element, currentPoints } = eventDetail;
            const deltaPointsWorld = deltaPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);
            const magnifyElement = element.querySelector('.magnifyTool');
            if (!magnifyElement) {
                return;
            }
            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;
            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;
            const { focalPoint, position } = magnifyViewport.getCamera();
            const updatedPosition = [
                position[0] + deltaPointsWorld[0],
                position[1] + deltaPointsWorld[1],
                position[2] + deltaPointsWorld[2],
            ];
            const updatedFocalPoint = [
                focalPoint[0] + deltaPointsWorld[0],
                focalPoint[1] + deltaPointsWorld[1],
                focalPoint[2] + deltaPointsWorld[2],
            ];
            magnifyViewport.setCamera({
                focalPoint: updatedFocalPoint,
                position: updatedPosition,
            });
            magnifyViewport.render();
        };
        this._dragEndCallback = (evt) => {
            let { element } = evt.detail;
            if (element === undefined) {
                const { enabledElement } = this.editData;
                const { viewport } = enabledElement;
                element = viewport.element;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);
            const viewportElement = element.querySelector('.viewport-element');
            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');
            viewportElement.removeChild(magnifyToolElement);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this._hasBeenRemoved = true;
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            this._hasBeenRemoved = false;
            element.addEventListener(enums.Events.MOUSE_UP, this._dragEndCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._dragEndCallback);
            element.addEventListener('contextmenu', this._cancelCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._dragEndCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._dragEndCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._dragEndCallback);
            element.removeEventListener('contextmenu', this._cancelCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._dragEndCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
    }
    _getReferencedImageId(viewport) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId;
        if (viewport instanceof esm.StackViewport) {
            referencedImageId = targetId.split('imageId:')[1];
        }
        return referencedImageId;
    }
}
MagnifyTool.toolName = 'Magnify';
/* harmony default export */ const tools_MagnifyTool = ((/* unused pure expression or super */ null && (MagnifyTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility = __webpack_require__(29601);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js + 2 modules
var circle = __webpack_require__(77081);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js + 3 modules
var point = __webpack_require__(82216);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js


















const MAGNIFY_CLASSNAME = 'advancedMagnifyTool';
const MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;
const { Events: csEvents } = esm.Enums;
const isSegmentation = (actor) => actor.uid !== actor.referencedId;
var AdvancedMagnifyToolActions;
(function (AdvancedMagnifyToolActions) {
    AdvancedMagnifyToolActions["ShowZoomFactorsList"] = "showZoomFactorsList";
})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));
const ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';
const PARALLEL_THRESHOLD = 1 - esm.CONSTANTS.EPSILON;
class AdvancedMagnifyTool extends base/* AnnotationTool */.EC {
    static { this.Actions = AdvancedMagnifyToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            magnifyingGlass: {
                radius: 125,
                zoomFactor: 3,
                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],
                autoPan: {
                    enabled: true,
                    padding: 10,
                },
            },
            actions: {
                showZoomFactorsList: {
                    method: 'showZoomFactorsList',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Secondary,
                            modifierKey: enums.KeyboardBindings.Shift,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const { magnifyingGlass: config } = this.configuration;
            const { radius, zoomFactor, autoPan } = config;
            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotationUID = esm.utilities.uuidv4();
            const magnifyViewportId = esm.utilities.uuidv4();
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                annotationUID,
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    sourceViewportId: viewport.id,
                    magnifyViewportId,
                    zoomFactor,
                    isCanvasAnnotation: true,
                    handles: {
                        points: canvasHandlePoints,
                        activeHandleIndex: null,
                    },
                },
            };
            this.magnifyViewportManager.createViewport(annotation, {
                magnifyViewportId,
                sourceEnabledElement: enabledElement,
                position: canvasPos,
                radius,
                zoomFactor,
                autoPan: {
                    enabled: autoPan.enabled,
                    padding: autoPan.padding,
                    callback: (data) => {
                        const annotationPoints = annotation.data.handles.points;
                        const { canvas: canvasDelta } = data.delta;
                        for (let i = 0, len = annotationPoints.length; i < len; i++) {
                            const point = annotationPoints[i];
                            point[0] += canvasDelta[0];
                            point[1] += canvasDelta[1];
                            annotation.invalidated = true;
                        }
                    },
                },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.onSetToolDisabled = () => {
            this.magnifyViewportManager.dispose();
            const annotations = (0,annotationState.getAllAnnotations)();
            annotations.forEach((annotation) => {
                if (annotation.metadata.toolName === this.getToolName()) {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                }
            });
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const center = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const radiusPoint = (0,circle.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radiusPoint - radius) < proximity * 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            const { points } = data.handles;
            const handleIndex = points.findIndex((p) => p === handle);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { deltaPoints } = eventDetail;
            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];
            const { annotation, viewportIdsToRender } = this.editData;
            const { points } = annotation.data.handles;
            points.forEach((point) => {
                point[0] += canvasDelta[0];
                point[1] += canvasDelta[1];
            });
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const canvasDelta = deltaPoints.canvas;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += canvasDelta[0];
                    point[1] += canvasDelta[1];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points;
            const canvasTop = canvasCoordinates[0];
            const canvasBottom = canvasCoordinates[2];
            const canvasLeft = canvasCoordinates[3];
            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
            const canvasCenter = [
                canvasLeft[0] + radius,
                canvasTop[1] + radius,
            ];
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const newRadius = (0,circle.getCanvasCircleRadius)([
                canvasCenter,
                currentCanvasPoints,
            ]);
            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);
            points[0] = newCanvasHandlePoints[0];
            points[1] = newCanvasHandlePoints[1];
            points[2] = newCanvasHandlePoints[2];
            points[3] = newCanvasHandlePoints[3];
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===
                viewport.id);
            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!filteredAnnotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < filteredAnnotations.length; i++) {
                const annotation = filteredAnnotations[i];
                const { annotationUID, data } = annotation;
                const { magnifyViewportId, zoomFactor, handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points;
                const canvasTop = canvasCoordinates[0];
                const canvasBottom = canvasCoordinates[2];
                const canvasLeft = canvasCoordinates[3];
                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;
                const center = [
                    canvasLeft[0] + radius,
                    canvasTop[1] + radius,
                ];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-advancedMagnify`;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineWidth: 5,
                }, dataId);
                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);
                magnifyViewport.position = center;
                magnifyViewport.radius = radius;
                magnifyViewport.zoomFactor = zoomFactor;
                magnifyViewport.update();
                renderStatus = true;
            }
            return renderStatus;
        };
        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {
            return [
                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],
                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],
                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],
                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],
            ];
        };
        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();
    }
    showZoomFactorsList(evt, annotation) {
        const { element, currentPoints } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvas: canvasPoint } = currentPoints;
        const viewportElement = element.querySelector(':scope .viewport-element');
        const currentZoomFactor = annotation.data.zoomFactor;
        const remove = () => dropdown.parentElement.removeChild(dropdown);
        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {
            if (newZoomFactor !== undefined) {
                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);
                annotation.invalidated = true;
            }
            remove();
            viewport.render();
        });
        Object.assign(dropdown.style, {
            left: `${canvasPoint[0]}px`,
            top: `${canvasPoint[1]}px`,
        });
        viewportElement.appendChild(dropdown);
        dropdown.focus();
    }
    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {
        const { zoomFactorList } = this.configuration.magnifyingGlass;
        const dropdown = document.createElement('select');
        dropdown.size = 5;
        Object.assign(dropdown.style, {
            width: '50px',
            position: 'absolute',
        });
        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {
            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());
        });
        dropdown.addEventListener('change', (evt) => {
            evt.stopPropagation();
            onChangeCallback(dropdown.value);
        });
        dropdown.addEventListener('keydown', (evt) => {
            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||
                evt.key?.toLowerCase() === 'escape';
            if (shouldCancel) {
                evt.stopPropagation();
                onChangeCallback();
            }
        });
        zoomFactorList.forEach((zoomFactor) => {
            const option = document.createElement('option');
            option.label = zoomFactor;
            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;
            option.value = zoomFactor;
            option.defaultSelected = zoomFactor === currentZoomFactor;
            dropdown.add(option);
        });
        return dropdown;
    }
}
class AdvancedMagnifyViewportManager {
    constructor() {
        this.createViewport = (annotation, viewportInfo) => {
            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;
            const { viewport: sourceViewport } = sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            const magnifyViewport = new AdvancedMagnifyViewport({
                magnifyViewportId,
                sourceEnabledElement,
                radius,
                position,
                zoomFactor,
                autoPan,
            });
            this._addSourceElementEventListener(sourceElement);
            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {
                annotation,
                magnifyViewport,
                magnifyViewportInfo: viewportInfo,
            });
            return magnifyViewport;
        };
        this._annotationRemovedCallback = (evt) => {
            const { annotation } = evt.detail;
            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {
                return;
            }
            this.destroyViewport(annotation.data.magnifyViewportId);
        };
        this._newStackImageCallback = (evt) => {
            const { viewportId: sourceViewportId, imageId } = evt.detail;
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            const { viewport } = (0,esm.getEnabledElementByViewportId)(sourceViewportId);
            if (viewport.stackActorReInitialized) {
                this._reset(sourceViewportId);
            }
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                annotation.metadata.referencedImageId = imageId;
                annotation.invalidated = true;
            });
        };
        this._newVolumeImageCallback = (evt) => {
            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;
            const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
            const sourceViewport = renderingEngine.getViewport(sourceViewportId);
            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();
            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
            magnifyViewportsMapEntries.forEach(({ annotation }) => {
                const { viewPlaneNormal } = annotation.metadata;
                const isParallel = Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(viewPlaneNormal, currentViewPlaneNormal)) >
                    PARALLEL_THRESHOLD;
                if (!isParallel) {
                    return;
                }
                const { handles } = annotation.data;
                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);
                const vecHandleToImagePlane = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), worldImagePlanePoint, handles.points[0]);
                const worldDist = gl_matrix_esm/* vec3.dot */.eR.dot(vecHandleToImagePlane, currentViewPlaneNormal);
                const worldDelta = gl_matrix_esm/* vec3.scale */.eR.scale(gl_matrix_esm/* vec3.create */.eR.create(), currentViewPlaneNormal, worldDist);
                for (let i = 0, len = handles.points.length; i < len; i++) {
                    const point = handles.points[i];
                    point[0] += worldDelta[0];
                    point[1] += worldDelta[1];
                    point[2] += worldDelta[2];
                }
                annotation.invalidated = true;
            });
        };
        this._magnifyViewportsMap = new Map();
        this._initialize();
    }
    static getInstance() {
        AdvancedMagnifyViewportManager._singleton =
            AdvancedMagnifyViewportManager._singleton ??
                new AdvancedMagnifyViewportManager();
        return AdvancedMagnifyViewportManager._singleton;
    }
    getViewport(magnifyViewportId) {
        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;
    }
    dispose() {
        this._removeEventListeners();
        this._destroyViewports();
    }
    destroyViewport(magnifyViewportId) {
        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);
        if (magnifyViewportMapEntry) {
            const { magnifyViewport } = magnifyViewportMapEntry;
            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;
            const { element: sourceElement } = sourceViewport;
            this._removeSourceElementEventListener(sourceElement);
            magnifyViewport.dispose();
            this._magnifyViewportsMap.delete(magnifyViewportId);
        }
    }
    _destroyViewports() {
        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());
        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));
    }
    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {
        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());
        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {
            const { viewport } = magnifyViewport.sourceEnabledElement;
            return viewport.id === sourceViewportId;
        });
    }
    _reset(sourceViewportId) {
        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);
        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {
            this.destroyViewport(magnifyViewport.viewportId);
            const newEnabledElement = (0,esm.getEnabledElementByViewportId)(sourceViewportId);
            this.createViewport(annotation, {
                ...magnifyViewportInfo,
                sourceEnabledElement: {
                    ...newEnabledElement,
                },
            });
        });
    }
    _addEventListeners() {
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _removeEventListeners() {
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_REMOVED, this._annotationRemovedCallback);
    }
    _addSourceElementEventListener(element) {
        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        const newStackHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);
        const newVolumeHandler = (evt) => {
            const { viewportId: sourceViewportId } = evt.detail;
            this._reset(sourceViewportId);
        };
        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);
        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.newStackHandler = newStackHandler;
        element.newVolumeHandler = newVolumeHandler;
    }
    _removeSourceElementEventListener(element) {
        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);
        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);
        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);
        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);
        delete element.newStackHandler;
        delete element.newVolumeHandler;
    }
    _initialize() {
        this._addEventListeners();
    }
}
class AdvancedMagnifyViewport {
    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {
        this._enabledElement = null;
        this._sourceToolGroup = null;
        this._magnifyToolGroup = null;
        this._isViewportReady = false;
        this._radius = 0;
        this._resized = false;
        this._canAutoPan = false;
        this._viewportId = magnifyViewportId ?? esm.utilities.uuidv4();
        this._sourceEnabledElement = sourceEnabledElement;
        this._autoPan = autoPan;
        this.radius = radius;
        this.position = position;
        this.zoomFactor = zoomFactor;
        this.visible = true;
        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);
        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);
        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);
        this._mouseDragCallback = this._mouseDragCallback.bind(this);
        this._resizeViewportAsync = ((0,debounce/* default */.A)(this._resizeViewport.bind(this), 1));
        this._initialize();
    }
    get sourceEnabledElement() {
        return this._sourceEnabledElement;
    }
    get viewportId() {
        return this._viewportId;
    }
    get radius() {
        return this._radius;
    }
    set radius(radius) {
        if (Math.abs(this._radius - radius) > 0.00001) {
            this._radius = radius;
            this._resized = true;
        }
    }
    update() {
        const { radius, position, visible } = this;
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const size = 2 * radius;
        const [x, y] = position;
        if (this._resized) {
            this._resizeViewportAsync();
            this._resized = false;
        }
        Object.assign(element.style, {
            display: visible ? 'block' : 'hidden',
            width: `${size}px`,
            height: `${size}px`,
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(${x}px, ${y}px)`,
        });
        if (this._isViewportReady) {
            this._syncViewports();
            viewport.render();
        }
    }
    dispose() {
        const { viewport } = this._enabledElement;
        const { element } = viewport;
        const renderingEngine = viewport.getRenderingEngine();
        this._removeEventListeners(element);
        renderingEngine.disableElement(viewport.id);
        if (element.parentNode) {
            element.parentNode.removeChild(element);
        }
    }
    _handleToolModeChanged(evt) {
        const { _magnifyToolGroup: magnifyToolGroup } = this;
        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;
        if (this._sourceToolGroup?.id !== toolGroupId) {
            return;
        }
        switch (mode) {
            case enums.ToolModes.Active:
                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);
                break;
            case enums.ToolModes.Passive:
                magnifyToolGroup.setToolPassive(toolName);
                break;
            case enums.ToolModes.Enabled:
                magnifyToolGroup.setToolEnabled(toolName);
                break;
            case enums.ToolModes.Disabled:
                magnifyToolGroup.setToolDisabled(toolName);
                break;
            default:
                throw new Error(`Unknow tool mode (${mode})`);
        }
    }
    _inheritBorderRadius(magnifyElement) {
        const viewport = magnifyElement.querySelector('.viewport-element');
        const canvas = magnifyElement.querySelector('.cornerstone-canvas');
        viewport.style.borderRadius = 'inherit';
        canvas.style.borderRadius = 'inherit';
    }
    _createViewportNode() {
        const magnifyElement = document.createElement('div');
        const { radius } = this;
        const size = radius * 2;
        magnifyElement.classList.add(MAGNIFY_CLASSNAME);
        Object.assign(magnifyElement.style, {
            display: 'block',
            width: `${size}px`,
            height: `${size}px`,
            position: 'absolute',
            overflow: 'hidden',
            borderRadius: '50%',
            boxSizing: 'border-box',
            left: `${-radius}px`,
            top: `${-radius}px`,
            transform: `translate(-1000px, -1000px)`,
        });
        return magnifyElement;
    }
    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {
        const { parallelScale } = viewport.getCamera();
        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;
        return parallelScale * (1 / zoomFactor) * canvasRatio;
    }
    _isStackViewport(viewport) {
        return 'setStack' in viewport;
    }
    _isVolumeViewport(viewport) {
        return 'addVolumes' in viewport;
    }
    _cloneToolGroups(sourceViewport, magnifyViewport) {
        const sourceActors = sourceViewport.getActors();
        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;
        const sourceToolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(sourceViewport.id, sourceViewport.renderingEngineId);
        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {
            const toolInstance = sourceToolGroup.getToolInstance(toolName);
            const isAnnotationTool = toolInstance instanceof base/* AnnotationTool */.EC &&
                !(toolInstance instanceof AdvancedMagnifyTool);
            return isAnnotationTool;
        });
        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);
        sourceActors.filter(isSegmentation).forEach((actor) => {
            (0,stateManagement_segmentation.addSegmentationRepresentations)(this.viewportId, [
                {
                    segmentationId: actor.referencedId,
                    type: enums.SegmentationRepresentations.Labelmap,
                },
            ]);
        });
        return { sourceToolGroup, magnifyToolGroup };
    }
    _cloneStack(sourceViewport, magnifyViewport) {
        const imageIds = sourceViewport.getImageIds();
        magnifyViewport.setStack(imageIds).then(() => {
            this._isViewportReady = true;
            this.update();
        });
    }
    _cloneVolumes(sourceViewport, magnifyViewport) {
        const actors = sourceViewport.getActors();
        const volumeInputArray = actors
            .filter((actor) => !isSegmentation(actor))
            .map((actor) => ({ volumeId: actor.uid }));
        magnifyViewport.setVolumes(volumeInputArray).then(() => {
            this._isViewportReady = true;
            this.update();
        });
        return magnifyViewport;
    }
    _cloneViewport(sourceViewport, magnifyElement) {
        const { viewportId: magnifyViewportId } = this;
        const renderingEngine = sourceViewport.getRenderingEngine();
        const { options: sourceViewportOptions } = sourceViewport;
        const viewportInput = {
            element: magnifyElement,
            viewportId: magnifyViewportId,
            type: sourceViewport.type,
            defaultOptions: { ...sourceViewportOptions },
        };
        renderingEngine.enableElement(viewportInput);
        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));
        if (this._isStackViewport(sourceViewport)) {
            this._cloneStack(sourceViewport, magnifyViewport);
        }
        else if (this._isVolumeViewport(sourceViewport)) {
            this._cloneVolumes(sourceViewport, magnifyViewport);
        }
        this._inheritBorderRadius(magnifyElement);
        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);
        this._sourceToolGroup = toolGroups.sourceToolGroup;
        this._magnifyToolGroup = toolGroups.magnifyToolGroup;
    }
    _cancelMouseEventCallback(evt) {
        evt.stopPropagation();
        evt.preventDefault();
    }
    _browserMouseUpCallback(evt) {
        const { element } = this._enabledElement.viewport;
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _browserMouseDownCallback(evt) {
        const { element } = this._enabledElement.viewport;
        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');
        document.addEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
    }
    _mouseDragCallback(evt) {
        if (!store_state/* state */.wk.isInteractingWithTool) {
            return;
        }
        const { _autoPan: autoPan } = this;
        if (!autoPan.enabled || !this._canAutoPan) {
            return;
        }
        const { currentPoints } = evt.detail;
        const { viewport } = this._enabledElement;
        const { canvasToWorld } = viewport;
        const { canvas: canvasCurrent } = currentPoints;
        const { radius: magnifyRadius } = this;
        const canvasCenter = [magnifyRadius, magnifyRadius];
        const dist = (0,point.distanceToPoint)(canvasCenter, canvasCurrent);
        const maxDist = magnifyRadius - autoPan.padding;
        if (dist <= maxDist) {
            return;
        }
        const panDist = dist - maxDist;
        const canvasDeltaPos = gl_matrix_esm/* vec2.sub */.Zc.sub(gl_matrix_esm/* vec2.create */.Zc.create(), canvasCurrent, canvasCenter);
        gl_matrix_esm/* vec2.normalize */.Zc.normalize(canvasDeltaPos, canvasDeltaPos);
        gl_matrix_esm/* vec2.scale */.Zc.scale(canvasDeltaPos, canvasDeltaPos, panDist);
        const newCanvasPosition = gl_matrix_esm/* vec2.add */.Zc.add(gl_matrix_esm/* vec2.create */.Zc.create(), this.position, canvasDeltaPos);
        const currentWorldPos = canvasToWorld(this.position);
        const newWorldPos = canvasToWorld(newCanvasPosition);
        const worldDeltaPos = gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), newWorldPos, currentWorldPos);
        const autoPanCallbackData = {
            points: {
                currentPosition: {
                    canvas: this.position,
                    world: currentWorldPos,
                },
                newPosition: {
                    canvas: newCanvasPosition,
                    world: newWorldPos,
                },
            },
            delta: {
                canvas: canvasDeltaPos,
                world: worldDeltaPos,
            },
        };
        autoPan.callback(autoPanCallbackData);
    }
    _addBrowserEventListeners(element) {
        document.addEventListener('mousedown', this._browserMouseDownCallback, true);
        element.addEventListener('mousedown', this._cancelMouseEventCallback);
        element.addEventListener('mouseup', this._cancelMouseEventCallback);
        element.addEventListener('mousemove', this._cancelMouseEventCallback);
        element.addEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _removeBrowserEventListeners(element) {
        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);
        document.removeEventListener('mouseup', this._browserMouseUpCallback);
        element.removeEventListener('mousedown', this._cancelMouseEventCallback);
        element.removeEventListener('mouseup', this._cancelMouseEventCallback);
        element.removeEventListener('mousemove', this._cancelMouseEventCallback);
        element.removeEventListener('dblclick', this._cancelMouseEventCallback);
    }
    _addEventListeners(element) {
        esm.eventTarget.addEventListener(enums.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._addBrowserEventListeners(element);
    }
    _removeEventListeners(element) {
        esm.eventTarget.removeEventListener(enums.Events.TOOL_MODE_CHANGED, this._handleToolModeChanged);
        element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseDragCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._mouseDragCallback);
        this._removeBrowserEventListeners(element);
    }
    _initialize() {
        const { _sourceEnabledElement: sourceEnabledElement } = this;
        const { viewport: sourceViewport } = sourceEnabledElement;
        const { canvas: sourceCanvas } = sourceViewport;
        const magnifyElement = this._createViewportNode();
        sourceCanvas.parentNode.appendChild(magnifyElement);
        this._addEventListeners(magnifyElement);
        this._cloneViewport(sourceViewport, magnifyElement);
        this._enabledElement = (0,esm.getEnabledElement)(magnifyElement);
    }
    _syncViewportsCameras(sourceViewport, magnifyViewport) {
        const worldPos = sourceViewport.canvasToWorld(this.position);
        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);
        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();
        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +
            Math.pow(focalPoint[1] - position[1], 2) +
            Math.pow(focalPoint[2] - position[2], 2));
        const updatedFocalPoint = [
            worldPos[0],
            worldPos[1],
            worldPos[2],
        ];
        const updatedPosition = [
            updatedFocalPoint[0] + distance * viewPlaneNormal[0],
            updatedFocalPoint[1] + distance * viewPlaneNormal[1],
            updatedFocalPoint[2] + distance * viewPlaneNormal[2],
        ];
        magnifyViewport.setCamera({
            parallelScale,
            focalPoint: updatedFocalPoint,
            position: updatedPosition,
        });
    }
    _syncStackViewports(sourceViewport, magnifyViewport) {
        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());
    }
    _syncViewports() {
        const { viewport: sourceViewport } = this._sourceEnabledElement;
        const { viewport: magnifyViewport } = this._enabledElement;
        const sourceProperties = sourceViewport.getProperties();
        const imageData = magnifyViewport.getImageData();
        if (!imageData) {
            return;
        }
        magnifyViewport.setProperties(sourceProperties);
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        if (this._isStackViewport(sourceViewport)) {
            this._syncStackViewports(sourceViewport, magnifyViewport);
        }
        this._syncViewportsCameras(sourceViewport, magnifyViewport);
        magnifyViewport.render();
    }
    _resizeViewport() {
        const { viewport } = this._enabledElement;
        const renderingEngine = viewport.getRenderingEngine();
        renderingEngine.resize();
    }
}
AdvancedMagnifyTool.toolName = 'AdvancedMagnify';


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js
var AnnotationDisplayTool = __webpack_require__(6030);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js








const { EPSILON } = esm.CONSTANTS;
class ReferenceLines extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceViewportId: '',
            enforceSameFrameOfReference: true,
            showFullDimension: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,esm.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            let viewports = renderingEngine.getViewports();
            viewports = (0,viewportFilters.filterViewportsWithToolEnabled)(viewports, this.getToolName());
            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);
            if (!sourceViewport?.getImageData()) {
                return;
            }
            const { element } = sourceViewport;
            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();
            const sourceViewportCanvasCornersInWorld = esm.utilities.getViewportImageCornersInWorld(sourceViewport);
            let annotation = this.editData?.annotation;
            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();
            if (!annotation) {
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [...viewPlaneNormal],
                        viewUp: [...viewUp],
                        FrameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        handles: {
                            points: sourceViewportCanvasCornersInWorld,
                        },
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, element);
                annotation = newAnnotation;
            }
            else {
                this.editData.annotation.data.handles.points =
                    sourceViewportCanvasCornersInWorld;
            }
            this.editData = {
                sourceViewportId: sourceViewport.id,
                renderingEngine,
                annotation,
            };
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewports
                .filter((viewport) => viewport.id !== sourceViewport.id)
                .map((viewport) => viewport.id));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolConfiguration = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport: targetViewport } = enabledElement;
            if (!this.editData) {
                return false;
            }
            const { annotation, sourceViewportId } = this.editData;
            let renderStatus = false;
            const { viewport: sourceViewport } = (0,esm.getEnabledElementByViewportId)(sourceViewportId) || {};
            if (!sourceViewport) {
                return renderStatus;
            }
            if (sourceViewport.id === targetViewport.id) {
                return renderStatus;
            }
            if (!annotation || !annotation?.data?.handles?.points) {
                return renderStatus;
            }
            if (this.configuration.enforceSameFrameOfReference &&
                sourceViewport.getFrameOfReferenceUID() !==
                    targetViewport.getFrameOfReferenceUID()) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const topLeft = annotation.data.handles.points[0];
            const topRight = annotation.data.handles.points[1];
            const bottomLeft = annotation.data.handles.points[2];
            const bottomRight = annotation.data.handles.points[3];
            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();
            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();
            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            let pointSetToUse = pointSet1;
            let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[0], pointSet1[1]);
            topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
            let topRightVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[2], pointSet1[0]);
            topRightVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topRightVec);
            const newNormal = gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec, topRightVec);
            if (this.isParallel(newNormal, viewPlaneNormal)) {
                return renderStatus;
            }
            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                pointSetToUse = pointSet2;
            }
            const lineStartWorld = esm.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
            const lineEndWorld = esm.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
            const { annotationUID } = annotation;
            styleSpecifier.annotationUID = annotationUID;
            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
            const color = this.getStyle('color', styleSpecifier, annotation);
            const shadow = this.getStyle('shadow', styleSpecifier, annotation);
            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
            if (this.configuration.showFullDimension) {
                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);
            }
            if (canvasCoordinates.length < 2) {
                return renderStatus;
            }
            const dataId = `${annotationUID}-line`;
            const lineUID = '1';
            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, dataId);
            renderStatus = true;
            return renderStatus;
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2);
            return Math.abs(dot) < EPSILON;
        };
    }
    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {
        const renderingEngine = targetViewport.getRenderingEngine();
        const targetId = this.getTargetId(targetViewport);
        const targetImage = this.getTargetImageData(targetId);
        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);
        if (referencedImageId && targetImage) {
            try {
                const { imageData, dimensions } = targetImage;
                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [
                    imageData.indexToWorld([0, 0, 0]),
                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),
                    imageData.indexToWorld([
                        dimensions[0] - 1,
                        dimensions[1] - 1,
                        0,
                    ]),
                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),
                ].map((world) => esm.utilities.worldToImageCoords(referencedImageId, world));
                const [lineStartImageCoord, lineEndImageCoord] = [
                    lineStartWorld,
                    lineEndWorld,
                ].map((world) => esm.utilities.worldToImageCoords(referencedImageId, world));
                canvasCoordinates = [
                    [topLeftImageCoord, topRightImageCoord],
                    [topRightImageCoord, bottomRightImageCoord],
                    [bottomLeftImageCoord, bottomRightImageCoord],
                    [topLeftImageCoord, bottomLeftImageCoord],
                ]
                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))
                    .filter((point) => point && this.isInBound(point, dimensions))
                    .map((point) => {
                    const world = esm.utilities.imageToWorldCoords(referencedImageId, point);
                    return targetViewport.worldToCanvas(world);
                });
            }
            catch (err) {
                console.log(err);
            }
        }
        return canvasCoordinates;
    }
    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {
        const [x1, y1] = line1Start;
        const [x2, y2] = line1End;
        const [x3, y3] = line2Start;
        const [x4, y4] = line2End;
        const a1 = y2 - y1;
        const b1 = x1 - x2;
        const c1 = x2 * y1 - x1 * y2;
        const a2 = y4 - y3;
        const b2 = x3 - x4;
        const c2 = x4 * y3 - x3 * y4;
        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {
            return;
        }
        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);
        return [x, y];
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2)) > 1 - EPSILON;
    }
    isInBound(point, dimensions) {
        return (point[0] >= 0 &&
            point[0] <= dimensions[0] &&
            point[1] >= 0 &&
            point[1] <= dimensions[1]);
    }
}
ReferenceLines.toolName = 'ReferenceLines';
/* harmony default export */ const ReferenceLinesTool = ((/* unused pure expression or super */ null && (ReferenceLines)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js







const { EPSILON: OverlayGridTool_EPSILON } = esm.CONSTANTS;
class OverlayGridTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            sourceImageIds: [],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onSetToolActive = () => {
            this._init();
        };
        this._init = () => {
            const sourceImageIds = this.configuration.sourceImageIds;
            if (!sourceImageIds?.length) {
                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');
                return;
            }
            const imagePlaneModule = esm.metaData.get('imagePlaneModule', sourceImageIds[0]);
            if (!imagePlaneModule) {
                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');
                return;
            }
            const { frameOfReferenceUID } = imagePlaneModule;
            const viewportsInfo = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn('OverlayGridTool: No viewports found');
                return;
            }
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const pointSets = sourceImageIds.map((id) => {
                    return this.calculateImageIdPointSets(id);
                });
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        viewportData: new Map(),
                        pointSets,
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.calculateImageIdPointSets = (imageId) => {
            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = esm.metaData.get('imagePlaneModule', imageId);
            const topLeft = [...imagePositionPatient];
            const topRight = [...imagePositionPatient];
            const bottomLeft = [...imagePositionPatient];
            const bottomRight = [...imagePositionPatient];
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);
            gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);
            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];
            return { pointSet1, pointSet2 };
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const sourceImageIds = this.configuration.sourceImageIds;
            let renderStatus = false;
            if (!sourceImageIds?.length) {
                return renderStatus;
            }
            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;
            const targetImageIds = targetViewport.getImageIds();
            if (targetImageIds.length < 2) {
                return renderStatus;
            }
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));
            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {
                return renderStatus;
            }
            const targetViewportPlane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const pointSets = annotation.data.pointSets;
            const viewportData = annotation.data.viewportData;
            for (let i = 0; i < sourceImageIds.length; i++) {
                const { pointSet1, pointSet2 } = pointSets[i];
                const targetData = viewportData.get(targetViewport.id) ||
                    this.initializeViewportData(viewportData, targetViewport.id);
                if (!targetData.pointSetsToUse[i]) {
                    let pointSetToUse = pointSet1;
                    let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet1[0], pointSet1[1]);
                    topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {
                        pointSetToUse = pointSet2;
                    }
                    targetData.pointSetsToUse[i] = pointSetToUse;
                    targetData.lineStartsWorld[i] = esm.utilities.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);
                    targetData.lineEndsWorld[i] = esm.utilities.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);
                }
                const lineStartWorld = targetData.lineStartsWorld[i];
                const lineEndWorld = targetData.lineEndsWorld[i];
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const shadow = this.getStyle('shadow', styleSpecifier, annotation);
                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));
                const dataId = `${annotationUID}-line`;
                const lineUID = `${i}`;
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
            }
            renderStatus = true;
            return renderStatus;
        };
        this.initializeViewportData = (viewportData, id) => {
            viewportData.set(id, {
                pointSetsToUse: [],
                lineStartsWorld: [],
                lineEndsWorld: [],
            });
            return viewportData.get(id);
        };
        this.isPerpendicular = (vec1, vec2) => {
            const dot = gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2);
            return Math.abs(dot) < OverlayGridTool_EPSILON;
        };
    }
    isParallel(vec1, vec2) {
        return Math.abs(gl_matrix_esm/* vec3.dot */.eR.dot(vec1, vec2)) > 1 - OverlayGridTool_EPSILON;
    }
    getImageIdNormal(imageId) {
        const { imageOrientationPatient } = esm.metaData.get('imagePlaneModule', imageId);
        const rowCosineVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
        const colCosineVec = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
        return gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), rowCosineVec, colCosineVec);
    }
}
OverlayGridTool.toolName = 'OverlayGrid';
/* harmony default export */ const tools_OverlayGridTool = ((/* unused pure expression or super */ null && (OverlayGridTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js









class SegmentationIntersectionTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            opacity: 0.5,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._init = () => {
            const viewportsInfo = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportsInfo?.length) {
                console.warn(this.getToolName() + 'Tool: No viewports found');
                return;
            }
            const firstViewport = (0,esm.getRenderingEngine)(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);
            if (!firstViewport) {
                return;
            }
            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), frameOfReferenceUID);
            if (!annotations?.length) {
                const actorsWorldPointsMap = new Map();
                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);
                const newAnnotation = {
                    highlighted: true,
                    invalidated: true,
                    metadata: {
                        toolName: this.getToolName(),
                        FrameOfReferenceUID: frameOfReferenceUID,
                        referencedImageId: null,
                    },
                    data: {
                        actorsWorldPointsMap,
                    },
                };
                (0,annotationState.addAnnotation)(newAnnotation, frameOfReferenceUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportsInfo.map(({ viewportId }) => viewportId));
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this._init();
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const { viewport, FrameOfReferenceUID } = enabledElement;
            let renderStatus = false;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), FrameOfReferenceUID);
            if (!annotations?.length) {
                return renderStatus;
            }
            const annotation = annotations[0];
            const { annotationUID } = annotation;
            const actorsWorldPointsMap = (annotation).data.actorsWorldPointsMap;
            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
            const actorEntries = viewport.getActors();
            const cacheId = getCacheId(viewport);
            actorEntries.forEach((actorEntry) => {
                if (!actorEntry?.clippingFilter) {
                    return;
                }
                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);
                if (!actorWorldPointMap) {
                    return;
                }
                if (!actorWorldPointMap.get(cacheId)) {
                    return;
                }
                let polyLineIdx = 1;
                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);
                for (let i = 0; i < worldPointsSet.length; i++) {
                    const worldPoints = worldPointsSet[i];
                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));
                    const options = {
                        color: color,
                        fillColor: color,
                        fillOpacity: this.configuration.opacity,
                        closePath: true,
                        lineWidth: 2,
                    };
                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;
                    (0,drawingSvg.drawPath)(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);
                    polyLineIdx++;
                }
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
function calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {
    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
        const viewport = (0,esm.getRenderingEngine)(renderingEngineId)?.getViewport(viewportId);
        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);
    });
}
function calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {
    const actorEntries = viewport.getActors();
    const cacheId = getCacheId(viewport);
    actorEntries.forEach((actorEntry) => {
        if (!actorEntry?.clippingFilter) {
            return;
        }
        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);
        if (!actorWorldPointsMap) {
            actorWorldPointsMap = new Map();
            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);
        }
        if (!actorWorldPointsMap.get(cacheId)) {
            const polyData = actorEntry.clippingFilter.getOutputData();
            const worldPointsSet = getPolyDataPoints(polyData);
            if (!worldPointsSet) {
                return;
            }
            const colorArray = actorEntry.actor.getProperty().getColor();
            const color = colorToString(colorArray);
            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });
        }
    });
}
function getCacheId(viewport) {
    const { viewPlaneNormal } = viewport.getCamera();
    const imageIndex = viewport.getCurrentImageIdIndex();
    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;
}
function colorToString(colorArray) {
    function colorComponentToString(component) {
        let componentString = Math.floor(component * 255).toString(16);
        if (componentString.length === 1) {
            componentString = '0' + componentString;
        }
        return componentString;
    }
    return ('#' +
        colorComponentToString(colorArray[0]) +
        colorComponentToString(colorArray[1]) +
        colorComponentToString(colorArray[2]));
}
function removeExtraPoints(viewport, worldPointsSet) {
    return worldPointsSet.map((worldPoints) => {
        const canvasPoints = worldPoints.map((point) => {
            const canvasPoint = viewport.worldToCanvas(point);
            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];
        });
        let lastPoint;
        const newWorldPoints = [];
        let newCanvasPoints = [];
        for (let i = 0; i < worldPoints.length; i++) {
            if (lastPoint) {
                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {
                    newWorldPoints.push(worldPoints[i]);
                    newCanvasPoints.push(canvasPoints[i]);
                }
            }
            lastPoint = canvasPoints[i];
        }
        const firstPoint = newCanvasPoints[0];
        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {
            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {
                newCanvasPoints = newCanvasPoints.slice(0, j);
                return newWorldPoints.slice(0, j);
            }
        }
        return newWorldPoints;
    });
}
SegmentationIntersectionTool.toolName = 'SegmentationIntersection';
/* harmony default export */ const tools_SegmentationIntersectionTool = ((/* unused pure expression or super */ null && (SegmentationIntersectionTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js











class ReferenceCursors extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            displayThreshold: 5,
            positionSync: true,
            disableCursor: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isHandleOutsideImage = false;
        this._elementWithCursor = null;
        this._currentCursorWorldPosition = null;
        this._currentCanvasPosition = null;
        this._disableCursorEnabled = false;
        this.mouseMoveCallback = (evt) => {
            const { detail } = evt;
            const { element, currentPoints } = detail;
            this._currentCursorWorldPosition = currentPoints.world;
            this._currentCanvasPosition = currentPoints.canvas;
            this._elementWithCursor = element;
            const annotation = this.getActiveAnnotation(element);
            if (annotation === null) {
                this.createInitialAnnotation(currentPoints.world, element);
                return false;
            }
            this.updateAnnotationPosition(element, annotation);
            return false;
        };
        this.createInitialAnnotation = (worldPos, element) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('No enabled element found');
            }
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            if (!viewPlaneNormal || !viewUp) {
                throw new Error('Camera not found');
            }
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                },
            };
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (annotations.length > 0) {
                return null;
            }
            const annotationId = (0,annotationState.addAnnotation)(annotation, element);
            if (annotationId === null) {
                return;
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.onCameraModified = (evt) => {
            const eventDetail = evt.detail;
            const { element, previousCamera, camera } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const viewport = enabledElement.viewport;
            if (element !== this._elementWithCursor) {
                return;
            }
            const oldFocalPoint = previousCamera.focalPoint;
            const cameraNormal = camera.viewPlaneNormal;
            const newFocalPoint = camera.focalPoint;
            const deltaCameraFocalPoint = [0, 0, 0];
            Core_Math/* default.subtract */.Ay.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);
            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {
                return;
            }
            const dotProduct = Core_Math/* default.dot */.Ay.dot(deltaCameraFocalPoint, cameraNormal);
            if (Math.abs(dotProduct) < 1e-2) {
                return;
            }
            if (!this._currentCanvasPosition) {
                return;
            }
            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);
            this._currentCursorWorldPosition = newWorldPos;
            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport, FrameOfReferenceUID } = enabledElement;
            const isElementWithCursor = this._elementWithCursor === viewport.element;
            if (this.configuration.positionSync && !isElementWithCursor) {
                this.updateViewportImage(viewport);
            }
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                if (!annotationUID) {
                    return renderStatus;
                }
                styleSpecifier.annotationUID = annotationUID;
                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));
                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor
                    ? lineWidthBase
                    : lineWidthBase;
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (points[0].some((e) => isNaN(e))) {
                    return renderStatus;
                }
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const crosshairUIDs = {
                    upper: 'upper',
                    right: 'right',
                    lower: 'lower',
                    left: 'left',
                };
                const [x, y] = canvasCoordinates[0];
                const centerSpace = isElementWithCursor ? 20 : 7;
                const lineLength = isElementWithCursor ? 5 : 7;
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });
                renderStatus = true;
            }
            return renderStatus;
        };
        this._disableCursorEnabled = this.configuration.disableCursor;
    }
    onSetToolActive() {
        this._disableCursorEnabled = this.configuration.disableCursor;
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,elementCursor.hideElementCursor)(element.viewport.element);
            }
        });
    }
    onSetToolDisabled() {
        if (!this._disableCursorEnabled) {
            return;
        }
        const viewportIds = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
        if (!viewportIds) {
            return;
        }
        const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
        enabledElements.forEach((element) => {
            if (element) {
                (0,elementCursor.resetElementCursor)(element.viewport.element);
            }
        });
    }
    getActiveAnnotation(element) {
        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
        if (!annotations.length) {
            return null;
        }
        const targetAnnotation = annotations[0];
        return targetAnnotation;
    }
    updateAnnotationPosition(element, annotation) {
        const worldPos = this._currentCursorWorldPosition;
        if (!worldPos) {
            return;
        }
        if (!annotation.data?.handles?.points) {
            return;
        }
        annotation.data.handles.points = [[...worldPos]];
        annotation.invalidated = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!(annotations instanceof Array) || annotations.length === 0) {
            return [];
        }
        const annotation = annotations[0];
        const viewport = (0,esm.getEnabledElement)(element)?.viewport;
        if (!viewport) {
            return [];
        }
        const camera = viewport.getCamera();
        const { viewPlaneNormal, focalPoint } = camera;
        if (!viewPlaneNormal || !focalPoint) {
            return [];
        }
        const points = annotation.data?.handles?.points;
        if (!(points instanceof Array) || points.length !== 1) {
            return [];
        }
        const worldPos = points[0];
        const plane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
        const distance = esm.utilities.planar.planeDistanceToPoint(plane, worldPos);
        return distance < this.configuration.displayThreshold ? [annotation] : [];
    }
    updateViewportImage(viewport) {
        const currentMousePosition = this._currentCursorWorldPosition;
        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {
            return;
        }
        if (viewport instanceof esm.StackViewport) {
            const closestIndex = esm.utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);
            if (closestIndex === null) {
                return;
            }
            if (closestIndex !== viewport.getCurrentImageIdIndex()) {
                viewport.setImageIdIndex(closestIndex);
            }
        }
        else if (viewport instanceof esm.VolumeViewport) {
            const { focalPoint, viewPlaneNormal } = viewport.getCamera();
            if (!focalPoint || !viewPlaneNormal) {
                return;
            }
            const plane = esm.utilities.planar.planeEquation(viewPlaneNormal, focalPoint);
            const currentDistance = esm.utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);
            if (Math.abs(currentDistance) < 0.5) {
                return;
            }
            const normalizedViewPlane = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), gl_matrix_esm/* vec3.fromValues */.eR.fromValues(...viewPlaneNormal));
            const scaledPlaneNormal = gl_matrix_esm/* vec3.scale */.eR.scale(gl_matrix_esm/* vec3.create */.eR.create(), normalizedViewPlane, currentDistance);
            const newFocalPoint = gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), gl_matrix_esm/* vec3.fromValues */.eR.fromValues(...focalPoint), scaledPlaneNormal);
            const isInBounds = true;
            if (isInBounds) {
                viewport.setCamera({ focalPoint: newFocalPoint });
                const renderingEngine = viewport.getRenderingEngine();
                if (renderingEngine) {
                    renderingEngine.renderViewport(viewport.id);
                }
            }
        }
    }
}
ReferenceCursors.toolName = 'ReferenceCursors';
/* harmony default export */ const tools_ReferenceCursors = ((/* unused pure expression or super */ null && (ReferenceCursors)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js






const viewportsWithAnnotations = [];
class ScaleOverlayTool extends AnnotationDisplayTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            viewportId: '',
            scaleLocation: 'bottom',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.editData = null;
        this._init = () => {
            const renderingEngines = (0,esm.getRenderingEngines)();
            const renderingEngine = renderingEngines[0];
            if (!renderingEngine) {
                return;
            }
            const viewportIds = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            if (!viewportIds) {
                return;
            }
            const enabledElements = viewportIds.map((e) => (0,esm.getEnabledElementByIds)(e.viewportId, e.renderingEngineId));
            let { viewport } = enabledElements[0];
            const { FrameOfReferenceUID } = enabledElements[0];
            if (this.configuration.viewportId) {
                enabledElements.forEach((element) => {
                    if (element.viewport.id == this.configuration.viewportId) {
                        viewport = element.viewport;
                    }
                });
            }
            if (!viewport) {
                return;
            }
            const { viewUp, viewPlaneNormal } = viewport.getCamera();
            const viewportCanvasCornersInWorld = esm.utilities.getViewportImageCornersInWorld(viewport);
            let annotation = this.editData?.annotation;
            const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
            if (annotations.length) {
                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
            }
            enabledElements.forEach((element) => {
                const { viewport } = element;
                if (!viewportsWithAnnotations.includes(viewport.id)) {
                    const newAnnotation = {
                        metadata: {
                            toolName: this.getToolName(),
                            viewPlaneNormal: [...viewPlaneNormal],
                            viewUp: [...viewUp],
                            FrameOfReferenceUID,
                            referencedImageId: null,
                        },
                        data: {
                            handles: {
                                points: esm.utilities.getViewportImageCornersInWorld(viewport),
                            },
                            viewportId: viewport.id,
                        },
                    };
                    viewportsWithAnnotations.push(viewport.id);
                    (0,annotationState.addAnnotation)(newAnnotation, viewport.element);
                    annotation = newAnnotation;
                }
            });
            if (this.editData?.annotation &&
                this.editData.annotation.data.viewportId == viewport.id) {
                this.editData.annotation.data.handles.points =
                    viewportCanvasCornersInWorld;
                this.editData.annotation.data.viewportId = viewport.id;
            }
            this.editData = {
                viewport,
                renderingEngine,
                annotation,
            };
        };
        this.onSetToolEnabled = () => {
            this._init();
        };
        this.onCameraModified = (evt) => {
            this.configuration.viewportId = evt.detail.viewportId;
            this._init();
        };
        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {
            const scaleSizes = [
                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,
            ];
            let currentScaleSize;
            if (location == 'top' || location == 'bottom') {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&
                    scaleSize > worldWidthViewport * 0.2);
            }
            else {
                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&
                    scaleSize > worldHeightViewport * 0.2);
            }
            return currentScaleSize[0];
        };
        this.computeEndScaleTicks = (canvasCoordinates, location) => {
            const locationTickOffset = {
                bottom: [
                    [0, -10],
                    [0, -10],
                ],
                top: [
                    [0, 10],
                    [0, 10],
                ],
                left: [
                    [0, 0],
                    [10, 0],
                ],
                right: [
                    [0, 0],
                    [-10, 0],
                ],
            };
            const endTick1 = [
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],
                ],
            ];
            const endTick2 = [
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],
                ],
                [
                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],
                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],
                ],
            ];
            return {
                endTick1: endTick1,
                endTick2: endTick2,
            };
        };
        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {
            let canvasScaleSize;
            if (location == 'bottom' || location == 'top') {
                canvasScaleSize = rightTick[0][0] - leftTick[0][0];
            }
            else if (location == 'left' || location == 'right') {
                canvasScaleSize = rightTick[0][1] - leftTick[0][1];
            }
            const tickIds = [];
            const tickUIDs = [];
            const tickCoordinates = [];
            let numberSmallTicks = scaleSize;
            if (scaleSize >= 50) {
                numberSmallTicks = scaleSize / 10;
            }
            const tickSpacing = canvasScaleSize / numberSmallTicks;
            for (let i = 0; i < numberSmallTicks - 1; i++) {
                const locationOffset = {
                    bottom: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), 5],
                    ],
                    top: [
                        [tickSpacing * (i + 1), 0],
                        [tickSpacing * (i + 1), -5],
                    ],
                    left: [
                        [0, tickSpacing * (i + 1)],
                        [-5, tickSpacing * (i + 1)],
                    ],
                    right: [
                        [0, tickSpacing * (i + 1)],
                        [5, tickSpacing * (i + 1)],
                    ],
                };
                tickIds.push(`${annotationUID}-tick${i}`);
                tickUIDs.push(`tick${i}`);
                if ((i + 1) % 5 == 0) {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][0][0],
                            leftTick[1][1] + locationOffset[location][0][1],
                        ],
                    ]);
                }
                else {
                    tickCoordinates.push([
                        [
                            leftTick[0][0] + locationOffset[location][0][0],
                            leftTick[0][1] + locationOffset[location][0][1],
                        ],
                        [
                            leftTick[1][0] + locationOffset[location][1][0],
                            leftTick[1][1] + locationOffset[location][1][1],
                        ],
                    ]);
                }
            }
            return { tickIds, tickUIDs, tickCoordinates };
        };
        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {
            let worldCoordinates;
            let topBottomVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet[0], pointSet[1]);
            topBottomVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topBottomVec);
            let topRightVec = gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), pointSet[2], pointSet[0]);
            topRightVec = gl_matrix_esm/* vec3.normalize */.eR.normalize(gl_matrix_esm/* vec3.create */.eR.create(), topRightVec);
            const midpointLocation = {
                bottom: [pointSet[1], pointSet[2]],
                top: [pointSet[0], pointSet[3]],
                right: [pointSet[2], pointSet[3]],
                left: [pointSet[0], pointSet[1]],
            };
            const midpoint = gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpointLocation[location][0], midpointLocation[location][0])
                .map((i) => i / 2);
            const offset = scaleSize /
                2 /
                Math.sqrt(Math.pow(topBottomVec[0], 2) +
                    Math.pow(topBottomVec[1], 2) +
                    Math.pow(topBottomVec[2], 2));
            if (location == 'top' || location == 'bottom') {
                worldCoordinates = [
                    gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                    gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topRightVec.map((i) => i * offset)),
                ];
            }
            else if (location == 'left' || location == 'right') {
                worldCoordinates = [
                    gl_matrix_esm/* vec3.add */.eR.add(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                    gl_matrix_esm/* vec3.subtract */.eR.subtract(gl_matrix_esm/* vec3.create */.eR.create(), midpoint, topBottomVec.map((i) => i * offset)),
                ];
            }
            return worldCoordinates;
        };
        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {
            let scaleCanvasCoordinates;
            if (location == 'top' || location == 'bottom') {
                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];
                scaleCanvasCoordinates = [
                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],
                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],
                ];
            }
            else if (location == 'left' || location == 'right') {
                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];
                scaleCanvasCoordinates = [
                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],
                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],
                ];
            }
            return scaleCanvasCoordinates;
        };
        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {
            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);
            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);
            const locationBounds = {
                bottom: [-vReduction, -hReduction],
                top: [vReduction, hReduction],
                left: [vReduction, hReduction],
                right: [-vReduction, -hReduction],
            };
            const canvasBounds = {
                bottom: [canvasSize.height, canvasSize.width],
                top: [0, canvasSize.width],
                left: [canvasSize.height, 0],
                right: [canvasSize.height, canvasSize.width],
            };
            return {
                height: canvasBounds[location][0] + locationBounds[location][0],
                width: canvasBounds[location][1] + locationBounds[location][1],
            };
        };
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.editData || !this.editData.viewport) {
            return;
        }
        const location = this.configuration.scaleLocation;
        const { viewport } = enabledElement;
        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];
        const canvas = enabledElement.viewport.canvas;
        const renderStatus = false;
        if (!viewport) {
            return renderStatus;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        const canvasSize = {
            width: canvas.width / window.devicePixelRatio || 1,
            height: canvas.height / window.devicePixelRatio || 1,
        };
        const topLeft = annotation.data.handles.points[0];
        const topRight = annotation.data.handles.points[1];
        const bottomLeft = annotation.data.handles.points[2];
        const bottomRight = annotation.data.handles.points[3];
        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];
        const worldWidthViewport = gl_matrix_esm/* vec3.distance */.eR.distance(bottomLeft, bottomRight);
        const worldHeightViewport = gl_matrix_esm/* vec3.distance */.eR.distance(topLeft, bottomLeft);
        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);
        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);
        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));
        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);
        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);
        const { annotationUID } = annotation;
        styleSpecifier.annotationUID = annotationUID;
        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
        const color = this.getStyle('color', styleSpecifier, annotation);
        const shadow = this.getStyle('shadow', styleSpecifier, annotation);
        const scaleId = `${annotationUID}-scaleline`;
        const scaleLineUID = '1';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, scaleId);
        const leftTickId = `${annotationUID}-left`;
        const leftTickUID = '2';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, leftTickId);
        const rightTickId = `${annotationUID}-right`;
        const rightTickUID = '3';
        (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {
            color,
            width: lineWidth,
            lineDash,
            shadow,
        }, rightTickId);
        const locationTextOffest = {
            bottom: [-10, -42],
            top: [-12, -35],
            left: [-40, -20],
            right: [-50, -20],
        };
        const textCanvasCoordinates = [
            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],
            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],
        ];
        const textBoxLines = this._getTextLines(scaleSize);
        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);
        for (let i = 0; i < tickUIDs.length; i++) {
            (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {
                color,
                width: lineWidth,
                lineDash,
                shadow,
            }, tickIds[i]);
        }
        const textUID = 'text0';
        (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {
            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            fontSize: '14px',
            lineDash: '2,3',
            lineWidth: '1',
            shadow: true,
            color: color,
        });
        return renderStatus;
    }
    _getTextLines(scaleSize) {
        let scaleSizeDisplayValue;
        let scaleSizeUnits;
        if (scaleSize >= 50) {
            scaleSizeDisplayValue = scaleSize / 10;
            scaleSizeUnits = ' cm';
        }
        else {
            scaleSizeDisplayValue = scaleSize;
            scaleSizeUnits = ' mm';
        }
        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];
        return textLines;
    }
}
ScaleOverlayTool.toolName = 'ScaleOverlay';
/* harmony default export */ const tools_ScaleOverlayTool = ((/* unused pure expression or super */ null && (ScaleOverlayTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool/CircleSculptCursor.js
var CircleSculptCursor = __webpack_require__(16175);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/distancePointToContour.js
var distancePointToContour = __webpack_require__(13271);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js












class SculptorTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            minSpacing: 1,
            referencedToolNames: [
                'PlanarFreehandROI',
                'PlanarFreehandContourSegmentationTool',
            ],
            toolShape: 'circle',
            referencedToolName: 'PlanarFreehandROI',
            updateCursorSize: 'dynamic',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.registeredShapes = new Map();
        this.isActive = false;
        this.commonData = {
            activeAnnotationUID: null,
            viewportIdsToRender: [],
            isEditingOpenContour: false,
            canvasLocation: undefined,
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.configureToolSize(evt);
            this.selectFreehandTool(eventData);
            if (this.commonData.activeAnnotationUID === null) {
                return;
            }
            this.isActive = true;
            (0,elementCursor.hideElementCursor)(element);
            this.activateModify(element);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === enums.ToolModes.Active) {
                this.configureToolSize(evt);
                this.updateCursor(evt);
            }
            else {
                this.commonData.canvasLocation = undefined;
            }
        };
        this.endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const config = this.configuration;
            const enabledElement = (0,esm.getEnabledElement)(element);
            this.isActive = false;
            this.deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngineId, viewportId } = enabledElement;
            const toolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (toolInstance.configuration.calculateStats) {
                activeAnnotation.invalidated = true;
            }
            (0,helpers_state.triggerAnnotationModified)(activeAnnotation, element, enums.ChangeTypes.HandlesUpdated);
        };
        this.dragCallback = (evt) => {
            const eventData = evt.detail;
            const element = eventData.element;
            this.updateCursor(evt);
            const annotations = this.filterSculptableAnnotationsForElement(element);
            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
            if (!annotations?.length || !this.isActive) {
                return;
            }
            const points = activeAnnotation.data.contour.polyline;
            this.sculpt(eventData, points);
        };
        this.registerShapes(CircleSculptCursor/* default */.A.shapeName, CircleSculptCursor/* default */.A);
        this.setToolShape(this.configuration.toolShape);
    }
    registerShapes(shapeName, shapeClass) {
        const shape = new shapeClass();
        this.registeredShapes.set(shapeName, shape);
    }
    sculpt(eventData, points) {
        const config = this.configuration;
        const element = eventData.element;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        this.sculptData = {
            mousePoint: eventData.currentPoints.world,
            mouseCanvasPoint: eventData.currentPoints.canvas,
            deltaWorld: eventData.deltaPoints.world,
            points,
            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),
            element: element,
        };
        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);
        if (pushedHandles.first !== undefined) {
            this.insertNewHandles(pushedHandles);
        }
    }
    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {
        const { element } = this.sculptData;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const nextHandleIndex = contourIndex(i + 1, points.length);
        const currentCanvasPoint = viewport.worldToCanvas(points[i]);
        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);
        const distanceToNextHandle = math.point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);
        if (distanceToNextHandle > maxSpacing) {
            indicesToInsertAfter.push(i);
        }
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const element = eventData.element;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine, viewport } = enabledElement;
        this.commonData.viewportIdsToRender = [viewport.id];
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);
        this.commonData.canvasLocation = eventData.currentPoints.canvas;
        if (this.isActive) {
            activeAnnotation.highlighted = true;
        }
        else {
            const cursorShape = this.registeredShapes.get(this.selectedShape);
            const canvasCoords = eventData.currentPoints.canvas;
            if (this.configuration.updateCursorSize === 'dynamic') {
                cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);
            }
        }
        (0,triggerAnnotationRenderForViewportIds/* triggerAnnotationRenderForViewportIds */.t)(this.commonData.viewportIdsToRender);
    }
    filterSculptableAnnotationsForElement(element) {
        const config = this.configuration;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngineId, viewportId } = enabledElement;
        const sculptableAnnotations = [];
        const toolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);
        config.referencedToolNames.forEach((referencedToolName) => {
            const annotations = (0,stateManagement/* getAnnotations */.Rh)(referencedToolName, element);
            if (annotations) {
                sculptableAnnotations.push(...annotations);
            }
        });
        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);
    }
    configureToolSize(evt) {
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.configureToolSize(evt);
    }
    insertNewHandles(pushedHandles) {
        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);
        let newIndexModifier = 0;
        for (let i = 0; i < indicesToInsertAfter?.length; i++) {
            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;
            this.insertHandleRadially(insertIndex);
            newIndexModifier++;
        }
    }
    findNewHandleIndices(pushedHandles) {
        const { points, maxSpacing } = this.sculptData;
        const indicesToInsertAfter = [];
        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {
            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);
        }
        return indicesToInsertAfter;
    }
    insertHandleRadially(insertIndex) {
        const { points } = this.sculptData;
        if (insertIndex > points.length - 1 &&
            this.commonData.isEditingOpenContour) {
            return;
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        const previousIndex = insertIndex - 1;
        const nextIndex = contourIndex(insertIndex, points.length);
        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);
        const handleData = insertPosition;
        points.splice(insertIndex, 0, handleData);
    }
    selectFreehandTool(eventData) {
        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);
        if (closestAnnotationUID === undefined) {
            return;
        }
        this.commonData.activeAnnotationUID = closestAnnotationUID;
    }
    getClosestFreehandToolOnElement(eventData) {
        const { element } = eventData;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const config = this.configuration;
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const canvasPoints = eventData.currentPoints.canvas;
        const closest = {
            distance: Infinity,
            toolIndex: undefined,
            annotationUID: undefined,
        };
        for (let i = 0; i < annotations?.length; i++) {
            if (annotations[i].isLocked || !annotations[i].isVisible) {
                continue;
            }
            const distanceFromTool = (0,distancePointToContour/* distancePointToContour */.X)(viewport, annotations[i], canvasPoints);
            if (distanceFromTool === -1) {
                continue;
            }
            if (distanceFromTool < closest.distance) {
                closest.distance = distanceFromTool;
                closest.toolIndex = i;
                closest.annotationUID = annotations[i].annotationUID;
            }
        }
        this.commonData.isEditingOpenContour =
            !annotations[closest.toolIndex].data.contour.closed;
        config.referencedToolName =
            annotations[closest.toolIndex].metadata.toolName;
        return closest.annotationUID;
    }
    activateModify(element) {
        element.addEventListener(enums.Events.MOUSE_UP, this.endCallback);
        element.addEventListener(enums.Events.MOUSE_CLICK, this.endCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this.dragCallback);
        element.addEventListener(enums.Events.TOUCH_TAP, this.endCallback);
        element.addEventListener(enums.Events.TOUCH_END, this.endCallback);
        element.addEventListener(enums.Events.TOUCH_DRAG, this.dragCallback);
    }
    deactivateModify(element) {
        element.removeEventListener(enums.Events.MOUSE_UP, this.endCallback);
        element.removeEventListener(enums.Events.MOUSE_CLICK, this.endCallback);
        element.removeEventListener(enums.Events.MOUSE_DRAG, this.dragCallback);
        element.removeEventListener(enums.Events.TOUCH_TAP, this.endCallback);
        element.removeEventListener(enums.Events.TOUCH_END, this.endCallback);
        element.removeEventListener(enums.Events.TOUCH_DRAG, this.dragCallback);
    }
    setToolShape(toolShape) {
        this.selectedShape =
            this.registeredShapes.get(toolShape) ?? CircleSculptCursor/* default */.A.shapeName;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        const { viewport } = enabledElement;
        const { element } = viewport;
        const viewportIdsToRender = this.commonData.viewportIdsToRender;
        if (!this.commonData.canvasLocation ||
            this.mode !== enums.ToolModes.Active ||
            !viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const annotations = this.filterSculptableAnnotationsForElement(element);
        if (!annotations?.length) {
            return;
        }
        const styleSpecifier = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: enabledElement.viewport.id,
        };
        let color = (0,helpers/* getStyleProperty */.h)('color', styleSpecifier, enums.AnnotationStyleStates.Default, this.mode);
        if (this.isActive) {
            color = (0,helpers/* getStyleProperty */.h)('color', styleSpecifier, enums.AnnotationStyleStates.Highlighted, this.mode);
        }
        const cursorShape = this.registeredShapes.get(this.selectedShape);
        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {
            color,
        });
    }
}
const contourIndex = (i, length) => {
    return (i + length) % length;
};
SculptorTool.toolName = 'SculptorTool';
/* harmony default export */ const tools_SculptorTool = ((/* unused pure expression or super */ null && (SculptorTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js



const DIRECTIONS = {
    X: [1, 0, 0],
    Y: [0, 1, 0],
    Z: [0, 0, 1],
    CUSTOM: [],
};
class VolumeRotateTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            direction: DIRECTIONS.Z,
            rotateIncrementDegrees: 30,
        },
    }) {
        super(toolProps, defaultToolProps);
    }
    mouseWheelCallback(evt) {
        const { element, wheel } = evt.detail;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { direction, rotateIncrementDegrees } = this.configuration;
        const camera = viewport.getCamera();
        const { viewUp, position, focalPoint } = camera;
        const { direction: deltaY } = wheel;
        const [cx, cy, cz] = focalPoint;
        const [ax, ay, az] = direction;
        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;
        const newPosition = [0, 0, 0];
        const newFocalPoint = [0, 0, 0];
        const newViewUp = [0, 0, 0];
        const transform = gl_matrix_esm/* mat4.identity */.pB.identity(new Float32Array(16));
        gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [cx, cy, cz]);
        gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix_esm/* mat4.translate */.pB.translate(transform, transform, [-cx, -cy, -cz]);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newPosition, position, transform);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newFocalPoint, focalPoint, transform);
        gl_matrix_esm/* mat4.identity */.pB.identity(transform);
        gl_matrix_esm/* mat4.rotate */.pB.rotate(transform, transform, angle, [ax, ay, az]);
        gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4(newViewUp, viewUp, transform);
        viewport.setCamera({
            position: newPosition,
            viewUp: newViewUp,
            focalPoint: newFocalPoint,
        });
        viewport.render();
    }
}
VolumeRotateTool.toolName = 'VolumeRotateMouseWheel';
/* harmony default export */ const tools_VolumeRotateTool = ((/* unused pure expression or super */ null && (VolumeRotateTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js
var BidirectionalTool = __webpack_require__(25072);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js












class LabelTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'Label'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback,
            changeTextCallback,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotationUID } = annotation;
            const point = annotation.data.handles.points[0];
            const annotationCanvasCoordinate = viewport.worldToCanvas(point);
            const dist = gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate);
            if (dist < proximity) {
                return true;
            }
            const svgLayer = element.querySelector('svg');
            if (!svgLayer) {
                return false;
            }
            const textGroup = svgLayer.querySelector(`g[data-annotation-uid="${annotationUID}"]`);
            if (!textGroup) {
                return false;
            }
            const textGroupElement = textGroup;
            const bbox = textGroupElement.getBBox();
            const transform = textGroupElement.getAttribute('transform');
            let translateX = 0;
            let translateY = 0;
            if (transform) {
                const matches = transform.match(/translate\(([-\d.]+)\s+([-\d.]+)\)/);
                if (matches) {
                    translateX = parseFloat(matches[1]);
                    translateY = parseFloat(matches[2]);
                }
            }
            const x = bbox.x + translateX;
            const y = bbox.y + translateY;
            const isNear = canvasCoords[0] >= x &&
                canvasCoords[0] <= x + bbox.width &&
                canvasCoords[1] >= y &&
                canvasCoords[1] <= y + bbox.height;
            return isNear;
        };
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
                offset: [0, 0, 0],
            };
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.configuration.getTextCallback((label) => {
                if (!label) {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                    (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                (0,elementCursor.resetElementCursor)(element);
                annotation.data.label = label;
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            let offset = [0, 0, 0];
            if (currentPoints && currentPoints.world) {
                const initialWorldPos = currentPoints.world;
                const anchorWorldPos = annotation.data.handles.points[0];
                offset = [
                    anchorWorldPos[0] - initialWorldPos[0],
                    anchorWorldPos[1] - initialWorldPos[1],
                    anchorWorldPos[2] - initialWorldPos[2],
                ];
            }
            this.editData = {
                annotation,
                viewportIdsToRender,
                offset,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, offset } = this.editData;
            if (offset) {
                annotation.data.handles.points[0] = [
                    worldPos[0] + offset[0],
                    worldPos[1] + offset[1],
                    worldPos[2] + offset[2],
                ];
            }
            else {
                annotation.data.handles.points[0] = [...worldPos];
            }
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.LabelChange);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const point = data.handles.points[0];
                styleSpecifier.annotationUID = annotationUID;
                const canvasCoordinates = viewport.worldToCanvas(point);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!data.label) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                const textBoxUID = '1';
                (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [data.label], canvasCoordinates, {
                    ...options,
                    padding: 0,
                });
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, position, label, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const { viewPlaneNormal, viewUp } = viewport.getCamera();
        const instance = new this();
        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                label,
                handles: {
                    points: [position],
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...options,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    handleSelectedCallback(_evt, _annotation, _handle, _interactionType) { }
    _doneChangingTextCallback(element, annotation, updatedLabel) {
        annotation.data.label = updatedLabel;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        (0,helpers_state.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
LabelTool.toolName = 'Label';
/* harmony default export */ const annotation_LabelTool = ((/* unused pure expression or super */ null && (LabelTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js

















const { transformWorldToIndex: LengthTool_transformWorldToIndex } = esm.utilities;
class LengthTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'Length'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [{ key: 'z' }],
                },
                redo: {
                    method: 'redo',
                    bindings: [{ key: 'y' }],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const dataId = `${annotationUID}-line`;
                const lineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = LengthTool_transformWorldToIndex(imageData, worldPos1);
            const index2 = LengthTool_transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
            const length = this._calculateLength(worldPos1, worldPos2) / scale;
            if (this._isInsideVolume(index1, index2, dimensions)) {
                this.isHandleOutsideImage = false;
            }
            else {
                this.isHandleOutsideImage = true;
            }
            cachedStats[targetId] = {
                length,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { length, unit } = cachedVolumeStats;
    if (length === undefined || length === null || isNaN(length)) {
        return;
    }
    const textLines = [`${esm.utilities.roundNumber(length)} ${unit}`];
    return textLines;
}
/* harmony default export */ const annotation_LengthTool = ((/* unused pure expression or super */ null && (LengthTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js

















const { transformWorldToIndex: HeightTool_transformWorldToIndex } = esm.utilities;
class HeightTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'Height'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: HeightTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const enabledElement = (0,esm.getEnabledElement)(element);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const heightUID = '0';
                (0,drawingSvg.drawHeight)(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash: lineDash,
                });
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateHeight(pos1, pos2) {
        const dx = pos2[0] - pos1[0];
        const dy = pos2[1] - pos1[1];
        const dz = pos2[2] - pos1[2];
        if (dx == 0) {
            if (dy != 0) {
                return Math.abs(dz);
            }
            else {
                return 0;
            }
        }
        else if (dy == 0) {
            return Math.abs(dz);
        }
        else if (dz == 0) {
            return Math.abs(dy);
        }
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData, dimensions } = image;
            const index1 = HeightTool_transformWorldToIndex(imageData, worldPos1);
            const index2 = HeightTool_transformWorldToIndex(imageData, worldPos2);
            const handles = [index1, index2];
            const { scale, unit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
            const height = this._calculateHeight(worldPos1, worldPos2) / scale;
            const outside = this._isInsideVolume(index1, index2, dimensions);
            this.isHandleOutsideImage = outside;
            cachedStats[targetId] = {
                height,
                unit,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function HeightTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { height, unit } = cachedVolumeStats;
    if (height === undefined || height === null || isNaN(height)) {
        return;
    }
    const textLines = [`${esm.utilities.roundNumber(height)} ${unit}`];
    return textLines;
}
/* harmony default export */ const annotation_HeightTool = ((/* unused pure expression or super */ null && (HeightTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js
var isViewportPreScaled = __webpack_require__(18990);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js















const { transformWorldToIndex: ProbeTool_transformWorldToIndex } = esm.utilities;
class ProbeTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'Probe'; }
    static { this.probeDefaults = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: ProbeTool_defaultGetTextLines,
            handleRadius: '6',
            textCanvasOffset: {
                x: 6,
                y: -6,
            },
        },
    }; }
    constructor(toolProps = {}, defaultToolProps) {
        super(toolProps, base/* AnnotationTool */.EC.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,esm.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const annotationUID = annotation.annotationUID;
                const data = annotation.data;
                const point = data.handles.points[0];
                const canvasCoordinates = viewport.worldToCanvas(point);
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats) {
                    data.cachedStats = {};
                }
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].value === null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        index: null,
                        value: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, enums.ChangeTypes.StatsUpdated);
                }
                else if (annotation.invalidated) {
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const handleGroupUID = '0';
                (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (textLines) {
                    const textCanvasCoordinates = [
                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,
                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,
                    ];
                    const textUID = '0';
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);
                }
            }
            return renderStatus;
        };
    }
    isPointNearTool(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        return gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
    }
    toolSelectedCallback() { }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { data } = annotation;
        const point = data.handles.points[0];
        const annotationCanvasCoordinate = viewport.worldToCanvas(point);
        const near = gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, annotationCanvasCoordinate) < proximity;
        if (near === true) {
            return point;
        }
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = enums.ChangeTypes.StatsUpdated) {
        const data = annotation.data;
        const { renderingEngineId, viewport } = enabledElement;
        const { element } = viewport;
        const worldPos = data.handles.points[0];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const pixelUnitsOptions = {
                isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
            };
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { dimensions, imageData, metadata, voxelManager } = image;
            const modality = metadata.Modality;
            let ijk = ProbeTool_transformWorldToIndex(imageData, worldPos);
            ijk = gl_matrix_esm/* vec3.round */.eR.round(ijk, ijk);
            if (esm.utilities.indexWithinDimensions(ijk, dimensions)) {
                this.isHandleOutsideImage = false;
                let value = voxelManager.getAtIJKPoint(ijk);
                if (targetId.startsWith('imageId:')) {
                    const imageId = targetId.split('imageId:')[1];
                    const imageURI = esm.utilities.imageIdToURI(imageId);
                    const viewports = esm.utilities.getViewportsWithImageURI(imageURI);
                    const viewport = viewports[0];
                    ijk[2] = viewport.getCurrentImageIdIndex();
                }
                let modalityUnit;
                if (modality === 'US') {
                    const calibratedResults = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [
                        ijk,
                    ]);
                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);
                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);
                    modalityUnit = hasEnhancedRegionValues
                        ? calibratedResults.units
                        : 'raw';
                }
                else {
                    modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                }
                cachedStats[targetId] = {
                    index: ijk,
                    value,
                    Modality: modality,
                    modalityUnit,
                };
                annotation.invalidated = true;
            }
            else {
                this.isHandleOutsideImage = true;
                cachedStats[targetId] = {
                    index: ijk,
                    Modality: modality,
                };
            }
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, changeType);
        }
        return cachedStats;
    }
}
function ProbeTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined || !index) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    if (value instanceof Array && modalityUnit instanceof Array) {
        for (let i = 0; i < value.length; i++) {
            textLines.push(`${esm.utilities.roundNumber(value[i])} ${modalityUnit[i]}`);
        }
    }
    else {
        textLines.push(`${esm.utilities.roundNumber(value)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const annotation_ProbeTool = (ProbeTool);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js






class DragProbeTool extends annotation_ProbeTool {
    static { this.toolName = 'DragProbe'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: DragProbeTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.postMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                invalidated: true,
                highlighted: true,
                isVisible: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId,
                },
                data: {
                    label: '',
                    handles: { points: [[...worldPos]] },
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                newAnnotation: true,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.postTouchStartCallback = (evt) => {
            return this.postMouseDownCallback(evt);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            if (!this.editData) {
                return renderStatus;
            }
            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const annotation = this.editData.annotation;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const point = data.handles.points[0];
            const canvasCoordinates = viewport.worldToCanvas(point);
            styleSpecifier.annotationUID = annotationUID;
            const { color } = this.getAnnotationStyle({
                annotation,
                styleSpecifier,
            });
            if (!data.cachedStats[targetId] ||
                data.cachedStats[targetId].value === null) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    index: null,
                    value: null,
                };
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._calculateCachedStats(annotation, renderingEngine, enabledElement);
            }
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const handleGroupUID = '0';
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });
            renderStatus = true;
            const textLines = this.configuration.getTextLines(data, targetId);
            if (textLines) {
                const textCanvasCoordinates = [
                    canvasCoordinates[0] + 6,
                    canvasCoordinates[1] - 6,
                ];
                const textUID = '0';
                (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));
            }
            return renderStatus;
        };
    }
}
function DragProbeTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { index, value, modalityUnit } = cachedVolumeStats;
    if (value === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);
    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);
    return textLines;
}
/* harmony default export */ const annotation_DragProbeTool = ((/* unused pure expression or super */ null && (DragProbeTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js
var RectangleROITool = __webpack_require__(4010);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js
var getWorldWidthAndHeightFromTwoPoints = __webpack_require__(62514);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js + 2 modules
var ellipse = __webpack_require__(87009);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/index.js
var basic = __webpack_require__(73262);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js






















const { transformWorldToIndex: EllipticalROITool_transformWorldToIndex } = esm.utilities;
class EllipticalROITool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'EllipticalROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: EllipticalROITool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                centerWorld: worldPos,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const [bottom, top, left, right] = canvasCoordinates;
            const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
            const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
            const angle = Math.atan2(left[1] - right[1], left[0] - right[0]);
            const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
            const minorEllipse = {
                center,
                xRadius: (w - proximity) / 2,
                yRadius: (h - proximity) / 2,
                angle,
            };
            const majorEllipse = {
                center,
                xRadius: (w + proximity) / 2,
                yRadius: (h + proximity) / 2,
                angle,
            };
            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);
            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);
            if (pointInMajorEllipse && !pointInMinorEllipse) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            let centerCanvas;
            let centerWorld;
            let canvasWidth;
            let canvasHeight;
            let originalHandleCanvas;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                const { viewport } = (0,esm.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = viewport;
                handleIndex = points.findIndex((p) => p === handle);
                const pointsCanvas = points.map(worldToCanvas);
                originalHandleCanvas = pointsCanvas[handleIndex];
                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);
                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);
                centerCanvas = [
                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,
                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,
                ];
                centerWorld = canvasToWorld(centerCanvas);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                canvasWidth,
                canvasHeight,
                centerWorld,
                originalHandleCanvas,
                movingTextBox,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];
            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];
            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];
            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { viewport } = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = viewport;
            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            const { data } = annotation;
            const { points } = data.handles;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            if (handleIndex === 0 || handleIndex === 1) {
                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - dYCanvas,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + dYCanvas,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];
                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;
                const canvasLeft = [
                    centerCanvas[0] - newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + newHalfCanvasWidth,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
            }
            else {
                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
                const canvasLeft = [
                    centerCanvas[0] - dXCanvas,
                    centerCanvas[1],
                ];
                const canvasRight = [
                    centerCanvas[0] + dXCanvas,
                    centerCanvas[1],
                ];
                points[2] = canvasToWorld(canvasLeft);
                points[3] = canvasToWorld(canvasRight);
                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];
                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;
                const canvasBottom = [
                    centerCanvas[0],
                    centerCanvas[1] - newHalfCanvasHeight,
                ];
                const canvasTop = [
                    centerCanvas[0],
                    centerCanvas[1] + newHalfCanvasHeight,
                ];
                points[0] = canvasToWorld(canvasBottom);
                points[1] = canvasToWorld(canvasTop);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasCorners = ((0,ellipse.getCanvasEllipseCorners)(canvasCoordinates));
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-ellipse`;
                const ellipseUID = '0';
                (0,drawingSvg.drawEllipseByCoordinates)(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);
                    if (minRadius > 3 * centerPointRadius) {
                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,ellipse.getCanvasEllipseCorners)(canvasCoordinates));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = EllipticalROITool_transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = EllipticalROITool_transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const center = [
                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,
                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,
                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,
                    ];
                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
                    const ellipseObj = {
                        center,
                        xRadius: xRadius < esm.EPSILON / 2 ? 0 : xRadius,
                        yRadius: yRadius < esm.EPSILON / 2 ? 0 : yRadius,
                        zRadius: zRadius < esm.EPSILON / 2 ? 0 : zRadius,
                    };
                    const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                    const handles = [pos1Index, pos2Index];
                    const { scale, unit, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
                    const aspect = (0,getCalibratedUnits/* getCalibratedAspect */.CQ)(image);
                    const area = Math.abs(Math.PI *
                        (worldWidth / scale / 2) *
                        (worldHeight / aspect / scale / 2));
                    const pixelUnitsOptions = {
                        isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    let pointsInShape;
                    if (voxelManager) {
                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                            isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                            boundsIJK,
                            imageData,
                            returnPoints: this.configuration.storePointData,
                        });
                    }
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        max: stats.max?.value,
                        min: stats.min?.value,
                        stdDev: stats.stdDev?.value,
                        statsArray: stats.array,
                        pointsInShape,
                        isEmptyArea,
                        areaUnit,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    _pointInEllipseCanvas(ellipse, location) {
        const { xRadius, yRadius, center, angle } = ellipse;
        const rotLocation = gl_matrix_esm/* vec2.rotate */.Zc.rotate(gl_matrix_esm/* vec2.create */.Zc.create(), location, center, -angle);
        if (xRadius <= 0.0 || yRadius <= 0.0) {
            return false;
        }
        const normalized = [rotLocation[0] - center[0], rotLocation[1] - center[1]];
        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +
            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=
            1.0;
        return inEllipse;
    }
    _getCanvasEllipseCenter(ellipseCanvasPoints) {
        const [bottom, top, left, right] = ellipseCanvasPoints;
        const topLeft = [left[0], top[1]];
        const bottomRight = [right[0], bottom[1]];
        return [
            (topLeft[0] + bottomRight[0]) / 2,
            (topLeft[1] + bottomRight[1]) / 2,
        ];
    }
}
function EllipticalROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, min } = cachedVolumeStats;
    const textLines = [];
    if (esm.utilities.isNumber(area)) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (esm.utilities.isNumber(mean)) {
        textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(max)) {
        textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(min)) {
        textLines.push(`Min: ${esm.utilities.roundNumber(min)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(stdDev)) {
        textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const annotation_EllipticalROITool = ((/* unused pure expression or super */ null && (EllipticalROITool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js























const { transformWorldToIndex: CircleROITool_transformWorldToIndex } = esm.utilities;
class CircleROITool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'CircleROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            storePointData: false,
            centerPointRadius: 0,
            calculateStats: true,
            getTextLines: CircleROITool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
            simplified: true,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            this.isDrawing = true;
            let points;
            if (this.configuration.simplified) {
                points = [[...worldPos], [...worldPos]];
            }
            else {
                points = [
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                ];
            }
            const annotation = this.createAnnotation(evt, points);
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { points } = annotation.data.handles;
            const canvasHandles = points.map((p) => viewport.worldToCanvas(p));
            const canvasCenter = canvasHandles[0];
            const radius = (0,circle.getCanvasCircleRadius)([canvasCenter, canvasHandles[1]]);
            const radiusPoint = (0,circle.getCanvasCircleRadius)([canvasCenter, canvasCoords]);
            return Math.abs(radiusPoint - radius) < proximity / 2;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const { world: worldPos, canvas: currentCanvasPoints } = currentPoints;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            const centerWorld = data.handles.points[0];
            const centerCanvas = viewport.worldToCanvas(centerWorld);
            if (this.configuration.simplified) {
                data.handles.points[1] = worldPos;
            }
            else {
                const radiusCanvas = gl_matrix_esm/* vec2.distance */.Zc.distance(centerCanvas, currentCanvasPoints);
                data.handles.points[0] = [...centerWorld];
                data.handles.points[1] = canvasToWorld([
                    centerCanvas[0],
                    centerCanvas[1] - radiusCanvas,
                ]);
                data.handles.points[2] = canvasToWorld([
                    centerCanvas[0],
                    centerCanvas[1] + radiusCanvas,
                ]);
                data.handles.points[3] = canvasToWorld([
                    centerCanvas[0] - radiusCanvas,
                    centerCanvas[1],
                ]);
                data.handles.points[4] = canvasToWorld([
                    centerCanvas[0] + radiusCanvas,
                    centerCanvas[1],
                ]);
            }
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragHandle(evt);
                annotation.invalidated = true;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation, handleIndex } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const { currentPoints, deltaPoints } = eventDetail;
            if (handleIndex === 0) {
                const worldPosDelta = deltaPoints.world;
                points.forEach((point) => {
                    gl_matrix_esm/* vec3.add */.eR.add(point, point, worldPosDelta);
                });
            }
            else {
                const centerWorld = points[0];
                const centerCanvas = worldToCanvas(centerWorld);
                const currentCanvasPoint = currentPoints.canvas;
                const newRadiusCanvas = gl_matrix_esm/* vec2.distance */.Zc.distance(centerCanvas, currentCanvasPoint);
                points[1] = canvasToWorld([
                    centerCanvas[0],
                    centerCanvas[1] - newRadiusCanvas,
                ]);
                points[2] = canvasToWorld([
                    centerCanvas[0],
                    centerCanvas[1] + newRadiusCanvas,
                ]);
                points[3] = canvasToWorld([
                    centerCanvas[0] - newRadiusCanvas,
                    centerCanvas[1],
                ]);
                points[4] = canvasToWorld([
                    centerCanvas[0] + newRadiusCanvas,
                    centerCanvas[1],
                ]);
            }
            annotation.invalidated = true;
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                annotation.highlighted = false;
                annotation.data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,circle.getCanvasCircleRadius)([center, canvasCoordinates[1]]);
                const canvasCorners = (0,circle.getCanvasCircleCorners)([
                    center,
                    canvasCoordinates[1],
                ]);
                const { centerPointRadius } = this.configuration;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                        radius: null,
                        radiusUnit: null,
                        perimeter: null,
                    };
                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
                    if (viewport instanceof esm.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = esm.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = esm.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    if (this.configuration.simplified) {
                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                    }
                    else {
                        activeHandleCanvasCoords = canvasCoordinates;
                    }
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-circle`;
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                if (this.configuration.calculateStats) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, targetId);
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    let canvasTextBoxCoords;
                    if (!data.handles.textBox.hasMoved) {
                        canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [center, canvasCoordinates[1]], {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            const { element } = viewport;
            const wasInvalidated = annotation.invalidated;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const canvasCenter = canvasCoordinates[0];
            const canvasTop = canvasCoordinates[1];
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            const [topLeftCanvas, bottomRightCanvas] = ((0,circle.getCanvasCircleCorners)([canvasCenter, canvasTop]));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = CircleROITool_transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = CircleROITool_transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const center = points[0];
                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;
                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;
                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;
                    const ellipseObj = {
                        center,
                        xRadius: xRadius < esm.EPSILON / 2 ? 0 : xRadius,
                        yRadius: yRadius < esm.EPSILON / 2 ? 0 : yRadius,
                        zRadius: zRadius < esm.EPSILON / 2 ? 0 : zRadius,
                    };
                    const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;
                    const handles = [pos1Index, pos2Index];
                    const { scale, unit, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, handles);
                    const aspect = (0,getCalibratedUnits/* getCalibratedAspect */.CQ)(image);
                    const area = Math.abs(Math.PI *
                        (worldWidth / scale / 2) *
                        (worldHeight / aspect / scale / 2));
                    const pixelUnitsOptions = {
                        isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    let pointsInShape;
                    if (voxelManager) {
                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                            isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS, { fast: true }),
                            boundsIJK,
                            imageData,
                            returnPoints: this.configuration.storePointData,
                        });
                    }
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        max: stats.max?.value,
                        min: stats.min?.value,
                        pointsInShape,
                        stdDev: stats.stdDev?.value,
                        statsArray: stats.array,
                        isEmptyArea,
                        areaUnit,
                        radius: worldWidth / 2 / scale,
                        radiusUnit: unit,
                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            annotation.invalidated = false;
            if (wasInvalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
}
function CircleROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { radius, radiusUnit, area, mean, stdDev, max, min, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;
    const textLines = [];
    if (esm.utilities.isNumber(radius)) {
        const radiusLine = isEmptyArea
            ? `Radius: Oblique not supported`
            : `Radius: ${esm.utilities.roundNumber(radius)} ${radiusUnit}`;
        textLines.push(radiusLine);
    }
    if (esm.utilities.isNumber(area)) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (esm.utilities.isNumber(mean)) {
        textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(max)) {
        textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(min)) {
        textLines.push(`Min: ${esm.utilities.roundNumber(min)} ${modalityUnit}`);
    }
    if (esm.utilities.isNumber(stdDev)) {
        textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const annotation_CircleROITool = (CircleROITool);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js













const CROSSHAIR_SIZE = 5;
class ETDRSGridTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'ETDRSGrid'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            degrees: [45, 135, 225, 315],
            diameters: [10, 30, 60],
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    ...viewport.getViewReference({ points: [worldPos] }),
                },
                data: {
                    label: '',
                    handles: {
                        points: [[...worldPos]],
                    },
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const center = viewport.worldToCanvas(points[0]);
            const radius = (0,circle.getCanvasCircleRadius)([center, canvasCoords]);
            if (Math.abs(radius) < proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            (0,elementCursor.hideElementCursor)(element);
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            data.handles.points = [
                canvasToWorld(currentCanvasPoints),
                canvasToWorld(currentCanvasPoints),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            const { deltaPoints } = eventDetail;
            const worldPosDelta = deltaPoints.world;
            const points = data.handles.points;
            points.forEach((point) => {
                point[0] += worldPosDelta[0];
                point[1] += worldPosDelta[1];
                point[2] += worldPosDelta[2];
            });
            annotation.invalidated = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._dragHandle = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;
            const { annotation } = this.editData;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => worldToCanvas(p));
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];
            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];
            const canvasCenter = currentCanvasPoints;
            const canvasEnd = [
                canvasCoordinates[1][0] + dXCanvas,
                canvasCoordinates[1][1] + dYCanvas,
            ];
            points[0] = canvasToWorld(canvasCenter);
            points[1] = canvasToWorld(canvasEnd);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                const { renderingEngine } = (0,esm.getEnabledElement)(element);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragDrawCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles } = data;
                const { points } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                let lineUID = `${annotationUID}-crosshair-vertical`;
                let start = [center[0], center[1] + CROSSHAIR_SIZE];
                let end = [center[0], center[1] - CROSSHAIR_SIZE];
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                lineUID = `${annotationUID}-crosshair-horizontal`;
                start = [center[0] + CROSSHAIR_SIZE, center[1]];
                end = [center[0] - CROSSHAIR_SIZE, center[1]];
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                    color,
                    lineDash,
                    lineWidth,
                });
                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));
                for (let i = 0; i < diametersCanvas.length; i++) {
                    const dataId = `${annotationUID}-circle-${i}`;
                    const circleUID = `${annotationUID}-circle-${i}`;
                    (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {
                        color,
                        lineDash,
                        lineWidth,
                    }, dataId);
                }
                const degreesRad = (x) => (x * Math.PI) / 180;
                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));
                for (let i = 0; i < angleRadians.length; i++) {
                    const lineUID = `${annotationUID}-line-${i}`;
                    const start = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],
                    ];
                    const end = [
                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],
                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],
                    ];
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, start, end, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                renderStatus = true;
            }
            return renderStatus;
        };
    }
    worldMeasureToCanvas(measurement, viewport) {
        const p1 = viewport.canvasToWorld([
            viewport.canvas.width / 2,
            viewport.canvas.height / 2,
        ]);
        const { viewUp } = viewport.getCamera();
        const p2 = gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(gl_matrix_esm/* vec3.create */.eR.create(), p1, viewUp, measurement);
        const p1Canvas = viewport.worldToCanvas(p1);
        const p2Canvas = viewport.worldToCanvas(p2);
        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +
            Math.pow(p2Canvas[1] - p1Canvas[1], 2));
        return distance;
    }
}
/* harmony default export */ const annotation_ETDRSGridTool = ((/* unused pure expression or super */ null && (ETDRSGridTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js
var getMouseModifier = __webpack_require__(76910);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js
var ContourAnnotation = __webpack_require__(93126);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js + 1 modules
var ContourSegmentationBaseTool = __webpack_require__(36320);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js





















const SPLINE_MIN_POINTS = 3;
const SPLINE_CLICK_CLOSE_CURVE_DIST = 10;
const DEFAULT_SPLINE_CONFIG = {
    resolution: 20,
    controlPointAdditionDistance: 6,
    controlPointDeletionDistance: 6,
    showControlPointsConnectors: false,
    controlPointAdditionEnabled: true,
    controlPointDeletionEnabled: true,
};
var SplineTypesEnum;
(function (SplineTypesEnum) {
    SplineTypesEnum["Cardinal"] = "CARDINAL";
    SplineTypesEnum["Linear"] = "LINEAR";
    SplineTypesEnum["CatmullRom"] = "CATMULLROM";
    SplineTypesEnum["BSpline"] = "BSPLINE";
})(SplineTypesEnum || (SplineTypesEnum = {}));
var SplineToolActions;
(function (SplineToolActions) {
    SplineToolActions["AddControlPoint"] = "addControlPoint";
    SplineToolActions["DeleteControlPoint"] = "deleteControlPoint";
})(SplineToolActions || (SplineToolActions = {}));
const splineToolNames = [
    'CatmullRomSplineROI',
    'LinearSplineROI',
    'BSplineROI',
    'CardinalSplineROI',
];
class SplineROITool extends ContourSegmentationBaseTool/* default */.A {
    static { this.toolName = 'SplineROI'; }
    static { this.SplineTypes = SplineTypesEnum; }
    static { this.Actions = SplineToolActions; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            calculateStats: true,
            simplifiedSpline: false,
            getTextLines: SplineROITool_defaultGetTextLines,
            contourHoleAdditionModifierKey: enums.KeyboardBindings.Shift,
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            spline: {
                configuration: {
                    [SplineTypesEnum.Cardinal]: {
                        Class: CardinalSpline,
                        scale: 0.5,
                    },
                    [SplineTypesEnum.CatmullRom]: {
                        Class: CatmullRomSpline,
                    },
                    [SplineTypesEnum.Linear]: {
                        Class: LinearSpline,
                    },
                    [SplineTypesEnum.BSpline]: {
                        Class: BSpline,
                        controlPointAdditionEnabled: false,
                        controlPointDeletionEnabled: false,
                        showControlPointsConnectors: true,
                    },
                },
                type: SplineTypesEnum.CatmullRom,
                drawPreviewEnabled: true,
                enableTwoPointPreview: false,
                lastControlPointDeletionKeys: ['Backspace', 'Delete'],
            },
            actions: {
                [SplineToolActions.AddControlPoint]: {
                    method: 'addControlPointCallback',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Primary,
                            modifierKey: enums.KeyboardBindings.Shift,
                        },
                    ],
                },
                [SplineToolActions.DeleteControlPoint]: {
                    method: 'deleteControlPointCallback',
                    bindings: [
                        {
                            mouseButton: enums.MouseBindings.Primary,
                            modifierKey: enums.KeyboardBindings.Ctrl,
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.splineToolNames = [
            'CatmullRomSplineROI',
            'LinearSplineROI',
            'BSplineROI',
            'CardinalSplineROI',
        ];
        this.isHandleOutsideImage = false;
        this.fireChangeOnUpdate = null;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const { instance: spline } = annotation.data.spline;
            return spline.isPointNearCurve(canvasCoords, proximity);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            annotation.autoGenerated = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));
            const { imageData, dimensions } = image;
            this.isHandleOutsideImage = data.handles.points
                .map((p) => esm.utilities.transformWorldToIndex(imageData, p))
                .some((index) => !esm.utilities.indexWithinDimensions(index, dimensions));
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            const changeType = newAnnotation
                ? enums.ChangeTypes.Completed
                : enums.ChangeTypes.HandlesUpdated;
            if (!this.fireChangeOnUpdate) {
                this.fireChangeOnUpdate = {
                    annotationUID: annotation.annotationUID,
                    changeType,
                    contourHoleProcessingEnabled,
                };
            }
            else {
                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;
                this.fireChangeOnUpdate.changeType = changeType;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._keyDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const key = eventDetail.key ?? '';
            const { lastControlPointDeletionKeys } = this.configuration.spline;
            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);
            if (!deleteLastPoint) {
                return;
            }
            const { annotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length === SPLINE_MIN_POINTS) {
                this.cancel(element);
                return;
            }
            else {
                const controlPointIndex = data.handles.points.length - 1;
                this._deleteControlPointByIndex(element, annotation, controlPointIndex);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { drawPreviewEnabled } = this.configuration.spline;
            if (!drawPreviewEnabled) {
                return;
            }
            const { element } = evt.detail;
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === enums.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender } = this.editData;
            const { data } = annotation;
            if (data.contour.closed) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const { canvas: canvasPoint, world: worldPoint } = currentPoints;
            let closeContour = data.handles.points.length >= 2 && doubleClick;
            let addNewPoint = true;
            if (data.handles.points.length) {
                this.createMemo(element, annotation, {
                    newAnnotation: data.handles.points.length === 1,
                });
            }
            if (data.handles.points.length >= 3) {
                this.createMemo(element, annotation);
                const { instance: spline } = data.spline;
                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
                if (closestControlPoint?.index === 0) {
                    addNewPoint = false;
                    closeContour = true;
                }
            }
            if (addNewPoint) {
                data.handles.points.push(worldPoint);
            }
            data.contour.closed = data.contour.closed || closeContour;
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (data.contour.closed) {
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                this.moveAnnotation(annotation, worldPosDelta);
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {
            const eventType = enums.Events.ANNOTATION_COMPLETED;
            const eventDetail = {
                annotation,
                changeType: enums.ChangeTypes.Completed,
                contourHoleProcessingEnabled,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {
            if (changeType === enums.ChangeTypes.Completed) {
                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);
            }
            else {
                this.triggerAnnotationModified(annotation, enabledElement, changeType);
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.KEY_DOWN, this._keyDownCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.KEY_DOWN, this._keyDownCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.spline.instance.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.addControlPointCallback = (evt, annotation) => {
            const { data } = annotation;
            const splineType = data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointAdditionDistance;
            if (splineConfig.controlPointAdditionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { instance: spline } = data.spline;
            const canvasPos = evt.detail.currentPoints.canvas;
            const closestPointInfo = spline.getClosestPoint(canvasPos);
            if (closestPointInfo.distance > maxDist) {
                return;
            }
            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);
            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));
            annotation.invalidated = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.deleteControlPointCallback = (evt, annotation) => {
            const splineType = annotation.data.spline.type;
            const splineConfig = this._getSplineConfig(splineType);
            const maxDist = splineConfig.controlPointDeletionDistance;
            if (splineConfig.controlPointDeletionEnabled === false) {
                return;
            }
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const { canvas: canvasPos } = currentPoints;
            const { instance: spline } = annotation.data.spline;
            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);
            if (!closestControlPoint) {
                return;
            }
            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = esm.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = esm.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, enums.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
        this.annotationCompletedBinded = this.annotationCompleted.bind(this);
    }
    annotationCompleted(evt) {
        const { sourceAnnotation: annotation } = evt.detail;
        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||
            !this.configuration.simplifiedSpline ||
            !this.isContourSegmentationTool()) {
            return;
        }
        (0,contourSegmentation.convertContourSegmentationAnnotation)(annotation);
    }
    initializeListeners() {
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);
    }
    removeListeners() {
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);
    }
    onSetToolEnabled() {
        this.initializeListeners();
    }
    onSetToolActive() {
        this.initializeListeners();
    }
    onSetToolDisabled() {
        this.removeListeners();
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { canvas: canvasPos } = currentPoints;
        const contourHoleProcessingEnabled = (0,getMouseModifier/* default */.A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        const annotation = this.createAnnotation(evt);
        this.isDrawing = true;
        this.addAnnotation(annotation, element);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
            lastCanvasPoint: canvasPos,
            contourHoleProcessingEnabled,
        };
        this._activateDraw(element);
        evt.preventDefault();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        return annotation;
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,elementCursor.resetElementCursor)(element);
        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
        if (newAnnotation) {
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        }
        super.cancelAnnotation(annotation);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        this.editData = null;
        return annotation.annotationUID;
    }
    isContourSegmentationTool() {
        return false;
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { element } = viewport;
        const annotation = renderContext.annotation;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const { points: controlPoints, activeHandleIndex } = handles;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;
        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));
        const { drawPreviewEnabled } = this.configuration.spline;
        const splineType = annotation.data.spline.type;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = annotation.data.spline.instance;
        const childAnnotations = (0,annotationState.getChildAnnotations)(annotation);
        const missingAnnotation = childAnnotations.findIndex((it) => !it);
        if (missingAnnotation !== -1) {
            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);
        }
        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));
        splineAnnotationsGroup.forEach((annotation) => {
            const spline = this._updateSplineInstance(element, annotation);
            const splinePolylineCanvas = spline.getPolylinePoints();
            this.updateContourPolyline(annotation, {
                points: splinePolylineCanvas,
                closed: data.contour.closed,
                targetWindingDirection: ContourAnnotation/* ContourWindingDirection */.W.Clockwise,
            }, viewport, { updateWindingDirection: data.contour.closed });
        });
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId].areaUnit == null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        let activeHandleCanvasCoords;
        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {
            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
        }
        if (activeHandleCanvasCoords || newAnnotation || highlighted) {
            const handleGroupUID = '0';
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                color,
                lineWidth,
                handleRadius: '3',
            });
        }
        if (drawPreviewEnabled &&
            spline.numControlPoints >= 1 &&
            this.editData?.lastCanvasPoint &&
            !spline.closed) {
            const { lastCanvasPoint } = this.editData;
            const { enableTwoPointPreview } = this.configuration.spline;
            if (spline.numControlPoints === 1 && enableTwoPointPreview) {
                const firstPoint = canvasCoordinates[0];
                const previewPolylinePoints = [firstPoint, lastCanvasPoint];
                (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {
                    color: '#9EA0CA',
                    lineDash: lineDash,
                    lineWidth: 1,
                });
            }
            else if (spline.numControlPoints > 1) {
                const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);
                (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {
                    color: '#9EA0CA',
                    lineDash: lineDash,
                    lineWidth: 1,
                });
            }
        }
        if (splineConfig.showControlPointsConnectors) {
            const controlPointsConnectors = [...canvasCoordinates];
            if (spline.closed) {
                controlPointsConnectors.push(canvasCoordinates[0]);
            }
            (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {
                color: 'rgba(255, 255, 255, 0.5)',
                lineWidth: 1,
            });
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {
            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);
            this.fireChangeOnUpdate = null;
        }
        annotation.invalidated = false;
        return true;
    }
    createInterpolatedSplineControl(annotation) {
        if (annotation.data.handles.points?.length) {
            return;
        }
        const { polyline } = annotation.data.contour;
        if (!polyline || !polyline.length) {
            return;
        }
        annotation.data.handles.points = [];
        const { points } = annotation.data.handles;
        const increment = Math.max(10, Math.floor(polyline.length / 20));
        for (let i = 0; i < polyline.length - increment; i += increment) {
            points.push(polyline[i]);
        }
        points.push(polyline[polyline.length - 1]);
    }
    isSplineAnnotation(annotation) {
        return splineToolNames.includes(annotation?.metadata?.toolName);
    }
    createSplineObjectFromType(annotation, splineType) {
        const splineConfig = this._getSplineConfig(splineType);
        const spline = new splineConfig.Class();
        annotation.data.spline = {
            type: splineConfig.type,
            instance: spline,
            resolution: splineConfig.resolution,
        };
    }
    createAnnotation(evt) {
        const contourAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const { type: splineType } = this.configuration.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const spline = new splineConfig.Class();
        const createSpline = () => ({
            type: splineConfig.type,
            instance: spline,
            resolution: splineConfig.resolution,
        });
        let onInterpolationComplete;
        if (this.configuration.interpolation?.enabled) {
            onInterpolationComplete = (annotation) => {
                annotation.data.spline ||= createSpline();
                this.createInterpolatedSplineControl(annotation);
            };
        }
        return esm.utilities.deepMerge(contourAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
                spline: createSpline(),
                cachedStats: {},
            },
            onInterpolationComplete,
        });
    }
    _deleteControlPointByIndex(element, annotation, controlPointIndex) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { points: controlPoints } = annotation.data.handles;
        if (controlPoints.length === 3) {
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        }
        else {
            controlPoints.splice(controlPointIndex, 1);
        }
        const { renderingEngine } = enabledElement;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        annotation.invalidated = true;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
    }
    _isSplineROIAnnotation(annotation) {
        return !!annotation.data?.spline;
    }
    _getSplineConfig(type) {
        const { configuration: config } = this;
        const splineConfigs = config.spline.configuration;
        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);
    }
    _updateSplineInstance(element, annotation) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { data } = annotation;
        const { type: splineType, instance: spline } = annotation.data.spline;
        const splineConfig = this._getSplineConfig(splineType);
        const worldPoints = data.handles.points;
        const canvasPoints = worldPoints.map(worldToCanvas);
        const resolution = splineConfig.resolution !== undefined
            ? parseInt(splineConfig.resolution)
            : undefined;
        const scale = splineConfig.scale !== undefined
            ? parseFloat(splineConfig.scale)
            : undefined;
        spline.setControlPoints(canvasPoints);
        spline.closed = !!data.contour.closed;
        if (!spline.fixedResolution &&
            resolution !== undefined &&
            spline.resolution !== resolution) {
            spline.resolution = resolution;
            annotation.invalidated = true;
        }
        if (spline instanceof CardinalSpline &&
            !spline.fixedScale &&
            scale !== undefined &&
            spline.scale !== scale) {
            spline.scale = scale;
            annotation.invalidated = true;
        }
        return spline;
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (points.length < SPLINE_MIN_POINTS) {
            console.warn('Spline requires at least 3 control points');
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);
        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;
        const splineConfig = instance._getSplineConfig(splineType);
        const SplineClass = splineConfig.Class;
        const splineInstance = new SplineClass();
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
                label: '',
                cachedStats: {},
                spline: {
                    type: splineType,
                    instance: splineInstance,
                },
                contour: {
                    closed: true,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: true,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
}
function SplineROITool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}
/* harmony default export */ const annotation_SplineROITool = (SplineROITool);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js




class SplineContourSegmentationTool extends annotation_SplineROITool {
    static { this.toolName = 'SplineContourSegmentationTool'; }
    constructor(toolProps) {
        const initialProps = esm.utilities.deepMerge({
            configuration: {
                calculateStats: false,
            },
        }, toolProps);
        super(initialProps);
        this.annotationCutMergeCompletedBinded =
            this.annotationCutMergeCompleted.bind(this);
    }
    isContourSegmentationTool() {
        return true;
    }
    initializeListeners() {
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);
    }
    removeListeners() {
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);
    }
    annotationCutMergeCompleted(evt) {
        const { sourceAnnotation: annotation } = evt.detail;
        if (this.toolName !== annotation?.metadata?.toolName ||
            !this.splineToolNames.includes(annotation?.metadata?.toolName) ||
            !this.configuration.simplifiedSpline) {
            return;
        }
        (0,contourSegmentation.convertContourSegmentationAnnotation)(annotation);
    }
}
/* harmony default export */ const annotation_SplineContourSegmentationTool = ((/* unused pure expression or super */ null && (SplineContourSegmentationTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js
var PlanarFreehandROITool = __webpack_require__(28220);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js
var PlanarFreehandContourSegmentationTool = __webpack_require__(37590);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js
var findHandlePolylineIndex = __webpack_require__(98013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LivewireScissors.js + 1 modules
var LivewireScissors = __webpack_require__(78044);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/livewire/LiveWirePath.js
var LiveWirePath = __webpack_require__(38776);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js



















const CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;
class LivewireContourTool extends ContourSegmentationBaseTool/* default */.A {
    static { this.toolName = 'LivewireContour'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextLines: LivewireContourTool_defaultGetTextLines,
            calculateStats: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: enums.KeyboardBindings.Shift,
            snapHandleNearby: 2,
            interpolation: {
                enabled: false,
                nearestEdge: 2,
                showInterpolationPolyline: false,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            actions: {
                cancelInProgress: {
                    method: 'cancelInProgress',
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const proximitySquared = proximity * proximity;
            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            let startPoint = canvasPoints[canvasPoints.length - 1];
            for (let i = 0; i < canvasPoints.length; i++) {
                const endPoint = canvasPoints[i];
                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);
                if (distanceToPointSquared <= proximitySquared) {
                    return true;
                }
                startPoint = endPoint;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            this._activateModify(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                const { points } = data.handles;
                handleIndex = points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt, clearAnnotation = false) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;
            const { data } = annotation;
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            if ((this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) ||
                clearAnnotation) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
                this.clearEditData();
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                return;
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            const changeType = newAnnotation
                ? enums.ChangeTypes.Completed
                : enums.ChangeTypes.HandlesUpdated;
            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);
            this.clearEditData();
        };
        this.triggerChangeEvent = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {
            if (changeType === enums.ChangeTypes.Completed) {
                (0,helpers_state.triggerContourAnnotationCompleted)(annotation, contourHoleProcessingEnabled);
            }
            else {
                (0,helpers_state.triggerAnnotationModified)(annotation, enabledElement.viewport.element, changeType);
            }
        };
        this._mouseDownCallback = (evt) => {
            const doubleClick = evt.type === enums.Events.MOUSE_DOUBLE_CLICK;
            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;
            if (this.editData.closed) {
                return;
            }
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;
            let worldPos = worldPosOriginal;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const controlPoints = this.editData.currentPath.getControlPoints();
            let closePath = controlPoints.length >= 2 && doubleClick;
            this.doneEditMemo();
            this.createMemo(element, annotation, {
                newAnnotation: newAnnotation && controlPoints.length === 1,
            });
            if (controlPoints.length >= 2) {
                const closestHandlePoint = {
                    index: -1,
                    distSquared: Infinity,
                };
                for (let i = 0, len = controlPoints.length; i < len; i++) {
                    const controlPoint = controlPoints[i];
                    const worldControlPoint = sliceToWorld(controlPoint);
                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);
                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);
                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&
                        distSquared < closestHandlePoint.distSquared) {
                        closestHandlePoint.distSquared = distSquared;
                        closestHandlePoint.index = i;
                    }
                }
                if (closestHandlePoint.index === 0) {
                    closePath = true;
                }
            }
            const { snapHandleNearby } = this.configuration;
            if (snapHandleNearby && !this.editData.closed) {
                const currentPath = new LiveWirePath/* LivewirePath */.j();
                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);
                const pathPoints = this.scissors.findPathToPoint(snapPoint);
                currentPath.addPoints(pathPoints);
                currentPath.prependPath(this.editData.confirmedPath);
                worldPos = sliceToWorld(snapPoint);
                this.editData.currentPath = currentPath;
            }
            this.editData.closed = this.editData.closed || closePath;
            this.editData.confirmedPath = this.editData.currentPath;
            const lastPoint = this.editData.currentPath.getLastPoint();
            this.editData.confirmedPath.addControlPoint(lastPoint);
            annotation.data.handles.points.push(sliceToWorld(lastPoint));
            this.scissors.startSearch(worldToSlice(worldPos));
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (this.editData.closed) {
                this.updateAnnotation(this.editData.confirmedPath);
                this._endCallback(evt);
            }
            evt.preventDefault();
        };
        this._mouseMoveCallback = (evt) => {
            const { element, currentPoints } = evt.detail;
            const { world: worldPos, canvas: canvasPos } = currentPoints;
            const { renderingEngine } = (0,esm.getEnabledElement)(element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData.lastCanvasPoint = canvasPos;
            const { width: imgWidth, height: imgHeight } = this.scissors;
            const { worldToSlice } = this.editData;
            const slicePoint = worldToSlice(worldPos);
            if (slicePoint[0] < 0 ||
                slicePoint[1] < 0 ||
                slicePoint[0] >= imgWidth ||
                slicePoint[1] >= imgHeight) {
                return;
            }
            const pathPoints = this.scissors.findPathToPoint(slicePoint);
            const currentPath = new LiveWirePath/* LivewirePath */.j();
            currentPath.addPoints(pathPoints);
            currentPath.prependPath(this.editData.confirmedPath);
            this.editData.currentPath = currentPath;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                console.warn('Drag annotation not implemented');
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                this.editHandle(worldPos, element, annotation, handleIndex);
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            if (newAnnotation) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.doneEditMemo();
            this.scissors = null;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._mouseMoveCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums.Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._mouseDownCallback);
        };
        this._calculateCachedStats = (annotation, element) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const data = annotation.data;
            if (!data.contour.closed) {
                return;
            }
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            const { cachedStats } = data;
            const { polyline: points } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix_esm/* vec3.distance */.eR.distance(originalWorldPoint, deltaYPoint);
                const { imageData } = image;
                const { scale, areaUnit } = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, () => {
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);
                    const topLeftBBWorld = viewport.canvasToWorld([
                        canvasMinX,
                        canvasMinY,
                    ]);
                    const topLeftBBIndex = esm.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = esm.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;
                area *= deltaInX * deltaInY;
                cachedStats[targetId] = {
                    Modality: metadata.Modality,
                    area,
                    areaUnit: areaUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                this.triggerAnnotationModified(annotation, enabledElement, enums.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {
            const data = annotation.data;
            const targetId = this.getTargetId(viewport);
            if (!data.contour.closed || !textboxStyle.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = 'textBox';
            const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        this.triggerAnnotationModified = (annotation, enabledElement, changeType = enums.ChangeTypes.StatsUpdated) => {
            const { viewportId, renderingEngineId } = enabledElement;
            const eventType = enums.Events.ANNOTATION_MODIFIED;
            const eventDetail = {
                annotation,
                viewportId,
                renderingEngineId,
                changeType,
            };
            (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const viewportImageData = viewport.getImageData();
        const { imageData: vtkImageData } = viewportImageData;
        let worldToSlice;
        let sliceToWorld;
        let width;
        let height;
        let scalarData;
        if (!(viewport instanceof esm.VolumeViewport)) {
            width = viewportImageData.dimensions[0];
            height = viewportImageData.dimensions[1];
            worldToSlice = (point) => {
                const ijkPoint = esm.utilities.transformWorldToIndex(vtkImageData, point);
                return [ijkPoint[0], ijkPoint[1]];
            };
            sliceToWorld = (point) => esm.utilities.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);
            scalarData = viewportImageData.scalarData;
        }
        else if (viewport instanceof esm.VolumeViewport) {
            const sliceImageData = esm.utilities.getCurrentVolumeViewportSlice(viewport);
            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;
            worldToSlice = (point) => {
                const ijkPoint = esm.utilities.transformWorldToIndex(vtkImageData, point);
                const slicePoint = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);
                return [slicePoint[0], slicePoint[1]];
            };
            sliceToWorld = (point) => {
                const ijkPoint = gl_matrix_esm/* vec3.transformMat4 */.eR.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);
                return esm.utilities.transformIndexToWorld(vtkImageData, ijkPoint);
            };
            scalarData = sliceImageData.scalarData;
            width = sliceImageData.width;
            height = sliceImageData.height;
        }
        else {
            throw new Error('Viewport not supported');
        }
        scalarData = esm.utilities.convertToGrayscale(scalarData, width, height);
        const { voiRange } = viewport.getProperties();
        const startPos = worldToSlice(worldPos);
        this.scissors = LivewireScissors/* LivewireScissors */.f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
        if (nextPos) {
            this.scissorsNext = LivewireScissors/* LivewireScissors */.f.createInstanceFromRawPixelData(scalarData, width, height, voiRange);
            this.scissorsNext.startSearch(worldToSlice(nextPos));
        }
        this.scissors.startSearch(startPos);
        const newAnnotation = !nextPos;
        const confirmedPath = new LiveWirePath/* LivewirePath */.j();
        const currentPath = new LiveWirePath/* LivewirePath */.j();
        const currentPathNext = newAnnotation ? undefined : new LiveWirePath/* LivewirePath */.j();
        confirmedPath.addPoint(startPos);
        confirmedPath.addControlPoint(startPos);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        const lastCanvasPoint = viewport.worldToCanvas(worldPos);
        this.editData = {
            annotation,
            viewportIdsToRender,
            newAnnotation,
            hasMoved: false,
            lastCanvasPoint,
            confirmedPath,
            currentPath,
            confirmedPathNext: currentPathNext,
            closed: false,
            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,
            worldToSlice,
            sliceToWorld,
            contourHoleProcessingEnabled,
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const annotation = this.createAnnotation(evt);
        const contourHoleProcessingEnabled = (0,getMouseModifier/* default */.A)(evt.detail.event) ===
            this.configuration.contourHoleAdditionModifierKey;
        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);
        this.addAnnotation(annotation, element);
        this._activateDraw(element);
        evt.preventDefault();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(this.editData.viewportIdsToRender);
        return annotation;
    }
    clearEditData() {
        this.editData = null;
        this.scissors = null;
        this.scissorsNext = null;
        this.isDrawing = false;
    }
    editHandle(worldPos, element, annotation, handleIndex) {
        const { data } = annotation;
        const { points: handlePoints } = data.handles;
        const { length: numHandles } = handlePoints;
        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];
        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];
        if (!this.editData?.confirmedPathNext) {
            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);
            const { polyline } = data.contour;
            const confirmedPath = new LiveWirePath/* LivewirePath */.j();
            const confirmedPathNext = new LiveWirePath/* LivewirePath */.j();
            const { worldToSlice } = this.editData;
            const previousIndex = (0,findHandlePolylineIndex/* default */.A)(annotation, handleIndex - 1);
            const nextIndex = (0,findHandlePolylineIndex/* default */.A)(annotation, handleIndex + 1);
            if (nextIndex === -1 || previousIndex === -1) {
                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);
            }
            if (handleIndex === 0) {
                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));
            }
            else {
                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));
                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));
            }
            this.editData.confirmedPath = confirmedPath;
            this.editData.confirmedPathNext = confirmedPathNext;
        }
        const { editData, scissors } = this;
        const { worldToSlice, sliceToWorld } = editData;
        const { activeHandleIndex } = data.handles;
        if (activeHandleIndex === null || activeHandleIndex === undefined) {
            data.handles.activeHandleIndex = handleIndex;
        }
        else if (activeHandleIndex !== handleIndex) {
            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);
        }
        const slicePos = worldToSlice(worldPos);
        if (slicePos[0] < 0 ||
            slicePos[0] >= scissors.width ||
            slicePos[1] < 0 ||
            slicePos[1] >= scissors.height) {
            return;
        }
        handlePoints[handleIndex] = sliceToWorld(slicePos);
        const pathPointsLeft = scissors.findPathToPoint(slicePos);
        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);
        const currentPath = new LiveWirePath/* LivewirePath */.j();
        currentPath.prependPath(editData.confirmedPath);
        if (handleIndex !== 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        currentPath.addPoints(pathPointsRight.reverse());
        currentPath.appendPath(editData.confirmedPathNext);
        if (handleIndex === 0) {
            currentPath.addPoints(pathPointsLeft);
        }
        editData.currentPath = currentPath;
        annotation.invalidated = true;
        editData.hasMoved = true;
        editData.closed = true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        this.updateAnnotation(this.editData?.currentPath);
        return super.renderAnnotation(enabledElement, svgDrawingHelper);
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const contourSegmentationAnnotation = super.createAnnotation(evt);
        const { world: worldPos } = evt.detail.currentPoints;
        const annotation = esm.utilities.deepMerge(contourSegmentationAnnotation, {
            data: {
                handles: {
                    points: [[...worldPos]],
                },
            },
        });
        return annotation;
    }
    cancelInProgress(element, config, evt) {
        if (!this.editData) {
            this.undo();
            return;
        }
        this._endCallback(evt, true);
    }
    renderAnnotationInstance(renderContext) {
        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;
        const { viewport } = enabledElement;
        const { element } = viewport;
        const { worldToCanvas } = viewport;
        const { annotationUID, data, highlighted } = annotation;
        const { handles } = data;
        const newAnnotation = this.editData?.newAnnotation;
        const { lineWidth, lineDash, color } = annotationStyle;
        if (highlighted ||
            (newAnnotation &&
                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {
            const handleGroupUID = '0';
            const canvasHandles = handles.points.map(worldToCanvas);
            (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {
                color,
                lineDash,
                lineWidth,
            });
        }
        super.renderAnnotationInstance(renderContext);
        if (!data.cachedStats[targetId] ||
            data.cachedStats[targetId]?.areaUnit === null) {
            data.cachedStats[targetId] = {
                Modality: null,
                area: null,
                areaUnit: null,
            };
            this._calculateCachedStats(annotation, element);
        }
        else if (annotation.invalidated) {
            this._throttledCalculateCachedStats(annotation, element);
        }
        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);
        return true;
    }
    updateAnnotation(livewirePath) {
        if (!this.editData || !livewirePath) {
            return;
        }
        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;
        let { pointArray: imagePoints } = livewirePath;
        if (imagePoints.length > 1) {
            imagePoints = [...imagePoints, imagePoints[0]];
        }
        const targetWindingDirection = newAnnotation && closed ? ContourAnnotation/* ContourWindingDirection */.W.Clockwise : undefined;
        this.updateContourPolyline(annotation, {
            points: imagePoints,
            closed,
            targetWindingDirection,
        }, {
            canvasToWorld: sliceToWorld,
            worldToCanvas: worldToSlice,
        });
    }
}
/* harmony default export */ const annotation_LivewireContourTool = (LivewireContourTool);
function LivewireContourTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, areaUnit } = cachedVolumeStats;
    const textLines = [];
    if (area) {
        const areaLine = `Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    return textLines;
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js






class LivewireContourSegmentationTool extends annotation_LivewireContourTool {
    static { this.toolName = 'LivewireContourSegmentationTool'; }
    updateInterpolatedAnnotation(annotation, enabledElement) {
        if (this.editData ||
            !annotation.invalidated ||
            !annotation.data.handles.interpolationSources) {
            return;
        }
        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;
        queueMicrotask(() => {
            if (!annotation.data.handles.interpolationSources) {
                return;
            }
            const { points } = annotation.data.handles;
            const { element } = enabledElement.viewport;
            this.setupBaseEditData(points[0], element, annotation);
            const { length: count } = points;
            const { scissors } = this;
            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;
            annotation.data.handles.originalPoints = points;
            const { worldToSlice, sliceToWorld } = this.editData;
            const handleSmoothing = [];
            if (nearestEdge) {
                let lastPoint = worldToSlice(points[points.length - 1]);
                points.forEach((point, hIndex) => {
                    const testPoint = worldToSlice(point);
                    lastPoint = testPoint;
                    handleSmoothing.push(testPoint);
                    scissors.startSearch(lastPoint);
                    scissors.findPathToPoint(testPoint);
                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));
                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);
                    if (!esm.utilities.isEqual(testPoint, minPoint)) {
                        handleSmoothing[hIndex] = minPoint;
                        lastPoint = minPoint;
                        points[hIndex] = sliceToWorld(minPoint);
                    }
                });
            }
            const acceptedPath = new LiveWirePath/* LivewirePath */.j();
            for (let i = 0; i < count; i++) {
                scissors.startSearch(worldToSlice(points[i]));
                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));
                acceptedPath.addPoints(path);
            }
            this.updateAnnotation(acceptedPath);
            this.scissors = null;
            this.scissorsNext = null;
            this.editData = null;
            annotation.data.handles.interpolationSources = null;
            if (repeatInterpolation) {
                (0,helpers_state.triggerAnnotationModified)(annotation, enabledElement.viewport.element, enums.ChangeTypes.InterpolationUpdated);
            }
        });
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        const { annotationUID } = annotation;
        const { viewport } = enabledElement;
        const { worldToCanvas } = viewport;
        const { showInterpolationPolyline } = this.configuration.interpolation || {};
        this.updateInterpolatedAnnotation?.(annotation, enabledElement);
        const { originalPolyline } = annotation.data.contour;
        const rendered = super.renderAnnotationInstance(renderContext);
        if (showInterpolationPolyline &&
            originalPolyline &&
            annotation.autoGenerated) {
            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);
            polylineCanvasPoints.push(polylineCanvasPoints[0]);
            (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {
                color: '#70ffff',
                lineWidth: 1,
                fillOpacity: 0,
            });
        }
        return rendered;
    }
    isContourSegmentationTool() {
        return true;
    }
}
/* harmony default export */ const annotation_LivewireContourSegmentationTool = ((/* unused pure expression or super */ null && (LivewireContourSegmentationTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js















class ArrowAnnotateTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'ArrowAnnotate'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            getTextCallback: ArrowAnnotateTool_getTextCallback,
            changeTextCallback: ArrowAnnotateTool_changeTextCallback,
            preventHandleOutsideImage: false,
            arrowFirst: true,
            arrowHeadStyle: 'legacy',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            this.startGroupRecording();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const { arrowFirst } = this.configuration;
            const annotation = this.createAnnotation(evt, [[...worldPos], [...worldPos]], {
                data: {
                    handles: {
                        arrowFirst,
                    },
                },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            if (newAnnotation) {
                this.configuration.getTextCallback((label) => {
                    if (!label) {
                        (0,annotationState.removeAnnotation)(annotation.annotationUID);
                        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                        this.editData = null;
                        this.isDrawing = false;
                        return;
                    }
                    annotation.data.label = label;
                    (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });
                    setAnnotationLabel(annotation, element, label);
                    this.endGroupRecording();
                    this.doneEditMemo();
                    (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                });
            }
            else if (!movingTextBox) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this.touchTapCallback = (evt) => {
            if (evt.detail.taps == 2) {
                this.doubleClickCallback(evt);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.editData = null;
            this.isDrawing = false;
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { handles, label } = data;
                const { points, activeHandleIndex } = handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineWidth,
                    });
                }
                const arrowUID = '1';
                if (this.configuration.arrowFirst) {
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                else {
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: lineWidth,
                        lineDash: lineDash,
                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',
                        markerSize,
                    });
                }
                renderStatus = true;
                if (!label) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, [label], textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    static { this.hydrate = (viewportId, points, label, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = this.createAnnotation({
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                label: label || '',
                handles: {
                    points,
                },
            },
            autoGenerated: false,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        });
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _doneChangingTextCallback(element, annotation, updatedLabel) {
        annotation.data.label = updatedLabel;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        (0,helpers_state.triggerAnnotationModified)(annotation, element);
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function ArrowAnnotateTool_getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function ArrowAnnotateTool_changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const annotation_ArrowAnnotateTool = ((/* unused pure expression or super */ null && (ArrowAnnotateTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js
















class AngleTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'Angle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            showAngleArc: false,
            arcOffset: 5,
            preventHandleOutsideImage: false,
            getTextLines: AngleTool_defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2, point3] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            if (!point3) {
                return false;
            }
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const line2 = {
                start: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
                end: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
            };
            const distanceToPoint2 = math_line.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {
                this.editData.handleIndex = 2;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.angleStartedNotYetCompleted = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotation.annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                let lineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length !== 3) {
                    return renderStatus;
                }
                lineUID = '2';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                if (this.configuration.showAngleArc) {
                    const center = canvasCoordinates[1];
                    const offset = this.configuration.arcOffset;
                    const radius = Math.min(math_line.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), math_line.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;
                    const anglePoints = [];
                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);
                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);
                    if (endAngle < startAngle) {
                        endAngle += 2 * Math.PI;
                    }
                    const angleDifference = endAngle - startAngle;
                    if (angleDifference > Math.PI) {
                        const temp = startAngle;
                        startAngle = endAngle;
                        endAngle = temp + 2 * Math.PI;
                    }
                    const segments = 32;
                    for (let i = 0; i <= segments; i++) {
                        const angle = startAngle + (i / segments) * (endAngle - startAngle);
                        anglePoints.push([
                            center[0] + radius * Math.cos(angle),
                            center[1] + radius * Math.sin(angle),
                        ]);
                    }
                    (0,drawingSvg.drawPath)(svgDrawingHelper, annotationUID, '3', anglePoints, {
                        color: color,
                        width: lineWidth,
                        lineDash: angleArcLineDash,
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 3) {
            return;
        }
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[1];
        const worldPos3 = data.handles.points[2];
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const angle = (0,angleBetweenLines/* default */.A)([worldPos1, worldPos2], [worldPos2, worldPos3]);
            const { dimensions, imageData } = this.getTargetImageData(targetId);
            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]
                .map((worldPos) => esm.utilities.transformWorldToIndex(imageData, worldPos))
                .some((index) => !esm.utilities.indexWithinDimensions(index, dimensions));
            cachedStats[targetId] = {
                angle: isNaN(angle) ? 'Incomplete Angle' : angle,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function AngleTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    if (isNaN(angle)) {
        return [`${angle}`];
    }
    const textLines = [
        `${esm.utilities.roundNumber(angle)} ${String.fromCharCode(176)}`,
    ];
    return textLines;
}
/* harmony default export */ const annotation_AngleTool = ((/* unused pure expression or super */ null && (AngleTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js
var midPoint = __webpack_require__(82983);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js



















class CobbAngleTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'CobbAngle'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: CobbAngleTool_defaultGetTextLines,
            showArcLines: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.angleStartedNotYetCompleted) {
                return;
            }
            this.angleStartedNotYetCompleted = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({
                viewport,
                points: data.handles.points,
                canvasCoords,
                proximity,
            });
            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({
                viewport,
                points: annotation.data.handles.points,
                canvasCoords,
                proximity,
            });
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
                isNearFirstLine,
                isNearSecondLine,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {
                (0,elementCursor.resetElementCursor)(element);
                this.editData.handleIndex = data.handles.points.length;
                return;
            }
            this.angleStartedNotYetCompleted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._mouseDownCallback = (evt) => {
            const { annotation, handleIndex } = this.editData;
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const worldPos = currentPoints.world;
            const { data } = annotation;
            if (handleIndex === 1) {
                data.handles.points[1] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[1][0] !== data.handles.points[0][0] ||
                        data.handles.points[1][1] !== data.handles.points[0][0];
                return;
            }
            if (handleIndex === 3) {
                data.handles.points[3] = worldPos;
                this.editData.hasMoved =
                    data.handles.points[3][0] !== data.handles.points[2][0] ||
                        data.handles.points[3][1] !== data.handles.points[2][0];
                this.angleStartedNotYetCompleted = false;
                return;
            }
            this.editData.hasMoved = false;
            (0,elementCursor.hideElementCursor)(element);
            data.handles.points[2] = data.handles.points[3] = worldPos;
            this.editData.handleIndex = data.handles.points.length - 1;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined &&
                (isNearFirstLine || isNearSecondLine)) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                if (isNearFirstLine) {
                    const firstLinePoints = [points[0], points[1]];
                    firstLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                else if (isNearSecondLine) {
                    const secondLinePoints = [points[2], points[3]];
                    secondLinePoints.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                }
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (!this.isDrawing) {
                return;
            }
            this.isDrawing = false;
            this._deactivateDraw(element);
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            if (data.handles.points.length < 4) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.angleStartedNotYetCompleted = false;
            return annotation.annotationUID;
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_START, this._mouseDownCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DOWN, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_START, this._mouseDownCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].angle == null) {
                    data.cachedStats[targetId] = {
                        angle: null,
                        arc1Angle: null,
                        arc2Angle: null,
                        points: {
                            world: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                            canvas: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null,
                            },
                        },
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                const showHandlesAlways = Boolean((0,helpers/* getStyleProperty */.h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color,
                        lineDash,
                        lineWidth,
                    });
                }
                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];
                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];
                let lineUID = 'line1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                renderStatus = true;
                if (canvasCoordinates.length < 4) {
                    return renderStatus;
                }
                lineUID = 'line2';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {
                    color,
                    width: lineWidth,
                    lineDash,
                });
                lineUID = 'linkLine';
                const mid1 = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
                const mid2 = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {
                    color,
                    lineWidth: '1',
                    lineDash: '1,4',
                });
                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;
                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];
                if (this.configuration.showArcLines) {
                    lineUID = 'arc1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {
                        color,
                        lineWidth: '1',
                    });
                    lineUID = 'arc2';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {
                        color,
                        lineWidth: '1',
                    });
                }
                if (!data.cachedStats[targetId]?.angle) {
                    continue;
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = 'cobbAngleText';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
                if (this.configuration.showArcLines) {
                    const arc1TextBoxUID = 'arcAngle1';
                    const arc1TextLine = [
                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch1TextPosCanvas = (0,midPoint/* midPoint2 */.f)(arc1Start, arc1End);
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                    const arc2TextBoxUID = 'arcAngle2';
                    const arc2TextLine = [
                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,
                    ];
                    const arch2TextPosCanvas = (0,midPoint/* midPoint2 */.f)(arc2Start, arc2End);
                    (0,drawingSvg.drawTextBox)(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {
                        ...options,
                        padding: 3,
                    });
                }
            }
            return renderStatus;
        };
        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {
            const [point1, point2, point3, point4] = points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const canvasPoint3 = viewport.worldToCanvas(point3);
            const canvasPoint4 = viewport.worldToCanvas(point4);
            const line1 = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const line2 = {
                start: {
                    x: canvasPoint3[0],
                    y: canvasPoint3[1],
                },
                end: {
                    x: canvasPoint4[0],
                    y: canvasPoint4[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);
            const distanceToPoint2 = math_line.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);
            let isNearFirstLine = false;
            let isNearSecondLine = false;
            if (distanceToPoint <= proximity) {
                isNearFirstLine = true;
            }
            else if (distanceToPoint2 <= proximity) {
                isNearSecondLine = true;
            }
            return {
                distanceToPoint,
                distanceToPoint2,
                isNearFirstLine,
                isNearSecondLine,
            };
        };
        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {
            const linkLine = [mid1, mid2];
            const arc1Angle = (0,angleBetweenLines/* default */.A)(firstLine, linkLine);
            const arc2Angle = (0,angleBetweenLines/* default */.A)(secondLine, linkLine);
            const arc1Side = arc1Angle > 90 ? 1 : 0;
            const arc2Side = arc2Angle > 90 ? 0 : 1;
            const midLinkLine = (0,midPoint/* midPoint2 */.f)(linkLine[0], linkLine[1]);
            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +
                (linkLine[1][1] - linkLine[0][1]) ** 2);
            const ratio = 0.1;
            const midFirstLine = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
            const midSecondLine = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
            const directionVectorStartArc1 = [
                firstLine[arc1Side][0] - midFirstLine[0],
                firstLine[arc1Side][1] - midFirstLine[1],
            ];
            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);
            const normalizedDirectionStartArc1 = [
                directionVectorStartArc1[0] / magnitudeStartArc1,
                directionVectorStartArc1[1] / magnitudeStartArc1,
            ];
            const arc1Start = [
                midFirstLine[0] +
                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,
                midFirstLine[1] +
                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc1 = [
                midLinkLine[0] - mid1[0],
                midLinkLine[1] - mid1[1],
            ];
            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);
            const normalizedDirectionEndArc1 = [
                directionVectorEndArc1[0] / magnitudeEndArc1,
                directionVectorEndArc1[1] / magnitudeEndArc1,
            ];
            const arc1End = [
                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,
                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,
            ];
            const directionVectorStartArc2 = [
                secondLine[arc2Side][0] - midSecondLine[0],
                secondLine[arc2Side][1] - midSecondLine[1],
            ];
            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);
            const normalizedDirectionStartArc2 = [
                directionVectorStartArc2[0] / magnitudeStartArc2,
                directionVectorStartArc2[1] / magnitudeStartArc2,
            ];
            const arc2Start = [
                midSecondLine[0] +
                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,
                midSecondLine[1] +
                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,
            ];
            const directionVectorEndArc2 = [
                midLinkLine[0] - mid2[0],
                midLinkLine[1] - mid2[1],
            ];
            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);
            const normalizedDirectionEndArc2 = [
                directionVectorEndArc2[0] / magnitudeEndArc2,
                directionVectorEndArc2[1] / magnitudeEndArc2,
            ];
            const arc2End = [
                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,
                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,
            ];
            return {
                arc1Start,
                arc1End,
                arc2Start,
                arc2End,
                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,
                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,
            };
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 25, { trailing: true });
    }
    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        if (data.handles.points.length !== 4) {
            return;
        }
        const seg1 = [null, null];
        const seg2 = [null, null];
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < 2; i += 1) {
            for (let j = 2; j < 4; j += 1) {
                const dist = gl_matrix_esm/* vec3.distance */.eR.distance(data.handles.points[i], data.handles.points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    seg1[1] = data.handles.points[i];
                    seg1[0] = data.handles.points[(i + 1) % 2];
                    seg2[0] = data.handles.points[j];
                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];
                }
            }
        }
        const { viewport } = enabledElement;
        const { element } = viewport;
        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const firstLine = [canvasPoints[0], canvasPoints[1]];
        const secondLine = [canvasPoints[2], canvasPoints[3]];
        const mid1 = (0,midPoint/* midPoint2 */.f)(firstLine[0], firstLine[1]);
        const mid2 = (0,midPoint/* midPoint2 */.f)(secondLine[0], secondLine[1]);
        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({
            firstLine,
            secondLine,
            mid1,
            mid2,
        });
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            cachedStats[targetId] = {
                angle: (0,angleBetweenLines/* default */.A)(seg1, seg2),
                arc1Angle,
                arc2Angle,
                points: {
                    canvas: {
                        arc1Start,
                        arc1End,
                        arc2End,
                        arc2Start,
                    },
                    world: {
                        arc1Start: viewport.canvasToWorld(arc1Start),
                        arc1End: viewport.canvasToWorld(arc1End),
                        arc2End: viewport.canvasToWorld(arc2End),
                        arc2Start: viewport.canvasToWorld(arc2Start),
                    },
                },
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function CobbAngleTool_defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { angle } = cachedVolumeStats;
    if (angle === undefined) {
        return;
    }
    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];
    return textLines;
}
/* harmony default export */ const annotation_CobbAngleTool = ((/* unused pure expression or super */ null && (CobbAngleTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js














const { transformWorldToIndex: UltrasoundDirectionalTool_transformWorldToIndex } = esm.utilities;
class UltrasoundDirectionalTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'UltrasoundDirectionalTool'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
            getTextLines: UltrasoundDirectionalTool_defaultGetTextLines,
            displayBothAxesDistances: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            if (this.startedDrawing) {
                return;
            }
            this.startedDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            if (!(viewport instanceof esm.StackViewport)) {
                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');
            }
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const annotation = (this.createAnnotation(evt, [
                [...worldPos],
                [...worldPos],
            ]));
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math.lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            if (this.startedDrawing && data.handles.points.length === 1) {
                this.editData.handleIndex = 1;
                return;
            }
            this.startedDrawing = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                data.handles.points[handleIndex] = [...worldPos];
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                this.startedDrawing = false;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].xValues == null) {
                    data.cachedStats[targetId] = {
                        xValues: [0, 0],
                        yValues: [0, 0],
                        isHorizontal: false,
                        units: [''],
                        isUnitless: false,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let handleGroupUID = '0';
                (0,drawingSvg.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {
                    color,
                }, 0);
                renderStatus = true;
                if (canvasCoordinates.length !== 2) {
                    return renderStatus;
                }
                handleGroupUID = '1';
                (0,drawingSvg.drawHandle)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {
                    color,
                }, 1);
                const isUnitless = data.cachedStats[targetId].isUnitless;
                if (!isUnitless) {
                    const canvasPoint1 = canvasCoordinates[0];
                    const canvasPoint2 = canvasCoordinates[1];
                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                    const isHorizontal = data.cachedStats[targetId].isHorizontal;
                    let projectedPointCanvas = [0, 0];
                    if (isHorizontal) {
                        projectedPointCanvas = [
                            canvasPoint1[0] + canvasDeltaX,
                            canvasPoint1[1],
                        ];
                    }
                    else {
                        projectedPointCanvas = [
                            canvasPoint1[0],
                            canvasPoint1[1] + canvasDeltaY,
                        ];
                    }
                    let dataId = `${annotationUID}-line-1`;
                    let lineUID = '1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                    dataId = `${annotationUID}-line-2`;
                    lineUID = '2';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {
                        color,
                        width: 1,
                        lineDash: [1, 1],
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                else {
                    const dataId = `${annotationUID}-line-1`;
                    const lineUID = '1';
                    (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                        color,
                        width: 1,
                        shadow: this.configuration.shadow,
                    }, dataId);
                }
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = canvasCoordinates[1];
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {
        return;
    }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        this.editData = {
            handleIndex,
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { renderingEngine } = enabledElement;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    _calculateCachedStats(annotation, renderingEngine, enabledElement) {
        const data = annotation.data;
        const { element } = enabledElement.viewport;
        if (data.handles.points.length !== 2) {
            return;
        }
        const { cachedStats } = data;
        const targetIds = Object.keys(cachedStats);
        for (let i = 0; i < targetIds.length; i++) {
            const targetId = targetIds[i];
            const image = this.getTargetImageData(targetId);
            if (!image) {
                continue;
            }
            const { imageData } = image;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const imageIndex1 = UltrasoundDirectionalTool_transformWorldToIndex(imageData, worldPos1);
            const imageIndex2 = UltrasoundDirectionalTool_transformWorldToIndex(imageData, worldPos2);
            const { values: values1, units: units1 } = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [imageIndex1]);
            const { values: values2, units: units2 } = (0,getCalibratedUnits/* getCalibratedProbeUnitsAndValue */.Xw)(image, [imageIndex2]);
            let xValues, yValues, units, isHorizontal;
            let isUnitless = false;
            if (units1[0] !== units2[0] ||
                units1[1] !== units2[1] ||
                (units1[0] === 'raw' && units2[0] === 'raw')) {
                const value = (0,point.distanceToPoint)(worldPos1, worldPos2);
                xValues = [value, 0];
                yValues = [value, 0];
                units = ['px'];
                isUnitless = true;
            }
            else {
                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);
                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);
                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];
                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];
                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);
                xValues = [values1[0], values2[0]];
                yValues = [values1[1], values2[1]];
                units = [units1[0], units1[1]];
            }
            cachedStats[targetId] = {
                xValues,
                yValues,
                isHorizontal,
                units,
                isUnitless,
            };
        }
        const invalidated = annotation.invalidated;
        annotation.invalidated = false;
        if (invalidated) {
            (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.StatsUpdated);
        }
        return cachedStats;
    }
}
function UltrasoundDirectionalTool_defaultGetTextLines(data, targetId, configuration) {
    const cachedStats = data.cachedStats[targetId];
    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;
    if (isUnitless) {
        return [`${esm.utilities.roundNumber(xValues[0])} px`];
    }
    if (configuration.displayBothAxesDistances) {
        const dist1 = Math.abs(xValues[1] - xValues[0]);
        const dist2 = Math.abs(yValues[1] - yValues[0]);
        return [
            `${esm.utilities.roundNumber(dist1)} ${units[0]}`,
            `${esm.utilities.roundNumber(dist2)} ${units[1]}`,
        ];
    }
    if (isHorizontal) {
        const dist = Math.abs(xValues[1] - xValues[0]);
        return [`${esm.utilities.roundNumber(dist)} ${units[0]}`];
    }
    else {
        const dist = Math.abs(yValues[1] - yValues[0]);
        return [`${esm.utilities.roundNumber(dist)} ${units[1]}`];
    }
}
/* harmony default export */ const annotation_UltrasoundDirectionalTool = ((/* unused pure expression or super */ null && (UltrasoundDirectionalTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/fan/fanUtils.js
var fanUtils = __webpack_require__(17787);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/UltrasoundPleuraBLineTool.js















const { transformIndexToWorld } = esm.utilities;
class UltrasoundPleuraBLineTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'UltrasoundPleuraBLineTool'; }
    static { this.USPleuraBLineAnnotationType = {
        BLINE: 'bLine',
        PLEURA: 'pleura',
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: UltrasoundPleuraBLineTool_defaultGetTextLines,
            center: null,
            innerRadius: null,
            outerRadius: null,
            startAngle: null,
            endAngle: null,
            bLineColor: 'rgb(60, 255, 60)',
            pleuraColor: 'rgb(0, 4, 255)',
            drawDepthGuide: true,
            depth_ratio: 0.5,
            depthGuideColor: 'rgb(0, 255, 255)',
            depthGuideThickness: 4,
            depthGuideDashLength: 20,
            depthGuideDashGap: 16,
            depthGuideOpacity: 0.2,
            fanOpacity: 0.1,
            showFanAnnotations: true,
            updatePercentageCallback: null,
            actions: {
                undo: {
                    method: 'undo',
                    bindings: [{ key: 'z' }],
                },
                redo: {
                    method: 'redo',
                    bindings: [{ key: 'y' }],
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.pleuraAnnotations = [];
        this.bLineAnnotations = [];
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            (0,elementCursor.hideElementCursor)(element);
            this.isDrawing = true;
            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();
            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    ...viewport.getViewReference({ points: [worldPos] }),
                    toolName: this.getToolName(),
                    referencedImageId,
                    viewUp,
                    cameraPosition,
                },
                data: {
                    handles: {
                        points: [[...worldPos], [...worldPos]],
                        activeHandleIndex: null,
                    },
                    annotationType: this.getActiveAnnotationType(),
                    label: '',
                },
            };
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 1,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const [point1, point2] = data.handles.points;
            const canvasPoint1 = viewport.worldToCanvas(point1);
            const canvasPoint2 = viewport.worldToCanvas(point2);
            const line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            const distanceToPoint = math_line.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.doneEditMemo();
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { viewport } = (0,esm.getEnabledElement)(element) || {};
            if (!viewport) {
                return;
            }
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                const allPointsInsideShape = points.every((point) => {
                    const newPoint = [
                        point[0] + worldPosDelta[0],
                        point[1] + worldPosDelta[1],
                        point[2] + worldPosDelta[2],
                    ];
                    return this.isInsideFanShape(viewport, newPoint);
                });
                if (allPointsInsideShape) {
                    points.forEach((point) => {
                        point[0] += worldPosDelta[0];
                        point[1] += worldPosDelta[1];
                        point[2] += worldPosDelta[2];
                    });
                    annotation.invalidated = true;
                }
            }
            else {
                const { currentPoints } = eventDetail;
                const worldPos = currentPoints.world;
                if (this.isInsideFanShape(viewport, worldPos)) {
                    data.handles.points[handleIndex] = [...worldPos];
                    annotation.invalidated = true;
                }
            }
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,helpers_state.triggerAnnotationModified)(annotation, element, enums.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,elementCursor.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,helpers_state.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            if (!this.getFanShapeGeometryParameters(viewport)) {
                return;
            }
            const { imageData } = viewport.getImageData() || {};
            if (!imageData) {
                return renderStatus;
            }
            if (this.configuration.drawDepthGuide) {
                this.drawDepthGuide(svgDrawingHelper, viewport);
            }
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            const fanCenter = viewport.worldToCanvas(transformIndexToWorld(imageData, this.configuration.center));
            const indexToCanvasRatio = this.getIndexToCanvasRatio(viewport);
            const innerRadius = this.configuration.innerRadius * indexToCanvasRatio;
            const outerRadius = this.configuration.outerRadius * indexToCanvasRatio;
            const currentImageId = viewport.getCurrentImageId();
            const unMergedPleuraIntervals = annotations
                .filter((annotation) => annotation.data.annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&
                annotation.metadata.referencedImageId === currentImageId)
                .map((annotation) => {
                const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));
                const interval = (0,fanUtils/* intervalFromPoints */.R3)(fanCenter, canvasCoordinates);
                return interval;
            });
            const mergedPleuraIntervals = (0,fanUtils/* mergeIntervals */.l7)(unMergedPleuraIntervals);
            const pleuraIntervalsDisplayed = [];
            const bLineIntervalsDisplayed = [];
            const drawAnnotation = (annotation) => {
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    return;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {
                        color: this.getColorForLineType(annotation),
                        fill: this.getColorForLineType(annotation),
                        lineDash,
                        lineWidth,
                    });
                }
                const dataId = `${annotationUID}-line`;
                const lineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color: this.getColorForLineType(annotation),
                    width: lineWidth,
                    lineDash,
                    shadow,
                }, dataId);
                if (this.configuration.showFanAnnotations) {
                    const lineInterval = (0,fanUtils/* intervalFromPoints */.R3)(fanCenter, canvasCoordinates);
                    let fanNumber = 0;
                    if (annotation.data.annotationType ===
                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {
                        const uncoveredIntervals = (0,fanUtils/* subtractIntervals */.V0)(bLineIntervalsDisplayed, lineInterval);
                        uncoveredIntervals.forEach((interval) => {
                            const clippedIntervals = (0,fanUtils/* clipInterval */.IM)(interval, mergedPleuraIntervals);
                            clippedIntervals.forEach((clippedInterval) => {
                                fanNumber++;
                                const fanIndex = fanNumber;
                                const fanDataId = `${annotationUID}-fan-${fanIndex}`;
                                const fanUID = `2-${fanIndex}`;
                                (0,drawingSvg.drawFan)(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, clippedInterval[0], clippedInterval[1], {
                                    color: 'transparent',
                                    fill: this.getColorForLineType(annotation),
                                    fillOpacity: this.configuration.fanOpacity,
                                    width: lineWidth,
                                    lineDash,
                                    shadow,
                                }, fanDataId, 10);
                                bLineIntervalsDisplayed.push(clippedInterval);
                            });
                        });
                    }
                    else if (annotation.data.annotationType ===
                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {
                        const uncoveredIntervals = (0,fanUtils/* subtractIntervals */.V0)(pleuraIntervalsDisplayed, lineInterval);
                        uncoveredIntervals.forEach((interval, index) => {
                            fanNumber++;
                            const fanIndex = fanNumber;
                            const fanDataId = `${annotationUID}-fan-${fanIndex}`;
                            const fanUID = `2-${fanIndex}`;
                            (0,drawingSvg.drawFan)(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, interval[0], interval[1], {
                                color: 'transparent',
                                fill: this.getColorForLineType(annotation),
                                fillOpacity: this.configuration.fanOpacity,
                                width: lineWidth,
                                lineDash,
                                shadow,
                            }, fanDataId, 5);
                            pleuraIntervalsDisplayed.push(interval);
                        });
                    }
                }
            };
            const pleuraAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&
                annotation.metadata.referencedImageId === currentImageId);
            pleuraAnnotationsToDraw.forEach((annotation) => {
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                drawAnnotation(annotation);
            });
            const bLineAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&
                annotation.metadata.referencedImageId === currentImageId);
            bLineAnnotationsToDraw.forEach((annotation) => {
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                drawAnnotation(annotation);
            });
            renderStatus = true;
            if (this.configuration.updatePercentageCallback && viewport) {
                this.configuration.updatePercentageCallback(this.calculateBLinePleuraPercentage(viewport));
            }
            return renderStatus;
        };
        this.activeAnnotationType =
            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE;
    }
    static filterAnnotations(element, filterFunction = () => true) {
        const annotations = (0,annotationState.getAnnotations)(UltrasoundPleuraBLineTool.toolName, element);
        if (!annotations?.length) {
            return [];
        }
        const filteredAnnotations = annotations.filter((annotation) => {
            const currentImageId = annotation.metadata.referencedImageId;
            return filterFunction(currentImageId);
        });
        return filteredAnnotations;
    }
    static countAnnotations(element, filterFunction = () => true) {
        const annotations = (0,annotationState.getAnnotations)(UltrasoundPleuraBLineTool.toolName, element);
        const { viewport } = (0,esm.getEnabledElement)(element);
        const imageIds = viewport.getImageIds();
        const getImageIdIndex = (imageId) => {
            const index = imageIds.findIndex((id) => id === imageId);
            if (index === -1) {
                return 0;
            }
            return index;
        };
        if (!annotations?.length) {
            return;
        }
        const annotationMapping = new Map();
        annotations.forEach((annotation) => {
            const currentImageId = annotation.metadata.referencedImageId;
            if (!filterFunction(currentImageId)) {
                return;
            }
            const { annotationType } = annotation.data;
            let counts;
            if (annotationMapping.has(currentImageId)) {
                counts = annotationMapping.get(currentImageId);
            }
            else {
                counts = {
                    frame: getImageIdIndex(currentImageId),
                    bLine: 0,
                    pleura: 0,
                };
            }
            if (annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {
                counts.pleura++;
            }
            else if (annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {
                counts.bLine++;
            }
            annotationMapping.set(currentImageId, counts);
        });
        return annotationMapping;
    }
    static deleteAnnotations(element, filterFunction = () => false) {
        const annotations = (0,annotationState.getAnnotations)(UltrasoundPleuraBLineTool.toolName, element);
        if (!annotations?.length) {
            return;
        }
        annotations.forEach((annotation) => {
            if (!filterFunction(annotation.metadata.referencedImageId)) {
                return;
            }
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        });
    }
    setActiveAnnotationType(type) {
        this.activeAnnotationType = type;
    }
    getActiveAnnotationType() {
        return this.activeAnnotationType;
    }
    deleteLastAnnotationType(element, type) {
        let annotationList;
        const annotations = (0,annotationState.getAnnotations)(UltrasoundPleuraBLineTool.toolName, element);
        if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {
            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA);
        }
        else if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {
            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===
                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE);
        }
        if (annotationList?.length > 0) {
            const annotation = annotationList.pop();
            (0,annotationState.removeAnnotation)(annotation.annotationUID);
        }
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(UltrasoundPleuraBLineTool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                },
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
    }; }
    handleSelectedCallback(evt, annotation, handle) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        const { data } = annotation;
        annotation.highlighted = true;
        let movingTextBox = false;
        let handleIndex;
        if (handle.worldPosition) {
            movingTextBox = true;
        }
        else {
            handleIndex = data.handles.points.findIndex((p) => p === handle);
        }
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex,
            movingTextBox,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    isInsideFanShape(viewport, point) {
        if (!this.getFanShapeGeometryParameters(viewport)) {
            return false;
        }
        const { imageData } = viewport.getImageData() || {};
        if (imageData) {
            const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));
            const canvasCoordinates = viewport.worldToCanvas(point);
            const angle = (0,fanUtils/* angleFromCenter */.xA)(fanCenter, canvasCoordinates);
            return (angle >= this.configuration.startAngle &&
                angle <= this.configuration.endAngle);
        }
    }
    updateFanGeometryConfiguration(fanGeometry) {
        if (!fanGeometry) {
            return;
        }
        if (this.isFanShapeGeometryParametersValid(fanGeometry)) {
            this.configuration.center = [
                fanGeometry.center[0],
                fanGeometry.center[1],
                0,
            ];
        }
        this.configuration.innerRadius = fanGeometry.innerRadius;
        this.configuration.outerRadius = fanGeometry.outerRadius;
        this.configuration.startAngle = fanGeometry.startAngle;
        this.configuration.endAngle = fanGeometry.endAngle;
    }
    deriveFanGeometryFromViewport(viewport) {
        const imageId = viewport.getCurrentImageId();
        const { fanGeometry } = calculateFanGeometry(imageId) || {};
        if (fanGeometry) {
            this.updateFanGeometryConfiguration(fanGeometry);
        }
    }
    isFanShapeGeometryParametersValid(fanGeometry) {
        if (!fanGeometry) {
            fanGeometry = this.configuration;
        }
        return (fanGeometry?.center &&
            fanGeometry?.innerRadius > 0 &&
            fanGeometry?.outerRadius &&
            fanGeometry?.startAngle > 0 &&
            fanGeometry?.startAngle < 360 &&
            fanGeometry?.endAngle > 0 &&
            fanGeometry?.endAngle < 360);
    }
    getFanShapeGeometryParameters(viewport) {
        if (this.isFanShapeGeometryParametersValid()) {
            return true;
        }
        if (!this.isFanShapeGeometryParametersValid()) {
            const imageId = viewport.getCurrentImageId();
            const fanGeometry = esm.metaData.get('ultrasoundFanShapeGeometry', imageId);
            this.updateFanGeometryConfiguration(fanGeometry);
        }
        if (!this.isFanShapeGeometryParametersValid()) {
            this.deriveFanGeometryFromViewport(viewport);
        }
        return this.isFanShapeGeometryParametersValid();
    }
    calculateBLinePleuraPercentage(viewport) {
        if (!this.getFanShapeGeometryParameters(viewport)) {
            return;
        }
        const { imageData } = viewport.getImageData() || {};
        if (!imageData) {
            return;
        }
        const { element } = viewport;
        const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));
        const currentImageId = viewport.getCurrentImageId();
        const annotations = (0,annotationState.getAnnotations)(this.getToolName(), element) || [];
        const pleuraIntervals = annotations
            .filter((annotation) => annotation.data.annotationType ===
            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&
            annotation.metadata.referencedImageId === currentImageId)
            .map((annotation) => {
            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));
            return canvasCoordinates;
        });
        const bLineIntervals = annotations
            .filter((annotation) => annotation.data.annotationType ===
            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&
            annotation.metadata.referencedImageId === currentImageId)
            .map((annotation) => {
            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));
            return canvasCoordinates;
        });
        return (0,fanUtils/* calculateInnerFanPercentage */.Mo)(fanCenter, pleuraIntervals, bLineIntervals);
    }
    getColorForLineType(annotation) {
        const { annotationType } = annotation.data;
        const { bLineColor, pleuraColor } = this.configuration;
        if (annotationType ===
            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {
            return bLineColor;
        }
        if (annotationType ===
            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {
            return pleuraColor;
        }
        return bLineColor;
    }
    getIndexToCanvasRatio(viewport) {
        const { imageData } = viewport.getImageData() || {};
        const v1 = viewport.worldToCanvas(imageData.indexToWorld([1, 0, 0]));
        const v2 = viewport.worldToCanvas(imageData.indexToWorld([2, 0, 0]));
        const diffVector = [v2[0] - v1[0], v2[1] - v1[1]];
        const vectorSize = Math.sqrt(diffVector[0] * diffVector[0] + diffVector[1] * diffVector[1]);
        return vectorSize;
    }
    drawDepthGuide(svgDrawingHelper, viewport) {
        if (!this.getFanShapeGeometryParameters(viewport)) {
            return;
        }
        const { imageData } = viewport.getImageData() || {};
        if (!imageData) {
            return;
        }
        const radToDegree = (rad) => (rad * 180) / Math.PI;
        const degreeToRad = (degree) => (degree * Math.PI) / 180;
        const indexToCanvas = (point) => {
            return viewport.worldToCanvas(transformIndexToWorld(imageData, point));
        };
        const depth_radius = this.configuration.innerRadius +
            this.configuration.depth_ratio *
                (this.configuration.outerRadius - this.configuration.innerRadius);
        const theta_start = this.configuration.startAngle;
        const theta_end = this.configuration.endAngle;
        const theta_range = theta_end - theta_start;
        const arc_length = degreeToRad(theta_range) * depth_radius;
        let num_dashes = Math.round(arc_length /
            (this.configuration.depthGuideDashLength +
                this.configuration.depthGuideDashGap));
        if (num_dashes <= 0) {
            num_dashes = Math.max(15, Math.round(theta_range / 5));
        }
        const theta_step = theta_range / num_dashes;
        for (let i = 0; i < num_dashes; i++) {
            const theta1 = degreeToRad(theta_start + i * theta_step);
            const theta2 = degreeToRad(theta_start +
                i * theta_step +
                radToDegree(this.configuration.depthGuideDashLength) / depth_radius);
            const start_point = [
                this.configuration.center[0] + depth_radius * Math.cos(theta1),
                this.configuration.center[1] + depth_radius * Math.sin(theta1),
                0,
            ];
            const end_point = [
                this.configuration.center[0] + depth_radius * Math.cos(theta2),
                this.configuration.center[1] + depth_radius * Math.sin(theta2),
                0,
            ];
            (0,drawingSvg.drawLine)(svgDrawingHelper, viewport.id, `depthGuide-${i}`, indexToCanvas(start_point), indexToCanvas(end_point), {
                color: this.configuration.depthGuideColor,
                lineWidth: this.configuration.depthGuideThickness,
                strokeOpacity: this.configuration.depthGuideOpacity,
            });
        }
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function UltrasoundPleuraBLineTool_defaultGetTextLines(data, targetId) {
    return [''];
}
/* harmony default export */ const UltrasoundPleuraBLineTool_UltrasoundPleuraBLineTool = ((/* unused pure expression or super */ null && (UltrasoundPleuraBLineTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js










class KeyImageTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'KeyImage'; }
    static { this.dataSeries = {
        data: {
            seriesLevel: true,
        },
    }; }
    static { this.dataPoint = {
        data: {
            isPoint: true,
        },
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            getTextCallback: KeyImageTool_getTextCallback,
            changeTextCallback: KeyImageTool_changeTextCallback,
            canvasPosition: [10, 10],
            canvasSize: 10,
            handleRadius: '6',
            seriesLevel: false,
            isPoint: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element, currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const worldPos = currentPoints.world;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: { points: [[...worldPos]] },
                    seriesLevel: this.configuration.seriesLevel,
                    isPoint: this.configuration.isPoint,
                },
            });
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            this.configuration.getTextCallback((label) => {
                if (!label) {
                    (0,annotationState.removeAnnotation)(annotation.annotationUID);
                    (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
                    this.isDrawing = false;
                    return;
                }
                annotation.data.label = label;
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
                (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            });
            this.createMemo(element, annotation, { newAnnotation: true });
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            if (!data?.isPoint) {
                return false;
            }
            const { canvasPosition, canvasSize } = this.configuration;
            if (!canvasPosition?.length) {
                return false;
            }
            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=
                canvasSize / 2 &&
                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=
                    canvasSize / 2) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            annotation.highlighted = true;
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { viewportId, renderingEngine } = (0,esm.getEnabledElement)(element);
            this.eventDispatchDetail = {
                viewportId,
                renderingEngineId: renderingEngine.id,
            };
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            if (newAnnotation) {
                this.createMemo(element, annotation, { newAnnotation });
            }
            this.editData = null;
            this.isDrawing = false;
            this.doneEditMemo();
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
        };
        this.doubleClickCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return;
            }
            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));
            if (!clickedAnnotation) {
                return;
            }
            const annotation = clickedAnnotation;
            this.createMemo(element, annotation);
            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));
            this.isDrawing = false;
            this.doneEditMemo();
            evt.stopImmediatePropagation();
            evt.preventDefault();
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            this.createMemo(element, annotation, { newAnnotation });
            data.handles.points[0] = [...worldPos];
            annotation.invalidated = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { canvasPosition, canvasSize } = this.configuration;
                const arrowUID = '1';
                if (data?.isPoint) {
                    const point = data.handles.points[0];
                    const canvasCoordinates = viewport.worldToCanvas(point);
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {
                        color,
                        lineWidth,
                        handleRadius: this.configuration.handleRadius,
                    });
                }
                else if (canvasPosition?.length) {
                    (0,drawingSvg.drawArrow)(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {
                        color,
                        width: 1,
                    });
                }
                renderStatus = true;
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
            }
            return renderStatus;
        };
    }
    handleSelectedCallback(evt, annotation) {
        const eventDetail = evt.detail;
        const { element } = eventDetail;
        annotation.highlighted = true;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
        };
        this._activateModify(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        evt.preventDefault();
    }
    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {
        annotation.data.isPoint = isPoint;
        (0,helpers_state.triggerAnnotationModified)(annotation, element);
    }
    _doneChangingTextCallback(element, annotation, updatedText) {
        annotation.data.label = updatedText;
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        (0,helpers_state.triggerAnnotationModified)(annotation, element);
    }
    cancel(element) {
        if (this.isDrawing) {
            this.isDrawing = false;
            this._deactivateModify(element);
            (0,elementCursor.resetElementCursor)(element);
            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
            const { data } = annotation;
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            return annotation.annotationUID;
        }
    }
    _isInsideVolume(index1, index2, dimensions) {
        return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
            esm.utilities.indexWithinDimensions(index2, dimensions));
    }
}
function KeyImageTool_getTextCallback(doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
function KeyImageTool_changeTextCallback(data, eventData, doneChangingTextCallback) {
    return doneChangingTextCallback(prompt('Enter your annotation:'));
}
/* harmony default export */ const annotation_KeyImageTool = ((/* unused pure expression or super */ null && (KeyImageTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js




class AnnotationEraserTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'mouse');
        };
        this.preTouchStartCallback = (evt) => {
            return this._deleteNearbyAnnotations(evt, 'touch');
        };
    }
    _deleteNearbyAnnotations(evt, interactionType) {
        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;
        const toolGroup = (0,store_ToolGroupManager.getToolGroupForViewport)(viewportId, renderingEngineId);
        if (!toolGroup) {
            return false;
        }
        const tools = toolGroup._toolInstances;
        const annotationsToRemove = [];
        for (const toolName in tools) {
            const toolInstance = tools[toolName];
            if (typeof toolInstance.isPointNearTool !== 'function' ||
                typeof toolInstance.filterInteractableAnnotationsForElement !==
                    'function') {
                continue;
            }
            const annotations = (0,annotationState.getAnnotations)(toolName, element);
            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);
            if (!interactableAnnotations) {
                continue;
            }
            for (const annotation of interactableAnnotations) {
                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {
                    annotationsToRemove.push(annotation.annotationUID);
                }
            }
        }
        for (const annotationUID of annotationsToRemove) {
            (0,annotationSelection.setAnnotationSelected)(annotationUID);
            const annotation = (0,annotationState.getAnnotation)(annotationUID);
            base/* AnnotationTool */.EC.createAnnotationMemo(element, annotation, {
                deleting: true,
            });
            (0,annotationState.removeAnnotation)(annotationUID);
        }
        evt.preventDefault();
        return true;
    }
}
AnnotationEraserTool.toolName = 'Eraser';
/* harmony default export */ const tools_AnnotationEraserTool = ((/* unused pure expression or super */ null && (AnnotationEraserTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/GrowCutBaseTool.js
var GrowCutBaseTool = __webpack_require__(10639);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js








class RegionSegmentTool extends GrowCutBaseTool/* default */.A {
    static { this.toolName = 'RegionSegment'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positiveSeedVariance: 0.5,
            negativeSeedVariance: 0.9,
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.growCutData.circleBorderPoint = currentWorldPoint;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,elementCursor.resetElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        await super.preMouseDownCallback(evt);
        Object.assign(this.growCutData, {
            circleCenterPoint: worldPoint,
            circleBorderPoint: worldPoint,
        });
        this._activateDraw(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        return true;
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;
        const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const worldCircleRadius = gl_matrix_esm/* vec3.len */.eR.len(gl_matrix_esm/* vec3.sub */.eR.sub(gl_matrix_esm/* vec3.create */.eR.create(), circleCenterPoint, circleBorderPoint));
        const sphereInfo = {
            center: circleCenterPoint,
            radius: worldCircleRadius,
        };
        return segmentation.growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);
    }
    _activateDraw(element) {
        element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;
        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);
        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);
        const vecCenterToBorder = gl_matrix_esm/* vec2.sub */.Zc.sub(gl_matrix_esm/* vec2.create */.Zc.create(), canvasBorderPoint, canvasCenterPoint);
        const circleRadius = gl_matrix_esm/* vec2.len */.Zc.len(vecCenterToBorder);
        if (esm.utilities.isEqual(circleRadius, 0)) {
            return;
        }
        const annotationUID = 'growcut';
        const circleUID = '0';
        const { color } = this.getSegmentStyle({
            segmentationId: segmentationData.segmentationId,
            segmentIndex: segmentationData.segmentIndex,
            viewportId: viewport.id,
        });
        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {
            color,
        });
    }
}
/* harmony default export */ const annotation_RegionSegmentTool = ((/* unused pure expression or super */ null && (RegionSegmentTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js
var runOneClickGrowCut = __webpack_require__(16171);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js





class RegionSegmentPlusTool extends GrowCutBaseTool/* default */.A {
    static { this.toolName = 'RegionSegmentPlus'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: false,
            positiveSeedVariance: 0.4,
            negativeSeedVariance: 0.9,
            subVolumePaddingPercentage: 0.1,
            islandRemoval: {
                enabled: false,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseTimer = null;
        this.allowedToProceed = false;
    }
    mouseMoveCallback(evt) {
        if (this.mode !== enums.ToolModes.Active) {
            return;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const { world: worldPoint } = currentPoints;
        element.style.cursor = 'default';
        if (this.mouseTimer !== null) {
            window.clearTimeout(this.mouseTimer);
            this.mouseTimer = null;
        }
        this.mouseTimer = window.setTimeout(() => {
            this.onMouseStable(evt, worldPoint, element);
        }, this.configuration.mouseStabilityDelay || 500);
    }
    async onMouseStable(evt, worldPoint, element) {
        await super.preMouseDownCallback(evt);
        const refVolume = esm.cache.getVolume(this.growCutData.segmentation.referencedVolumeId);
        const seeds = (0,runOneClickGrowCut/* calculateGrowCutSeeds */.sG)(refVolume, worldPoint, {}) || {
            positiveSeedIndices: new Set(),
            negativeSeedIndices: new Set(),
        };
        const { positiveSeedIndices, negativeSeedIndices } = seeds;
        let cursor;
        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||
            negativeSeedIndices.size < 30) {
            cursor = 'not-allowed';
            this.allowedToProceed = false;
        }
        else {
            cursor = 'copy';
            this.allowedToProceed = true;
        }
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (element) {
            element.style.cursor = cursor;
            requestAnimationFrame(() => {
                if (element.style.cursor !== cursor) {
                    element.style.cursor = cursor;
                }
            });
        }
        if (this.allowedToProceed) {
            this.seeds = seeds;
        }
        if (enabledElement && enabledElement.viewport) {
            enabledElement.viewport.render();
        }
    }
    async preMouseDownCallback(evt) {
        if (!this.allowedToProceed) {
            return false;
        }
        const eventData = evt.detail;
        const { currentPoints, element } = eventData;
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (enabledElement) {
            element.style.cursor = 'wait';
            requestAnimationFrame(() => {
                if (element.style.cursor !== 'wait') {
                    element.style.cursor = 'wait';
                }
            });
        }
        const { world: worldPoint } = currentPoints;
        await super.preMouseDownCallback(evt);
        this.growCutData = esm.utilities.deepMerge(this.growCutData, {
            worldPoint,
            islandRemoval: {
                worldIslandPoints: [worldPoint],
            },
        });
        this.growCutData.worldPoint = worldPoint;
        this.growCutData.islandRemoval = {
            worldIslandPoints: [worldPoint],
        };
        await this.runGrowCut();
        if (element) {
            element.style.cursor = 'default';
        }
        return true;
    }
    getRemoveIslandData(growCutData) {
        const { worldPoint } = growCutData;
        return {
            worldIslandPoints: [worldPoint],
        };
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;
        const { subVolumePaddingPercentage } = this.configuration;
        const mergedOptions = {
            ...options,
            subVolumePaddingPercentage,
            seeds: this.seeds,
        };
        return segmentation.growCut.runOneClickGrowCut({
            referencedVolumeId,
            worldPosition: worldPoint,
            options: mergedOptions,
        });
    }
}
/* harmony default export */ const annotation_RegionSegmentPlusTool = ((/* unused pure expression or super */ null && (RegionSegmentPlusTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js








const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
const ISLAND_PIXEL_RANGE = [1000, 1900];
const { transformWorldToIndex: WholeBodySegmentTool_transformWorldToIndex, transformIndexToWorld: WholeBodySegmentTool_transformIndexToWorld } = esm.utilities;
class WholeBodySegmentTool extends GrowCutBaseTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            isPartialVolume: true,
            positivePixelRange: POSITIVE_PIXEL_RANGE,
            negativePixelRange: NEGATIVE_PIXEL_RANGE,
            islandRemoval: {
                enabled: true,
                islandPixelRange: ISLAND_PIXEL_RANGE,
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const { world: currentWorldPoint } = currentPoints;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);
            this.growCutData.horizontalLines[1] = linePoints;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        };
        this._endCallback = async (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            await this.runGrowCut();
            this._deactivateDraw(element);
            this.growCutData = null;
            (0,elementCursor.resetElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport, renderingEngine } = enabledElement;
        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);
        await super.preMouseDownCallback(evt);
        this.growCutData.horizontalLines = [linePoints, linePoints];
        this._activateDraw(element);
        (0,elementCursor.hideElementCursor)(element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        return true;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this.growCutData) {
            return;
        }
        const { segmentation: segmentationData, horizontalLines } = this.growCutData;
        if (horizontalLines.length !== 2) {
            return;
        }
        const { viewport } = enabledElement;
        const { segmentationId, segmentIndex } = segmentationData;
        const [line1, line2] = horizontalLines;
        const [worldLine1P1, worldLine1P2] = line1;
        const [worldLine2P1, worldLine2P2] = line2;
        const canvasPoints = [
            worldLine1P1,
            worldLine1P2,
            worldLine2P2,
            worldLine2P1,
        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));
        const annotationUID = 'growCutRect';
        const squareGroupUID = '0';
        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({
            segmentationId,
            segmentIndex,
            viewportId: viewport.id,
        });
        (0,drawingSvg.drawPolyline)(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {
            color,
            fillColor,
            fillOpacity,
            lineWidth,
            lineDash,
            closePath: true,
        });
    }
    async getGrowCutLabelmap(growCutData) {
        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;
        const renderingEngine = (0,esm.getRenderingEngine)(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const [line1, line2] = horizontalLines;
        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];
        const referencedVolume = esm.cache.getVolume(referencedVolumeId);
        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);
        const ijkTopLeft = WholeBodySegmentTool_transformWorldToIndex(referencedVolume.imageData, worldTopLeft);
        const ijkBottomRight = WholeBodySegmentTool_transformWorldToIndex(referencedVolume.imageData, worldBottomRight);
        const boundingBoxInfo = {
            boundingBox: {
                ijkTopLeft,
                ijkBottomRight,
            },
        };
        const config = this.configuration;
        const options = {
            positiveSeedValue: segmentIndex,
            negativeSeedValue: 255,
            negativePixelRange: config.negativePixelRange,
            positivePixelRange: config.positivePixelRange,
        };
        return segmentation.growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);
    }
    getRemoveIslandData() {
        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;
        const referencedVolume = esm.cache.getVolume(referencedVolumeId);
        const labelmapVolume = esm.cache.getVolume(labelmapVolumeId);
        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();
        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();
        const { islandPixelRange } = this.configuration.islandRemoval;
        const islandPointIndexes = [];
        for (let i = 0, len = labelmapData.length; i < len; i++) {
            if (labelmapData[i] !== segmentIndex) {
                continue;
            }
            const pixelValue = referencedVolumeData[i];
            if (pixelValue >= islandPixelRange[0] &&
                pixelValue <= islandPixelRange[1]) {
                islandPointIndexes.push(i);
            }
        }
        return {
            islandPointIndexes,
        };
    }
    _activateDraw(element) {
        element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
        element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
        element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
    }
    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = WholeBodySegmentTool_transformWorldToIndex(volume.imageData, worldEdgePoint);
        const axis = vecDirection.findIndex((n) => esm.utilities.isEqual(Math.abs(n), 1));
        if (axis === -1) {
            throw new Error('Non-orthogonal direction vector');
        }
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {
        const { viewPlaneNormal } = viewport.getCamera();
        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);
    }
    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {
        const cuboidPoints = [];
        const volume = this._getViewportVolume(viewport);
        worldSquarePoints.forEach((worldSquarePoint) => {
            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);
            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => WholeBodySegmentTool_transformIndexToWorld(volume.imageData, ijkPoint));
            cuboidPoints.push(...worldEdgePoints);
        });
        return cuboidPoints;
    }
    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {
        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);
        const topLeft = [...worldCuboidPoints[0]];
        const bottomRight = [...worldCuboidPoints[0]];
        worldCuboidPoints.forEach((worldPoint) => {
            gl_matrix_esm/* vec3.min */.eR.min(topLeft, topLeft, worldPoint);
            gl_matrix_esm/* vec3.max */.eR.max(bottomRight, bottomRight, worldPoint);
        });
        return { topLeft, bottomRight };
    }
    _getViewportVolume(viewport) {
        if (!(viewport instanceof esm.BaseVolumeViewport)) {
            throw new Error('Viewport is not a BaseVolumeViewport');
        }
        const volumeId = viewport.getAllVolumeIds()[0];
        return esm.cache.getVolume(volumeId);
    }
    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const { dimensions } = volume;
        const ijkPoint = WholeBodySegmentTool_transformWorldToIndex(volume.imageData, worldPoint);
        const { viewUp, viewPlaneNormal } = viewport.getCamera();
        const vecRow = gl_matrix_esm/* vec3.cross */.eR.cross(gl_matrix_esm/* vec3.create */.eR.create(), viewUp, viewPlaneNormal);
        const axis = vecRow.findIndex((n) => esm.utilities.isEqual(Math.abs(n), 1));
        const ijkLineP1 = [...ijkPoint];
        const ijkLineP2 = [...ijkPoint];
        ijkLineP1[axis] = 0;
        ijkLineP2[axis] = dimensions[axis] - 1;
        return [ijkLineP1, ijkLineP2];
    }
    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {
        const { viewport } = enabledElement;
        const volume = this._getViewportVolume(viewport);
        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);
        const worldPoint1 = WholeBodySegmentTool_transformIndexToWorld(volume.imageData, ijkPoint1);
        const worldPoint2 = WholeBodySegmentTool_transformIndexToWorld(volume.imageData, ijkPoint2);
        return [worldPoint1, worldPoint2];
    }
}
WholeBodySegmentTool.toolName = 'WholeBodySegment';
/* harmony default export */ const annotation_WholeBodySegmentTool = ((/* unused pure expression or super */ null && (WholeBodySegmentTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js
var LabelmapBaseTool = __webpack_require__(23631);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js
var fillRectangle = __webpack_require__(10088);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js
var eraseRectangle = __webpack_require__(47347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js












class RectangleScissorsTool extends LabelmapBaseTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillRectangle/* fillInsideRectangle */.pY,
                ERASE_INSIDE: eraseRectangle/* eraseInsideRectangle */.M,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = stateManagement_segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = stateManagement_segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = stateManagement_segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = stateManagement_segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const labelmapData = representationData[enums.SegmentationRepresentations.Labelmap];
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                },
            };
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = esm.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex } = this.editData;
            const { data } = annotation;
            const { currentPoints } = eventDetail;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
            const worldPos = currentPoints.world;
            const { points } = data.handles;
            points[handleIndex] = [...worldPos];
            let bottomLeftCanvas;
            let bottomRightCanvas;
            let topLeftCanvas;
            let topRightCanvas;
            let bottomLeftWorld;
            let bottomRightWorld;
            let topLeftWorld;
            let topRightWorld;
            switch (handleIndex) {
                case 0:
                case 3:
                    bottomLeftCanvas = worldToCanvas(points[0]);
                    topRightCanvas = worldToCanvas(points[3]);
                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                    bottomRightWorld = canvasToWorld(bottomRightCanvas);
                    topLeftWorld = canvasToWorld(topLeftCanvas);
                    points[1] = bottomRightWorld;
                    points[2] = topLeftWorld;
                    break;
                case 1:
                case 2:
                    bottomRightCanvas = worldToCanvas(points[1]);
                    topLeftCanvas = worldToCanvas(points[2]);
                    bottomLeftCanvas = [
                        topLeftCanvas[0],
                        bottomRightCanvas[1],
                    ];
                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];
                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                    topRightWorld = canvasToWorld(topRightCanvas);
                    points[0] = bottomLeftWorld;
                    points[3] = topRightWorld;
                    break;
            }
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const rectangleUID = '0';
            (0,drawingSvg.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
RectangleScissorsTool.toolName = 'RectangleScissor';
/* harmony default export */ const segmentation_RectangleScissorsTool = ((/* unused pure expression or super */ null && (RectangleScissorsTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js
var fillCircle = __webpack_require__(56789);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js
var eraseCircle = __webpack_require__(33852);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js











class CircleScissorsTool extends LabelmapBaseTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillCircle/* fillInsideCircle */.kr,
                ERASE_INSIDE: eraseCircle/* eraseInsideCircle */.r,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeLabelmapSegmentation = stateManagement_segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeLabelmapSegmentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeLabelmapSegmentation;
            const segmentIndex = stateManagement_segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = stateManagement_segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = stateManagement_segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const labelmapData = representationData.Labelmap;
            if (!labelmapData) {
                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');
            }
            const annotation = {
                invalidated: true,
                highlighted: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    isDrawing: true,
                    cachedStats: {},
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = labelmapData;
                const segmentation = esm.cache.getVolume(volumeId);
                this.editData = {
                    ...this.editData,
                    volumeId,
                    referencedVolumeId: segmentation.referencedVolumeId,
                };
            }
            else {
                const segmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                this.editData = {
                    ...this.editData,
                    imageId: segmentationImageId,
                };
            }
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
CircleScissorsTool.toolName = 'CircleScissor';
/* harmony default export */ const segmentation_CircleScissorsTool = ((/* unused pure expression or super */ null && (CircleScissorsTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js
var fillSphere = __webpack_require__(17492);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js
var eraseSphere = __webpack_require__(1989);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js










class SphereScissorsTool extends LabelmapBaseTool/* default */.A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE: fillSphere/* fillInsideSphere */.Jq,
                ERASE_INSIDE: eraseSphere/* eraseInsideSphere */._,
            },
            defaultStrategy: 'FILL_INSIDE',
            activeStrategy: 'FILL_INSIDE',
        },
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            if (this.isDrawing === true) {
                return;
            }
            this.doneEditMemo();
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const canvasPos = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const activeSegmentationRepresentation = stateManagement_segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = stateManagement_segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = stateManagement_segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const segmentColor = stateManagement_segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);
            this.isDrawing = true;
            const annotation = {
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    referencedImageId: '',
                    toolName: this.getToolName(),
                    segmentColor,
                },
                data: {
                    invalidated: true,
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    cachedStats: {},
                    highlighted: true,
                },
            };
            const viewportIdsToRender = [viewport.id];
            this.editData = {
                annotation,
                centerCanvas: canvasPos,
                segmentIndex,
                segmentationId,
                segmentsLocked,
                segmentColor,
                toolGroupId: this.toolGroupId,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
                volumeId: null,
                referencedVolumeId: null,
                imageId: null,
            };
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            const editData = this.getEditData({
                viewport,
                representationData,
                segmentsLocked,
                segmentationId,
            });
            this.editData = {
                ...this.editData,
                ...editData,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return true;
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { currentPoints } = eventDetail;
            const currentCanvasPoints = currentPoints.canvas;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { renderingEngine, viewport } = enabledElement;
            const { canvasToWorld } = viewport;
            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;
            const { data } = annotation;
            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);
            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);
            const radius = Math.sqrt(dX * dX + dY * dY);
            const bottomCanvas = [
                centerCanvas[0],
                centerCanvas[1] + radius,
            ];
            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];
            const leftCanvas = [
                centerCanvas[0] - radius,
                centerCanvas[1],
            ];
            const rightCanvas = [
                centerCanvas[0] + radius,
                centerCanvas[1],
            ];
            data.handles.points = [
                canvasToWorld(bottomCanvas),
                canvasToWorld(topCanvas),
                canvasToWorld(leftCanvas),
                canvasToWorld(rightCanvas),
            ];
            annotation.invalidated = true;
            this.editData.hasMoved = true;
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;
            const { data } = annotation;
            const { viewPlaneNormal, viewUp } = annotation.metadata;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const enabledElement = (0,esm.getEnabledElement)(element);
            const operationData = {
                ...this.editData,
                points: data.handles.points,
                segmentIndex,
                segmentsLocked,
                viewPlaneNormal,
                viewUp,
                createMemo: this.createMemo.bind(this),
            };
            this.editData = null;
            this.isDrawing = false;
            this.applyActiveStrategy(enabledElement, operationData);
            this.doneEditMemo();
        };
        this._activateDraw = (element) => {
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            if (!this.editData) {
                return renderStatus;
            }
            const { viewport } = enabledElement;
            const { viewportIdsToRender } = this.editData;
            if (!viewportIdsToRender.includes(viewport.id)) {
                return renderStatus;
            }
            const { annotation } = this.editData;
            const toolMetadata = annotation.metadata;
            const annotationUID = annotation.annotationUID;
            const data = annotation.data;
            const { points } = data.handles;
            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
            const bottom = canvasCoordinates[0];
            const top = canvasCoordinates[1];
            const center = [
                Math.floor((bottom[0] + top[0]) / 2),
                Math.floor((bottom[1] + top[1]) / 2),
            ];
            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;
            if (!viewport.getRenderingEngine()) {
                console.warn('Rendering Engine has been destroyed');
                return renderStatus;
            }
            const circleUID = '0';
            (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                color,
            });
            renderStatus = true;
            return renderStatus;
        };
    }
}
SphereScissorsTool.toolName = 'SphereScissor';
/* harmony default export */ const segmentation_SphereScissorsTool = ((/* unused pure expression or super */ null && (SphereScissorsTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js
var RectangleROIThresholdTool = __webpack_require__(40336);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js
var RectangleROIStartEndThresholdTool = __webpack_require__(67847);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js






















const { transformWorldToIndex: CircleROIStartEndThresholdTool_transformWorldToIndex } = esm.utilities;
class CircleROIStartEndThresholdTool extends annotation_CircleROITool {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            simplified: true,
            storePointData: false,
            numSlicesToPropagate: 10,
            calculatePointsInsideVolume: true,
            getTextLines: CircleROIStartEndThresholdTool_defaultGetTextLines,
            statsCalculator: basic.BasicStatsCalculator,
            showTextBox: false,
            throttleTimeout: 100,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isHandleOutsideImage = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof esm.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = esm.utilities.getVolumeId(targetId);
                imageVolume = esm.cache.getVolume(volumeId);
                referencedImageId = esm.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = esm.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            let points;
            if (this.configuration.simplified) {
                points = [[...worldPos], [...worldPos]];
            }
            else {
                points = [
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                    [...worldPos],
                ];
            }
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [...viewPlaneNormal],
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    volumeId,
                    spacingInNormal,
                    enabledElement,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points,
                        activeHandleIndex: null,
                    },
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        statistics: [],
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,annotationState.addAnnotation)(annotation, element);
            const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            annotation.highlighted = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            const { metadata } = annotation;
            const { enabledElement } = metadata;
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,annotationState.removeAnnotation)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = esm.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,helpers_state.triggerAnnotationCompleted)(annotation);
            }
            else {
                (0,helpers_state.triggerAnnotationModified)(annotation, element);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,planar.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                const { enabledElement: annotationEnabledElement } = metadata;
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const center = canvasCoordinates[0];
                const radius = (0,circle.getCanvasCircleRadius)([
                    canvasCoordinates[0],
                    canvasCoordinates[1],
                ]);
                const { centerPointRadius } = this.configuration;
                const canvasCorners = (0,circle.getCanvasCircleCorners)([
                    canvasCoordinates[0],
                    canvasCoordinates[1],
                ]);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let tempStartCoordinate = startCoordinate;
                let tempEndCoordinate = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);
                    data.startCoordinate = tempStartCoordinate;
                }
                if (Array.isArray(endCoordinate)) {
                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);
                    data.endCoordinate = tempEndCoordinate;
                }
                const roundedStartCoordinate = esm.utilities.roundToPrecision(data.startCoordinate);
                const roundedEndCoordinate = esm.utilities.roundToPrecision(data.endCoordinate);
                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCameraCoordinate = esm.utilities.roundToPrecision(cameraCoordinate);
                if (roundedCameraCoordinate <
                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||
                    roundedCameraCoordinate >
                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {
                    continue;
                }
                const middleCoordinate = esm.utilities.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);
                let isMiddleSlice = false;
                if (roundedCameraCoordinate === middleCoordinate) {
                    isMiddleSlice = true;
                }
                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;
                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();
                for (const volumeId of iteratorVolumeIDs) {
                    if (annotation.invalidated &&
                        annotation.metadata.volumeId === volumeId) {
                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    isMiddleSlice) {
                    if (this.configuration.simplified) {
                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                    }
                    else {
                        activeHandleCanvasCoords = canvasCoordinates;
                    }
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineWidthToUse = lineWidth;
                let lineDashToUse = lineDash;
                if (isMiddleSlice) {
                    lineWidthToUse = lineWidth;
                    lineDashToUse = [];
                }
                else {
                    lineDashToUse = [5, 5];
                }
                const circleUID = '0';
                (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth: lineWidthToUse,
                });
                if (centerPointRadius > 0) {
                    if (radius > 3 * centerPointRadius) {
                        (0,drawingSvg.drawCircle)(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {
                            color,
                            lineDash,
                            lineWidth,
                        });
                    }
                }
                renderStatus = true;
                if (this.configuration.showTextBox) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    let canvasTextBoxCoords;
                    if (!data.handles.textBox.hasMoved) {
                        canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCorners);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [canvasCoordinates[0], canvasCoordinates[1]], {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        if (this.configuration.calculatePointsInsideVolume) {
            this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });
        }
        else {
            this._throttledCalculateCachedStats = (0,debounce/* default */.A)(this._calculateCachedStatsTool, this.configuration.throttleTimeout);
        }
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        const startWorld = gl_matrix_esm/* vec3.clone */.eR.clone(points[0]);
        startWorld[projectionAxisIndex] = startCoordinate;
        const endWorld = gl_matrix_esm/* vec3.clone */.eR.clone(points[0]);
        endWorld[projectionAxisIndex] = endCoordinate;
        const direction = gl_matrix_esm/* vec3.create */.eR.create();
        gl_matrix_esm/* vec3.subtract */.eR.subtract(direction, endWorld, startWorld);
        const distance = gl_matrix_esm/* vec3.length */.eR.length(direction);
        if (distance === 0) {
            const handlesOnStartPlane = points.map((p) => {
                const newPoint = gl_matrix_esm/* vec3.clone */.eR.clone(p);
                newPoint[projectionAxisIndex] = startCoordinate;
                return Array.from(newPoint);
            });
            data.cachedStats.projectionPoints = [handlesOnStartPlane];
            return;
        }
        gl_matrix_esm/* vec3.normalize */.eR.normalize(direction, direction);
        const handlesToStart = esm.utilities.deepClone(points);
        handlesToStart[0][projectionAxisIndex] = startCoordinate;
        handlesToStart[1][projectionAxisIndex] = startCoordinate;
        const newProjectionPoints = [];
        for (let dist = 0; dist <= distance + 1e-6; dist += spacingInNormal) {
            newProjectionPoints.push(handlesToStart.map((point) => {
                const newPoint = gl_matrix_esm/* vec3.create */.eR.create();
                gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(newPoint, point, direction, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));
        const baseTopLeftCanvas = (0,circle.getCanvasCircleCorners)([
            canvasCoordinates[0],
            canvasCoordinates[1],
        ])[0];
        const baseBottomRightCanvas = (0,circle.getCanvasCircleCorners)([
            canvasCoordinates[0],
            canvasCoordinates[1],
        ])[1];
        const basePos1 = viewport.canvasToWorld(baseTopLeftCanvas);
        const basePos2 = viewport.canvasToWorld(baseBottomRightCanvas);
        const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, basePos1, basePos2);
        const measureInfo = (0,getCalibratedUnits/* getCalibratedLengthUnitsAndScale */.Op)(image, data.handles.points);
        const aspect = (0,getCalibratedUnits/* getCalibratedAspect */.CQ)(image);
        const area = Math.abs(Math.PI *
            (worldWidth / measureInfo.scale / 2) *
            (worldHeight / aspect / measureInfo.scale / 2));
        const modalityUnitOptions = {
            isPreScaled: (0,isViewportPreScaled/* isViewportPreScaled */.u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,getPixelValueUnits/* getPixelValueUnits */.j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const centerWorld = projectionPoints[i][0];
            const currentCanvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));
            const [topLeftCanvas, bottomRightCanvas] = ((0,circle.getCanvasCircleCorners)([
                currentCanvasCoordinates[0],
                currentCanvasCoordinates[1],
            ]));
            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);
            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);
            const worldPos1 = topLeftWorld;
            const worldPos2 = bottomRightWorld;
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, centerWorld);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = CircleROIStartEndThresholdTool_transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const center = centerWorld;
                const ellipseObj = {
                    center,
                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,
                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,
                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,
                };
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    isInObject: (pointLPS) => (0,ellipse.pointInEllipse)(ellipseObj, pointLPS),
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = esm.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);
        annotation.invalidated = false;
        (0,helpers_state.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);
        const startPos = gl_matrix_esm/* vec3.create */.eR.create();
        gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);
        const endPos = gl_matrix_esm/* vec3.create */.eR.create();
        gl_matrix_esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function CircleROIStartEndThresholdTool_defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${esm.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${esm.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${esm.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${esm.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
CircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';
/* harmony default export */ const segmentation_CircleROIStartEndThresholdTool = ((/* unused pure expression or super */ null && (CircleROIStartEndThresholdTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js
var BrushTool = __webpack_require__(48736);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js
var floodFill = __webpack_require__(84882);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js







const { transformWorldToIndex: PaintFillTool_transformWorldToIndex, isEqual: PaintFillTool_isEqual } = esm.utilities;
class PaintFillTool extends base/* BaseTool */.oS {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
    }) {
        super(toolProps, defaultToolProps);
        this.preMouseDownCallback = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const camera = viewport.getCamera();
            const { viewPlaneNormal } = camera;
            const activeSegmentationRepresentation = stateManagement_segmentation.activeSegmentation.getActiveSegmentation(viewport.id);
            if (!activeSegmentationRepresentation) {
                throw new Error('No active segmentation detected, create one before using scissors tool');
            }
            const { segmentationId } = activeSegmentationRepresentation;
            const segmentIndex = stateManagement_segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);
            const segmentsLocked = stateManagement_segmentation.segmentLocking.getLockedSegmentIndices(segmentationId);
            const { representationData } = (0,segmentationState.getSegmentation)(segmentationId);
            let dimensions;
            let direction;
            let index;
            let voxelManager;
            this.doneEditMemo();
            if (viewport instanceof esm.BaseVolumeViewport) {
                const { volumeId } = representationData[enums.SegmentationRepresentations.Labelmap];
                const segmentation = esm.cache.getVolume(volumeId);
                ({ dimensions, direction } = segmentation);
                voxelManager = segmentation.voxelManager;
                index = PaintFillTool_transformWorldToIndex(segmentation.imageData, worldPos);
            }
            else {
                const currentSegmentationImageId = (0,segmentationState.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
                if (!currentSegmentationImageId) {
                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');
                }
                const { imageData } = viewport.getImageData();
                dimensions = imageData.getDimensions();
                direction = imageData.getDirection();
                const image = esm.cache.getImage(currentSegmentationImageId);
                voxelManager = image.voxelManager;
                index = PaintFillTool_transformWorldToIndex(imageData, worldPos);
            }
            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);
            if (fixedDimension === undefined) {
                console.warn('Oblique paint fill not yet supported');
                return;
            }
            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);
            if (index[0] < 0 ||
                index[0] >= dimensions[0] ||
                index[1] < 0 ||
                index[1] >= dimensions[1] ||
                index[2] < 0 ||
                index[2] >= dimensions[2]) {
                return;
            }
            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);
            if (segmentsLocked.includes(clickedLabelValue)) {
                return;
            }
            const floodFillResult = (0,floodFill/* default */.A)(floodFillGetter, inPlaneSeedPoint);
            const { flooded } = floodFillResult;
            flooded.forEach((index) => {
                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);
                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);
            });
            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);
            (0,triggerSegmentationEvents.triggerSegmentationDataModified)(segmentationId, framesModified);
            return true;
        };
        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {
            const { flooded: boundaries } = floodFillResult;
            if (fixedDimension === 2) {
                return [fixedDimensionValue];
            }
            let minJ = Infinity;
            let maxJ = -Infinity;
            for (let b = 0; b < boundaries.length; b++) {
                const j = boundaries[b][1];
                if (j < minJ) {
                    minJ = j;
                }
                if (j > maxJ) {
                    maxJ = j;
                }
            }
            const framesModified = [];
            for (let frame = minJ; frame <= maxJ; frame++) {
                framesModified.push(frame);
            }
            return framesModified;
        };
        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {
            let fixedDimensionValue;
            let inPlaneSeedPoint;
            switch (fixedDimension) {
                case 0:
                    fixedDimensionValue = seedIndex3D[0];
                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];
                    break;
                case 1:
                    fixedDimensionValue = seedIndex3D[1];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];
                    break;
                case 2:
                    fixedDimensionValue = seedIndex3D[2];
                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            const getScalarDataPosition = (x, y, z) => {
                return voxelManager.toIndex([x, y, z]);
            };
            const getLabelValue = (x, y, z) => {
                return voxelManager.getAtIJK(x, y, z);
            };
            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);
            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);
            return {
                getScalarDataPositionFromPlane,
                getLabelValue,
                floodFillGetter,
                inPlaneSeedPoint,
                fixedDimensionValue,
            };
        };
        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {
            let floodFillGetter;
            switch (fixedDimension) {
                case 0:
                    floodFillGetter = (y, z) => {
                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    floodFillGetter = (x, z) => {
                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {
                            return;
                        }
                        return getLabelValue(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    floodFillGetter = (x, y) => {
                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {
                            return;
                        }
                        return getLabelValue(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return floodFillGetter;
        };
        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {
            let getScalarDataPositionFromPlane;
            switch (fixedDimension) {
                case 0:
                    getScalarDataPositionFromPlane = (y, z) => {
                        return getScalarDataPosition(fixedDimensionValue, y, z);
                    };
                    break;
                case 1:
                    getScalarDataPositionFromPlane = (x, z) => {
                        return getScalarDataPosition(x, fixedDimensionValue, z);
                    };
                    break;
                case 2:
                    getScalarDataPositionFromPlane = (x, y) => {
                        return getScalarDataPosition(x, y, fixedDimensionValue);
                    };
                    break;
                default:
                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);
            }
            return getScalarDataPositionFromPlane;
        };
    }
    getFixedDimension(viewPlaneNormal, direction) {
        const xDirection = direction.slice(0, 3);
        const yDirection = direction.slice(3, 6);
        const zDirection = direction.slice(6, 9);
        const absoluteOfViewPlaneNormal = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const absoluteOfXDirection = [
            Math.abs(xDirection[0]),
            Math.abs(xDirection[1]),
            Math.abs(xDirection[2]),
        ];
        if (PaintFillTool_isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {
            return 0;
        }
        const absoluteOfYDirection = [
            Math.abs(yDirection[0]),
            Math.abs(yDirection[1]),
            Math.abs(yDirection[2]),
        ];
        if (PaintFillTool_isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {
            return 1;
        }
        const absoluteOfZDirection = [
            Math.abs(zDirection[0]),
            Math.abs(zDirection[1]),
            Math.abs(zDirection[2]),
        ];
        if (PaintFillTool_isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {
            return 2;
        }
    }
}
PaintFillTool.toolName = 'PaintFill';
/* harmony default export */ const segmentation_PaintFillTool = ((/* unused pure expression or super */ null && (PaintFillTool)));

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget.js + 1 modules
var OrientationMarkerWidget = __webpack_require__(25161);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor.js + 2 modules
var AnnotatedCubeActor = __webpack_require__(85825);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AxesActor.js + 4 modules
var AxesActor = __webpack_require__(45700);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js + 4 modules
var XMLPolyDataReader = __webpack_require__(94199);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js












var OverlayMarkerType;
(function (OverlayMarkerType) {
    OverlayMarkerType[OverlayMarkerType["ANNOTATED_CUBE"] = 1] = "ANNOTATED_CUBE";
    OverlayMarkerType[OverlayMarkerType["AXES"] = 2] = "AXES";
    OverlayMarkerType[OverlayMarkerType["CUSTOM"] = 3] = "CUSTOM";
})(OverlayMarkerType || (OverlayMarkerType = {}));
class OrientationMarkerTool extends base/* BaseTool */.oS {
    static { this.CUBE = 1; }
    static { this.AXIS = 2; }
    static { this.VTPFILE = 3; }
    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            orientationWidget: {
                enabled: true,
                viewportCorner: OrientationMarkerWidget/* default */.Ay.Corners.BOTTOM_RIGHT,
                viewportSize: 0.15,
                minPixelSize: 100,
                maxPixelSize: 300,
            },
            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,
            overlayConfiguration: {
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {
                    faceProperties: {
                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },
                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },
                        yPlus: {
                            text: 'P',
                            faceColor: '#00ffff',
                            fontColor: 'white',
                            faceRotation: 180,
                        },
                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },
                        zPlus: { text: 'S' },
                        zMinus: { text: 'I' },
                    },
                    defaultStyle: {
                        fontStyle: 'bold',
                        fontFamily: 'Arial',
                        fontColor: 'black',
                        fontSizeScale: (res) => res / 2,
                        faceColor: '#0000ff',
                        edgeThickness: 0.1,
                        edgeColor: 'black',
                        resolution: 400,
                    },
                },
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},
                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {
                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._resizeObservers = new Map();
        this.onSetToolEnabled = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolActive = () => {
            this.initViewports();
            this._subscribeToViewportEvents();
        };
        this.onSetToolDisabled = () => {
            this.cleanUpData();
            this._unsubscribeToViewportNewVolumeSet();
        };
        this._getViewportsInfo = () => {
            const viewports = (0,store_ToolGroupManager.getToolGroup)(this.toolGroupId).viewportsInfo;
            return viewports;
        };
        this.resize = (viewportId) => {
            const orientationMarker = this.orientationMarkers[viewportId];
            if (!orientationMarker) {
                return;
            }
            const { orientationWidget } = orientationMarker;
            orientationWidget.updateViewport();
        };
        this.orientationMarkers = {};
        this.updatingOrientationMarker = {};
    }
    _unsubscribeToViewportNewVolumeSet() {
        const unsubscribe = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                element.removeEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = this._resizeObservers.get(viewportId);
                resizeObserver.unobserve(element);
            });
        };
        esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            unsubscribe();
            this.initViewports();
        });
    }
    _subscribeToViewportEvents() {
        const subscribeToElementResize = () => {
            const viewportsInfo = this._getViewportsInfo();
            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {
                const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                const { element } = viewport;
                this.initViewports();
                element.addEventListener(esm.Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));
                const resizeObserver = new ResizeObserver(() => {
                    setTimeout(() => {
                        const element = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
                        if (!element) {
                            return;
                        }
                        const { viewport } = element;
                        this.resize(viewportId);
                        viewport.render();
                    }, 100);
                });
                resizeObserver.observe(element);
                this._resizeObservers.set(viewportId, resizeObserver);
            });
        };
        subscribeToElementResize();
        esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {
            if (evt.detail.toolGroupId !== this.toolGroupId) {
                return;
            }
            subscribeToElementResize();
            this.initViewports();
        });
    }
    cleanUpData() {
        const renderingEngines = (0,esm.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        const viewports = renderingEngine.getViewports();
        viewports.forEach((viewport) => {
            const orientationMarker = this.orientationMarkers[viewport.id];
            if (!orientationMarker) {
                return;
            }
            const { actor, orientationWidget } = orientationMarker;
            orientationWidget?.setEnabled(false);
            orientationWidget?.delete();
            actor?.delete();
            const renderWindow = viewport
                .getRenderingEngine()
                .getOffscreenMultiRenderWindow(viewport.id)
                .getRenderWindow();
            renderWindow.render();
            viewport.getRenderingEngine().render();
            delete this.orientationMarkers[viewport.id];
        });
    }
    initViewports() {
        const renderingEngines = (0,esm.getRenderingEngines)();
        const renderingEngine = renderingEngines[0];
        if (!renderingEngine) {
            return;
        }
        let viewports = renderingEngine.getViewports();
        viewports = (0,viewportFilters.filterViewportsWithToolEnabled)(viewports, this.getToolName());
        viewports.forEach((viewport) => {
            const widget = viewport.getWidget(this.getToolName());
            if (!widget || widget.isDeleted()) {
                this.addAxisActorInViewport(viewport);
            }
        });
    }
    async addAxisActorInViewport(viewport) {
        const viewportId = viewport.id;
        if (!this.updatingOrientationMarker[viewportId]) {
            this.updatingOrientationMarker[viewportId] = true;
            const type = this.configuration.overlayMarkerType;
            const overlayConfiguration = this.configuration.overlayConfiguration[type];
            if (this.orientationMarkers[viewportId]) {
                const { actor, orientationWidget } = this.orientationMarkers[viewportId];
                viewport.getRenderer().removeActor(actor);
                orientationWidget.setEnabled(false);
            }
            let actor;
            if (type === 1) {
                actor = this.createAnnotationCube(overlayConfiguration);
            }
            else if (type === 2) {
                actor = AxesActor/* default.newInstance */.Ay.newInstance();
            }
            else if (type === 3) {
                actor = await this.createCustomActor();
            }
            const renderer = viewport.getRenderer();
            const renderWindow = viewport
                .getRenderingEngine()
                .getOffscreenMultiRenderWindow(viewportId)
                .getRenderWindow();
            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;
            const orientationWidget = OrientationMarkerWidget/* default.newInstance */.Ay.newInstance({
                actor,
                interactor: renderWindow.getInteractor(),
                parentRenderer: renderer,
            });
            orientationWidget.setEnabled(enabled);
            orientationWidget.setViewportCorner(viewportCorner);
            orientationWidget.setViewportSize(viewportSize);
            orientationWidget.setMinPixelSize(minPixelSize);
            orientationWidget.setMaxPixelSize(maxPixelSize);
            orientationWidget.updateMarkerOrientation();
            this.orientationMarkers[viewportId] = {
                orientationWidget,
                actor,
            };
            viewport.addWidget(this.getToolName(), orientationWidget);
            renderWindow.render();
            viewport.getRenderingEngine().render();
            this.updatingOrientationMarker[viewportId] = false;
        }
    }
    async createCustomActor() {
        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]
            .polyDataURL;
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const vtpReader = XMLPolyDataReader/* default.newInstance */.Ay.newInstance();
        vtpReader.parseAsArrayBuffer(arrayBuffer);
        vtpReader.update();
        const polyData = PolyData/* default.newInstance */.Ay.newInstance();
        polyData.shallowCopy(vtpReader.getOutputData());
        polyData.getPointData().setActiveScalars('Color');
        const mapper = Mapper/* default.newInstance */.Ay.newInstance();
        mapper.setInputData(polyData);
        mapper.setColorModeToDirectScalars();
        const actor = Actor/* default.newInstance */.Ay.newInstance();
        actor.setMapper(mapper);
        actor.rotateZ(180);
        return actor;
    }
    createAnnotationCube(overlayConfiguration) {
        const actor = AnnotatedCubeActor/* default.newInstance */.Ay.newInstance();
        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });
        actor.setXPlusFaceProperty({
            ...overlayConfiguration.faceProperties.xPlus,
        });
        actor.setXMinusFaceProperty({
            ...overlayConfiguration.faceProperties.xMinus,
        });
        actor.setYPlusFaceProperty({
            ...overlayConfiguration.faceProperties.yPlus,
        });
        actor.setYMinusFaceProperty({
            ...overlayConfiguration.faceProperties.yMinus,
        });
        actor.setZPlusFaceProperty({
            ...overlayConfiguration.faceProperties.zPlus,
        });
        actor.setZMinusFaceProperty({
            ...overlayConfiguration.faceProperties.zMinus,
        });
        return actor;
    }
    async createAnnotatedCubeActor() {
        const axes = AnnotatedCubeActor/* default.newInstance */.Ay.newInstance();
        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;
        axes.setDefaultStyle(defaultStyle);
        Object.keys(faceProperties).forEach((key) => {
            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;
            axes[methodName](faceProperties[key]);
        });
        return axes;
    }
}
OrientationMarkerTool.toolName = 'OrientationMarker';
/* harmony default export */ const tools_OrientationMarkerTool = ((/* unused pure expression or super */ null && (OrientationMarkerTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js + 1 modules
var segmentation_activeSegmentation = __webpack_require__(26228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentIndex = __webpack_require__(70930);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js









class SegmentSelectTool extends base/* BaseTool */.oS {
    static { this.SelectMode = {
        Inside: 'Inside',
        Border: 'Border',
    }; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            mode: SegmentSelectTool.SelectMode.Border,
            searchRadius: 6,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.mode !== enums.ToolModes.Active) {
                return;
            }
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setActiveSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.hoverTimer = null;
    }
    _setActiveSegment(evt = {}) {
        if (store_state/* state */.wk.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,segmentation_activeSegmentation.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId, representationData } = activeSegmentation;
        let hoveredSegmentIndex;
        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {
            hoveredSegmentIndex = (0,segmentation.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
                viewport,
            });
        }
        else {
            if (representationData.Labelmap) {
                hoveredSegmentIndex = (0,segmentation.getSegmentIndexAtLabelmapBorder)(segmentationId, worldPoint, {
                    viewport,
                    searchRadius: this.configuration.searchRadius,
                });
            }
            else if (representationData.Contour) {
                hoveredSegmentIndex =
                    (0,segmentation.getHoveredContourSegmentationAnnotation)(segmentationId);
            }
            else if (representationData.Surface) {
            }
        }
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        (0,segmentIndex.setActiveSegmentIndex)(segmentationId, hoveredSegmentIndex);
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIds);
    }
}
SegmentSelectTool.toolName = 'SegmentSelectTool';
/* harmony default export */ const segmentation_SegmentSelectTool = ((/* unused pure expression or super */ null && (SegmentSelectTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
var segmentationColor = __webpack_require__(93733);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js











class SegmentBidirectionalTool extends BidirectionalTool/* default */.A {
    static { this.toolName = 'SegmentBidirectional'; }
    constructor(toolProps = {}) {
        super(toolProps);
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const viewportId = viewport.id;
            let annotations = (0,annotationState.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { segmentIndex, segmentationId } = annotation.metadata;
                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const colorArray = (0,segmentationColor.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,annotationVisibility.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,annotationLocking.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,drawingSvg.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineWidth,
                    lineDash,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                options.color = color;
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,drawing.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,drawingSvg.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        const { viewport } = enabledElement;
        this.isDrawing = true;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const annotation = {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID,
                referencedImageId,
                ...viewport.getViewReference({ points: [worldPos] }),
            },
            data: {
                handles: {
                    points: [
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                        [...worldPos],
                    ],
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
        };
        (0,annotationState.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,elementCursor.hideElementCursor)(element);
        evt.preventDefault();
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,esm.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const existingAnnotations = (0,annotationState.getAllAnnotations)();
        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');
        const existingAnnotation = toolAnnotations.find((annotation) => {
            const { metadata } = annotation;
            if (metadata.segmentIndex === options?.segmentIndex &&
                metadata.segmentationId === options?.segmentationId) {
                return true;
            }
            return false;
        });
        if (existingAnnotation) {
            (0,annotationState.removeAnnotation)(existingAnnotation.annotationUID);
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || esm.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                segmentIndex: options?.segmentIndex,
                segmentationId: options?.segmentationId,
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,annotationState.addAnnotation)(annotation, viewport.element);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)([viewport.id]);
        return annotation;
    }; }
}
/* harmony default export */ const segmentation_SegmentBidirectionalTool = ((/* unused pure expression or super */ null && (SegmentBidirectionalTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js
var strategies = __webpack_require__(99522);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js









class SegmentLabelTool extends base/* BaseTool */.oS {
    constructor(toolProps = {
        data: {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        },
    }, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            hoverTimeout: 100,
            searchRadius: 6,
            color: null,
            background: null,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.mouseMoveCallback = (evt) => {
            if (this.hoverTimer) {
                clearTimeout(this.hoverTimer);
            }
            this.hoverTimer = setTimeout(() => {
                this._setHoveredSegment(evt);
                this.hoverTimer = null;
            }, this.configuration.hoverTimeout);
            return true;
        };
        this.onSetToolEnabled = () => {
            this.onSetToolActive();
        };
        this.onSetToolActive = () => {
            this.hoverTimer = null;
        };
        this.onSetToolDisabled = () => {
            this.hoverTimer = null;
        };
        this.data = toolProps.data ?? {
            handles: {
                textBox: {
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
            },
        };
        this.hoverTimer = null;
    }
    _setHoveredSegment(evt = {}) {
        if (store_state/* state */.wk.isInteractingWithTool) {
            return;
        }
        const { element, currentPoints } = evt.detail;
        const worldPoint = currentPoints.world;
        const enabledElement = (0,esm.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const { viewport } = enabledElement;
        const activeSegmentation = (0,segmentation_activeSegmentation.getActiveSegmentation)(viewport.id);
        if (!activeSegmentation) {
            return;
        }
        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);
    }
    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {
        const imageDataInfo = viewport.getImageData();
        if (!imageDataInfo) {
            return;
        }
        const { segmentationId } = activeSegmentation;
        const hoveredSegmentIndex = (0,segmentation.getSegmentIndexAtWorldPoint)(segmentationId, worldPoint, {
            viewport,
        });
        const segment = activeSegmentation.segments[hoveredSegmentIndex];
        const color = this.configuration.color ??
            stateManagement_segmentation.config.color.getSegmentIndexColor(viewport.id, segmentationId, hoveredSegmentIndex);
        const label = segment?.label;
        const canvasCoordinates = viewport.worldToCanvas(worldPoint);
        this._editData = {
            hoveredSegmentIndex,
            hoveredSegmentLabel: label,
            canvasCoordinates,
            color,
        };
        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {
            return;
        }
        const renderingEngine = viewport.getRenderingEngine();
        const viewportIds = renderingEngine.getViewports().map((v) => v.id);
        (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentationId);
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportIds);
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._editData) {
            return;
        }
        const { viewport } = enabledElement;
        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, color, } = this._editData;
        if (!hoveredSegmentIndex) {
            return;
        }
        const offset = -15;
        const textBoxPosition = [
            canvasCoordinates[0] + offset,
            canvasCoordinates[1] + offset,
        ];
        const boundingBox = (0,drawingSvg.drawTextBox)(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ?? '(unnamed segment)'], textBoxPosition, {
            color: `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`,
            background: this.configuration.background ?? undefined,
        });
        const left = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const { width, height } = boundingBox;
        this.data.handles.textBox.worldBoundingBox = {
            topLeft: viewport.canvasToWorld([left, top]),
            topRight: viewport.canvasToWorld([left + width, top]),
            bottomLeft: viewport.canvasToWorld([left, top + height]),
            bottomRight: viewport.canvasToWorld([left + width, top + height]),
        };
    }
}
SegmentLabelTool.toolName = 'SegmentLabelTool';
/* harmony default export */ const segmentation_SegmentLabelTool = ((/* unused pure expression or super */ null && (SegmentLabelTool)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapEditWithContour.js






class LabelMapEditWithContourTool extends PlanarFreehandContourSegmentationTool/* default */.A {
    static { this.toolName = 'LabelMapEditWithContour'; }
    static { this.annotationsToViewportMap = new Map(); }
    static { this.viewportIdsChecked = []; }
    constructor(toolProps = {}) {
        const initialProps = esm.utilities.deepMerge({
            configuration: {
                calculateStats: false,
                allowOpenContours: false,
            },
        }, toolProps);
        super(initialProps);
        this.onViewportAddedToToolGroupBinded =
            this.onViewportAddedToToolGroup.bind(this);
        this.onSegmentationModifiedBinded = this.onSegmentationModified.bind(this);
    }
    initializeListeners() {
        LabelMapEditWithContourTool.annotationsToViewportMap.clear();
        LabelMapEditWithContourTool.viewportIdsChecked = [];
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_MODIFIED, this.annotationModified);
        esm.eventTarget.addEventListener(enums.Events.ANNOTATION_COMPLETED, this.annotationCompleted);
        esm.eventTarget.addEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroupBinded);
        esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_MODIFIED, this.onSegmentationModifiedBinded);
        esm.eventTarget.addEventListener(enums.Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModifiedBinded);
    }
    cleanUpListeners() {
        LabelMapEditWithContourTool.annotationsToViewportMap.clear();
        LabelMapEditWithContourTool.viewportIdsChecked = [];
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_MODIFIED, this.annotationModified);
        esm.eventTarget.removeEventListener(enums.Events.ANNOTATION_COMPLETED, this.annotationCompleted);
        esm.eventTarget.removeEventListener(enums.Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroup.bind(this));
        esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_MODIFIED, this.onSegmentationModified.bind(this));
        esm.eventTarget.removeEventListener(enums.Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModified.bind(this));
    }
    async checkContourSegmentation(viewportId) {
        if (LabelMapEditWithContourTool.viewportIdsChecked.includes(viewportId)) {
            return;
        }
        const activeSeg = stateManagement_segmentation.getActiveSegmentation(viewportId);
        if (!activeSeg) {
            console.log('No active segmentation detected');
            return false;
        }
        const segmentationId = activeSeg.segmentationId;
        if (!activeSeg.representationData.Contour) {
            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);
            await stateManagement_segmentation.addContourRepresentationToViewport(viewportId, [
                {
                    segmentationId,
                    type: enums.SegmentationRepresentations.Contour,
                },
            ]);
            stateManagement_segmentation.addRepresentationData({
                segmentationId,
                type: enums.SegmentationRepresentations.Contour,
                data: {},
            });
        }
        else {
            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);
        }
        return true;
    }
    onViewportAddedToToolGroup(evt) {
        const { toolGroupId, viewportId } = evt.detail;
        if (toolGroupId !== this.toolGroupId) {
            return;
        }
        this.checkContourSegmentation(viewportId);
    }
    onSegmentationModified(evt) {
        const { segmentationId } = evt.detail || {};
        if (!segmentationId) {
            return;
        }
        const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentationsBySegmentationId */.ny)(segmentationId);
        if (!representations) {
            return;
        }
        representations.forEach(async ({ viewportId }) => await this.checkContourSegmentation(viewportId));
    }
    onSetToolEnabled() {
        this.initializeListeners();
    }
    onSetToolActive() {
        this.initializeListeners();
    }
    onSetToolDisabled() {
        this.cleanUpListeners();
    }
    annotationModified(evt) {
        const { annotation, renderingEngineId, viewportId } = evt.detail;
        const viewport = (0,esm.getRenderingEngine)(renderingEngineId)?.getViewport(viewportId);
        if (!viewport) {
            return;
        }
        LabelMapEditWithContourTool.annotationsToViewportMap.set(annotation.annotationUID, viewport);
    }
    annotationCompleted(evt) {
        const { annotation } = evt.detail;
        const { polyline } = annotation.data?.contour || {};
        if (annotation?.metadata?.toolName !== LabelMapEditWithContourTool.toolName) {
            return;
        }
        if (!polyline) {
            return;
        }
        if (LabelMapEditWithContourTool.annotationsToViewportMap.has(annotation.annotationUID)) {
            const viewport = LabelMapEditWithContourTool.annotationsToViewportMap.get(annotation.annotationUID);
            if (polyline.length > 3) {
                BrushTool/* default */.A.viewportContoursToLabelmap(viewport);
            }
        }
    }
}
/* harmony default export */ const LabelmapEditWithContour = ((/* unused pure expression or super */ null && (LabelMapEditWithContourTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/index.js
































































// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js
var rectangle = __webpack_require__(33657);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js













class VideoRedactionTool extends base/* AnnotationTool */.EC {
    static { this.toolName = 'VideoRedaction'; }
    constructor(toolConfiguration = {}) {
        super(toolConfiguration, {
            supportedInteractionTypes: ['Mouse', 'Touch'],
            configuration: { shadow: true, preventHandleOutsideImage: false },
        });
        this.addNewAnnotation = (evt) => {
            const eventData = evt.detail;
            const { currentPoints, element } = eventData;
            const worldPos = currentPoints.world;
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                    },
                },
            });
            (0,stateManagement/* addAnnotation */.lC)(annotation, element);
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,elementCursor.hideElementCursor)(element);
            evt.preventDefault();
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            return annotation;
        };
        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);
                const near = gl_matrix_esm/* vec2.distance */.Zc.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;
                if (near === true) {
                    data.handles.activeHandleIndex = i;
                    return point;
                }
            }
            data.handles.activeHandleIndex = null;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,esm.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
        };
        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { data } = annotation;
            data.active = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportUIDsToRender = (0,viewportFilters.getViewportIdsWithToolToRender)(element, this.getToolName(), false);
            this.editData = {
                annotation,
                viewportUIDsToRender,
                handleIndex,
            };
            this._activateModify(element);
            (0,elementCursor.hideElementCursor)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.active = false;
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,elementCursor.resetElementCursor)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,stateManagement/* removeAnnotation */.O8)(annotation.annotationUID);
            }
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventData = evt.detail;
            const { element } = eventData;
            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (handleIndex === undefined) {
                const { deltaPoints } = eventData;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                data.invalidated = true;
            }
            else {
                const { currentPoints } = eventData;
                const enabledElement = (0,esm.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                data.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,esm.getEnabledElement)(element);
            (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        };
        this._activateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateDraw = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._activateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = true;
            element.addEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.addEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this._deactivateModify = (element) => {
            store_state/* state */.wk.isInteractingWithTool = false;
            element.removeEventListener(enums.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(enums.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(enums.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(enums.Events.TOUCH_DRAG, this._dragCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            const renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,stateManagement/* getAnnotations */.Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID } = annotation;
                const data = annotation.data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return;
                }
                let activeHandleCanvasCoords;
                if (!this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,drawingSvg.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,drawingSvg.drawRedactionRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color: 'black',
                    lineDash,
                    lineWidth,
                });
            }
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetUIDs = Object.keys(cachedStats);
            for (let i = 0; i < targetUIDs.length; i++) {
                const targetUID = targetUIDs[i];
                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);
                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;
                const worldPos1Index = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
                const worldPos2Index = gl_matrix_esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
                imageData.worldToIndexVec3(worldPos1, worldPos1Index);
                worldPos1Index[0] = Math.floor(worldPos1Index[0]);
                worldPos1Index[1] = Math.floor(worldPos1Index[1]);
                worldPos1Index[2] = Math.floor(worldPos1Index[2]);
                imageData.worldToIndexVec3(worldPos2, worldPos2Index);
                worldPos2Index[0] = Math.floor(worldPos2Index[0]);
                worldPos2Index[1] = Math.floor(worldPos2Index[1]);
                worldPos2Index[2] = Math.floor(worldPos2Index[2]);
                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                    const { worldWidth, worldHeight } = (0,getWorldWidthAndHeightFromTwoPoints/* default */.A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const area = worldWidth * worldHeight;
                    let count = 0;
                    let mean = 0;
                    let stdDev = 0;
                    const yMultiple = dimensions[0];
                    const zMultiple = dimensions[0] * dimensions[1];
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                count++;
                                mean += value;
                            }
                        }
                    }
                    mean /= count;
                    for (let k = kMin; k <= kMax; k++) {
                        for (let j = jMin; j <= jMax; j++) {
                            for (let i = iMin; i <= iMax; i++) {
                                const value = scalarData[k * zMultiple + j * yMultiple + i];
                                const valueMinusMean = value - mean;
                                stdDev += valueMinusMean * valueMinusMean;
                            }
                        }
                    }
                    stdDev /= count;
                    stdDev = Math.sqrt(stdDev);
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                        area,
                        mean,
                        stdDev,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetUID] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                const eventType = enums.Events.ANNOTATION_MODIFIED;
                const eventDetail = {
                    annotation,
                    viewportUID,
                    renderingEngineUID,
                    sceneUID: sceneUID,
                    changeType: enums.ChangeTypes.StatsUpdated,
                };
                (0,esm.triggerEvent)(esm.eventTarget, eventType, eventDetail);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (esm.utilities.indexWithinDimensions(index1, dimensions) &&
                esm.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._getTargetVolumeUID = (scene) => {
            if (this.configuration.volumeUID) {
                return this.configuration.volumeUID;
            }
            const volumeActors = scene.getVolumeActors();
            if (!volumeActors && !volumeActors.length) {
                return;
            }
            return volumeActors[0].uid;
        };
        this._throttledCalculateCachedStats = (0,throttle/* default */.A)(this._calculateCachedStats, 100, { trailing: true });
    }
    cancel(element) {
        if (!this.isDrawing) {
            return;
        }
        this.isDrawing = false;
        this._deactivateDraw(element);
        this._deactivateModify(element);
        (0,elementCursor.resetElementCursor)(element);
        const { annotation, viewportUIDsToRender } = this.editData;
        const { data } = annotation;
        data.active = false;
        data.handles.activeHandleIndex = null;
        (0,triggerAnnotationRenderForViewportIds/* default */.A)(viewportUIDsToRender);
        this.editData = null;
        return annotation.annotationUID;
    }
    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {
        let imageVolume, viewport;
        if (targetUID.startsWith('stackTarget')) {
            const coloneIndex = targetUID.indexOf(':');
            const viewportUID = targetUID.substring(coloneIndex + 1);
            const viewport = renderingEngine.getViewport(viewportUID);
            imageVolume = viewport.getImageData();
        }
        else {
            imageVolume = esm.cache.getVolume(targetUID);
        }
        return { imageVolume, viewport };
    }
    _getTargetStackUID(viewport) {
        return `stackTarget:${viewport.uid}`;
    }
}
/* harmony default export */ const annotation_VideoRedactionTool = ((/* unused pure expression or super */ null && (VideoRedactionTool)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/index.js



















// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// ../../../node_modules/@kitware/vtk.js/Filters/General/ContourLoopExtraction.js



const Dir = {
  Forward: 1,
  Backward: -1
};
const visited = new Set();
function vtkContourLoopExtraction(publicAPI, model) {
  publicAPI.requestData = (inData, outData) => {
    const [input] = inData;
    if (!outData[0]) {
      outData[0] = PolyData/* default.newInstance */.Ay.newInstance();
    }
    const [output] = outData;
    publicAPI.extractContours(input, output);
    output.modified();
  };
  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {
    let lineId = startLineId;
    let lastPtId = startPtId;
    let terminated = false;
    let numInserted = 0;
    while (!terminated) {
      const {
        cellPointIds
      } = pd.getCellPoints(lineId);
      if (!cellPointIds) {
        // eslint-disable-next-line no-continue
        continue;
      }
      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];
      numInserted++;

      // parametric point value
      const t = dir * numInserted;
      loopPoints.push({
        t,
        ptId: lastPtId
      });
      const lineCell = pd.getPointCells(lastPtId);
      if (lineCell.length !== 2 || lastPtId === startPtId) {
        // looped
        return lastPtId;
      }
      if (lineCell.length === 2) {
        // continue along loop
        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];
        visited.add(lineId);
      } else {
        // empty or invalid cell
        terminated = true;
      }
    }
    return lastPtId;
  };
  publicAPI.extractContours = (input, output) => {
    const loops = [];
    visited.clear();
    const inLines = input.getLines();
    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));

    // TODO skip if cached input mtime hasn't changed.
    // iterate over input lines
    for (let li = 0; li < inLines.getNumberOfCells(); li++) {
      if (visited.has(li)) {
        // eslint-disable-next-line no-continue
        continue;
      }
      const {
        cellPointIds
      } = input.getCellPoints(li);
      if (!cellPointIds) {
        // eslint-disable-next-line no-continue
        continue;
      }
      visited.add(li);
      const startPtId = cellPointIds[0];
      const loopPoints = [];
      loopPoints.push({
        t: 0,
        ptId: startPtId
      });
      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);
      if (startPtId !== endPtId) {
        // didn't find a loop. Go other direction to see where we end up
        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);
        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);
        // make closed contour
        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {
          loopPoints.push({
            ...loopPoints[loopPoints.length - 1]
          });
        }
      }
      if (loopPoints.length) {
        loops.push(loopPoints);
      }
    }

    // clear output lines
    const outLines = output.getLines();
    outLines.resize(0);
    loops.forEach(loop => {
      outLines.insertNextCell(loop.map(pt => pt.ptId));
    });
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  macros2.m.algo(publicAPI, model, 1, 1);
  vtkContourLoopExtraction(publicAPI);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkContourLoopExtraction');

// ----------------------------------------------------------------------------

var ContourLoopExtraction_index = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var Cutter = __webpack_require__(61088);
;// ../../../node_modules/@cornerstonejs/polymorphic-segmentation/dist/esm/workers/polySegConverters.js









const { math: { polyline: { containsPoint, getAABB, projectTo2D }, }, geometricSurfaceUtils: { checkStandardBasis, rotatePoints }, boundingBox: { getBoundingBoxAroundShapeWorld }, planar: { isPlaneIntersectingAABB }, } = utilities_namespaceObject;
async function peerImport(moduleId) {
    try {
        if (moduleId === '@icr/polyseg-wasm') {
            return __webpack_require__.e(/* import() */ 7758).then(__webpack_require__.bind(__webpack_require__, 65745));
        }
    }
    catch (error) {
        console.warn('Error importing module:', error);
        return null;
    }
}
const polySegConverters = {
    polySeg: null,
    polySegInitializing: false,
    polySegInitializingPromise: null,
    async initializePolySeg(progressCallback) {
        let ICRPolySeg;
        try {
            ICRPolySeg = (await peerImport('@icr/polyseg-wasm')).default;
        }
        catch (error) {
            console.error(error);
            console.debug("Warning: '@icr/polyseg-wasm' module not found. Please install it separately.");
            return;
        }
        if (this.polySegInitializing) {
            await this.polySegInitializingPromise;
            return;
        }
        if (this.polySeg?.instance) {
            return;
        }
        this.polySegInitializing = true;
        this.polySegInitializingPromise = new Promise((resolve) => {
            this.polySeg = new ICRPolySeg();
            this.polySeg
                .initialize({
                updateProgress: progressCallback,
            })
                .then(() => {
                this.polySegInitializing = false;
                resolve();
            });
        });
        await this.polySegInitializingPromise;
    },
    async convertContourToSurface(args, ...callbacks) {
        const { polylines, numPointsArray } = args;
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const results = await this.polySeg.instance.convertContourRoiToSurface(polylines, numPointsArray);
        return results;
    },
    async convertLabelmapToSurface(args, ...callbacks) {
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const results = this.polySeg.instance.convertLabelmapToSurface(args.scalarData, args.dimensions, args.spacing, args.direction, args.origin, [args.segmentIndex]);
        const rotationInfo = checkStandardBasis(args.direction);
        if (!rotationInfo.isStandard) {
            const rotatedPoints = rotatePoints(rotationInfo.rotationMatrix, args.origin, results.points);
            results.points = [...rotatedPoints];
        }
        return results;
    },
    async convertContourToVolumeLabelmap(args, ...callbacks) {
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const { segmentIndices, scalarData, annotationUIDsInSegmentMap, dimensions, origin, direction, spacing, } = args;
        const segmentationVoxelManager = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData,
        });
        const imageData = ImageData/* default.newInstance */.Ay.newInstance();
        imageData.setDimensions(dimensions);
        imageData.setOrigin(origin);
        imageData.setDirection(direction);
        imageData.setSpacing(spacing);
        const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
            name: 'Pixels',
            numberOfComponents: 1,
            values: scalarData,
        });
        imageData.getPointData().setScalars(scalarArray);
        imageData.modified();
        for (const index of segmentIndices) {
            const annotations = annotationUIDsInSegmentMap.get(index);
            for (const annotation of annotations) {
                if (!annotation.polyline) {
                    continue;
                }
                const { polyline, holesPolyline } = annotation;
                const bounds = getBoundingBoxAroundShapeWorld(polyline);
                const [iMin, jMin, kMin] = esm.utilities.transformWorldToIndex(imageData, [
                    bounds[0][0],
                    bounds[1][0],
                    bounds[2][0],
                ]);
                const [iMax, jMax, kMax] = esm.utilities.transformWorldToIndex(imageData, [
                    bounds[0][1],
                    bounds[1][1],
                    bounds[2][1],
                ]);
                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);
                const holes = holesPolyline?.map((hole) => {
                    const { projectedPolyline: projectedHole } = projectTo2D(hole);
                    return projectedHole;
                });
                const firstDim = (sharedDimensionIndex + 1) % 3;
                const secondDim = (sharedDimensionIndex + 2) % 3;
                const voxels = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
                    dimensions,
                    scalarData,
                });
                voxels.forEach(({ pointIJK }) => {
                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);
                }, {
                    imageData,
                    isInObject: (pointLPS) => {
                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];
                        const isInside = containsPoint(projectedPolyline, point2D, {
                            holes,
                        });
                        return isInside;
                    },
                    boundsIJK: [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ],
                });
            }
        }
        return segmentationVoxelManager.scalarData;
    },
    async convertContourToStackLabelmap(args, ...callbacks) {
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } = args;
        const segmentationVoxelManagers = new Map();
        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {
            const { dimensions, scalarData, direction, spacing, origin } = segmentationInfo;
            const manager = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
                dimensions,
                scalarData,
            });
            const imageData = ImageData/* default.newInstance */.Ay.newInstance();
            imageData.setDimensions(dimensions);
            imageData.setOrigin(origin);
            imageData.setDirection(direction);
            imageData.setSpacing(spacing);
            const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: scalarData,
            });
            imageData.getPointData().setScalars(scalarArray);
            imageData.modified();
            segmentationVoxelManagers.set(referencedImageId, { manager, imageData });
        });
        for (const index of segmentIndices) {
            const annotations = annotationUIDsInSegmentMap.get(index);
            for (const annotation of annotations) {
                if (!annotation.polyline) {
                    continue;
                }
                const { polyline, holesPolyline, referencedImageId } = annotation;
                const bounds = getBoundingBoxAroundShapeWorld(polyline);
                const { manager: segmentationVoxelManager, imageData } = segmentationVoxelManagers.get(referencedImageId);
                const [iMin, jMin, kMin] = esm.utilities.transformWorldToIndex(imageData, [
                    bounds[0][0],
                    bounds[1][0],
                    bounds[2][0],
                ]);
                const [iMax, jMax, kMax] = esm.utilities.transformWorldToIndex(imageData, [
                    bounds[0][1],
                    bounds[1][1],
                    bounds[2][1],
                ]);
                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);
                const holes = holesPolyline?.map((hole) => {
                    const { projectedPolyline: projectedHole } = projectTo2D(hole);
                    return projectedHole;
                });
                const firstDim = (sharedDimensionIndex + 1) % 3;
                const secondDim = (sharedDimensionIndex + 2) % 3;
                const voxels = esm.utilities.VoxelManager.createImageVoxelManager({
                    width: imageData.getDimensions()[0],
                    height: imageData.getDimensions()[1],
                    scalarData: imageData.getPointData().getScalars().getData(),
                });
                voxels.forEach(({ pointIJK }) => {
                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);
                }, {
                    imageData,
                    isInObject: (pointLPS) => {
                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];
                        const isInside = containsPoint(projectedPolyline, point2D, {
                            holes,
                        });
                        return isInside;
                    },
                    boundsIJK: [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ],
                });
            }
        }
        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {
            const { manager: segmentationVoxelManager } = segmentationVoxelManagers.get(referencedImageId);
            segmentationInfo.scalarData = segmentationVoxelManager.scalarData;
        });
        return segmentationsInfo;
    },
    async convertSurfaceToVolumeLabelmap(args, ...callbacks) {
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const results = this.polySeg.instance.convertSurfaceToLabelmap(args.points, args.polys, args.dimensions, args.spacing, args.direction, args.origin);
        return results;
    },
    async convertSurfacesToVolumeLabelmap(args, ...callbacks) {
        const [progressCallback] = callbacks;
        await this.initializePolySeg(progressCallback);
        const { segmentsInfo } = args;
        const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {
            const { points, polys } = segmentsInfo.get(segmentIndex);
            const result = this.polySeg.instance.convertSurfaceToLabelmap(points, polys, args.dimensions, args.spacing, args.direction, args.origin);
            return {
                ...result,
                segmentIndex,
            };
        });
        const results = await Promise.all(promises);
        const targetImageData = ImageData/* default.newInstance */.Ay.newInstance();
        targetImageData.setDimensions(args.dimensions);
        targetImageData.setOrigin(args.origin);
        targetImageData.setSpacing(args.spacing);
        targetImageData.setDirection(args.direction);
        const totalSize = args.dimensions[0] * args.dimensions[1] * args.dimensions[2];
        const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
            name: 'Pixels',
            numberOfComponents: 1,
            values: new Uint8Array(totalSize),
        });
        targetImageData.getPointData().setScalars(scalarArray);
        targetImageData.modified();
        const { dimensions } = args;
        const scalarData = targetImageData.getPointData().getScalars().getData();
        const segmentationVoxelManager = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData,
        });
        const outputVolumesInfo = results.map((result) => {
            const { data, dimensions, direction, origin, spacing } = result;
            const volume = ImageData/* default.newInstance */.Ay.newInstance();
            volume.setDimensions(dimensions);
            volume.setOrigin(origin);
            volume.setSpacing(spacing);
            volume.setDirection(direction);
            const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: data,
            });
            volume.getPointData().setScalars(scalarArray);
            volume.modified();
            const voxelManager = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
                dimensions,
                scalarData: data,
            });
            const extent = volume.getExtent();
            return {
                volume,
                voxelManager,
                extent,
                scalarData: data,
                segmentIndex: result.segmentIndex,
            };
        });
        const voxels = esm.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions: targetImageData.getDimensions(),
            scalarData: targetImageData.getPointData().getScalars().getData(),
        });
        voxels.forEach(({ pointIJK, pointLPS }) => {
            try {
                for (const volumeInfo of outputVolumesInfo) {
                    const { volume, extent, voxelManager, segmentIndex } = volumeInfo;
                    const index = volume.worldToIndex(pointLPS);
                    if (index[0] < extent[0] ||
                        index[0] > extent[1] ||
                        index[1] < extent[2] ||
                        index[1] > extent[3] ||
                        index[2] < extent[4] ||
                        index[2] > extent[5]) {
                        continue;
                    }
                    const roundedIndex = index.map(Math.round);
                    const value = voxelManager.getAtIJK(...roundedIndex);
                    if (value > 0) {
                        segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);
                        break;
                    }
                }
            }
            catch (error) {
            }
        }, { imageData: targetImageData });
        return segmentationVoxelManager.scalarData;
    },
    getSurfacesAABBs({ surfacesInfo }) {
        const aabbs = new Map();
        for (const { points, id } of surfacesInfo) {
            const aabb = getAABB(points, { numDimensions: 3 });
            aabbs.set(id, aabb);
        }
        return aabbs;
    },
    cutSurfacesIntoPlanes({ planesInfo, surfacesInfo, surfacesAABB = new Map() }, progressCallback, updateCacheCallback) {
        const numberOfPlanes = planesInfo.length;
        const cutter = Cutter/* default.newInstance */.Ay.newInstance();
        const plane1 = Plane/* default.newInstance */.Ay.newInstance();
        cutter.setCutFunction(plane1);
        const surfacePolyData = PolyData/* default.newInstance */.Ay.newInstance();
        try {
            for (const [index, planeInfo] of planesInfo.entries()) {
                const { sliceIndex, planes } = planeInfo;
                const polyDataResults = new Map();
                for (const polyDataInfo of surfacesInfo) {
                    const { points, polys, id, segmentIndex } = polyDataInfo;
                    const aabb3 = surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });
                    if (!surfacesAABB.has(id)) {
                        surfacesAABB.set(id, aabb3);
                    }
                    const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;
                    const { origin, normal } = planes[0];
                    if (!isPlaneIntersectingAABB(origin, normal, minX, minY, minZ, maxX, maxY, maxZ)) {
                        continue;
                    }
                    surfacePolyData.getPoints().setData(points, 3);
                    surfacePolyData.getPolys().setData(polys);
                    surfacePolyData.modified();
                    cutter.setInputData(surfacePolyData);
                    plane1.setOrigin(origin);
                    plane1.setNormal(normal);
                    try {
                        cutter.update();
                    }
                    catch (e) {
                        console.warn('Error during clipping', e);
                        continue;
                    }
                    const polyData = cutter.getOutputData();
                    if (!polyData ||
                        !polyData.getPoints() ||
                        polyData.getPoints().getNumberOfPoints() === 0) {
                        continue;
                    }
                    const cutterOutput = polyData;
                    cutterOutput.buildLinks();
                    const loopExtraction = ContourLoopExtraction_index.newInstance();
                    loopExtraction.setInputData(cutterOutput);
                    try {
                        loopExtraction.update();
                        const loopOutput = loopExtraction.getOutputData();
                        if (loopOutput &&
                            loopOutput.getPoints() &&
                            loopOutput.getLines() &&
                            loopOutput.getPoints().getNumberOfPoints() > 0 &&
                            loopOutput.getLines().getNumberOfCells() > 0) {
                            polyDataResults.set(segmentIndex, {
                                points: loopOutput.getPoints().getData(),
                                lines: loopOutput.getLines().getData(),
                                numberOfCells: loopOutput.getLines().getNumberOfCells(),
                                segmentIndex,
                            });
                        }
                    }
                    catch (loopError) {
                        console.warn('Error during loop extraction:', loopError);
                        continue;
                    }
                }
                progressCallback({ progress: (index + 1) / numberOfPlanes });
                updateCacheCallback({ sliceIndex, polyDataResults });
            }
        }
        catch (e) {
            console.warn('Error during processing', e);
        }
        finally {
            surfacesInfo = null;
            plane1.delete();
        }
    },
};
(0,comlink/* expose */.p)(polySegConverters);


/***/ }),

/***/ 93952:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const CORNERSTONE_COLOR_LUT = [
    [0, 0, 0, 0],
    [221, 84, 84, 255],
    [77, 228, 121, 255],
    [166, 70, 235, 255],
    [189, 180, 116, 255],
    [109, 182, 196, 255],
    [204, 101, 157, 255],
    [123, 211, 94, 255],
    [93, 87, 218, 255],
    [225, 128, 80, 255],
    [73, 232, 172, 255],
    [181, 119, 186, 255],
    [176, 193, 112, 255],
    [105, 153, 200, 255],
    [208, 97, 120, 255],
    [90, 215, 101, 255],
    [135, 83, 222, 255],
    [229, 178, 76, 255],
    [122, 183, 181, 255],
    [190, 115, 171, 255],
    [149, 197, 108, 255],
    [100, 118, 205, 255],
    [212, 108, 93, 255],
    [86, 219, 141, 255],
    [183, 79, 226, 255],
    [233, 233, 72, 255],
    [118, 167, 187, 255],
    [194, 111, 146, 255],
    [116, 201, 104, 255],
    [115, 96, 209, 255],
    [216, 147, 89, 255],
    [82, 223, 188, 255],
    [230, 75, 224, 255],
    [163, 184, 121, 255],
    [114, 143, 191, 255],
    [198, 107, 114, 255],
    [99, 206, 122, 255],
    [153, 92, 213, 255],
    [220, 192, 85, 255],
    [78, 215, 227, 255],
    [234, 71, 173, 255],
    [141, 188, 117, 255],
    [110, 113, 195, 255],
    [202, 128, 103, 255],
    [95, 210, 157, 255],
    [195, 88, 217, 255],
    [206, 224, 81, 255],
    [74, 166, 231, 255],
    [185, 120, 139, 255],
    [113, 192, 113, 255],
    [133, 106, 199, 255],
    [207, 162, 98, 255],
    [91, 214, 198, 255],
    [221, 84, 198, 255],
    [159, 228, 77, 255],
    [70, 111, 235, 255],
    [189, 119, 116, 255],
    [109, 196, 138, 255],
    [165, 101, 204, 255],
    [211, 201, 94, 255],
    [87, 191, 218, 255],
    [225, 80, 153, 255],
    [106, 232, 73, 255],
    [124, 119, 186, 255],
    [193, 142, 112, 255],
    [105, 200, 168, 255],
    [203, 97, 208, 255],
    [184, 215, 90, 255],
    [83, 147, 222, 255],
    [229, 76, 101, 255],
    [122, 183, 130, 255],
    [146, 115, 190, 255],
    [197, 171, 108, 255],
    [100, 205, 205, 255],
    [212, 93, 177, 255],
    [141, 219, 86, 255],
    [79, 97, 226, 255],
    [233, 99, 72, 255],
    [118, 187, 150, 255],
    [173, 111, 194, 255],
    [197, 201, 104, 255],
    [96, 171, 209, 255],
    [216, 89, 137, 255],
    [94, 223, 82, 255],
    [107, 75, 230, 255],
    [184, 153, 121, 255],
    [114, 191, 175, 255],
    [198, 107, 191, 255],
    [166, 206, 99, 255],
    [92, 132, 213, 255],
    [220, 85, 91, 255],
    [78, 227, 115, 255],
    [159, 71, 234, 255],
    [188, 176, 117, 255],
    [110, 185, 195, 255],
    [202, 103, 161, 255],
    [129, 210, 95, 255],
    [88, 88, 217, 255],
    [224, 123, 81, 255],
    [74, 231, 166, 255],
    [177, 120, 185, 255],
    [179, 192, 113, 255],
    [106, 156, 199, 255],
    [207, 98, 125, 255],
    [91, 214, 96, 255],
    [130, 84, 221, 255],
    [228, 171, 77, 255],
    [70, 235, 221, 255],
    [189, 116, 174, 255],
    [153, 196, 109, 255],
    [101, 123, 204, 255],
    [211, 104, 94, 255],
    [87, 218, 136, 255],
    [177, 80, 225, 255],
    [232, 225, 73, 255],
    [119, 169, 186, 255],
    [193, 112, 149, 255],
    [121, 200, 105, 255],
    [111, 97, 208, 255],
    [215, 142, 90, 255],
    [83, 222, 181, 255],
    [229, 76, 229, 255],
    [165, 183, 122, 255],
    [115, 146, 190, 255],
    [197, 108, 119, 255],
    [100, 205, 118, 255],
    [148, 93, 212, 255],
    [219, 186, 86, 255],
    [79, 220, 226, 255],
    [233, 72, 179, 255],
    [144, 187, 118, 255],
    [111, 118, 194, 255],
    [201, 124, 104, 255],
    [96, 209, 153, 255],
    [189, 89, 216, 255],
    [211, 223, 82, 255],
    [75, 172, 230, 255],
    [184, 121, 142, 255],
    [117, 191, 114, 255],
    [130, 107, 198, 255],
    [206, 157, 99, 255],
    [92, 213, 193, 255],
    [220, 85, 203, 255],
    [165, 227, 78, 255],
    [71, 118, 234, 255],
    [188, 117, 117, 255],
    [110, 195, 135, 255],
    [161, 103, 202, 255],
    [210, 195, 95, 255],
    [88, 195, 217, 255],
    [224, 81, 158, 255],
    [113, 231, 74, 255],
    [123, 120, 185, 255],
    [192, 139, 113, 255],
    [106, 199, 164, 255],
    [198, 98, 207, 255],
    [188, 214, 91, 255],
    [84, 153, 221, 255],
    [228, 77, 108, 255],
    [70, 235, 84, 255],
    [143, 116, 189, 255],
    [196, 167, 109, 255],
    [101, 204, 199, 255],
    [211, 94, 182, 255],
    [147, 218, 87, 255],
    [80, 104, 225, 255],
    [232, 93, 73, 255],
    [119, 186, 147, 255],
    [170, 112, 193, 255],
    [200, 200, 105, 255],
    [97, 175, 208, 255],
    [215, 90, 142, 255],
    [100, 222, 83, 255],
    [101, 76, 229, 255],
    [183, 150, 122, 255],
    [115, 190, 171, 255],
    [197, 108, 194, 255],
    [170, 205, 100, 255],
    [93, 138, 212, 255],
    [219, 86, 97, 255],
    [79, 226, 110, 255],
    [153, 72, 233, 255],
    [187, 173, 118, 255],
    [111, 187, 194, 255],
    [201, 104, 165, 255],
    [134, 209, 96, 255],
    [89, 95, 216, 255],
    [223, 117, 82, 255],
    [75, 230, 159, 255],
    [174, 121, 184, 255],
    [182, 191, 114, 255],
    [107, 160, 198, 255],
    [206, 99, 130, 255],
    [92, 213, 92, 255],
    [124, 85, 220, 255],
    [227, 165, 78, 255],
    [71, 234, 214, 255],
    [188, 117, 176, 255],
    [156, 195, 110, 255],
    [103, 128, 202, 255],
    [210, 100, 95, 255],
    [88, 217, 131, 255],
    [170, 81, 224, 255],
    [231, 218, 74, 255],
    [120, 172, 185, 255],
    [192, 113, 153, 255],
    [125, 199, 106, 255],
    [107, 98, 207, 255],
    [214, 137, 91, 255],
    [84, 221, 175, 255],
    [222, 77, 228, 255],
    [194, 235, 70, 255],
    [116, 149, 189, 255],
    [196, 109, 123, 255],
    [101, 204, 114, 255],
    [143, 94, 211, 255],
    [218, 180, 87, 255],
    [80, 225, 225, 255],
    [232, 73, 186, 255],
    [147, 186, 119, 255],
    [112, 122, 193, 255],
    [200, 121, 105, 255],
    [97, 208, 148, 255],
    [184, 90, 215, 255],
    [216, 222, 83, 255],
    [76, 178, 229, 255],
    [183, 122, 145, 255],
    [121, 190, 115, 255],
    [126, 108, 197, 255],
    [205, 153, 100, 255],
    [93, 212, 187, 255],
    [219, 86, 208, 255],
    [171, 226, 79, 255],
    [72, 126, 233, 255],
    [187, 118, 121, 255],
    [111, 194, 132, 255],
    [157, 104, 201, 255],
    [209, 190, 96, 255],
    [89, 200, 216, 255],
    [223, 82, 164, 255],
    [120, 230, 75, 255],
    [121, 121, 184, 255],
    [191, 136, 114, 255],
    [107, 198, 160, 255],
    [192, 99, 206, 255],
    [193, 213, 92, 255],
    [85, 158, 220, 255],
    [227, 78, 115, 255],
    [71, 234, 78, 255],
    [141, 117, 188, 255],
    [195, 163, 110, 255],
    [103, 202, 194, 255],
    [210, 95, 186, 255],
    [153, 217, 88, 255],
    [81, 111, 224, 255],
];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CORNERSTONE_COLOR_LUT);


/***/ }),

/***/ 18262:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ drawingSvg_draw)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js


const VIEWPORT_ELEMENT = 'viewport-element';
function getSvgDrawingHelper(element) {
    const enabledElement = (0,esm.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement;
    const canvasHash = `${viewportId}:${renderingEngineId}`;
    const svgLayerElement = _getSvgLayer(element);
    Object.keys(state/* state */.wk.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        state/* state */.wk.svgNodeCache[canvasHash][cacheKey].touched = false;
    });
    return {
        svgLayerElement: svgLayerElement,
        svgNodeCacheForCanvas: state/* state */.wk.svgNodeCache,
        getSvgNode: getSvgNode.bind(this, canvasHash),
        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),
        setNodeTouched: setNodeTouched.bind(this, canvasHash),
        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),
    };
}
function _getSvgLayer(element) {
    const viewportElement = `.${VIEWPORT_ELEMENT}`;
    const internalDivElement = element.querySelector(viewportElement);
    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');
    return svgLayer;
}
function getSvgNode(canvasHash, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    if (state/* state */.wk.svgNodeCache[canvasHash][cacheKey]) {
        return state/* state */.wk.svgNodeCache[canvasHash][cacheKey].domRef;
    }
}
function appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return null;
    }
    state/* state */.wk.svgNodeCache[canvasHash][cacheKey] = {
        touched: true,
        domRef: svgNode,
    };
    svgLayerElement.appendChild(svgNode);
}
function setNodeTouched(canvasHash, cacheKey) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    if (state/* state */.wk.svgNodeCache[canvasHash][cacheKey]) {
        state/* state */.wk.svgNodeCache[canvasHash][cacheKey].touched = true;
    }
}
function clearUntouched(svgLayerElement, canvasHash) {
    if (!state/* state */.wk.svgNodeCache[canvasHash]) {
        return;
    }
    Object.keys(state/* state */.wk.svgNodeCache[canvasHash]).forEach((cacheKey) => {
        const cacheEntry = state/* state */.wk.svgNodeCache[canvasHash][cacheKey];
        if (!cacheEntry.touched && cacheEntry.domRef) {
            svgLayerElement.removeChild(cacheEntry.domRef);
            delete state/* state */.wk.svgNodeCache[canvasHash][cacheKey];
        }
    });
}
/* harmony default export */ const drawingSvg_getSvgDrawingHelper = (getSvgDrawingHelper);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js

function draw(element, fn) {
    const svgDrawingHelper = drawingSvg_getSvgDrawingHelper(element);
    fn(svgDrawingHelper);
    svgDrawingHelper.clearUntouched();
}
/* harmony default export */ const drawingSvg_draw = (draw);


/***/ }),

/***/ 12004:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56442);



function drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {
    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        fill: 'transparent',
        width: '2',
        lineDash: undefined,
        lineWidth: undefined,
        strokeOpacity: 1,
        fillOpacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'circle', circleUID);
    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        r: `${radius}`,
        stroke: color,
        fill,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'fill-opacity': fillOpacity,
        'stroke-opacity': strokeOpacity,
    };
    if (existingCircleElement) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, existingCircleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newCircleElement = document.createElementNS(svgns, 'circle');
        if (dataId !== '') {
            newCircleElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, newCircleElement);
        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawCircle);


/***/ }),

/***/ 95074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56442);



function drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'ellipse', ellipseUID);
    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [bottom, top, left, right] = canvasCoordinates;
    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);
    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);
    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;
    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];
    const radiusX = w / 2;
    const radiusY = h / 2;
    const attributes = {
        cx: `${center[0]}`,
        cy: `${center[1]}`,
        rx: `${radiusX}`,
        ry: `${radiusY}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingEllipse) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, existingEllipse);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');
        if (dataId !== '') {
            svgEllipseElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, svgEllipseElement);
        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawEllipseByCoordinates);


/***/ }),

/***/ 56745:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _drawHandle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94042);

function drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {
    handlePoints.forEach((handle, i) => {
        (0,_drawHandle__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawHandles);


/***/ }),

/***/ 1595:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ drawingSvg_drawLinkedTextBox)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js
var drawTextBox = __webpack_require__(26290);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js
var drawLine = __webpack_require__(92118);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js
var findClosestPoint = __webpack_require__(90554);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js


function drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {
    const start = annotationAnchorPoints.length > 0
        ? (0,findClosestPoint/* default */.A)(annotationAnchorPoints, refPoint)
        : refPoint;
    const boundingBoxPoints = _boundingBoxPoints(boundingBox);
    const end = (0,findClosestPoint/* default */.A)(boundingBoxPoints, start);
    const mergedOptions = Object.assign({
        color: 'rgb(255, 255, 0)',
        lineWidth: '1',
        lineDash: '2,3',
    }, options);
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);
}
function _boundingBoxPoints(boundingBox) {
    const { x: left, y: top, height, width } = boundingBox;
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const topMiddle = [left + halfWidth, top];
    const leftMiddle = [left, top + halfHeight];
    const bottomMiddle = [left + halfWidth, top + height];
    const rightMiddle = [left + width, top + halfHeight];
    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];
}
/* harmony default export */ const drawingSvg_drawLink = (drawLink);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js


function drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {
    const mergedOptions = Object.assign({
        handleRadius: '6',
        centering: {
            x: false,
            y: true,
        },
    }, options);
    const canvasBoundingBox = (0,drawTextBox/* default */.A)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);
    drawingSvg_drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);
    return canvasBoundingBox;
}
/* harmony default export */ const drawingSvg_drawLinkedTextBox = (drawLinkedTextBox);


/***/ }),

/***/ 97530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawRect)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75076);


function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {
    const topLeft = [start[0], start[1]];
    const topRight = [end[0], start[1]];
    const bottomLeft = [start[0], end[1]];
    const bottomRight = [end[0], end[1]];
    (0,_drawRectByCoordinates__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);
}


/***/ }),

/***/ 74347:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  draw: () => (/* reexport */ draw/* default */.A),
  drawArrow: () => (/* reexport */ drawArrow),
  drawCircle: () => (/* reexport */ drawCircle/* default */.A),
  drawEllipseByCoordinates: () => (/* reexport */ drawEllipseByCoordinates/* default */.A),
  drawFan: () => (/* reexport */ drawingSvg_drawFan),
  drawHandle: () => (/* reexport */ drawHandle/* default */.A),
  drawHandles: () => (/* reexport */ drawHandles/* default */.A),
  drawHeight: () => (/* reexport */ drawHeight),
  drawLine: () => (/* reexport */ drawLine/* default */.A),
  drawLinkedTextBox: () => (/* reexport */ drawLinkedTextBox/* default */.A),
  drawPath: () => (/* reexport */ drawPath/* default */.A),
  drawPolyline: () => (/* reexport */ drawPolyline/* default */.A),
  drawRect: () => (/* reexport */ drawRect/* default */.A),
  drawRectByCoordinates: () => (/* reexport */ drawRectByCoordinates/* default */.A),
  drawRedactionRect: () => (/* reexport */ drawRedactionRect),
  drawTextBox: () => (/* reexport */ drawTextBox/* default */.A)
});

// UNUSED EXPORTS: drawEllipse, setAttributesIfNecessary, setNewAttributesIfValid

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js + 1 modules
var draw = __webpack_require__(18262);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js
var drawCircle = __webpack_require__(12004);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js
var drawEllipse = __webpack_require__(85856);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js
var drawEllipseByCoordinates = __webpack_require__(95074);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js
var drawHandles = __webpack_require__(56745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js
var drawHandle = __webpack_require__(94042);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js
var drawLine = __webpack_require__(92118);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js

function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color, width, lineWidth, lineDash } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const midX = end[0] + (start[0] - end[0]) / 2;
    const endfirstLine = [midX, start[1]];
    const endsecondLine = [midX, end[1]];
    const firstLine = {
        start: start,
        end: endfirstLine,
    };
    const secondLine = {
        start: endfirstLine,
        end: endsecondLine,
    };
    const threeLine = {
        start: endsecondLine,
        end: end,
    };
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js
var drawPolyline = __webpack_require__(98812);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js
var drawPath = __webpack_require__(17311);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js
var _getHash = __webpack_require__(97181);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js
var setAttributesIfNecessary = __webpack_require__(85899);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js
var setNewAttributesIfValid = __webpack_require__(56442);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawFan.js



function drawFan(svgDrawingHelper, annotationUID, fanUID, center, innerRadius, outerRadius, startAngle, endAngle, options = {}, dataId = '', zIndex) {
    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        fill: 'transparent',
        width: '2',
        lineDash: undefined,
        lineWidth: undefined,
        strokeOpacity: 1,
        fillOpacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'fan', fanUID);
    const existingFanElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    const startRad = (startAngle * Math.PI) / 180;
    const endRad = (endAngle * Math.PI) / 180;
    const centerX = center[0];
    const centerY = center[1];
    const outerStartX = centerX + outerRadius * Math.cos(startRad);
    const outerStartY = centerY + outerRadius * Math.sin(startRad);
    const outerEndX = centerX + outerRadius * Math.cos(endRad);
    const outerEndY = centerY + outerRadius * Math.sin(endRad);
    const innerStartX = centerX + innerRadius * Math.cos(startRad);
    const innerStartY = centerY + innerRadius * Math.sin(startRad);
    const innerEndX = centerX + innerRadius * Math.cos(endRad);
    const innerEndY = centerY + innerRadius * Math.sin(endRad);
    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;
    let pathData = `M ${outerStartX} ${outerStartY}`;
    pathData += ` A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}`;
    pathData += ` L ${innerEndX} ${innerEndY}`;
    pathData += ` A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}`;
    pathData += ` Z`;
    const attributes = {
        d: pathData,
        stroke: color,
        fill,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'fill-opacity': fillOpacity,
        'stroke-opacity': strokeOpacity,
        'mix-blend-mode': 'normal',
    };
    if (existingFanElement) {
        (0,setAttributesIfNecessary/* default */.A)(attributes, existingFanElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newFanElement = document.createElementNS(svgns, 'path');
        if (dataId !== '') {
            newFanElement.setAttribute('data-id', dataId);
        }
        if (zIndex !== undefined) {
            newFanElement.style.zIndex = zIndex.toString();
        }
        (0,setNewAttributesIfValid/* default */.A)(attributes, newFanElement);
        svgDrawingHelper.appendNode(newFanElement, svgNodeHash);
    }
}
/* harmony default export */ const drawingSvg_drawFan = (drawFan);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js + 1 modules
var drawLinkedTextBox = __webpack_require__(1595);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js
var drawRect = __webpack_require__(97530);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js
var drawRectByCoordinates = __webpack_require__(75076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js
var drawTextBox = __webpack_require__(26290);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js

const svgns = 'http://www.w3.org/2000/svg';
function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;
    if (!viaMarker) {
        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
        return;
    }
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const markerBaseId = `arrow-${annotationUID}`;
    const markerFullId = `${markerBaseId}-${layerId}`;
    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');
    let arrowMarker = defs.querySelector(`#${markerFullId}`);
    if (!arrowMarker) {
        arrowMarker = document.createElementNS(svgns, 'marker');
        arrowMarker.setAttribute('id', markerFullId);
        arrowMarker.setAttribute('viewBox', '0 0 10 10');
        arrowMarker.setAttribute('refX', '8');
        arrowMarker.setAttribute('refY', '5');
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        arrowMarker.setAttribute('orient', 'auto');
        const arrowPath = document.createElementNS(svgns, 'path');
        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
        arrowPath.setAttribute('fill', color);
        arrowMarker.appendChild(arrowPath);
        defs.appendChild(arrowMarker);
    }
    else {
        arrowMarker.setAttribute('markerWidth', `${markerSize}`);
        arrowMarker.setAttribute('markerHeight', `${markerSize}`);
        const arrowPath = arrowMarker.querySelector('path');
        if (arrowPath) {
            arrowPath.setAttribute('fill', color);
        }
    }
    options.markerEndId = markerFullId;
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, arrowUID, start, end, options);
}
function legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {
    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;
    const headLength = 10;
    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);
    const firstLine = {
        start: [
            end[0] - headLength * Math.cos(angle - Math.PI / 7),
            end[1] - headLength * Math.sin(angle - Math.PI / 7),
        ],
        end: end,
    };
    const secondLine = {
        start: [
            end[0] - headLength * Math.cos(angle + Math.PI / 7),
            end[1] - headLength * Math.sin(angle + Math.PI / 7),
        ],
        end: end,
    };
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, arrowUID, start, end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
    (0,drawLine/* default */.A)(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {
        color,
        width,
        lineWidth,
        lineDash,
    });
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js



function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash/* default */.A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    const attributes = {
        x: `${tlhc[0]}`,
        y: `${tlhc[1]}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'black',
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,setAttributesIfNecessary/* default */.A)(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        (0,setNewAttributesIfValid/* default */.A)(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js






















/***/ }),

/***/ 75183:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["Interaction"] = "Interaction";
    ChangeTypes["HandlesUpdated"] = "HandlesUpdated";
    ChangeTypes["StatsUpdated"] = "StatsUpdated";
    ChangeTypes["InitialSetup"] = "InitialSetup";
    ChangeTypes["Completed"] = "Completed";
    ChangeTypes["InterpolationUpdated"] = "InterpolationUpdated";
    ChangeTypes["History"] = "History";
    ChangeTypes["MetadataReferenceModified"] = "MetadataReferenceModified";
    ChangeTypes["LabelChange"] = "LabelChange";
})(ChangeTypes || (ChangeTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChangeTypes);


/***/ }),

/***/ 10401:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ Swipe)
/* harmony export */ });
var Swipe;
(function (Swipe) {
    Swipe["UP"] = "UP";
    Swipe["DOWN"] = "DOWN";
    Swipe["LEFT"] = "LEFT";
    Swipe["RIGHT"] = "RIGHT";
})(Swipe || (Swipe = {}));



/***/ }),

/***/ 21418:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  kt: () => (/* reexport */ keyboard/* default */.A)
});

// UNUSED EXPORTS: annotationCompletedListener, annotationModifiedListener, annotationRemovedListener, annotationSelectionListener, imageChangeEventListener, mouseEventListeners, segmentationDataModifiedEventListener, segmentationModifiedListener, touchEventListeners, wheelEventListener

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js
var mouseDoubleClickListener = __webpack_require__(91099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js
var mouseDownListener = __webpack_require__(68014);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js
var mouseMoveListener = __webpack_require__(41343);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js



function disable(element) {
    element.removeEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.removeEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.removeEventListener('mousemove', mouseMoveListener/* default */.A);
    element.removeEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
function enable(element) {
    disable(element);
    element.addEventListener('dblclick', mouseDoubleClickListener/* default */.A);
    element.addEventListener('mousedown', mouseDownListener/* default */.Ay);
    element.addEventListener('mousemove', mouseMoveListener/* default */.A);
    element.addEventListener('dblclick', mouseDownListener/* mouseDoubleClickIgnoreListener */.DF, {
        capture: true,
    });
}
/* harmony default export */ const mouse = ({
    enable,
    disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js
var preventGhostClick = __webpack_require__(41666);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js + 1 modules
var touchStartListener = __webpack_require__(82603);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js


function touch_disable(element) {
    preventGhostClick/* default */.A.disable(element);
    element.removeEventListener('touchstart', touchStartListener/* default */.A);
}
function touch_enable(element) {
    touch_disable(element);
    preventGhostClick/* default */.A.enable(element);
    element.addEventListener('touchstart', touchStartListener/* default */.A, {
        passive: false,
    });
}
/* harmony default export */ const touch = ({
    enable: touch_enable,
    disable: touch_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js + 1 modules
var wheelListener = __webpack_require__(17806);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js

function wheel_enable(element) {
    wheel_disable(element);
    element.addEventListener('wheel', wheelListener/* default */.A, { passive: false });
}
function wheel_disable(element) {
    element.removeEventListener('wheel', wheelListener/* default */.A);
}
/* harmony default export */ const wheel = ({
    enable: wheel_enable,
    disable: wheel_disable,
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js
var keyboard = __webpack_require__(39595);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js

function performVolumeLabelmapUpdate_performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {
    const segmentationVolume = cache.getVolume(representationData[type].volumeId);
    if (!segmentationVolume) {
        console.warn('segmentation not found in cache');
        return;
    }
    const { imageData, vtkOpenGLTexture } = segmentationVolume;
    let slicesToUpdate;
    if (modifiedSlicesToUse?.length > 0) {
        slicesToUpdate = modifiedSlicesToUse;
    }
    else {
        const numSlices = imageData.getDimensions()[2];
        slicesToUpdate = [...Array(numSlices).keys()];
    }
    slicesToUpdate.forEach((i) => {
        vtkOpenGLTexture.setUpdatedFrame(i);
    });
    imageData.modified();
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js
var getSegmentationActor = __webpack_require__(59452);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js





function performStackLabelmapUpdate_performStackLabelmapUpdate({ viewportIds, segmentationId, }) {
    viewportIds.forEach((viewportId) => {
        let representations = getSegmentationRepresentations(viewportId, {
            segmentationId,
        });
        representations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);
        representations.forEach((representation) => {
            if (representation.segmentationId !== segmentationId) {
                return;
            }
            const enabledElement = getEnabledElementByViewportId(viewportId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            if (viewport instanceof VolumeViewport) {
                return;
            }
            const actorEntries = getLabelmapActorEntries(viewportId, segmentationId);
            if (!actorEntries?.length) {
                return;
            }
            actorEntries.forEach((actorEntry, i) => {
                const segImageData = actorEntry.actor.getMapper().getInputData();
                const currentSegmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
                const segmentationImage = cache.getImage(currentSegmentationImageIds[i]);
                segImageData.modified();
                csUtils.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);
            });
        });
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var segmentation_getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var segmentation_getViewportIdsWithSegmentation = __webpack_require__(58859);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js






const onLabelmapSegmentationDataModified_onLabelmapSegmentationDataModified = function (evt) {
    const { segmentationId, modifiedSlicesToUse } = evt.detail;
    const { representationData } = getSegmentation(segmentationId);
    const viewportIds = getViewportIdsWithSegmentation(segmentationId);
    const hasVolumeViewport = viewportIds.some((viewportId) => {
        const { viewport } = getEnabledElementByViewportId(viewportId);
        return viewport instanceof VolumeViewport;
    });
    const hasStackViewport = viewportIds.some((viewportId) => {
        const { viewport } = getEnabledElementByViewportId(viewportId);
        return viewport instanceof StackViewport;
    });
    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;
    viewportIds.forEach((viewportId) => {
        const { viewport } = getEnabledElementByViewportId(viewportId);
        if (viewport instanceof VolumeViewport) {
            performVolumeLabelmapUpdate({
                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,
                representationData,
                type: SegmentationRepresentations.Labelmap,
            });
        }
        if (viewport instanceof StackViewport) {
            performStackLabelmapUpdate({
                viewportIds,
                segmentationId,
            });
        }
    });
};
/* harmony default export */ const labelmap_onLabelmapSegmentationDataModified = ((/* unused pure expression or super */ null && (onLabelmapSegmentationDataModified_onLabelmapSegmentationDataModified)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js



const onSegmentationDataModified = function (evt) {
    const { segmentationId } = evt.detail;
    const { representationData } = getSegmentation(segmentationId);
    if (representationData.Labelmap) {
        onLabelmapSegmentationDataModified(evt);
    }
    triggerSegmentationRenderBySegmentationId(segmentationId);
};
/* harmony default export */ const segmentationDataModifiedEventListener = ((/* unused pure expression or super */ null && (onSegmentationDataModified)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js

const segmentationModifiedListener = function (evt) {
    const { segmentationId } = evt.detail;
    triggerSegmentationRenderBySegmentationId(segmentationId);
};
/* harmony default export */ const segmentationModifiedEventListener = ((/* unused pure expression or super */ null && (segmentationModifiedListener)));

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js









const imageChangeEventListener_enable = function (element) {
    if (!element) {
        return;
    }
    const enabledElement = (0,esm.getEnabledElement)(element);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    if (viewport instanceof esm.BaseVolumeViewport) {
        return;
    }
    element.addEventListener(esm.Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);
    element.addEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const imageChangeEventListener_disable = function (element) {
    element.removeEventListener(esm.Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);
    element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
};
const perViewportManualTriggers = new Map();
function _imageChangeEventListener(evt) {
    const eventData = evt.detail;
    const { viewportId, renderingEngineId } = eventData;
    const { viewport } = (0,esm.getEnabledElementByIds)(viewportId, renderingEngineId);
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId);
    if (!representations?.length) {
        return;
    }
    const labelmapRepresentations = representations.filter((representation) => representation.type === enums.SegmentationRepresentations.Labelmap);
    const actors = viewport.getActors();
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        (0,updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)(viewportId, segmentationId);
    });
    const labelmapActors = labelmapRepresentations
        .flatMap((representation) => {
        return (0,getSegmentationActor/* getLabelmapActorEntries */.ED)(viewportId, representation.segmentationId);
    })
        .filter((actor) => actor !== undefined);
    if (!labelmapActors.length) {
        return;
    }
    labelmapActors.forEach((actor) => {
        const validActor = labelmapRepresentations.find((representation) => {
            const derivedImageIds = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF)(viewportId, representation.segmentationId);
            return derivedImageIds?.includes(actor.referencedId);
        });
        if (!validActor) {
            viewport.removeActors([actor.uid]);
        }
    });
    labelmapRepresentations.forEach((representation) => {
        const { segmentationId } = representation;
        const currentImageId = viewport.getCurrentImageId();
        const derivedImageIds = (0,getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF)(viewportId, segmentationId);
        if (!derivedImageIds) {
            return;
        }
        let shouldTriggerSegmentationRender = false;
        const updateSegmentationActor = (derivedImageId) => {
            const derivedImage = esm.cache.getImage(derivedImageId);
            if (!derivedImage) {
                console.warn('No derived image found in the cache for segmentation representation', representation);
                return;
            }
            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);
            if (!segmentationActorInput) {
                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);
                const currentImage = esm.cache.getImage(currentImageId) ||
                    {
                        imageId: currentImageId,
                    };
                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);
                const originToUse = currentOrigin;
                const constructor = derivedImage.voxelManager.getConstructor();
                const newPixelData = derivedImage.voxelManager.getScalarData();
                const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: new constructor(newPixelData),
                });
                const imageData = ImageData/* default.newInstance */.Ay.newInstance();
                imageData.setDimensions(dimensions[0], dimensions[1], 1);
                imageData.setSpacing(spacing);
                imageData.setDirection(direction);
                imageData.setOrigin(originToUse);
                imageData.getPointData().setScalars(scalarArray);
                imageData.modified();
                viewport.addImages([
                    {
                        imageId: derivedImageId,
                        representationUID: `${segmentationId}-${enums.SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,
                        callback: ({ imageActor }) => {
                            imageActor.getMapper().setInputData(imageData);
                        },
                    },
                ]);
                shouldTriggerSegmentationRender = true;
                return;
            }
            else {
                const segmentationImageData = segmentationActorInput.actor
                    .getMapper()
                    .getInputData();
                if (segmentationImageData.setDerivedImage) {
                    segmentationImageData.setDerivedImage(derivedImage);
                }
                else {
                    esm.utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);
                }
            }
        };
        derivedImageIds.forEach(updateSegmentationActor);
        if (shouldTriggerSegmentationRender) {
            (0,SegmentationRenderingEngine/* triggerSegmentationRender */.h6)(viewportId);
        }
        viewport.render();
        if (evt.type === esm.Enums.Events.IMAGE_RENDERED) {
            viewport.element.removeEventListener(esm.Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);
        }
    });
}
/* harmony default export */ const imageChangeEventListener = ({
    enable: imageChangeEventListener_enable,
    disable: imageChangeEventListener_disable,
});

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js + 1 modules
var contourSegmentation = __webpack_require__(56534);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js
var utilities_getViewportsForAnnotation = __webpack_require__(15295);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js + 6 modules
var ToolGroupManager = __webpack_require__(77609);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getIntersectingAnnotations.js
var getIntersectingAnnotations = __webpack_require__(3444);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/mergeMultipleAnnotations.js
var mergeMultipleAnnotations = __webpack_require__(49941);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/sharedOperations.js
var sharedOperations = __webpack_require__(65172);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js









const DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';
async function contourSegmentationCompletedListener(evt) {
    const sourceAnnotation = evt.detail
        .annotation;
    if (!isContourSegmentationAnnotation(sourceAnnotation)) {
        return;
    }
    const viewport = getViewport(sourceAnnotation);
    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
    if (!contourSegmentationAnnotations.length) {
        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {
            element: viewport.element,
            sourceAnnotation,
        });
        return;
    }
    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
    const intersectingContours = findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations);
    if (!intersectingContours.length) {
        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {
            element: viewport.element,
            sourceAnnotation,
        });
        return;
    }
    if (intersectingContours.length > 1) {
        processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours);
        return;
    }
    const { targetAnnotation, targetPolyline, isContourHole } = intersectingContours[0];
    if (isContourHole) {
        const { contourHoleProcessingEnabled = false } = evt.detail;
        if (!contourHoleProcessingEnabled) {
            return;
        }
        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
    }
    else {
        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
    }
}
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
    const toolName = 'PlanarFreehandContourSegmentationTool';
    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);
    let errorMessage;
    if (!toolGroup) {
        errorMessage = `ToolGroup not found for viewport ${viewport.id}`;
    }
    else if (!toolGroup.hasTool(toolName)) {
        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
    }
    else if (!toolGroup.getToolOptions(toolName)) {
        errorMessage = `Tool ${toolName} must be in active/passive state in ${toolGroup.id} toolGroup`;
    }
    if (errorMessage && !silent) {
        console.warn(errorMessage);
    }
    return !errorMessage;
}
function getViewport(annotation) {
    const viewports = getViewportsForAnnotation(annotation);
    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
    return viewportWithToolRegistered ?? viewports[0];
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
    const allAnnotations = getAllAnnotations();
    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&
        targetAnnotation.annotationUID !== sourceAnnotationUID &&
        isContourSegmentationAnnotation(targetAnnotation) &&
        areSameSegment(targetAnnotation, sourceAnnotation) &&
        viewport.isReferenceViewable(targetAnnotation.metadata));
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js

function contourSegmentationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    removeContourSegmentationAnnotation(annotation);
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/index.js



;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js


function annotationCompletedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {
        contourSegmentationCompleted(evt);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js
var utilities_triggerAnnotationRenderForViewportIds = __webpack_require__(58640);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js


function annotationSelectionListener(evt) {
    const deselectedAnnotation = evt.detail.removed;
    if (!deselectedAnnotation.length) {
        return;
    }
    const renderingEngines = getRenderingEngines();
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        triggerAnnotationRenderForViewportIds(viewportIds);
    });
}
/* harmony default export */ const annotations_annotationSelectionListener = ((/* unused pure expression or super */ null && (annotationSelectionListener)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js

function annotationModifiedListener(evt) {
    const { viewportId } = evt.detail;
    triggerAnnotationRenderForViewportIds([viewportId]);
}
/* harmony default export */ const annotations_annotationModifiedListener = ((/* unused pure expression or super */ null && (annotationModifiedListener)));

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js


function annotationRemovedListener(evt) {
    const annotation = evt.detail.annotation;
    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {
        contourSegmentationRemoved(evt);
    }
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js






;// ../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js









/***/ }),

/***/ 24917:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h6: () => (/* binding */ triggerSegmentationRender)
/* harmony export */ });
/* unused harmony exports triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18682);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93210);
/* harmony import */ var _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67014);
/* harmony import */ var _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25894);
/* harmony import */ var _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(684);
/* harmony import */ var _store_addTool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(68040);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85204);
/* harmony import */ var _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(37590);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77609);











const renderers = {
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Labelmap]: _tools_displayTools_Labelmap_labelmapDisplay__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Contour]: _tools_displayTools_Contour_contourDisplay__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A,
    [_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Surface]: _tools_displayTools_Surface_surfaceDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay,
};
const planarContourToolName = _tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.toolName;
class SegmentationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._pendingRenderQueue = [];
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._getAllViewports = () => {
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)();
            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());
        };
        this._renderFlaggedSegmentations = () => {
            this._throwIfDestroyed();
            const viewportIds = Array.from(this._needsRender);
            viewportIds.forEach((viewportId) => {
                this._triggerRender(viewportId);
            });
            this._needsRender.clear();
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            if (this._pendingRenderQueue.length > 0) {
                const nextViewportIds = this._pendingRenderQueue.shift();
                if (nextViewportIds && nextViewportIds.length > 0) {
                    this._setViewportsToBeRenderedNextFrame(nextViewportIds);
                }
            }
        };
    }
    renderSegmentationsForViewport(viewportId) {
        const viewportIds = viewportId
            ? [viewportId]
            : this._getViewportIdsForSegmentation();
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderSegmentation(segmentationId) {
        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    _getViewportIdsForSegmentation(segmentationId) {
        const viewports = this._getAllViewports();
        const viewportIds = [];
        for (const viewport of viewports) {
            const viewportId = viewport.id;
            if (segmentationId) {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
            else {
                const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
                if (segmentationRepresentations?.length > 0) {
                    viewportIds.push(viewportId);
                }
            }
        }
        return viewportIds;
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        if (this._animationFrameSet) {
            this._pendingRenderQueue.push(viewportIds);
            return;
        }
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(viewportId) {
        const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentationRepresentations */ .r$)(viewportId);
        if (!segmentationRepresentations?.length) {
            return;
        }
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId) || {};
        if (!viewport) {
            return;
        }
        const viewportRenderList = [];
        const segmentationRenderList = segmentationRepresentations.map((representation) => {
            if (representation.type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour) {
                this._addPlanarFreeHandToolIfAbsent(viewport);
            }
            const display = renderers[representation.type];
            try {
                const viewportId = display.render(viewport, representation);
                viewportRenderList.push(viewportId);
            }
            catch (error) {
                console.error(error);
            }
            return Promise.resolve({
                segmentationId: representation.segmentationId,
                type: representation.type,
            });
        });
        Promise.allSettled(segmentationRenderList).then((results) => {
            const segmentationDetails = results
                .filter((r) => r.status === 'fulfilled')
                .map((r) => r.value);
            function onSegmentationRender(evt) {
                const { element, viewportId } = evt.detail;
                element.removeEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
                segmentationDetails.forEach((detail) => {
                    const eventDetail = {
                        viewportId,
                        segmentationId: detail.segmentationId,
                        type: detail.type,
                    };
                    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_RENDERED, {
                        ...eventDetail,
                    });
                });
            }
            const element = viewport.element;
            element.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_RENDERED, onSegmentationRender);
            viewport.render();
        });
    }
    _addPlanarFreeHandToolIfAbsent(viewport) {
        if (!(planarContourToolName in _store_state__WEBPACK_IMPORTED_MODULE_8__/* .state */ .wk.tools)) {
            (0,_store_addTool__WEBPACK_IMPORTED_MODULE_7__/* .addTool */ .Gx)(_tools_annotation_PlanarFreehandContourSegmentationTool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A);
        }
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_10__.getToolGroupForViewport)(viewport.id);
        if (!toolGroup.hasTool(planarContourToolName)) {
            toolGroup.addTool(planarContourToolName);
            toolGroup.setToolPassive(planarContourToolName);
        }
    }
}
function triggerSegmentationRender(viewportId) {
    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);
}
function triggerSegmentationRenderBySegmentationId(segmentationId) {
    segmentationRenderingEngine.renderSegmentation(segmentationId);
}
const segmentationRenderingEngine = new SegmentationRenderingEngine();



/***/ }),

/***/ 59475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zm: () => (/* binding */ internalComputeVolumeLabelmapFromStack),
/* harmony export */   _6: () => (/* binding */ defaultSegmentationStateManager),
/* harmony export */   cC: () => (/* binding */ internalConvertStackToVolumeLabelmap)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99341);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92686);
/* harmony import */ var _events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(75419);







const initialDefaultState = {
    colorLUT: [],
    segmentations: [],
    viewportSegRepresentations: {},
};
class SegmentationStateManager {
    constructor(uid) {
        this._stackLabelmapImageIdReferenceMap = new Map();
        this._labelmapImageIdReferenceMap = new Map();
        uid ||= _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
        this.uid = uid;
    }
    getState() {
        return this.state;
    }
    updateState(updater) {
        const newState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(this.state);
        updater(newState);
        this.state = Object.freeze(newState);
    }
    getColorLUT(lutIndex) {
        return this.state.colorLUT[lutIndex];
    }
    getNextColorLUTIndex() {
        return this.state.colorLUT.length;
    }
    resetState() {
        this._stackLabelmapImageIdReferenceMap.clear();
        this._labelmapImageIdReferenceMap.clear();
        this.state = Object.freeze(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(initialDefaultState));
    }
    getSegmentation(segmentationId) {
        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
    }
    updateSegmentation(segmentationId, payload) {
        this.updateState((draftState) => {
            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
            if (!segmentation) {
                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);
                return;
            }
            Object.assign(segmentation, payload);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    addSegmentation(segmentation) {
        if (this.getSegmentation(segmentation.segmentationId)) {
            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);
        }
        this.updateState((state) => {
            const newSegmentation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(segmentation);
            if (newSegmentation.representationData.Labelmap &&
                'volumeId' in newSegmentation.representationData.Labelmap &&
                !('imageIds' in newSegmentation.representationData.Labelmap)) {
                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);
                newSegmentation.representationData
                    .Labelmap.imageIds = imageIds;
            }
            state.segmentations.push(newSegmentation);
        });
        (0,_events_triggerSegmentationAdded__WEBPACK_IMPORTED_MODULE_6__/* .triggerSegmentationAdded */ .R)(segmentation.segmentationId);
    }
    removeSegmentation(segmentationId) {
        this.updateState((state) => {
            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);
            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRemoved)(segmentationId);
    }
    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {
            type: type,
            segmentationId,
        });
        if (existingRepresentations.length > 0) {
            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);
            return;
        }
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                state.viewportSegRepresentations[viewportId] = [];
                _SegmentationStyle__WEBPACK_IMPORTED_MODULE_5__/* .segmentationStyle */ .Y.setRenderInactiveSegmentations(viewportId, true);
            }
            if (type !== _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);
            }
            else {
                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);
            }
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId, type);
    }
    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {
        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);
        if (!segmentation) {
            return;
        }
        const segmentReps = {};
        Object.keys(segmentation.segments).forEach((segmentIndex) => {
            segmentReps[Number(segmentIndex)] = {
                visible: true,
            };
        });
        state.viewportSegRepresentations[viewportId].push({
            segmentationId,
            type,
            active: true,
            visible: true,
            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,
            segments: segmentReps,
            config: {
                ...getDefaultRenderingConfig(type),
                ...renderingConfig,
            },
        });
        this._setActiveSegmentation(state, viewportId, segmentationId);
    }
    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap)) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
        }
        this.processLabelmapRepresentationAddition(viewportId, segmentationId);
        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap, renderingConfig);
    }
    async processLabelmapRepresentationAddition(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        const volumeViewport = enabledElement.viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport;
        const { representationData } = segmentation;
        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;
        const viewport = enabledElement.viewport;
        if (!volumeViewport && !isBaseVolumeSegmentation) {
            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);
        }
    }
    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {
        const referenceImageId = viewport.getCurrentImageId();
        let viewableLabelmapImageIdFound = false;
        for (const labelmapImageId of labelmapImageIds) {
            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });
            if (viewableImageId) {
                viewableLabelmapImageIdFound = true;
                this._stackLabelmapImageIdReferenceMap
                    .get(segmentationId)
                    .set(referenceImageId, labelmapImageId);
                this._updateLabelmapImageIdReferenceMap({
                    segmentationId,
                    referenceImageId,
                    labelmapImageId,
                });
            }
        }
        if (updateCallback) {
            updateCallback(viewport, segmentationId, labelmapImageIds);
        }
        return viewableLabelmapImageIdFound
            ? this._stackLabelmapImageIdReferenceMap
                .get(segmentationId)
                .get(referenceImageId)
            : undefined;
    }
    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);
    }
    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());
        }
        const { representationData } = segmentation;
        if (!representationData.Labelmap) {
            return;
        }
        const labelmapImageIds = this.getLabelmapImageIds(representationData);
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const stackViewport = enabledElement.viewport;
        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {
            const imageIds = stackViewport.getImageIds();
            imageIds.forEach((referenceImageId, index) => {
                for (const labelmapImageId of labelmapImageIds) {
                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });
                    if (viewableImageId) {
                        this._stackLabelmapImageIdReferenceMap
                            .get(segmentationId)
                            .set(referenceImageId, labelmapImageId);
                        this._updateLabelmapImageIdReferenceMap({
                            segmentationId,
                            referenceImageId,
                            labelmapImageId,
                        });
                    }
                }
            });
        });
    }
    getLabelmapImageIds(representationData) {
        const labelmapData = representationData.Labelmap;
        let labelmapImageIds;
        if (labelmapData.imageIds) {
            labelmapImageIds = labelmapData
                .imageIds;
        }
        else if (!labelmapImageIds &&
            labelmapData.volumeId) {
            const volumeId = labelmapData
                .volumeId;
            const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            labelmapImageIds = volume.imageIds;
        }
        return labelmapImageIds;
    }
    getLabelmapImageIdsForImageId(imageId, segmentationId) {
        const key = this._generateMapKey({
            segmentationId,
            referenceImageId: imageId,
        });
        return this._labelmapImageIdReferenceMap.get(key);
    }
    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const referenceImageId = stackViewport.getCurrentImageId();
        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);
    }
    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {
            return;
        }
        const stackViewport = enabledElement.viewport;
        const currentImageId = stackViewport.getCurrentImageId();
        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIdReferenceMap.get(currentImageId);
    }
    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
        const segmentation = this.getSegmentation(segmentationId);
        if (!segmentation) {
            return [];
        }
        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        const imageIds = viewport.getImageIds();
        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);
        return imageIds.map((imageId) => {
            return associatedReferenceImageAndLabelmapImageIds.get(imageId);
        });
    }
    removeSegmentationRepresentationsInternal(viewportId, specifier) {
        const removedRepresentations = [];
        this.updateState((state) => {
            if (!state.viewportSegRepresentations[viewportId]) {
                return;
            }
            const currentRepresentations = state.viewportSegRepresentations[viewportId];
            let activeRepresentationRemoved = false;
            if (!specifier ||
                Object.values(specifier).every((value) => value === undefined)) {
                removedRepresentations.push(...currentRepresentations);
                delete state.viewportSegRepresentations[viewportId];
            }
            else {
                const { segmentationId, type } = specifier;
                state.viewportSegRepresentations[viewportId] =
                    currentRepresentations.filter((representation) => {
                        const shouldRemove = (segmentationId &&
                            type &&
                            representation.segmentationId === segmentationId &&
                            representation.type === type) ||
                            (segmentationId &&
                                !type &&
                                representation.segmentationId === segmentationId) ||
                            (!segmentationId && type && representation.type === type);
                        if (shouldRemove) {
                            removedRepresentations.push(representation);
                            if (representation.active) {
                                activeRepresentationRemoved = true;
                            }
                        }
                        return !shouldRemove;
                    });
                if (state.viewportSegRepresentations[viewportId].length === 0) {
                    delete state.viewportSegRepresentations[viewportId];
                }
                else if (activeRepresentationRemoved) {
                    state.viewportSegRepresentations[viewportId][0].active = true;
                }
            }
        });
        return removedRepresentations;
    }
    removeSegmentationRepresentations(viewportId, specifier) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        removedRepresentations.forEach((representation) => {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, representation.segmentationId, representation.type);
        });
        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);
        if (remainingRepresentations.length > 0 &&
            remainingRepresentations[0].active) {
            (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);
        }
        return removedRepresentations;
    }
    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {
        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);
        if (!suppressEvent) {
            removedRepresentations.forEach(({ segmentationId, type }) => {
                (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationRemoved)(viewportId, segmentationId, type);
            });
        }
        return removedRepresentations;
    }
    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {
        const key = this._generateMapKey({ segmentationId, referenceImageId });
        if (!this._labelmapImageIdReferenceMap.has(key)) {
            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);
            return;
        }
        const currentValues = this._labelmapImageIdReferenceMap.get(key);
        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));
        this._labelmapImageIdReferenceMap.set(key, newValues);
    }
    _setActiveSegmentation(state, viewportId, segmentationId) {
        const viewport = state.viewportSegRepresentations[viewportId];
        if (!viewport) {
            return;
        }
        viewport.forEach((value) => {
            value.active = value.segmentationId === segmentationId;
        });
    }
    setActiveSegmentation(viewportId, segmentationId) {
        this.updateState((state) => {
            const viewport = state.viewportSegRepresentations[viewportId];
            if (!viewport) {
                return;
            }
            viewport.forEach((value) => {
                value.active = value.segmentationId === segmentationId;
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
    }
    getActiveSegmentation(viewportId) {
        if (!this.state.viewportSegRepresentations[viewportId]) {
            return;
        }
        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);
        if (!activeSegRep) {
            return;
        }
        return this.getSegmentation(activeSegRep.segmentationId);
    }
    getSegmentationRepresentations(viewportId, specifier = {}) {
        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];
        if (!viewportRepresentations) {
            return [];
        }
        if (!specifier.type && !specifier.segmentationId) {
            return viewportRepresentations;
        }
        return viewportRepresentations.filter((representation) => {
            const typeMatch = specifier.type
                ? representation.type === specifier.type
                : true;
            const idMatch = specifier.segmentationId
                ? representation.segmentationId === specifier.segmentationId
                : true;
            return typeMatch && idMatch;
        });
    }
    getSegmentationRepresentation(viewportId, specifier) {
        return this.getSegmentationRepresentations(viewportId, specifier)[0];
    }
    getSegmentationRepresentationVisibility(viewportId, specifier) {
        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);
        return viewportRepresentation?.visible;
    }
    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
        this.updateState((state) => {
            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);
            if (!viewportRepresentations) {
                return;
            }
            viewportRepresentations.forEach((representation) => {
                representation.visible = visible;
                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {
                    segment.visible = visible;
                });
            });
        });
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationRepresentationModified)(viewportId, specifier.segmentationId, specifier.type);
    }
    addColorLUT(colorLUT, lutIndex) {
        this.updateState((state) => {
            if (state.colorLUT[lutIndex]) {
                console.warn('Color LUT table already exists, overwriting');
            }
            state.colorLUT[lutIndex] = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepClone(colorLUT);
        });
    }
    removeColorLUT(colorLUTIndex) {
        this.updateState((state) => {
            delete state.colorLUT[colorLUTIndex];
        });
    }
    _getStackIdForImageIds(imageIds) {
        return imageIds
            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))
            .join('_');
    }
    getAllViewportSegmentationRepresentations() {
        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({
            viewportId,
            representations,
        }));
    }
    getSegmentationRepresentationsBySegmentationId(segmentationId) {
        const result = [];
        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {
            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);
            if (filteredReps.length > 0) {
                result.push({ viewportId, representations: filteredReps });
            }
        });
        return result;
    }
    _generateMapKey({ segmentationId, referenceImageId }) {
        return `${segmentationId}-${referenceImageId}`;
    }
}
async function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {
    const segmentationImageIds = imageIds;
    const volumeId = options?.volumeId || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);
    return { volumeId };
}
async function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {
    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);
    const data = segmentation.representationData
        .Labelmap;
    const { volumeId } = await internalComputeVolumeLabelmapFromStack({
        imageIds: data.imageIds,
        options,
    });
    segmentation.representationData.Labelmap.volumeId = volumeId;
}
function getDefaultRenderingConfig(type) {
    const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    ofun.addPoint(0, 0);
    if (type === _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap) {
        return {
            cfun,
            ofun,
        };
    }
    else {
        return {};
    }
}
const defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');



/***/ }),

/***/ 92686:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ segmentationStyle)
/* harmony export */ });
/* harmony import */ var _tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67772);
/* harmony import */ var _tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53486);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15327);




class SegmentationStyle {
    constructor() {
        this.config = {
            global: {},
            segmentations: {},
            viewportsStyle: {},
        };
    }
    setStyle(specifier, styles) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        const currentStyles = this.getStyle(specifier);
        let updatedStyles;
        if (!viewportId && !segmentationId) {
            updatedStyles = {
                ...currentStyles,
                ...styles,
            };
        }
        else {
            updatedStyles = this.copyActiveToInactiveIfNotProvided({
                ...currentStyles,
                ...styles,
            }, type);
        }
        if (!type) {
            throw new Error('Type is required to set a style');
        }
        if (viewportId) {
            if (!this.config.viewportsStyle[viewportId]) {
                this.config.viewportsStyle[viewportId] = {
                    renderInactiveSegmentations: false,
                    representations: {},
                };
            }
            const representations = this.config.viewportsStyle[viewportId].representations;
            if (segmentationId) {
                if (!representations[segmentationId]) {
                    representations[segmentationId] = {};
                }
                if (!representations[segmentationId][type]) {
                    representations[segmentationId][type] = {};
                }
                const repConfig = representations[segmentationId][type];
                if (segmentIndex !== undefined) {
                    if (!repConfig.perSegment) {
                        repConfig.perSegment = {};
                    }
                    repConfig.perSegment[segmentIndex] = updatedStyles;
                }
                else {
                    repConfig.allSegments = updatedStyles;
                }
            }
            else {
                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';
                if (!representations[ALL_SEGMENTATIONS_KEY]) {
                    representations[ALL_SEGMENTATIONS_KEY] = {};
                }
                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {
                    representations[ALL_SEGMENTATIONS_KEY][type] = {};
                }
                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =
                    updatedStyles;
            }
        }
        else if (segmentationId) {
            if (!this.config.segmentations[segmentationId]) {
                this.config.segmentations[segmentationId] = {};
            }
            if (!this.config.segmentations[segmentationId][type]) {
                this.config.segmentations[segmentationId][type] = {};
            }
            const segConfig = this.config.segmentations[segmentationId][type];
            if (segmentIndex !== undefined) {
                if (!segConfig.perSegment) {
                    segConfig.perSegment = {};
                }
                segConfig.perSegment[segmentIndex] = updatedStyles;
            }
            else {
                segConfig.allSegments = updatedStyles;
            }
        }
        else {
            this.config.global[type] = updatedStyles;
        }
    }
    copyActiveToInactiveIfNotProvided(styles, type) {
        const processedStyles = { ...styles };
        if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap) {
            const labelmapStyles = processedStyles;
            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;
            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;
            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;
            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;
            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;
        }
        else if (type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
            const contourStyles = processedStyles;
            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;
            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;
            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;
            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;
            contourStyles.renderFillInactive ??= contourStyles.renderFill;
            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;
        }
        return processedStyles;
    }
    getStyle(specifier) {
        const { viewportId, segmentationId, type, segmentIndex } = specifier;
        let combinedStyle = this.getDefaultStyle(type);
        let renderInactiveSegmentations = false;
        if (this.config.global[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.global[type],
            };
        }
        if (this.config.segmentations[segmentationId]?.[type]) {
            combinedStyle = {
                ...combinedStyle,
                ...this.config.segmentations[segmentationId][type].allSegments,
            };
            if (segmentIndex !== undefined &&
                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],
                };
            }
        }
        if (viewportId && this.config.viewportsStyle[viewportId]) {
            renderInactiveSegmentations =
                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;
            const allSegmentationsKey = '__allSegmentations__';
            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,
                };
            }
            if (segmentationId &&
                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {
                combinedStyle = {
                    ...combinedStyle,
                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,
                };
                if (segmentIndex !== undefined &&
                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {
                    combinedStyle = {
                        ...combinedStyle,
                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],
                    };
                }
            }
        }
        return combinedStyle;
    }
    getRenderInactiveSegmentations(viewportId) {
        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;
    }
    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
        if (!this.config.viewportsStyle[viewportId]) {
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations: false,
                representations: {},
            };
        }
        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =
            renderInactiveSegmentations;
    }
    getDefaultStyle(type) {
        switch (type) {
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Labelmap:
                return (0,_tools_displayTools_Labelmap_labelmapConfig__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour:
                return (0,_tools_displayTools_Contour_contourConfig__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)();
            case _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Surface:
                return {};
            default:
                throw new Error(`Unknown representation type: ${type}`);
        }
    }
    clearSegmentationStyle(segmentationId) {
        if (this.config.segmentations[segmentationId]) {
            delete this.config.segmentations[segmentationId];
        }
    }
    clearAllSegmentationStyles() {
        this.config.segmentations = {};
    }
    clearViewportStyle(viewportId) {
        if (this.config.viewportsStyle[viewportId]) {
            delete this.config.viewportsStyle[viewportId];
        }
    }
    clearAllViewportStyles() {
        for (const viewportId in this.config.viewportsStyle) {
            const viewportStyle = this.config.viewportsStyle[viewportId];
            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;
            this.config.viewportsStyle[viewportId] = {
                renderInactiveSegmentations,
                representations: {},
            };
        }
    }
    resetToGlobalStyle() {
        this.clearAllSegmentationStyles();
        this.clearAllViewportStyles();
    }
    hasCustomStyle(specifier) {
        const { type } = specifier;
        const style = this.getStyle(specifier);
        const defaultStyle = this.getDefaultStyle(type);
        return !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_3__.utilities.deepEqual(style, defaultStyle);
    }
}
const segmentationStyle = new SegmentationStyle();



/***/ }),

/***/ 26228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getActiveSegmentation: () => (/* binding */ activeSegmentation_getActiveSegmentation),
  setActiveSegmentation: () => (/* binding */ activeSegmentation_setActiveSegmentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
var getActiveSegmentation = __webpack_require__(67165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js

function setActiveSegmentation(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js


function activeSegmentation_getActiveSegmentation(viewportId) {
    return (0,getActiveSegmentation/* getActiveSegmentation */.T)(viewportId);
}
function activeSegmentation_setActiveSegmentation(viewportId, segmentationId) {
    setActiveSegmentation(viewportId, segmentationId);
}



/***/ }),

/***/ 4714:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ addColorLUT)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);
/* harmony import */ var _getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70906);
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93952);




function addColorLUT(colorLUT, index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const indexToUse = index ?? (0,_getNextColorLUTIndex__WEBPACK_IMPORTED_MODULE_2__/* .getNextColorLUTIndex */ .u)();
    let colorLUTToUse = [...colorLUT];
    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {
        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');
        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];
    }
    colorLUTToUse = colorLUTToUse.map((color) => {
        if (color.length === 3) {
            return [color[0], color[1], color[2], 255];
        }
        return color;
    });
    if (colorLUTToUse.length < 255) {
        const missingColorLUTs = _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.slice(colorLUTToUse.length);
        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];
    }
    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);
    return indexToUse;
}


/***/ }),

/***/ 74283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   At: () => (/* binding */ addContourRepresentationToViewport),
/* harmony export */   gR: () => (/* binding */ addSegmentationRepresentations)
/* harmony export */ });
/* unused harmony exports addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap */
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55894);


function addSegmentationRepresentations(viewportId, segmentationInputArray) {
    segmentationInputArray.map((segmentationInput) => {
        return (0,_internalAddSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_1__/* .internalAddSegmentationRepresentation */ .U)(viewportId, segmentationInput);
    });
}
function addContourRepresentationToViewport(viewportId, contourInputArray) {
    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({
        ...input,
        type: _enums__WEBPACK_IMPORTED_MODULE_0__.SegmentationRepresentations.Contour,
    })));
}
function addContourRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}
function addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {
    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({
        ...input,
        type: SegmentationRepresentations.Labelmap,
    })));
}
function addLabelmapRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({
            ...input,
            type: SegmentationRepresentations.Labelmap,
        })));
    }
}
function addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {
    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({
        ...input,
        type: SegmentationRepresentations.Surface,
    })));
}
function addSurfaceRepresentationToViewportMap(viewportInputMap) {
    const results = {};
    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {
        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);
    }
    return results;
}



/***/ }),

/***/ 30935:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ addSegmentations)
});

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js


function normalizeSegmentationInput(segmentationInput) {
    const { segmentationId, representation, config } = segmentationInput;
    const { type, data: inputData } = representation;
    const data = inputData ? { ...inputData } : {};
    if (!data) {
        throw new Error('Segmentation representation data may not be undefined');
    }
    if (type === enums.SegmentationRepresentations.Contour) {
        normalizeContourData(data);
    }
    const normalizedSegments = normalizeSegments(config?.segments, type, data);
    delete config?.segments;
    return {
        segmentationId,
        label: config?.label ?? null,
        cachedStats: config?.cachedStats ?? {},
        segments: normalizedSegments,
        representationData: {
            [type]: {
                ...data,
            },
        },
    };
}
function normalizeContourData(contourData) {
    contourData.geometryIds = contourData.geometryIds ?? [];
    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();
}
function normalizeSegments(segmentsConfig, type, data) {
    const normalizedSegments = {};
    if (segmentsConfig) {
        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {
            const { label, locked, cachedStats, active, ...rest } = segment;
            const normalizedSegment = {
                segmentIndex: Number(segmentIndex),
                label: label ?? `Segment ${segmentIndex}`,
                locked: locked ?? false,
                cachedStats: cachedStats ?? {},
                active: active ?? false,
                ...rest,
            };
            normalizedSegments[segmentIndex] = normalizedSegment;
        });
    }
    else if (type === enums.SegmentationRepresentations.Contour) {
        normalizeContourSegments(normalizedSegments, data);
    }
    else if (type === enums.SegmentationRepresentations.Surface) {
        normalizeSurfaceSegments(normalizedSegments, data);
    }
    else {
        normalizedSegments[1] = createDefaultSegment();
    }
    return normalizedSegments;
}
function normalizeContourSegments(normalizedSegments, contourData) {
    const { geometryIds } = contourData;
    geometryIds?.forEach((geometryId) => {
        const geometry = esm.cache.getGeometry(geometryId);
        if (geometry?.data) {
            const { segmentIndex } = geometry.data;
            normalizedSegments[segmentIndex] = { segmentIndex };
        }
    });
}
function normalizeSurfaceSegments(normalizedSegments, surfaceData) {
    const { geometryIds } = surfaceData;
    geometryIds?.forEach((geometryId) => {
        const geometry = esm.cache.getGeometry(geometryId);
        if (geometry?.data) {
            const { segmentIndex } = geometry.data;
            normalizedSegments[segmentIndex] = { segmentIndex };
        }
    });
}
function createDefaultSegment() {
    return {
        segmentIndex: 1,
        label: 'Segment 1',
        locked: false,
        cachedStats: {},
        active: true,
    };
}
/* harmony default export */ const helpers_normalizeSegmentationInput = (normalizeSegmentationInput);

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js



function addSegmentations(segmentationInputArray, suppressEvents) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationInputArray.forEach((segmentationInput) => {
        const segmentation = helpers_normalizeSegmentationInput(segmentationInput);
        segmentationStateManager.addSegmentation(segmentation);
        if (!suppressEvents) {
            (0,triggerSegmentationEvents.triggerSegmentationModified)(segmentation.segmentationId);
        }
    });
}
/* harmony default export */ const segmentation_addSegmentations = ((/* unused pure expression or super */ null && (addSegmentations)));


/***/ }),

/***/ 93733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addColorLUT: () => (/* binding */ addColorLUT),
/* harmony export */   getSegmentIndexColor: () => (/* binding */ getSegmentIndexColor),
/* harmony export */   setColorLUT: () => (/* binding */ setColorLUT),
/* harmony export */   setSegmentIndexColor: () => (/* binding */ setSegmentIndexColor)
/* harmony export */ });
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4714);
/* harmony import */ var _getColorLUT__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50409);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93210);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);




function addColorLUT(colorLUT, colorLUTIndex) {
    if (!colorLUT) {
        throw new Error('addColorLUT: colorLUT is required');
    }
    return (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_0__/* .addColorLUT */ .u)(colorLUT, colorLUTIndex);
}
function setColorLUT(viewportId, segmentationId, colorLUTsIndex) {
    if (!(0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTsIndex)) {
        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);
    }
    const segmentationRepresentations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, { segmentationId });
    if (!segmentationRepresentations) {
        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);
    }
    segmentationRepresentations.forEach((segmentationRepresentation) => {
        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;
    });
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}
function getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {
    const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentationRepresentations */ .r$)(viewportId, {
        segmentationId,
    });
    if (!representations || representations.length === 0) {
        return null;
    }
    const representation = representations[0];
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_getColorLUT__WEBPACK_IMPORTED_MODULE_1__/* .getColorLUT */ .B)(colorLUTIndex);
    let colorValue = colorLUT[segmentIndex];
    if (!colorValue) {
        if (typeof segmentIndex !== 'number') {
            console.warn(`Can't create colour for LUT index ${segmentIndex}`);
            return null;
        }
        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];
    }
    return colorValue;
}
function setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {
    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);
    for (let i = 0; i < color.length; i++) {
        colorReference[i] = color[i];
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationRepresentationModified)(viewportId, segmentationId);
}



/***/ }),

/***/ 98798:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ triggerSegmentationDataModified)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64063);



function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {
    const eventDetail = {
        segmentationId,
        modifiedSlicesToUse,
        segmentIndex,
    };
    (0,_utilities_segmentation_utilities__WEBPACK_IMPORTED_MODULE_2__/* .setSegmentationDirty */ .HM)(segmentationId);
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.SEGMENTATION_DATA_MODIFIED, eventDetail);
}


/***/ }),

/***/ 67165:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getActiveSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getActiveSegmentation(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getActiveSegmentation(viewportId);
}


/***/ }),

/***/ 70906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ getNextColorLUTIndex)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getNextColorLUTIndex() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getNextColorLUTIndex();
}


/***/ }),

/***/ 93210:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ut: () => (/* binding */ getSegmentationRepresentation),
/* harmony export */   ny: () => (/* binding */ getSegmentationRepresentationsBySegmentationId),
/* harmony export */   r$: () => (/* binding */ getSegmentationRepresentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentationRepresentations(viewportId, specifier = {}) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
}
function getSegmentationRepresentation(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    if (!specifier.segmentationId || !specifier.type) {
        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');
    }
    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);
    return representations?.[0];
}
function getSegmentationRepresentationsBySegmentationId(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);
}


/***/ }),

/***/ 33658:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ getSegmentationRepresentationVisibility)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentationRepresentationVisibility(viewportId, specifier) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);
}


/***/ }),

/***/ 70758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ getSegmentations)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    return state.segmentations;
}


/***/ }),

/***/ 42568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getViewportSegmentations),
/* harmony export */   z: () => (/* binding */ getViewportSegmentationRepresentations)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59475);


function getViewportSegmentations(viewportId, type) {
    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);
    const segmentations = viewportRepresentations.map((representation) => {
        if (type && representation.type === type) {
            return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
        }
        return (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(representation.segmentationId);
    });
    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);
    return filteredSegmentations;
}
function getViewportSegmentationRepresentations(viewportId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_1__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportRepresentations = state.viewportSegRepresentations[viewportId];
    return viewportRepresentations;
}


/***/ }),

/***/ 93690:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ convertVolumeToStackLabelmap)
/* harmony export */ });
/* unused harmony export computeStackLabelmapFromVolume */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33283);
/* harmony import */ var _helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98149);



async function computeStackLabelmapFromVolume({ volumeId, }) {
    const segmentationVolume = cache.getVolume(volumeId);
    return { imageIds: segmentationVolume.imageIds };
}
function convertVolumeToStackLabelmap({ segmentationId, options, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    const { volumeId } = segmentation.representationData
        .Labelmap;
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    return (0,_helpers_updateStackSegmentationState__WEBPACK_IMPORTED_MODULE_2__/* .updateStackSegmentationState */ .X)({
        segmentationId,
        viewportId: options.viewportId,
        imageIds: segmentationVolume.imageIds,
        options,
    });
}


/***/ }),

/***/ 6994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ computeVolumeLabelmapFromStack)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

async function computeVolumeLabelmapFromStack(args) {
    return (0,_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .internalComputeVolumeLabelmapFromStack */ .Zm)(args);
}


/***/ }),

/***/ 55126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  activeSegmentation: () => (/* reexport */ activeSegmentation),
  addContourRepresentationToViewport: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addContourRepresentationToViewport */.At),
  addRepresentationData: () => (/* reexport */ internalAddRepresentationData/* default */.A),
  addSegmentationRepresentations: () => (/* reexport */ addSegmentationRepresentationsToViewport/* addSegmentationRepresentations */.gR),
  config: () => (/* reexport */ config_namespaceObject),
  getActiveSegmentation: () => (/* reexport */ getActiveSegmentation/* getActiveSegmentation */.T),
  segmentIndex: () => (/* reexport */ segmentIndex),
  segmentLocking: () => (/* reexport */ segmentLocking),
  state: () => (/* reexport */ segmentationState)
});

// UNUSED EXPORTS: addContourRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentations, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIds, getLabelmapImageIdsForImageId, helpers, removeAllSegmentationRepresentations, removeAllSegmentations, removeContourRepresentation, removeLabelmapRepresentation, removeSegment, removeSegmentation, removeSegmentationRepresentation, removeSegmentationRepresentations, removeSurfaceRepresentation, segmentationStyle, strategies, triggerSegmentationEvents, updateSegmentations, utilities

// NAMESPACE OBJECT: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js
var config_namespaceObject = {};
__webpack_require__.r(config_namespaceObject);
__webpack_require__.d(config_namespaceObject, {
  color: () => (segmentationColor)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js
var addSegmentationRepresentationsToViewport = __webpack_require__(74283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js
var internalAddRepresentationData = __webpack_require__(44188);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js
var triggerSegmentationEvents = __webpack_require__(49906);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js


function updateSegmentations_updateSegmentations(segmentationUpdateArray, suppressEvents) {
    const segmentationStateManager = defaultSegmentationStateManager;
    segmentationUpdateArray.forEach((segmentationUpdate) => {
        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);
        if (!suppressEvents) {
            triggerSegmentationModified(segmentationUpdate.segmentationId);
        }
    });
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js + 1 modules
var activeSegmentation = __webpack_require__(26228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js
var segmentLocking = __webpack_require__(26795);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js + 2 modules
var segmentationState = __webpack_require__(98870);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js
var segmentationColor = __webpack_require__(93733);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var segmentation_getSegmentationRepresentation = __webpack_require__(93210);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js

function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {
    const segmentationStateManager = defaultSegmentationStateManager;
    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js
var getSegmentationRepresentationVisibility = __webpack_require__(33658);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js
var SegmentationRenderingEngine = __webpack_require__(24917);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js





function segmentationVisibility_setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {
    const representations = getSegmentationRepresentations(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        _setSegmentationRepresentationVisibility(viewportId, {
            segmentationId: representation.segmentationId,
            type: representation.type,
        }, visibility);
    });
}
function segmentationVisibility_getSegmentationRepresentationVisibility(viewportId, specifier) {
    return _getSegmentationRepresentationVisibility(viewportId, specifier);
}
function setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {
    const representations = getSegmentationRepresentations(viewportId, specifier);
    if (!representations) {
        return;
    }
    representations.forEach((representation) => {
        if (!representation.segments || !representation.segments[segmentIndex]) {
            return;
        }
        representation.segments[segmentIndex].visible = visibility;
    });
    triggerSegmentationRenderBySegmentationId(specifier.segmentationId);
    triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId);
}
function getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {
    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);
    return !hiddenSegments.has(segmentIndex);
}
function getHiddenSegmentIndices(viewportId, specifier) {
    const representation = getSegmentationRepresentation(viewportId, specifier);
    if (!representation) {
        return new Set();
    }
    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {
        if (!segment.visible) {
            acc.add(Number(segmentIndex));
        }
        return acc;
    }, new Set());
    return segmentsHidden;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var segmentation_getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var segmentation_getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js
var SegmentationStyle = __webpack_require__(92686);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js





function getStyle(specifier) {
    return segmentationStyle.getStyle(specifier);
}
function setStyle(specifier, style) {
    segmentationStyle.setStyle(specifier, style);
    if (!specifier.viewportId && !specifier.segmentationId) {
        const segmentations = getSegmentations();
        segmentations.forEach((segmentation) => {
            triggerSegmentationRender(segmentation.segmentationId);
        });
    }
    triggerSegmentationRepresentationModified(specifier.viewportId, specifier.segmentationId, specifier.type);
}
function setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {
    segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);
    triggerSegmentationRender(viewportId);
    const segmentations = getViewportSegmentations(viewportId);
    segmentations.forEach((segmentation) => {
        triggerSegmentationRepresentationModified(viewportId, segmentation.segmentationId);
    });
}
function getRenderInactiveSegmentations(viewportId) {
    return segmentationStyle.getRenderInactiveSegmentations(viewportId);
}
function resetToGlobalStyle() {
    segmentationStyle.resetToGlobalStyle();
    triggerSegmentationRender();
}
function hasCustomStyle(specifier) {
    return segmentationStyle.hasCustomStyle(specifier);
}


;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js





// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js
var segmentIndex = __webpack_require__(70930);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/index.js
var utilities = __webpack_require__(31994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/convertStackToVolumeLabelmap.js
var convertStackToVolumeLabelmap = __webpack_require__(6273);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js
var computeVolumeLabelmapFromStack = __webpack_require__(6994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var segmentation_getSegmentation = __webpack_require__(33283);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js



function clearSegmentValue_clearSegmentValue(segmentationId, segmentIndex) {
    const segmentation = (0,segmentation_getSegmentation/* getSegmentation */.T)(segmentationId);
    if (segmentation.representationData.Labelmap) {
        const { representationData } = segmentation;
        const labelmapData = representationData.Labelmap;
        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {
            const items = 'imageIds' in labelmapData
                ? labelmapData.imageIds.map((imageId) => esm.cache.getImage(imageId))
                : [esm.cache.getVolume(labelmapData.volumeId)];
            items.forEach((item) => {
                if (!item) {
                    return;
                }
                const { voxelManager } = item;
                voxelManager.forEach(({ value, index }) => {
                    if (value === segmentIndex) {
                        voxelManager.setAtIndex(index, 0);
                    }
                });
            });
        }
        (0,triggerSegmentationEvents.triggerSegmentationDataModified)(segmentationId);
    }
    else {
        throw new Error('Invalid segmentation type, only labelmap is supported right now');
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js
var computeStackLabelmapFromVolume = __webpack_require__(93690);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js
var segmentation_getActiveSegmentIndex = __webpack_require__(60740);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var segmentation_getViewportIdsWithSegmentation = __webpack_require__(58859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js + 1 modules
var contourSegmentation = __webpack_require__(56534);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/removeSegmentAnnotations.js



function removeSegmentAnnotations_removeContourSegmentAnnotations(segmentationId, segmentIndex) {
    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentationId);
    if (!annotationUIDsMap) {
        return;
    }
    const annotationUIDs = annotationUIDsMap.get(segmentIndex);
    if (!annotationUIDs) {
        return;
    }
    annotationUIDs.forEach((annotationUID) => {
        const annotation = getAnnotation(annotationUID);
        if (isContourSegmentationAnnotation(annotation)) {
            removeCompleteContourAnnotation(annotation);
        }
    });
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js








function removeSegment(segmentationId, segmentIndex, options = {
    setNextSegmentAsActive: true,
}) {
    const segmentation = getSegmentation(segmentationId);
    if (segmentation?.representationData.Contour) {
        removeContourSegmentAnnotations(segmentationId, segmentIndex);
    }
    else if (segmentation?.representationData.Labelmap) {
        clearSegmentValue(segmentationId, segmentIndex);
    }
    else {
        throw new Error('Invalid segmentation type');
    }
    const isThisSegmentActive = getActiveSegmentIndex(segmentationId) === segmentIndex;
    const { segments } = segmentation;
    delete segments[segmentIndex];
    const updatedSegments = {
        ...segments,
    };
    updateSegmentations([
        {
            segmentationId,
            payload: {
                segments: updatedSegments,
            },
        },
    ]);
    if (isThisSegmentActive && options.setNextSegmentAsActive) {
        const segmentIndices = Object.keys(segments)
            .map(Number)
            .sort((a, b) => a - b);
        const currentIndex = segmentIndices.indexOf(segmentIndex);
        const nextSegmentIndex = segmentIndices[currentIndex + 1];
        const previousSegmentIndex = segmentIndices[currentIndex - 1];
        if (nextSegmentIndex !== undefined) {
            setActiveSegmentIndex(segmentationId, nextSegmentIndex);
        }
        else if (previousSegmentIndex !== undefined) {
            setActiveSegmentIndex(segmentationId, previousSegmentIndex);
        }
    }
    const viewportIds = getViewportIdsWithSegmentation(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = getSegmentationRepresentations(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            delete representation.segments[segmentIndex];
        });
    });
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js


function getLabelmapImageIds(segmentationId) {
    const segmentationStateManager = defaultSegmentationStateManager;
    const segmentation = getSegmentation(segmentationId);
    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/index.js
var strategies = __webpack_require__(99522);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js
var getActiveSegmentation = __webpack_require__(67165);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js
























const helpers = {
    clearSegmentValue: clearSegmentValue_clearSegmentValue,
    convertStackToVolumeLabelmap: convertStackToVolumeLabelmap/* convertStackToVolumeLabelmap */.p,
    computeVolumeLabelmapFromStack: computeVolumeLabelmapFromStack/* computeVolumeLabelmapFromStack */.a,
    convertVolumeToStackLabelmap: computeStackLabelmapFromVolume/* convertVolumeToStackLabelmap */.f,
};



/***/ }),

/***/ 44188:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);


function internalAddRepresentationData({ segmentationId, type, data, }) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`Segmentation ${segmentationId} not found`);
    }
    if (segmentation.representationData[type]) {
        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);
    }
    switch (type) {
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Labelmap:
            if (data) {
                segmentation.representationData[type] =
                    data;
            }
            break;
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour:
            if (data) {
                segmentation.representationData[type] = data;
            }
            break;
        case _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface:
            if (data) {
                segmentation.representationData[type] = data;
            }
            break;
        default:
            throw new Error(`Invalid representation type ${type}`);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (internalAddRepresentationData);


/***/ }),

/***/ 55894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ internalAddSegmentationRepresentation)
/* harmony export */ });
/* harmony import */ var _constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93952);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49906);
/* harmony import */ var _addColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4714);
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59475);
/* harmony import */ var _segmentIndex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(70930);







function internalAddSegmentationRepresentation(viewportId, representationInput) {
    const { segmentationId, config } = representationInput;
    const renderingConfig = {
        colorLUTIndex: getColorLUTIndex(config),
        ...config,
    };
    _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__/* .defaultSegmentationStateManager */ ._6.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);
    if (!(0,_segmentIndex__WEBPACK_IMPORTED_MODULE_6__.getActiveSegmentIndex)(segmentationId)) {
        let firstSegmentIndex = 1;
        const segmentation = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_5__/* .defaultSegmentationStateManager */ ._6.getSegmentation(segmentationId);
        if (segmentation) {
            const segmentKeys = Object.keys(segmentation.segments);
            if (segmentKeys.length > 0) {
                firstSegmentIndex = segmentKeys.map((k) => Number(k)).sort()[0];
            }
        }
        (0,_segmentIndex__WEBPACK_IMPORTED_MODULE_6__.setActiveSegmentIndex)(segmentationId, firstSegmentIndex);
    }
    if (representationInput.type === _enums__WEBPACK_IMPORTED_MODULE_2__.SegmentationRepresentations.Contour) {
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* .triggerAnnotationRenderForViewportIds */ .t)([viewportId]);
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_3__.triggerSegmentationModified)(segmentationId);
}
function getColorLUTIndex(config) {
    const { colorLUTOrIndex } = config || {};
    if (colorLUTOrIndex === undefined) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)));
        return index;
    }
    if (typeof colorLUTOrIndex === 'number') {
        return colorLUTOrIndex;
    }
    if (Array.isArray(colorLUTOrIndex) &&
        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {
        const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(colorLUTOrIndex);
        return index;
    }
    const index = (0,_addColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .addColorLUT */ .u)(JSON.parse(JSON.stringify(_constants_COLOR_LUT__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)));
    return index;
}



/***/ }),

/***/ 63427:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ removeAllSegmentations),
/* harmony export */   z: () => (/* binding */ removeSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53662);



function removeSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const viewportsWithSegmentation = segmentationStateManager
        .getAllViewportSegmentationRepresentations()
        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))
        .map(({ viewportId }) => viewportId);
    viewportsWithSegmentation.forEach((viewportId) => {
        (0,_removeSegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* .removeSegmentationRepresentations */ .nc)(viewportId, { segmentationId });
    });
    segmentationStateManager.removeSegmentation(segmentationId);
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationRemoved)(segmentationId);
}
function removeAllSegmentations() {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const segmentations = segmentationStateManager.getState().segmentations;
    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);
    segmentationIds.forEach((segmentationId) => {
        removeSegmentation(segmentationId);
    });
    segmentationStateManager.resetState();
}


/***/ }),

/***/ 53662:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  us: () => (/* binding */ removeAllSegmentationRepresentations),
  OE: () => (/* binding */ removeContourRepresentation),
  kN: () => (/* binding */ removeLabelmapRepresentation),
  E8: () => (/* binding */ removeSegmentationRepresentation),
  nc: () => (/* binding */ removeSegmentationRepresentations),
  JC: () => (/* binding */ removeSurfaceRepresentation)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js
var labelmapDisplay = __webpack_require__(684);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js
var contourDisplay = __webpack_require__(25894);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js
var surfaceDisplay = __webpack_require__(67014);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/index.js



;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js







function removeSegmentationRepresentation(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function removeSegmentationRepresentations(viewportId, specifier, immediate) {
    return _removeSegmentationRepresentations(viewportId, specifier, immediate);
}
function _removeSegmentationRepresentations(viewportId, specifier, immediate) {
    const { segmentationId, type } = specifier;
    _removeRepresentationObject(viewportId, segmentationId, type, immediate);
    return SegmentationStateManager/* defaultSegmentationStateManager */._6.removeSegmentationRepresentations(viewportId, {
        segmentationId,
        type,
    });
}
function removeAllSegmentationRepresentations() {
    const state = SegmentationStateManager/* defaultSegmentationStateManager */._6.getAllViewportSegmentationRepresentations();
    state.forEach(({ viewportId, representations }) => {
        representations.forEach(({ segmentationId, type }) => {
            removeSegmentationRepresentation(viewportId, {
                segmentationId,
                type,
            });
        });
    });
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}
function removeLabelmapRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Labelmap,
    }, immediate);
}
function removeContourRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Contour,
    }, immediate);
}
function removeSurfaceRepresentation(viewportId, segmentationId, immediate) {
    removeSegmentationRepresentation(viewportId, {
        segmentationId,
        type: SegmentationRepresentations/* default */.A.Surface,
    }, immediate);
}
function _removeRepresentationObject(viewportId, segmentationId, type, immediate) {
    const representations = (0,getSegmentationRepresentation/* getSegmentationRepresentations */.r$)(viewportId, {
        segmentationId,
        type,
    });
    representations.forEach((representation) => {
        if (representation.type === SegmentationRepresentations/* default */.A.Labelmap) {
            labelmapDisplay/* default.removeRepresentation */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Contour) {
            contourDisplay/* default */.A.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
        else if (representation.type === SegmentationRepresentations/* default */.A.Surface) {
            surfaceDisplay/* default */.Ay.removeRepresentation(viewportId, representation.segmentationId, immediate);
        }
    });
    const { viewport } = (0,esm.getEnabledElementByViewportId)(viewportId) || {};
    if (viewport) {
        viewport.render();
    }
}



/***/ }),

/***/ 70930:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActiveSegmentIndex: () => (/* reexport safe */ _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__.Q),
/* harmony export */   setActiveSegmentIndex: () => (/* binding */ setActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35706);
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58859);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49906);
/* harmony import */ var _getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60740);
/* harmony import */ var _getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(93210);







function setActiveSegmentIndex(segmentationId, segmentIndex) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    if (typeof segmentIndex === 'string') {
        console.warn('segmentIndex is a string, converting to number');
        segmentIndex = Number(segmentIndex);
    }
    Object.values(segmentation.segments).forEach((segment) => {
        segment.active = false;
    });
    if (!segmentation.segments[segmentIndex]) {
        segmentation.segments[segmentIndex] = {
            segmentIndex,
            label: '',
            locked: false,
            cachedStats: {},
            active: false,
        };
    }
    if (segmentation.segments[segmentIndex].active !== true) {
        segmentation.segments[segmentIndex].active = true;
        (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_4__.triggerSegmentationModified)(segmentationId);
    }
    const viewportIds = (0,_getViewportIdsWithSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getViewportIdsWithSegmentation */ .P)(segmentationId);
    viewportIds.forEach((viewportId) => {
        const representations = (0,_getSegmentationRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentationRepresentations */ .r$)(viewportId, {
            segmentationId,
        });
        representations.forEach((representation) => {
            if (!representation.segments[segmentIndex]) {
                representation.segments[segmentIndex] = {
                    visible: true,
                };
            }
        });
    });
    viewportIds.forEach((viewportId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroupForViewport)(viewportId);
        (0,_utilities_segmentation_invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_1__/* .invalidateBrushCursor */ .E)(toolGroup.id);
    });
}



/***/ }),

/***/ 26795:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLockedSegmentIndices: () => (/* binding */ getLockedSegmentIndices),
/* harmony export */   isSegmentIndexLocked: () => (/* binding */ isSegmentIndexLocked),
/* harmony export */   setSegmentIndexLocked: () => (/* binding */ setSegmentIndexLocked)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);
/* harmony import */ var _annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2076);
/* harmony import */ var _triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49906);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31994);




function _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked) {
    const annotationUIDsMap = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getAnnotationsUIDMapFromSegmentation)(segmentation.segmentationId);
    if (!annotationUIDsMap) {
        return;
    }
    const annotationUIDs = annotationUIDsMap.get(segmentIndex);
    if (!annotationUIDs) {
        return;
    }
    annotationUIDs.forEach((annotationUID) => {
        (0,_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_1__.setAnnotationLocked)(annotationUID, locked);
    });
}
function isSegmentIndexLocked(segmentationId, segmentIndex) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    return segments[segmentIndex].locked;
}
function setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    segments[segmentIndex].locked = locked;
    if (segmentation?.representationData?.Contour) {
        _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked);
    }
    (0,_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_2__.triggerSegmentationModified)(segmentationId);
}
function getLockedSegmentIndices(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation state found for ${segmentationId}`);
    }
    const { segments } = segmentation;
    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);
    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));
}



/***/ }),

/***/ 98870:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  addColorLUT: () => (/* reexport */ addColorLUT/* addColorLUT */.u),
  addSegmentations: () => (/* reexport */ addSegmentations/* addSegmentations */.d),
  destroy: () => (/* binding */ destroy),
  getColorLUT: () => (/* reexport */ getColorLUT/* getColorLUT */.B),
  getCurrentLabelmapImageIdForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdForViewport */.vl),
  getCurrentLabelmapImageIdsForViewport: () => (/* reexport */ getCurrentLabelmapImageIdForViewport/* getCurrentLabelmapImageIdsForViewport */.aF),
  getNextColorLUTIndex: () => (/* reexport */ getNextColorLUTIndex/* getNextColorLUTIndex */.u),
  getSegmentation: () => (/* reexport */ getSegmentation/* getSegmentation */.T),
  getSegmentationRepresentation: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentation */.Ut),
  getSegmentationRepresentations: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentations */.r$),
  getSegmentationRepresentationsBySegmentationId: () => (/* reexport */ getSegmentationRepresentation/* getSegmentationRepresentationsBySegmentationId */.ny),
  getSegmentations: () => (/* reexport */ getSegmentations/* getSegmentations */.K),
  getStackSegmentationImageIdsForViewport: () => (/* reexport */ getStackSegmentationImageIdsForViewport),
  getViewportIdsWithSegmentation: () => (/* reexport */ getViewportIdsWithSegmentation/* getViewportIdsWithSegmentation */.P),
  getViewportSegmentationRepresentations: () => (/* reexport */ getViewportSegmentations/* getViewportSegmentationRepresentations */.z),
  getViewportSegmentations: () => (/* reexport */ getViewportSegmentations/* getViewportSegmentations */.a),
  removeAllSegmentationRepresentations: () => (/* reexport */ removeSegmentationRepresentations/* removeAllSegmentationRepresentations */.us),
  removeAllSegmentations: () => (/* reexport */ removeSegmentation/* removeAllSegmentations */.j),
  removeColorLUT: () => (/* reexport */ removeColorLUT),
  removeContourRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeContourRepresentation */.OE),
  removeLabelmapRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeLabelmapRepresentation */.kN),
  removeSegmentation: () => (/* reexport */ removeSegmentation/* removeSegmentation */.z),
  removeSegmentationRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSegmentationRepresentation */.E8),
  removeSurfaceRepresentation: () => (/* reexport */ removeSegmentationRepresentations/* removeSurfaceRepresentation */.JC),
  updateLabelmapSegmentationImageReferences: () => (/* reexport */ updateLabelmapSegmentationImageReferences/* updateLabelmapSegmentationImageReferences */.t)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js
var getSegmentations = __webpack_require__(70758);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js + 1 modules
var addSegmentations = __webpack_require__(30935);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js
var removeSegmentation = __webpack_require__(63427);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js + 1 modules
var removeSegmentationRepresentations = __webpack_require__(53662);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js
var addColorLUT = __webpack_require__(4714);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js
var getColorLUT = __webpack_require__(50409);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js
var getNextColorLUTIndex = __webpack_require__(70906);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js
var SegmentationStateManager = __webpack_require__(59475);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js

function removeColorLUT(colorLUTIndex) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    segmentationStateManager.removeColorLUT(colorLUTIndex);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js
var getViewportSegmentations = __webpack_require__(42568);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js
var getViewportIdsWithSegmentation = __webpack_require__(58859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js
var getCurrentLabelmapImageIdForViewport = __webpack_require__(97577);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js
var updateLabelmapSegmentationImageReferences = __webpack_require__(78231);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js

function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = SegmentationStateManager/* defaultSegmentationStateManager */._6;
    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js
var getSegmentationRepresentation = __webpack_require__(93210);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js
















function destroy() {
    SegmentationStateManager/* defaultSegmentationStateManager */._6.resetState();
}



/***/ }),

/***/ 78231:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ updateLabelmapSegmentationImageReferences)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);
}


/***/ }),

/***/ 98484:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ getAnnotationsUIDMapFromSegmentation)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function getAnnotationsUIDMapFromSegmentation(segmentationId) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    const contourRepresentationData = segmentation.representationData
        ?.Contour;
    if (!contourRepresentationData) {
        return;
    }
    const { annotationUIDsMap } = contourRepresentationData;
    if (!annotationUIDsMap) {
        return;
    }
    return annotationUIDsMap;
}


/***/ }),

/***/ 31994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAnnotationsUIDMapFromSegmentation: () => (/* reexport safe */ _getAnnotationsUIDMapFromSegmentation__WEBPACK_IMPORTED_MODULE_0__.B)
/* harmony export */ });
/* harmony import */ var _getAnnotationsUIDMapFromSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98484);
/* harmony import */ var _getViewportAssociatedToSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16493);
/* harmony import */ var _getAnnotationMapFromSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10407);
/* harmony import */ var _decimateContours__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53097);
/* harmony import */ var _extractSegmentPolylines__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96629);
/* harmony import */ var _removeCompleteContourAnnotation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38928);
/* harmony import */ var _removeContourHoles__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19741);
/* harmony import */ var _removeContourIslands__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85512);
/* harmony import */ var _smoothContours__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68362);
/* harmony import */ var _convertContourHoles__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(64540);













/***/ }),

/***/ 65136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85204);


function getToolGroupForViewport(viewportId, renderingEngineId) {
    if (!renderingEngineId) {
        renderingEngineId = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngines)().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;
    }
    const toolGroupFilteredByIds = _state__WEBPACK_IMPORTED_MODULE_1__/* .state */ .wk.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&
        (!vp.viewportId || vp.viewportId === viewportId)));
    if (!toolGroupFilteredByIds.length) {
        return;
    }
    if (toolGroupFilteredByIds.length > 1) {
        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only
      have one tool group per viewport in a renderingEngine.`);
    }
    return toolGroupFilteredByIds[0];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getToolGroupForViewport);


/***/ }),

/***/ 48145:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export resetSvgNodeCache */
let svgNodeCache = {};
function resetSvgNodeCache() {
    svgNodeCache = {};
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (svgNodeCache);


/***/ }),

/***/ 25072:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85817);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82056);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(74347);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60810);
/* harmony import */ var _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(93258);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(473);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(76712);


















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class BidirectionalTool extends _base__WEBPACK_IMPORTED_MODULE_3__/* .AnnotationTool */ .EC {
    static { this.toolName = 'Bidirectional'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            preventHandleOutsideImage: false,
            getTextLines: defaultGetTextLines,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            let canvasPoint1 = viewport.worldToCanvas(points[0]);
            let canvasPoint2 = viewport.worldToCanvas(points[1]);
            let line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            let distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            canvasPoint1 = viewport.worldToCanvas(points[2]);
            canvasPoint2 = viewport.worldToCanvas(points[3]);
            line = {
                start: {
                    x: canvasPoint1[0],
                    y: canvasPoint1[1],
                },
                end: {
                    x: canvasPoint2[0],
                    y: canvasPoint2[1],
                },
            };
            distanceToPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const data = annotation.data;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            this.doneEditMemo();
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            const { renderingEngine } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            if (this.editData.handleIndex !== undefined) {
                const { points } = data.handles;
                const firstLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[0], points[1]);
                const secondLineSegmentLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[2], points[3]);
                if (secondLineSegmentLength > firstLineSegmentLength) {
                    const longAxis = [[...points[2]], [...points[3]]];
                    const shortAxisPoint0 = [...points[0]];
                    const shortAxisPoint1 = [...points[1]];
                    const longAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);
                    const counterClockWisePerpendicularToLongAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);
                    const currentShortAxisVector = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
                    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);
                    let shortAxis;
                    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.dot */ .Zc.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {
                        shortAxis = [shortAxisPoint0, shortAxisPoint1];
                    }
                    else {
                        shortAxis = [shortAxisPoint1, shortAxisPoint0];
                    }
                    data.handles.points = [
                        longAxis[0],
                        longAxis[1],
                        shortAxis[0],
                        shortAxis[1],
                    ];
                }
            }
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.removeAnnotation)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
            }
            this.editData = null;
            this.isDrawing = false;
        };
        this._dragDrawCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { worldToCanvas } = viewport;
            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            const worldPos = currentPoints.world;
            data.handles.points[handleIndex] = [...worldPos];
            const canvasCoordPoints = data.handles.points.map(worldToCanvas);
            const canvasCoords = {
                longLineSegment: {
                    start: {
                        x: canvasCoordPoints[0][0],
                        y: canvasCoordPoints[0][1],
                    },
                    end: {
                        x: canvasCoordPoints[1][0],
                        y: canvasCoordPoints[1][1],
                    },
                },
                shortLineSegment: {
                    start: {
                        x: canvasCoordPoints[2][0],
                        y: canvasCoordPoints[2][1],
                    },
                    end: {
                        x: canvasCoordPoints[3][0],
                        y: canvasCoordPoints[3][1],
                    },
                },
            };
            const dist = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.distance */ .Zc.distance(canvasCoordPoints[0], canvasCoordPoints[1]);
            const shortAxisDistFromCenter = dist / 3;
            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;
            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const vectorX = dx / length;
            const vectorY = dy / length;
            const xMid = (canvasCoords.longLineSegment.start.x +
                canvasCoords.longLineSegment.end.x) /
                2;
            const yMid = (canvasCoords.longLineSegment.start.y +
                canvasCoords.longLineSegment.end.y) /
                2;
            const startX = xMid + shortAxisDistFromCenter * vectorY;
            const startY = yMid - shortAxisDistFromCenter * vectorX;
            const endX = xMid - shortAxisDistFromCenter * vectorY;
            const endY = yMid + shortAxisDistFromCenter * vectorX;
            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);
            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);
            annotation.invalidated = true;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            this.editData.hasMoved = true;
        };
        this._dragModifyCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const points = data.handles.points;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                this._dragModifyHandle(evt);
                annotation.invalidated = true;
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.HandlesUpdated);
            }
        };
        this._dragModifyHandle = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { annotation, handleIndex: movingHandleIndex } = this.editData;
            const { data } = annotation;
            const worldPos = currentPoints.world;
            const canvasCoordHandlesCurrent = [
                viewport.worldToCanvas(data.handles.points[0]),
                viewport.worldToCanvas(data.handles.points[1]),
                viewport.worldToCanvas(data.handles.points[2]),
                viewport.worldToCanvas(data.handles.points[3]),
            ];
            const firstLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[0][0],
                    y: canvasCoordHandlesCurrent[0][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[1][0],
                    y: canvasCoordHandlesCurrent[1][1],
                },
            };
            const secondLineSegment = {
                start: {
                    x: canvasCoordHandlesCurrent[2][0],
                    y: canvasCoordHandlesCurrent[2][1],
                },
                end: {
                    x: canvasCoordHandlesCurrent[3][0],
                    y: canvasCoordHandlesCurrent[3][1],
                },
            };
            const proposedPoint = [...worldPos];
            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);
            if (movingHandleIndex === 0 || movingHandleIndex === 1) {
                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;
                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];
                const fixedHandleToProposedCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);
                const fixedHandleToOldCoordVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -
                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -
                    fixedHandleCanvasCoord[1]);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);
                const proposedFirstLineSegment = {
                    start: {
                        x: fixedHandleCanvasCoord[0],
                        y: fixedHandleCanvasCoord[1],
                    },
                    end: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                };
                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {
                    return;
                }
                const centerOfRotation = fixedHandleCanvasCoord;
                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);
                let firstPointX = canvasCoordHandlesCurrent[2][0];
                let firstPointY = canvasCoordHandlesCurrent[2][1];
                let secondPointX = canvasCoordHandlesCurrent[3][0];
                let secondPointY = canvasCoordHandlesCurrent[3][1];
                firstPointX -= centerOfRotation[0];
                firstPointY -= centerOfRotation[1];
                secondPointX -= centerOfRotation[0];
                secondPointY -= centerOfRotation[1];
                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);
                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);
                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);
                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);
                firstPointX = rotatedFirstPoint + centerOfRotation[0];
                firstPointY = rotatedFirstPointY + centerOfRotation[1];
                secondPointX = rotatedSecondPoint + centerOfRotation[0];
                secondPointY = rotatedSecondPointY + centerOfRotation[1];
                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);
                const newSecondPoint = viewport.canvasToWorld([
                    secondPointX,
                    secondPointY,
                ]);
                data.handles.points[movingHandleIndex] = proposedPoint;
                data.handles.points[2] = newFirstPoint;
                data.handles.points[3] = newSecondPoint;
            }
            else {
                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;
                const canvasCoordsCurrent = {
                    longLineSegment: {
                        start: firstLineSegment.start,
                        end: firstLineSegment.end,
                    },
                    shortLineSegment: {
                        start: secondLineSegment.start,
                        end: secondLineSegment.end,
                    },
                };
                const longLineSegmentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordsCurrent.longLineSegment.end.x,
                    canvasCoordsCurrent.longLineSegment.end.y,
                ], [
                    canvasCoordsCurrent.longLineSegment.start.x,
                    canvasCoordsCurrent.longLineSegment.start.y,
                ]);
                const longLineSegmentVecNormalized = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), longLineSegmentVec);
                const proposedToCurrentVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.subtract */ .Zc.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [
                    canvasCoordHandlesCurrent[movingHandleIndex][0],
                    canvasCoordHandlesCurrent[movingHandleIndex][1],
                ]);
                const movementLength = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.length */ .Zc.length(proposedToCurrentVec);
                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);
                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;
                const newTranslatedPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.scaleAndAdd */ .Zc.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create(), [
                    canvasCoordHandlesCurrent[translateHandleIndex][0],
                    canvasCoordHandlesCurrent[translateHandleIndex][1],
                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);
                if (this._movingLongAxisWouldPutItThroughShortAxis({
                    start: {
                        x: proposedCanvasCoord[0],
                        y: proposedCanvasCoord[1],
                    },
                    end: {
                        x: newTranslatedPoint[0],
                        y: newTranslatedPoint[1],
                    },
                }, {
                    start: {
                        x: canvasCoordsCurrent.longLineSegment.start.x,
                        y: canvasCoordsCurrent.longLineSegment.start.y,
                    },
                    end: {
                        x: canvasCoordsCurrent.longLineSegment.end.x,
                        y: canvasCoordsCurrent.longLineSegment.end.y,
                    },
                })) {
                    return;
                }
                const intersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
                if (!intersectionPoint) {
                    return;
                }
                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);
                data.handles.points[movingHandleIndex] = proposedPoint;
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_MOVE, this._dragDrawCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragDrawCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_10__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_DRAG, this._dragModifyCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_11__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = true;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.getAnnotations)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].unit == null) {
                    data.cachedStats[targetId] = {
                        length: null,
                        width: null,
                        unit: null,
                    };
                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_6__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                const showHandlesAlways = Boolean((0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_17__/* .getStyleProperty */ .h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId1 = `${annotationUID}-line-1`;
                const dataId2 = `${annotationUID}-line-2`;
                const lineUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId1);
                const secondLineUID = '1';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLine)(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                    shadow,
                }, dataId2);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                let canvasTextBoxCoords;
                if (!data.handles.textBox.hasMoved) {
                    canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_14__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_9__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {
            const vectorInSecondLineDirection = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.create */ .Zc.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.set */ .Zc.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec2.normalize */ .Zc.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);
            const extendedSecondLineSegment = {
                start: {
                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,
                },
                end: {
                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,
                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,
                },
            };
            const proposedIntersectionPoint = _utilities_math_line__WEBPACK_IMPORTED_MODULE_13__.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);
            const wouldPutThroughShortAxis = !proposedIntersectionPoint;
            return wouldPutThroughShortAxis;
        };
        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { element } = enabledElement.viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[1];
            const worldPos3 = data.handles.points[2];
            const worldPos4 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, dimensions } = image;
                const index1 = transformWorldToIndex(imageData, worldPos1);
                const index2 = transformWorldToIndex(imageData, worldPos2);
                const index3 = transformWorldToIndex(imageData, worldPos3);
                const index4 = transformWorldToIndex(imageData, worldPos4);
                const handles1 = [index1, index2];
                const handles2 = [index3, index4];
                const { scale: scale1, unit: units1 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles1);
                const { scale: scale2, unit: units2 } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles2);
                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;
                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;
                const length = dist1 > dist2 ? dist1 : dist2;
                const width = dist1 > dist2 ? dist2 : dist1;
                const unit = dist1 > dist2 ? units1 : units2;
                const widthUnit = dist1 > dist2 ? units2 : units1;
                this._isInsideVolume(index1, index2, index3, index4, dimensions)
                    ? (this.isHandleOutsideImage = false)
                    : (this.isHandleOutsideImage = true);
                cachedStats[targetId] = {
                    length,
                    width,
                    unit,
                    widthUnit,
                };
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_11__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index3, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index4, dimensions));
        };
        this._getSignedAngle = (vector1, vector2) => {
            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    addNewAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const worldPos = currentPoints.world;
        this.isDrawing = true;
        const annotation = this.createAnnotation(evt, [
            [...worldPos],
            [...worldPos],
            [...worldPos],
            [...worldPos],
        ]);
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, element);
        const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_12__.getViewportIdsWithToolToRender)(element, this.getToolName());
        this.editData = {
            annotation,
            viewportIdsToRender,
            handleIndex: 1,
            movingTextBox: false,
            newAnnotation: true,
            hasMoved: false,
        };
        this._activateDraw(element);
        (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
        evt.preventDefault();
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
        return annotation;
    }
    static { this.hydrate = (viewportId, axis, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);
        const [majorAxis, minorAxis] = axis;
        const [major0, major1] = majorAxis;
        const [minor0, minor1] = minorAxis;
        const points = [major0, major1, minor0, minor1];
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_5__.addAnnotation)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)([viewport.id]);
        return annotation;
    }; }
    _calculateLength(pos1, pos2) {
        const dx = pos1[0] - pos2[0];
        const dy = pos1[1] - pos2[1];
        const dz = pos1[2] - pos2[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
}
function defaultGetTextLines(data, targetId) {
    const { cachedStats, label } = data;
    const { length, width, unit } = cachedStats[targetId];
    const textLines = [];
    if (label) {
        textLines.push(label);
    }
    if (length === undefined) {
        return textLines;
    }
    textLines.push(`L: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit || unit}`, `W: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(width)} ${unit}`);
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BidirectionalTool);


/***/ }),

/***/ 37590:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28220);



class PlanarFreehandContourSegmentationTool extends _PlanarFreehandROITool__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A {
    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }
    constructor(toolProps) {
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge({
            configuration: {
                calculateStats: false,
                allowOpenContours: false,
            },
        }, toolProps);
        super(initialProps);
    }
    isContourSegmentationTool() {
        return true;
    }
    renderAnnotationInstance(renderContext) {
        const annotation = renderContext.annotation;
        const { invalidated } = annotation;
        const renderResult = super.renderAnnotationInstance(renderContext);
        if (invalidated) {
            const { segmentationId } = annotation.data.segmentation;
            (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(segmentationId);
        }
        return renderResult;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandContourSegmentationTool);


/***/ }),

/***/ 28220:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4096);
/* harmony import */ var _utilities_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95527);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13165);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27730);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(60810);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(58640);
/* harmony import */ var _planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55927);
/* harmony import */ var _planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(92400);
/* harmony import */ var _planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(57999);
/* harmony import */ var _planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(69855);
/* harmony import */ var _planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(70734);
/* harmony import */ var _planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(58161);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(74347);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(473);
/* harmony import */ var _utilities_math_polyline__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(92984);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(73262);
/* harmony import */ var _utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(93843);
/* harmony import */ var _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(36320);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(99737);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(40634);


























const { pointCanProjectOnLine } = _utilities_math__WEBPACK_IMPORTED_MODULE_4__.polyline;
const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS;
const PARALLEL_THRESHOLD = 1 - EPSILON;
class PlanarFreehandROITool extends _base_ContourSegmentationBaseTool__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A {
    static { this.toolName = 'PlanarFreehandROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            contourHoleAdditionModifierKey: _enums__WEBPACK_IMPORTED_MODULE_23__.KeyboardBindings.Shift,
            alwaysRenderOpenContourHandles: {
                enabled: false,
                radius: 2,
            },
            allowOpenContours: true,
            closeContourProximity: 10,
            checkCanvasEditFallbackProximity: 6,
            makeClockWise: true,
            subPixelResolution: 4,
            smoothing: {
                smoothOnAdd: false,
                smoothOnEdit: false,
                knotsRatioPercentageOnAdd: 40,
                knotsRatioPercentageOnEdit: 40,
            },
            interpolation: {
                enabled: false,
                onInterpolationComplete: null,
            },
            decimate: {
                enabled: false,
                epsilon: 0.1,
            },
            displayOnePointAsCrosshairs: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_20__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.isDrawing = false;
        this.isEditingClosed = false;
        this.isEditingOpen = false;
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const annotation = this.createAnnotation(evt);
            this.addAnnotation(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateDraw(evt, annotation, viewportIdsToRender);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_7__.getViewportIdsWithToolToRender)(element, this.getToolName());
            if (annotation.data.contour.closed) {
                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);
            }
            else {
                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);
            }
            evt.preventDefault();
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { polyline: points } = annotation.data.contour;
            let previousPoint = viewport.worldToCanvas(points[0]);
            for (let i = 1; i < points.length; i++) {
                const p1 = previousPoint;
                const p2 = viewport.worldToCanvas(points[i]);
                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);
                if (canProject) {
                    return true;
                }
                previousPoint = p2;
            }
            if (!annotation.data.contour.closed) {
                return false;
            }
            const pStart = viewport.worldToCanvas(points[0]);
            const pEnd = viewport.worldToCanvas(points[points.length - 1]);
            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);
        };
        this.cancel = (element) => {
            const isDrawing = this.isDrawing;
            const isEditingOpen = this.isEditingOpen;
            const isEditingClosed = this.isEditingClosed;
            if (isDrawing) {
                this.cancelDrawing(element);
            }
            else if (isEditingOpen) {
                this.cancelOpenContourEdit(element);
            }
            else if (isEditingClosed) {
                this.cancelClosedContourEdit(element);
            }
        };
        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {
            const { data } = annotation;
            const { cachedStats } = data;
            const { polyline: points, closed } = data.contour;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { imageData, metadata } = image;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                const modalityUnitOptions = {
                    isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_19__/* .isViewportPreScaled */ .u)(viewport, targetId),
                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                };
                const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_24__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
                const calibratedScale = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_3__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, () => {
                    const polyline = data.contour.polyline;
                    const numPoints = polyline.length;
                    const projectedPolyline = new Array(numPoints);
                    for (let i = 0; i < numPoints; i++) {
                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
                    }
                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = _utilities_math__WEBPACK_IMPORTED_MODULE_4__.polyline.getAABB(projectedPolyline);
                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);
                    const topLeftBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, topLeftBBWorld);
                    const bottomRightBBWorld = viewport.canvasToWorld([
                        canvasMaxX,
                        canvasMaxY,
                    ]);
                    const bottomRightBBIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, bottomRightBBWorld);
                    return [topLeftBBIndex, bottomRightBBIndex];
                });
                const canvasPoint = canvasCoordinates[0];
                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);
                const deltaXPoint = viewport.canvasToWorld([
                    canvasPoint[0] + 1,
                    canvasPoint[1],
                ]);
                const deltaYPoint = viewport.canvasToWorld([
                    canvasPoint[0],
                    canvasPoint[1] + 1,
                ]);
                const deltaInX = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaXPoint);
                const deltaInY = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.distance */ .eR.distance(originalWorldPoint, deltaYPoint);
                if (closed) {
                    this.updateClosedCachedStats({
                        targetId,
                        viewport,
                        canvasCoordinates,
                        points,
                        imageData,
                        metadata,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                        deltaInX,
                        deltaInY,
                    });
                }
                else {
                    this.updateOpenCachedStats({
                        metadata,
                        canvasCoordinates,
                        targetId,
                        cachedStats,
                        modalityUnit,
                        calibratedScale,
                        deltaInX,
                        deltaInY,
                    });
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_15__.triggerAnnotationModified)(annotation, enabledElement.viewport.element, _enums__WEBPACK_IMPORTED_MODULE_23__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {
            const { data } = annotation;
            const targetId = this.getTargetId(viewport);
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
                annotationUID: annotation.annotationUID,
            };
            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
            if (!options.visibility) {
                return;
            }
            const textLines = this.configuration.getTextLines(data, targetId);
            if (!textLines || textLines.length === 0) {
                return;
            }
            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));
            if (!data.handles.textBox.hasMoved) {
                const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_17__.getTextBoxCoordsCanvas)(canvasCoordinates);
                data.handles.textBox.worldPosition =
                    viewport.canvasToWorld(canvasTextBoxCoords);
            }
            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
            const textBoxUID = '1';
            const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_16__.drawLinkedTextBox)(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
            const { x: left, y: top, width, height } = boundingBox;
            data.handles.textBox.worldBoundingBox = {
                topLeft: viewport.canvasToWorld([left, top]),
                topRight: viewport.canvasToWorld([left + width, top]),
                bottomLeft: viewport.canvasToWorld([left, top + height]),
                bottomRight: viewport.canvasToWorld([left + width, top + height]),
            };
        };
        (0,_planarFreehandROITool_drawLoop__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_editLoopCommon__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_closedContourEditLoop__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_openContourEditLoop__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_openContourEndEditLoop__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(this);
        (0,_planarFreehandROITool_renderMethods__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(this);
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations || !annotations.length) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        let annotationsToDisplay;
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
            const camera = viewport.getCamera();
            const { spacingInNormalDirection } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getTargetVolumeAndSpacingInNormalDir(viewport, camera);
            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);
        }
        else {
            annotationsToDisplay = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_5__.filterAnnotationsForDisplay)(viewport, annotations);
        }
        return annotationsToDisplay;
    }
    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {
        const { viewPlaneNormal } = camera;
        const annotationsWithParallelNormals = annotations.filter((td) => {
            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;
            if (!td.metadata.referencedImageId &&
                !annotationViewPlaneNormal &&
                td.metadata.FrameOfReferenceUID) {
                for (const point of td.data.contour.polyline) {
                    const vector = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create(), point, camera.focalPoint);
                    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.dot */ .eR.dot(vector, camera.viewPlaneNormal);
                    if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(dotProduct, 0)) {
                        return false;
                    }
                }
                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;
                td.metadata.cameraFocalPoint = camera.focalPoint;
                return true;
            }
            if (!annotationViewPlaneNormal) {
                const { referencedImageId } = td.metadata;
                const { imageOrientationPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.metaData.get('imagePlaneModule', referencedImageId);
                const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);
                const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.fromValues */ .eR.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);
                annotationViewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.cross */ .eR.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);
                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;
            }
            const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.dot */ .eR.dot(viewPlaneNormal, annotationViewPlaneNormal)) >
                PARALLEL_THRESHOLD;
            return annotationViewPlaneNormal && isParallel;
        });
        if (!annotationsWithParallelNormals.length) {
            return [];
        }
        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;
        const { focalPoint } = camera;
        const annotationsWithinSlice = [];
        for (const annotation of annotationsWithParallelNormals) {
            const data = annotation.data;
            const point = data.contour.polyline[0];
            if (!annotation.isVisible) {
                continue;
            }
            const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
            gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.sub */ .eR.sub(dir, focalPoint, point);
            const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.dot */ .eR.dot(dir, viewPlaneNormal);
            if (Math.abs(dot) < halfSpacingInNormalDirection) {
                annotationsWithinSlice.push(annotation);
            }
        }
        return annotationsWithinSlice;
    }
    isContourSegmentationTool() {
        return false;
    }
    createAnnotation(evt) {
        const worldPos = evt.detail.currentPoints.world;
        const contourAnnotation = super.createAnnotation(evt);
        const onInterpolationComplete = (annotation) => {
            annotation.data.handles.points.length = 0;
        };
        const annotation = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.deepMerge(contourAnnotation, {
            data: {
                contour: {
                    polyline: [[...worldPos]],
                },
                label: '',
                cachedStats: {},
            },
            onInterpolationComplete,
        });
        return annotation;
    }
    getAnnotationStyle(context) {
        return super.getAnnotationStyle(context);
    }
    renderAnnotationInstance(renderContext) {
        const { enabledElement, targetId, svgDrawingHelper } = renderContext;
        const annotation = renderContext.annotation;
        let renderStatus = false;
        const { viewport, renderingEngine } = enabledElement;
        const isDrawing = this.isDrawing;
        const isEditingOpen = this.isEditingOpen;
        const isEditingClosed = this.isEditingClosed;
        if (!(isDrawing || isEditingOpen || isEditingClosed)) {
            if (this.configuration.displayOnePointAsCrosshairs &&
                annotation.data.contour.polyline.length === 1) {
                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
            }
            else {
                this.renderContour(enabledElement, svgDrawingHelper, annotation);
            }
        }
        else {
            const activeAnnotationUID = this.commonData.annotation.annotationUID;
            if (annotation.annotationUID === activeAnnotationUID) {
                if (isDrawing) {
                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingClosed) {
                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else if (isEditingOpen) {
                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                }
            }
            else {
                if (this.configuration.displayOnePointAsCrosshairs &&
                    annotation.data.contour.polyline.length === 1) {
                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);
                }
                else {
                    this.renderContour(enabledElement, svgDrawingHelper, annotation);
                }
            }
            renderStatus = true;
        }
        if (!this.configuration.calculateStats) {
            return;
        }
        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);
        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);
        return renderStatus;
    }
    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {
        const activeAnnotationUID = this.commonData?.annotation.annotationUID;
        if (annotation.annotationUID === activeAnnotationUID &&
            !this.commonData?.movingTextBox) {
            return;
        }
        if (!this.commonData?.movingTextBox) {
            const { data } = annotation;
            if (!data.cachedStats[targetId]?.unit) {
                data.cachedStats[targetId] = {
                    Modality: null,
                    area: null,
                    max: null,
                    mean: null,
                    stdDev: null,
                    areaUnit: null,
                    unit: null,
                };
                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
            else if (annotation.invalidated) {
                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);
            }
        }
    }
    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, deltaInX, deltaInY, }) {
        const { scale, areaUnit, unit } = calibratedScale;
        const { voxelManager } = viewport.getImageData();
        const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, points[0]);
        worldPosIndex[0] = Math.floor(worldPosIndex[0]);
        worldPosIndex[1] = Math.floor(worldPosIndex[1]);
        worldPosIndex[2] = Math.floor(worldPosIndex[2]);
        let iMin = worldPosIndex[0];
        let iMax = worldPosIndex[0];
        let jMin = worldPosIndex[1];
        let jMax = worldPosIndex[1];
        let kMin = worldPosIndex[2];
        let kMax = worldPosIndex[2];
        for (let j = 1; j < points.length; j++) {
            const worldPosIndex = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, points[j]);
            worldPosIndex[0] = Math.floor(worldPosIndex[0]);
            worldPosIndex[1] = Math.floor(worldPosIndex[1]);
            worldPosIndex[2] = Math.floor(worldPosIndex[2]);
            iMin = Math.min(iMin, worldPosIndex[0]);
            iMax = Math.max(iMax, worldPosIndex[0]);
            jMin = Math.min(jMin, worldPosIndex[1]);
            jMax = Math.max(jMax, worldPosIndex[1]);
            kMin = Math.min(kMin, worldPosIndex[2]);
            kMax = Math.max(kMax, worldPosIndex[2]);
        }
        const worldPosIndex2 = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.transformWorldToIndex(imageData, points[1]);
        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);
        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);
        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);
        let area = _utilities_math__WEBPACK_IMPORTED_MODULE_4__.polyline.getArea(canvasCoordinates) / scale / scale;
        area *= deltaInX * deltaInY;
        let perimeter = (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .A)(canvasCoordinates, closed) / scale;
        perimeter *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));
        const iDelta = 0.01 * (iMax - iMin);
        const jDelta = 0.01 * (jMax - jMin);
        const kDelta = 0.01 * (kMax - kMin);
        iMin = Math.floor(iMin - iDelta);
        iMax = Math.ceil(iMax + iDelta);
        jMin = Math.floor(jMin - jDelta);
        jMax = Math.ceil(jMax + jDelta);
        kMin = Math.floor(kMin - kDelta);
        kMax = Math.ceil(kMax + kDelta);
        const boundsIJK = [
            [iMin, iMax],
            [jMin, jMax],
            [kMin, kMax],
        ];
        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);
        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);
        let curRow = 0;
        let intersections = [];
        let intersectionCounter = 0;
        let pointsInShape;
        if (voxelManager) {
            pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                imageData,
                isInObject: (pointLPS, _pointIJK) => {
                    let result = true;
                    const point = viewport.worldToCanvas(pointLPS);
                    if (point[1] != curRow) {
                        intersectionCounter = 0;
                        curRow = point[1];
                        intersections = (0,_utilities_math_polyline__WEBPACK_IMPORTED_MODULE_18__.getLineSegmentIntersectionsCoordinates)(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);
                        intersections.sort((function (index) {
                            return function (a, b) {
                                return a[index] === b[index]
                                    ? 0
                                    : a[index] < b[index]
                                        ? -1
                                        : 1;
                            };
                        })(0));
                    }
                    if (intersections.length && point[0] > intersections[0][0]) {
                        intersections.shift();
                        intersectionCounter++;
                    }
                    if (intersectionCounter % 2 === 0) {
                        result = false;
                    }
                    return result;
                },
                boundsIJK,
                returnPoints: this.configuration.storePointData,
            });
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            area,
            perimeter,
            mean: stats.mean?.value,
            max: stats.max?.value,
            min: stats.min?.value,
            stdDev: stats.stdDev?.value,
            statsArray: stats.array,
            pointsInShape: pointsInShape,
            areaUnit,
            modalityUnit,
            unit,
        };
    }
    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, deltaInX, deltaInY, }) {
        const { scale, unit } = calibratedScale;
        let length = (0,_utilities_contours_calculatePerimeter__WEBPACK_IMPORTED_MODULE_21__/* ["default"] */ .A)(canvasCoordinates, closed) / scale;
        length *= Math.sqrt(Math.pow(deltaInX, 2) + Math.pow(deltaInY, 2));
        cachedStats[targetId] = {
            Modality: metadata.Modality,
            length,
            modalityUnit,
            unit,
        };
    }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, stdDev, length, perimeter, max, min, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};
    const textLines = [];
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(area)) {
        const areaLine = isEmptyArea
            ? `Area: Oblique not supported`
            : `Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`;
        textLines.push(areaLine);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(mean)) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(max)) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(min)) {
        textLines.push(`Min: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(min)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(stdDev)) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(perimeter)) {
        textLines.push(`Perimeter: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(perimeter)} ${unit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(length)) {
        textLines.push(`${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(length)} ${unit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlanarFreehandROITool);


/***/ }),

/***/ 4010:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85817);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4096);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27730);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2076);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44049);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(74347);
/* harmony import */ var _store_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(85204);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99737);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(60810);
/* harmony import */ var _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(33657);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(473);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35489);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(58640);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(40634);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(73262);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(76712);





















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
class RectangleROITool extends _base__WEBPACK_IMPORTED_MODULE_0__/* .AnnotationTool */ .EC {
    static { this.toolName = 'RectangleROI'; }
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            storePointData: false,
            shadow: true,
            preventHandleOutsideImage: false,
            calculateStats: true,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_19__.BasicStatsCalculator,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.isDrawing = true;
            const annotation = (this.constructor).createAnnotationForViewport(viewport, {
                data: {
                    handles: {
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                    },
                    cachedStats: {},
                },
            });
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                movingTextBox: false,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            const { data } = annotation;
            const { points } = data.handles;
            const canvasPoint1 = viewport.worldToCanvas(points[0]);
            const canvasPoint2 = viewport.worldToCanvas(points[3]);
            const rect = this._getRectangleImageCoordinates([
                canvasPoint1,
                canvasPoint2,
            ]);
            const point = [canvasCoords[0], canvasCoords[1]];
            const { left, top, width, height } = rect;
            const distanceToPoint = _utilities_math_rectangle__WEBPACK_IMPORTED_MODULE_12__.distanceToPoint([left, top, width, height], point);
            if (distanceToPoint <= proximity) {
                return true;
            }
            return false;
        };
        this.toolSelectedCallback = (evt, annotation) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            annotation.highlighted = true;
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                movingTextBox: false,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this.handleSelectedCallback = (evt, annotation, handle) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { data } = annotation;
            annotation.highlighted = true;
            let movingTextBox = false;
            let handleIndex;
            if (handle.worldPosition) {
                movingTextBox = true;
            }
            else {
                handleIndex = data.handles.points.findIndex((p) => p === handle);
            }
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_11__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex,
                movingTextBox,
            };
            this._activateModify(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.hideElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            const { renderingEngine } = enabledElement;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            evt.preventDefault();
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
            this.doneEditMemo();
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
            }
        };
        this._dragCallback = (evt) => {
            this.isDrawing = true;
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;
            this.createMemo(element, annotation, { newAnnotation });
            const { data } = annotation;
            if (movingTextBox) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { textBox } = data.handles;
                const { worldPosition } = textBox;
                worldPosition[0] += worldPosDelta[0];
                worldPosition[1] += worldPosDelta[1];
                worldPosition[2] += worldPosDelta[2];
                textBox.hasMoved = true;
            }
            else if (handleIndex === undefined) {
                const { deltaPoints } = eventDetail;
                const worldPosDelta = deltaPoints.world;
                const { points } = data.handles;
                points.forEach((point) => {
                    point[0] += worldPosDelta[0];
                    point[1] += worldPosDelta[1];
                    point[2] += worldPosDelta[2];
                });
                annotation.invalidated = true;
            }
            else {
                const { currentPoints } = eventDetail;
                const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;
                const worldPos = currentPoints.world;
                const { points } = data.handles;
                points[handleIndex] = [...worldPos];
                let bottomLeftCanvas;
                let bottomRightCanvas;
                let topLeftCanvas;
                let topRightCanvas;
                let bottomLeftWorld;
                let bottomRightWorld;
                let topLeftWorld;
                let topRightWorld;
                switch (handleIndex) {
                    case 0:
                    case 3:
                        bottomLeftCanvas = worldToCanvas(points[0]);
                        topRightCanvas = worldToCanvas(points[3]);
                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];
                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];
                        bottomRightWorld = canvasToWorld(bottomRightCanvas);
                        topLeftWorld = canvasToWorld(topLeftCanvas);
                        points[1] = bottomRightWorld;
                        points[2] = topLeftWorld;
                        break;
                    case 1:
                    case 2:
                        bottomRightCanvas = worldToCanvas(points[1]);
                        topLeftCanvas = worldToCanvas(points[2]);
                        bottomLeftCanvas = [
                            topLeftCanvas[0],
                            bottomRightCanvas[1],
                        ];
                        topRightCanvas = [
                            bottomRightCanvas[0],
                            topLeftCanvas[1],
                        ];
                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);
                        topRightWorld = canvasToWorld(topRightCanvas);
                        points[0] = bottomLeftWorld;
                        points[3] = topRightWorld;
                        break;
                }
                annotation.invalidated = true;
            }
            this.editData.hasMoved = true;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElement)(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
            if (annotation.invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.HandlesUpdated);
            }
        };
        this.cancel = (element) => {
            if (this.isDrawing) {
                this.isDrawing = false;
                this._deactivateDraw(element);
                this._deactivateModify(element);
                (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_15__.resetElementCursor)(element);
                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;
                const { data } = annotation;
                annotation.highlighted = false;
                data.handles.activeHandleIndex = null;
                (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(viewportIdsToRender);
                if (newAnnotation) {
                    (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationCompleted)(annotation);
                }
                this.editData = null;
                return annotation.annotationUID;
            }
        };
        this._activateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_MOVE, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._activateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = true;
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this._deactivateModify = (element) => {
            _store_state__WEBPACK_IMPORTED_MODULE_9__/* .state */ .wk.isInteractingWithTool = false;
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.MOUSE_CLICK, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_END, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_10__.Events.TOUCH_TAP, this._endCallback);
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const targetId = this.getTargetId(viewport);
            const renderingEngine = viewport.getRenderingEngine();
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const { color, lineWidth, lineDash } = this.getAnnotationStyle({
                    annotation,
                    styleSpecifier,
                });
                const { viewPlaneNormal, viewUp } = viewport.getCamera();
                if (!data.cachedStats[targetId] ||
                    data.cachedStats[targetId].areaUnit == null) {
                    data.cachedStats[targetId] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                    };
                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                }
                else if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);
                    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.VolumeViewport) {
                        const { referencedImageId } = annotation.metadata;
                        for (const targetId in data.cachedStats) {
                            if (targetId.startsWith('imageId')) {
                                const viewports = renderingEngine.getStackViewports();
                                const invalidatedStack = viewports.find((vp) => {
                                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(referencedImageId);
                                    const hasImageURI = vp.hasImageURI(referencedImageURI);
                                    const currentImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.imageIdToURI(vp.getCurrentImageId());
                                    return hasImageURI && currentImageURI !== referencedImageURI;
                                });
                                if (invalidatedStack) {
                                    delete data.cachedStats[targetId];
                                }
                            }
                        }
                    }
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_6__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_5__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    activeHandleIndex !== undefined) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                const showHandlesAlways = Boolean((0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_20__/* .getStyleProperty */ .h)('showHandlesAlways', {}));
                if (activeHandleCanvasCoords || showHandlesAlways) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {
                        color,
                    });
                }
                const dataId = `${annotationUID}-rect`;
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawRectByCoordinates)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {
                    color,
                    lineDash,
                    lineWidth,
                }, dataId);
                renderStatus = true;
                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                if (!options.visibility) {
                    data.handles.textBox = {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    };
                    continue;
                }
                const textLines = this.configuration.getTextLines(data, targetId);
                if (!textLines || textLines.length === 0) {
                    continue;
                }
                if (!data.handles.textBox.hasMoved) {
                    const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_13__.getTextBoxCoordsCanvas)(canvasCoordinates);
                    data.handles.textBox.worldPosition =
                        viewport.canvasToWorld(canvasTextBoxCoords);
                }
                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                const textBoxUID = '1';
                const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_8__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                const { x: left, y: top, width, height } = boundingBox;
                data.handles.textBox.worldBoundingBox = {
                    topLeft: viewport.canvasToWorld([left, top]),
                    topRight: viewport.canvasToWorld([left + width, top]),
                    bottomLeft: viewport.canvasToWorld([left, top + height]),
                    bottomRight: viewport.canvasToWorld([left + width, top + height]),
                };
            }
            return renderStatus;
        };
        this._getRectangleImageCoordinates = (points) => {
            const [point0, point1] = points;
            return {
                left: Math.min(point0[0], point1[0]),
                top: Math.min(point0[1], point1[1]),
                width: Math.abs(point0[0] - point1[0]),
                height: Math.abs(point0[1] - point1[1]),
            };
        };
        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {
            if (!this.configuration.calculateStats) {
                return;
            }
            const { data } = annotation;
            const { viewport } = enabledElement;
            const { element } = viewport;
            const worldPos1 = data.handles.points[0];
            const worldPos2 = data.handles.points[3];
            const { cachedStats } = data;
            const targetIds = Object.keys(cachedStats);
            for (let i = 0; i < targetIds.length; i++) {
                const targetId = targetIds[i];
                const image = this.getTargetImageData(targetId);
                if (!image) {
                    continue;
                }
                const { dimensions, imageData, metadata, voxelManager } = image;
                const pos1Index = transformWorldToIndex(imageData, worldPos1);
                pos1Index[0] = Math.floor(pos1Index[0]);
                pos1Index[1] = Math.floor(pos1Index[1]);
                pos1Index[2] = Math.floor(pos1Index[2]);
                const pos2Index = transformWorldToIndex(imageData, worldPos2);
                pos2Index[0] = Math.floor(pos2Index[0]);
                pos2Index[1] = Math.floor(pos2Index[1]);
                pos2Index[2] = Math.floor(pos2Index[2]);
                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {
                    this.isHandleOutsideImage = false;
                    const iMin = Math.min(pos1Index[0], pos2Index[0]);
                    const iMax = Math.max(pos1Index[0], pos2Index[0]);
                    const jMin = Math.min(pos1Index[1], pos2Index[1]);
                    const jMax = Math.max(pos1Index[1], pos2Index[1]);
                    const kMin = Math.min(pos1Index[2], pos2Index[2]);
                    const kMax = Math.max(pos1Index[2], pos2Index[2]);
                    const boundsIJK = [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ];
                    const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
                    const handles = [pos1Index, pos2Index];
                    const { scale, areaUnit } = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_2__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, handles);
                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);
                    const pixelUnitsOptions = {
                        isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_18__/* .isViewportPreScaled */ .u)(viewport, targetId),
                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
                    };
                    const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_17__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);
                    let pointsInShape;
                    if (voxelManager) {
                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                            boundsIJK,
                            imageData,
                            returnPoints: this.configuration.storePointData,
                        });
                    }
                    const stats = this.configuration.statsCalculator.getStatistics();
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                        area,
                        mean: stats.mean?.value,
                        stdDev: stats.stdDev?.value,
                        max: stats.max?.value,
                        min: stats.min?.value,
                        statsArray: stats.array,
                        pointsInShape: pointsInShape,
                        areaUnit,
                        modalityUnit,
                    };
                }
                else {
                    this.isHandleOutsideImage = true;
                    cachedStats[targetId] = {
                        Modality: metadata.Modality,
                    };
                }
            }
            const invalidated = annotation.invalidated;
            annotation.invalidated = false;
            if (invalidated) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_7__.triggerAnnotationModified)(annotation, element, _enums__WEBPACK_IMPORTED_MODULE_10__.ChangeTypes.StatsUpdated);
            }
            return cachedStats;
        };
        this._isInsideVolume = (index1, index2, dimensions) => {
            return (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index1, dimensions) &&
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.indexWithinDimensions(index2, dimensions));
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this._calculateCachedStats, 100, { trailing: true });
    }
    static { this.hydrate = (viewportId, points, options) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            return;
        }
        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);
        const { toolInstance, ...serializableOptions } = options || {};
        const annotation = {
            annotationUID: options?.annotationUID || _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.uuidv4(),
            data: {
                handles: {
                    points,
                    activeHandleIndex: null,
                },
                label: '',
                cachedStats: {},
            },
            highlighted: false,
            autoGenerated: false,
            invalidated: false,
            isLocked: false,
            isVisible: true,
            metadata: {
                toolName: instance.getToolName(),
                viewPlaneNormal,
                FrameOfReferenceUID,
                referencedImageId,
                ...serializableOptions,
            },
        };
        (0,_stateManagement__WEBPACK_IMPORTED_MODULE_4__/* .addAnnotation */ .lC)(annotation, viewport.element);
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)([viewport.id]);
    }; }
}
function defaultGetTextLines(data, targetId) {
    const cachedVolumeStats = data.cachedStats[targetId];
    const { area, mean, max, stdDev, areaUnit, modalityUnit, min } = cachedVolumeStats;
    if (mean === undefined || mean === null) {
        return;
    }
    const textLines = [];
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(area)) {
        textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(area)} ${areaUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(mean)) {
        textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(mean)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(max)) {
        textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(max)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(min)) {
        textLines.push(`Min: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(min)} ${modalityUnit}`);
    }
    if (_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isNumber(stdDev)) {
        textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    }
    return textLines;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RectangleROITool);


/***/ }),

/***/ 48736:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99737);
/* harmony import */ var _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17492);
/* harmony import */ var _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1989);
/* harmony import */ var _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56789);
/* harmony import */ var _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33852);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(74347);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(58640);
/* harmony import */ var _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(23631);
/* harmony import */ var _strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(40905);












class BrushTool extends _LabelmapBaseTool__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            strategies: {
                FILL_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .fillInsideCircle */ .kr,
                ERASE_INSIDE_CIRCLE: _strategies_eraseCircle__WEBPACK_IMPORTED_MODULE_6__/* .eraseInsideCircle */ .r,
                FILL_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .fillInsideSphere */ .Jq,
                ERASE_INSIDE_SPHERE: _strategies_eraseSphere__WEBPACK_IMPORTED_MODULE_4__/* .eraseInsideSphere */ ._,
                THRESHOLD_INSIDE_CIRCLE: _strategies_fillCircle__WEBPACK_IMPORTED_MODULE_5__/* .thresholdInsideCircle */ .q,
                THRESHOLD_INSIDE_SPHERE: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .thresholdInsideSphere */ .rd,
                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: _strategies_fillSphere__WEBPACK_IMPORTED_MODULE_3__/* .thresholdInsideSphereIsland */ .Sw,
            },
            defaultStrategy: 'FILL_INSIDE_CIRCLE',
            activeStrategy: 'FILL_INSIDE_CIRCLE',
            brushSize: 25,
            useCenterSegmentIndex: false,
            preview: {
                enabled: false,
                previewColors: {
                    0: [255, 255, 255, 128],
                },
                previewTimeMs: 250,
                previewMoveDistance: 8,
                dragMoveDistance: 4,
                dragTimeMs: 500,
            },
            actions: {
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.AcceptPreview,
                    bindings: [
                        {
                            key: 'Enter',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview,
                    bindings: [
                        {
                            key: 'Escape',
                        },
                    ],
                },
                [_enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate]: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'i',
                        },
                    ],
                    configuration: {
                        useBallStructuringElement: true,
                        noUseDistanceTransform: true,
                        noUseExtrapolation: true,
                    },
                },
                interpolateExtrapolation: {
                    method: _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate,
                    bindings: [
                        {
                            key: 'e',
                        },
                    ],
                    configuration: {},
                },
            },
        },
    }) {
        super(toolProps, defaultToolProps);
        this._lastDragInfo = null;
        this.onSetToolPassive = (evt) => {
            this.disableCursor();
        };
        this.onSetToolEnabled = () => {
            this.disableCursor();
        };
        this.onSetToolDisabled = (evt) => {
            this.disableCursor();
        };
        this.preMouseDownCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this._editData = this.createEditData(element);
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.hideElementCursor)(element);
            evt.preventDefault();
            this._previewData.isDrag = false;
            this._previewData.timerStart = Date.now();
            const canvasPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.clone */ .Zc.clone(currentPoints.canvas);
            const worldPoint = viewport.canvasToWorld([
                canvasPoint[0],
                canvasPoint[1],
            ]);
            this._lastDragInfo = {
                canvas: canvasPoint,
                world: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.clone */ .eR.clone(worldPoint),
            };
            const hoverData = this._hoverData || this.createHoverData(element);
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(hoverData.viewportIdsToRender);
            const operationData = this.getOperationData(element);
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionStart);
            return true;
        };
        this.mouseMoveCallback = (evt) => {
            if (this.mode === _enums__WEBPACK_IMPORTED_MODULE_2__.ToolModes.Active) {
                this.updateCursor(evt);
                if (!this.configuration.preview.enabled) {
                    return;
                }
                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;
                const { currentPoints, element } = evt.detail;
                const { canvas } = currentPoints;
                const { startPoint, timer, timerStart, isDrag } = this._previewData;
                if (isDrag) {
                    return;
                }
                const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(canvas, startPoint);
                const time = Date.now() - timerStart;
                if (delta > previewMoveDistance ||
                    (time > previewTimeMs && delta > dragMoveDistance)) {
                    if (timer) {
                        window.clearTimeout(timer);
                        this._previewData.timer = null;
                    }
                    if (!isDrag) {
                        this.rejectPreview(element);
                    }
                }
                if (!this._previewData.timer) {
                    const timer = window.setTimeout(this.previewCallback, 250);
                    Object.assign(this._previewData, {
                        timerStart: Date.now(),
                        timer,
                        startPoint: canvas,
                        element,
                    });
                }
            }
        };
        this.previewCallback = () => {
            if (this._previewData.isDrag) {
                this._previewData.timer = null;
                return;
            }
            this._previewData.timer = null;
            const operationData = this.getOperationData(this._previewData.element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            const activeStrategy = this.configuration.activeStrategy;
            const strategyData = (0,_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_11__/* .getStrategyData */ .S)({
                operationData,
                viewport,
                strategy: activeStrategy,
            });
            if (!operationData) {
                return;
            }
            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);
            this._previewData.preview = this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(this._previewData.element), {
                ...operationData,
                ...strategyData,
                memo,
            }, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Preview);
        };
        this._dragCallback = (evt) => {
            const eventData = evt.detail;
            const { element, currentPoints } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport } = enabledElement;
            this.updateCursor(evt);
            const { viewportIdsToRender } = this._hoverData;
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewportIdsToRender);
            const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.distance */ .Zc.distance(currentPoints.canvas, this._previewData.startPoint);
            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;
            if (!this._previewData.isDrag &&
                Date.now() - this._previewData.timerStart < dragTimeMs &&
                delta < dragMoveDistance) {
                return;
            }
            if (this._previewData.timer) {
                window.clearTimeout(this._previewData.timer);
                this._previewData.timer = null;
            }
            if (!this._lastDragInfo) {
                const startCanvas = this._previewData.startPoint;
                const startWorld = viewport.canvasToWorld([
                    startCanvas[0],
                    startCanvas[1],
                ]);
                this._lastDragInfo = {
                    canvas: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.clone */ .Zc.clone(startCanvas),
                    world: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.clone */ .eR.clone(startWorld),
                };
            }
            const currentCanvas = currentPoints.canvas;
            const currentWorld = viewport.canvasToWorld([
                currentCanvas[0],
                currentCanvas[1],
            ]);
            this._hoverData = this.createHoverData(element, currentCanvas);
            this._calculateCursor(element, currentCanvas);
            const operationData = this.getOperationData(element);
            operationData.strokePointsWorld = [
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.clone */ .eR.clone(this._lastDragInfo.world),
                gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.clone */ .eR.clone(currentWorld),
            ];
            this._previewData.preview = this.applyActiveStrategy(enabledElement, operationData);
            const currentCanvasClone = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec2.clone */ .Zc.clone(currentCanvas);
            this._lastDragInfo = {
                canvas: currentCanvasClone,
                world: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.clone */ .eR.clone(currentWorld),
            };
            this._previewData.element = element;
            this._previewData.timerStart = Date.now() + dragTimeMs;
            this._previewData.isDrag = true;
            this._previewData.startPoint = currentCanvasClone;
        };
        this._endCallback = (evt) => {
            const eventData = evt.detail;
            const { element } = eventData;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const operationData = this.getOperationData(element);
            if (!this._previewData.preview && !this._previewData.isDrag) {
                this.applyActiveStrategy(enabledElement, operationData);
            }
            this.doneEditMemo();
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_8__.resetElementCursor)(element);
            this.updateCursor(evt);
            this._editData = null;
            this._lastDragInfo = null;
            this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.OnInteractionEnd);
            if (!this._previewData.isDrag) {
                this.acceptPreview(element);
            }
        };
        this._activateDraw = (element) => {
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
        this._deactivateDraw = (element) => {
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_UP, this._endCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_DRAG, this._dragCallback);
            element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_2__.Events.MOUSE_CLICK, this._endCallback);
        };
    }
    disableCursor() {
        this._hoverData = undefined;
        this.rejectPreview();
    }
    updateCursor(evt) {
        const eventData = evt.detail;
        const { element } = eventData;
        const { currentPoints } = eventData;
        const centerCanvas = currentPoints.canvas;
        this._hoverData = this.createHoverData(element, centerCanvas);
        this._calculateCursor(element, centerCanvas);
        if (!this._hoverData) {
            return;
        }
        (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this._hoverData.viewportIdsToRender);
    }
    _calculateCursor(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const { canvasToWorld } = viewport;
        const camera = viewport.getCamera();
        const { brushSize } = this.configuration;
        const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
        const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
        const centerCursorInWorld = canvasToWorld([
            centerCanvas[0],
            centerCanvas[1],
        ]);
        const bottomCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const topCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const leftCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        const rightCursorInWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
        for (let i = 0; i <= 2; i++) {
            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;
            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;
            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;
            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;
        }
        if (!this._hoverData) {
            return;
        }
        const { brushCursor } = this._hoverData;
        const { data } = brushCursor;
        if (data.handles === undefined) {
            data.handles = {};
        }
        data.handles.points = [
            bottomCursorInWorld,
            topCursorInWorld,
            leftCursorInWorld,
            rightCursorInWorld,
        ];
        const activeStrategy = this.configuration.activeStrategy;
        const strategy = this.configuration.strategies[activeStrategy];
        if (typeof strategy?.computeInnerCircleRadius === 'function') {
            strategy.computeInnerCircleRadius({
                configuration: this.configuration,
                viewport,
            });
        }
        data.invalidated = false;
    }
    getStatistics(element, segmentIndices) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.GetStatistics, segmentIndices);
        return stats;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        this.doneEditMemo();
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        super.acceptPreview(element);
    }
    interpolate(element, config) {
        if (!element) {
            return;
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_2__.StrategyCallbacks.Interpolate, config.configuration);
        this._previewData.isDrag = true;
    }
    invalidateBrushCursor() {
        if (this._hoverData === undefined) {
            return;
        }
        const { data } = this._hoverData.brushCursor;
        const { viewport } = this._hoverData;
        data.invalidated = true;
        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};
        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;
    }
    renderAnnotation(enabledElement, svgDrawingHelper) {
        if (!this._hoverData) {
            return;
        }
        const { viewport } = enabledElement;
        const viewportIdsToRender = this._hoverData.viewportIdsToRender;
        if (!viewportIdsToRender.includes(viewport.id)) {
            return;
        }
        const brushCursor = this._hoverData.brushCursor;
        if (brushCursor.data.invalidated === true) {
            const { centerCanvas } = this._hoverData;
            const { element } = viewport;
            this._calculateCursor(element, centerCanvas);
        }
        const toolMetadata = brushCursor.metadata;
        if (!toolMetadata) {
            return;
        }
        const annotationUID = toolMetadata.brushCursorUID;
        const data = brushCursor.data;
        const { points } = data.handles;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const bottom = canvasCoordinates[0];
        const top = canvasCoordinates[1];
        const center = [
            Math.floor((bottom[0] + top[0]) / 2),
            Math.floor((bottom[1] + top[1]) / 2),
        ];
        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));
        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;
        if (!viewport.getRenderingEngine()) {
            console.warn('Rendering Engine has been destroyed');
            return;
        }
        const circleUID = '0';
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID, center, radius, {
            color,
            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,
        });
        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {
            dynamicRadiusInCanvas: 0,
        };
        if (dynamicRadiusInCanvas) {
            const circleUID1 = '1';
            (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_7__.drawCircle)(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {
                color,
            });
        }
    }
}
BrushTool.toolName = 'Brush';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BrushTool);


/***/ }),

/***/ 23631:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ LabelmapBaseTool)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85817);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18682);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67165);
/* harmony import */ var _stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26795);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97577);
/* harmony import */ var _stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(93733);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60740);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(99737);
/* harmony import */ var _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(2397);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(82056);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(13165);
/* harmony import */ var _utilities_math_polyline__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(92984);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(49906);
/* harmony import */ var _strategies__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(99522);
















class LabelmapBaseTool extends _base__WEBPACK_IMPORTED_MODULE_1__/* .BaseTool */ .oS {
    static { this.previewData = {
        preview: null,
        element: null,
        timerStart: 0,
        timer: null,
        startPoint: [NaN, NaN],
        isDrag: false,
    }; }
    constructor(toolProps, defaultToolProps) {
        super(toolProps, defaultToolProps);
        this.memoMap = new Map();
        this.acceptedMemoIds = new Map();
        this.centerSegmentIndexInfo = {
            segmentIndex: null,
            hasSegmentIndex: false,
            hasPreviewIndex: false,
            changedIndices: [],
        };
    }
    _historyRedoHandler(evt) {
        const { id, operationType } = evt.detail;
        if (operationType !== 'labelmap') {
            return;
        }
        if (this.acceptedMemoIds.has(id)) {
            this._hoverData = null;
            const memoData = this.acceptedMemoIds.get(id);
            const element = memoData?.element;
            const operationData = this.getOperationData(element);
            operationData.segmentIndex = memoData?.segmentIndex;
            if (element) {
                this.applyActiveStrategyCallback((0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element), operationData, _enums__WEBPACK_IMPORTED_MODULE_9__.StrategyCallbacks.AcceptPreview);
            }
        }
        this._previewData.isDrag = true;
    }
    get _previewData() {
        return LabelmapBaseTool.previewData;
    }
    hasPreviewData() {
        return !!this._previewData.preview;
    }
    shouldResolvePreviewRequests() {
        return ((this.mode === 'Active' || this.mode === 'Enabled') &&
            this.hasPreviewData());
    }
    createMemo(segmentationId, segmentationVoxelManager) {
        const voxelManagerId = segmentationVoxelManager.id;
        if (this.memo &&
            this.memo.segmentationVoxelManager === segmentationVoxelManager) {
            return this.memo;
        }
        let memo = this.memoMap.get(voxelManagerId);
        if (!memo) {
            memo = _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_10__.createLabelmapMemo(segmentationId, segmentationVoxelManager);
            this.memoMap.set(voxelManagerId, memo);
        }
        else {
            if (memo.redoVoxelManager) {
                memo = _utilities_segmentation_createLabelmapMemo__WEBPACK_IMPORTED_MODULE_10__.createLabelmapMemo(segmentationId, segmentationVoxelManager);
                this.memoMap.set(voxelManagerId, memo);
            }
        }
        this.memo = memo;
        return memo;
    }
    createEditData(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const activeSegmentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getActiveSegmentation */ .T)(viewport.id);
        if (!activeSegmentation) {
            const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                detail: {
                    type: 'Segmentation',
                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',
                },
                cancelable: true,
            });
            _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
            return null;
        }
        const { segmentationId } = activeSegmentation;
        const segmentsLocked = (0,_stateManagement_segmentation_segmentLocking__WEBPACK_IMPORTED_MODULE_4__.getLockedSegmentIndices)(segmentationId);
        const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_5__/* .getSegmentation */ .T)(segmentationId);
        const editData = this.getEditData({
            viewport,
            representationData,
            segmentsLocked,
            segmentationId,
        });
        return editData;
    }
    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const { volumeId } = representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.Labelmap];
            const actors = viewport.getActors();
            const isStackViewport = viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport;
            if (isStackViewport) {
                const event = new CustomEvent(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.ERROR_EVENT, {
                    detail: {
                        type: 'Segmentation',
                        message: 'Cannot perform brush operation on the selected viewport',
                    },
                    cancelable: true,
                });
                _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.dispatchEvent(event);
                return null;
            }
            const volumes = actors.map((actorEntry) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(actorEntry.referencedId));
            const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            const referencedVolumeIdToThreshold = volumes.find((volume) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;
            return {
                volumeId,
                referencedVolumeId: this.configuration.threshold?.volumeId ??
                    referencedVolumeIdToThreshold,
                segmentsLocked,
            };
        }
        else {
            const segmentationImageId = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_6__/* .getCurrentLabelmapImageIdForViewport */ .vl)(viewport.id, segmentationId);
            if (!segmentationImageId) {
                return;
            }
            return {
                imageId: segmentationImageId,
                segmentsLocked,
            };
        }
    }
    createHoverData(element, centerCanvas) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp } = camera;
        const viewportIdsToRender = [viewport.id];
        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};
        const brushCursor = {
            metadata: {
                viewPlaneNormal: [...viewPlaneNormal],
                viewUp: [...viewUp],
                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                referencedImageId: '',
                toolName: this.getToolName(),
                segmentColor,
            },
            data: {},
        };
        return {
            brushCursor,
            centerCanvas,
            segmentIndex,
            viewport,
            segmentationId,
            segmentColor,
            viewportIdsToRender,
        };
    }
    getActiveSegmentationData(viewport) {
        const viewportId = viewport.id;
        const activeRepresentation = (0,_stateManagement_segmentation_getActiveSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getActiveSegmentation */ .T)(viewportId);
        if (!activeRepresentation) {
            return;
        }
        const { segmentationId } = activeRepresentation;
        const segmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_8__/* .getActiveSegmentIndex */ .Q)(segmentationId);
        if (!segmentIndex) {
            return;
        }
        const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_7__.getSegmentIndexColor)(viewportId, segmentationId, segmentIndex);
        return {
            segmentIndex,
            segmentationId,
            segmentColor,
        };
    }
    getOperationData(element) {
        const editData = this._editData || this.createEditData(element);
        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);
        const { data, metadata = {} } = brushCursor || {};
        const { viewPlaneNormal, viewUp } = metadata;
        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];
        const { viewport } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const segmentColor = (0,_stateManagement_segmentation_config_segmentationColor__WEBPACK_IMPORTED_MODULE_7__.getSegmentIndexColor)(viewport.id, segmentationId, segmentIndex);
        if (!configColor && !segmentColor) {
            return;
        }
        let previewColor = null, previewSegmentIndex = null;
        if (this.configuration.preview?.enabled) {
            previewColor = configColor || lightenColor(...segmentColor);
            previewSegmentIndex = 255;
        }
        const operationData = {
            ...editData,
            points: data?.handles?.points,
            segmentIndex,
            viewPlaneNormal,
            previewOnHover: !this._previewData.isDrag,
            toolGroupId: this.toolGroupId,
            segmentationId,
            viewUp,
            centerSegmentIndexInfo: this.centerSegmentIndexInfo,
            activeStrategy: this.configuration.activeStrategy,
            configuration: this.configuration,
            previewColor,
            previewSegmentIndex,
            createMemo: this.createMemo.bind(this),
        };
        return operationData;
    }
    addPreview(element = this._previewData.element, options) {
        const { _previewData } = this;
        const acceptReject = options?.acceptReject;
        if (acceptReject === true) {
            this.acceptPreview(element);
        }
        else if (acceptReject === false) {
            this.rejectPreview(element);
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_9__.StrategyCallbacks.AddPreview);
        _previewData.isDrag = true;
        if (results?.modified) {
            _previewData.preview = results;
            _previewData.element = element;
        }
        return results;
    }
    rejectPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        this.doneEditMemo();
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), _enums__WEBPACK_IMPORTED_MODULE_9__.StrategyCallbacks.RejectPreview);
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    acceptPreview(element = this._previewData.element) {
        if (!element) {
            return;
        }
        const operationData = this.getOperationData(element);
        if (this.memo && this.memo.id) {
            this.acceptedMemoIds.set(this.memo.id, {
                element,
                segmentIndex: operationData.segmentIndex,
            });
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        this.applyActiveStrategyCallback(enabledElement, operationData, _enums__WEBPACK_IMPORTED_MODULE_9__.StrategyCallbacks.AcceptPreview);
        this.doneEditMemo();
        this._previewData.preview = null;
        this._previewData.isDrag = false;
    }
    static viewportContoursToLabelmap(viewport, options) {
        const removeContours = options?.removeContours ?? true;
        const annotations = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_11__.getAllAnnotations)();
        const viewAnnotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_12__.filterAnnotationsForDisplay)(viewport, annotations);
        if (!viewAnnotations?.length) {
            return;
        }
        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);
        if (!contourAnnotations.length) {
            return;
        }
        const brushInstance = new LabelmapBaseTool({}, {
            configuration: {
                strategies: {
                    FILL_INSIDE_CIRCLE: _strategies__WEBPACK_IMPORTED_MODULE_15__.fillInsideCircle,
                },
                activeStrategy: 'FILL_INSIDE_CIRCLE',
            },
        });
        const preview = brushInstance.addPreview(viewport.element);
        const { memo, segmentationId } = preview;
        const previewVoxels = memo?.voxelManager;
        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;
        const { dimensions } = previewVoxels;
        const imageData = viewport
            .getDefaultActor()
            .actor.getMapper()
            .getInputData();
        for (const annotation of contourAnnotations) {
            const boundsIJK = [
                [Infinity, -Infinity],
                [Infinity, -Infinity],
                [Infinity, -Infinity],
            ];
            const { polyline } = annotation.data.contour;
            for (const point of polyline) {
                const indexPoint = imageData.worldToIndex(point);
                indexPoint.forEach((v, idx) => {
                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);
                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);
                });
            }
            boundsIJK.forEach((bound, idx) => {
                bound[0] = Math.round(Math.max(0, bound[0]));
                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));
            });
            const activeIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_8__/* .getActiveSegmentIndex */ .Q)(segmentationId);
            const startPoint = annotation.data.handles?.[0] || polyline[0];
            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);
            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;
            let hasZeroIndex = false;
            let hasPositiveIndex = false;
            for (const polyPoint of polyline) {
                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);
                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);
                if (polyValue === startValue) {
                    hasZeroIndex = true;
                }
                else if (polyValue >= 0) {
                    hasPositiveIndex = true;
                }
            }
            const hasBoth = hasZeroIndex && hasPositiveIndex;
            const segmentIndex = hasBoth
                ? startValue
                : startValue === 0
                    ? activeIndex
                    : 0;
            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {
                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {
                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {
                        const worldPoint = imageData.indexToWorld([i, j, k]);
                        const isContained = (0,_utilities_math_polyline__WEBPACK_IMPORTED_MODULE_13__.isPointInsidePolyline3D)(worldPoint, polyline);
                        if (isContained) {
                            previewVoxels.setAtIJK(i, j, k, segmentIndex);
                        }
                    }
                }
            }
            if (removeContours) {
                (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_11__.removeAnnotation)(annotation.annotationUID);
            }
        }
        const slices = previewVoxels.getArrayOfModifiedSlices();
        (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__.triggerSegmentationDataModified)(segmentationId, slices);
    }
}
function lightenColor(r, g, b, a, factor = 0.4) {
    return [
        Math.round(r + (255 - r) * factor),
        Math.round(g + (255 - g) * factor),
        Math.round(b + (255 - b) * factor),
        a,
    ];
}


/***/ }),

/***/ 56789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C$: () => (/* binding */ getEllipseCornersFromCanvasCoordinates),
/* harmony export */   kr: () => (/* binding */ fillInsideCircle),
/* harmony export */   mu: () => (/* binding */ createPointInEllipse),
/* harmony export */   pB: () => (/* binding */ CIRCLE_STRATEGY),
/* harmony export */   q: () => (/* binding */ thresholdInsideCircle)
/* harmony export */ });
/* unused harmony exports fillOutsideCircle, CIRCLE_THRESHOLD_STRATEGY, createPointInEllipse */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72282);
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55887);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11990);
/* harmony import */ var _utilities_math_sphere__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62783);







const { transformWorldToIndex, transformIndexToWorld, isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {
    const [bottom, top, left, right] = canvasCoordinates;
    const topLeft = [left[0], top[1]];
    const bottomRight = [right[0], bottom[1]];
    const bottomLeft = [left[0], bottom[1]];
    const topRight = [right[0], top[1]];
    return [topLeft, bottomRight, bottomLeft, topRight];
}
function createCircleCornersForCenter(center, viewUp, viewRight, radius) {
    const centerVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(center[0], center[1], center[2]);
    const top = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(top, centerVec, viewUp, radius);
    const bottom = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottom, centerVec, viewUp, -radius);
    const right = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(right, centerVec, viewRight, radius);
    const left = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(left, centerVec, viewRight, -radius);
    return [
        bottom,
        top,
        left,
        right,
    ];
}
function createStrokePredicate(centers, radius) {
    if (!centers.length || radius <= 0) {
        return null;
    }
    const radiusSquared = radius * radius;
    const centerVecs = centers.map((point) => [point[0], point[1], point[2]]);
    const segments = [];
    for (let i = 1; i < centerVecs.length; i++) {
        const start = centerVecs[i - 1];
        const end = centerVecs[i];
        const dx = end[0] - start[0];
        const dy = end[1] - start[1];
        const dz = end[2] - start[2];
        const lengthSquared = dx * dx + dy * dy + dz * dz;
        segments.push({ start, vector: [dx, dy, dz], lengthSquared });
    }
    return (worldPoint) => {
        if (!worldPoint) {
            return false;
        }
        for (const centerVec of centerVecs) {
            const dx = worldPoint[0] - centerVec[0];
            const dy = worldPoint[1] - centerVec[1];
            const dz = worldPoint[2] - centerVec[2];
            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {
                return true;
            }
        }
        for (const { start, vector, lengthSquared } of segments) {
            if (lengthSquared === 0) {
                const dx = worldPoint[0] - start[0];
                const dy = worldPoint[1] - start[1];
                const dz = worldPoint[2] - start[2];
                if (dx * dx + dy * dy + dz * dz <= radiusSquared) {
                    return true;
                }
                continue;
            }
            const dx = worldPoint[0] - start[0];
            const dy = worldPoint[1] - start[1];
            const dz = worldPoint[2] - start[2];
            const dot = dx * vector[0] + dy * vector[1] + dz * vector[2];
            const t = Math.max(0, Math.min(1, dot / lengthSquared));
            const projX = start[0] + vector[0] * t;
            const projY = start[1] + vector[1] * t;
            const projZ = start[2] + vector[2] * t;
            const distX = worldPoint[0] - projX;
            const distY = worldPoint[1] - projY;
            const distZ = worldPoint[2] - projZ;
            if (distX * distX + distY * distY + distZ * distZ <= radiusSquared) {
                return true;
            }
        }
        return false;
    };
}
const initializeCircle = {
    [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData, viewUp, viewPlaneNormal, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        if (points.length >= 2) {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(center, points[0], points[1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(center, center, 0.5);
        }
        else {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.copy */ .eR.copy(center, points[0]);
        }
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const brushRadius = points.length >= 2 ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.distance */ .eR.distance(points[0], points[1]) / 2 : 0;
        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);
        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));
        const normalizedViewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(viewUp[0], viewUp[1], viewUp[2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normalizedViewUp, normalizedViewUp);
        const normalizedPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(viewPlaneNormal[0], viewPlaneNormal[1], viewPlaneNormal[2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normalizedPlaneNormal, normalizedPlaneNormal);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(viewRight, normalizedViewUp, normalizedPlaneNormal);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(viewRight, viewRight);
        const strokeCentersSource = operationData.strokePointsWorld &&
            operationData.strokePointsWorld.length > 0
            ? operationData.strokePointsWorld
            : [operationData.centerWorld];
        const strokeCenters = strokeCentersSource.map((point) => gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(point));
        const strokeCornersWorld = strokeCenters.flatMap((centerPoint) => createCircleCornersForCenter(centerPoint, normalizedViewUp, viewRight, brushRadius));
        const circleCornersIJK = strokeCornersWorld.map((world) => transformWorldToIndex(segmentationImageData, world));
        const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)(circleCornersIJK, segmentationImageData.getDimensions());
        operationData.strokePointsWorld = strokeCenters;
        operationData.isInObject = createPointInEllipse(cornersInWorld, {
            strokePointsWorld: strokeCenters,
            segmentationImageData,
            radius: brushRadius,
        });
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInEllipse(cornersInWorld = [], options = {}) {
    if (!cornersInWorld || cornersInWorld.length !== 4) {
        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');
    }
    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;
    const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(center, topLeft, bottomRight);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(center, center, 0.5);
    const majorAxisVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(majorAxisVec, topRight, topLeft);
    const xRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(majorAxisVec) / 2;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(majorAxisVec, majorAxisVec);
    const minorAxisVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(minorAxisVec, bottomLeft, topLeft);
    const yRadius = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(minorAxisVec) / 2;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(minorAxisVec, minorAxisVec);
    const normal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(normal, majorAxisVec, minorAxisVec);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normal, normal);
    const radiusForStroke = options.radius ?? Math.max(xRadius, yRadius);
    const strokePredicate = createStrokePredicate(options.strokePointsWorld || [], radiusForStroke);
    if (isEqual(xRadius, yRadius)) {
        const radius = xRadius;
        const sphereObj = {
            center,
            radius,
            radius2: radius * radius,
        };
        return (pointLPS, pointIJK) => {
            let worldPoint = pointLPS;
            if (!worldPoint && pointIJK && options.segmentationImageData) {
                worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);
            }
            if (!worldPoint) {
                return false;
            }
            if (strokePredicate?.(worldPoint)) {
                return true;
            }
            return (0,_utilities_math_sphere__WEBPACK_IMPORTED_MODULE_6__/* .pointInSphere */ .d)(sphereObj, worldPoint);
        };
    }
    return (pointLPS, pointIJK) => {
        let worldPoint = pointLPS;
        if (!worldPoint && pointIJK && options.segmentationImageData) {
            worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);
        }
        if (!worldPoint) {
            return false;
        }
        if (strokePredicate?.(worldPoint)) {
            return true;
        }
        const pointVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(pointVec, worldPoint, center);
        const distToPlane = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(pointVec, normal);
        const proj = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(proj, pointVec, normal, -distToPlane);
        const fromTopLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        const centerToTopLeft = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(centerToTopLeft, center, topLeft);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(fromTopLeft, proj, centerToTopLeft);
        const x = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(fromTopLeft, majorAxisVec);
        const y = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(fromTopLeft, minorAxisVec);
        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;
    };
}
const CIRCLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A('Circle', _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.labelmapStatistics);
const CIRCLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A('CircleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.setValue, initializeCircle, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.threshold, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.labelmapStatistics);
const fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;
const thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;
function fillOutsideCircle() {
    throw new Error('Not yet implemented');
}



/***/ }),

/***/ 10088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pY: () => (/* binding */ fillInsideRectangle)
/* harmony export */ });
/* unused harmony exports RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, thresholdInsideRectangle */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72282);
/* harmony import */ var _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55887);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _compositions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11990);






const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const initializeRectangle = {
    [_enums__WEBPACK_IMPORTED_MODULE_4__.StrategyCallbacks.Initialize]: (operationData) => {
        const { points, viewport, segmentationImageData, } = operationData;
        if (!points) {
            return;
        }
        const center = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(0, 0, 0);
        points.forEach((point) => {
            gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.add */ .eR.add(center, center, point);
        });
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scale */ .eR.scale(center, center, 1 / points.length);
        operationData.centerWorld = center;
        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);
        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);
        operationData.isInObject = pointInShapeFn;
        operationData.isInObjectBoundsIJK = boundsIJK;
    },
};
function createPointInRectangle(viewport, points, segmentationImageData) {
    let rectangleCornersIJK = points.map((world) => {
        return transformWorldToIndex(segmentationImageData, world);
    });
    rectangleCornersIJK = rectangleCornersIJK.map((point) => {
        return point.map((coord) => {
            return Math.round(coord);
        });
    });
    const boundsIJK = (0,_utilities_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)(rectangleCornersIJK, segmentationImageData.getDimensions());
    const [p0, p1, p2, p3] = points;
    const axisU = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    const axisV = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(axisU, p1, p0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(axisV, p3, p0);
    const uLen = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(axisU);
    const vLen = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(axisV);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(axisU, axisU);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(axisV, axisV);
    const normal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(normal, axisU, axisV);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(normal, normal);
    const direction = segmentationImageData.getDirection();
    const spacing = segmentationImageData.getSpacing();
    const { viewPlaneNormal } = viewport.getCamera();
    const EPS = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getSpacingInNormalDirection({
        direction,
        spacing,
    }, viewPlaneNormal);
    const pointInShapeFn = (pointLPS) => {
        const v = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(v, pointLPS, p0);
        const u = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(v, axisU);
        const vproj = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(v, axisV);
        const d = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(v, normal));
        return (u >= -EPS &&
            u <= uLen + EPS &&
            vproj >= -EPS &&
            vproj <= vLen + EPS &&
            d <= EPS);
    };
    return { boundsIJK, pointInShapeFn };
}
const RECTANGLE_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A('Rectangle', _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.labelmapStatistics);
const RECTANGLE_THRESHOLD_STRATEGY = new _BrushStrategy__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A('RectangleThreshold', _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.regionFill, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.setValue, initializeRectangle, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.determineSegmentIndex, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.dynamicThreshold, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.threshold, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.preview, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.islandRemoval, _compositions__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.labelmapStatistics);
const fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;
const thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;



/***/ }),

/***/ 99522:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillInsideCircle: () => (/* reexport safe */ _fillCircle__WEBPACK_IMPORTED_MODULE_1__.kr)
/* harmony export */ });
/* harmony import */ var _fillRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10088);
/* harmony import */ var _fillCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56789);





/***/ }),

/***/ 13369:
/***/ (() => {



/***/ }),

/***/ 64485:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ getClosestImageIdForStackViewport)
/* harmony export */ });
/* unused harmony export annotationHydration */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82056);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);



function annotationHydration(viewport, toolName, worldPoints, options) {
    const viewReference = viewport.getViewReference();
    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;
    const annotation = {
        annotationUID: options?.annotationUID || utilities.uuidv4(),
        data: {
            handles: {
                points: worldPoints,
            },
        },
        highlighted: false,
        autoGenerated: false,
        invalidated: false,
        isLocked: false,
        isVisible: true,
        metadata: {
            toolName,
            viewPlaneNormal,
            FrameOfReferenceUID,
            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),
            ...options,
        },
    };
    addAnnotation(annotation, viewport.element);
    return annotation;
}
function getReferencedImageId(viewport, worldPos, viewPlaneNormal) {
    let referencedImageId;
    if (viewport instanceof StackViewport) {
        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);
    }
    else if (viewport instanceof BaseVolumeViewport) {
        const targetId = getTargetId(viewport);
        const volumeId = utilities.getVolumeId(targetId);
        const imageVolume = cache.getVolume(volumeId);
        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    else {
        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');
    }
    return referencedImageId;
}
function getTargetId(viewport) {
    const targetId = viewport.getViewReferenceId?.();
    if (targetId) {
        return targetId;
    }
    if (viewport instanceof BaseVolumeViewport) {
        return `volumeId:${getTargetVolumeId(viewport)}`;
    }
    throw new Error('getTargetId: viewport must have a getTargetId method');
}
function getTargetVolumeId(viewport) {
    const actorEntries = viewport.getActors();
    if (!actorEntries) {
        return;
    }
    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;
}
function getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {
    const imageIds = viewport.getImageIds();
    if (!imageIds || !imageIds.length) {
        return;
    }
    const distanceImagePairs = imageIds.map((imageId) => {
        const { imagePositionPatient } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('imagePlaneModule', imageId);
        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);
        return { imageId, distance };
    });
    distanceImagePairs.sort((a, b) => a.distance - b.distance);
    return distanceImagePairs[0].imageId;
}
function calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {
    const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.sub */ .eR.sub(dir, worldPos, ImagePositionPatient);
    const dot = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.dot */ .eR.dot(dir, viewPlaneNormal);
    return Math.abs(dot);
}



/***/ }),

/***/ 76802:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {
    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);
    if (sliceNormalIndex === -1) {
        throw new Error('3D bounding boxes not supported in an oblique plane');
    }
    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;
    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;
    return boundsIJK;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extend2DBoundingBoxInViewAxis);


/***/ }),

/***/ 87063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ getBoundingBoxAroundShapeWorld),
/* harmony export */   g: () => (/* binding */ getBoundingBoxAroundShapeIJK)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
function calculateBoundingBox(points, dimensions, isWorld = false) {
    let xMin = Infinity;
    let xMax = isWorld ? -Infinity : 0;
    let yMin = Infinity;
    let yMax = isWorld ? -Infinity : 0;
    let zMin = Infinity;
    let zMax = isWorld ? -Infinity : 0;
    const is3D = points[0]?.length === 3;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        xMin = Math.min(p[0], xMin);
        xMax = Math.max(p[0], xMax);
        yMin = Math.min(p[1], yMin);
        yMax = Math.max(p[1], yMax);
        if (is3D) {
            zMin = Math.min(p[2] ?? zMin, zMin);
            zMax = Math.max(p[2] ?? zMax, zMax);
        }
    }
    if (dimensions) {
        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
        if (is3D && dimensions.length === 3) {
            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
        }
    }
    else if (!isWorld) {
        xMin = Math.max(0, xMin);
        xMax = Math.min(Infinity, xMax);
        yMin = Math.max(0, yMin);
        yMax = Math.min(Infinity, yMax);
        if (is3D) {
            zMin = Math.max(0, zMin);
            zMax = Math.min(Infinity, zMax);
        }
    }
    return is3D
        ? [
            [xMin, xMax],
            [yMin, yMax],
            [zMin, zMax],
        ]
        : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
    return calculateBoundingBox(points, dimensions, false);
}
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
    return calculateBoundingBox(points, clipBounds, true);
}


/***/ }),

/***/ 72282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extend2DBoundingBoxInViewAxis: () => (/* reexport safe */ _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   getBoundingBoxAroundShape: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   getBoundingBoxAroundShapeIJK: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   getBoundingBoxAroundShapeWorld: () => (/* reexport safe */ _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__.C)
/* harmony export */ });
/* harmony import */ var _extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76802);
/* harmony import */ var _getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);





/***/ }),

/***/ 56534:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  addContourSegmentationAnnotation: () => (/* reexport */ addContourSegmentationAnnotation/* addContourSegmentationAnnotation */.V),
  convertContourSegmentationAnnotation: () => (/* reexport */ convertContourSegmentationAnnotation),
  createPolylineHole: () => (/* reexport */ sharedOperations/* createPolylineHole */.rK),
  removeContourSegmentationAnnotation: () => (/* reexport */ removeContourSegmentationAnnotation/* removeContourSegmentationAnnotation */.M)
});

// UNUSED EXPORTS: LogicalOperation, add, areSameSegment, checkIntersection, cleanupPolylines, combinePolylines, contourSegmentationOperation, convertContourPolylineToCanvasSpace, convertContourPolylineToWorld, copy, copyAnnotation, copyContourSegment, createNewAnnotationFromPolyline, deleteOperation, findAllIntersectingContours, getContourHolesData, intersect, intersectPolylinesSets, isContourSegmentationAnnotation, processMultipleIntersections, removeDuplicatePoints, subtract, subtractAnnotationPolylines, subtractMultiplePolylineSets, subtractPolylineSets, unifyAnnotationPolylines, unifyMultiplePolylineSets, unifyPolylineSets, updateViewportsForAnnotations, xor, xorPolylinesSets

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js
var areSameSegment = __webpack_require__(62854);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js
var stateManagement = __webpack_require__(6802);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js
var removeContourSegmentationAnnotation = __webpack_require__(37354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js
var addContourSegmentationAnnotation = __webpack_require__(85263);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
var state = __webpack_require__(44049);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/convertContourSegmentation.js





const DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';
function convertContourSegmentationAnnotation(annotation) {
    const { polyline } = annotation.data?.contour || {};
    if (!polyline || polyline.length < 3) {
        console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);
        return;
    }
    (0,stateManagement/* removeAnnotation */.O8)(annotation.annotationUID);
    (0,removeContourSegmentationAnnotation/* removeContourSegmentationAnnotation */.M)(annotation);
    const startPointWorld = polyline[0];
    const endPointWorld = polyline[polyline.length - 1];
    const newAnnotation = {
        metadata: {
            ...annotation.metadata,
            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,
            originalToolName: annotation.metadata.originalToolName || annotation.metadata.toolName,
        },
        data: {
            cachedStats: {},
            handles: {
                points: [startPointWorld, endPointWorld],
                textBox: annotation.data.handles.textBox
                    ? { ...annotation.data.handles.textBox }
                    : undefined,
            },
            contour: {
                ...annotation.data.contour,
            },
            spline: annotation.data.spline,
            segmentation: {
                ...annotation.data.segmentation,
            },
        },
        annotationUID: esm.utilities.uuidv4(),
        highlighted: true,
        invalidated: true,
        isLocked: false,
        isVisible: undefined,
        interpolationUID: annotation.interpolationUID,
        interpolationCompleted: annotation.interpolationCompleted,
    };
    (0,stateManagement/* addAnnotation */.lC)(newAnnotation, annotation.metadata.FrameOfReferenceUID);
    (0,addContourSegmentationAnnotation/* addContourSegmentationAnnotation */.V)(newAnnotation);
    (0,state.triggerAnnotationModified)(newAnnotation);
    return newAnnotation;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/copyAnnotation.js
var copyAnnotation = __webpack_require__(29031);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/logicalOperators.js + 1 modules
var logicalOperators = __webpack_require__(21536);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js
var isContourSegmentationAnnotation = __webpack_require__(78130);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getIntersectingAnnotations.js
var getIntersectingAnnotations = __webpack_require__(3444);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/mergeMultipleAnnotations.js
var mergeMultipleAnnotations = __webpack_require__(49941);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/contourSegmentationOperation.js
var contourSegmentationOperation = __webpack_require__(1318);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/sharedOperations.js
var sharedOperations = __webpack_require__(65172);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineUnify.js
var polylineUnify = __webpack_require__(98916);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineSubtract.js
var polylineSubtract = __webpack_require__(86591);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineIntersect.js
var polylineIntersect = __webpack_require__(52634);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineXor.js
var polylineXor = __webpack_require__(63890);
;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/index.js


















/***/ }),

/***/ 46228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports findContours, findContoursFromReducedSet */
function findNextLink(line, lines, contourPoints) {
    let index = -1;
    lines.forEach((cell, i) => {
        if (index >= 0) {
            return;
        }
        if (cell.a == line.b) {
            index = i;
        }
    });
    if (index >= 0) {
        const nextLine = lines[index];
        lines.splice(index, 1);
        contourPoints.push(nextLine.b);
        if (contourPoints[0] == nextLine.b) {
            return {
                remainingLines: lines,
                contourPoints,
                type: 'CLOSED_PLANAR',
            };
        }
        return findNextLink(nextLine, lines, contourPoints);
    }
    return {
        remainingLines: lines,
        contourPoints,
        type: 'OPEN_PLANAR',
    };
}
function findContours(lines) {
    if (lines.length == 0) {
        return [];
    }
    const contourPoints = [];
    const firstCell = lines.shift();
    contourPoints.push(firstCell.a);
    contourPoints.push(firstCell.b);
    const result = findNextLink(firstCell, lines, contourPoints);
    if (result.remainingLines.length == 0) {
        return [
            {
                type: result.type,
                contourPoints: result.contourPoints,
            },
        ];
    }
    else {
        const extraContours = findContours(result.remainingLines);
        extraContours.push({
            type: result.type,
            contourPoints: result.contourPoints,
        });
        return extraContours;
    }
}
function findContoursFromReducedSet(lines) {
    return findContours(lines);
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({
    findContours,
    findContoursFromReducedSet,
});


/***/ }),

/***/ 98013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findHandlePolylineIndex)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);


const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function findHandlePolylineIndex(annotation, handleIndex) {
    const { polyline } = annotation.data.contour;
    const { points } = annotation.data.handles;
    const { length } = points;
    if (handleIndex === length) {
        return polyline.length;
    }
    if (handleIndex < 0) {
        handleIndex = (handleIndex + length) % length;
    }
    if (handleIndex === 0) {
        return 0;
    }
    const handle = points[handleIndex];
    const index = polyline.findIndex((point) => isEqual(handle, point));
    if (index !== -1) {
        return index;
    }
    let closestDistance = Infinity;
    return polyline.reduce((closestIndex, point, testIndex) => {
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.squaredDistance */ .eR.squaredDistance(point, handle);
        if (distance < closestDistance) {
            closestDistance = distance;
            return testIndex;
        }
        return closestIndex;
    }, -1);
}


/***/ }),

/***/ 37546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export getDeduplicatedVTKPolyDataPoints */
function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {
    const points = polyData.getPoints();
    const lines = polyData.getLines();
    const pointsArray = new Array(points.getNumberOfPoints())
        .fill(0)
        .map((_, i) => points.getPoint(i).slice());
    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {
        const cell = lines.getCell(i * 3).slice();
        return { a: cell[0], b: cell[1] };
    });
    if (bypass) {
        return { points: pointsArray, lines: linesArray };
    }
    const newPoints = [];
    for (const [i, pt] of pointsArray.entries()) {
        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);
        if (index >= 0) {
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = index;
                }
                if (line.b === i) {
                    line.b = index;
                }
                return line;
            });
        }
        else {
            const newIndex = newPoints.length;
            newPoints.push(pt);
            linesArray.map((line) => {
                if (line.a === i) {
                    line.a = newIndex;
                }
                if (line.b === i) {
                    line.b = newIndex;
                }
                return line;
            });
        }
    }
    const newLines = linesArray.filter((line) => line.a !== line.b);
    return { points: newPoints, lines: newLines };
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({ getDeduplicatedVTKPolyDataPoints });


/***/ }),

/***/ 52905:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45217);

function debounce(func, wait, options) {
    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    wait = Number(wait) || 0;
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(options)) {
        leading = Boolean(options.leading);
        maxing = 'maxWait' in options;
        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;
    }
    function invokeFunc(time) {
        const args = lastArgs;
        const thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function startTimer(pendingFunc, wait) {
        if (useRAF) {
            return window.requestAnimationFrame(pendingFunc);
        }
        return setTimeout(pendingFunc, wait);
    }
    function cancelTimer(id) {
        if (useRAF) {
            return window.cancelAnimationFrame(id);
        }
        clearTimeout(id);
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = startTimer(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        const timeWaiting = wait - timeSinceLastCall;
        return maxing
            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
    }
    function shouldInvoke(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        return (lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && timeSinceLastInvoke >= maxWait));
    }
    function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            cancelTimer(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(Date.now());
    }
    function pending() {
        return timerId !== undefined;
    }
    function debounced(...args) {
        const time = Date.now();
        const isInvoking = shouldInvoke(time);
        lastArgs = args;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                timerId = startTimer(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = startTimer(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);


/***/ }),

/***/ 1239:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getTextBoxCoordsCanvas)
/* harmony export */ });
function getTextBoxCoordsCanvas(annotationCanvasPoints) {
    const corners = _determineCorners(annotationCanvasPoints);
    const centerY = (corners.top[1] + corners.bottom[1]) / 2;
    const textBoxCanvas = [corners.right[0], centerY];
    return textBoxCanvas;
}
function _determineCorners(canvasPoints) {
    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);
    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);
    const right = handlesLeftToRight[handlesLeftToRight.length - 1];
    const top = handlesTopToBottom[0];
    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];
    return {
        top,
        bottom,
        right,
    };
    function _compareX(a, b) {
        return a[0] < b[0] ? -1 : 1;
    }
    function _compareY(a, b) {
        return a[1] < b[1] ? -1 : 1;
    }
}


/***/ }),

/***/ 473:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextBoxCoordsCanvas: () => (/* reexport safe */ _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _getTextBoxCoordsCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1239);




/***/ }),

/***/ 4096:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CQ: () => (/* binding */ getCalibratedAspect),
/* harmony export */   Op: () => (/* binding */ getCalibratedLengthUnitsAndScale),
/* harmony export */   Xw: () => (/* binding */ getCalibratedProbeUnitsAndValue)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { CalibrationTypes } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums;
const PIXEL_UNITS = 'px';
const VOXEL_UNITS = 'voxels';
const SUPPORTED_REGION_DATA_TYPES = [
    1,
    2,
    3,
    4,
];
const SUPPORTED_LENGTH_VARIANT = [
    '3,3',
    '4,7',
];
const SUPPORTED_PROBE_VARIANT = [
    '4,3',
    '4,7',
];
const UNIT_MAPPING = {
    0: 'px',
    1: 'percent',
    2: 'dB',
    3: 'cm',
    4: 'seconds',
    5: 'hertz',
    6: 'dB/seconds',
    7: 'cm/sec',
    8: 'cm\xb2',
    9: 'cm\xb2/s',
    0xc: 'degrees',
};
const EPS = 1e-3;
const SQUARE = '\xb2';
const getCalibratedLengthUnitsAndScale = (image, handles) => {
    const { calibration, hasPixelSpacing } = image;
    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;
    const volumeUnit = hasPixelSpacing ? 'mm\xb3' : VOXEL_UNITS;
    let areaUnit = unit + SQUARE;
    let scale = 1;
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { unit, areaUnit, scale, volumeUnit };
    }
    if (calibration.type === CalibrationTypes.UNCALIBRATED) {
        return {
            unit: PIXEL_UNITS,
            areaUnit: PIXEL_UNITS + SQUARE,
            scale,
            volumeUnit: VOXEL_UNITS,
        };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        let imageIndex1, imageIndex2;
        if (Array.isArray(handles) && handles.length === 2) {
            [imageIndex1, imageIndex2] = handles;
        }
        else if (typeof handles === 'function') {
            const points = handles();
            imageIndex1 = points[0];
            imageIndex2 = points[1];
        }
        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&
            imageIndex1[0] <= region.regionLocationMaxX1 &&
            imageIndex1[1] >= region.regionLocationMinY0 &&
            imageIndex1[1] <= region.regionLocationMaxY1 &&
            imageIndex2[0] >= region.regionLocationMinX0 &&
            imageIndex2[0] <= region.regionLocationMaxX1 &&
            imageIndex2[1] >= region.regionLocationMinY0 &&
            imageIndex2[1] <= region.regionLocationMaxY1);
        if (!regions?.length) {
            return { unit, areaUnit, scale, volumeUnit };
        }
        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!regions.length) {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
        const region = regions[0];
        const physicalDeltaX = Math.abs(region.physicalDeltaX);
        const physicalDeltaY = Math.abs(region.physicalDeltaY);
        const isSamePhysicalDelta = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);
        if (isSamePhysicalDelta) {
            scale = 1 / physicalDeltaX;
            calibrationType = 'US Region';
            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';
            areaUnit = unit + SQUARE;
        }
        else {
            return {
                unit: PIXEL_UNITS,
                areaUnit: PIXEL_UNITS + SQUARE,
                scale,
                volumeUnit: VOXEL_UNITS,
            };
        }
    }
    else if (calibration.scale) {
        scale = calibration.scale;
    }
    const types = [
        CalibrationTypes.ERMF,
        CalibrationTypes.USER,
        CalibrationTypes.ERROR,
        CalibrationTypes.PROJECTION,
        CalibrationTypes.CALIBRATED,
        CalibrationTypes.UNKNOWN,
    ];
    if (types.includes(calibration?.type)) {
        calibrationType = calibration.type;
    }
    return {
        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),
        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),
        scale,
        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),
    };
};
const getCalibratedProbeUnitsAndValue = (image, handles) => {
    const [imageIndex] = handles;
    const { calibration } = image;
    let units = ['raw'];
    let values = [null];
    let calibrationType = '';
    if (!calibration ||
        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {
        return { units, values };
    }
    if (calibration.sequenceOfUltrasoundRegions) {
        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&
            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));
        if (!supportedRegionsMetadata?.length) {
            return { units, values };
        }
        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&
            imageIndex[0] <= region.regionLocationMaxX1 &&
            imageIndex[1] >= region.regionLocationMinY0 &&
            imageIndex[1] <= region.regionLocationMaxY1);
        if (!region) {
            return { units, values };
        }
        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;
        const { physicalDeltaX, physicalDeltaY } = region;
        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *
            physicalDeltaY;
        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *
            physicalDeltaX;
        calibrationType = 'US Region';
        values = [xValue, yValue];
        units = [
            UNIT_MAPPING[region.physicalUnitsXDirection],
            UNIT_MAPPING[region.physicalUnitsYDirection],
        ];
    }
    return {
        units,
        values,
        calibrationType,
    };
};
const getCalibratedAspect = (image) => image.calibration?.aspect || 1;



/***/ }),

/***/ 4296:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSphereBoundsInfo),
/* harmony export */   l: () => (/* binding */ getSphereBoundsInfoFromViewport)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);
/* harmony import */ var _boundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72282);



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {
    const [bottom, top] = circlePoints;
    const centerWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);
    const radiusWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.distance */ .eR.distance(bottom, top) / 2;
    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);
    return {
        boundsIJK,
        centerWorld: centerWorld,
        radiusWorld,
        topLeftWorld: topLeftWorld,
        bottomRightWorld: bottomRightWorld,
    };
}
function getSphereBoundsInfo(circlePoints, imageData) {
    const direction = imageData.getDirection();
    const rowCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[0], direction[1], direction[2]);
    const columnCosine = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[3], direction[4], direction[5]);
    const scanAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(direction[6], direction[7], direction[8]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), scanAxis);
    const directionVectors = {
        row: rowCosine,
        column: columnCosine,
        normal: viewPlaneNormal,
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {
    if (!viewport) {
        throw new Error('viewport is required in order to calculate the sphere bounds');
    }
    const camera = viewport.getCamera();
    const viewUp = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);
    const viewPlaneNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.fromValues */ .eR.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);
    const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.cross */ .eR.cross(viewRight, viewUp, viewPlaneNormal);
    const directionVectors = {
        row: viewRight,
        normal: viewPlaneNormal,
        column: gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create(), viewUp),
    };
    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);
}
function _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {
    const dimensions = imageData.getDimensions();
    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;
    const topLeftWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    const bottomRightWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);
    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);
    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));
    const boundsIJK = (0,_boundingBox__WEBPACK_IMPORTED_MODULE_2__.getBoundingBoxAroundShapeIJK)([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);
    return { boundsIJK, topLeftWorld, bottomRightWorld };
}



/***/ }),

/***/ 40133:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getViewportForAnnotation)
/* harmony export */ });
/* harmony import */ var _getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15295);

function getViewportForAnnotation(annotation) {
    const viewports = (0,_getViewportsForAnnotation__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotation);
    if (!viewports?.length) {
        return undefined;
    }
    const viewport = viewports.find((viewport) => viewport
        .getImageIds()
        .some((imageId) => imageId === annotation.metadata.referencedImageId));
    return viewport ?? viewports[0];
}


/***/ }),

/***/ 45217:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isObject(value) {
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);


/***/ }),

/***/ 95527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BasicStatsCalculator: () => (/* reexport module object */ _basic__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   aabb: () => (/* reexport module object */ _aabb__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   angle: () => (/* reexport module object */ _angle__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   circle: () => (/* reexport module object */ _circle__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   ellipse: () => (/* reexport module object */ _ellipse__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   lineSegment: () => (/* reexport module object */ _line__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   point: () => (/* reexport module object */ _point__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   polyline: () => (/* reexport module object */ _polyline__WEBPACK_IMPORTED_MODULE_6__),
/* harmony export */   rectangle: () => (/* reexport module object */ _rectangle__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   vec2: () => (/* reexport module object */ _vec2__WEBPACK_IMPORTED_MODULE_8__)
/* harmony export */ });
/* harmony import */ var _aabb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88638);
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73262);
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77081);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87009);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93258);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82216);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(92984);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(33657);
/* harmony import */ var _vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(23324);
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(83923);













/***/ }),

/***/ 93258:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   distanceToPoint: () => (/* reexport safe */ _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   distanceToPointSquared: () => (/* reexport safe */ _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   distanceToPointSquaredInfo: () => (/* reexport safe */ _distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   intersectLine: () => (/* reexport safe */ _intersectLine__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   isPointOnLineSegment: () => (/* reexport safe */ _isPointOnLineSegment__WEBPACK_IMPORTED_MODULE_4__.A)
/* harmony export */ });
/* harmony import */ var _distanceToPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86978);
/* harmony import */ var _distanceToPointSquared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18989);
/* harmony import */ var _distanceToPointSquaredInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(73149);
/* harmony import */ var _intersectLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81205);
/* harmony import */ var _isPointOnLineSegment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91818);








/***/ }),

/***/ 62783:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* reexport */ pointInSphere)
});

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js
function pointInSphere(sphere, pointLPS) {
    const { center, radius } = sphere;
    const radius2 = sphere.radius2 || radius * radius;
    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +
        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +
        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=
        radius2);
}

;// ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js




/***/ }),

/***/ 13179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68915);

class SegmentStatsCalculator {
    static { this.calculators = new Map(); }
    static { this.indices = []; }
    static { this.mode = 'collective'; }
    static statsInit(options) {
        const { storePointData, indices, mode } = options;
        this.mode = mode;
        this.indices = indices;
        this.calculators.clear();
        if (this.mode === 'individual') {
            indices.forEach((index) => {
                this.calculators.set(index, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceVolumetricCalculator */ .C3({ storePointData }));
            });
        }
        else {
            this.calculators.set(indices, new _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceVolumetricCalculator */ .C3({ storePointData }));
        }
    }
    static statsCallback(data) {
        const { segmentIndex, ...statsData } = data;
        if (!segmentIndex) {
            throw new Error('Segment index is required for stats calculation');
        }
        const calculator = this.mode === 'individual'
            ? this.calculators.get(segmentIndex)
            : this.calculators.get(this.indices);
        if (!calculator) {
            throw new Error(`No calculator found for segment ${segmentIndex}`);
        }
        calculator.statsCallback(statsData);
    }
    static getStatistics(options) {
        if (this.mode === 'individual') {
            const result = {};
            this.calculators.forEach((calculator, segmentIndex) => {
                result[segmentIndex] = calculator.getStatistics(options);
            });
            return result;
        }
        const calculator = this.calculators.get(this.indices);
        return calculator.getStatistics(options);
    }
}


/***/ }),

/***/ 60199:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, createBidirectionalForSlice */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _isLineInSegment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60213);


const EPSILON = 1e-2;
function findLargestBidirectional(contours, segVolumeId, segment) {
    const { sliceContours } = contours;
    const { segmentIndex, containedSegmentIndices } = segment;
    let maxBidirectional;
    const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);
    for (const sliceContour of sliceContours) {
        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);
        if (!bidirectional) {
            continue;
        }
        maxBidirectional = bidirectional;
    }
    if (maxBidirectional) {
        Object.assign(maxBidirectional, segment);
    }
    return maxBidirectional;
}
function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {
    const { points } = sliceContour.polyData;
    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;
    let maxMajor = currentMaxMajor * currentMaxMajor;
    let maxMinor = currentMaxMinor * currentMaxMinor;
    let maxMajorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = vec3.sqrDist(point1, point2);
            if (distance2 < maxMajor) {
                continue;
            }
            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!isLineInSegment(point1, point2, isInSegment)) {
                continue;
            }
            maxMajor = distance2 - EPSILON;
            maxMajorPoints = [index1, index2];
            maxMinor = 0;
        }
    }
    if (!maxMajorPoints) {
        return;
    }
    maxMajor = Math.sqrt(maxMajor + EPSILON);
    const handle0 = points[maxMajorPoints[0]];
    const handle1 = points[maxMajorPoints[1]];
    const unitMajor = vec3.sub(vec3.create(), handle0, handle1);
    vec3.scale(unitMajor, unitMajor, 1 / maxMajor);
    let maxMinorPoints;
    for (let index1 = 0; index1 < points.length; index1++) {
        for (let index2 = index1 + 1; index2 < points.length; index2++) {
            const point1 = points[index1];
            const point2 = points[index2];
            const distance2 = vec3.sqrDist(point1, point2);
            if (distance2 <= maxMinor) {
                continue;
            }
            const delta = vec3.sub(vec3.create(), point1, point2);
            const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);
            if (dot > EPSILON) {
                continue;
            }
            if (!isInSegment.testCenter(point1, point2)) {
                continue;
            }
            if (!isLineInSegment(point1, point2, isInSegment)) {
                continue;
            }
            maxMinor = distance2;
            maxMinorPoints = [index1, index2];
        }
    }
    if (!maxMinorPoints) {
        return;
    }
    maxMinor = Math.sqrt(maxMinor);
    const handle2 = points[maxMinorPoints[0]];
    const handle3 = points[maxMinorPoints[1]];
    const bidirectional = {
        majorAxis: [handle0, handle1],
        minorAxis: [handle2, handle3],
        maxMajor,
        maxMinor,
        ...sliceContour,
    };
    return bidirectional;
}


/***/ }),

/***/ 84882:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function floodFill(getter, seed, options = {}) {
    const onFlood = options.onFlood;
    const onBoundary = options.onBoundary;
    const equals = options.equals;
    const filter = options.filter;
    const diagonals = options.diagonals || false;
    const startNode = get(seed);
    const permutations = prunedPermutations();
    const stack = [];
    const flooded = [];
    const visits = new Set();
    const bounds = options.bounds;
    stack.push({ currentArgs: seed });
    while (stack.length > 0) {
        flood(stack.pop());
    }
    return {
        flooded,
    };
    function flood(job) {
        const getArgs = job.currentArgs;
        const prevArgs = job.previousArgs;
        if (visited(getArgs)) {
            return;
        }
        markAsVisited(getArgs);
        if (member(getArgs)) {
            markAsFlooded(getArgs);
            pushAdjacent(getArgs);
        }
        else {
            markAsBoundary(prevArgs);
        }
    }
    function visited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        return visits.has(iKey);
    }
    function markAsVisited(key) {
        const [x, y, z = 0] = key;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        visits.add(iKey);
    }
    function member(getArgs) {
        const node = get(getArgs);
        return equals ? equals(node, startNode) : node === startNode;
    }
    function markAsFlooded(getArgs) {
        flooded.push(getArgs);
        if (onFlood) {
            onFlood(...getArgs);
        }
    }
    function markAsBoundary(prevArgs) {
        const [x, y, z = 0] = prevArgs;
        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));
        bounds?.set(iKey, prevArgs);
        if (onBoundary) {
            onBoundary(...prevArgs);
        }
    }
    function pushAdjacent(getArgs) {
        for (let i = 0; i < permutations.length; i += 1) {
            const perm = permutations[i];
            const nextArgs = getArgs.slice(0);
            for (let j = 0; j < getArgs.length; j += 1) {
                nextArgs[j] += perm[j];
            }
            if (filter?.(nextArgs) === false) {
                continue;
            }
            if (visited(nextArgs)) {
                continue;
            }
            stack.push({
                currentArgs: nextArgs,
                previousArgs: getArgs,
            });
        }
    }
    function get(getArgs) {
        return getter(...getArgs);
    }
    function prunedPermutations() {
        const permutations = permute(seed.length);
        return permutations.filter(function (perm) {
            const count = countNonZeroes(perm);
            return count !== 0 && (count === 1 || diagonals);
        });
    }
    function permute(length) {
        const perms = [];
        const permutation = function (string) {
            return string.split('').map(function (c) {
                return parseInt(c, 10) - 1;
            });
        };
        for (let i = 0; i < Math.pow(3, length); i += 1) {
            const string = lpad(i.toString(3), '0', length);
            perms.push(permutation(string));
        }
        return perms;
    }
}
function countNonZeroes(array) {
    let count = 0;
    for (let i = 0; i < array.length; i += 1) {
        if (array[i] !== 0) {
            count += 1;
        }
    }
    return count;
}
function lpad(string, character, length) {
    const array = new Array(length + 1);
    const pad = array.join(character);
    return (pad + string).slice(-length);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (floodFill);


/***/ }),

/***/ 14957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ getBrushToolInstances)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48736);


function getBrushToolInstances(toolGroupId, toolName) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return [];
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return [];
    }
    if (toolName && toolInstances[toolName]) {
        return [toolInstances[toolName]];
    }
    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof _tools_segmentation_BrushTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
    return brushBasedToolInstances;
}


/***/ }),

/***/ 20527:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ getHoveredContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98870);


function getHoveredContourSegmentationAnnotation(segmentationId) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const { annotationUIDsMap } = segmentation.representationData.Contour;
    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {
        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => (0,_stateManagement__WEBPACK_IMPORTED_MODULE_0__/* .getAnnotation */ .gw)(annotationUID).highlighted);
        if (highlightedAnnotationUID) {
            return segmentIndex;
        }
    }
    return undefined;
}


/***/ }),

/***/ 46507:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSegmentIndexAtLabelmapBorder)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98870);
/* harmony import */ var _stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91963);



function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getSegmentation)(segmentationId);
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const voxelManager = segmentationVolume.voxelManager;
        const imageData = segmentationVolume.imageData;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
        const canvasPoint = viewport.worldToCanvas(worldPoint);
        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);
        return onEdge ? segmentIndex : undefined;
    }
    const segmentationImageId = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_1__.getCurrentLabelmapImageIdForViewport)(viewport.id, segmentationId);
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers__WEBPACK_IMPORTED_MODULE_2__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);
    return onEdge ? segmentIndex : undefined;
}
function isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {
    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);
    for (const deltaI of neighborRange) {
        for (const deltaJ of neighborRange) {
            for (const deltaK of neighborRange) {
                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {
                    continue;
                }
                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);
                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {
                    return true;
                }
            }
        }
    }
    return false;
}
function isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {
        const neighborIJK = [
            indexIJK[0] + deltaI,
            indexIJK[1] + deltaJ,
            indexIJK[2] + deltaK,
        ];
        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
function isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ) => {
        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];
        const worldPoint = viewport.canvasToWorld(neighborCanvas);
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}


/***/ }),

/***/ 71751:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hX: () => (/* binding */ getSegmentIndexAtWorldPoint)
/* harmony export */ });
/* unused harmony exports getSegmentIndexAtWorldForLabelmap, getSegmentIndexAtWorldForContour */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98870);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6802);
/* harmony import */ var _math_polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(92984);
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59452);






function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {
    const segmentation = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getSegmentation)(segmentationId);
    const representationData = segmentation.representationData;
    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];
    if (!desiredRepresentation) {
        throw new Error(`Segmentation ${segmentationId} does not have any representations`);
    }
    switch (desiredRepresentation) {
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap:
            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);
        case _enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Contour:
            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);
        default:
            return;
    }
}
function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
    const labelmapData = segmentation.representationData.Labelmap;
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const { volumeId } = labelmapData;
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        return segmentIndex;
    }
    const segmentationImageIds = (0,_stateManagement_segmentation_segmentationState__WEBPACK_IMPORTED_MODULE_2__.getCurrentLabelmapImageIdsForViewport)(viewport.id, segmentation.segmentationId);
    if (segmentationImageIds.length > 1) {
        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');
        return;
    }
    const segmentationImageId = segmentationImageIds[0];
    const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationActorEntry = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_5__/* .getLabelmapActorEntry */ .wV)(viewport.id, segmentation.segmentationId);
    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();
    const indexIJK = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.VoxelManager.createScalarVolumeVoxelManager({
            dimensions,
            scalarData: imageData.getPointData().getScalars().getData(),
        }));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    return segmentIndex;
}
function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {
    const contourData = segmentation.representationData.Contour;
    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
    const { viewPlaneNormal } = viewport.getCamera();
    for (const segmentIndex of segmentIndices) {
        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
        if (!annotationsSet) {
            continue;
        }
        for (const annotationUID of annotationsSet) {
            const annotation = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotation */ .gw)(annotationUID);
            if (!annotation) {
                continue;
            }
            const { polyline } = annotation.data.contour;
            if (!_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
                continue;
            }
            if ((0,_math_polyline__WEBPACK_IMPORTED_MODULE_4__.isPointInsidePolyline3D)(worldPoint, polyline)) {
                return Number(segmentIndex);
            }
        }
    }
}


/***/ }),

/***/ 2733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const shader = `
const MAX_STRENGTH = 65535f;

// Workgroup size - X*Y*Z must be multiple of 32 for better performance
override workGroupSizeX = 1u;
override workGroupSizeY = 1u;
override workGroupSizeZ = 1u;

// Compare the current voxel to neighbors using a 9x9x9 window
override windowSize = 9i;

struct Params {
  size: vec3u,
  iteration: u32,
}

// New structure to track bounds of modified voxels
struct Bounds {
  minX: atomic<i32>,
  minY: atomic<i32>,
  minZ: atomic<i32>,
  maxX: atomic<i32>,
  maxY: atomic<i32>,
  maxZ: atomic<i32>,
}

@group(0) @binding(0) var<uniform> params: Params;
@group(0) @binding(1) var<storage> volumePixelData: array<f32>;
@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;
@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;
@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;
@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;
@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;
@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;

fn getPixelIndex(ijkPos: vec3u) -> u32 {
  let numPixelsPerSlice = params.size.x * params.size.y;
  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;
}

fn updateBounds(position: vec3i) {
  // Atomically update min bounds (use min operation)
  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);
  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);
  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);

  // Atomically update max bounds (use max operation)
  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);
  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);
  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);
}

@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
fn main(
  @builtin(global_invocation_id) globalId: vec3u,
) {
  // Make sure it will not get out of bounds for volume with sizes that
  // are not multiple of workGroupSize
  if (
    globalId.x >= params.size.x ||
    globalId.y >= params.size.y ||
    globalId.z >= params.size.z
  ) {
    return;
  }

  // Initialize bounds for the first iteration
  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {
    // Initialize to opposite extremes to ensure any update will improve the bounds
    atomicStore(&modifiedBounds.minX, i32(params.size.x));
    atomicStore(&modifiedBounds.minY, i32(params.size.y));
    atomicStore(&modifiedBounds.minZ, i32(params.size.z));
    atomicStore(&modifiedBounds.maxX, -1);
    atomicStore(&modifiedBounds.maxY, -1);
    atomicStore(&modifiedBounds.maxZ, -1);
  }

  let currentCoord = vec3i(globalId);
  let currentPixelIndex = getPixelIndex(globalId);

  let numPixels = arrayLength(&volumePixelData);
  let currentPixelValue = volumePixelData[currentPixelIndex];

  if (params.iteration == 0) {
    // All non-zero initial labels are given maximum strength
    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);

    // Update bounds for non-zero initial labels
    if (labelmap[currentPixelIndex] != 0) {
      updateBounds(currentCoord);
    }
    return;
  }

  // It should at least copy the values from previous state
  var newLabel = prevLabelmap[currentPixelIndex];
  var newStrength = prevStrengthData[currentPixelIndex];

  let window = i32(ceil(f32(windowSize - 1) * .5));
  let minWindow = -1i * window;
  let maxWindow = 1i * window;

  for (var k = minWindow; k <= maxWindow; k++) {
    for (var j = minWindow; j <= maxWindow; j++) {
      for (var i = minWindow; i <= maxWindow; i++) {
        // Skip current voxel
        if (i == 0 && j == 0 && k == 0) {
          continue;
        }

        let neighborCoord = currentCoord + vec3i(i, j, k);

        //  Boundary conditions. Do not grow outside of the volume
        if (
          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||
          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||
          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)
        ) {
          continue;
        }

        let neighborIndex = getPixelIndex(vec3u(neighborCoord));
        let neighborPixelValue = volumePixelData[neighborIndex];
        let prevNeighborStrength = prevStrengthData[neighborIndex];
        let strengthCost = abs(neighborPixelValue - currentPixelValue);
        let takeoverStrength = prevNeighborStrength - strengthCost;

        if (takeoverStrength > newStrength) {
          newLabel = prevLabelmap[neighborIndex];
          newStrength = takeoverStrength;
        }
      }
    }
  }

  if (labelmap[currentPixelIndex] != newLabel) {
    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);

    // Update bounds for modified voxels
    updateBounds(currentCoord);
  }

  labelmap[currentPixelIndex] = newLabel;
  strengthData[currentPixelIndex] = newStrength;
}
`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shader);


/***/ }),

/***/ 95373:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   run: () => (/* reexport safe */ _runGrowCut__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   runGrowCutForBoundingBox: () => (/* reexport safe */ _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__.z),
/* harmony export */   runGrowCutForSphere: () => (/* reexport safe */ _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__.n),
/* harmony export */   runOneClickGrowCut: () => (/* reexport safe */ _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__.HW)
/* harmony export */ });
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66499);
/* harmony import */ var _runGrowCutForSphere__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73569);
/* harmony import */ var _runGrowCutForBoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20271);
/* harmony import */ var _runOneClickGrowCut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16171);






/***/ }),

/***/ 66499:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ runGrowCut)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _growCutShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2733);


const GB = 1024 * 1024 * 1024;
const WEBGPU_MEMORY_LIMIT = 1.99 * GB;
const DEFAULT_GROWCUT_OPTIONS = {
    windowSize: 3,
    maxProcessingTime: 30000,
    inspection: {
        numCyclesInterval: 5,
        numCyclesBelowThreshold: 3,
        threshold: 1e-4,
    },
};
async function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {
    const workGroupSize = [8, 8, 4];
    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);
    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referenceVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(labelmapVolumeId);
    const [columns, rows, numSlices] = volume.dimensions;
    if (labelmap.dimensions[0] !== columns ||
        labelmap.dimensions[1] !== rows ||
        labelmap.dimensions[2] !== numSlices) {
        throw new Error('Volume and labelmap must have the same size');
    }
    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);
    numIterations = Math.min(numIterations, 500);
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();
    if (!(volumePixelData instanceof Float32Array)) {
        volumePixelData = new Float32Array(volumePixelData);
    }
    const requiredLimits = {
        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,
        maxBufferSize: WEBGPU_MEMORY_LIMIT,
    };
    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter.requestDevice({ requiredLimits });
    const BUFFER_SIZE = volumePixelData.byteLength;
    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;
    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;
    const shaderModule = device.createShaderModule({
        code: _growCutShader__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A,
    });
    const numIterationIndex = 3;
    const paramsArrayValues = new Uint32Array([
        columns,
        rows,
        numSlices,
        0,
    ]);
    const gpuParamsBuffer = device.createBuffer({
        size: paramsArrayValues.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    const gpuVolumePixelDataBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);
    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    }));
    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));
    const gpuStrengthBuffers = [0, 1].map(() => {
        const strengthBuffer = device.createBuffer({
            size: BUFFER_SIZE,
            usage: GPUBufferUsage.STORAGE |
                GPUBufferUsage.COPY_SRC |
                GPUBufferUsage.COPY_DST,
        });
        return strengthBuffer;
    });
    const gpuCounterBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const gpuBoundsBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC |
            GPUBufferUsage.COPY_DST,
    });
    const initialBounds = new Int32Array([
        columns,
        rows,
        numSlices,
        -1,
        -1,
        -1,
    ]);
    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);
    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            {
                binding: 0,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'uniform',
                },
            },
            {
                binding: 1,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 2,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 3,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 4,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 5,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'read-only-storage',
                },
            },
            {
                binding: 6,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
            {
                binding: 7,
                visibility: GPUShaderStage.COMPUTE,
                buffer: {
                    type: 'storage',
                },
            },
        ],
    });
    const bindGroups = [0, 1].map((i) => {
        const outputLabelmapBuffer = gpuLabelmapBuffers[i];
        const outputStrengthBuffer = gpuStrengthBuffers[i];
        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];
        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];
        return device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: gpuParamsBuffer,
                    },
                },
                {
                    binding: 1,
                    resource: {
                        buffer: gpuVolumePixelDataBuffer,
                    },
                },
                {
                    binding: 2,
                    resource: {
                        buffer: outputLabelmapBuffer,
                    },
                },
                {
                    binding: 3,
                    resource: {
                        buffer: outputStrengthBuffer,
                    },
                },
                {
                    binding: 4,
                    resource: {
                        buffer: previouLabelmapBuffer,
                    },
                },
                {
                    binding: 5,
                    resource: {
                        buffer: previousStrengthBuffer,
                    },
                },
                {
                    binding: 6,
                    resource: {
                        buffer: gpuCounterBuffer,
                    },
                },
                {
                    binding: 7,
                    resource: {
                        buffer: gpuBoundsBuffer,
                    },
                },
            ],
        });
    });
    const pipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [bindGroupLayout],
        }),
        compute: {
            module: shaderModule,
            entryPoint: 'main',
            constants: {
                workGroupSizeX: workGroupSize[0],
                workGroupSizeY: workGroupSize[1],
                workGroupSizeZ: workGroupSize[2],
                windowSize,
            },
        },
    });
    const numWorkGroups = [
        Math.ceil(columns / workGroupSize[0]),
        Math.ceil(rows / workGroupSize[1]),
        Math.ceil(numSlices / workGroupSize[2]),
    ];
    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({
        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const limitProcessingTime = maxProcessingTime
        ? performance.now() + maxProcessingTime
        : 0;
    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
    let belowThresholdCounter = 0;
    for (let i = 0; i < numIterations; i++) {
        paramsArrayValues[numIterationIndex] = i;
        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroups[i % 2]);
        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);
        passEncoder.end();
        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);
        device.queue.submit([commandEncoder.finish()]);
        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);
        if (inspect) {
            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);
            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));
            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;
            gpuUpdatedVoxelsCounterStagingBuffer.unmap();
            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {
                currentInspectionNumCyclesInterval = 1;
                belowThresholdCounter++;
                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {
                    break;
                }
            }
            else {
                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;
            }
        }
        if (limitProcessingTime && performance.now() > limitProcessingTime) {
            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);
            break;
        }
    }
    const commandEncoder = device.createCommandEncoder();
    const outputLabelmapBufferIndex = (numIterations + 1) % 2;
    const labelmapStagingBuffer = device.createBuffer({
        size: BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    const boundsStagingBuffer = device.createBuffer({
        size: BOUNDS_BUFFER_SIZE,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
    });
    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);
    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);
    device.queue.submit([commandEncoder.finish()]);
    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);
    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);
    const labelmapResult = new Uint32Array(labelmapResultBuffer);
    labelmapData.set(labelmapResult);
    labelmapStagingBuffer.unmap();
    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);
    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);
    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));
    boundsStagingBuffer.unmap();
    const minX = boundsResult[0];
    const minY = boundsResult[1];
    const minZ = boundsResult[2];
    const maxX = boundsResult[3];
    const maxY = boundsResult[4];
    const maxZ = boundsResult[5];
    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);
    labelmap.voxelManager.clearBounds();
    labelmap.voxelManager.setBounds([
        [minX, maxX],
        [minY, maxY],
        [minZ, maxZ],
    ]);
}



/***/ }),

/***/ 20271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ runGrowCutForBoundingBox)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66499);


const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const NEGATIVE_PIXEL_RANGE = [-Infinity, -995];
const POSITIVE_PIXEL_RANGE = [0, 1900];
function _setNegativeSeedValues(subVolume, labelmap, options) {
    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const visited = new Array(width * height).fill(false);
    const sliceOffset = middleSliceIndex * width * height;
    const bfs = (startX, startY) => {
        const queue = [[startX, startY]];
        while (queue.length) {
            const [x, y] = queue.shift();
            const slicePixelIndex = y * width + x;
            if (x < 0 ||
                x >= width ||
                y < 0 ||
                y >= height ||
                visited[slicePixelIndex]) {
                continue;
            }
            visited[slicePixelIndex] = true;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);
            queue.push([x - 1, y]);
            queue.push([x + 1, y]);
            queue.push([x, y - 1]);
            queue.push([x, y + 1]);
        }
    };
    const scanLine = (startX, limitX, incX, y) => {
        for (let x = startX; x !== limitX; x += incX) {
            const slicePixelIndex = y * width + x;
            const volumeVoxelIndex = sliceOffset + slicePixelIndex;
            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];
            if (volumeVoxelValue < negativePixelRange[0] ||
                volumeVoxelValue > negativePixelRange[1]) {
                break;
            }
            if (!visited[slicePixelIndex]) {
                bfs(x, y);
            }
        }
    };
    for (let y = 0; y < height; y++) {
        scanLine(0, width - 1, 1, y);
        scanLine(width - 1, 0, -1, y);
    }
}
function _setPositiveSeedValues(subVolume, labelmap, options) {
    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    const [width, height, numSlices] = labelmap.dimensions;
    const middleSliceIndex = Math.floor(numSlices / 2);
    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);
    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);
    const pixelsPerSlice = width * height;
    for (let z = startSliceIndex; z < stopSliceIndex; z++) {
        const zOffset = z * pixelsPerSlice;
        for (let y = 0; y < height; y++) {
            const yOffset = y * width;
            for (let x = 0; x < width; x++) {
                const index = zOffset + yOffset + x;
                const pixelValue = subVolPixelData[index];
                const isPositiveValue = pixelValue >= positivePixelRange[0] &&
                    pixelValue <= positivePixelRange[1];
                if (isPositiveValue) {
                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);
                }
            }
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, options);
    _setNegativeSeedValues(subVolume, labelmap, options);
    return labelmap;
}
async function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {
    const { boundingBox } = boundingBoxInfo;
    const { ijkTopLeft, ijkBottomRight } = boundingBox;
    const subVolumeBoundsIJK = {
        minX: ijkTopLeft[0],
        maxX: ijkBottomRight[0],
        minY: ijkTopLeft[1],
        maxY: ijkBottomRight[1],
        minZ: ijkTopLeft[2],
        maxZ: ijkBottomRight[2],
    };
    const subVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__/* .run */ .e)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ 73569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ runGrowCutForSphere)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66499);
/* harmony import */ var _getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4296);




const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities;
const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const POSITIVE_SEED_VARIANCE = 0.1;
const NEGATIVE_SEED_VARIANCE = 0.8;
function _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {
    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;
    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);
    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);
    return {
        ...sphereBoundsInfo,
        topLeftIJK,
        bottomRightIJK,
    };
}
function _getSphereBoundsInfo(referencedVolume, sphereInfo) {
    const direction = referencedVolume.imageData.getDirection();
    const vecColumn = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(direction[3], direction[4], direction[5]);
    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;
    const refVolImageData = referencedVolume.imageData;
    const topCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereCenterPoint, vecColumn, -sphereRadius);
    const bottomCirclePoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereCenterPoint, vecColumn, sphereRadius);
    const sphereBoundsInfo = (0,_getSphereBoundsInfo__WEBPACK_IMPORTED_MODULE_3__/* .getSphereBoundsInfo */ .R)([bottomCirclePoint, topCirclePoint], refVolImageData);
    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);
}
function _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {
    const refVolImageData = referencedVolume.imageData;
    const camera = viewport.getCamera();
    const { ijkVecRowDir, ijkVecColDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(refVolImageData, camera);
    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[0]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[1]), 1) &&
        !_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.isEqual(Math.abs(vec[2]), 1));
    if (obliqueView) {
        console.warn('Oblique view is not supported!');
        return;
    }
    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);
    const subVolumeBoundsIJK = {
        minX: sphereBoundsIJK[0][0],
        maxX: sphereBoundsIJK[0][1] + 1,
        minY: sphereBoundsIJK[1][0],
        maxY: sphereBoundsIJK[1][1] + 1,
        minZ: sphereBoundsIJK[2][0],
        maxZ: sphereBoundsIJK[2][1] + 1,
    };
    return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
}
function _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {
    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    const worldStartPos = sphereInfo.center;
    const [width, height, numSlices] = referencedVolume.dimensions;
    const numPixelsPerSlice = width * height;
    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);
    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0]];
    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;
    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;
    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0];
    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);
    const queue = [ijkStartPosition];
    while (queue.length) {
        const ijkVoxel = queue.shift();
        const [x, y, z] = ijkVoxel;
        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
            const neighborCoordDelta = neighborsCoordDelta[i];
            const nx = x + neighborCoordDelta[0];
            const ny = y + neighborCoordDelta[1];
            const nz = z + neighborCoordDelta[2];
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];
            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);
            if (neighborLabelmapValue === positiveSeedValue ||
                neighborPixelValue < minPositivePixelValue ||
                neighborPixelValue > maxPositivePixelValue) {
                continue;
            }
            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);
            queue.push([nx, ny, nz]);
        }
    }
}
function _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const [columns, rows, numSlices] = labelmap.dimensions;
    const numPixelsPerSlice = columns * rows;
    const { worldVecRowDir, worldVecSliceDir } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.utilities.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());
    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);
    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +
        ijkSphereCenter[1] * columns +
        ijkSphereCenter[0]];
    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;
    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;
    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
    const numCirclePoints = 360;
    const rotationAngle = (2 * Math.PI) / numCirclePoints;
    const worldQuat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create(), worldVecSliceDir, rotationAngle);
    const vecRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.clone */ .eR.clone(worldVecRowDir);
    for (let i = 0; i < numCirclePoints; i++) {
        const worldCircleBorderPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create(), sphereInfo.center, vecRotation, sphereInfo.radius);
        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);
        const [x, y, z] = ijkCircleBorderPoint;
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformQuat */ .eR.transformQuat(vecRotation, vecRotation, worldQuat);
        if (x < 0 ||
            x >= columns ||
            y < 0 ||
            y >= rows ||
            z < 0 ||
            z >= numSlices) {
            continue;
        }
        const offset = x + y * columns + z * numPixelsPerSlice;
        const pixelValue = subVolPixelData[offset];
        if (pixelValue < minNegativePixelValue ||
            pixelValue > maxNegativePixelValue) {
            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);
        }
    }
}
async function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {
    const labelmap = await _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);
    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);
    return labelmap;
}
async function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_1__.cache.getVolume(referencedVolumeId);
    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);
    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_2__/* .run */ .e)(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}



/***/ }),

/***/ 16171:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HW: () => (/* binding */ runOneClickGrowCut),
/* harmony export */   sG: () => (/* binding */ calculateGrowCutSeeds)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _runGrowCut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66499);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10564);



const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_POSITIVE_SEEDS = 100000;
function calculateGrowCutSeeds(referencedVolume, worldPosition, options) {
    const { dimensions, imageData: refImageData } = referencedVolume;
    const [width, height, numSlices] = dimensions;
    const referenceVolumeVoxelManager = referencedVolume.voxelManager;
    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();
    const numPixelsPerSlice = width * height;
    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEIGHBORHOOD_RADIUS */ .Sp;
    const positiveK = options?.positiveStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_POSITIVE_STD_DEV_MULTIPLIER */ .ee;
    const negativeK = options?.negativeStdDevMultiplier ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER */ .ag;
    const negativeSeedMargin = options?.negativeSeedMargin ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_SEED_MARGIN */ .BX;
    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .DEFAULT_NEGATIVE_SEEDS_COUNT */ .Zi;
    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);
    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);
    if (ijkStart[0] < 0 ||
        ijkStart[0] >= width ||
        ijkStart[1] < 0 ||
        ijkStart[1] >= height ||
        ijkStart[2] < 0 ||
        ijkStart[2] >= numSlices) {
        console.warn('Click position is outside volume bounds.');
        return null;
    }
    const initialStats = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);
    if (initialStats.count === 0) {
        initialStats.mean = scalarData[startIndex];
        initialStats.stdDev = 0;
    }
    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;
    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
    const positiveSeedIndices = new Set();
    const queue = [];
    const startValue = scalarData[startIndex];
    if (startValue >= positiveIntensityMin &&
        startValue <= positiveIntensityMax) {
        positiveSeedIndices.add(startIndex);
        queue.push(ijkStart);
        minX = maxX = ijkStart[0];
        minY = maxY = ijkStart[1];
        minZ = maxZ = ijkStart[2];
    }
    else {
        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let currentQueueIndex = 0;
    while (currentQueueIndex < queue.length &&
        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
        const [x, y, z] = queue[currentQueueIndex++];
        minX = Math.min(x, minX);
        minY = Math.min(y, minY);
        minZ = Math.min(z, minZ);
        maxX = Math.max(x, maxX);
        maxY = Math.max(y, maxY);
        maxZ = Math.max(z, maxZ);
        for (let i = 0; i < neighborsCoordDelta.length; i++) {
            const [dx, dy, dz] = neighborsCoordDelta[i];
            const nx = x + dx;
            const ny = y + dy;
            const nz = z + dz;
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;
            if (positiveSeedIndices.has(neighborIndex)) {
                continue;
            }
            const neighborValue = scalarData[neighborIndex];
            if (neighborValue >= positiveIntensityMin &&
                neighborValue <= positiveIntensityMax) {
                positiveSeedIndices.add(neighborIndex);
                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {
                    queue.push([nx, ny, nz]);
                }
            }
        }
    }
    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {
        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);
    }
    if (positiveSeedIndices.size === 0) {
        console.warn('No positive seeds found after BFS.');
        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };
    }
    let positiveSum = 0;
    let positiveSumSq = 0;
    positiveSeedIndices.forEach((index) => {
        const value = scalarData[index];
        positiveSum += value;
        positiveSumSq += value * value;
    });
    const positiveCount = positiveSeedIndices.size;
    const positiveMean = positiveSum / positiveCount;
    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;
    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));
    const negativeDiffThreshold = negativeK * positiveStdDev;
    const minXm = Math.max(0, minX - negativeSeedMargin);
    const minYm = Math.max(0, minY - negativeSeedMargin);
    const minZm = Math.max(0, minZ - negativeSeedMargin);
    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);
    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);
    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);
    const negativeSeedIndices = new Set();
    let attempts = 0;
    let patchesAdded = 0;
    const maxAttempts = negativeSeedsTargetPatches * _constants__WEBPACK_IMPORTED_MODULE_2__/* .MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER */ .gN;
    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {
        attempts++;
        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);
        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);
        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);
        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;
        if (positiveSeedIndices.has(centerIndex) ||
            negativeSeedIndices.has(centerIndex)) {
            continue;
        }
        const centerValue = scalarData[centerIndex];
        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {
            let patchContributed = false;
            for (let dy = -1; dy <= 1; dy++) {
                const ny = ry + dy;
                if (ny < 0 || ny >= height) {
                    continue;
                }
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = rx + dx;
                    if (nx < 0 || nx >= width) {
                        continue;
                    }
                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;
                    if (positiveSeedIndices.has(neighborIndex) ||
                        negativeSeedIndices.has(neighborIndex)) {
                        continue;
                    }
                    negativeSeedIndices.add(neighborIndex);
                    patchContributed = true;
                }
            }
            if (patchContributed) {
                patchesAdded++;
            }
        }
    }
    if (negativeSeedIndices.size === 0) {
        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');
    }
    console.debug('positiveSeedIndices', positiveSeedIndices.size);
    console.debug('negativeSeedIndices', negativeSeedIndices.size);
    return { positiveSeedIndices, negativeSeedIndices };
}
async function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {
    const referencedVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    const labelmap = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);
    labelmap.voxelManager.forEach(({ index, value }) => {
        if (value !== 0) {
            labelmap.voxelManager.setAtIndex(index, 0);
        }
    });
    const seeds = options.seeds ??
        calculateGrowCutSeeds(referencedVolume, worldPosition, options);
    const positiveSeedLabel = options?.positiveSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .POSITIVE_SEED_LABEL */ .VD;
    const negativeSeedLabel = options?.negativeSeedValue ?? _constants__WEBPACK_IMPORTED_MODULE_2__/* .NEGATIVE_SEED_LABEL */ .bs;
    if (!seeds) {
        return null;
    }
    const { positiveSeedIndices, negativeSeedIndices } = seeds;
    if (positiveSeedIndices.size < 10 ||
        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||
        negativeSeedIndices.size < 10) {
        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');
        return labelmap;
    }
    positiveSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);
    });
    negativeSeedIndices.forEach((index) => {
        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);
    });
    await (0,_runGrowCut__WEBPACK_IMPORTED_MODULE_1__/* .run */ .e)(referencedVolumeId, labelmap.volumeId, options);
    return labelmap;
}



/***/ }),

/***/ 93759:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   floodFill: () => (/* reexport safe */ _floodFill__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   getHoveredContourSegmentationAnnotation: () => (/* reexport safe */ _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__.L),
/* harmony export */   getOrCreateSegmentationVolume: () => (/* reexport safe */ _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__.A),
/* harmony export */   getSegmentIndexAtLabelmapBorder: () => (/* reexport safe */ _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__.T),
/* harmony export */   getSegmentIndexAtWorldPoint: () => (/* reexport safe */ _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__.hX),
/* harmony export */   growCut: () => (/* reexport module object */ _growCut__WEBPACK_IMPORTED_MODULE_20__)
/* harmony export */ });
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8582);
/* harmony import */ var _rectangleROIThresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52323);
/* harmony import */ var _createMergedLabelmapForIndex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4334);
/* harmony import */ var _createLabelmapVolumeForViewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97492);
/* harmony import */ var _stateManagement_segmentation_SegmentationRenderingEngine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24917);
/* harmony import */ var _floodFill__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(84882);
/* harmony import */ var _brushSizeForToolGroup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17014);
/* harmony import */ var _brushThresholdForToolGroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(49492);
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68915);
/* harmony import */ var _SegmentStatsCalculator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13179);
/* harmony import */ var _thresholdSegmentationByRange__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(73706);
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13276);
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(14514);
/* harmony import */ var _segmentContourAction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(22592);
/* harmony import */ var _invalidateBrushCursor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(35706);
/* harmony import */ var _getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(25758);
/* harmony import */ var _getSegmentIndexAtWorldPoint__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(71751);
/* harmony import */ var _getSegmentIndexAtLabelmapBorder__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(46507);
/* harmony import */ var _getHoveredContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(20527);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(14957);
/* harmony import */ var _growCut__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(95373);
/* harmony import */ var _createLabelmapMemo__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(2397);
/* harmony import */ var _islandRemoval__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(67912);
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(30722);
/* harmony import */ var _getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(83075);
/* harmony import */ var _getStatistics__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(38440);
/* harmony import */ var _validateLabelmap__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(21345);
/* harmony import */ var _stateManagement_segmentation_helpers_computeStackLabelmapFromVolume__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(93690);
/* harmony import */ var _stateManagement_segmentation_helpers_computeVolumeLabelmapFromStack__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(6994);
/* harmony import */ var _getReferenceVolumeForSegmentationVolume__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(12853);
/* harmony import */ var _getSegmentLargestBidirectional__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(78773);
/* harmony import */ var _computeMetabolicStats__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(88274);



































/***/ }),

/***/ 35706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ invalidateBrushCursor)
/* harmony export */ });
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14957);



function invalidateBrushCursor(toolGroupId) {
    const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__.getToolGroup)(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = (0,_getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__/* .getBrushToolInstances */ .n)(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    (0,_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewportIds);
}


/***/ }),

/***/ 60213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, createIsInSegment, createIsInSegmentMetadata, isLineInSegment */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3823);


function isLineInSegment(point1, point2, isInSegment) {
    const ijk1 = isInSegment.toIJK(point1);
    const ijk2 = isInSegment.toIJK(point2);
    const testPoint = vec3.create();
    const { testIJK } = isInSegment;
    const delta = vec3.sub(vec3.create(), ijk1, ijk2);
    const testSize = Math.round(Math.max(...delta.map(Math.abs)));
    if (testSize < 2) {
        return true;
    }
    const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);
    for (let i = 1; i < testSize; i++) {
        vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);
        if (!testIJK(testPoint)) {
            return false;
        }
    }
    return true;
}
function createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {
    const width = dimensions[0];
    const pixelsPerSlice = width * dimensions[1];
    return {
        testCenter: (point1, point2) => {
            const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);
            const ijk = imageData.worldToIndex(point).map(Math.round);
            const [i, j, k] = ijk;
            const index = i + j * width + k * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
        toIJK: (point) => imageData.worldToIndex(point),
        testIJK: (ijk) => {
            const [i, j, k] = ijk;
            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;
            const value = voxelManager.getAtIndex(index);
            return value === segmentIndex || containedSegmentIndices?.has(value);
        },
    };
}
function createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {
    const vol = cache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    return createIsInSegmentMetadata({
        dimensions: vol.dimensions,
        imageData: vol.imageData,
        voxelManager: vol.voxelManager,
        segmentIndex,
        containedSegmentIndices,
    });
}



/***/ }),

/***/ 27730:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52905);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45217);


function throttle(func, wait, options) {
    let leading = true;
    let trailing = true;
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    if ((0,_isObject__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(options)) {
        leading = 'leading' in options ? Boolean(options.leading) : leading;
        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;
    }
    return (0,_debounce__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(func, wait, {
        leading,
        trailing,
        maxWait: wait,
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ 76260:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyPoints: () => (/* binding */ copyPoints),
/* harmony export */   copyPointsList: () => (/* binding */ copyPointsList),
/* harmony export */   getDeltaDistance: () => (/* binding */ getDeltaDistance),
/* harmony export */   getDeltaDistanceBetweenIPoints: () => (/* binding */ getDeltaDistanceBetweenIPoints),
/* harmony export */   getDeltaPoints: () => (/* binding */ getDeltaPoints),
/* harmony export */   getMeanTouchPoints: () => (/* binding */ getMeanTouchPoints)
/* harmony export */ });
/* unused harmony exports getMeanPoints, getDeltaRotation */
function getDeltaPoints(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _subtractPoints2D(curr.page, last.page),
        client: _subtractPoints2D(curr.client, last.client),
        canvas: _subtractPoints2D(curr.canvas, last.canvas),
        world: _subtractPoints3D(curr.world, last.world),
    };
}
function getDeltaDistance(currentPoints, lastPoints) {
    const curr = getMeanPoints(currentPoints);
    const last = getMeanPoints(lastPoints);
    return {
        page: _getDistance2D(curr.page, last.page),
        client: _getDistance2D(curr.client, last.client),
        canvas: _getDistance2D(curr.canvas, last.canvas),
        world: _getDistance3D(curr.world, last.world),
    };
}
function getDeltaRotation(currentPoints, lastPoints) {
}
function getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {
    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);
    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);
    const deltaDistance = {
        page: currentDistance.page - lastDistance.page,
        client: currentDistance.client - lastDistance.client,
        canvas: currentDistance.canvas - lastDistance.canvas,
        world: currentDistance.world - lastDistance.world,
    };
    return deltaDistance;
}
function copyPointsList(points) {
    return JSON.parse(JSON.stringify(points));
}
function copyPoints(points) {
    return JSON.parse(JSON.stringify(points));
}
function getMeanPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
    });
}
function getMeanTouchPoints(points) {
    return points.reduce((prev, curr) => {
        return {
            page: [
                prev.page[0] + curr.page[0] / points.length,
                prev.page[1] + curr.page[1] / points.length,
            ],
            client: [
                prev.client[0] + curr.client[0] / points.length,
                prev.client[1] + curr.client[1] / points.length,
            ],
            canvas: [
                prev.canvas[0] + curr.canvas[0] / points.length,
                prev.canvas[1] + curr.canvas[1] / points.length,
            ],
            world: [
                prev.world[0] + curr.world[0] / points.length,
                prev.world[1] + curr.world[1] / points.length,
                prev.world[2] + curr.world[2] / points.length,
            ],
            touch: {
                identifier: null,
                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,
                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,
                force: prev.touch.force + curr.touch.force / points.length,
                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,
            },
        };
    }, {
        page: [0, 0],
        client: [0, 0],
        canvas: [0, 0],
        world: [0, 0, 0],
        touch: {
            identifier: null,
            radiusX: 0,
            radiusY: 0,
            force: 0,
            rotationAngle: 0,
        },
    });
}
function _subtractPoints2D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1]];
}
function _subtractPoints3D(point0, point1) {
    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];
}
function _getMeanDistanceBetweenAllIPoints(points) {
    const pairedDistance = [];
    for (let i = 0; i < points.length; i++) {
        for (let j = 0; j < points.length; j++) {
            if (i < j) {
                pairedDistance.push({
                    page: _getDistance2D(points[i].page, points[j].page),
                    client: _getDistance2D(points[i].client, points[j].client),
                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),
                    world: _getDistance3D(points[i].world, points[j].world),
                });
            }
        }
    }
    return pairedDistance.reduce((prev, curr) => {
        return {
            page: prev.page + curr.page / pairedDistance.length,
            client: prev.client + curr.client / pairedDistance.length,
            canvas: prev.canvas + curr.canvas / pairedDistance.length,
            world: prev.world + curr.world / pairedDistance.length,
        };
    }, {
        page: 0,
        client: 0,
        canvas: 0,
        world: 0,
    });
}
function _getDistance2D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));
}
function _getDistance3D(point0, point1) {
    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +
        Math.pow(point0[1] - point1[1], 2) +
        Math.pow(point0[2] - point1[2], 2));
}



/***/ }),

/***/ 94779:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ triggerAnnotationRenderForToolGroupIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77609);



function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {
    toolGroupIds.forEach((toolGroupId) => {
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroup)(toolGroupId);
        if (!toolGroup) {
            console.warn(`ToolGroup not available for ${toolGroupId}`);
            return;
        }
        const viewportsInfo = toolGroup.getViewportsInfo();
        viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(renderingEngineId);
            if (!renderingEngine) {
                console.warn(`RenderingEngine not available for ${renderingEngineId}`);
                return;
            }
            const viewport = renderingEngine.getViewport(viewportId);
            (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element);
        });
    });
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (triggerAnnotationRenderForToolGroupIds)));


/***/ }),

/***/ 58640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   t: () => (/* binding */ triggerAnnotationRenderForViewportIds)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56069);


function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {
    if (!viewportIdsToRender.length) {
        return;
    }
    viewportIdsToRender.forEach((viewportId) => {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
        if (!enabledElement) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const { viewport } = enabledElement;
        if (!viewport) {
            console.warn(`Viewport not available for ${viewportId}`);
            return;
        }
        const element = viewport.element;
        (0,_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(element);
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRenderForViewportIds);


/***/ }),

/***/ 19027:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isViewportPreScaled: () => (/* reexport safe */ _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__.u)
/* harmony export */ });
/* harmony import */ var _isViewportPreScaled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18990);




/***/ }),

/***/ 18990:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ isViewportPreScaled)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function isViewportPreScaled(viewport, targetId) {
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
        const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
        const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;
    }
    else if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
        const { preScale } = viewport.getImageData() || {};
        return !!preScale?.scaled;
    }
    else {
        return false;
    }
}



/***/ }),

/***/ 60810:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterViewportsWithToolEnabled: () => (/* reexport safe */ _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   getViewportIdsWithToolToRender: () => (/* reexport safe */ _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__.A)
/* harmony export */ });
/* harmony import */ var _filterViewportsWithFrameOfReferenceUID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3198);
/* harmony import */ var _filterViewportsWithToolEnabled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9356);
/* harmony import */ var _getViewportIdsWithToolToRender__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14543);
/* harmony import */ var _filterViewportsWithParallelNormals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67514);







/***/ }),

/***/ 20646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ ColorbarRangeTextPosition)
/* harmony export */ });
var ColorbarRangeTextPosition;
(function (ColorbarRangeTextPosition) {
    ColorbarRangeTextPosition["Top"] = "top";
    ColorbarRangeTextPosition["Left"] = "left";
    ColorbarRangeTextPosition["Bottom"] = "bottom";
    ColorbarRangeTextPosition["Right"] = "right";
})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));


/***/ }),

/***/ 51807:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorbarRangeTextPosition: () => (/* reexport safe */ _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__.U)
/* harmony export */ });
/* harmony import */ var _ColorbarRangeTextPosition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20646);



/***/ }),

/***/ 62612:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   kP: () => (/* binding */ DesiredOutputPrecision)
/* harmony export */ });
/* unused harmony exports AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, PointGhostTypes, ghostArrayName */
const AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
const AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
const CellGhostTypes = {
  DUPLICATECELL: 1,
  // the cell is present on multiple processors
  HIGHCONNECTIVITYCELL: 2,
  // the cell has more neighbors than in a regular mesh
  LOWCONNECTIVITYCELL: 4,
  // the cell has less neighbors than in a regular mesh
  REFINEDCELL: 8,
  // other cells are present that refines it.
  EXTERIORCELL: 16,
  // the cell is on the exterior of the data set
  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.
};

const PointGhostTypes = {
  DUPLICATEPOINT: 1,
  // the cell is present on multiple processors
  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.
};

const AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3 // all of the above
};

const ghostArrayName = 'vtkGhostType';
const DesiredOutputPrecision = {
  DEFAULT: 0,
  // use the point type that does not truncate any data
  SINGLE: 1,
  // use Float32Array
  DOUBLE: 2 // use Float64Array
};

var Constants = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};




/***/ }),

/***/ 58498:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkImageData$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _DataSet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69147);
/* harmony import */ var _StructuredData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24964);
/* harmony import */ var _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(85278);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3823);








const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkImageData methods
// ----------------------------------------------------------------------------

function vtkImageData(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageData');
  publicAPI.setExtent = function () {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = _StructuredData_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].getDataDescriptionFromExtent */ .A.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function () {
    let i;
    let j;
    let k;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (arguments.length === 1) {
      const array = arguments.length <= 0 ? undefined : arguments[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? undefined : arguments[0];
      j = arguments.length <= 1 ? undefined : arguments[1];
      k = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      vtkErrorMacro('Bad dimension specification');
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;
    for (let i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = index => {
    const dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro('Requesting a point from an empty image.');
      return null;
    }
    const ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.EMPTY:
        return null;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.SINGLE_POINT:
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.X_LINE:
        ijk[0] = index;
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.Y_LINE:
        ijk[1] = index;
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.Z_LINE:
        ijk[2] = index;
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.XY_PLANE:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0];
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.YZ_PLANE:
        ijk[1] = index % dims[1];
        ijk[2] = index / dims[1];
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.XZ_PLANE:
        ijk[0] = index % dims[0];
        ijk[2] = index / dims[0];
        break;
      case _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.XYZ_GRID:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0] % dims[1];
        ijk[2] = index / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro('Invalid dataDescription');
        break;
    }
    const coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };

  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;
  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;
  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;
  // virtual vtkIdType FindPoint(double x, double y, double z)
  // {
  //   return this->vtkDataSet::FindPoint(x, y, z);
  // }
  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;
  // vtkIdType FindCell(
  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,
  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;
  // vtkIdType FindCell(
  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,
  //   vtkIdType cellId, double tol2, int& subId,
  //   double pcoords[3], double *weights) VTK_OVERRIDE;
  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,
  //                                 double tol2, int& subId, double pcoords[3],
  //                                 double *weights) VTK_OVERRIDE;
  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;
  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE
  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,
  //                                     this->GetDimensions());}
  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE
  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}
  // void ComputeBounds() VTK_OVERRIDE;
  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest

  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  publicAPI.extentToBounds = ex => _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].transformBounds */ .Ay.transformBounds(ex, model.indexToWorld);
  publicAPI.getSpatialExtent = () => _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].inflate */ .Ay.inflate([...model.extent], 0.5);

  // Internal, shouldn't need to call this manually.
  publicAPI.computeTransforms = () => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .mat4.fromTranslation */ .pB.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .mat4.scale */ .pB.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .mat4.invert */ .pB.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.indexToWorld = function (ain) {
    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.transformMat4 */ .eR.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function (ain) {
    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .vec3.transformMat4 */ .eR.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function (bin) {
    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].transformBounds */ .Ay.transformBounds(bin, model.indexToWorld, bout);
  };
  publicAPI.worldToIndexBounds = function (bin) {
    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].transformBounds */ .Ay.transformBounds(bin, model.worldToIndex, bout);
  };

  // Make sure the transform is correct
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();
  publicAPI.getCenter = () => _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCenter */ .Ay.getCenter(publicAPI.getBounds());
  publicAPI.computeHistogram = function (worldBounds) {
    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    _BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].computeCornerPoints */ .Ay.computeCornerPoints(bounds, point1, point2);
    (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.b)(point1, point1);
    (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.b)(point2, point2);
    const dimensions = publicAPI.getDimensions();
    (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.c)(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.c)(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];
    const pixels = publicAPI.getPointData().getScalars().getData();
    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;
    for (let z = point1[2]; z <= point2[2]; z++) {
      for (let y = point1[1]; y <= point2[1]; y++) {
        let index = point1[0] + y * yStride + z * zStride;
        for (let x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {
            const pixel = pixels[index];
            if (pixel > maximum) maximum = pixel;
            if (pixel < minimum) minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index;
        }
      }
    }
    const average = inum > 0 ? isum / inum : 0;
    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    const sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };

  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).
  // Scalar data could be tuples for color information?
  publicAPI.computeIncrements = function (extent) {
    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const increments = [];
    let incr = numberOfComponents;

    // Calculate array increment offsets
    // similar to c++ vtkImageData::ComputeIncrements
    for (let idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };

  /**
   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.
   * @return {Number} the corresponding flattened index in the scalar array
   */
  publicAPI.computeOffsetIndex = _ref => {
    let [i, j, k] = _ref;
    const extent = publicAPI.getExtent();
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent, numberOfComponents);
    // Use the array increments to find the pixel index
    // similar to c++ vtkImageData::GetArrayPointer
    // Math.floor to catch "practically 0" e^-15 scenarios.
    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
  };

  /**
   * @param {Number[]} xyz the [x,y,z] Array in world coordinates
   * @return {Number|NaN} the corresponding pixel's index in the scalar array
   */
  publicAPI.getOffsetIndexFromWorld = xyz => {
    const extent = publicAPI.getExtent();
    const index = publicAPI.worldToIndex(xyz);

    // Confirm indexed i,j,k coords are within the bounds of the volume
    for (let idx = 0; idx < 3; ++idx) {
      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);
        return NaN;
      }
    }

    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream
    return publicAPI.computeOffsetIndex(index);
  };
  /**
   * @param {Number[]} xyz the [x,y,z] Array in world coordinates
   * @param {Number?} comp the scalar component index for multi-component scalars
   * @return {Number|NaN} the corresponding pixel's scalar value
   */
  publicAPI.getScalarValueFromWorld = function (xyz) {
    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      // VTK Error Macro will have been tripped already, no need to do it again,
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  direction: null,
  // a mat3
  indexToWorld: null,
  // a mat4
  worldToIndex: null,
  // a mat4
  spacing: [1.0, 1.0, 1.0],
  origin: [0.0, 0.0, 0.0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: _StructuredData_Constants_js__WEBPACK_IMPORTED_MODULE_5__/* .StructuredType */ .e.EMPTY
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _DataSet_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = gl_matrix__WEBPACK_IMPORTED_MODULE_6__/* .mat3.identity */ .w0.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);

  // Set/Get methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['direction'], 9);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['extent'], 6);

  // Object specific methods
  vtkImageData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkImageData');

// ----------------------------------------------------------------------------

var vtkImageData$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 642:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkColorTransferFunction$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _Common_Core_ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80993);
/* harmony import */ var _ColorTransferFunction_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25128);





const {
  ColorSpace,
  Scale
} = _ColorTransferFunction_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  ScalarMappingTarget
} = _Common_Core_ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
const {
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
/* eslint-disable no-continue                                                */

// Convert to and from a special polar version of CIELAB (useful for creating
// continuous diverging color maps).
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  const L = lab[0];
  const a = lab[1];
  const b = lab[2];
  const M = Math.sqrt(L * L + a * a + b * b);
  const s = M > 0.001 ? Math.acos(L / M) : 0.0;
  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  const M = msh[0];
  const s = msh[1];
  const h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}

// For the case when interpolating from a saturated color to an unsaturated
// color, find a hue for the unsaturated color that makes sense.
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    // The best we can do is hold hue constant.
    return msh[2];
  }

  // This equation is designed to make the perceptual change of the
  // interpolation to be close to constant.
  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  // Spin hue away from 0 except in purple hues.
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  let adiff = a1 - a2;
  if (adiff < 0.0) {
    adiff = -adiff;
  }
  while (adiff >= 2.0 * Math.PI) {
    adiff -= 2.0 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2.0 * Math.PI - adiff;
  }
  return adiff;
}

// Interpolate a diverging color map.
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  const lab1 = [];
  const lab2 = [];
  (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb1, lab1);
  (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb2, lab2);
  const msh1 = [];
  const msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);

  // If the endpoints are distinct saturated colors, then place white in between
  // them.
  let localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    // Insert the white midpoint by setting one end to white and adjusting the
    // scalar value.
    let Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88.0, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0.0;
      msh2[2] = 0.0;
      localS *= 2.0;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0.0;
      msh1[2] = 0.0;
      localS = 2.0 * localS - 1.0;
    }
  }

  // If one color has no saturation, then its hue value is invalid.  In this
  // case, we want to set it to something logical so that the interpolation of
  // hue makes sense.
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  const mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];

  // Now convert back to RGB
  const labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.O)(labTmp, result);
}

// ----------------------------------------------------------------------------
// vtkColorTransferFunction methods
// ----------------------------------------------------------------------------

function vtkColorTransferFunction(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkColorTransferFunction');

  // Return the number of points which specify this function
  publicAPI.getSize = () => model.nodes.length;

  //----------------------------------------------------------------------------
  // Add a point defined in RGB
  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);

  //----------------------------------------------------------------------------
  // Add a point defined in RGB
  publicAPI.addRGBPointLong = function (x, r, g, b) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;
    // Error check
    if (midpoint < 0.0 || midpoint > 1.0) {
      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');
      return -1;
    }
    if (sharpness < 0.0 || sharpness > 1.0) {
      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');
      return -1;
    }

    // remove any node already at this X location
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }

    // Create the new node
    const node = {
      x,
      r,
      g,
      b,
      midpoint,
      sharpness
    };

    // Add it, then sort to get everything in order
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();

    // We need to find the index of the node we just added in order
    // to return this value
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If we didn't find it, something went horribly wrong so
    // return -1
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };

  //----------------------------------------------------------------------------
  // Add a point defined in HSV
  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);

  //----------------------------------------------------------------------------
  // Add a point defined in HSV
  publicAPI.addHSVPointLong = function (x, h, s, v) {
    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;
    const rgb = [];
    const hsv = [h, s, v];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };

  //----------------------------------------------------------------------------
  // Set nodes directly
  publicAPI.setNodes = nodes => {
    if (model.nodes !== nodes) {
      const before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      const after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };

  //----------------------------------------------------------------------------
  // Sort the vector in increasing order, then fill in
  // the Range
  publicAPI.sortAndUpdateRange = () => {
    const before = JSON.stringify(model.nodes);
    model.nodes.sort((a, b) => a.x - b.x);
    const after = JSON.stringify(model.nodes);
    const modifiedInvoked = publicAPI.updateRange();
    // If range is updated, Modified() has been called, don't call it again.
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };

  //----------------------------------------------------------------------------
  publicAPI.updateRange = () => {
    const oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    const size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }

    // If the range is the same, then no need to call Modified()
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };

  //----------------------------------------------------------------------------
  // Remove a point
  publicAPI.removePoint = x => {
    // First find the node since we need to know its
    // index as our return value
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    const retVal = i;

    // If the node doesn't exist, we return -1
    if (i >= model.nodes.length) {
      return -1;
    }

    // If the first or last point has been removed, then we update the range
    // No need to sort here as the order of points hasn't changed.
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };

  //----------------------------------------------------------------------------
  publicAPI.movePoint = (oldX, newX) => {
    if (oldX === newX) {
      // Nothing to do.
      return;
    }
    publicAPI.removePoint(newX);
    for (let i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };

  //----------------------------------------------------------------------------
  // Remove all points
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  // Add a line defined in RGB
  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {
    // First, find all points in this range and remove them
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }

    // Now add the points
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // Add a line defined in HSV
  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {
    const hsv1 = [h1, s1, v1];
    const hsv2 = [h2, s2, v2];
    const rgb1 = [];
    const rgb2 = [];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsv1, rgb1);
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };

  //----------------------------------------------------------------------------
  // Returns the RGBA color evaluated at the specified location
  publicAPI.mapValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];
  };

  //----------------------------------------------------------------------------
  // Returns the RGB color evaluated at the specified location
  publicAPI.getColor = (x, rgb) => {
    if (model.indexedLookup) {
      const numNodes = publicAPI.getSize();
      // todo
      const idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        const nanColor = publicAPI.getNanColorByReference();
        rgb[0] = nanColor[0];
        rgb[1] = nanColor[1];
        rgb[2] = nanColor[2];
      } else {
        const nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.
        rgb[0] = nodeVal[1];
        rgb[1] = nodeVal[2];
        rgb[2] = nodeVal[3];
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };

  //----------------------------------------------------------------------------
  // Returns the red color evaluated at the specified location
  publicAPI.getRedValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };

  //----------------------------------------------------------------------------
  // Returns the green color evaluated at the specified location
  publicAPI.getGreenValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };

  //----------------------------------------------------------------------------
  // Returns the blue color evaluated at the specified location
  publicAPI.getBlueValue = x => {
    const rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };

  //----------------------------------------------------------------------------
  // Returns a table of RGB colors at regular intervals along the function
  publicAPI.getTable = (xStart_, xEnd_, size, table) => {
    // To handle BigInt limitation
    const xStart = Number(xStart_);
    const xEnd = Number(xEnd_);

    // Special case: If either the start or end is a NaN, then all any
    // interpolation done on them is also a NaN.  Therefore, fill the table with
    // the NaN color.
    if ((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.i)(xStart) || (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.i)(xEnd)) {
      for (let i = 0; i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    let idx = 0;
    const numNodes = model.nodes.length;

    // Need to keep track of the last value so that
    // we can fill in table locations past this with
    // this value if Clamping is On.
    let lastR = 0.0;
    let lastG = 0.0;
    let lastB = 0.0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    let x = 0.0;
    let x1 = 0.0;
    let x2 = 0.0;
    const rgb1 = [0.0, 0.0, 0.0];
    const rgb2 = [0.0, 0.0, 0.0];
    let midpoint = 0.0;
    let sharpness = 0.0;
    const tmpVec = [];

    // If the scale is logarithmic, make sure the range is valid.
    let usingLogScale = model.scale === Scale.LOG10;
    if (usingLogScale) {
      // Note: This requires range[0] <= range[1].
      usingLogScale = model.mappingRange[0] > 0.0;
    }
    let logStart = 0.0;
    let logEnd = 0.0;
    let logX = 0.0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }

    // For each table entry
    for (let i = 0; i < size; i++) {
      // Find our location in the table
      const tidx = 3 * i;

      // Find our X location. If we are taking only 1 sample, make
      // it halfway between start and end (usually start and end will
      // be the same in this case)
      if (size > 1) {
        if (usingLogScale) {
          logX = logStart + i / (size - 1.0) * (logEnd - logStart);
          x = 10.0 ** logX;
        } else {
          x = xStart + i / (size - 1.0) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = 10.0 ** logX;
      } else {
        x = 0.5 * (xStart + xEnd);
      }

      // Linearly map x from mappingRange to [0, numberOfValues-1],
      // discretize (round down to the closest integer),
      // then map back to mappingRange
      if (model.discretize) {
        const range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          const numberOfValues = model.numberOfValues;
          const deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2.0;
          } else {
            // normalize x
            const xn = (x - range[0]) / deltaRange;
            // discretize
            const discretizeIndex = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.K)(numberOfValues * xn);
            // get discretized x
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }

      // Do we need to move to the next node?
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        // If we are at a valid point index, fill in
        // the value at this node, and the one before (the
        // two that surround our current sample location)
        // idx cannot be 0 since we just incremented it.
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;

          // We only need the previous midpoint and sharpness
          // since these control this region
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;

          // Move midpoint away from extreme ends of range to avoid
          // degenerate math
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }

      // Are we at or past the end? If so, just use the last value
      if (x > model.mappingRange[1]) {
        table[tidx] = 0.0;
        table[tidx + 1] = 0.0;
        table[tidx + 2] = 0.0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.L)(x) && x < 0) {
        // we are before the first node? If so, duplicate this node's values.
        // We have to deal with -inf here
        table[tidx] = 0.0;
        table[tidx + 1] = 0.0;
        table[tidx + 2] = 0.0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0.0;
          table[tidx + 1] = 0.0;
          table[tidx + 2] = 0.0;
        }
      } else {
        // OK, we are between two nodes - interpolate
        // Our first attempt at a normalized location [0,1] -
        // we will be modifying this based on midpoint and
        // sharpness to get the curve shape we want and to have
        // it pass through (y1+y2)/2 at the midpoint.
        let s = 0.0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }

        // Readjust based on the midpoint - linear adjustment
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);
        }

        // override for sharpness > 0.99
        // In this case we just want piecewise constant
        if (sharpness > 0.99) {
          // Use the first value since we are below the midpoint
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            // Use the second value at or above the midpoint
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }

        // Override for sharpness < 0.01
        // In this case we want piecewise linear
        if (sharpness < 0.01) {
          // Simple linear interpolation
          if (model.colorSpace === ColorSpace.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace.HSV) {
            const hsv1 = [];
            const hsv2 = [];
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.M)(rgb1, hsv1);
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.M)(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1.0;
              } else {
                hsv2[0] -= 1.0;
              }
            }
            const hsvTmp = [];
            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0.0) {
              hsvTmp[0] += 1.0;
            }
            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];

            // Now convert this back to RGB
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace.LAB) {
            const lab1 = [];
            const lab2 = [];
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb1, lab1);
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb2, lab2);
            const labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];

            // Now convert back to RGB
            (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.O)(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);
          }
          continue;
        }

        // We have a sharpness between [0.01, 0.99] - we will
        // used a modified hermite curve interpolation where we
        // derive the slope based on the sharpness, and we compress
        // the curve non-linearly based on the sharpness

        // First, we will adjust our position based on sharpness in
        // order to make the curve sharper (closer to piecewise constant)
        if (s < 0.5) {
          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);
        } else if (s > 0.5) {
          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);
        }

        // Compute some coefficients we will need for the hermite curve
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2.0 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;
        let slope;
        let t;
        if (model.colorSpace === ColorSpace.RGB) {
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = rgb2[j] - rgb1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace.HSV) {
          const hsv1 = [];
          const hsv2 = [];
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.M)(rgb1, hsv1);
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.M)(rgb2, hsv2);
          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
            if (hsv1[0] > hsv2[0]) {
              hsv1[0] -= 1.0;
            } else {
              hsv2[0] -= 1.0;
            }
          }
          const hsvTmp = [];
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = hsv2[j] - hsv1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;
            if (j === 0 && hsvTmp[j] < 0.0) {
              hsvTmp[j] += 1.0;
            }
          }
          // Now convert this back to RGB
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace.LAB) {
          const lab1 = [];
          const lab2 = [];
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb1, lab1);
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.N)(rgb2, lab2);
          const labTmp = [];
          for (let j = 0; j < 3; j++) {
            // Use one slope for both end points
            slope = lab2[j] - lab1[j];
            t = (1.0 - sharpness) * slope;

            // Compute the value
            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;
          }
          // Now convert this back to RGB
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.O)(labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace.DIVERGING) {
          // I have not implemented proper interpolation by a hermite curve for
          // the diverging color map, but I cannot think of a good use case for
          // that anyway.
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro('ColorSpace set to invalid value.');
        }

        // Final error check to make sure we don't go outside [0,1]
        for (let j = 0; j < 3; j++) {
          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];
          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];
        }
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getUint8Table = function (xStart, xEnd, size) {
    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro('Attempting to lookup a value with no points in the function');
      return model.table;
    }
    const nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    const tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (let i = 0; i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromArray = array => {
    publicAPI.removeAllPoints();
    const numComponents = array.getNumberOfComponents();
    for (let i = 0; i < array.getNumberOfTuples(); i++) {
      switch (numComponents) {
        case 3:
          {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: 0.5,
              sharpness: 0.0
            });
            break;
          }
        case 4:
          {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: 0.5,
              sharpness: 0.0
            });
            break;
          }
        case 5:
          {
            model.nodes.push({
              x: i,
              r: array.getComponent(i, 0),
              g: array.getComponent(i, 1),
              b: array.getComponent(i, 2),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
        case 6:
          {
            model.nodes.push({
              x: array.getComponent(i, 0),
              r: array.getComponent(i, 1),
              g: array.getComponent(i, 2),
              b: array.getComponent(i, 3),
              midpoint: array.getComponent(i, 4),
              sharpness: array.getComponent(i, 5)
            });
            break;
          }
      }
    }
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {
    let inc = 0.0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1.0);
    }
    for (let i = 0; i < size; i++) {
      const node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0.0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };

  //----------------------------------------------------------------------------
  // For a specified index value, get the node parameters
  publicAPI.getNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].r;
    val[2] = model.nodes[index].g;
    val[3] = model.nodes[index].b;
    val[4] = model.nodes[index].midpoint;
    val[5] = model.nodes[index].sharpness;
    return 1;
  };

  //----------------------------------------------------------------------------
  // For a specified index value, get the node parameters
  publicAPI.setNodeValue = (index, val) => {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].r = val[1];
    model.nodes[index].g = val[2];
    model.nodes[index].b = val[3];
    model.nodes[index].midpoint = val[4];
    model.nodes[index].sharpness = val[5];
    if (oldX !== val[0]) {
      // The point has been moved, the order of points or the range might have
      // been modified.
      publicAPI.sortAndUpdateRange();
      // No need to call Modified() here because SortAndUpdateRange() has done it
      // already.
    } else {
      publicAPI.modified();
    }
    return 1;
  };

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAvailableColors = () => {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      // Not sure if this is correct since it is only set if
      // "const unsigned char *::GetTable(double xStart, double xEnd,int size)"
      // has been called.
      return model.tableSize;
    }
    const nNodes = model.nodes?.length ?? 0;
    // The minimum is 4094 colors so that it fills in the 4096 texels texture in `mapScalarsToTexture`
    return Math.max(4094, nNodes);
  };

  //----------------------------------------------------------------------------
  publicAPI.getIndexedColor = (idx, rgba) => {
    const n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      const nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (let j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1.0; // NodeColor is RGB-only.
      return;
    }
    const nanColor = publicAPI.getNanColorByReference();
    rgba[0] = nanColor[0];
    rgba[1] = nanColor[1];
    rgba[2] = nanColor[2];
    rgba[3] = 1.0; // NanColor is RGB-only.
  };

  //----------------------------------------------------------------------------
  publicAPI.fillFromDataPointer = (nb, ptr) => {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (let i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.setMappingRange = (min, max) => {
    const range = [min, max];
    const originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro('attempt to set zero width color range');
      return;
    }
    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    const shift = range[0] - originalRange[0] * scale;
    for (let i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.adjustRange = range => {
    const functionRange = publicAPI.getRange();

    // Make sure we have points at each end of the range
    const rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }

    // Remove all points out-of-range
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };

  //--------------------------------------------------------------------------
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };

  //----------------------------------------------------------------------------
  publicAPI.findMinimumXDistance = () => {
    if (model.nodes.length < 2) {
      return -1.0;
    }
    let distance = Number.MAX_VALUE;
    for (let i = 0; i < model.nodes.length - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro('Transfer Function Has No Points!');
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.mapData = (input, output, outFormat, inputOffset) => {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro('Transfer Function Has No Points!');
      return;
    }
    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    const rgb = [];
    if (outFormat === ScalarMappingTarget.RGBA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget.RGB) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);
        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);
        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {
      for (let i = 0; i < length; i++) {
        const x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[i * 2 + 1] = alpha;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.applyColorMap = colorMap => {
    const oldColorSpace = JSON.stringify(model.colorSpace);
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === undefined) {
        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);
        model.colorSpace = ColorSpace.RGB;
      }
    }
    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);
    const oldNanColor = isModified || JSON.stringify(model.nanColor);
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1.0);
      }
    }
    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);
    const oldNodes = isModified || JSON.stringify(model.nodes);
    if (colorMap.RGBPoints) {
      const size = colorMap.RGBPoints.length;
      model.nodes = [];
      const midpoint = 0.5;
      const sharpness = 0.0;
      for (let i = 0; i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    const modifiedInvoked = publicAPI.sortAndUpdateRange();
    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));
    if (callModified) publicAPI.modified();
    return modifiedInvoked || callModified;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  clamping: true,
  colorSpace: ColorSpace.RGB,
  hSVWrap: true,
  scale: Scale.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Common_Core_ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Internal objects initialization
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0.0, 0.0, 1.0];
  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];
  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];
  model.buildTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.buildTime);

  // Create get-only macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['buildTime', 'mappingRange']);

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'discretize', 'numberOfValues', {
    type: 'enum',
    name: 'colorSpace',
    enum: ColorSpace
  }, {
    type: 'enum',
    name: 'scale',
    enum: Scale
  }]);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkColorTransferFunction(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkColorTransferFunction');

// ----------------------------------------------------------------------------

var vtkColorTransferFunction$1 = {
  newInstance,
  extend,
  ..._ColorTransferFunction_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay
};




/***/ }),

/***/ 9175:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   angle: () => (/* binding */ angle),
/* harmony export */   bezier: () => (/* binding */ bezier),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   hermite: () => (/* binding */ hermite),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat3: () => (/* binding */ transformMat3),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ 44779:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ zip)
/* harmony export */ });
/* harmony import */ var _transpose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43183);


function zip() {
  return (0,_transpose_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(arguments);
}


/***/ }),

/***/ 20919:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}


/***/ })

}]);