(self["webpackChunk"] = self["webpackChunk"] || []).push([[2482],{

/***/ 46347:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(660);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99341);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49038);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71851);
/* harmony import */ var _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41864);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10364);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26896);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(69372);
/* harmony import */ var _utilities_colormap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13859);
/* harmony import */ var _utilities_invertRgbTransferFunction__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(50134);
/* harmony import */ var _utilities_createSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(40256);
/* harmony import */ var _utilities_transformWorldToIndex__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(38669);
/* harmony import */ var _utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(85745);
/* harmony import */ var _helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(61640);
/* harmony import */ var _helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(90740);
/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(10056);
/* harmony import */ var _vtkClasses_vtkSlabCamera__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(17232);
/* harmony import */ var _utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(61375);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(98039);
/* harmony import */ var _utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(80500);
/* harmony import */ var _utilities_getVoiFromSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(70210);
/* harmony import */ var _utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(74638);
/* harmony import */ var _utilities_applyPreset__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(96833);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(39537);
/* harmony import */ var _utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(80221);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(74876);






























class BaseVolumeViewport extends _Viewport__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .A {
    constructor(props) {
        super(props);
        this.useCPURendering = false;
        this.perVolumeIdDefaultProperties = new Map();
        this.viewportProperties = {};
        this.volumeIds = new Set();
        this.setRotation = (rotation) => {
            const panFit = this.getPan(this.fitToCanvasCamera);
            const pan = this.getPan();
            const previousCamera = this.getCamera();
            const panSub = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.sub */ .Zc.sub([0, 0], panFit, pan);
            this.setPan(panSub, false);
            const { flipVertical } = this.getCamera();
            const initialViewUp = flipVertical
                ? gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate([0, 0, 0], this.initialViewUp)
                : this.initialViewUp;
            this.setCameraNoEvent({
                viewUp: initialViewUp,
            });
            this.rotateCamera(rotation);
            const afterPan = this.getPan();
            const afterPanFit = this.getPan(this.fitToCanvasCamera);
            const newCenter = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.sub */ .Zc.sub([0, 0], afterPan, afterPanFit);
            const newOffset = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.add */ .Zc.add([0, 0], panFit, newCenter);
            this.setPan(newOffset, false);
            if (this._suppressCameraModifiedEvents) {
                return;
            }
            const camera = this.getCamera();
            const eventDetail = {
                previousCamera,
                camera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, eventDetail);
        };
        this.getDefaultProperties = (volumeId) => {
            let volumeProperties;
            if (volumeId !== undefined) {
                volumeProperties = this.perVolumeIdDefaultProperties.get(volumeId);
            }
            if (volumeProperties !== undefined) {
                return volumeProperties;
            }
            return {
                ...this.globalDefaultProperties,
            };
        };
        this.getProperties = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                return;
            }
            const { colormap: latestColormap, VOILUTFunction, interpolationType, invert, slabThickness, preset, } = this.viewportProperties;
            volumeId ||= this.getVolumeId();
            const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeId);
            if (!volume) {
                return null;
            }
            const volumeActorEntry = this.getActors().find((actorEntry) => {
                return actorEntry.referencedId === volumeId;
            });
            if (!volumeActorEntry) {
                return;
            }
            const volumeActor = volumeActorEntry.actor;
            const cfun = volumeActor.getProperty().getRGBTransferFunction(0);
            const [lower, upper] = this.viewportProperties?.VOILUTFunction === 'SIGMOID'
                ? (0,_utilities_getVoiFromSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_23__/* ["default"] */ .A)(cfun)
                : cfun.getRange();
            const voiRange = { lower, upper };
            const volumeColormap = this.getColormap(volumeId);
            const colormap = volumeId && volumeColormap ? volumeColormap : latestColormap;
            return {
                colormap: colormap,
                voiRange: voiRange,
                VOILUTFunction: VOILUTFunction,
                interpolationType: interpolationType,
                invert: invert,
                slabThickness: slabThickness,
                preset,
            };
        };
        this.getColormap = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                return;
            }
            const { volumeActor } = applicableVolumeActorInfo;
            const cfun = this._getOrCreateColorTransferFunction(volumeId);
            const { nodes } = cfun.getState();
            const RGBPoints = nodes.reduce((acc, node) => {
                acc.push(node.x, node.r, node.g, node.b);
                return acc;
            }, []);
            const matchedColormap = (0,_utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.findMatchingColormap)(RGBPoints, volumeActor);
            return matchedColormap;
        };
        this.getRotation = () => {
            const { viewUp: currentViewUp, viewPlaneNormal, flipVertical, } = this.getCameraNoRotation();
            const initialViewUp = flipVertical
                ? gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate([0, 0, 0], this.initialViewUp)
                : this.initialViewUp;
            if (!initialViewUp) {
                return 0;
            }
            const initialToCurrentViewUpAngle = (gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.angle */ .eR.angle(initialViewUp, currentViewUp) * 180) / Math.PI;
            const initialToCurrentViewUpCross = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross([0, 0, 0], initialViewUp, currentViewUp);
            const normalDot = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(initialToCurrentViewUpCross, viewPlaneNormal);
            const value = normalDot >= 0
                ? initialToCurrentViewUpAngle
                : (360 - initialToCurrentViewUpAngle) % 360;
            return value;
        };
        this.getFrameOfReferenceUID = () => {
            return this._FrameOfReferenceUID;
        };
        this.canvasToWorld = (canvasPos) => {
            const vtkCamera = this.getVtkActiveCamera();
            vtkCamera.setIsPerformingCoordinateTransformation?.(true);
            const renderer = this.getRenderer();
            const displayCoords = this.getVtkDisplayCoords(canvasPos);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const worldCoord = openGLRenderWindow.displayToWorld(displayCoords[0], displayCoords[1], displayCoords[2], renderer);
            vtkCamera.setIsPerformingCoordinateTransformation?.(false);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.getVtkDisplayCoords = (canvasPos) => {
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = [
                canvasPosWithDPR[0] + this.sx,
                canvasPosWithDPR[1] + this.sy,
            ];
            displayCoord[1] = size[1] - displayCoord[1];
            return [displayCoord[0], displayCoord[1], 0];
        };
        this.worldToCanvas = (worldPos) => {
            const vtkCamera = this.getVtkActiveCamera();
            vtkCamera.setIsPerformingCoordinateTransformation?.(true);
            const renderer = this.getRenderer();
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
            displayCoord[1] = size[1] - displayCoord[1];
            const canvasCoord = [
                displayCoord[0] - this.sx,
                displayCoord[1] - this.sy,
            ];
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasCoordWithDPR = [
                canvasCoord[0] / devicePixelRatio,
                canvasCoord[1] / devicePixelRatio,
            ];
            vtkCamera.setIsPerformingCoordinateTransformation(false);
            return canvasCoordWithDPR;
        };
        this.hasImageURI = (imageURI) => {
            const volumeActors = this.getActors().filter((actorEntry) => (0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume'));
            return volumeActors.some(({ uid, referencedId }) => {
                const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(referencedId || uid);
                if (!volume?.imageIds) {
                    return false;
                }
                const volumeImageURIs = volume.imageIds.map(_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_26__/* ["default"] */ .A);
                return volumeImageURIs.includes(imageURI);
            });
        };
        this.getImageIds = (volumeId) => {
            const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
            if (!applicableVolumeActorInfo) {
                throw new Error(`No actor found for the given volumeId: ${volumeId}`);
            }
            const volumeIdToUse = applicableVolumeActorInfo.volumeId;
            const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeIdToUse);
            if (!imageVolume) {
                throw new Error(`imageVolume with id: ${volumeIdToUse} does not exist in cache`);
            }
            return imageVolume.imageIds;
        };
        this.useCPURendering = (0,_init__WEBPACK_IMPORTED_MODULE_9__/* .getShouldUseCPURendering */ .LH)();
        if (this.useCPURendering) {
            throw new Error('VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.');
        }
        const renderer = this.getRenderer();
        const camera = _vtkClasses_vtkSlabCamera__WEBPACK_IMPORTED_MODULE_19__/* ["default"].newInstance */ .Ay.newInstance();
        renderer.setActiveCamera(camera);
        switch (this.type) {
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.ORTHOGRAPHIC:
                camera.setParallelProjection(true);
                break;
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.VOLUME_3D:
                camera.setParallelProjection(true);
                break;
            case _enums_ViewportType__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.PERSPECTIVE:
                camera.setParallelProjection(false);
                break;
            default:
                throw new Error(`Unrecognized viewport type: ${this.type}`);
        }
        this.initializeVolumeNewImageEventDispatcher();
    }
    static get useCustomRenderingPipeline() {
        return false;
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    applyViewOrientation(orientation, resetCamera = true) {
        const { viewPlaneNormal, viewUp } = this._getOrientationVectors(orientation);
        const camera = this.getVtkActiveCamera();
        camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        camera.setViewUpFrom(viewUp);
        this.initialViewUp = viewUp;
        if (resetCamera) {
            const t = this;
            t.resetCamera({ resetOrientation: false, resetRotation: false });
        }
    }
    initializeVolumeNewImageEventDispatcher() {
        const volumeNewImageHandlerBound = volumeNewImageHandler.bind(this);
        const volumeNewImageCleanUpBound = volumeNewImageCleanUp.bind(this);
        function volumeNewImageHandler(cameraEvent) {
            const { viewportId } = cameraEvent.detail;
            if (viewportId !== this.id || this.isDisabled) {
                return;
            }
            const viewportImageData = this.getImageData();
            if (!viewportImageData) {
                return;
            }
            (0,_helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .A)(cameraEvent);
        }
        function volumeNewImageCleanUp(evt) {
            const { viewportId } = evt.detail;
            if (viewportId !== this.id) {
                return;
            }
            this.element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
            _eventTarget__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
            (0,_helpers_volumeNewImageEventDispatcher__WEBPACK_IMPORTED_MODULE_17__/* .resetVolumeNewImageState */ .g)(viewportId);
        }
        this.element.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
        this.element.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.CAMERA_MODIFIED, volumeNewImageHandlerBound);
        _eventTarget__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_6__.Events.ELEMENT_DISABLED, volumeNewImageCleanUpBound);
    }
    setVOILUTFunction(voiLUTFunction, volumeId, suppressEvents) {
        if (!Object.values(_enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType).includes(voiLUTFunction)) {
            voiLUTFunction = _enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType.LINEAR;
        }
        const { voiRange } = this.getProperties();
        this.setVOI(voiRange, volumeId, suppressEvents);
        this.viewportProperties.VOILUTFunction = voiLUTFunction;
    }
    setColormap(colormap, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const cfun = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
        let colormapObj = _utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.getColormap(colormap.name);
        const { name } = colormap;
        if (!colormapObj) {
            colormapObj = _kitware_vtk_js_Rendering_Core_ColorTransferFunction_ColorMaps__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.getPresetByName(name);
        }
        if (!colormapObj) {
            throw new Error(`Colormap ${colormap} not found`);
        }
        const range = volumeActor
            .getProperty()
            .getRGBTransferFunction(0)
            .getRange();
        cfun.applyColorMap(colormapObj);
        cfun.setMappingRange(range[0], range[1]);
        volumeActor.getProperty().setRGBTransferFunction(0, cfun);
        this.viewportProperties.colormap = colormap;
        if (!suppressEvents) {
            const eventDetail = {
                viewportId: this.id,
                colormap,
                volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.COLORMAP_MODIFIED, eventDetail);
        }
    }
    setOpacity(colormap, volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const ofun = _kitware_vtk_js_Common_DataModel_PiecewiseFunction__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
        if (typeof colormap.opacity === 'number') {
            (0,_utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.updateOpacity)(volumeActor, colormap.opacity);
        }
        else {
            colormap.opacity.forEach(({ opacity, value }) => {
                ofun.addPoint(value, opacity);
            });
            volumeActor.getProperty().setScalarOpacity(0, ofun);
        }
        if (!this.viewportProperties.colormap) {
            this.viewportProperties.colormap = {};
        }
        this.viewportProperties.colormap.opacity = colormap.opacity;
    }
    setInvert(inverted, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const volumeIdToUse = applicableVolumeActorInfo.volumeId;
        const cfun = this._getOrCreateColorTransferFunction(volumeIdToUse);
        (0,_utilities_invertRgbTransferFunction__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(cfun);
        this.viewportProperties.invert = inverted;
        if (!suppressEvents) {
            const eventDetail = {
                ...this.getVOIModifiedEventDetail(volumeIdToUse),
                invertStateChanged: true,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
        }
    }
    getVOIModifiedEventDetail(volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        const volumeActor = applicableVolumeActorInfo.volumeActor;
        const transferFunction = volumeActor
            .getProperty()
            .getRGBTransferFunction(0);
        const range = transferFunction.getMappingRange();
        const matchedColormap = this.getColormap(volumeId);
        const { VOILUTFunction, invert } = this.getProperties(volumeId);
        return {
            viewportId: this.id,
            range: {
                lower: range[0],
                upper: range[1],
            },
            volumeId: applicableVolumeActorInfo.volumeId,
            VOILUTFunction: VOILUTFunction,
            colormap: matchedColormap,
            invert,
        };
    }
    _getOrCreateColorTransferFunction(volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return null;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const rgbTransferFunction = volumeActor
            .getProperty()
            .getRGBTransferFunction(0);
        if (rgbTransferFunction) {
            return rgbTransferFunction;
        }
        const newRGBTransferFunction = _kitware_vtk_js_Rendering_Core_ColorTransferFunction__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
        volumeActor.getProperty().setRGBTransferFunction(0, newRGBTransferFunction);
        return newRGBTransferFunction;
    }
    setInterpolationType(interpolationType, volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const volumeProperty = volumeActor.getProperty();
        volumeProperty.setInterpolationType(interpolationType);
        this.viewportProperties.interpolationType = interpolationType;
    }
    setVOI(voiRange, volumeId, suppressEvents = false) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        const volumeIdToUse = applicableVolumeActorInfo.volumeId;
        const voiRangeToUse = voiRange;
        if (typeof voiRangeToUse === 'undefined') {
            throw new Error('voiRangeToUse is undefined, need to implement this in the new volume model');
        }
        const { VOILUTFunction } = this.getProperties(volumeIdToUse);
        if (VOILUTFunction === _enums__WEBPACK_IMPORTED_MODULE_6__.VOILUTFunctionType.SAMPLED_SIGMOID) {
            const cfun = (0,_utilities_createSigmoidRGBTransferFunction__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .A)(voiRangeToUse);
            volumeActor.getProperty().setRGBTransferFunction(0, cfun);
        }
        else {
            const { lower, upper } = voiRangeToUse;
            volumeActor
                .getProperty()
                .getRGBTransferFunction(0)
                .setRange(lower, upper);
        }
        if (!suppressEvents) {
            const eventDetail = {
                ...this.getVOIModifiedEventDetail(volumeIdToUse),
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOI_MODIFIED, eventDetail);
        }
        this.viewportProperties.voiRange = voiRangeToUse;
    }
    rotateCamera(rotation) {
        const rotationToApply = rotation - this.getRotation();
        this.getVtkActiveCamera().roll(-rotationToApply);
    }
    setDefaultProperties(ViewportProperties, volumeId) {
        if (volumeId == null) {
            this.globalDefaultProperties = ViewportProperties;
        }
        else {
            this.perVolumeIdDefaultProperties.set(volumeId, ViewportProperties);
        }
    }
    clearDefaultProperties(volumeId) {
        if (volumeId == null) {
            this.globalDefaultProperties = {};
            this.resetProperties();
        }
        else {
            this.perVolumeIdDefaultProperties.delete(volumeId);
            this.resetToDefaultProperties(volumeId);
        }
    }
    getViewReference(viewRefSpecifier = {}) {
        const target = super.getViewReference(viewRefSpecifier);
        const volumeId = this.getVolumeId(viewRefSpecifier);
        if (viewRefSpecifier?.forFrameOfReference !== false) {
            target.volumeId = volumeId;
        }
        if (typeof viewRefSpecifier?.sliceIndex !== 'number') {
            return target;
        }
        const { viewPlaneNormal } = target;
        const delta = viewRefSpecifier?.sliceIndex - this.getSliceIndex();
        const { sliceRangeInfo } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
        const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
        const { focalPoint, position } = camera;
        const { newFocalPoint } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
        target.cameraFocalPoint = newFocalPoint;
        return target;
    }
    isReferenceViewable(viewRef, options) {
        if (!viewRef.FrameOfReferenceUID) {
            return false;
        }
        if (!super.isReferenceViewable(viewRef, options)) {
            return false;
        }
        if (options?.withNavigation) {
            return true;
        }
        const currentSliceIndex = this.getSliceIndex();
        const { sliceIndex } = viewRef;
        if (Array.isArray(sliceIndex)) {
            return (sliceIndex[0] <= currentSliceIndex && currentSliceIndex <= sliceIndex[1]);
        }
        return sliceIndex === undefined || sliceIndex === currentSliceIndex;
    }
    scroll(delta = 1) {
        const volumeId = this.getVolumeId();
        const { sliceRangeInfo } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
        if (!sliceRangeInfo) {
            return;
        }
        const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;
        const { focalPoint, viewPlaneNormal, position } = camera;
        const { newFocalPoint, newPosition } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
        this.setCamera({
            focalPoint: newFocalPoint,
            position: newPosition,
        });
        this.render();
    }
    setViewReference(viewRef) {
        if (!viewRef) {
            return;
        }
        const volumeId = this.getVolumeId();
        const { viewPlaneNormal: refViewPlaneNormal, FrameOfReferenceUID: refFrameOfReference, cameraFocalPoint, referencedImageId, viewUp, } = viewRef;
        let { sliceIndex } = viewRef;
        const { focalPoint, viewPlaneNormal, position } = this.getCamera();
        const isNegativeNormal = (0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* .isEqualNegative */ .WC)(viewPlaneNormal, refViewPlaneNormal);
        const isSameNormal = (0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Ay)(viewPlaneNormal, refViewPlaneNormal);
        if (typeof sliceIndex === 'number' &&
            volumeId !== undefined &&
            viewRef.volumeId === volumeId &&
            (isNegativeNormal || isSameNormal)) {
            const { currentStepIndex, sliceRangeInfo, numScrollSteps } = (0,_utilities_getVolumeViewportScrollInfo__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .A)(this, volumeId, true);
            const { sliceRange, spacingInNormalDirection } = sliceRangeInfo;
            if (isNegativeNormal) {
                sliceIndex = numScrollSteps - sliceIndex - 1;
            }
            const delta = sliceIndex - currentStepIndex;
            const { newFocalPoint, newPosition } = (0,_utilities_snapFocalPointToSlice__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);
            this.setCamera({ focalPoint: newFocalPoint, position: newPosition });
        }
        else if (refFrameOfReference === this.getFrameOfReferenceUID()) {
            if (refViewPlaneNormal && !isNegativeNormal && !isSameNormal) {
                this.setOrientation({ viewPlaneNormal: refViewPlaneNormal, viewUp });
                this.setViewReference(viewRef);
                return;
            }
            if (referencedImageId && this.isInAcquisitionPlane()) {
                const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_28__.get(_enums__WEBPACK_IMPORTED_MODULE_6__.MetadataModules.IMAGE_PLANE, referencedImageId);
                const { imagePositionPatient } = imagePlaneModule;
                const { focalPoint } = this.getCamera();
                const diffVector = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, imagePositionPatient);
                const projectedDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(diffVector, viewPlaneNormal);
                const newImagePositionPatient = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance);
                this.setCamera({
                    focalPoint: newImagePositionPatient,
                });
                this.render();
                return;
            }
            if (cameraFocalPoint) {
                const focalDelta = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], cameraFocalPoint, focalPoint);
                const useNormal = refViewPlaneNormal ?? viewPlaneNormal;
                const normalDot = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(focalDelta, useNormal);
                if (!(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Ay)(normalDot, 0)) {
                    gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scale */ .eR.scale(focalDelta, useNormal, normalDot);
                }
                const newFocal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add([0, 0, 0], focalPoint, focalDelta);
                const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add([0, 0, 0], position, focalDelta);
                this.setCamera({ focalPoint: newFocal, position: newPosition });
            }
        }
        else {
            throw new Error(`Incompatible view refs: ${refFrameOfReference}!==${this.getFrameOfReferenceUID()}`);
        }
    }
    setThreshold(colormap, volumeId) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        (0,_utilities_colormap__WEBPACK_IMPORTED_MODULE_11__.updateThreshold)(volumeActor, colormap.threshold);
        if (!this.viewportProperties.colormap) {
            this.viewportProperties.colormap = {};
        }
        this.viewportProperties.colormap.threshold = colormap.threshold;
    }
    setProperties({ voiRange, VOILUTFunction, invert, colormap, preset, interpolationType, slabThickness, } = {}, volumeId, suppressEvents = false) {
        if (this.globalDefaultProperties == null) {
            this.setDefaultProperties({
                voiRange,
                VOILUTFunction,
                invert,
                colormap,
                preset,
                slabThickness,
            });
        }
        if (invert !== undefined && this.viewportProperties.invert !== invert) {
            this.setInvert(invert, volumeId, suppressEvents);
        }
        if (colormap?.name) {
            this.setColormap(colormap, volumeId, suppressEvents);
        }
        if (colormap?.opacity != null) {
            this.setOpacity(colormap, volumeId);
        }
        if (colormap?.threshold != null) {
            this.setThreshold(colormap, volumeId);
        }
        if (voiRange !== undefined) {
            this.setVOI(voiRange, volumeId, suppressEvents);
        }
        if (typeof interpolationType !== 'undefined') {
            this.setInterpolationType(interpolationType);
        }
        if (VOILUTFunction !== undefined) {
            this.setVOILUTFunction(VOILUTFunction, volumeId, suppressEvents);
        }
        if (preset !== undefined) {
            this.setPreset(preset, volumeId, suppressEvents);
        }
        if (slabThickness !== undefined) {
            this.setSlabThickness(slabThickness);
        }
    }
    resetToDefaultProperties(volumeId) {
        const properties = this.globalDefaultProperties;
        if (properties.colormap?.name) {
            this.setColormap(properties.colormap, volumeId);
        }
        if (properties.colormap?.opacity != null) {
            this.setOpacity(properties.colormap, volumeId);
        }
        if (properties.voiRange !== undefined) {
            this.setVOI(properties.voiRange, volumeId);
        }
        if (properties.VOILUTFunction !== undefined) {
            this.setVOILUTFunction(properties.VOILUTFunction, volumeId);
        }
        if (properties.invert !== undefined) {
            this.setInvert(properties.invert, volumeId);
        }
        if (properties.slabThickness !== undefined) {
            this.setSlabThickness(properties.slabThickness);
            this.viewportProperties.slabThickness = properties.slabThickness;
        }
        if (properties.preset !== undefined) {
            this.setPreset(properties.preset, volumeId, false);
        }
        if (properties.preset !== undefined) {
            this.setPreset(properties.preset, volumeId, false);
        }
        this.render();
    }
    setPreset(presetNameOrObj, volumeId, suppressEvents) {
        const applicableVolumeActorInfo = this._getApplicableVolumeActor(volumeId);
        if (!applicableVolumeActorInfo) {
            return;
        }
        const { volumeActor } = applicableVolumeActorInfo;
        let preset = presetNameOrObj;
        if (typeof preset === 'string') {
            preset = _constants__WEBPACK_IMPORTED_MODULE_5__.VIEWPORT_PRESETS.find((preset) => {
                return preset.name === presetNameOrObj;
            });
        }
        if (!preset) {
            return;
        }
        (0,_utilities_applyPreset__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .A)(volumeActor, preset);
        this.viewportProperties.preset = preset;
        this.render();
        if (!suppressEvents) {
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.PRESET_MODIFIED, {
                viewportId: this.id,
                volumeId: applicableVolumeActorInfo.volumeId,
                actor: volumeActor,
                presetName: preset.name,
            });
        }
    }
    async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist, you need to create/allocate the volume first`);
        }
        const FrameOfReferenceUID = firstImageVolume.metadata.FrameOfReferenceUID;
        this._isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID);
        this._FrameOfReferenceUID = FrameOfReferenceUID;
        volumeInputArray.forEach((volumeInput) => {
            this._addVolumeId(volumeInput.volumeId);
        });
        const volumeActors = [];
        for (let i = 0; i < volumeInputArray.length; i++) {
            const { volumeId, actorUID, slabThickness, ...rest } = volumeInputArray[i];
            const actor = await (0,_helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(volumeInputArray[i], this.element, this.id, suppressEvents);
            const uid = actorUID || (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .A)();
            volumeActors.push({
                uid,
                actor,
                slabThickness,
                referencedId: volumeId,
                ...rest,
            });
        }
        this._setVolumeActors(volumeActors);
        this.viewportStatus = _enums__WEBPACK_IMPORTED_MODULE_6__.ViewportStatus.PRE_RENDER;
        this.initializeColorTransferFunction(volumeInputArray);
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_6__.Events.VOLUME_VIEWPORT_NEW_VOLUME, {
            viewportId: this.id,
            volumeActors,
        });
        if (immediate) {
            this.render();
        }
    }
    async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        const volumeActors = [];
        this._isValidVolumeInputArray(volumeInputArray, this._FrameOfReferenceUID);
        volumeInputArray.forEach((volumeInput) => {
            this._addVolumeId(volumeInput.volumeId);
        });
        for (let i = 0; i < volumeInputArray.length; i++) {
            const { volumeId, visibility, actorUID, slabThickness, ...rest } = volumeInputArray[i];
            const actor = await (0,_helpers_createVolumeActor__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A)(volumeInputArray[i], this.element, this.id, suppressEvents);
            if (!visibility) {
                actor.setVisibility(false);
            }
            const uid = actorUID || (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_27__/* ["default"] */ .A)();
            volumeActors.push({
                uid,
                actor,
                slabThickness,
                referencedId: volumeId,
                ...rest,
            });
        }
        this.addActors(volumeActors);
        this.initializeColorTransferFunction(volumeInputArray);
        if (immediate) {
            this.render();
        }
    }
    removeVolumeActors(actorUIDs, immediate = false) {
        this.removeActors(actorUIDs);
        if (immediate) {
            this.render();
        }
    }
    setOrientation(_orientation, _immediate = true) {
        console.warn('Method "setOrientation" needs implementation');
    }
    initializeColorTransferFunction(volumeInputArray) {
        const selectedVolumeId = volumeInputArray[0].volumeId;
        const colorTransferFunction = this._getOrCreateColorTransferFunction(selectedVolumeId);
        if (!this.initialTransferFunctionNodes && colorTransferFunction) {
            this.initialTransferFunctionNodes = (0,_utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_15__.getTransferFunctionNodes)(colorTransferFunction);
        }
    }
    _getApplicableVolumeActor(volumeId) {
        const actorEntries = this.getActors();
        if (!actorEntries?.length) {
            return;
        }
        if (volumeId) {
            const actorEntry = actorEntries.find((actor) => actor.referencedId === volumeId);
            if (!actorEntry) {
                return;
            }
            return {
                volumeActor: actorEntry.actor,
                volumeId,
                actorUID: actorEntry.uid,
            };
        }
        const defaultActorEntry = actorEntries[0];
        return {
            volumeActor: defaultActorEntry.actor,
            volumeId: defaultActorEntry.referencedId,
            actorUID: defaultActorEntry.uid,
        };
    }
    async _isValidVolumeInputArray(volumeInputArray, FrameOfReferenceUID) {
        const numVolumes = volumeInputArray.length;
        for (let i = 1; i < numVolumes; i++) {
            const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeInputArray[i].volumeId);
            if (FrameOfReferenceUID !== imageVolume.metadata.FrameOfReferenceUID) {
                throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
            }
        }
        return true;
    }
    getBounds() {
        const renderer = this.getRenderer();
        const bounds = renderer.computeVisiblePropBounds();
        return bounds;
    }
    flip(flipDirection) {
        super.flip(flipDirection);
    }
    hasVolumeId(volumeId) {
        return this.volumeIds.has(volumeId);
    }
    hasVolumeURI(volumeURI) {
        for (const volumeId of this.volumeIds) {
            if (volumeId.includes(volumeURI)) {
                return true;
            }
        }
        return false;
    }
    getImageData(volumeId) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        volumeId ||= this.getVolumeId();
        const actorEntry = this.getActors()?.find((actor) => actor.referencedId === volumeId);
        if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume')) {
            return;
        }
        const actor = actorEntry.actor;
        const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeId);
        const vtkImageData = actor.getMapper().getInputData();
        return {
            dimensions: vtkImageData.getDimensions(),
            spacing: vtkImageData.getSpacing(),
            origin: vtkImageData.getOrigin(),
            direction: vtkImageData.getDirection(),
            imageData: actor.getMapper().getInputData(),
            metadata: {
                Modality: volume?.metadata?.Modality,
                FrameOfReferenceUID: volume?.metadata?.FrameOfReferenceUID,
            },
            get scalarData() {
                return volume?.voxelManager?.getScalarData();
            },
            scaling: volume?.scaling,
            hasPixelSpacing: true,
            voxelManager: volume?.voxelManager,
        };
    }
    setCameraClippingRange() {
        throw new Error('Method not implemented.');
    }
    getSliceIndex() {
        throw new Error('Method not implemented.');
    }
    setCamera(cameraInterface, storeAsInitialCamera) {
        super.setCamera(cameraInterface, storeAsInitialCamera);
        this.setCameraClippingRange();
    }
    _setVolumeActors(volumeActorEntries) {
        for (let i = 0; i < volumeActorEntries.length; i++) {
            this.viewportProperties.invert = false;
        }
        this.setActors(volumeActorEntries);
    }
    _getOrientationVectors(orientation) {
        if (typeof orientation === 'object') {
            if (orientation.viewPlaneNormal && orientation.viewUp) {
                return orientation;
            }
            else {
                throw new Error('Invalid orientation object. It must contain viewPlaneNormal and viewUp');
            }
        }
        else if (typeof orientation === 'string') {
            if (orientation === 'acquisition') {
                return this._getAcquisitionPlaneOrientation();
            }
            else if (_constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES[orientation]) {
                this.viewportProperties.orientation = orientation;
                return _constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES[orientation];
            }
        }
        throw new Error(`Invalid orientation: ${orientation}. Valid orientations are: ${Object.keys(_constants__WEBPACK_IMPORTED_MODULE_5__.MPR_CAMERA_VALUES).join(', ')}`);
    }
    _getAcquisitionPlaneOrientation() {
        const actorEntry = this.getDefaultActor();
        if (!actorEntry) {
            return;
        }
        const volumeId = this.getVolumeId();
        const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        const { direction } = imageVolume;
        const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
        const viewUp = direction.slice(3, 6).map((x) => -x);
        return {
            viewPlaneNormal,
            viewUp,
        };
    }
    getSlabThickness() {
        const actors = this.getActors();
        let slabThickness = _constants__WEBPACK_IMPORTED_MODULE_5__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
        actors.forEach((actor) => {
            if (actor.slabThickness > slabThickness) {
                slabThickness = actor.slabThickness;
            }
        });
        return slabThickness;
    }
    getIntensityFromWorld(point) {
        const actorEntry = this.getDefaultActor();
        if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_21__/* .actorIsA */ .N)(actorEntry, 'vtkVolume')) {
            return;
        }
        const { actor } = actorEntry;
        const imageData = actor.getMapper().getInputData();
        const volume = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getVolume(this.getVolumeId());
        const index = (0,_utilities_transformWorldToIndex__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A)(imageData, point);
        return volume.voxelManager.getAtIJKPoint(index);
    }
    getVolumeId(specifier) {
        const actorEntries = this.getActors();
        if (!actorEntries) {
            return;
        }
        if (!specifier?.volumeId) {
            const found = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume');
            return found?.referencedId || found?.uid;
        }
        const found = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume' &&
            actorEntry.referencedId === specifier?.volumeId);
        return found?.referencedId || found?.uid;
    }
    getViewReferenceId(specifier = {}) {
        let { volumeId, sliceIndex: sliceIndex } = specifier;
        if (!volumeId) {
            const actorEntries = this.getActors();
            if (!actorEntries) {
                return;
            }
            volumeId = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.referencedId;
        }
        const currentIndex = this.getSliceIndex();
        sliceIndex ??= currentIndex;
        const { viewPlaneNormal, focalPoint } = this.getCamera();
        const querySeparator = volumeId.includes('?') ? '&' : '?';
        return `volumeId:${volumeId}${querySeparator}sliceIndex=${sliceIndex}&viewPlaneNormal=${viewPlaneNormal.join(',')}`;
    }
    _addVolumeId(volumeId) {
        this.volumeIds.add(volumeId);
    }
    getAllVolumeIds() {
        return Array.from(this.volumeIds);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseVolumeViewport);


/***/ }),

/***/ 58165:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_StackViewport)
});

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData = __webpack_require__(58498);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var Camera = __webpack_require__(26719);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
var ColorTransferFunction = __webpack_require__(642);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js + 1 modules
var ColorMaps = __webpack_require__(660);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var Constants = __webpack_require__(94520);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
var AbstractMapper3D = __webpack_require__(68076);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper.js




// ----------------------------------------------------------------------------
// vtkAbstractImageMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractImageMapper(publicAPI, model) {
  model.classHierarchy.push('vtkAbstractImageMapper');
  publicAPI.getIsOpaque = () => true;
  publicAPI.getCurrentImage = () => null;
  publicAPI.getBoundsForSlice = () => {
    macros2.m.vtkErrorMacro('vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED');
    return (0,Core_Math.H)();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  slice: 0,
  customDisplayExtent: [0, 0, 0, 0, 0, 0],
  useCustomExtents: false,
  backgroundColor: [0, 0, 0, 1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  AbstractMapper3D/* default.extend */.A.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['slice', 'useCustomExtents']);
  macros2.m.setGetArray(publicAPI, model, ['customDisplayExtent'], 6);
  macros2.m.setGetArray(publicAPI, model, ['backgroundColor'], 4);
  vtkAbstractImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------
var vtkAbstractImageMapper$1 = {
  extend
};



// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js



/**
 * Perform plane-line intersection, where the line is defined by two points (p1, p2),
 * and the plane is defined by the imageData and slice number.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function doPicking(p1, p2, mapper) {
  const imageData = mapper.getCurrentImage();
  const extent = imageData.getExtent();

  // Slice origin
  const ijk = [extent[0], extent[2], extent[4]];
  const {
    ijkMode
  } = mapper.getClosestIJKAxis();
  let nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();
  if (ijkMode !== mapper.getSlicingMode()) {
    // If not IJK slicing, get the IJK slice from the XYZ position/slice
    nSlice = mapper.getSliceAtPosition(nSlice);
  }
  ijk[ijkMode] += nSlice;
  const worldOrigin = [0, 0, 0];
  imageData.indexToWorld(ijk, worldOrigin);

  // Normal computation
  ijk[ijkMode] += 1;
  const worldNormal = [0, 0, 0];
  imageData.indexToWorld(ijk, worldNormal);
  worldNormal[0] -= worldOrigin[0];
  worldNormal[1] -= worldOrigin[1];
  worldNormal[2] -= worldOrigin[2];
  esm/* vec3.normalize */.eR.normalize(worldNormal, worldNormal);
  const intersect = Plane/* default */.Ay.intersectWithLine(p1, p2, worldOrigin, worldNormal);
  if (intersect.intersection) {
    const point = intersect.x;
    const absoluteIJK = [0, 0, 0];
    imageData.worldToIndex(point, absoluteIJK);
    // `t` is the parametric position along the line
    // defined in Plane.intersectWithLine
    return {
      t: intersect.t,
      absoluteIJK
    };
  }
  return null;
}

/**
 * Implement point picking for image plane.
 * The plane is defined by the imageData and current slice number,
 * set in the input mapper.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function intersectWithLineForPointPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();

    // Get closer integer ijk
    // NB: point picking means closest slice, means rounding
    const ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])];

    // Are we outside our actual extent
    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {
      return null;
    }
    return {
      t: pickingData.t,
      ijk
    };
  }
  return null;
}

/**
 * Implement cell picking for image plane.
 * The plane is defined by the imageData and current slice number,
 * set in the input mapper.
 *
 * @param {Vector3} p1
 * @param {Vector3} p2
 * @param {vtkImageMapper|vtkImageArrayMapper} mapper
 */
function intersectWithLineForCellPicking(p1, p2, mapper) {
  const pickingData = doPicking(p1, p2, mapper);
  if (pickingData) {
    const imageData = mapper.getCurrentImage();
    const extent = imageData.getExtent();
    const absIJK = pickingData.absoluteIJK;

    // Get closer integer ijk
    // NB: cell picking means closest voxel, means flooring
    const ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])];

    // Are we outside our actual extent
    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] ||
    // handle single-slice images
    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {
      return null;
    }

    // Parametric coordinates within cell
    const pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];
    return {
      t: pickingData.t,
      ijk,
      pCoords
    };
  }
  return null;
}



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
var CoincidentTopologyHelper = __webpack_require__(57285);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js







const {
  staticOffsetAPI,
  otherStaticMethods
} = CoincidentTopologyHelper/* default */.Ay;
const {
  SlicingMode
} = Constants/* default */.A;

// ----------------------------------------------------------------------------
// vtkImageMapper methods
// ----------------------------------------------------------------------------

function vtkImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageMapper');
  publicAPI.getSliceAtPosition = pos => {
    const image = publicAPI.getCurrentImage();
    let pos3;
    if (pos.length === 3) {
      pos3 = pos;
    } else if (Number.isFinite(pos)) {
      const bds = image.getBounds();
      switch (model.slicingMode) {
        case SlicingMode.X:
          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Y:
          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];
          break;
        case SlicingMode.Z:
          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];
          break;
      }
    }
    const ijk = [0, 0, 0];
    image.worldToIndex(pos3, ijk);
    const ex = image.getExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let slice = 0;
    switch (ijkMode) {
      case SlicingMode.I:
        slice = (0,Core_Math.E)(ijk[0], ex[0], ex[1]);
        break;
      case SlicingMode.J:
        slice = (0,Core_Math.E)(ijk[1], ex[2], ex[3]);
        break;
      case SlicingMode.K:
        slice = (0,Core_Math.E)(ijk[2], ex[4], ex[5]);
        break;
      default:
        return 0;
    }
    return slice;
  };
  publicAPI.setSliceFromCamera = cam => {
    const fp = cam.getFocalPoint();
    switch (model.slicingMode) {
      case SlicingMode.I:
      case SlicingMode.J:
      case SlicingMode.K:
        {
          const slice = publicAPI.getSliceAtPosition(fp);
          publicAPI.setSlice(slice);
        }
        break;
      case SlicingMode.X:
        publicAPI.setSlice(fp[0]);
        break;
      case SlicingMode.Y:
        publicAPI.setSlice(fp[1]);
        break;
      case SlicingMode.Z:
        publicAPI.setSlice(fp[2]);
        break;
    }
  };
  publicAPI.setXSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.X);
    publicAPI.setSlice(id);
  };
  publicAPI.setYSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.Y);
    publicAPI.setSlice(id);
  };
  publicAPI.setZSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.Z);
    publicAPI.setSlice(id);
  };
  publicAPI.setISlice = id => {
    publicAPI.setSlicingMode(SlicingMode.I);
    publicAPI.setSlice(id);
  };
  publicAPI.setJSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.J);
    publicAPI.setSlice(id);
  };
  publicAPI.setKSlice = id => {
    publicAPI.setSlicingMode(SlicingMode.K);
    publicAPI.setSlice(id);
  };
  publicAPI.getSlicingModeNormal = () => {
    const out = [0, 0, 0];
    const mat3 = publicAPI.getCurrentImage().getDirection();
    switch (model.slicingMode) {
      case SlicingMode.X:
        out[0] = 1;
        break;
      case SlicingMode.Y:
        out[1] = 1;
        break;
      case SlicingMode.Z:
        out[2] = 1;
        break;
      case SlicingMode.I:
        (0,Core_Math.S)(mat3, [1, 0, 0], out);
        break;
      case SlicingMode.J:
        (0,Core_Math.S)(mat3, [0, 1, 0], out);
        break;
      case SlicingMode.K:
        (0,Core_Math.S)(mat3, [0, 0, 1], out);
        break;
    }
    return out;
  };
  function computeClosestIJKAxis() {
    let xyzMode;
    switch (model.slicingMode) {
      case SlicingMode.X:
        xyzMode = 0;
        break;
      case SlicingMode.Y:
        xyzMode = 1;
        break;
      case SlicingMode.Z:
        xyzMode = 2;
        break;
      default:
        model.closestIJKAxis = {
          ijkMode: model.slicingMode,
          flip: false
        };
        return;
    }

    // The direction matrix in vtkImageData is the indexToWorld rotation matrix
    // with a column-major data layout since it is stored as a WebGL matrix.
    const direction = publicAPI.getCurrentImage().getDirection();
    const newMatrix = (0,Core_Math.T)(direction);
    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1
    // We have xyzVector = (+/-) newMatrix * ijkVector
    let ijkMode = 0;
    for (; ijkMode < 3; ++ijkMode) {
      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {
        break;
      }
    }
    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;
    model.closestIJKAxis = {
      ijkMode,
      flip
    };
  }
  publicAPI.setSlicingMode = mode => {
    if (model.slicingMode === mode) {
      return;
    }
    model.slicingMode = mode;
    if (publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    publicAPI.modified();
  };
  publicAPI.getClosestIJKAxis = () => {
    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {
      computeClosestIJKAxis();
    }
    return model.closestIJKAxis;
  };
  publicAPI.getBounds = () => {
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return (0,Core_Math.H)();
    }
    if (!model.useCustomExtents) {
      return image.getBounds();
    }
    const ex = model.customDisplayExtent.slice();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = model.slice;
    if (ijkMode !== model.slicingMode) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      nSlice = publicAPI.getSliceAtPosition(model.slice);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        ex[0] = nSlice;
        ex[1] = nSlice;
        break;
      case SlicingMode.J:
        ex[2] = nSlice;
        ex[3] = nSlice;
        break;
      case SlicingMode.K:
        ex[4] = nSlice;
        ex[5] = nSlice;
        break;
    }
    return image.extentToBounds(ex);
  };
  publicAPI.getBoundsForSlice = function () {
    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;
    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const image = publicAPI.getCurrentImage();
    if (!image) {
      return (0,Core_Math.H)();
    }
    const extent = image.getSpatialExtent();
    const {
      ijkMode
    } = publicAPI.getClosestIJKAxis();
    let nSlice = slice;
    if (ijkMode !== model.slicingMode) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      nSlice = publicAPI.getSliceAtPosition(slice);
    }
    switch (ijkMode) {
      case SlicingMode.I:
        extent[0] = nSlice - halfThickness;
        extent[1] = nSlice + halfThickness;
        break;
      case SlicingMode.J:
        extent[2] = nSlice - halfThickness;
        extent[3] = nSlice + halfThickness;
        break;
      case SlicingMode.K:
        extent[4] = nSlice - halfThickness;
        extent[5] = nSlice + halfThickness;
        break;
    }
    return image.extentToBounds(extent);
  };
  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);
  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);
  publicAPI.getCurrentImage = () => publicAPI.getInputData();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageMapper_DEFAULT_VALUES = {
  slicingMode: SlicingMode.NONE,
  closestIJKAxis: {
    ijkMode: SlicingMode.NONE,
    flip: false
  },
  renderToRectangle: false,
  sliceAtFocalPoint: false,
  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate
};

// ----------------------------------------------------------------------------

function ImageMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageMapper_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkAbstractImageMapper$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['slicingMode']);
  macros2.m.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);
  CoincidentTopologyHelper/* default */.Ay.implementCoincidentTopologyMethods(publicAPI, model);

  // Object methods
  vtkImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(ImageMapper_extend, 'vtkImageMapper');

// ----------------------------------------------------------------------------

var vtkImageMapper$1 = {
  newInstance,
  extend: ImageMapper_extend,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ...Constants/* default */.A
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var Prop3D = __webpack_require__(62502);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var ImageProperty_Constants = __webpack_require__(91732);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty.js



const {
  InterpolationType
} = ImageProperty_Constants/* default */.A;
const {
  vtkErrorMacro
} = macros2.m;
const VTK_MAX_VRCOMP = 4;

// ----------------------------------------------------------------------------
// vtkImageProperty methods
// ----------------------------------------------------------------------------

function vtkImageProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageProperty');
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP; index++) {
      // Color MTimes
      if (model.componentData[index].rGBTransferFunction) {
        // time that RGB transfer function was last modified
        time = model.componentData[index].rGBTransferFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }

      // Piecewise function MTimes
      if (model.componentData[index].piecewiseFunction) {
        // time that weighting function was last modified
        time = model.componentData[index].piecewiseFunction.getMTime();
        mTime = mTime > time ? mTime : time;
      }
    }
    return mTime;
  };

  // Set the color of a volume to an RGB transfer function
  publicAPI.setRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // backwards compatible call without the component index
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].rGBTransferFunction !== transferFunc) {
      model.componentData[idx].rGBTransferFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the currently set RGB transfer function.
  publicAPI.getRGBTransferFunction = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].rGBTransferFunction;
  };

  // Set the piecewise function
  publicAPI.setPiecewiseFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    if (model.componentData[idx].piecewiseFunction !== transferFunc) {
      model.componentData[idx].piecewiseFunction = transferFunc;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the component weighting function.
  publicAPI.getPiecewiseFunction = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.componentData[idx].piecewiseFunction;
  };

  // Alias to set the piecewise function
  publicAPI.setScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    // backwards compatible call without the component index
    let idx = index;
    let transferFunc = func;
    if (!Number.isInteger(index)) {
      transferFunc = index;
      idx = 0;
    }
    return publicAPI.setPiecewiseFunction(idx, transferFunc);
  };

  // Alias to get the piecewise function (backwards compatibility)
  publicAPI.getScalarOpacity = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return publicAPI.getPiecewiseFunction(idx);
  };
  publicAPI.setComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return 0.0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType.LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macros2.m.enumToString(InterpolationType, model.interpolationType);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const ImageProperty_DEFAULT_VALUES = {
  independentComponents: false,
  interpolationType: InterpolationType.LINEAR,
  colorWindow: 255,
  colorLevel: 127.5,
  ambient: 1.0,
  diffuse: 0.0,
  opacity: 1.0,
  useLookupTableScalarRange: false,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1.0
};

// ----------------------------------------------------------------------------

function ImageProperty_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageProperty_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP; i++) {
      model.componentData.push({
        rGBTransferFunction: null,
        piecewiseFunction: null,
        componentWeight: 1.0
      });
    }
  }
  macros2.m.setGet(publicAPI, model, ['independentComponents', 'interpolationType', 'colorWindow', 'colorLevel', 'ambient', 'diffuse', 'opacity', 'useLookupTableScalarRange', 'useLabelOutline', 'labelOutlineOpacity']);
  macros2.m.setGetArray(publicAPI, model, ['labelOutlineThickness']);

  // Object methods
  vtkImageProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageProperty_newInstance = macros2.m.newInstance(ImageProperty_extend, 'vtkImageProperty');

// ----------------------------------------------------------------------------

var vtkImageProperty$1 = {
  newInstance: ImageProperty_newInstance,
  extend: ImageProperty_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js






const {
  vtkDebugMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkImageSlice methods
// ----------------------------------------------------------------------------

function vtkImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageSlice');
  publicAPI.getActors = () => publicAPI;
  publicAPI.getImages = () => publicAPI;
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    // make sure we have a property
    if (!model.property) {
      // force creation of a property
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1.0;

    // are we using an opaque scalar array, if any?
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };

  // Always render during opaque pass, to keep the behavior
  // predictable and because depth-peeling kills alpha-blending.
  // In the future, the Renderer should render images in layers,
  // i.e. where each image will have a layer number assigned to it,
  // and the Renderer will do the images in their own pass.
  publicAPI.hasTranslucentPolygonalGeometry = () => false;
  publicAPI.makeProperty = vtkImageProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.map(x => x);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
      BoundingBox/* default.transformBounds */.Ay.transformBounds(bds, tmp4, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBoundsForSlice = (slice, thickness) => {
    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBoundsForSlice(slice, thickness);
    // Check for the special case when the actor is empty.
    if (!BoundingBox/* default.isValid */.Ay.isValid(bds)) {
      return bds;
    }
    publicAPI.computeMatrix();
    const tmp4 = new Float64Array(16);
    esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
    const newBounds = BoundingBox/* default.transformBounds */.Ay.transformBounds(bds, tmp4);
    return newBounds;
  };

  //----------------------------------------------------------------------------
  // Get the minimum X bound
  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];

  // Get the maximum X bound
  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];

  // Get the minimum Y bound
  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];

  // Get the maximum Y bound
  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];

  // Get the minimum Z bound
  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];

  // Get the maximum Z bound
  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    if (model.property !== null) {
      let time = model.property.getMTime();
      mt = time > mt ? time : mt;
      if (model.property.getRGBTransferFunction() !== null) {
        time = model.property.getRGBTransferFunction().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageSlice_DEFAULT_VALUES = {
  mapper: null,
  property: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [...BoundingBox/* default */.Ay.INIT_BOUNDS]
};

// ----------------------------------------------------------------------------

function ImageSlice_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageSlice_DEFAULT_VALUES, initialValues);

  // Inheritance
  Prop3D/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  macros2.m.obj(model.boundsMTime);

  // Build VTK API
  macros2.m.set(publicAPI, model, ['property']);
  macros2.m.setGet(publicAPI, model, ['mapper', 'forceOpaque', 'forceTranslucent']);
  macros2.m.getArray(publicAPI, model, ['bounds'], 6);

  // Object methods
  vtkImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageSlice_newInstance = macros2.m.newInstance(ImageSlice_extend, 'vtkImageSlice');

// ----------------------------------------------------------------------------

var vtkImageSlice$1 = {
  newInstance: ImageSlice_newInstance,
  extend: ImageSlice_extend
};



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageDataMetadata.js
var getImageDataMetadata = __webpack_require__(53932);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/logger.js
var logger = __webpack_require__(7608);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
var actorCheck = __webpack_require__(98039);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js
var utilities_colormap = __webpack_require__(13859);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var transferFunctionUtils = __webpack_require__(85745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js
var windowLevel = __webpack_require__(68136);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js
var createLinearRGBTransferFunction = __webpack_require__(74657);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js
var createSigmoidRGBTransferFunction = __webpack_require__(40256);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js
var updateVTKImageDataWithCornerstoneImage = __webpack_require__(45278);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js
var isEqual = __webpack_require__(74638);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js
var invertRgbTransferFunction = __webpack_require__(50134);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js
var imageRetrieveMetadataProvider = __webpack_require__(17791);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js
var imageIdToURI = __webpack_require__(39537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js
var drawImageSync = __webpack_require__(5057);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/buildMetadata.js
var buildMetadata = __webpack_require__(89131);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js
var calculateTransform = __webpack_require__(7808);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getTransform.js

/* harmony default export */ function getTransform(enabledElement) {
    return (0,calculateTransform/* default */.A)(enabledElement);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.js

/* harmony default export */ function canvasToPixel(enabledElement, pt) {
    const transform = getTransform(enabledElement);
    transform.invert();
    return transform.transformPoint(pt);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js
var getDefaultViewport = __webpack_require__(36931);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.js

/* harmony default export */ function pixelToCanvas(enabledElement, pt) {
    const transform = getTransform(enabledElement);
    return transform.transformPoint(pt);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.js
var getImageFitScale = __webpack_require__(57162);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.js

/* harmony default export */ function fitToWindow(enabledElement) {
    const { image } = enabledElement;
    enabledElement.viewport.scale = (0,getImageFitScale/* default */.A)(enabledElement.canvas, image, enabledElement.viewport.rotation).scaleFactor;
    enabledElement.viewport.translation.x = 0;
    enabledElement.viewport.translation.y = 0;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.js
var getImageSize = __webpack_require__(62596);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resize.js


function setCanvasSize(enabledElement) {
    const { canvas } = enabledElement;
    const { clientWidth, clientHeight } = canvas;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth;
        canvas.height = clientHeight;
    }
}
function wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight) {
    const scale = enabledElement.viewport.scale;
    const imageSize = (0,getImageSize/* default */.A)(enabledElement.image, enabledElement.viewport.rotation);
    const imageWidth = Math.round(imageSize.width * scale);
    const imageHeight = Math.round(imageSize.height * scale);
    const x = enabledElement.viewport.translation.x;
    const y = enabledElement.viewport.translation.y;
    return ((imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||
        (imageWidth <= oldCanvasWidth &&
            imageHeight === oldCanvasHeight &&
            x === 0 &&
            y === 0));
}
function relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight) {
    const scale = enabledElement.viewport.scale;
    const canvasWidth = enabledElement.canvas.width;
    const canvasHeight = enabledElement.canvas.height;
    const relWidthChange = canvasWidth / oldCanvasWidth;
    const relHeightChange = canvasHeight / oldCanvasHeight;
    const relChange = Math.sqrt(relWidthChange * relHeightChange);
    enabledElement.viewport.scale = relChange * scale;
}
/* harmony default export */ function resize(enabledElement, forceFitToWindow = false) {
    const oldCanvasWidth = enabledElement.canvas.width;
    const oldCanvasHeight = enabledElement.canvas.height;
    setCanvasSize(enabledElement);
    if (enabledElement.image === undefined) {
        return;
    }
    if (forceFitToWindow ||
        wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)) {
        fitToWindow(enabledElement);
    }
    else {
        relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 2 modules
var init = __webpack_require__(26896);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js + 4 modules
var ProgressiveRetrieveImages = __webpack_require__(36822);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/correctShift.js
/* harmony default export */ function correctShift(shift, viewportOrientation) {
    const { hflip, vflip, rotation } = viewportOrientation;
    shift.x *= hflip ? -1 : 1;
    shift.y *= vflip ? -1 : 1;
    if (rotation !== 0) {
        const angle = (rotation * Math.PI) / 180;
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const newX = shift.x * cosA - shift.y * sinA;
        const newY = shift.x * sinA + shift.y * cosA;
        shift.x = newX;
        shift.y = newY;
    }
    return shift;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.js

/* harmony default export */ function resetCamera(enabledElement, resetPan = true, resetZoom = true) {
    const { canvas, image, viewport } = enabledElement;
    const scale = (0,getImageFitScale/* default */.A)(canvas, image, 0).scaleFactor;
    viewport.vflip = false;
    viewport.hflip = false;
    if (resetPan) {
        viewport.translation.x = 0;
        viewport.translation.y = 0;
    }
    if (resetZoom) {
        viewport.displayedArea.tlhc.x = 1;
        viewport.displayedArea.tlhc.y = 1;
        viewport.displayedArea.brhc.x = image.columns;
        viewport.displayedArea.brhc.y = image.rows;
        viewport.scale = scale;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
var getSpacingInNormalDirection = __webpack_require__(85008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
var getClosestImageId = __webpack_require__(88619);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js












































const EPSILON = 1;
const log = logger.coreLog.getLogger('RenderingEngine', 'StackViewport');
class StackViewport extends Viewport/* default */.A {
    constructor(props) {
        super(props);
        this.imageIds = [];
        this.imageKeyToIndexMap = new Map();
        this.currentImageIdIndex = 0;
        this.targetImageIdIndex = 0;
        this.imagesLoader = this;
        this.globalDefaultProperties = {};
        this.perImageIdDefaultProperties = new Map();
        this.voiUpdatedWithSetProperties = false;
        this.invert = false;
        this.initialInvert = false;
        this.initialTransferFunctionNodes = null;
        this.stackInvalidated = false;
        this._publishCalibratedEvent = false;
        this.updateRenderingPipeline = () => {
            this._configureRenderingPipeline();
        };
        this.resize = () => {
            if (this.useCPURendering) {
                this._resizeCPU();
            }
        };
        this._resizeCPU = () => {
            if (this._cpuFallbackEnabledElement.viewport) {
                resize(this._cpuFallbackEnabledElement);
            }
        };
        this.getFrameOfReferenceUID = (sliceIndex) => this.getImagePlaneReferenceData(sliceIndex)?.FrameOfReferenceUID;
        this.getCornerstoneImage = () => this.csImage;
        this.createActorMapper = (imageData) => {
            const mapper = vtkImageMapper$1.newInstance();
            mapper.setInputData(imageData);
            const actor = vtkImageSlice$1.newInstance();
            actor.setMapper(mapper);
            const { preferSizeOverAccuracy } = (0,init/* getConfiguration */.D0)().rendering;
            if (preferSizeOverAccuracy) {
                mapper.setPreferSizeOverAccuracy(true);
            }
            if (imageData.getPointData().getScalars().getNumberOfComponents() > 1) {
                actor.getProperty().setIndependentComponents(false);
            }
            return actor;
        };
        this.getNumberOfSlices = () => {
            return this.imageIds.length;
        };
        this.getDefaultProperties = (imageId) => {
            let imageProperties;
            if (imageId !== undefined) {
                imageProperties = this.perImageIdDefaultProperties.get(imageId);
            }
            if (imageProperties !== undefined) {
                return imageProperties;
            }
            return {
                ...this.globalDefaultProperties,
            };
        };
        this.getProperties = () => {
            const { colormap, voiRange, VOILUTFunction, interpolationType, invert, voiUpdatedWithSetProperties, } = this;
            return {
                colormap,
                voiRange,
                VOILUTFunction,
                interpolationType,
                invert,
                isComputedVOI: !voiUpdatedWithSetProperties,
            };
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
                suppressEvents: true,
            });
        };
        this.getRotationCPU = () => {
            const { viewport } = this._cpuFallbackEnabledElement;
            return viewport.rotation;
        };
        this.getRotationGPU = () => {
            const { viewUp: currentViewUp, viewPlaneNormal, flipVertical, } = this.getCameraNoRotation();
            const initialViewUp = flipVertical
                ? esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), this.initialViewUp)
                : this.initialViewUp;
            const initialToCurrentViewUpAngle = (esm/* vec3.angle */.eR.angle(initialViewUp, currentViewUp) * 180) / Math.PI;
            const initialToCurrentViewUpCross = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), initialViewUp, currentViewUp);
            const normalDot = esm/* vec3.dot */.eR.dot(initialToCurrentViewUpCross, viewPlaneNormal);
            return normalDot >= 0
                ? initialToCurrentViewUpAngle
                : (360 - initialToCurrentViewUpAngle) % 360;
        };
        this.setRotation = (rotation) => {
            const previousCamera = this.getCamera();
            if (this.useCPURendering) {
                this.setRotationCPU(rotation);
            }
            else {
                this.setRotationGPU(rotation);
            }
            if (this._suppressCameraModifiedEvents) {
                return;
            }
            const camera = this.getCamera();
            const eventDetail = {
                previousCamera,
                camera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
        };
        this.renderImageObject = (image) => {
            this._setCSImage(image);
            const renderFn = this.useCPURendering
                ? this._updateToDisplayImageCPU
                : this._updateActorToDisplayImageId;
            renderFn.call(this, image);
        };
        this._setCSImage = (image) => {
            image.isPreScaled = image.preScale?.scaled;
            this.csImage = image;
        };
        this.canvasToWorldCPU = (canvasPos, worldPos = [0, 0, 0]) => {
            if (!this._cpuFallbackEnabledElement.image) {
                return;
            }
            const [px, py] = canvasToPixel(this._cpuFallbackEnabledElement, canvasPos);
            const { origin, spacing, direction } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
            return worldPos;
        };
        this.worldToCanvasCPU = (worldPos) => {
            const { spacing, direction, origin } = this.getImageData();
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            const diff = esm/* vec3.subtract */.eR.subtract(esm/* vec3.create */.eR.create(), worldPos, origin);
            const indexPoint = [
                esm/* vec3.dot */.eR.dot(diff, iVector) / spacing[0],
                esm/* vec3.dot */.eR.dot(diff, jVector) / spacing[1],
            ];
            const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, indexPoint);
            return canvasPoint;
        };
        this.canvasToWorldGPU = (canvasPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasPosWithDPR = [
                canvasPos[0] * devicePixelRatio,
                canvasPos[1] * devicePixelRatio,
            ];
            const displayCoord = [
                canvasPosWithDPR[0] + this.sx,
                canvasPosWithDPR[1] + this.sy,
            ];
            displayCoord[1] = size[1] - displayCoord[1];
            const worldCoord = openGLRenderWindow.displayToWorld(displayCoord[0], displayCoord[1], 0, renderer);
            vtkCamera.setClippingRange(crange[0], crange[1]);
            return [worldCoord[0], worldCoord[1], worldCoord[2]];
        };
        this.worldToCanvasGPU = (worldPos) => {
            const renderer = this.getRenderer();
            const vtkCamera = this.getVtkActiveCamera();
            const crange = vtkCamera.getClippingRange();
            const distance = vtkCamera.getDistance();
            vtkCamera.setClippingRange(distance, distance + 0.1);
            const offscreenMultiRenderWindow = this.getRenderingEngine().offscreenMultiRenderWindow;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const size = openGLRenderWindow.getSize();
            const displayCoord = openGLRenderWindow.worldToDisplay(...worldPos, renderer);
            displayCoord[1] = size[1] - displayCoord[1];
            const canvasCoord = [
                displayCoord[0] - this.sx,
                displayCoord[1] - this.sy,
            ];
            vtkCamera.setClippingRange(crange[0], crange[1]);
            const devicePixelRatio = window.devicePixelRatio || 1;
            const canvasCoordWithDPR = [
                canvasCoord[0] / devicePixelRatio,
                canvasCoord[1] / devicePixelRatio,
            ];
            return canvasCoordWithDPR;
        };
        this.getCurrentImageIdIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getSliceIndex = () => {
            return this.currentImageIdIndex;
        };
        this.getTargetImageIdIndex = () => {
            return this.targetImageIdIndex;
        };
        this.getImageIds = () => {
            return this.imageIds;
        };
        this.getCurrentImageId = (index = this.getCurrentImageIdIndex()) => {
            return this.imageIds[index];
        };
        this.hasImageId = (imageId) => {
            return this.imageKeyToIndexMap.has(imageId);
        };
        this.hasImageURI = (imageURI) => {
            return this.imageKeyToIndexMap.has(imageURI);
        };
        this.customRenderViewportToCanvas = () => {
            if (!this.useCPURendering) {
                throw new Error('Custom cpu rendering pipeline should only be hit in CPU rendering mode');
            }
            if (this._cpuFallbackEnabledElement.image) {
                (0,drawImageSync/* default */.A)(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated);
                this.cpuRenderingInvalidated = false;
            }
            else {
                this.fillWithBackgroundColor();
            }
            return {
                canvas: this.canvas,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
                viewportStatus: this.viewportStatus,
            };
        };
        this.renderingPipelineFunctions = {
            getImageData: {
                cpu: this.getImageDataCPU,
                gpu: this.getImageDataGPU,
            },
            setColormap: {
                cpu: this.setColormapCPU,
                gpu: this.setColormapGPU,
            },
            getCamera: {
                cpu: this.getCameraCPU,
                gpu: super.getCamera,
            },
            setCamera: {
                cpu: this.setCameraCPU,
                gpu: super.setCamera,
            },
            getPan: {
                cpu: this.getPanCPU,
                gpu: super.getPan,
            },
            setPan: {
                cpu: this.setPanCPU,
                gpu: super.setPan,
            },
            getZoom: {
                cpu: this.getZoomCPU,
                gpu: super.getZoom,
            },
            setZoom: {
                cpu: this.setZoomCPU,
                gpu: super.setZoom,
            },
            setVOI: {
                cpu: this.setVOICPU,
                gpu: this.setVOIGPU,
            },
            getRotation: {
                cpu: this.getRotationCPU,
                gpu: this.getRotationGPU,
            },
            setInterpolationType: {
                cpu: this.setInterpolationTypeCPU,
                gpu: this.setInterpolationTypeGPU,
            },
            setInvertColor: {
                cpu: this.setInvertColorCPU,
                gpu: this.setInvertColorGPU,
            },
            resetCamera: {
                cpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraCPU({ resetPan, resetZoom });
                    return true;
                },
                gpu: (options = {}) => {
                    const { resetPan = true, resetZoom = true } = options;
                    this.resetCameraGPU({ resetPan, resetZoom });
                    return true;
                },
            },
            canvasToWorld: {
                cpu: this.canvasToWorldCPU,
                gpu: this.canvasToWorldGPU,
            },
            worldToCanvas: {
                cpu: this.worldToCanvasCPU,
                gpu: this.worldToCanvasGPU,
            },
            getRenderer: {
                cpu: () => this.getCPUFallbackError('getRenderer'),
                gpu: super.getRenderer,
            },
            getDefaultActor: {
                cpu: () => this.getCPUFallbackError('getDefaultActor'),
                gpu: super.getDefaultActor,
            },
            getActors: {
                cpu: () => this.getCPUFallbackError('getActors'),
                gpu: super.getActors,
            },
            getActor: {
                cpu: () => this.getCPUFallbackError('getActor'),
                gpu: super.getActor,
            },
            setActors: {
                cpu: () => this.getCPUFallbackError('setActors'),
                gpu: super.setActors,
            },
            addActors: {
                cpu: () => this.getCPUFallbackError('addActors'),
                gpu: super.addActors,
            },
            addActor: {
                cpu: () => this.getCPUFallbackError('addActor'),
                gpu: super.addActor,
            },
            removeAllActors: {
                cpu: () => this.getCPUFallbackError('removeAllActors'),
                gpu: super.removeAllActors,
            },
            unsetColormap: {
                cpu: this.unsetColormapCPU,
                gpu: this.unsetColormapGPU,
            },
        };
        this.scaling = {};
        this.modality = null;
        this.useCPURendering = (0,init/* getShouldUseCPURendering */.LH)();
        this._configureRenderingPipeline();
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
        this.currentImageIdIndex = 0;
        this.targetImageIdIndex = 0;
        this.resetCamera();
        this.initializeElementDisabledHandler();
    }
    setUseCPURendering(value) {
        this.useCPURendering = value;
        this._configureRenderingPipeline(value);
    }
    static get useCustomRenderingPipeline() {
        return (0,init/* getShouldUseCPURendering */.LH)();
    }
    _configureRenderingPipeline(value) {
        this.useCPURendering = value ?? (0,init/* getShouldUseCPURendering */.LH)();
        for (const key in this.renderingPipelineFunctions) {
            if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, key)) {
                const functions = this.renderingPipelineFunctions[key];
                this[key] = this.useCPURendering ? functions.cpu : functions.gpu;
            }
        }
        const result = this.useCPURendering
            ? this._resetCPUFallbackElement()
            : this._resetGPUViewport();
    }
    _resetCPUFallbackElement() {
        this._cpuFallbackEnabledElement = {
            canvas: this.canvas,
            renderingTools: {},
            transform: new transform/* Transform */.d(),
            viewport: { rotation: 0 },
        };
    }
    _resetGPUViewport() {
        const renderer = this.getRenderer();
        const camera = Camera/* default.newInstance */.Ay.newInstance();
        renderer.setActiveCamera(camera);
        const viewPlaneNormal = [0, 0, -1];
        this.initialViewUp = [0, -1, 0];
        camera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        camera.setViewUp(...this.initialViewUp);
        camera.setParallelProjection(true);
        camera.setThicknessFromFocalPoint(0.1);
        camera.setFreezeFocalPoint(true);
    }
    initializeElementDisabledHandler() {
        eventTarget/* default */.A.addEventListener(enums.Events.ELEMENT_DISABLED, function elementDisabledHandler() {
            clearTimeout(this.debouncedTimeout);
            eventTarget/* default */.A.removeEventListener(enums.Events.ELEMENT_DISABLED, elementDisabledHandler);
        });
    }
    getImageDataGPU() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const vtkImageData = actor.getMapper().getInputData();
        const csImage = this.csImage;
        return {
            dimensions: vtkImageData.getDimensions(),
            spacing: vtkImageData.getSpacing(),
            origin: vtkImageData.getOrigin(),
            direction: vtkImageData.getDirection(),
            get scalarData() {
                return csImage?.voxelManager.getScalarData();
            },
            imageData: actor.getMapper().getInputData(),
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    getImageDataCPU() {
        const { metadata } = this._cpuFallbackEnabledElement;
        if (!metadata) {
            return;
        }
        const spacing = metadata.spacing;
        const csImage = this.csImage;
        return {
            dimensions: metadata.dimensions,
            spacing,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            },
            scaling: this.scaling,
            imageData: {
                getDirection: () => metadata.direction,
                getDimensions: () => metadata.dimensions,
                getScalarData: () => this.cpuImagePixelData,
                getSpacing: () => spacing,
                worldToIndex: (point) => {
                    const canvasPoint = this.worldToCanvasCPU(point);
                    const pixelCoord = canvasToPixel(this._cpuFallbackEnabledElement, canvasPoint);
                    return [pixelCoord[0], pixelCoord[1], 0];
                },
                indexToWorld: (point, destPoint) => {
                    const canvasPoint = pixelToCanvas(this._cpuFallbackEnabledElement, [
                        point[0],
                        point[1],
                    ]);
                    return this.canvasToWorldCPU(canvasPoint, destPoint);
                },
            },
            scalarData: this.cpuImagePixelData,
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: { ...csImage?.calibration, ...this.calibration },
            preScale: {
                ...csImage?.preScale,
            },
            voxelManager: csImage?.voxelManager,
        };
    }
    calibrateIfNecessary(imageId, imagePlaneModule) {
        const calibration = metaData.get('calibratedPixelSpacing', imageId);
        const isUpdated = this.calibration !== calibration;
        const { scale } = calibration || {};
        this.hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;
        imagePlaneModule.calibration = calibration;
        if (!isUpdated) {
            return imagePlaneModule;
        }
        this.calibration = calibration;
        this._publishCalibratedEvent = true;
        this._calibrationEvent = {
            scale,
            calibration,
        };
        return imagePlaneModule;
    }
    setDefaultProperties(ViewportProperties, imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = ViewportProperties;
        }
        else {
            this.perImageIdDefaultProperties.set(imageId, ViewportProperties);
            if (this.getCurrentImageId() === imageId) {
                this.setProperties(ViewportProperties);
            }
        }
    }
    clearDefaultProperties(imageId) {
        if (imageId == null) {
            this.globalDefaultProperties = {};
            this.resetProperties();
        }
        else {
            this.perImageIdDefaultProperties.delete(imageId);
            this.resetToDefaultProperties();
        }
    }
    setProperties({ colormap, voiRange, VOILUTFunction, invert, interpolationType, } = {}, suppressEvents = false) {
        this.viewportStatus = this.csImage
            ? enums.ViewportStatus.PRE_RENDER
            : enums.ViewportStatus.LOADING;
        this.globalDefaultProperties = {
            colormap: this.globalDefaultProperties.colormap ?? colormap,
            voiRange: this.globalDefaultProperties.voiRange ?? voiRange,
            VOILUTFunction: this.globalDefaultProperties.VOILUTFunction ?? VOILUTFunction,
            invert: this.globalDefaultProperties.invert ?? invert,
            interpolationType: this.globalDefaultProperties.interpolationType ?? interpolationType,
        };
        if (typeof colormap !== 'undefined') {
            this.setColormap(colormap);
        }
        if (typeof voiRange !== 'undefined') {
            const voiUpdatedWithSetProperties = true;
            this.setVOI(voiRange, { suppressEvents, voiUpdatedWithSetProperties });
        }
        if (typeof VOILUTFunction !== 'undefined') {
            this.setVOILUTFunction(VOILUTFunction, suppressEvents);
        }
        if (typeof invert !== 'undefined') {
            this.setInvertColor(invert);
        }
        if (typeof interpolationType !== 'undefined') {
            this.setInterpolationType(interpolationType);
        }
    }
    resetProperties() {
        this.cpuRenderingInvalidated = true;
        this.voiUpdatedWithSetProperties = false;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        this._resetProperties();
        this.render();
    }
    _resetProperties() {
        let voiRange;
        if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        this.setVOI(voiRange);
        this.setInvertColor(this.initialInvert);
        this.setInterpolationType(enums.InterpolationType.LINEAR);
        if (!this.useCPURendering) {
            const transferFunction = this.getTransferFunction();
            (0,transferFunctionUtils.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
            const nodes = (0,transferFunctionUtils.getTransferFunctionNodes)(transferFunction);
            const RGBPoints = nodes.reduce((acc, node) => {
                acc.push(node[0], node[1], node[2], node[3]);
                return acc;
            }, []);
            const defaultActor = this.getDefaultActor();
            const matchedColormap = utilities_colormap.findMatchingColormap(RGBPoints, defaultActor.actor);
            this.setColormap(matchedColormap);
        }
    }
    resetToDefaultProperties() {
        this.cpuRenderingInvalidated = true;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
        }
        const currentImageId = this.getCurrentImageId();
        const properties = this.perImageIdDefaultProperties.get(currentImageId) ||
            this.globalDefaultProperties;
        if (properties.colormap?.name) {
            this.setColormap(properties.colormap);
        }
        let voiRange;
        if (properties.voiRange == undefined) {
            voiRange = this._getVOIRangeForCurrentImage();
        }
        else {
            voiRange = properties.voiRange;
        }
        this.setVOI(voiRange);
        this.setInterpolationType(enums.InterpolationType.LINEAR);
        this.setInvertColor(false);
        this.render();
    }
    _getVOIFromCache() {
        let voiRange;
        if (this.voiUpdatedWithSetProperties) {
            voiRange = this.voiRange;
        }
        else if (this._isCurrentImagePTPrescaled()) {
            voiRange = this._getDefaultPTPrescaledVOIRange();
        }
        else {
            voiRange = this._getVOIRangeForCurrentImage() ?? this.voiRange;
        }
        return voiRange;
    }
    _setPropertiesFromCache() {
        const voiRange = this._getVOIFromCache();
        const { interpolationType, invert } = this;
        this.setVOI(voiRange);
        this.setInterpolationType(interpolationType);
        this.setInvertColor(invert);
    }
    getCameraCPU() {
        const { metadata, viewport } = this._cpuFallbackEnabledElement;
        if (!metadata) {
            return {};
        }
        const { direction } = metadata;
        const viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
        let viewUp = direction.slice(3, 6).map((x) => -x);
        if (viewport.rotation) {
            const rotationMatrix = esm/* mat4.fromRotation */.pB.fromRotation(esm/* mat4.create */.pB.create(), (viewport.rotation * Math.PI) / 180, viewPlaneNormal);
            viewUp = esm/* vec3.transformMat4 */.eR.transformMat4(esm/* vec3.create */.eR.create(), viewUp, rotationMatrix);
        }
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const canvasCenterWorld = this.canvasToWorld(canvasCenter);
        const topLeftWorld = this.canvasToWorld([0, 0]);
        const bottomLeftWorld = this.canvasToWorld([0, this.element.clientHeight]);
        const parallelScale = esm/* vec3.distance */.eR.distance(topLeftWorld, bottomLeftWorld) / 2;
        return {
            parallelProjection: true,
            focalPoint: canvasCenterWorld,
            position: [0, 0, 0],
            parallelScale,
            scale: viewport.scale,
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
        };
    }
    setCameraCPU(cameraInterface) {
        const { viewport, image } = this._cpuFallbackEnabledElement;
        const previousCamera = this.getCameraCPU();
        const { focalPoint, parallelScale, scale, flipHorizontal, flipVertical } = cameraInterface;
        const { clientHeight } = this.element;
        if (focalPoint) {
            const focalPointCanvas = this.worldToCanvasCPU(focalPoint);
            const focalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, focalPointCanvas);
            const prevFocalPointCanvas = this.worldToCanvasCPU(previousCamera.focalPoint);
            const prevFocalPointPixel = canvasToPixel(this._cpuFallbackEnabledElement, prevFocalPointCanvas);
            const deltaPixel = esm/* vec2.create */.Zc.create();
            esm/* vec2.subtract */.Zc.subtract(deltaPixel, esm/* vec2.fromValues */.Zc.fromValues(focalPointPixel[0], focalPointPixel[1]), esm/* vec2.fromValues */.Zc.fromValues(prevFocalPointPixel[0], prevFocalPointPixel[1]));
            const shift = correctShift({ x: deltaPixel[0], y: deltaPixel[1] }, viewport);
            viewport.translation.x -= shift.x;
            viewport.translation.y -= shift.y;
        }
        if (parallelScale) {
            const { rowPixelSpacing } = image;
            const scale = (clientHeight * rowPixelSpacing * 0.5) / parallelScale;
            viewport.scale = scale;
            viewport.parallelScale = parallelScale;
        }
        if (scale) {
            const { rowPixelSpacing } = image;
            viewport.scale = scale;
            viewport.parallelScale = (clientHeight * rowPixelSpacing * 0.5) / scale;
        }
        if (flipHorizontal !== undefined || flipVertical !== undefined) {
            this.setFlipCPU({ flipHorizontal, flipVertical });
        }
        this._cpuFallbackEnabledElement.transform = (0,calculateTransform/* default */.A)(this._cpuFallbackEnabledElement);
        const eventDetail = {
            previousCamera,
            camera: this.getCamera(),
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
    }
    getPanCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return [viewport.translation.x, viewport.translation.y];
    }
    setPanCPU(pan) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({
            ...camera,
            focalPoint: [...pan.map((p) => -p), 0],
        });
    }
    getZoomCPU() {
        const { viewport } = this._cpuFallbackEnabledElement;
        return viewport.scale;
    }
    setZoomCPU(zoom) {
        const camera = this.getCameraCPU();
        this.setCameraCPU({ ...camera, scale: zoom });
    }
    setFlipCPU({ flipHorizontal, flipVertical }) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (flipHorizontal !== undefined) {
            viewport.hflip = flipHorizontal;
            this.flipHorizontal = viewport.hflip;
        }
        if (flipVertical !== undefined) {
            viewport.vflip = flipVertical;
            this.flipVertical = viewport.vflip;
        }
    }
    setVOILUTFunction(voiLUTFunction, suppressEvents) {
        if (this.useCPURendering) {
            throw new Error('VOI LUT function is not supported in CPU rendering');
        }
        const newVOILUTFunction = this._getValidVOILUTFunction(voiLUTFunction);
        let forceRecreateLUTFunction = false;
        if (this.VOILUTFunction !== newVOILUTFunction) {
            forceRecreateLUTFunction = true;
        }
        this.VOILUTFunction = newVOILUTFunction;
        const { voiRange } = this.getProperties();
        this.setVOI(voiRange, { suppressEvents, forceRecreateLUTFunction });
    }
    setRotationCPU(rotation) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.rotation = rotation;
    }
    setRotationGPU(rotation) {
        const panFit = this.getPan(this.fitToCanvasCamera);
        const pan = this.getPan();
        const panSub = esm/* vec2.sub */.Zc.sub([0, 0], panFit, pan);
        this.setPan(panSub, false);
        const { flipVertical } = this.getCamera();
        const initialViewUp = flipVertical
            ? esm/* vec3.negate */.eR.negate(esm/* vec3.create */.eR.create(), this.initialViewUp)
            : this.initialViewUp;
        this.setCameraNoEvent({
            viewUp: initialViewUp,
        });
        this.getVtkActiveCamera().roll(-rotation);
        const afterPan = this.getPan();
        const afterPanFit = this.getPan(this.fitToCanvasCamera);
        const newCenter = esm/* vec2.sub */.Zc.sub([0, 0], afterPan, afterPanFit);
        const newOffset = esm/* vec2.add */.Zc.add([0, 0], panFit, newCenter);
        this.setPan(newOffset, false);
    }
    setInterpolationTypeGPU(interpolationType) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const { actor } = defaultActor;
        const volumeProperty = actor.getProperty();
        volumeProperty.setInterpolationType(interpolationType);
        this.interpolationType = interpolationType;
    }
    setInterpolationTypeCPU(interpolationType) {
        const { viewport } = this._cpuFallbackEnabledElement;
        viewport.pixelReplication =
            interpolationType === enums.InterpolationType.LINEAR ? false : true;
        this.interpolationType = interpolationType;
    }
    setInvertColorCPU(invert) {
        const { viewport } = this._cpuFallbackEnabledElement;
        if (!viewport) {
            return;
        }
        viewport.invert = invert;
        this.invert = invert;
    }
    setInvertColorGPU(invert) {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        if ((0,actorCheck/* actorIsA */.N)(defaultActor, 'vtkVolume')) {
            const volumeActor = defaultActor.actor;
            const tfunc = volumeActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                (0,invertRgbTransferFunction/* default */.A)(tfunc);
            }
            this.invert = invert;
        }
        else if ((0,actorCheck/* actorIsA */.N)(defaultActor, 'vtkImageSlice')) {
            const imageSliceActor = defaultActor.actor;
            const tfunc = imageSliceActor.getProperty().getRGBTransferFunction(0);
            if ((!this.invert && invert) || (this.invert && !invert)) {
                (0,invertRgbTransferFunction/* default */.A)(tfunc);
            }
            this.invert = invert;
        }
    }
    setVOICPU(voiRange, options = {}) {
        const { suppressEvents = false } = options;
        const { viewport, image } = this._cpuFallbackEnabledElement;
        if (!viewport || !image) {
            return;
        }
        if (typeof voiRange === 'undefined') {
            const { windowWidth: ww, windowCenter: wc } = image;
            const wwToUse = Array.isArray(ww) ? ww[0] : ww;
            const wcToUse = Array.isArray(wc) ? wc[0] : wc;
            viewport.voi = {
                windowWidth: wwToUse,
                windowCenter: wcToUse,
                voiLUTFunction: image.voiLUTFunction,
            };
            const { lower, upper } = windowLevel.toLowHighRange(wwToUse, wcToUse, image.voiLUTFunction);
            voiRange = { lower, upper };
        }
        else {
            const { lower, upper } = voiRange;
            const { windowCenter, windowWidth } = windowLevel.toWindowLevel(lower, upper);
            if (!viewport.voi) {
                viewport.voi = {
                    windowWidth: 0,
                    windowCenter: 0,
                    voiLUTFunction: image.voiLUTFunction,
                };
            }
            viewport.voi.windowWidth = windowWidth;
            viewport.voi.windowCenter = windowCenter;
        }
        this.voiRange = voiRange;
        const eventDetail = {
            viewportId: this.id,
            range: voiRange,
        };
        if (!suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetail);
        }
    }
    getTransferFunction() {
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        return imageActor.getProperty().getRGBTransferFunction(0);
    }
    setVOIGPU(voiRange, options = {}) {
        const { suppressEvents = false, forceRecreateLUTFunction = false, voiUpdatedWithSetProperties = false, } = options;
        if (voiRange &&
            this.voiRange &&
            this.voiRange.lower === voiRange.lower &&
            this.voiRange.upper === voiRange.upper &&
            !forceRecreateLUTFunction &&
            !this.stackInvalidated) {
            return;
        }
        const defaultActor = this.getDefaultActor();
        if (!defaultActor) {
            return;
        }
        if (!(0,actorCheck/* isImageActor */.e)(defaultActor)) {
            return;
        }
        const imageActor = defaultActor.actor;
        let voiRangeToUse = voiRange;
        if (typeof voiRangeToUse === 'undefined') {
            const imageData = imageActor.getMapper().getInputData();
            const range = imageData.getPointData().getScalars().getRange();
            const maxVoiRange = { lower: range[0], upper: range[1] };
            voiRangeToUse = maxVoiRange;
        }
        imageActor.getProperty().setUseLookupTableScalarRange(true);
        let transferFunction = imageActor.getProperty().getRGBTransferFunction(0);
        const isSigmoidTFun = this.VOILUTFunction === enums.VOILUTFunctionType.SAMPLED_SIGMOID;
        if (isSigmoidTFun || !transferFunction || forceRecreateLUTFunction) {
            const transferFunctionCreator = isSigmoidTFun
                ? createSigmoidRGBTransferFunction/* default */.A
                : createLinearRGBTransferFunction/* default */.A;
            transferFunction = transferFunctionCreator(voiRangeToUse);
            if (this.invert) {
                (0,invertRgbTransferFunction/* default */.A)(transferFunction);
            }
            imageActor.getProperty().setRGBTransferFunction(0, transferFunction);
            this.initialTransferFunctionNodes =
                (0,transferFunctionUtils.getTransferFunctionNodes)(transferFunction);
        }
        if (!isSigmoidTFun) {
            transferFunction.setRange(voiRangeToUse.lower, voiRangeToUse.upper);
        }
        this.voiRange = voiRangeToUse;
        if (!this.voiUpdatedWithSetProperties) {
            this.voiUpdatedWithSetProperties = voiUpdatedWithSetProperties;
        }
        if (suppressEvents) {
            return;
        }
        const eventDetail = {
            viewportId: this.id,
            range: voiRangeToUse,
            VOILUTFunction: this.VOILUTFunction,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetail);
    }
    _addScalingToViewport(imageIdScalingFactor) {
        if (this.scaling.PT) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = imageIdScalingFactor;
        const ptScaling = {};
        if (suvlbm) {
            ptScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            ptScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        this.scaling.PT = ptScaling;
    }
    getImageDataMetadata(image) {
        const imageId = image.imageId;
        const props = (0,getImageDataMetadata/* getImageDataMetadata */.T)(image);
        const { numberOfComponents, origin, direction, dimensions, spacing, numVoxels, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = props;
        if (modality === 'PT' && scalingFactor) {
            this._addScalingToViewport(scalingFactor);
        }
        this.modality = modality;
        const voiLUTFunctionEnum = this._getValidVOILUTFunction(voiLUTFunction);
        this.VOILUTFunction = voiLUTFunctionEnum;
        this.calibration = calibration;
        let imagePlaneModule = this._getImagePlaneModule(imageId);
        if (!this.useCPURendering) {
            imagePlaneModule = this.calibrateIfNecessary(imageId, imagePlaneModule);
        }
        return {
            bitsAllocated: imagePixelModule.bitsAllocated,
            numberOfComponents,
            origin,
            direction,
            dimensions,
            spacing,
            numVoxels,
            imagePlaneModule,
            imagePixelModule,
        };
    }
    matchImagesForOverlay(currentImageId, targetOverlayImageId) {
        const matchImagesForOverlay = (targetImageId) => {
            const overlayImagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, targetOverlayImageId);
            const currentImagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, targetImageId);
            const overlayOrientation = overlayImagePlaneModule.imageOrientationPatient;
            const currentOrientation = currentImagePlaneModule.imageOrientationPatient;
            if (overlayOrientation && currentOrientation) {
                const closeEnough = (0,isEqual/* isEqual */.n4)(overlayImagePlaneModule.imageOrientationPatient, currentImagePlaneModule.imageOrientationPatient);
                if (closeEnough) {
                    const referencePosition = overlayImagePlaneModule.imagePositionPatient;
                    const currentPosition = currentImagePlaneModule.imagePositionPatient;
                    if (referencePosition && currentPosition) {
                        const closeEnough = (0,isEqual/* isEqual */.n4)(referencePosition, currentPosition);
                        if (closeEnough) {
                            const referenceRows = overlayImagePlaneModule.rows;
                            const referenceColumns = overlayImagePlaneModule.columns;
                            const currentRows = currentImagePlaneModule.rows;
                            const currentColumns = currentImagePlaneModule.columns;
                            if (referenceRows === currentRows &&
                                referenceColumns === currentColumns) {
                                return targetImageId;
                            }
                        }
                    }
                }
            }
            else {
                const referenceRows = overlayImagePlaneModule.rows;
                const referenceColumns = overlayImagePlaneModule.columns;
                const currentRows = currentImagePlaneModule.rows;
                const currentColumns = currentImagePlaneModule.columns;
                if (referenceRows === currentRows &&
                    referenceColumns === currentColumns) {
                    return targetImageId;
                }
            }
        };
        return matchImagesForOverlay(currentImageId);
    }
    getImagePlaneReferenceData(sliceIndex = this.getCurrentImageIdIndex()) {
        const imageId = this.imageIds[sliceIndex];
        if (!imageId) {
            return;
        }
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, imageId);
        if (!imagePlaneModule) {
            return;
        }
        const { imagePositionPatient, frameOfReferenceUID: FrameOfReferenceUID } = imagePlaneModule;
        let { rowCosines, columnCosines } = imagePlaneModule;
        rowCosines ||= [1, 0, 0];
        columnCosines ||= [0, 1, 0];
        const viewPlaneNormal = esm/* vec3.cross */.eR.cross([0, 0, 0], columnCosines, rowCosines);
        return {
            FrameOfReferenceUID,
            viewPlaneNormal,
            cameraFocalPoint: imagePositionPatient,
            referencedImageId: imageId,
            sliceIndex,
        };
    }
    _getCameraOrientation(imageDataDirection) {
        const viewPlaneNormal = imageDataDirection.slice(6, 9).map((x) => -x);
        const viewUp = imageDataDirection.slice(3, 6).map((x) => -x);
        return {
            viewPlaneNormal: [
                viewPlaneNormal[0],
                viewPlaneNormal[1],
                viewPlaneNormal[2],
            ],
            viewUp: [viewUp[0], viewUp[1], viewUp[2]],
        };
    }
    createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        const values = new pixelArray.constructor(pixelArray.length);
        const scalarArray = DataArray/* default.newInstance */.Ay.newInstance({
            name: 'Pixels',
            numberOfComponents: numberOfComponents,
            values: values,
        });
        const imageData = ImageData/* default.newInstance */.Ay.newInstance();
        imageData.setDimensions(dimensions);
        imageData.setSpacing(spacing);
        imageData.setDirection(direction);
        imageData.setOrigin(origin);
        imageData.getPointData().setScalars(scalarArray);
        return imageData;
    }
    _createVTKImageData({ origin, direction, dimensions, spacing, numberOfComponents, pixelArray, }) {
        try {
            this._imageData = this.createVTKImageData({
                origin,
                direction,
                dimensions,
                spacing,
                numberOfComponents,
                pixelArray,
            });
        }
        catch (e) {
            log.error(e);
        }
    }
    async setStack(imageIds, currentImageIdIndex = 0) {
        this._throwIfDestroyed();
        this.imageIds = imageIds;
        if (currentImageIdIndex > imageIds.length) {
            throw new Error('Current image index is greater than the number of images in the stack');
        }
        this.imageKeyToIndexMap.clear();
        imageIds.forEach((imageId, index) => {
            this.imageKeyToIndexMap.set(imageId, index);
            this.imageKeyToIndexMap.set((0,imageIdToURI/* default */.A)(imageId), index);
        });
        this.currentImageIdIndex = currentImageIdIndex;
        this.targetImageIdIndex = currentImageIdIndex;
        const imageRetrieveConfiguration = metaData.get(imageRetrieveMetadataProvider/* default */.A.IMAGE_RETRIEVE_CONFIGURATION, imageIds[currentImageIdIndex], 'stack');
        this.imagesLoader = imageRetrieveConfiguration
            ? (imageRetrieveConfiguration.create || ProgressiveRetrieveImages/* createProgressive */.Ke)(imageRetrieveConfiguration)
            : this;
        this.stackInvalidated = true;
        this.flipVertical = false;
        this.flipHorizontal = false;
        this.voiRange = null;
        this.interpolationType = enums.InterpolationType.LINEAR;
        this.invert = false;
        this.viewportStatus = enums.ViewportStatus.LOADING;
        this.fillWithBackgroundColor();
        if (this.useCPURendering) {
            this._cpuFallbackEnabledElement.renderingTools = {};
            delete this._cpuFallbackEnabledElement.viewport.colormap;
        }
        const imageId = await this._setImageIdIndex(currentImageIdIndex);
        const eventDetail = {
            imageIds,
            viewportId: this.id,
            element: this.element,
            currentImageIdIndex: currentImageIdIndex,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VIEWPORT_NEW_IMAGE_SET, eventDetail);
        return imageId;
    }
    _throwIfDestroyed() {
        if (this.isDisabled) {
            throw new Error('The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you ' +
                'are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance ' +
                'using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.');
        }
    }
    _checkVTKImageDataMatchesCornerstoneImage(image, imageData) {
        if (!imageData) {
            return false;
        }
        const [xSpacing, ySpacing] = imageData.getSpacing();
        const [xVoxels, yVoxels] = imageData.getDimensions();
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        const direction = imageData.getDirection();
        const rowCosines = direction.slice(0, 3);
        const columnCosines = direction.slice(3, 6);
        const dataType = imageData.getPointData().getScalars().getDataType();
        const isSameXSpacing = (0,isEqual/* isEqual */.n4)(xSpacing, image.columnPixelSpacing);
        const isSameYSpacing = (0,isEqual/* isEqual */.n4)(ySpacing, image.rowPixelSpacing);
        const isXSpacingValid = isSameXSpacing || (image.columnPixelSpacing === null && xSpacing === 1.0);
        const isYSpacingValid = isSameYSpacing || (image.rowPixelSpacing === null && ySpacing === 1.0);
        const isXVoxelsMatching = xVoxels === image.columns;
        const isYVoxelsMatching = yVoxels === image.rows;
        const isRowCosinesMatching = (0,isEqual/* isEqual */.n4)(imagePlaneModule.rowCosines, rowCosines);
        const isColumnCosinesMatching = (0,isEqual/* isEqual */.n4)(imagePlaneModule.columnCosines, columnCosines);
        const isDataTypeMatching = dataType === image.voxelManager.getScalarData().constructor.name;
        const result = isXSpacingValid &&
            isYSpacingValid &&
            isXVoxelsMatching &&
            isYVoxelsMatching &&
            isRowCosinesMatching &&
            isColumnCosinesMatching &&
            isDataTypeMatching;
        return result;
    }
    _updateVTKImageDataFromCornerstoneImage(image) {
        const imagePlaneModule = this._getImagePlaneModule(image.imageId);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        this._imageData.setOrigin(origin);
        const actor = this.getActor(this.id);
        if (actor) {
            actor.referencedId = image.imageId;
        }
        (0,updateVTKImageDataWithCornerstoneImage/* updateVTKImageDataWithCornerstoneImage */.J)(this._imageData, image);
    }
    _loadAndDisplayImage(imageId, imageIdIndex) {
        return this.useCPURendering
            ? this._loadAndDisplayImageCPU(imageId, imageIdIndex)
            : this._loadAndDisplayImageGPU(imageId, imageIdIndex);
    }
    _loadAndDisplayImageCPU(imageId, imageIdIndex) {
        return new Promise((resolve, reject) => {
            function successCallback(image, imageIdIndex, imageId) {
                if (this.currentImageIdIndex !== imageIdIndex) {
                    return;
                }
                const pixelData = image.voxelManager.getScalarData();
                const preScale = image.preScale;
                const scalingParams = preScale?.scalingParameters;
                const scaledWithNonIntegers = (preScale?.scaled && scalingParams?.rescaleIntercept % 1 !== 0) ||
                    scalingParams?.rescaleSlope % 1 !== 0;
                if (pixelData instanceof Float32Array && scaledWithNonIntegers) {
                    const floatMinMax = {
                        min: image.minPixelValue,
                        max: image.maxPixelValue,
                    };
                    const floatRange = Math.abs(floatMinMax.max - floatMinMax.min);
                    const intRange = 65535;
                    const slope = floatRange / intRange;
                    const intercept = floatMinMax.min;
                    const numPixels = pixelData.length;
                    const intPixelData = new Uint16Array(numPixels);
                    let min = 65535;
                    let max = 0;
                    for (let i = 0; i < numPixels; i++) {
                        const rescaledPixel = Math.floor((pixelData[i] - intercept) / slope);
                        intPixelData[i] = rescaledPixel;
                        min = Math.min(min, rescaledPixel);
                        max = Math.max(max, rescaledPixel);
                    }
                    image.minPixelValue = min;
                    image.maxPixelValue = max;
                    image.slope = slope;
                    image.intercept = intercept;
                    if (image.voxelManager) {
                        image.voxelManager.getScalarData = () => intPixelData;
                    }
                    else {
                        image.getPixelData = () => intPixelData;
                    }
                    image.preScale = {
                        ...image.preScale,
                        scaled: false,
                    };
                }
                this._setCSImage(image);
                this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
                const eventDetail = {
                    image,
                    imageId,
                    imageIdIndex,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId,
                };
                (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, eventDetail);
                this._updateToDisplayImageCPU(image);
                this.render();
                this.currentImageIdIndex = imageIdIndex;
                resolve(imageId);
            }
            function errorCallback(error, imageIdIndex, imageId) {
                const eventDetail = {
                    error,
                    imageIdIndex,
                    imageId,
                };
                if (!this.suppressEvents) {
                    (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_LOAD_ERROR, eventDetail);
                }
                reject(error);
            }
            function sendRequest(imageId, imageIdIndex, options) {
                return (0,imageLoader.loadAndCacheImage)(imageId, options).then((image) => {
                    successCallback.call(this, image, imageIdIndex, imageId);
                }, (error) => {
                    errorCallback.call(this, error, imageIdIndex, imageId);
                });
            }
            const priority = -5;
            const requestType = enums.RequestType.Interaction;
            const additionalDetails = { imageId, imageIdIndex };
            const options = {
                useRGBA: true,
                requestType,
            };
            const eventDetail = {
                imageId,
                imageIdIndex,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.PRE_STACK_NEW_IMAGE, eventDetail);
            imageLoadPoolManager/* default */.A.addRequest(sendRequest.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        if (this.currentImageIdIndex !== imageIdIndex) {
            return;
        }
        const csImgFrame = this.csImage?.imageFrame;
        const imgFrame = image?.imageFrame;
        const photometricInterpretation = csImgFrame?.photometricInterpretation ||
            this.csImage?.photometricInterpretation;
        const newPhotometricInterpretation = imgFrame?.photometricInterpretation || image?.photometricInterpretation;
        if (photometricInterpretation !== newPhotometricInterpretation) {
            this.stackInvalidated = true;
        }
        this._setCSImage(image);
        const eventDetail = {
            image,
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        this._updateActorToDisplayImageId(image);
        (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, eventDetail);
        this.render();
        this.currentImageIdIndex = imageIdIndex;
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    getLoaderImageOptions(imageId) {
        const imageIdIndex = this.imageIds.indexOf(imageId);
        const { transferSyntaxUID } = metaData.get('transferSyntax', imageId) || {};
        const options = {
            useRGBA: false,
            transferSyntaxUID,
            priority: 5,
            requestType: enums.RequestType.Interaction,
            additionalDetails: { imageId, imageIdIndex },
        };
        return options;
    }
    async loadImages(imageIds, listener) {
        const resultList = await Promise.allSettled(imageIds.map((imageId) => {
            const options = this.getLoaderImageOptions(imageId);
            return (0,imageLoader.loadAndCacheImage)(imageId, options).then((image) => {
                listener.successCallback(imageId, image);
                return imageId;
            }, (error) => {
                listener.errorCallback(imageId, true, error);
                return imageId;
            });
        }));
        const errorList = resultList.filter((item) => item.status === 'rejected');
        if (errorList && errorList.length) {
            const event = new CustomEvent(enums.Events.IMAGE_LOAD_ERROR, {
                detail: errorList,
                cancelable: true,
            });
            eventTarget/* default */.A.dispatchEvent(event);
        }
        return resultList;
    }
    _loadAndDisplayImageGPU(imageId, imageIdIndex) {
        if (!imageId) {
            console.warn('No image id set yet to load');
            return;
        }
        const eventDetail = {
            imageId,
            imageIdIndex,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.PRE_STACK_NEW_IMAGE, eventDetail);
        return this.imagesLoader.loadImages([imageId], this).then((v) => {
            return imageId;
        });
    }
    _updateToDisplayImageCPU(image) {
        const metadata = this.getImageDataMetadata(image);
        const viewport = (0,getDefaultViewport/* default */.A)(this.canvas, image, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
        const { windowCenter, windowWidth, voiLUTFunction } = viewport.voi;
        this.voiRange = windowLevel.toLowHighRange(windowWidth, windowCenter, voiLUTFunction);
        this._cpuFallbackEnabledElement.image = image;
        this._cpuFallbackEnabledElement.metadata = {
            ...metadata,
        };
        this.cpuImagePixelData = image.voxelManager.getScalarData();
        const viewportSettingToUse = Object.assign({}, viewport, this._cpuFallbackEnabledElement.viewport);
        this._cpuFallbackEnabledElement.viewport = this.stackInvalidated
            ? viewport
            : viewportSettingToUse;
        this.stackInvalidated = false;
        this.cpuRenderingInvalidated = true;
        this._cpuFallbackEnabledElement.transform = (0,calculateTransform/* default */.A)(this._cpuFallbackEnabledElement);
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    addImages(stackInputs) {
        const actors = [];
        stackInputs.forEach((stackInput) => {
            const { imageId, ...rest } = stackInput;
            const image = cache/* default */.Ay.getImage(imageId);
            const { origin, dimensions, direction, spacing, numberOfComponents } = this.getImageDataMetadata(image);
            const imagedata = this.createVTKImageData({
                origin,
                dimensions,
                direction,
                spacing,
                numberOfComponents,
                pixelArray: image.voxelManager.getScalarData(),
            });
            const imageActor = this.createActorMapper(imagedata);
            if (imageActor) {
                actors.push({
                    uid: stackInput.actorUID ?? (0,uuidv4/* default */.A)(),
                    actor: imageActor,
                    referencedId: imageId,
                    ...rest,
                });
                if (stackInput.callback) {
                    stackInput.callback({ imageActor, imageId: stackInput.imageId });
                }
            }
        });
        this.addActors(actors);
    }
    _updateActorToDisplayImageId(image) {
        const sameImageData = this._checkVTKImageDataMatchesCornerstoneImage(image, this._imageData);
        const viewPresentation = this.getViewPresentation();
        if (sameImageData && !this.stackInvalidated) {
            this._updateVTKImageDataFromCornerstoneImage(image);
            this.resetCameraNoEvent();
            this.setViewPresentation(viewPresentation);
            this._setPropertiesFromCache();
            this.stackActorReInitialized = false;
            return;
        }
        const { origin, direction, dimensions, spacing, numberOfComponents, imagePixelModule, } = this.getImageDataMetadata(image);
        const pixelArray = image.voxelManager.getScalarData();
        this._createVTKImageData({
            origin,
            direction,
            dimensions,
            spacing,
            numberOfComponents,
            pixelArray,
        });
        this._updateVTKImageDataFromCornerstoneImage(image);
        const actor = this.createActorMapper(this._imageData);
        const oldActors = this.getActors();
        if (oldActors.length && oldActors[0].uid === this.id) {
            oldActors[0].actor = actor;
        }
        else {
            oldActors.unshift({ uid: this.id, actor, referencedId: image.imageId });
        }
        this.setActors(oldActors);
        const { viewPlaneNormal, viewUp } = this._getCameraOrientation(direction);
        const previousCamera = this.getCamera();
        this.setCameraNoEvent({ viewUp, viewPlaneNormal });
        this.initialViewUp = viewUp;
        this.resetCameraNoEvent();
        this.setViewPresentation(viewPresentation);
        this.triggerCameraEvent(this.getCamera(), previousCamera);
        const monochrome1 = imagePixelModule.photometricInterpretation === 'MONOCHROME1';
        this.stackInvalidated = true;
        const voiRange = this._getInitialVOIRange(image);
        this.setVOI(voiRange, {
            forceRecreateLUTFunction: !!monochrome1,
        });
        this.initialInvert = !!monochrome1;
        this.setInvertColor(this.invert || this.initialInvert);
        this.stackInvalidated = false;
        this.stackActorReInitialized = true;
        if (this._publishCalibratedEvent) {
            this.triggerCalibrationEvent();
        }
    }
    _getInitialVOIRange(image) {
        if (this.voiRange && this.voiUpdatedWithSetProperties) {
            return this.voiRange;
        }
        const { windowCenter, windowWidth, voiLUTFunction } = image;
        let voiRange = this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
        voiRange = this._getPTPreScaledRange() || voiRange;
        return voiRange;
    }
    _getPTPreScaledRange() {
        if (!this._isCurrentImagePTPrescaled()) {
            return undefined;
        }
        return this._getDefaultPTPrescaledVOIRange();
    }
    _isCurrentImagePTPrescaled() {
        if (this.modality !== 'PT' || !this.csImage.isPreScaled) {
            return false;
        }
        if (!this.csImage.preScale?.scalingParameters.suvbw) {
            return false;
        }
        return true;
    }
    _getDefaultPTPrescaledVOIRange() {
        return { lower: 0, upper: 5 };
    }
    _getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction = enums.VOILUTFunctionType.LINEAR) {
        let center, width;
        if (typeof windowCenter === 'number' && typeof windowWidth === 'number') {
            center = windowCenter;
            width = windowWidth;
        }
        else if (Array.isArray(windowCenter) && Array.isArray(windowWidth)) {
            center = windowCenter[0];
            width = windowWidth[0];
        }
        if (center !== undefined && width !== undefined) {
            return windowLevel.toLowHighRange(width, center, voiLUTFunction);
        }
    }
    async _setImageIdIndex(imageIdIndex) {
        if (imageIdIndex >= this.imageIds.length) {
            throw new Error(`ImageIdIndex provided ${imageIdIndex} is invalid, the stack only has ${this.imageIds.length} elements`);
        }
        this.currentImageIdIndex = imageIdIndex;
        this.hasPixelSpacing = true;
        this.viewportStatus = enums.ViewportStatus.PRE_RENDER;
        const imageId = await this._loadAndDisplayImage(this.imageIds[imageIdIndex], imageIdIndex);
        if (this.perImageIdDefaultProperties.size >= 1) {
            const defaultProperties = this.perImageIdDefaultProperties.get(imageId);
            if (defaultProperties !== undefined) {
                this.setProperties(defaultProperties);
            }
            else if (this.globalDefaultProperties !== undefined) {
                this.setProperties(this.globalDefaultProperties);
            }
        }
        return imageId;
    }
    resetCameraCPU({ resetPan = true, resetZoom = true, }) {
        const { image } = this._cpuFallbackEnabledElement;
        if (!image) {
            return;
        }
        resetCamera(this._cpuFallbackEnabledElement, resetPan, resetZoom);
        const { scale } = this._cpuFallbackEnabledElement.viewport;
        const { clientWidth, clientHeight } = this.element;
        const center = [clientWidth / 2, clientHeight / 2];
        const centerWorld = this.canvasToWorldCPU(center);
        this.setCameraCPU({
            focalPoint: centerWorld,
            scale,
        });
    }
    resetCameraGPU({ resetPan, resetZoom }) {
        this.setCamera({
            flipHorizontal: false,
            flipVertical: false,
            viewUp: this.initialViewUp,
        });
        const resetToCenter = true;
        return super.resetCamera({ resetPan, resetZoom, resetToCenter });
    }
    scroll(delta, debounce = true, loop = false) {
        const imageIds = this.imageIds;
        if (isNaN(this.targetImageIdIndex)) {
            return;
        }
        const currentTargetImageIdIndex = this.targetImageIdIndex;
        const numberOfFrames = imageIds.length;
        let newTargetImageIdIndex = currentTargetImageIdIndex + delta;
        if (loop) {
            newTargetImageIdIndex =
                (newTargetImageIdIndex + numberOfFrames) % numberOfFrames;
        }
        else {
            newTargetImageIdIndex = Math.max(0, Math.min(numberOfFrames - 1, newTargetImageIdIndex));
        }
        this.targetImageIdIndex = newTargetImageIdIndex;
        const targetImageId = imageIds[newTargetImageIdIndex];
        const imageAlreadyLoaded = cache/* default */.Ay.isLoaded(targetImageId);
        if (imageAlreadyLoaded || !debounce) {
            this.setImageIdIndex(newTargetImageIdIndex);
        }
        else {
            clearTimeout(this.debouncedTimeout);
            this.debouncedTimeout = window.setTimeout(() => {
                this.setImageIdIndex(newTargetImageIdIndex);
            }, 40);
        }
        const eventData = {
            newImageIdIndex: newTargetImageIdIndex,
            imageId: targetImageId,
            direction: delta,
        };
        if (newTargetImageIdIndex !== currentTargetImageIdIndex) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_VIEWPORT_SCROLL, eventData);
        }
    }
    setImageIdIndex(imageIdIndex) {
        this._throwIfDestroyed();
        if (this.currentImageIdIndex === imageIdIndex) {
            return Promise.resolve(this.getCurrentImageId());
        }
        const imageIdPromise = this._setImageIdIndex(imageIdIndex);
        this.targetImageIdIndex = imageIdIndex;
        return imageIdPromise;
    }
    calibrateSpacing(imageId) {
        const imageIdIndex = this.getImageIds().indexOf(imageId);
        this.stackInvalidated = true;
        this._loadAndDisplayImage(imageId, imageIdIndex);
    }
    triggerCameraEvent(camera, previousCamera) {
        const eventDetail = {
            previousCamera,
            camera,
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
        };
        if (!this.suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_MODIFIED, eventDetail);
        }
    }
    triggerCalibrationEvent() {
        const { imageData } = this.getImageData();
        const eventDetail = {
            element: this.element,
            viewportId: this.id,
            renderingEngineId: this.renderingEngineId,
            imageId: this.getCurrentImageId(),
            imageData: imageData,
            worldToIndex: imageData.getWorldToIndex(),
            ...this._calibrationEvent,
        };
        if (!this.suppressEvents) {
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_SPACING_CALIBRATED, eventDetail);
        }
        this._publishCalibratedEvent = false;
    }
    jumpToWorld(worldPos) {
        const imageIds = this.getImageIds();
        const imageData = this.getImageData();
        const { direction, spacing } = imageData;
        const imageId = (0,getClosestImageId/* default */.A)({ direction, spacing, imageIds }, worldPos, this.getCamera().viewPlaneNormal, { ignoreSpacing: true });
        const index = imageIds.indexOf(imageId);
        if (index === -1) {
            return false;
        }
        this.setImageIdIndex(index);
        this.render();
        return true;
    }
    _getVOIRangeForCurrentImage() {
        const { windowCenter, windowWidth, voiLUTFunction } = this.csImage;
        return this._getVOIRangeFromWindowLevel(windowWidth, windowCenter, voiLUTFunction);
    }
    _getValidVOILUTFunction(voiLUTFunction) {
        if (!Object.values(enums.VOILUTFunctionType).includes(voiLUTFunction)) {
            return enums.VOILUTFunctionType.LINEAR;
        }
        return voiLUTFunction;
    }
    getSliceInfo() {
        const sliceIndex = this.getSliceIndex();
        const { dimensions } = this.getImageData();
        return {
            width: dimensions[0],
            height: dimensions[1],
            sliceIndex,
            slicePlane: 2,
        };
    }
    isReferenceViewable(viewRef, options = {}) {
        const testIndex = this.getCurrentImageIdIndex();
        const currentImageId = this.imageIds[testIndex];
        if (!currentImageId || !viewRef) {
            return false;
        }
        const { referencedImageId, multiSliceReference } = viewRef;
        if (referencedImageId) {
            if (referencedImageId === currentImageId) {
                return true;
            }
            viewRef.referencedImageURI ||= (0,imageIdToURI/* default */.A)(referencedImageId);
            const { referencedImageURI: referencedImageURI } = viewRef;
            const foundSliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
            if (options.asOverlay) {
                const matchedImageId = this.matchImagesForOverlay(currentImageId, referencedImageId);
                if (matchedImageId) {
                    return true;
                }
            }
            if (foundSliceIndex === undefined) {
                return false;
            }
            if (options.withNavigation) {
                return true;
            }
            const rangeEndSliceIndex = multiSliceReference &&
                this.imageKeyToIndexMap.get(multiSliceReference.referencedImageId);
            return testIndex <= rangeEndSliceIndex && testIndex >= foundSliceIndex;
        }
        if (!super.isReferenceViewable(viewRef, options)) {
            return false;
        }
        if (viewRef.volumeId) {
            return options.asVolume;
        }
        const { cameraFocalPoint } = viewRef;
        if (options.asNearbyProjection && cameraFocalPoint) {
            const { spacing, direction, origin } = this.getImageData();
            const viewPlaneNormal = direction.slice(6, 9);
            const sliceThickness = (0,getSpacingInNormalDirection/* default */.A)({ direction, spacing }, viewPlaneNormal);
            const diff = esm/* vec3.subtract */.eR.subtract(esm/* vec3.create */.eR.create(), cameraFocalPoint, origin);
            const distanceToPlane = esm/* vec3.dot */.eR.dot(diff, viewPlaneNormal);
            const threshold = sliceThickness / 2;
            if (Math.abs(distanceToPlane) <= threshold) {
                return true;
            }
        }
        return false;
    }
    getViewReference(viewRefSpecifier = {}) {
        const { sliceIndex = this.getCurrentImageIdIndex() } = viewRefSpecifier;
        const reference = super.getViewReference(viewRefSpecifier);
        const referencedImageId = this.getCurrentImageId(sliceIndex);
        if (!referencedImageId) {
            return;
        }
        reference.referencedImageId = referencedImageId;
        if (this.getCurrentImageIdIndex() !== sliceIndex) {
            const referenceData = this.getImagePlaneReferenceData(sliceIndex);
            if (!referenceData) {
                return;
            }
            Object.assign(reference, referenceData);
        }
        return reference;
    }
    setViewReference(viewRef) {
        if (!viewRef?.referencedImageId) {
            if (viewRef?.sliceIndex !== undefined) {
                this.scroll(viewRef.sliceIndex - this.targetImageIdIndex);
            }
            return;
        }
        const { referencedImageId } = viewRef;
        viewRef.referencedImageURI ||= (0,imageIdToURI/* default */.A)(referencedImageId);
        const { referencedImageURI: referencedImageURI } = viewRef;
        const sliceIndex = this.imageKeyToIndexMap.get(referencedImageURI);
        if (sliceIndex === undefined) {
            log.error(`No image URI found for ${referencedImageURI}`);
            return;
        }
        this.scroll(sliceIndex - this.targetImageIdIndex);
    }
    getViewReferenceId(specifier = {}) {
        const { sliceIndex = this.currentImageIdIndex } = specifier;
        return `imageId:${this.imageIds[sliceIndex]}`;
    }
    getSliceIndexForImage(reference) {
        if (!reference) {
            return;
        }
        if (typeof reference === 'string') {
            return this.imageKeyToIndexMap.get(reference);
        }
        if (reference.referencedImageId) {
            return this.imageKeyToIndexMap.get(reference.referencedImageId);
        }
        return;
    }
    getCPUFallbackError(method) {
        return new Error(`method ${method} cannot be used during CPU Fallback mode`);
    }
    fillWithBackgroundColor() {
        const renderingEngine = this.getRenderingEngine();
        if (renderingEngine) {
            renderingEngine.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
        }
    }
    unsetColormapCPU() {
        delete this._cpuFallbackEnabledElement.viewport.colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.cpuRenderingInvalidated = true;
        this.fillWithBackgroundColor();
        this.render();
    }
    setColormapCPU(colormapData) {
        this.colormap = colormapData;
        const colormap = utilities_colormap.getColormap(colormapData.name);
        this._cpuFallbackEnabledElement.viewport.colormap = colormap;
        this._cpuFallbackEnabledElement.renderingTools = {};
        this.fillWithBackgroundColor();
        this.cpuRenderingInvalidated = true;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap: colormapData,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.COLORMAP_MODIFIED, eventDetail);
    }
    setColormapGPU(colormap) {
        const ActorEntry = this.getDefaultActor();
        const actor = ActorEntry.actor;
        const actorProp = actor.getProperty();
        const rgbTransferFunction = actorProp.getRGBTransferFunction();
        const colormapObj = utilities_colormap.getColormap(colormap.name) ||
            ColorMaps/* default */.A.getPresetByName(colormap.name);
        if (!rgbTransferFunction) {
            const cfun = ColorTransferFunction/* default.newInstance */.Ay.newInstance();
            cfun.applyColorMap(colormapObj);
            cfun.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, cfun);
        }
        else {
            rgbTransferFunction.applyColorMap(colormapObj);
            rgbTransferFunction.setMappingRange(this.voiRange.lower, this.voiRange.upper);
            actorProp.setRGBTransferFunction(0, rgbTransferFunction);
        }
        this.colormap = colormap;
        this.render();
        const eventDetail = {
            viewportId: this.id,
            colormap,
        };
        (0,triggerEvent/* default */.A)(this.element, enums.Events.COLORMAP_MODIFIED, eventDetail);
    }
    unsetColormapGPU() {
        throw new Error('unsetColormapGPU not implemented.');
    }
    _getImagePlaneModule(imageId) {
        const imagePlaneModule = (0,buildMetadata/* getImagePlaneModule */.SJ)(imageId);
        this.hasPixelSpacing =
            !imagePlaneModule.usingDefaultValues ||
                this.calibration?.scale > 0 ||
                this.calibration?.rowPixelSpacing > 0;
        this.calibration ||= imagePlaneModule.calibration;
        return imagePlaneModule;
    }
    isInAcquisitionPlane() {
        return true;
    }
}
/* harmony default export */ const RenderingEngine_StackViewport = (StackViewport);


/***/ }),

/***/ 32501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_VideoViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var rendering_transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 3 modules
var helpers = __webpack_require__(40661);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasProperties.js
class CanvasProperties {
    constructor(actor) {
        this.opacity = 0.4;
        this.outlineOpacity = 0.4;
        this.transferFunction = [];
        this.actor = actor;
    }
    setRGBTransferFunction(index, cfun) {
        this.transferFunction[index] = cfun;
    }
    setScalarOpacity(opacity) {
    }
    setInterpolationTypeToNearest() {
    }
    setUseLabelOutline() {
    }
    setLabelOutlineOpacity(opacity) {
        this.outlineOpacity = opacity;
    }
    setLabelOutlineThickness() {
    }
    getColor(index) {
        const cfun = this.transferFunction[0];
        const r = cfun.getRedValue(index);
        const g = cfun.getGreenValue(index);
        const b = cfun.getBlueValue(index);
        return [r, g, b, this.opacity];
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/CanvasMapper.js
class CanvasMapper {
    constructor(actor) {
        this.actor = actor;
    }
    getInputData() {
        return this.actor.getImage();
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/CanvasActor/index.js


class CanvasActor {
    constructor(viewport, derivedImage) {
        this.canvasProperties = new CanvasProperties(this);
        this.visibility = false;
        this.mapper = new CanvasMapper(this);
        this.className = 'CanvasActor';
        this.derivedImage = derivedImage;
        this.viewport = viewport;
    }
    renderRLE(viewport, context, voxelManager) {
        const { width, height } = this.image;
        let { canvas } = this;
        if (!canvas || canvas.width !== width || canvas.height !== height) {
            this.canvas = canvas = new window.OffscreenCanvas(width, height);
        }
        const localContext = canvas.getContext('2d');
        const imageData = localContext.createImageData(width, height);
        const { data: imageArray } = imageData;
        imageArray.fill(0);
        const { map } = voxelManager;
        let dirtyX = Infinity;
        let dirtyY = Infinity;
        let dirtyX2 = -Infinity;
        let dirtyY2 = -Infinity;
        for (let y = 0; y < height; y++) {
            const row = map.getRun(y, 0);
            if (!row) {
                continue;
            }
            dirtyY = Math.min(dirtyY, y);
            dirtyY2 = Math.max(dirtyY2, y);
            const baseOffset = (y * width) << 2;
            let indicesToDelete;
            for (const run of row) {
                const { start, end, value: segmentIndex } = run;
                if (segmentIndex === 0) {
                    indicesToDelete ||= [];
                    indicesToDelete.push(row.indexOf(run));
                    continue;
                }
                dirtyX = Math.min(dirtyX, start);
                dirtyX2 = Math.max(dirtyX2, end);
                const rgb = this.canvasProperties
                    .getColor(segmentIndex)
                    .map((v) => v * 255);
                let startOffset = baseOffset + (start << 2);
                for (let i = start; i < end; i++) {
                    imageArray[startOffset++] = rgb[0];
                    imageArray[startOffset++] = rgb[1];
                    imageArray[startOffset++] = rgb[2];
                    imageArray[startOffset++] = rgb[3];
                }
            }
        }
        if (dirtyX > width) {
            return;
        }
        const dirtyWidth = dirtyX2 - dirtyX;
        const dirtyHeight = dirtyY2 - dirtyY;
        localContext.putImageData(imageData, 0, 0, dirtyX - 1, dirtyY - 1, dirtyWidth + 2, dirtyHeight + 2);
        context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    setMapper(mapper) {
        this.mapper = mapper;
    }
    render(viewport, context) {
        if (!this.visibility) {
            return;
        }
        const image = this.image || this.getImage();
        const { width, height } = image;
        const data = image.getScalarData();
        if (!data) {
            return;
        }
        const { voxelManager } = image;
        if (voxelManager) {
            if (voxelManager.map.getRun) {
                this.renderRLE(viewport, context, voxelManager);
                return;
            }
        }
        let { canvas } = this;
        if (!canvas || canvas.width !== width || canvas.height !== height) {
            this.canvas = canvas = new window.OffscreenCanvas(width, height);
        }
        const localContext = canvas.getContext('2d');
        const imageData = localContext.createImageData(width, height);
        const { data: imageArray } = imageData;
        let offset = 0;
        let destOffset = 0;
        let dirtyX = Infinity;
        let dirtyY = Infinity;
        let dirtyX2 = -Infinity;
        let dirtyY2 = -Infinity;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const segmentIndex = data[offset++];
                if (segmentIndex) {
                    dirtyX = Math.min(x, dirtyX);
                    dirtyY = Math.min(y, dirtyY);
                    dirtyX2 = Math.max(x, dirtyX2);
                    dirtyY2 = Math.max(y, dirtyY2);
                    const rgb = this.canvasProperties.getColor(segmentIndex);
                    imageArray[destOffset] = rgb[0] * 255;
                    imageArray[destOffset + 1] = rgb[1] * 255;
                    imageArray[destOffset + 2] = rgb[2] * 255;
                    imageArray[destOffset + 3] = 127;
                }
                destOffset += 4;
            }
        }
        if (dirtyX > width) {
            return;
        }
        const dirtyWidth = dirtyX2 - dirtyX + 1;
        const dirtyHeight = dirtyY2 - dirtyY + 1;
        localContext.putImageData(imageData, 0, 0, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        context.drawImage(canvas, dirtyX, dirtyY, dirtyWidth, dirtyHeight, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    getClassName() {
        return this.className;
    }
    getProperty() {
        return this.canvasProperties;
    }
    setVisibility(visibility) {
        this.visibility = visibility;
    }
    getMapper() {
        return this.mapper;
    }
    isA(actorType) {
        return actorType === this.className;
    }
    getImage() {
        if (this.image) {
            return this.image;
        }
        this.image = { ...this.derivedImage };
        const imageData = this.viewport.getImageData();
        Object.assign(this.image, {
            worldToIndex: (worldPos) => imageData.imageData.worldToIndex(worldPos),
            indexToWorld: (index, destPoint) => imageData.imageData.indexToWorld(index, destPoint),
            getDimensions: () => imageData.dimensions,
            getScalarData: () => this.derivedImage?.getPixelData(),
            getDirection: () => imageData.direction,
            getSpacing: () => imageData.spacing,
            setOrigin: () => null,
            setDerivedImage: (image) => {
                this.derivedImage = image;
                this.image = null;
            },
            modified: () => null,
        });
        return this.image;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js
var FrameRange = __webpack_require__(56750);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
var pointInShapeCallback = __webpack_require__(56577);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js












class VideoViewport extends Viewport/* default */.A {
    static { this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i; }
    constructor(props) {
        super({
            ...props,
            canvas: props.canvas || (0,helpers/* getOrCreateCanvas */.oI)(props.element),
        });
        this.videoWidth = 0;
        this.videoHeight = 0;
        this.loop = true;
        this.mute = true;
        this.isPlaying = false;
        this.scrollSpeed = 1;
        this.playbackRate = 1;
        this.frameRange = [0, 0];
        this.fps = 30;
        this.videoCamera = {
            panWorld: [0, 0],
            parallelScale: 1,
        };
        this.voiRange = {
            lower: 0,
            upper: 255,
        };
        this.getProperties = () => {
            return {
                loop: this.videoElement.loop,
                muted: this.videoElement.muted,
                playbackRate: this.playbackRate,
                scrollSpeed: this.scrollSpeed,
                voiRange: { ...this.voiRange },
            };
        };
        this.getMiddleSliceData = () => {
            throw new Error('Method not implemented.');
        };
        this.useCustomRenderingPipeline = true;
        this.resetCamera = () => {
            this.refreshRenderValues();
            this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
            if (!this.isPlaying) {
                this.renderFrame();
            }
            return true;
        };
        this.getNumberOfSlices = () => {
            const computedSlices = Math.round((this.videoElement.duration * this.fps) / this.scrollSpeed);
            return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;
        };
        this.getFrameOfReferenceUID = () => {
            return this.videoElement.src;
        };
        this.resize = () => {
            const canvas = this.canvas;
            const { clientWidth, clientHeight } = canvas;
            if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
                canvas.width = clientWidth;
                canvas.height = clientHeight;
            }
            this.refreshRenderValues();
            if (!this.isPlaying) {
                this.renderFrame();
            }
        };
        this.canvasToWorld = (canvasPos, destPos = [0, 0, 0]) => {
            const pan = this.videoCamera.panWorld;
            const worldToCanvasRatio = this.getWorldToCanvasRatio();
            const panOffsetCanvas = [
                pan[0] * worldToCanvasRatio,
                pan[1] * worldToCanvasRatio,
            ];
            const subCanvasPos = [
                canvasPos[0] - panOffsetCanvas[0],
                canvasPos[1] - panOffsetCanvas[1],
            ];
            destPos.splice(0, 2, subCanvasPos[0] / worldToCanvasRatio, subCanvasPos[1] / worldToCanvasRatio);
            return destPos;
        };
        this.worldToCanvas = (worldPos) => {
            const pan = this.videoCamera.panWorld;
            const worldToCanvasRatio = this.getWorldToCanvasRatio();
            const canvasPos = [
                (worldPos[0] + pan[0]) * worldToCanvasRatio,
                (worldPos[1] + pan[1]) * worldToCanvasRatio,
            ];
            return canvasPos;
        };
        this.getRotation = () => 0;
        this.canvasToIndex = (canvasPos) => {
            const transform = this.getTransform();
            transform.invert();
            return transform.transformPoint(canvasPos.map((it) => it * devicePixelRatio));
        };
        this.indexToCanvas = (indexPos) => {
            const transform = this.getTransform();
            return transform
                .transformPoint(indexPos)
                .map((it) => it / devicePixelRatio);
        };
        this.customRenderViewportToCanvas = () => {
            this.renderFrame();
        };
        this.renderFrame = () => {
            const dpr = window.devicePixelRatio || 1;
            const transform = this.getTransform();
            const transformationMatrix = transform.getMatrix();
            const ctx = this.canvasContext;
            ctx.resetTransform();
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            ctx.transform(transformationMatrix[0] / dpr, transformationMatrix[1] / dpr, transformationMatrix[2] / dpr, transformationMatrix[3] / dpr, transformationMatrix[4] / dpr, transformationMatrix[5] / dpr);
            ctx.drawImage(this.videoElement, 0, 0, this.videoWidth, this.videoHeight);
            for (const actor of this.getActors()) {
                actor.actor.render(this, this.canvasContext);
            }
            this.canvasContext.resetTransform();
            (0,triggerEvent/* default */.A)(this.element, enums.Events.STACK_NEW_IMAGE, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                renderingEngineId: this.renderingEngineId,
                time: this.videoElement.currentTime,
                duration: this.videoElement.duration,
            });
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_RENDERED, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                imageIndex: this.getCurrentImageIdIndex(),
                numberOfSlices: this.numberOfFrames,
                renderingEngineId: this.renderingEngineId,
                time: this.videoElement.currentTime,
                duration: this.videoElement.duration,
            });
            this.initialRender?.();
            const frame = this.getFrameNumber();
            if (this.isPlaying) {
                if (frame < this.frameRange[0]) {
                    this.setFrameNumber(this.frameRange[0]);
                }
                else if (frame > this.frameRange[1]) {
                    if (this.loop) {
                        this.setFrameNumber(this.frameRange[0]);
                    }
                    else {
                        this.pause();
                    }
                }
            }
        };
        this.renderWhilstPlaying = () => {
            this.renderFrame();
            if (this.isPlaying) {
                requestAnimationFrame(this.renderWhilstPlaying);
            }
        };
        this.canvasContext = this.canvas.getContext('2d');
        this.renderingEngineId = props.renderingEngineId;
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.videoElement = document.createElement('video');
        this.videoElement.muted = this.mute;
        this.videoElement.loop = this.loop;
        this.videoElement.autoplay = true;
        this.videoElement.crossOrigin = 'anonymous';
        this.addEventListeners();
        this.resize();
    }
    static get useCustomRenderingPipeline() {
        return true;
    }
    addEventListeners() {
        this.canvas.addEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
        this.canvas.removeEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
        this.removeEventListeners();
        this.videoElement.remove();
    }
    getImageDataMetadata(image) {
        const imageId = typeof image === 'string' ? image : image.imageId;
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, imageId);
        let rowCosines = imagePlaneModule.rowCosines;
        let columnCosines = imagePlaneModule.columnCosines;
        const usingDefaultValues = imagePlaneModule.usingDefaultValues;
        if (usingDefaultValues || rowCosines == null || columnCosines == null) {
            rowCosines = [1, 0, 0];
            columnCosines = [0, 1, 0];
        }
        const rowCosineVec = esm/* vec3.fromValues */.eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
        const colCosineVec = esm/* vec3.fromValues */.eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
        const { rows, columns } = imagePlaneModule;
        const scanAxisNormal = esm/* vec3.create */.eR.create();
        esm/* vec3.cross */.eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
        let origin = imagePlaneModule.imagePositionPatient;
        if (origin == null) {
            origin = [0, 0, 0];
        }
        const xSpacing = imagePlaneModule.columnPixelSpacing || 1;
        const ySpacing = imagePlaneModule.rowPixelSpacing || 1;
        const xVoxels = imagePlaneModule.columns;
        const yVoxels = imagePlaneModule.rows;
        const zSpacing = 1;
        const zVoxels = 1;
        this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;
        return {
            bitsAllocated: 8,
            numberOfComponents: 3,
            origin,
            rows,
            columns,
            direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
            dimensions: [xVoxels, yVoxels, zVoxels],
            spacing: [xSpacing, ySpacing, zSpacing],
            hasPixelSpacing: this.hasPixelSpacing,
            numVoxels: xVoxels * yVoxels * zVoxels,
            imagePlaneModule,
        };
    }
    setDataIds(imageIds, options) {
        this.setVideo(imageIds[0], (options.viewReference?.sliceIndex || 0) + 1);
    }
    setVideo(imageId, frameNumber) {
        this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;
        const imageUrlModule = metaData.get(enums.MetadataModules.IMAGE_URL, imageId);
        if (!imageUrlModule?.rendered) {
            throw new Error(`Video Image ID ${imageId} does not have a rendered video view`);
        }
        const { rendered } = imageUrlModule;
        const generalSeries = metaData.get(enums.MetadataModules.GENERAL_SERIES, imageId);
        this.modality = generalSeries?.Modality;
        this.metadata = this.getImageDataMetadata(imageId);
        let { cineRate, numberOfFrames } = metaData.get(enums.MetadataModules.CINE, imageId);
        this.numberOfFrames = numberOfFrames;
        return this.setVideoURL(rendered).then(() => {
            if (!numberOfFrames || numberOfFrames === 1) {
                numberOfFrames = Math.round(this.videoElement.duration * (cineRate || 30));
            }
            if (!cineRate) {
                cineRate = Math.round(numberOfFrames / this.videoElement.duration);
            }
            this.fps = cineRate;
            this.numberOfFrames = numberOfFrames;
            this.setFrameRange([1, numberOfFrames]);
            this.initialRender = () => {
                this.initialRender = null;
                this.pause();
                this.setFrameNumber(frameNumber || 1);
            };
            return new Promise((resolve) => {
                window.setTimeout(() => {
                    this.setFrameNumber(frameNumber || 1);
                    resolve(this);
                }, 25);
            });
        });
    }
    async setVideoURL(videoURL) {
        return new Promise((resolve) => {
            this.videoElement.src = videoURL;
            this.videoElement.preload = 'auto';
            const loadedMetadataEventHandler = () => {
                this.videoWidth = this.videoElement.videoWidth;
                this.videoHeight = this.videoElement.videoHeight;
                this.videoElement.removeEventListener('loadedmetadata', loadedMetadataEventHandler);
                this.refreshRenderValues();
                resolve(true);
            };
            this.videoElement.addEventListener('loadedmetadata', loadedMetadataEventHandler);
        });
    }
    getImageIds() {
        const imageIds = new Array(this.numberOfFrames);
        const baseImageId = this.imageId.replace(/[0-9]+$/, '');
        for (let i = 0; i < this.numberOfFrames; i++) {
            imageIds[i] = `${baseImageId}${i + 1}`;
        }
        return imageIds;
    }
    togglePlayPause() {
        if (this.isPlaying) {
            this.pause();
            return false;
        }
        else {
            this.play();
            return true;
        }
    }
    async play() {
        try {
            if (!this.isPlaying) {
                this.isPlaying = true;
                await this.videoElement.play();
                this.renderWhilstPlaying();
            }
        }
        catch (e) {
        }
    }
    pause() {
        try {
            this.isPlaying = false;
            this.videoElement.pause();
        }
        catch (e) {
        }
    }
    async scroll(delta = 1) {
        await this.pause();
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        const currentTime = videoElement.currentTime;
        const newTime = currentTime + (delta * this.scrollSpeed) / this.fps;
        videoElement.currentTime = newTime;
        const seekEventListener = (evt) => {
            renderFrame();
            videoElement.removeEventListener('seeked', seekEventListener);
        };
        videoElement.addEventListener('seeked', seekEventListener);
    }
    async start() {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = 0;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    async end() {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = videoElement.duration;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    async setTime(timeInSeconds) {
        const videoElement = this.videoElement;
        const renderFrame = this.renderFrame;
        videoElement.currentTime = timeInSeconds;
        if (videoElement.paused) {
            const seekEventListener = (evt) => {
                renderFrame();
                videoElement.removeEventListener('seeked', seekEventListener);
            };
            videoElement.addEventListener('seeked', seekEventListener);
        }
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    async setFrameNumber(frame) {
        this.setTime((frame - 1) / this.fps);
    }
    setFrameRange(frameRange) {
        if (!frameRange) {
            this.frameRange = [1, this.numberOfFrames];
            return;
        }
        if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {
            return;
        }
        this.frameRange = [frameRange[0], frameRange[1]];
    }
    getSliceIndexForImage(reference) {
        if (!reference) {
            return;
        }
        if (typeof reference === 'string') {
            return FrameRange/* default */.A.imageIdToFrameStart(reference);
        }
        if (reference.referencedImageId) {
            return FrameRange/* default */.A.imageIdToFrameStart(reference.referencedImageId);
        }
        return;
    }
    getFrameRange() {
        return this.frameRange;
    }
    setProperties(props) {
        if (props.loop !== undefined) {
            this.videoElement.loop = props.loop;
        }
        if (props.muted !== undefined) {
            this.videoElement.muted = props.muted;
        }
        if (props.playbackRate !== undefined) {
            this.setPlaybackRate(props.playbackRate);
        }
        if (props.scrollSpeed !== undefined) {
            this.setScrollSpeed(props.scrollSpeed);
        }
        if (props.voiRange) {
            this.setVOI(props.voiRange);
        }
    }
    setPlaybackRate(rate = 1) {
        this.playbackRate = rate;
        if (rate < 0.0625) {
            this.pause();
            return;
        }
        if (!this.videoElement) {
            return;
        }
        this.videoElement.playbackRate = rate;
        this.play();
    }
    setScrollSpeed(scrollSpeed = 1, unit = enums.VideoEnums.SpeedUnit.FRAME) {
        this.scrollSpeed =
            unit === enums.VideoEnums.SpeedUnit.SECOND
                ? scrollSpeed * this.fps
                : scrollSpeed;
    }
    resetProperties() {
        this.setProperties({
            loop: false,
            muted: true,
        });
    }
    getScalarData() {
        if (this.scalarData?.frameNumber === this.getFrameNumber()) {
            return this.scalarData;
        }
        if (!this.videoElement ||
            !this.videoElement.videoWidth ||
            !this.videoElement.videoHeight) {
            console.debug('Video not ready yet, returning empty scalar data');
            const emptyData = new Uint8ClampedArray();
            emptyData.getRange = () => [0, 255];
            emptyData.frameNumber = -1;
            return emptyData;
        }
        const canvas = document.createElement('canvas');
        canvas.width = this.videoElement.videoWidth;
        canvas.height = this.videoElement.videoHeight;
        const context = canvas.getContext('2d');
        context.drawImage(this.videoElement, 0, 0);
        const canvasData = context.getImageData(0, 0, canvas.width, canvas.height);
        const scalarData = canvasData.data;
        scalarData.getRange = () => [0, 255];
        scalarData.frameNumber = this.getFrameNumber();
        this.scalarData = scalarData;
        return scalarData;
    }
    getImageData() {
        const { metadata } = this;
        const spacing = metadata.spacing;
        const imageData = {
            getDirection: () => metadata.direction,
            getDimensions: () => metadata.dimensions,
            getRange: () => [0, 255],
            getScalarData: () => this.getScalarData(),
            getSpacing: () => metadata.spacing,
            worldToIndex: (point) => {
                const canvasPoint = this.worldToCanvas(point);
                const pixelCoord = this.canvasToIndex(canvasPoint);
                return [pixelCoord[0], pixelCoord[1], 0];
            },
            indexToWorld: (point, destPoint) => {
                const canvasPoint = this.indexToCanvas([point[0], point[1]]);
                return this.canvasToWorld(canvasPoint, destPoint);
            },
        };
        const imageDataForReturn = {
            dimensions: metadata.dimensions,
            spacing,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: metadata.FrameOfReferenceUID,
            },
            getScalarData: () => this.getScalarData(),
            scalarData: this.getScalarData(),
            imageData,
            voxelManager: {
                forEach: (callback, options) => {
                    return (0,pointInShapeCallback/* pointInShapeCallback */.ii)(options.imageData, {
                        pointInShapeFn: options.isInObject ?? (() => true),
                        callback: callback,
                        boundsIJK: options.boundsIJK,
                        returnPoints: options.returnPoints ?? false,
                    });
                },
            },
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: this.calibration,
            preScale: {
                scaled: false,
            },
        };
        Object.defineProperty(imageData, 'scalarData', {
            get: () => this.getScalarData(),
            enumerable: true,
        });
        return imageDataForReturn;
    }
    hasImageURI(imageURI) {
        const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);
        const testURI = framesMatch
            ? imageURI.substring(0, framesMatch.index)
            : imageURI;
        return this.imageId.includes(testURI);
    }
    setVOI(voiRange) {
        this.voiRange = voiRange;
        this.setColorTransform();
    }
    setWindowLevel(windowWidth = 256, windowCenter = 128) {
        const lower = windowCenter - windowWidth / 2;
        const upper = windowCenter + windowWidth / 2 - 1;
        this.setVOI({ lower, upper });
        this.setColorTransform();
    }
    setAverageWhite(averageWhite) {
        this.averageWhite = averageWhite;
        this.setColorTransform();
    }
    setColorTransform() {
        if (!this.voiRange && !this.averageWhite) {
            this.feFilter = null;
            return;
        }
        const white = this.averageWhite || [255, 255, 255];
        const maxWhite = Math.max(...white);
        const scaleWhite = white.map((c) => maxWhite / c);
        const { lower = 0, upper = 255 } = this.voiRange || {};
        const wlScale = (upper - lower + 1) / 255;
        const wlDelta = lower / 255;
        this.feFilter = `url('data:image/svg+xml,\
      <svg xmlns="http://www.w3.org/2000/svg">\
        <filter id="colour" color-interpolation-filters="linearRGB">\
        <feColorMatrix type="matrix" \
        values="\
          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta} \
          0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta} \
          0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta} \
          0 0 0 1 0" />\
        </filter>\
      </svg>#colour')`;
        this.canvas.style.filter = this.feFilter;
    }
    setCamera(camera) {
        const { parallelScale, focalPoint } = camera;
        if (parallelScale) {
            this.videoCamera.parallelScale =
                this.element.clientHeight / 2 / parallelScale;
        }
        if (focalPoint !== undefined) {
            const focalPointCanvas = this.worldToCanvas(focalPoint);
            const canvasCenter = [
                this.element.clientWidth / 2,
                this.element.clientHeight / 2,
            ];
            const panWorldDelta = [
                (focalPointCanvas[0] - canvasCenter[0]) /
                    this.videoCamera.parallelScale,
                (focalPointCanvas[1] - canvasCenter[1]) /
                    this.videoCamera.parallelScale,
            ];
            this.videoCamera.panWorld = [
                this.videoCamera.panWorld[0] - panWorldDelta[0],
                this.videoCamera.panWorld[1] - panWorldDelta[1],
            ];
        }
        this.canvasContext.fillStyle = 'rgba(0,0,0,1)';
        this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (!this.isPlaying) {
            this.renderFrame();
        }
    }
    getCurrentImageId(index = this.getCurrentImageIdIndex()) {
        const current = this.imageId.replace('/frames/1', `/frames/${index + 1}`);
        return current;
    }
    getViewReferenceId(specifier = {}) {
        const { sliceIndex: sliceIndex } = specifier;
        if (sliceIndex === undefined) {
            return `videoId:${this.getCurrentImageId()}`;
        }
        if (Array.isArray(sliceIndex)) {
            return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${sliceIndex[0] + 1}-${sliceIndex[1] + 1}`;
        }
        const baseTarget = this.imageId.replace('/frames/1', `/frames/${1 + sliceIndex}`);
        return `videoId:${baseTarget}`;
    }
    isReferenceViewable(viewRef, options = {}) {
        let { imageURI } = options;
        const { referencedImageId, sliceIndex, multiSliceReference } = viewRef;
        if (!super.isReferenceViewable(viewRef)) {
            return false;
        }
        const imageId = this.getCurrentImageId();
        if (!imageURI) {
            const colonIndex = imageId.indexOf(':');
            imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);
        }
        if (options.withNavigation) {
            return true;
        }
        const currentIndex = this.getSliceIndex();
        if (multiSliceReference) {
            const rangeEndSliceIndex = FrameRange/* default */.A.imageIdToFrameEnd(multiSliceReference.referencedImageId);
            return currentIndex >= sliceIndex && currentIndex <= rangeEndSliceIndex;
        }
        if (sliceIndex !== undefined) {
            return currentIndex === sliceIndex;
        }
        if (!referencedImageId) {
            return false;
        }
        const match = referencedImageId.match(VideoViewport.frameRangeExtractor);
        if (!match) {
            return true;
        }
        if (!match[2]) {
            return true;
        }
        const range = match[2].split('-').map((it) => Number(it));
        const frame = currentIndex + 1;
        return range[0] <= frame && frame <= (range[1] ?? range[0]);
    }
    setViewReference(viewRef) {
        if (typeof viewRef.sliceIndex === 'number') {
            this.setFrameNumber(viewRef.sliceIndex + 1);
        }
        else if (Array.isArray(viewRef.sliceIndex)) {
            this.setFrameRange(viewRef.sliceIndex);
        }
    }
    getViewReference(viewRefSpecifier) {
        const sliceIndex = viewRefSpecifier?.sliceIndex ??
            (this.isPlaying ? this.frameRange[0] : this.getCurrentImageIdIndex());
        const rangeEndSliceIndex = viewRefSpecifier?.rangeEndSliceIndex ??
            (this.isPlaying ? this.frameRange[1] - 1 : undefined);
        const multiSliceReference = rangeEndSliceIndex > sliceIndex
            ? {
                sliceIndex: rangeEndSliceIndex,
                referencedImageId: this.getCurrentImageId(rangeEndSliceIndex),
            }
            : undefined;
        return {
            ...super.getViewReference(viewRefSpecifier),
            referencedImageId: this.getViewReferenceId(viewRefSpecifier),
            sliceIndex,
            multiSliceReference,
        };
    }
    getFrameNumber() {
        return 1 + this.getCurrentImageIdIndex();
    }
    getCurrentImageIdIndex() {
        return Math.round(this.videoElement.currentTime * this.fps);
    }
    getSliceIndex() {
        return this.getCurrentImageIdIndex() / this.scrollSpeed;
    }
    getCamera() {
        const { parallelScale } = this.videoCamera;
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const canvasCenterWorld = this.canvasToWorld(canvasCenter);
        return {
            parallelProjection: true,
            focalPoint: canvasCenterWorld,
            position: [0, 0, 0],
            viewUp: [0, -1, 0],
            parallelScale: this.element.clientHeight / 2 / parallelScale,
            viewPlaneNormal: [0, 0, 1],
        };
    }
    getFrameRate() {
        return this.fps;
    }
    getPan() {
        const panWorld = this.videoCamera.panWorld;
        return [panWorld[0], panWorld[1]];
    }
    refreshRenderValues() {
        let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;
        if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {
            worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;
        }
        const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);
        const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);
        const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;
        const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;
        const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;
        const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;
        this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];
        this.videoCamera.parallelScale = worldToCanvasRatio;
    }
    getWorldToCanvasRatio() {
        return this.videoCamera.parallelScale;
    }
    getCanvasToWorldRatio() {
        return 1.0 / this.videoCamera.parallelScale;
    }
    getTransform() {
        const panWorld = this.videoCamera.panWorld;
        const devicePixelRatio = window.devicePixelRatio || 1;
        const worldToCanvasRatio = this.getWorldToCanvasRatio();
        const canvasToWorldRatio = this.getCanvasToWorldRatio();
        const halfCanvas = [
            this.canvas.offsetWidth / 2,
            this.canvas.offsetHeight / 2,
        ];
        const halfCanvasWorldCoordinates = [
            halfCanvas[0] * canvasToWorldRatio,
            halfCanvas[1] * canvasToWorldRatio,
        ];
        const transform = new rendering_transform/* Transform */.d();
        transform.scale(devicePixelRatio, devicePixelRatio);
        transform.translate(halfCanvas[0], halfCanvas[1]);
        transform.scale(worldToCanvasRatio, worldToCanvasRatio);
        transform.translate(panWorld[0], panWorld[1]);
        transform.translate(-halfCanvasWorldCoordinates[0], -halfCanvasWorldCoordinates[1]);
        return transform;
    }
    updateCameraClippingPlanesAndRange() {
    }
    addImages(stackInputs) {
        const actors = this.getActors();
        stackInputs.forEach((stackInput) => {
            const { imageId, ...rest } = stackInput;
            const image = cache/* default */.Ay.getImage(imageId);
            const imageActor = this.createActorMapper(image);
            const uid = stackInput.actorUID ?? (0,uuidv4/* default */.A)();
            if (imageActor) {
                actors.push({ uid, actor: imageActor, referencedId: imageId, ...rest });
                if (stackInput.callback) {
                    stackInput.callback({
                        imageActor: imageActor,
                        imageId,
                    });
                }
            }
        });
        this.setActors(actors);
    }
    createActorMapper(image) {
        return new CanvasActor(this, image);
    }
}
/* harmony default export */ const RenderingEngine_VideoViewport = (VideoViewport);


/***/ }),

/***/ 10056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89265);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84607);
/* harmony import */ var _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75127);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32643);
/* harmony import */ var _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1814);
/* harmony import */ var _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41864);
/* harmony import */ var _renderingEngineCache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5862);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98039);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69372);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52268);
/* harmony import */ var _utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(74638);
/* harmony import */ var _utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(38883);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(71851);
/* harmony import */ var _utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(99949);
















class Viewport {
    static { this.CameraViewPresentation = {
        rotation: true,
        pan: true,
        zoom: true,
        displayArea: true,
    }; }
    static { this.TransferViewPresentation = {
        windowLevel: true,
        paletteLut: true,
    }; }
    constructor(props) {
        this.insetImageMultiplier = 1.1;
        this.flipHorizontal = false;
        this.flipVertical = false;
        this.viewportStatus = _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.NO_DATA;
        this._suppressCameraModifiedEvents = false;
        this.hasPixelSpacing = true;
        this.getProperties = () => ({});
        this.setRotation = (_rotation) => {
        };
        this.viewportWidgets = new Map();
        this.addWidget = (widgetId, widget) => {
            this.viewportWidgets.set(widgetId, widget);
        };
        this.getWidget = (id) => {
            return this.viewportWidgets.get(id);
        };
        this.getWidgets = () => {
            return Array.from(this.viewportWidgets.values());
        };
        this.removeWidgets = () => {
            const widgets = this.getWidgets();
            widgets.forEach((widget) => {
                if (widget.getEnabled()) {
                    widget.setEnabled(false);
                }
                if (widget.getActor && widget.getRenderer) {
                    const actor = widget.getActor();
                    const renderer = widget.getRenderer();
                    if (renderer && actor) {
                        renderer.removeActor(actor);
                    }
                }
            });
        };
        this.id = props.id;
        this.renderingEngineId = props.renderingEngineId;
        this.type = props.type;
        this.element = props.element;
        this.canvas = props.canvas;
        this.sx = props.sx;
        this.sy = props.sy;
        this.sWidth = props.sWidth;
        this.sHeight = props.sHeight;
        this._actors = new Map();
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.defaultOptions = (0,_utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__/* .deepClone */ .G)(props.defaultOptions);
        this.suppressEvents = props.defaultOptions.suppressEvents
            ? props.defaultOptions.suppressEvents
            : false;
        this.options = (0,_utilities_deepClone__WEBPACK_IMPORTED_MODULE_15__/* .deepClone */ .G)(props.defaultOptions);
        this.isDisabled = false;
    }
    static get useCustomRenderingPipeline() {
        return false;
    }
    setRendered() {
        if (this.viewportStatus === _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.NO_DATA ||
            this.viewportStatus === _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.LOADING) {
            return;
        }
        this.viewportStatus = _enums_ViewportStatus__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.RENDERED;
    }
    getRenderingEngine() {
        return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A.get(this.renderingEngineId);
    }
    getRenderer() {
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            throw new Error('Rendering engine has been destroyed');
        }
        return renderingEngine.offscreenMultiRenderWindow?.getRenderer(this.id);
    }
    render() {
        const renderingEngine = this.getRenderingEngine();
        renderingEngine.renderViewport(this.id);
    }
    setOptions(options, immediate = false) {
        this.options = structuredClone(options);
        if (this.options?.displayArea) {
            this.setDisplayArea(this.options?.displayArea);
        }
        if (immediate) {
            this.render();
        }
    }
    reset(immediate = false) {
        this.options = structuredClone(this.defaultOptions);
        if (immediate) {
            this.render();
        }
    }
    getSliceViewInfo() {
        throw new Error('Method not implemented.');
    }
    flip({ flipHorizontal, flipVertical }) {
        const imageData = this.getDefaultImageData();
        if (!imageData) {
            return;
        }
        const camera = this.getCamera();
        const { viewPlaneNormal, viewUp, focalPoint, position } = camera;
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewPlaneNormal, viewUp);
        let viewUpToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.copy */ .eR.copy(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp);
        const viewPlaneNormalToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewPlaneNormal);
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.distance */ .eR.distance(position, focalPoint);
        const dimensions = imageData.getDimensions();
        const middleIJK = dimensions.map((d) => Math.floor(d / 2));
        const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
        const centeredFocalPoint = imageData.indexToWorld(idx, gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create());
        const resetFocalPoint = this._getFocalPointForResetCamera(centeredFocalPoint, camera, { resetPan: true, resetToCenter: false });
        const panDir = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, resetFocalPoint);
        const panValue = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.length */ .eR.length(panDir);
        const getPanDir = (mirrorVec) => {
            const panDirMirror = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scale */ .eR.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), mirrorVec, 2 * gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(panDir, mirrorVec));
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(panDirMirror, panDirMirror, panDir);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.normalize */ .eR.normalize(panDirMirror, panDirMirror);
            return panDirMirror;
        };
        if (flipHorizontal) {
            const panDirMirror = getPanDir(viewUpToSet);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), resetFocalPoint, panDirMirror, panValue);
            const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), newFocalPoint, viewPlaneNormalToSet, distance);
            this.setCamera({
                viewPlaneNormal: viewPlaneNormalToSet,
                position: newPosition,
                focalPoint: newFocalPoint,
            });
            this.flipHorizontal = !this.flipHorizontal;
        }
        if (flipVertical) {
            viewUpToSet = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(viewUpToSet, viewUp);
            const panDirMirror = getPanDir(viewRight);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), resetFocalPoint, panDirMirror, panValue);
            const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), newFocalPoint, viewPlaneNormalToSet, distance);
            this.setCamera({
                focalPoint: newFocalPoint,
                viewPlaneNormal: viewPlaneNormalToSet,
                viewUp: viewUpToSet,
                position: newPosition,
            });
            this.flipVertical = !this.flipVertical;
        }
        this.render();
    }
    getDefaultImageData() {
        const actorEntry = this.getDefaultActor();
        if (actorEntry && (0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .isImageActor */ .e)(actorEntry)) {
            return actorEntry.actor.getMapper().getInputData();
        }
    }
    getDefaultActor() {
        return this.getActors()[0];
    }
    getActors() {
        return Array.from(this._actors.values());
    }
    getActorUIDs() {
        return Array.from(this._actors.keys());
    }
    getActor(actorUID) {
        return this._actors.get(actorUID);
    }
    getImageActor(volumeId) {
        const actorEntries = this.getActors();
        let actorEntry = actorEntries[0];
        if (volumeId) {
            actorEntry = actorEntries.find((a) => a.referencedId === volumeId);
        }
        if (!actorEntry || !(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .isImageActor */ .e)(actorEntry)) {
            return null;
        }
        const actor = actorEntry.actor;
        return actor;
    }
    getActorUIDByIndex(index) {
        const actor = this.getActors()[index];
        if (actor) {
            return actor.uid;
        }
    }
    getActorByIndex(index) {
        return this.getActors()[index];
    }
    setActors(actors) {
        const currentActors = this.getActors();
        this.removeAllActors();
        this.addActors(actors, { resetCamera: true });
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ACTORS_CHANGED, {
            viewportId: this.id,
            removedActors: currentActors,
            addedActors: actors,
            currentActors: actors,
        });
    }
    _removeActor(actorUID) {
        const actorEntry = this.getActor(actorUID);
        if (!actorEntry) {
            console.warn(`Actor ${actorUID} does not exist in ${this.id}, can't remove`);
            return;
        }
        const renderer = this.getRenderer();
        renderer.removeActor(actorEntry.actor);
        this._actors.delete(actorUID);
        return actorEntry;
    }
    removeActors(actorUIDs) {
        const removedActors = [];
        actorUIDs.forEach((actorUID) => {
            const removedActor = this._removeActor(actorUID);
            if (removedActor) {
                removedActors.push(removedActor);
            }
        });
        const currentActors = this.getActors();
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ACTORS_CHANGED, {
            viewportId: this.id,
            removedActors,
            addedActors: [],
            currentActors,
        });
    }
    addActors(actors, options = {}) {
        const { resetCamera = false } = options;
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            console.warn('Viewport::addActors::Rendering engine has not been initialized or has been destroyed');
            return;
        }
        actors.forEach((actor) => {
            this.addActor(actor);
        });
        const prevViewPresentation = this.getViewPresentation();
        const prevViewRef = this.getViewReference();
        this.resetCamera();
        if (!resetCamera) {
            this.setViewReference(prevViewRef);
            this.setViewPresentation(prevViewPresentation);
        }
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ACTORS_CHANGED, {
            viewportId: this.id,
            removedActors: [],
            addedActors: actors,
            currentActors: this.getActors(),
        });
    }
    addActor(actorEntry) {
        const { uid: actorUID, actor } = actorEntry;
        const renderingEngine = this.getRenderingEngine();
        if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
            console.warn(`Cannot add actor UID of ${actorUID} Rendering Engine has been destroyed`);
            return;
        }
        if (!actorUID || !actor) {
            throw new Error('Actors should have uid and vtk Actor properties');
        }
        if (this.getActor(actorUID)) {
            console.warn(`Actor ${actorUID} already exists for this viewport`);
            return;
        }
        const renderer = this.getRenderer();
        renderer?.addActor(actor);
        this._actors.set(actorUID, Object.assign({}, actorEntry));
        this.updateCameraClippingPlanesAndRange();
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ACTORS_CHANGED, {
            viewportId: this.id,
            removedActors: [],
            addedActors: [actorEntry],
            currentActors: this.getActors(),
        });
    }
    removeAllActors() {
        const currentActors = this.getActors();
        this.getRenderer()?.removeAllViewProps();
        this._actors = new Map();
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ACTORS_CHANGED, {
            viewportId: this.id,
            removedActors: currentActors,
            addedActors: [],
            currentActors: [],
        });
        return;
    }
    resetCameraNoEvent() {
        this._suppressCameraModifiedEvents = true;
        this.resetCamera();
        this._suppressCameraModifiedEvents = false;
    }
    setCameraNoEvent(camera) {
        this._suppressCameraModifiedEvents = true;
        this.setCamera(camera);
        this._suppressCameraModifiedEvents = false;
    }
    _getViewImageDataIntersections(imageData, focalPoint, normal) {
        const A = normal[0];
        const B = normal[1];
        const C = normal[2];
        const D = A * focalPoint[0] + B * focalPoint[1] + C * focalPoint[2];
        const bounds = imageData.getBounds();
        const edges = this._getEdges(bounds);
        const intersections = [];
        for (const edge of edges) {
            const [[x0, y0, z0], [x1, y1, z1]] = edge;
            if (A * (x1 - x0) + B * (y1 - y0) + C * (z1 - z0) === 0) {
                continue;
            }
            const intersectionPoint = _utilities_planar__WEBPACK_IMPORTED_MODULE_10__.linePlaneIntersection([x0, y0, z0], [x1, y1, z1], [A, B, C, D]);
            if (this._isInBounds(intersectionPoint, bounds)) {
                intersections.push(intersectionPoint);
            }
        }
        return intersections;
    }
    setInterpolationType(_interpolationType, _arg) {
    }
    setDisplayArea(displayArea, suppressEvents = false) {
        if (!displayArea) {
            return;
        }
        const { storeAsInitialCamera, type: areaType } = displayArea;
        if (storeAsInitialCamera) {
            this.options.displayArea = displayArea;
        }
        const { _suppressCameraModifiedEvents } = this;
        this._suppressCameraModifiedEvents = true;
        this.setCamera(this.fitToCanvasCamera);
        if (areaType === 'SCALE') {
            this.setDisplayAreaScale(displayArea);
        }
        else {
            this.setInterpolationType(this.getProperties()?.interpolationType ?? _enums__WEBPACK_IMPORTED_MODULE_14__.InterpolationType.LINEAR);
            this.setDisplayAreaFit(displayArea);
        }
        if (storeAsInitialCamera) {
            this.initialCamera = this.getCamera();
        }
        this._suppressCameraModifiedEvents = _suppressCameraModifiedEvents;
        if (!suppressEvents && !_suppressCameraModifiedEvents) {
            const eventDetail = {
                viewportId: this.id,
                displayArea: displayArea,
                storeAsInitialCamera: storeAsInitialCamera,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.DISPLAY_AREA_MODIFIED, eventDetail);
            this.setCamera(this.getCamera());
        }
    }
    setDisplayAreaScale(displayArea) {
        const { scale = 1 } = displayArea;
        const canvas = this.canvas;
        const height = canvas.height;
        const width = canvas.width;
        if (height < 8 || width < 8) {
            return;
        }
        const imageData = this.getDefaultImageData();
        const spacingWorld = imageData.getSpacing();
        const spacing = spacingWorld[1];
        this.setInterpolationType(_enums__WEBPACK_IMPORTED_MODULE_14__.InterpolationType.NEAREST);
        this.setCamera({ parallelScale: (height * spacing) / (2 * scale) });
        delete displayArea.imageArea;
        this.setDisplayAreaFit(displayArea);
        const { focalPoint, position, viewUp, viewPlaneNormal } = this.getCamera();
        const focalChange = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create();
        if (canvas.height % 2) {
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(focalChange, focalChange, viewUp, scale * 0.5 * spacing);
        }
        if (canvas.width % 2) {
            const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp, viewPlaneNormal);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(focalChange, focalChange, viewRight, scale * 0.5 * spacing);
        }
        if (!focalChange[0] && !focalChange[1] && !focalChange[2]) {
            return;
        }
        this.setCamera({
            focalPoint: gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, focalChange),
            position: gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.add */ .eR.add(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), position, focalChange),
        });
    }
    setDisplayAreaFit(displayArea) {
        const { imageArea, imageCanvasPoint } = displayArea;
        const devicePixelRatio = window?.devicePixelRatio || 1;
        const imageData = this.getDefaultImageData();
        if (!imageData) {
            return;
        }
        const canvasWidth = this.sWidth / devicePixelRatio;
        const canvasHeight = this.sHeight / devicePixelRatio;
        const dimensions = imageData.getDimensions();
        const canvasZero = this.worldToCanvas(imageData.indexToWorld([0, 0, 0]));
        const canvasEdge = this.worldToCanvas(imageData.indexToWorld([
            dimensions[0],
            dimensions[1],
            dimensions[2],
        ]));
        const canvasImage = [
            Math.abs(canvasEdge[0] - canvasZero[0]),
            Math.abs(canvasEdge[1] - canvasZero[1]),
        ];
        const [imgWidth, imgHeight] = canvasImage;
        let zoom = this.getZoom() / this.insetImageMultiplier;
        if (imageArea) {
            const [areaX, areaY] = imageArea;
            const currentScale = Math.max(Math.abs(imgWidth / canvasWidth), Math.abs(imgHeight / canvasHeight));
            const requireX = Math.abs((areaX * imgWidth) / canvasWidth);
            const requireY = Math.abs((areaY * imgHeight) / canvasHeight);
            const initZoom = this.getZoom();
            const fitZoom = this.getZoom(this.fitToCanvasCamera);
            const absZoom = requireX > requireY ? currentScale / requireX : currentScale / requireY;
            const applyZoom = (absZoom * initZoom) / fitZoom;
            zoom = applyZoom;
            this.setZoom(this.insetImageMultiplier * zoom, false);
        }
        if (imageCanvasPoint) {
            const { imagePoint, canvasPoint = imagePoint || [0.5, 0.5] } = imageCanvasPoint;
            const [canvasX, canvasY] = canvasPoint;
            const canvasPanX = canvasWidth * (canvasX - 0.5);
            const canvasPanY = canvasHeight * (canvasY - 0.5);
            const [imageX, imageY] = imagePoint || canvasPoint;
            const useZoom = zoom;
            const imagePanX = this.insetImageMultiplier * useZoom * imgWidth * (0.5 - imageX);
            const imagePanY = this.insetImageMultiplier * useZoom * imgHeight * (0.5 - imageY);
            const newPositionX = imagePanX + canvasPanX;
            const newPositionY = imagePanY + canvasPanY;
            const deltaPoint2 = [newPositionX, newPositionY];
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.add */ .Zc.add(deltaPoint2, deltaPoint2, this.getPan());
            this.setPan(deltaPoint2, false);
        }
    }
    getDisplayArea() {
        return this.options?.displayArea;
    }
    resetCamera(options) {
        const { resetPan = true, resetZoom = true, resetToCenter = true, storeAsInitialCamera = true, } = options || {};
        const renderer = this.getRenderer();
        this.setCameraNoEvent({
            flipHorizontal: false,
            flipVertical: false,
        });
        const previousCamera = this.getCamera();
        let bounds;
        const defaultActor = this.getDefaultActor();
        if (defaultActor && (0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .isImageActor */ .e)(defaultActor)) {
            const imageData = defaultActor.actor.getMapper().getInputData();
            bounds = imageData.getBounds();
        }
        else {
            bounds = renderer.computeVisiblePropBounds();
        }
        const focalPoint = [0, 0, 0];
        const imageData = this.getDefaultImageData();
        if (imageData) {
            const spc = imageData.getSpacing();
            bounds[0] = bounds[0] + spc[0] / 2;
            bounds[1] = bounds[1] - spc[0] / 2;
            bounds[2] = bounds[2] + spc[1] / 2;
            bounds[3] = bounds[3] - spc[1] / 2;
            bounds[4] = bounds[4] + spc[2] / 2;
            bounds[5] = bounds[5] - spc[2] / 2;
        }
        const activeCamera = this.getVtkActiveCamera();
        const viewPlaneNormal = activeCamera.getViewPlaneNormal();
        const viewUp = activeCamera.getViewUp();
        focalPoint[0] = (bounds[0] + bounds[1]) / 2.0;
        focalPoint[1] = (bounds[2] + bounds[3]) / 2.0;
        focalPoint[2] = (bounds[4] + bounds[5]) / 2.0;
        if (imageData) {
            const dimensions = imageData.getDimensions();
            const middleIJK = dimensions.map((d) => Math.floor(d / 2));
            const idx = [middleIJK[0], middleIJK[1], middleIJK[2]];
            imageData.indexToWorld(idx, focalPoint);
        }
        const { widthWorld, heightWorld } = this._getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal);
        const canvasSize = [this.sWidth, this.sHeight];
        const boundsAspectRatio = widthWorld / heightWorld;
        const canvasAspectRatio = canvasSize[0] / canvasSize[1];
        const scaleFactor = boundsAspectRatio / canvasAspectRatio;
        const parallelScale = scaleFactor < 1
            ? (this.insetImageMultiplier * heightWorld) / 2
            : (this.insetImageMultiplier * heightWorld * scaleFactor) / 2;
        const radius = Viewport.boundsRadius(bounds) *
            (this.type === _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.VOLUME_3D ? 10 : 1);
        const distance = this.insetImageMultiplier * radius;
        const viewUpToSet = Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(viewUp, viewPlaneNormal)) > 0.999
            ? [-viewUp[2], viewUp[0], viewUp[1]]
            : viewUp;
        const focalPointToSet = this._getFocalPointForResetCamera(focalPoint, previousCamera, { resetPan, resetToCenter });
        const positionToSet = [
            focalPointToSet[0] + distance * viewPlaneNormal[0],
            focalPointToSet[1] + distance * viewPlaneNormal[1],
            focalPointToSet[2] + distance * viewPlaneNormal[2],
        ];
        renderer.resetCameraClippingRange(bounds);
        const clippingRangeToUse = [
            -_constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE,
            _constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE,
        ];
        activeCamera.setPhysicalScale(radius);
        activeCamera.setPhysicalTranslation(-focalPointToSet[0], -focalPointToSet[1], -focalPointToSet[2]);
        this.setCamera({
            parallelScale: resetZoom ? parallelScale : previousCamera.parallelScale,
            focalPoint: focalPointToSet,
            position: positionToSet,
            viewAngle: 90,
            viewUp: viewUpToSet,
            clippingRange: clippingRangeToUse,
        });
        const modifiedCamera = this.getCamera();
        this.setFitToCanvasCamera(this.getCamera());
        if (storeAsInitialCamera) {
            this.setInitialCamera(modifiedCamera);
        }
        if (resetZoom) {
            this.setZoom(1, storeAsInitialCamera);
        }
        const RESET_CAMERA_EVENT = {
            type: 'ResetCameraEvent',
            renderer,
        };
        renderer.invokeEvent(RESET_CAMERA_EVENT);
        this.triggerCameraModifiedEventIfNecessary(previousCamera, modifiedCamera);
        if (imageData &&
            this.options.displayArea &&
            resetZoom &&
            resetPan &&
            resetToCenter) {
            this.setDisplayArea(this.options.displayArea);
        }
        return true;
    }
    setInitialCamera(camera) {
        this.initialCamera = camera;
    }
    setFitToCanvasCamera(camera) {
        this.fitToCanvasCamera = camera;
    }
    getPan(initialCamera = this.initialCamera) {
        if (!initialCamera) {
            return [0, 0];
        }
        const activeCamera = this.getVtkActiveCamera();
        const focalPoint = activeCamera.getFocalPoint();
        const zero3 = this.canvasToWorld([0, 0]);
        const initialCanvasFocal = this.worldToCanvas(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], initialCamera.focalPoint, zero3));
        const currentCanvasFocal = this.worldToCanvas(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract([0, 0, 0], focalPoint, zero3));
        const result = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.subtract */ .Zc.subtract([0, 0], initialCanvasFocal, currentCanvasFocal);
        return result;
    }
    getCurrentImageIdIndex() {
        throw new Error('Not implemented');
    }
    getSliceIndex() {
        throw new Error('Not implemented');
    }
    getImageData() {
        throw new Error('Not implemented');
    }
    getViewReferenceId(_specifier) {
        return null;
    }
    setPan(pan, storeAsInitialCamera = false) {
        const previousCamera = this.getCamera();
        const { focalPoint, position } = previousCamera;
        const zero3 = this.canvasToWorld([0, 0]);
        const delta2 = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.subtract */ .Zc.subtract([0, 0], pan, this.getPan());
        if (Math.abs(delta2[0]) < 1 &&
            Math.abs(delta2[1]) < 1 &&
            !storeAsInitialCamera) {
            return;
        }
        const delta = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), this.canvasToWorld(delta2), zero3);
        const newFocal = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), focalPoint, delta);
        const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), position, delta);
        this.setCamera({
            ...previousCamera,
            focalPoint: newFocal,
            position: newPosition,
        }, storeAsInitialCamera);
    }
    getZoom(compareCamera = this.initialCamera) {
        if (!compareCamera) {
            return 1;
        }
        const activeCamera = this.getVtkActiveCamera();
        const { parallelScale: initialParallelScale } = compareCamera;
        return initialParallelScale / activeCamera.getParallelScale();
    }
    setZoom(value, storeAsInitialCamera = false) {
        const camera = this.getCamera();
        const { parallelScale: initialParallelScale } = this.initialCamera;
        const parallelScale = initialParallelScale / value;
        if (camera.parallelScale === parallelScale && !storeAsInitialCamera) {
            return;
        }
        this.setCamera({
            ...camera,
            parallelScale,
        }, storeAsInitialCamera);
    }
    _getFocalPointForViewPlaneReset(imageData) {
        const { focalPoint, viewPlaneNormal: normal } = this.getCamera();
        const intersections = this._getViewImageDataIntersections(imageData, focalPoint, normal);
        let x = 0;
        let y = 0;
        let z = 0;
        intersections.forEach(([point_x, point_y, point_z]) => {
            x += point_x;
            y += point_y;
            z += point_z;
        });
        const newFocalPoint = [
            x / intersections.length,
            y / intersections.length,
            z / intersections.length,
        ];
        return newFocalPoint;
    }
    getCanvas() {
        return this.canvas;
    }
    getVtkActiveCamera() {
        const renderer = this.getRenderer();
        if (!renderer) {
            console.warn('No renderer found for the viewport');
            return null;
        }
        return renderer.getActiveCamera();
    }
    getCameraNoRotation() {
        const vtkCamera = this.getVtkActiveCamera();
        const sanitizeVector = (vector, defaultValue) => {
            return vector.some((v) => isNaN(v)) ? defaultValue : vector;
        };
        const viewUp = sanitizeVector([...vtkCamera.getViewUp()], [0, 1, 0]);
        const viewPlaneNormal = sanitizeVector([...vtkCamera.getViewPlaneNormal()], [0, 0, -1]);
        const position = sanitizeVector([...vtkCamera.getPosition()], [0, 0, 1]);
        const focalPoint = sanitizeVector([...vtkCamera.getFocalPoint()], [0, 0, 0]);
        return {
            viewUp,
            viewPlaneNormal,
            position,
            focalPoint,
            parallelProjection: vtkCamera.getParallelProjection(),
            parallelScale: vtkCamera.getParallelScale(),
            viewAngle: vtkCamera.getViewAngle(),
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
        };
    }
    getCamera() {
        const camera = this.getCameraNoRotation();
        return {
            ...camera,
            rotation: this.getRotation(),
        };
    }
    setCamera(cameraInterface, storeAsInitialCamera = false) {
        const vtkCamera = this.getVtkActiveCamera();
        const previousCamera = this.getCamera();
        const updatedCamera = Object.assign({}, previousCamera, cameraInterface);
        const { viewUp, viewPlaneNormal, position, focalPoint, parallelScale, viewAngle, flipHorizontal, flipVertical, clippingRange, } = cameraInterface;
        if (flipHorizontal !== undefined) {
            const flipH = (flipHorizontal && !this.flipHorizontal) ||
                (!flipHorizontal && this.flipHorizontal);
            if (flipH) {
                this.flip({ flipHorizontal: flipH });
            }
        }
        if (flipVertical !== undefined) {
            const flipV = (flipVertical && !this.flipVertical) ||
                (!flipVertical && this.flipVertical);
            if (flipV) {
                this.flip({ flipVertical: flipV });
            }
        }
        if (viewUp !== undefined) {
            vtkCamera.setViewUp(viewUp);
        }
        if (viewPlaneNormal !== undefined) {
            vtkCamera.setDirectionOfProjection(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        }
        if (position !== undefined) {
            vtkCamera.setPosition(...position);
        }
        if (focalPoint !== undefined) {
            vtkCamera.setFocalPoint(...focalPoint);
        }
        if (parallelScale !== undefined) {
            vtkCamera.setParallelScale(parallelScale);
        }
        if (viewAngle !== undefined) {
            vtkCamera.setViewAngle(viewAngle);
        }
        if (clippingRange !== undefined) {
            vtkCamera.setClippingRange(clippingRange);
        }
        const prevFocalPoint = previousCamera.focalPoint;
        const prevViewUp = previousCamera.viewUp;
        if ((prevFocalPoint && focalPoint) || (prevViewUp && viewUp)) {
            const currentViewPlaneNormal = vtkCamera.getViewPlaneNormal();
            const currentViewUp = vtkCamera.getViewUp();
            let cameraModifiedOutOfPlane = false;
            let viewUpHasChanged = false;
            if (focalPoint) {
                const deltaCamera = [
                    focalPoint[0] - prevFocalPoint[0],
                    focalPoint[1] - prevFocalPoint[1],
                    focalPoint[2] - prevFocalPoint[2],
                ];
                cameraModifiedOutOfPlane =
                    Math.abs(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Ay.dot(deltaCamera, currentViewPlaneNormal)) > 0;
            }
            if (viewUp) {
                viewUpHasChanged = !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(currentViewUp, prevViewUp);
            }
            if (cameraModifiedOutOfPlane || viewUpHasChanged) {
                const actorEntry = this.getDefaultActor();
                if (!actorEntry?.actor) {
                    return;
                }
                if (!(0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .actorIsA */ .N)(actorEntry, 'vtkActor')) {
                    this.updateClippingPlanesForActors(updatedCamera);
                }
                if ((0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_8__/* .actorIsA */ .N)(actorEntry, 'vtkImageSlice') ||
                    this.type === _enums_ViewportType__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.VOLUME_3D) {
                    const renderer = this.getRenderer();
                    renderer.resetCameraClippingRange();
                }
            }
        }
        if (storeAsInitialCamera) {
            this.setInitialCamera(updatedCamera);
        }
        this.triggerCameraModifiedEventIfNecessary(previousCamera, this.getCamera());
    }
    triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera) {
        if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
            const eventDetail = {
                previousCamera,
                camera: updatedCamera,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.CAMERA_MODIFIED, eventDetail);
        }
    }
    updateCameraClippingPlanesAndRange() {
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.getRenderer().resetCameraClippingRange();
    }
    async updateClippingPlanesForActors(updatedCamera) {
        const actorEntries = this.getActors();
        actorEntries.map((actorEntry) => {
            if (!actorEntry.actor) {
                return;
            }
            const mapper = actorEntry.actor.getMapper();
            let vtkPlanes = actorEntry?.clippingFilter
                ? actorEntry?.clippingFilter.getClippingPlanes()
                : mapper.getClippingPlanes();
            if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
                vtkPlanes = [_kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance(), _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance()];
            }
            let slabThickness = _constants__WEBPACK_IMPORTED_MODULE_13__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            if (actorEntry.slabThickness) {
                slabThickness = actorEntry.slabThickness;
            }
            const { viewPlaneNormal, focalPoint } = updatedCamera;
            this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(this.element, _enums_Events__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.CLIPPING_PLANES_UPDATED, {
                actorEntry,
                focalPoint,
                vtkPlanes,
                viewport: this,
            });
        });
    }
    setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, focalPoint) {
        if (vtkPlanes.length < 2) {
            return;
        }
        const scaledDistance = [
            viewPlaneNormal[0],
            viewPlaneNormal[1],
            viewPlaneNormal[2],
        ];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyScalar */ .Ay.multiplyScalar(scaledDistance, slabThickness);
        vtkPlanes[0].setNormal(viewPlaneNormal);
        const newOrigin1 = [0, 0, 0];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Ay.subtract(focalPoint, scaledDistance, newOrigin1);
        vtkPlanes[0].setOrigin(newOrigin1);
        vtkPlanes[1].setNormal(-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]);
        const newOrigin2 = [0, 0, 0];
        _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__/* ["default"].add */ .Ay.add(focalPoint, scaledDistance, newOrigin2);
        vtkPlanes[1].setOrigin(newOrigin2);
    }
    getClippingPlanesForActor(actorEntry) {
        if (!actorEntry) {
            actorEntry = this.getDefaultActor();
        }
        if (!actorEntry.actor) {
            throw new Error('Invalid actor entry: Actor is undefined');
        }
        const mapper = actorEntry.actor.getMapper();
        let vtkPlanes = actorEntry?.clippingFilter
            ? actorEntry?.clippingFilter.getClippingPlanes()
            : mapper.getClippingPlanes();
        if (vtkPlanes.length === 0 && actorEntry?.clippingFilter) {
            vtkPlanes = [_kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance(), _kitware_vtk_js_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance()];
        }
        return vtkPlanes;
    }
    _getWorldDistanceViewUpAndViewRight(bounds, viewUp, viewPlaneNormal) {
        const viewUpCorners = this._getCorners(bounds);
        const viewRightCorners = this._getCorners(bounds);
        const viewRight = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), viewUp, viewPlaneNormal);
        let transform = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
            .buildFromDegree()
            .identity()
            .rotateFromDirections(viewUp, [1, 0, 0]);
        viewUpCorners.forEach((pt) => transform.apply(pt));
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < 8; i++) {
            const y = viewUpCorners[i][0];
            if (y > maxY) {
                maxY = y;
            }
            if (y < minY) {
                minY = y;
            }
        }
        transform = _kitware_vtk_js_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
            .buildFromDegree()
            .identity()
            .rotateFromDirections([viewRight[0], viewRight[1], viewRight[2]], [1, 0, 0]);
        viewRightCorners.forEach((pt) => transform.apply(pt));
        let minX = Infinity;
        let maxX = -Infinity;
        for (let i = 0; i < 8; i++) {
            const x = viewRightCorners[i][0];
            if (x > maxX) {
                maxX = x;
            }
            if (x < minX) {
                minX = x;
            }
        }
        return { widthWorld: maxX - minX, heightWorld: maxY - minY };
    }
    getViewReference(viewRefSpecifier) {
        const { focalPoint: cameraFocalPoint, viewPlaneNormal, viewUp, } = this.getCamera();
        const target = {
            FrameOfReferenceUID: this.getFrameOfReferenceUID(),
            cameraFocalPoint,
            viewPlaneNormal,
            viewUp,
            sliceIndex: viewRefSpecifier?.sliceIndex ?? this.getSliceIndex(),
        };
        return target;
    }
    isReferenceViewable(viewRef, options) {
        if (viewRef.FrameOfReferenceUID &&
            viewRef.FrameOfReferenceUID !== this.getFrameOfReferenceUID()) {
            return false;
        }
        const { viewPlaneNormal } = viewRef;
        const camera = this.getCamera();
        if (viewPlaneNormal &&
            !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(viewPlaneNormal, camera.viewPlaneNormal) &&
            !(0,_utilities_isEqual__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Ay)(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.negate */ .eR.negate(camera.viewPlaneNormal, camera.viewPlaneNormal), viewPlaneNormal)) {
            return options?.withOrientation;
        }
        return true;
    }
    getViewPresentation(viewPresSel = {
        rotation: true,
        displayArea: true,
        zoom: true,
        pan: true,
        flipHorizontal: true,
        flipVertical: true,
    }) {
        const target = {};
        const { rotation, displayArea, zoom, pan, flipHorizontal, flipVertical } = viewPresSel;
        if (rotation) {
            target.rotation = this.getRotation();
        }
        if (displayArea) {
            target.displayArea = this.getDisplayArea();
        }
        const initZoom = this.getZoom();
        if (zoom) {
            target.zoom = initZoom;
        }
        if (pan) {
            target.pan = this.getPan();
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.scale */ .Zc.scale(target.pan, target.pan, 1 / initZoom);
        }
        if (flipHorizontal) {
            target.flipHorizontal = this.flipHorizontal;
        }
        if (flipVertical) {
            target.flipVertical = this.flipVertical;
        }
        return target;
    }
    setViewReference(viewRef) {
    }
    setViewPresentation(viewPres) {
        if (!viewPres) {
            return;
        }
        const { displayArea, zoom = this.getZoom(), pan, rotation, flipHorizontal = this.flipHorizontal, flipVertical = this.flipVertical, } = viewPres;
        if (displayArea !== this.getDisplayArea()) {
            this.setDisplayArea(displayArea);
        }
        this.setZoom(zoom);
        if (pan) {
            this.setPan(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec2.scale */ .Zc.scale([0, 0], pan, zoom));
        }
        if (rotation >= 0) {
            this.setRotation(rotation);
        }
        if (flipHorizontal !== undefined &&
            flipHorizontal !== this.flipHorizontal) {
            this.flip({ flipHorizontal });
        }
        if (flipVertical !== undefined && flipVertical !== this.flipVertical) {
            this.flip({ flipVertical });
        }
    }
    _getCorners(bounds) {
        return [
            [bounds[0], bounds[2], bounds[4]],
            [bounds[0], bounds[2], bounds[5]],
            [bounds[0], bounds[3], bounds[4]],
            [bounds[0], bounds[3], bounds[5]],
            [bounds[1], bounds[2], bounds[4]],
            [bounds[1], bounds[2], bounds[5]],
            [bounds[1], bounds[3], bounds[4]],
            [bounds[1], bounds[3], bounds[5]],
        ];
    }
    _getFocalPointForResetCamera(centeredFocalPoint, previousCamera, { resetPan = true, resetToCenter = true }) {
        if (resetToCenter && resetPan) {
            return centeredFocalPoint;
        }
        if (resetToCenter && !resetPan) {
            return (0,_utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(previousCamera.focalPoint)
                ? centeredFocalPoint
                : previousCamera.focalPoint;
        }
        if (!resetToCenter && resetPan) {
            const oldCamera = previousCamera;
            const oldFocalPoint = oldCamera.focalPoint;
            const oldViewPlaneNormal = oldCamera.viewPlaneNormal;
            const vectorFromOldFocalPointToCenteredFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.subtract */ .eR.subtract(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), centeredFocalPoint, oldFocalPoint);
            const distanceFromOldFocalPointToCenteredFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.dot */ .eR.dot(vectorFromOldFocalPointToCenteredFocalPoint, oldViewPlaneNormal);
            const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.create */ .eR.create(), centeredFocalPoint, oldViewPlaneNormal, -1 * distanceFromOldFocalPointToCenteredFocalPoint);
            return [newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]];
        }
        if (!resetPan && !resetToCenter) {
            return (0,_utilities_hasNaNValues__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(previousCamera.focalPoint)
                ? centeredFocalPoint
                : previousCamera.focalPoint;
        }
    }
    _isInBounds(point, bounds) {
        const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
        const [x, y, z] = point;
        if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
            return false;
        }
        return true;
    }
    _getEdges(bounds) {
        const [p1, p2, p3, p4, p5, p6, p7, p8] = this._getCorners(bounds);
        return [
            [p1, p2],
            [p1, p5],
            [p1, p3],
            [p2, p4],
            [p2, p6],
            [p3, p4],
            [p3, p7],
            [p4, p8],
            [p5, p7],
            [p5, p6],
            [p6, p8],
            [p7, p8],
        ];
    }
    static boundsRadius(bounds) {
        const w1 = (bounds[1] - bounds[0]) ** 2;
        const w2 = (bounds[3] - bounds[2]) ** 2;
        const w3 = (bounds[5] - bounds[4]) ** 2;
        const radius = Math.sqrt(w1 + w2 + w3 || 1) * 0.5;
        return radius;
    }
    setDataIds(_imageIds, _options) {
        throw new Error('Unsupported operatoin setDataIds');
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);


/***/ }),

/***/ 94155:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_VolumeViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 6 modules
var constants = __webpack_require__(19325);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js
var actorCheck = __webpack_require__(98039);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
var getClosestImageId = __webpack_require__(88619);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js
var getSliceRange = __webpack_require__(20537);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
var getSpacingInNormalDirection = __webpack_require__(85008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js
var snapFocalPointToSlice = __webpack_require__(80500);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
var BaseVolumeViewport = __webpack_require__(46347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setDefaultVolumeVOI.js
var setDefaultVolumeVOI = __webpack_require__(89821);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js
var transferFunctionUtils = __webpack_require__(85745);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js
var getImageSliceDataForVolumeViewport = __webpack_require__(47476);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js
var transformCanvasToIJK = __webpack_require__(51919);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js
var transformIndexToWorld = __webpack_require__(94741);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIJKToCanvas.js

function transformIJKToCanvas(viewport, ijkPoint) {
    const { imageData: vtkImageData } = viewport.getImageData();
    const worldPoint = (0,transformIndexToWorld/* default */.A)(vtkImageData, ijkPoint);
    return viewport.worldToCanvas(worldPoint);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js
var getVolumeViewportScrollInfo = __webpack_require__(61375);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js


















class VolumeViewport extends BaseVolumeViewport/* default */.A {
    constructor(props) {
        super(props);
        this._useAcquisitionPlaneForViewPlane = false;
        this.getNumberOfSlices = () => {
            const { numberOfSlices } = (0,getImageSliceDataForVolumeViewport/* default */.A)(this) || {};
            return numberOfSlices;
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
                resetRotation: false,
                suppressEvents: true,
            });
        };
        this.getCurrentImageIdIndex = (volumeId, useSlabThickness = true) => {
            const { currentStepIndex } = (0,getVolumeViewportScrollInfo/* default */.A)(this, volumeId || this.getVolumeId(), useSlabThickness);
            return currentStepIndex;
        };
        this.getSliceIndex = () => {
            const { imageIndex } = (0,getImageSliceDataForVolumeViewport/* default */.A)(this) || {};
            return imageIndex;
        };
        this.getCurrentImageId = () => {
            const actorEntry = this.getDefaultActor();
            if (!actorEntry || !(0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                return;
            }
            const volume = cache/* default */.Ay.getVolume(this.getVolumeId());
            if (!volume) {
                return;
            }
            const { viewPlaneNormal, focalPoint } = this.getCamera();
            return (0,getClosestImageId/* default */.A)(volume, focalPoint, viewPlaneNormal);
        };
        this.getSlicePlaneCoordinates = () => {
            const actorEntry = this.getDefaultActor();
            if (!actorEntry?.actor) {
                console.warn('No image data found for calculating vtkPlanes.');
                return [];
            }
            const volumeId = this.getVolumeId();
            const imageVolume = cache/* default */.Ay.getVolume(volumeId);
            const camera = this.getCamera();
            const { focalPoint, position, viewPlaneNormal } = camera;
            const spacingInNormalDirection = (0,getSpacingInNormalDirection/* default */.A)(imageVolume, viewPlaneNormal);
            const sliceRange = (0,getSliceRange/* default */.A)(actorEntry.actor, viewPlaneNormal, focalPoint);
            const numSlicesBackward = Math.round((sliceRange.current - sliceRange.min) / spacingInNormalDirection);
            const numSlicesForward = Math.round((sliceRange.max - sliceRange.current) / spacingInNormalDirection);
            const currentSliceIndex = this.getSliceIndex();
            const focalPoints = [];
            for (let i = -numSlicesBackward; i <= numSlicesForward; i++) {
                const { newFocalPoint: point } = (0,snapFocalPointToSlice/* default */.A)(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, i);
                focalPoints.push({ sliceIndex: currentSliceIndex + i, point });
            }
            return focalPoints;
        };
        const { orientation } = this.options;
        if (orientation && orientation !== enums.OrientationAxis.ACQUISITION) {
            this.applyViewOrientation(orientation);
            return;
        }
        this._useAcquisitionPlaneForViewPlane = true;
    }
    async setVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = cache/* default */.Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        if (this._useAcquisitionPlaneForViewPlane) {
            this._setViewPlaneToAcquisitionPlane(firstImageVolume);
            this._useAcquisitionPlaneForViewPlane = false;
        }
        return super.setVolumes(volumeInputArray, immediate, suppressEvents);
    }
    async addVolumes(volumeInputArray, immediate = false, suppressEvents = false) {
        const firstImageVolume = cache/* default */.Ay.getVolume(volumeInputArray[0].volumeId);
        if (!firstImageVolume) {
            throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);
        }
        if (this._useAcquisitionPlaneForViewPlane) {
            this._setViewPlaneToAcquisitionPlane(firstImageVolume);
            this._useAcquisitionPlaneForViewPlane = false;
        }
        return super.addVolumes(volumeInputArray, immediate, suppressEvents);
    }
    jumpToWorld(worldPos) {
        const { focalPoint } = this.getCamera();
        const delta = [0, 0, 0];
        esm/* vec3.sub */.eR.sub(delta, worldPos, focalPoint);
        const camera = this.getCamera();
        const normal = camera.viewPlaneNormal;
        const dotProd = esm/* vec3.dot */.eR.dot(delta, normal);
        const projectedDelta = esm/* vec3.fromValues */.eR.fromValues(normal[0], normal[1], normal[2]);
        esm/* vec3.scale */.eR.scale(projectedDelta, projectedDelta, dotProd);
        if (Math.abs(projectedDelta[0]) > 1e-3 ||
            Math.abs(projectedDelta[1]) > 1e-3 ||
            Math.abs(projectedDelta[2]) > 1e-3) {
            const newFocalPoint = [0, 0, 0];
            const newPosition = [0, 0, 0];
            esm/* vec3.add */.eR.add(newFocalPoint, camera.focalPoint, projectedDelta);
            esm/* vec3.add */.eR.add(newPosition, camera.position, projectedDelta);
            this.setCamera({
                focalPoint: newFocalPoint,
                position: newPosition,
            });
            this.render();
        }
        return true;
    }
    setOrientation(orientation, immediate = true) {
        let viewPlaneNormal, viewUp;
        if (typeof orientation === 'string') {
            if (orientation === enums.OrientationAxis.ACQUISITION) {
                ({ viewPlaneNormal, viewUp } = super._getAcquisitionPlaneOrientation());
            }
            else if (constants.MPR_CAMERA_VALUES[orientation]) {
                ({ viewPlaneNormal, viewUp } = constants.MPR_CAMERA_VALUES[orientation]);
            }
            else {
                throw new Error(`Invalid orientation: ${orientation}. Use Enums.OrientationAxis instead.`);
            }
            this.setCamera({
                viewPlaneNormal,
                viewUp,
            });
            this.viewportProperties.orientation = orientation;
            this.resetCamera();
        }
        else {
            ({ viewPlaneNormal, viewUp } = orientation);
            this.applyViewOrientation(orientation);
        }
        if (immediate) {
            this.render();
        }
    }
    setCameraClippingRange() {
        const activeCamera = this.getVtkActiveCamera();
        if (!activeCamera) {
            console.warn('No active camera found');
            return;
        }
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, constants.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
    }
    _setViewPlaneToAcquisitionPlane(imageVolume) {
        let viewPlaneNormal, viewUp;
        if (imageVolume) {
            const { direction } = imageVolume;
            viewPlaneNormal = direction.slice(6, 9).map((x) => -x);
            viewUp = direction.slice(3, 6).map((x) => -x);
        }
        else {
            ({ viewPlaneNormal, viewUp } = this._getAcquisitionPlaneOrientation());
        }
        this.setCamera({
            viewPlaneNormal,
            viewUp,
        });
        this.initialViewUp = viewUp;
        this.resetCamera();
    }
    getBlendMode(filterActorUIDs) {
        const actorEntries = this.getActors();
        const actorForBlend = filterActorUIDs?.length > 0
            ? actorEntries.find((actorEntry) => filterActorUIDs.includes(actorEntry.uid))
            : actorEntries[0];
        return (actorForBlend?.blendMode ||
            actorForBlend?.actor.getMapper().getBlendMode());
    }
    setBlendMode(blendMode, filterActorUIDs = [], immediate = false) {
        let actorEntries = this.getActors();
        if (filterActorUIDs?.length > 0) {
            actorEntries = actorEntries.filter((actorEntry) => {
                return filterActorUIDs.includes(actorEntry.uid);
            });
        }
        actorEntries.forEach((actorEntry) => {
            const { actor } = actorEntry;
            const mapper = actor.getMapper();
            mapper.setBlendMode?.(blendMode);
            actorEntry.blendMode = blendMode;
        });
        if (immediate) {
            this.render();
        }
    }
    resetCamera(options) {
        const { resetPan = true, resetZoom = true, resetRotation = true, resetToCenter = true, suppressEvents = false, resetOrientation = true, } = options || {};
        const { orientation } = this.viewportProperties;
        if (orientation && resetOrientation) {
            this.applyViewOrientation(orientation, false);
        }
        super.resetCamera({ resetPan, resetZoom, resetToCenter });
        const activeCamera = this.getVtkActiveCamera();
        const viewPlaneNormal = activeCamera.getViewPlaneNormal();
        const focalPoint = activeCamera.getFocalPoint();
        const actorEntries = this.getActors();
        actorEntries.forEach((actorEntry) => {
            if (!actorEntry.actor) {
                return;
            }
            const mapper = actorEntry.actor.getMapper();
            const vtkPlanes = mapper.getClippingPlanes();
            if (vtkPlanes.length === 0 && !actorEntry?.clippingFilter) {
                const clipPlane1 = Plane/* default.newInstance */.Ay.newInstance();
                const clipPlane2 = Plane/* default.newInstance */.Ay.newInstance();
                const newVtkPlanes = [clipPlane1, clipPlane2];
                let slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
                if (actorEntry.slabThickness) {
                    slabThickness = actorEntry.slabThickness;
                }
                this.setOrientationOfClippingPlanes(newVtkPlanes, slabThickness, viewPlaneNormal, focalPoint);
                mapper.addClippingPlane(clipPlane1);
                mapper.addClippingPlane(clipPlane2);
            }
        });
        if (resetRotation &&
            constants.MPR_CAMERA_VALUES[this.viewportProperties.orientation] !== undefined) {
            const viewToReset = constants.MPR_CAMERA_VALUES[this.viewportProperties.orientation];
            this.setCameraNoEvent({
                viewUp: viewToReset.viewUp,
                viewPlaneNormal: viewToReset.viewPlaneNormal,
            });
        }
        if (!suppressEvents) {
            const eventDetail = {
                viewportId: this.id,
                camera: this.getCamera(),
                renderingEngineId: this.renderingEngineId,
                element: this.element,
            };
            (0,triggerEvent/* default */.A)(this.element, enums.Events.CAMERA_RESET, eventDetail);
        }
        return true;
    }
    setSlabThickness(slabThickness, filterActorUIDs = []) {
        if (slabThickness < 0.1) {
            slabThickness = 0.1;
        }
        let actorEntries = this.getActors();
        if (filterActorUIDs?.length > 0) {
            actorEntries = actorEntries.filter((actorEntry) => {
                return filterActorUIDs.includes(actorEntry.uid);
            });
        }
        actorEntries.forEach((actorEntry) => {
            if ((0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                actorEntry.slabThickness = slabThickness;
            }
        });
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
        this.viewportProperties.slabThickness = slabThickness;
    }
    resetSlabThickness() {
        const actorEntries = this.getActors();
        actorEntries.forEach((actorEntry) => {
            if ((0,actorCheck/* actorIsA */.N)(actorEntry, 'vtkVolume')) {
                actorEntry.slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            }
        });
        const currentCamera = this.getCamera();
        this.updateClippingPlanesForActors(currentCamera);
        this.triggerCameraModifiedEventIfNecessary(currentCamera, currentCamera);
        this.viewportProperties.slabThickness = undefined;
    }
    isInAcquisitionPlane() {
        const imageData = this.getImageData();
        if (!imageData) {
            return false;
        }
        const { direction } = imageData;
        const { viewPlaneNormal } = this.getCamera();
        const normalDirection = [direction[6], direction[7], direction[8]];
        const TOLERANCE = 0.99;
        return (Math.abs(esm/* vec3.dot */.eR.dot(viewPlaneNormal, normalDirection)) > TOLERANCE);
    }
    getSliceViewInfo() {
        const { width: canvasWidth, height: canvasHeight } = this.getCanvas();
        const ijkOriginPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [0, 0]);
        const ijkRowPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [canvasWidth - 1, 0]);
        const ijkColPoint = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [0, canvasHeight - 1]);
        const ijkRowVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkRowPoint, ijkOriginPoint);
        const ijkColVec = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkColPoint, ijkOriginPoint);
        const ijkSliceVec = esm/* vec3.cross */.eR.cross(esm/* vec3.create */.eR.create(), ijkRowVec, ijkColVec);
        esm/* vec3.normalize */.eR.normalize(ijkRowVec, ijkRowVec);
        esm/* vec3.normalize */.eR.normalize(ijkColVec, ijkColVec);
        esm/* vec3.normalize */.eR.normalize(ijkSliceVec, ijkSliceVec);
        const { dimensions } = this.getImageData();
        const [sx, sy, sz] = dimensions;
        const ijkCorners = [
            [0, 0, 0],
            [sx - 1, 0, 0],
            [0, sy - 1, 0],
            [sx - 1, sy - 1, 0],
            [0, 0, sz - 1],
            [sx - 1, 0, sz - 1],
            [0, sy - 1, sz - 1],
            [sx - 1, sy - 1, sz - 1],
        ];
        const canvasCorners = ijkCorners.map((ijkCorner) => transformIJKToCanvas(this, ijkCorner));
        const canvasAABB = canvasCorners.reduce((aabb, canvasPoint) => {
            aabb.minX = Math.min(aabb.minX, canvasPoint[0]);
            aabb.minY = Math.min(aabb.minY, canvasPoint[1]);
            aabb.maxX = Math.max(aabb.maxX, canvasPoint[0]);
            aabb.maxY = Math.max(aabb.maxY, canvasPoint[1]);
            return aabb;
        }, { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
        const ijkTopLeft = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [
            canvasAABB.minX,
            canvasAABB.minY,
        ]);
        const sliceToIndexMatrix = esm/* mat4.fromValues */.pB.fromValues(ijkRowVec[0], ijkRowVec[1], ijkRowVec[2], 0, ijkColVec[0], ijkColVec[1], ijkColVec[2], 0, ijkSliceVec[0], ijkSliceVec[1], ijkSliceVec[2], 0, ijkTopLeft[0], ijkTopLeft[1], ijkTopLeft[2], 1);
        const ijkBottomRight = (0,transformCanvasToIJK/* transformCanvasToIJK */.e)(this, [
            canvasAABB.maxX,
            canvasAABB.maxY,
        ]);
        const ijkDiagonal = esm/* vec3.sub */.eR.sub(esm/* vec3.create */.eR.create(), ijkBottomRight, ijkTopLeft);
        const indexToSliceMatrix = esm/* mat4.invert */.pB.invert(esm/* mat4.create */.pB.create(), sliceToIndexMatrix);
        const { viewPlaneNormal } = this.getCamera();
        const isOblique = viewPlaneNormal.filter((component) => Math.abs(component) > constants.EPSILON)
            .length > 1;
        if (isOblique) {
            throw new Error('getSliceInfo is not supported for oblique views');
        }
        const sliceAxis = viewPlaneNormal.findIndex((component) => Math.abs(component) > 1 - constants.EPSILON);
        if (sliceAxis === -1) {
            throw new Error('Unable to determine slice axis');
        }
        const sliceWidth = esm/* vec3.dot */.eR.dot(ijkRowVec, ijkDiagonal) + 1;
        const sliceHeight = esm/* vec3.dot */.eR.dot(ijkColVec, ijkDiagonal) + 1;
        return {
            sliceIndex: this.getSliceIndex(),
            width: sliceWidth,
            height: sliceHeight,
            slicePlane: sliceAxis,
            sliceToIndexMatrix,
            indexToSliceMatrix,
        };
    }
    getCurrentSlicePixelData() {
        const { voxelManager } = this.getImageData();
        const sliceData = voxelManager.getSliceData(this.getSliceViewInfo());
        return sliceData;
    }
    getViewReference(viewRefSpecifier = {}) {
        const viewRef = super.getViewReference(viewRefSpecifier);
        if (!viewRef?.volumeId) {
            return;
        }
        const volume = cache/* default */.Ay.getVolume(viewRef.volumeId);
        viewRef.referencedImageId = (0,getClosestImageId/* default */.A)(volume, viewRef.cameraFocalPoint, viewRef.viewPlaneNormal);
        return viewRef;
    }
    resetProperties(volumeId) {
        this._resetProperties(volumeId);
    }
    _resetProperties(volumeId) {
        const volumeActor = volumeId
            ? this.getActor(volumeId)
            : this.getDefaultActor();
        if (!volumeActor) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        if (volumeActor.slabThickness) {
            volumeActor.slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            this.viewportProperties.slabThickness = undefined;
            this.updateClippingPlanesForActors(this.getCamera());
        }
        volumeId ||= this.getVolumeId();
        const imageVolume = cache/* default */.Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        (0,setDefaultVolumeVOI/* default */.A)(volumeActor.actor, imageVolume);
        if ((0,actorCheck/* isImageActor */.e)(volumeActor)) {
            const transferFunction = volumeActor.actor
                .getProperty()
                .getRGBTransferFunction(0);
            (0,transferFunctionUtils.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
        }
        const eventDetails = {
            ...super.getVOIModifiedEventDetail(volumeId),
        };
        const resetPan = true;
        const resetZoom = true;
        const resetToCenter = true;
        const resetCameraRotation = true;
        this.resetCamera({
            resetPan,
            resetZoom,
            resetToCenter,
            resetCameraRotation,
        });
        (0,triggerEvent/* default */.A)(this.element, enums.Events.VOI_MODIFIED, eventDetails);
    }
    getSlicesClippingPlanes() {
        const focalPoints = this.getSlicePlaneCoordinates();
        const { viewPlaneNormal } = this.getCamera();
        const slabThickness = constants.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
        return focalPoints.map(({ point, sliceIndex }) => {
            const vtkPlanes = [Plane/* default.newInstance */.Ay.newInstance(), Plane/* default.newInstance */.Ay.newInstance()];
            this.setOrientationOfClippingPlanes(vtkPlanes, slabThickness, viewPlaneNormal, point);
            return {
                sliceIndex,
                planes: vtkPlanes.map((plane) => ({
                    normal: plane.getNormal(),
                    origin: plane.getOrigin(),
                })),
            };
        });
    }
}
/* harmony default export */ const RenderingEngine_VolumeViewport = (VolumeViewport);


/***/ }),

/***/ 40893:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19325);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71851);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49038);
/* harmony import */ var _helpers_setDefaultVolumeVOI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89821);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69372);
/* harmony import */ var _utilities_actorCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98039);
/* harmony import */ var _utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85745);
/* harmony import */ var _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(46347);








class VolumeViewport3D extends _BaseVolumeViewport__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A {
    constructor(props) {
        super(props);
        this.getNumberOfSlices = () => {
            return 1;
        };
        this.getRotation = () => 0;
        this.getCurrentImageIdIndex = () => {
            return 0;
        };
        this.getCurrentImageId = () => {
            return null;
        };
        this.resetCameraForResize = () => {
            return this.resetCamera({
                resetPan: true,
                resetZoom: true,
                resetToCenter: true,
            });
        };
        const { parallelProjection, orientation } = this.options;
        const activeCamera = this.getVtkActiveCamera();
        if (parallelProjection != null) {
            activeCamera.setParallelProjection(parallelProjection);
        }
        if (orientation && orientation !== _enums__WEBPACK_IMPORTED_MODULE_1__.OrientationAxis.ACQUISITION) {
            this.applyViewOrientation(orientation);
        }
    }
    isInAcquisitionPlane() {
        return false;
    }
    resetCamera({ resetPan = true, resetZoom = true, resetToCenter = true, } = {}) {
        super.resetCamera({ resetPan, resetZoom, resetToCenter });
        const activeCamera = this.getVtkActiveCamera();
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        const renderer = this.getRenderer();
        renderer.resetCameraClippingRange();
        return true;
    }
    setSlabThickness(slabThickness, filterActorUIDs) {
        return null;
    }
    setBlendMode(blendMode, filterActorUIDs, immediate) {
        return null;
    }
    resetProperties(volumeId) {
        const volumeActor = volumeId
            ? this.getActor(volumeId)
            : this.getDefaultActor();
        if (!volumeActor) {
            throw new Error(`No actor found for the given volumeId: ${volumeId}`);
        }
        if (volumeActor.slabThickness) {
            volumeActor.slabThickness = _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;
            this.viewportProperties.slabThickness = undefined;
            this.updateClippingPlanesForActors(this.getCamera());
        }
        volumeId ||= this.getVolumeId();
        const imageVolume = _cache_cache__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay.getVolume(volumeId);
        if (!imageVolume) {
            throw new Error(`imageVolume with id: ${volumeId} does not exist in cache`);
        }
        (0,_helpers_setDefaultVolumeVOI__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(volumeActor.actor, imageVolume);
        if ((0,_utilities_actorCheck__WEBPACK_IMPORTED_MODULE_5__/* .isImageActor */ .e)(volumeActor)) {
            const transferFunction = volumeActor.actor
                .getProperty()
                .getRGBTransferFunction(0);
            (0,_utilities_transferFunctionUtils__WEBPACK_IMPORTED_MODULE_6__.setTransferFunctionNodes)(transferFunction, this.initialTransferFunctionNodes);
        }
        this.setCamera(this.initialCamera);
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.VOI_MODIFIED, super.getVOIModifiedEventDetail(volumeId));
    }
    getSliceIndex() {
        return null;
    }
    setCamera(props) {
        super.setCamera(props);
        this.getRenderer().resetCameraClippingRange();
        this.render();
    }
    setCameraClippingRange() {
        const activeCamera = this.getVtkActiveCamera();
        if (activeCamera.getParallelProjection()) {
            activeCamera.setClippingRange(-_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
        else {
            activeCamera.setClippingRange(_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, _constants__WEBPACK_IMPORTED_MODULE_0__.RENDERING_DEFAULTS.MAXIMUM_RAY_DISTANCE);
        }
    }
    resetSlabThickness() {
        return null;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumeViewport3D);


/***/ }),

/***/ 81466:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ RenderingEngine_WSIViewport)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/metaData.js
var metaData = __webpack_require__(74876);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/transform.js
var rendering_transform = __webpack_require__(45354);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/Viewport.js
var Viewport = __webpack_require__(10056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 3 modules
var helpers = __webpack_require__(40661);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js + 6 modules
var constants = __webpack_require__(19325);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 2 modules
var init = __webpack_require__(26896);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js
var pointInShapeCallback = __webpack_require__(56577);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/microscopyViewportCss.js
const microscopyViewportCss = `
.DicomMicroscopyViewer {
  --ol-partial-background-color: rgba(127, 127, 127, 0.7);
  --ol-foreground-color: #000000;
  --ol-subtle-foreground-color: #000;
  --ol-subtle-background-color: rgba(78, 78, 78, 0.5);
}

.DicomMicroscopyViewer .ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.DicomMicroscopyViewer .ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.DicomMicroscopyViewer .ol-scale-bar-inner {
  display: flex;
}

.DicomMicroscopyViewer .ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.DicomMicroscopyViewer .ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.DicomMicroscopyViewer .ol-unsupported {
  display: none;
}

.DicomMicroscopyViewer .ol-viewport,
.DicomMicroscopyViewer .ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.DicomMicroscopyViewer .ol-viewport canvas {
  all: unset;
}

.DicomMicroscopyViewer .ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.DicomMicroscopyViewer .ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.DicomMicroscopyViewer .ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.DicomMicroscopyViewer .ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.DicomMicroscopyViewer .ol-zoom {
  top: 0.5em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-rotate {
  top: 0.5em;
  right: 0.5em;
  transition:
    opacity 0.25s linear,
    visibility 0s linear;
}

.DicomMicroscopyViewer .ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition:
    opacity 0.25s linear,
    visibility 0s linear 0.25s;
}

.DicomMicroscopyViewer .ol-zoom-extent {
  top: 4.643em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-full-screen {
  right: 0.5em;
  top: 0.5em;
}

.DicomMicroscopyViewer .ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: 0.4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.DicomMicroscopyViewer .ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.DicomMicroscopyViewer .ol-zoom-extent button {
  line-height: 1.4em;
}

.DicomMicroscopyViewer .ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.DicomMicroscopyViewer .ol-touch .ol-control button {
  font-size: 1.5em;
}

.DicomMicroscopyViewer .ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-control button:hover,
.DicomMicroscopyViewer .ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.DicomMicroscopyViewer .ol-attribution {
  text-align: right;
  bottom: 0.5em;
  right: 0.5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.DicomMicroscopyViewer .ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.DicomMicroscopyViewer .ol-attribution ul {
  margin: 0;
  padding: 1px 0.5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.DicomMicroscopyViewer .ol-attribution li {
  display: inline;
  list-style: none;
}

.DicomMicroscopyViewer .ol-attribution li:not(:last-child):after {
  content: ' ';
}

.DicomMicroscopyViewer .ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.DicomMicroscopyViewer .ol-attribution button {
  flex-shrink: 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-collapsed ul {
  display: none;
}

.DicomMicroscopyViewer .ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible img {
  margin-top: -0.2em;
  max-height: 1.6em;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-zoomslider {
  top: 4.5em;
  left: 0.5em;
  height: 200px;
}

.DicomMicroscopyViewer .ol-zoomslider button {
  position: relative;
  height: 10px;
}

.DicomMicroscopyViewer .ol-touch .ol-zoomslider {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap button {
  display: block;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.DicomMicroscopyViewer .ol-overviewmap-box {
  border: 0.5px dotted var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}

@layout-header-background: #007ea3;
@primary-color: #007ea3;
@processing-color: #8cb8c6;
@success-color: #3f9c35;
@warning-color: #eeaf30;
@error-color: #96172e;
@font-size-base: 14px;

.DicomMicroscopyViewer .ol-tooltip {
  font-size: 16px !important;
}
`;
/* harmony default export */ const constants_microscopyViewportCss = (microscopyViewportCss);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js












const _map = Symbol.for('map');
const EVENT_POSTRENDER = 'postrender';
class WSIViewport extends Viewport/* default */.A {
    constructor(props) {
        super({
            ...props,
            canvas: props.canvas || (0,helpers/* getOrCreateCanvas */.oI)(props.element),
        });
        this.internalCamera = {
            rotation: 0,
            centerIndex: [0, 0],
            extent: [0, -2, 1, -1],
            xSpacing: 1,
            ySpacing: 1,
            resolution: 1,
            zoom: 1,
        };
        this.voiRange = {
            lower: 0,
            upper: 255,
        };
        this.getProperties = () => {
            return {};
        };
        this.resetCamera = () => {
            return true;
        };
        this.getNumberOfSlices = () => {
            return 1;
        };
        this.getFrameOfReferenceUID = () => {
            return this.frameOfReferenceUID;
        };
        this.resize = () => {
            const canvas = this.canvas;
            const { clientWidth, clientHeight } = canvas;
            if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
                canvas.width = clientWidth;
                canvas.height = clientHeight;
            }
            this.refreshRenderValues();
        };
        this.canvasToWorld = (canvasPos) => {
            if (!this.metadata) {
                return;
            }
            const [px, py] = this.canvasToIndex(canvasPos);
            const { origin, spacing, direction } = this.getImageData();
            const worldPos = esm/* vec3.fromValues */.eR.fromValues(0, 0, 0);
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, origin, iVector, px * spacing[0]);
            esm/* vec3.scaleAndAdd */.eR.scaleAndAdd(worldPos, worldPos, jVector, py * spacing[1]);
            return [worldPos[0], worldPos[1], worldPos[2]];
        };
        this.worldToCanvas = (worldPos) => {
            if (!this.metadata) {
                return;
            }
            const { spacing, direction, origin } = this.metadata;
            const iVector = direction.slice(0, 3);
            const jVector = direction.slice(3, 6);
            const diff = esm/* vec3.subtract */.eR.subtract([0, 0, 0], worldPos, origin);
            const indexPoint = [
                esm/* vec3.dot */.eR.dot(diff, iVector) / spacing[0],
                esm/* vec3.dot */.eR.dot(diff, jVector) / spacing[1],
            ];
            const canvasPoint = this.indexToCanvas(indexPoint);
            return canvasPoint;
        };
        this.postrender = () => {
            this.refreshRenderValues();
            (0,triggerEvent/* default */.A)(this.element, enums.Events.IMAGE_RENDERED, {
                element: this.element,
                viewportId: this.id,
                viewport: this,
                renderingEngineId: this.renderingEngineId,
            });
        };
        this.getRotation = () => 0;
        this.canvasToIndex = (canvasPos) => {
            const transform = this.getTransform();
            transform.invert();
            return transform.transformPoint(canvasPos.map((it) => it * devicePixelRatio));
        };
        this.indexToCanvas = (indexPos) => {
            const transform = this.getTransform();
            return transform
                .transformPoint(indexPos)
                .map((it) => it / devicePixelRatio);
        };
        this.customRenderViewportToCanvas = () => {
        };
        this.getImageIds = () => {
            return [this.imageIds[0]];
        };
        this.renderingEngineId = props.renderingEngineId;
        this.element.setAttribute('data-viewport-uid', this.id);
        this.element.setAttribute('data-rendering-engine-uid', this.renderingEngineId);
        this.element.style.position = 'relative';
        this.microscopyElement = document.createElement('div');
        this.microscopyElement.setAttribute('class', 'DicomMicroscopyViewer');
        this.microscopyElement.id = (0,uuidv4/* default */.A)();
        this.microscopyElement.innerText = 'Initial';
        this.microscopyElement.style.background = 'grey';
        this.microscopyElement.style.width = '100%';
        this.microscopyElement.style.height = '100%';
        this.microscopyElement.style.position = 'absolute';
        this.microscopyElement.style.left = '0';
        this.microscopyElement.style.top = '0';
        const cs3dElement = this.element.firstElementChild;
        cs3dElement.insertBefore(this.microscopyElement, cs3dElement.childNodes[1]);
        this.addEventListeners();
        this.addWidget('DicomMicroscopyViewer', {
            getEnabled: () => !!this.viewer,
            setEnabled: () => {
                this.elementDisabledHandler();
            },
        });
        this.resize();
    }
    static get useCustomRenderingPipeline() {
        return true;
    }
    addEventListeners() {
        this.canvas.addEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    removeEventListeners() {
        this.canvas.removeEventListener(enums.Events.ELEMENT_DISABLED, this.elementDisabledHandler);
    }
    elementDisabledHandler() {
        this.removeEventListeners();
        this.viewer?.cleanup();
        this.viewer = null;
        const cs3dElement = this.element.firstElementChild;
        cs3dElement.removeChild(this.microscopyElement);
        this.microscopyElement = null;
    }
    getImageDataMetadata(imageIndex = 0) {
        const maxImage = this.metadataDicomweb.reduce((maxImage, image) => {
            return maxImage?.NumberOfFrames < image.NumberOfFrames ? image : maxImage;
        });
        const { TotalPixelMatrixColumns: columns, TotalPixelMatrixRows: rows, ImageOrientationSlide, ImagedVolumeWidth: width, ImagedVolumeHeight: height, ImagedVolumeDepth: depth, } = maxImage;
        const imagePlaneModule = metaData.get(enums.MetadataModules.IMAGE_PLANE, this.imageIds[imageIndex]);
        let rowCosines = ImageOrientationSlide.slice(0, 3);
        let columnCosines = ImageOrientationSlide.slice(3, 6);
        if (rowCosines == null || columnCosines == null) {
            rowCosines = [1, 0, 0];
            columnCosines = [0, 1, 0];
        }
        const rowCosineVec = esm/* vec3.fromValues */.eR.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
        const colCosineVec = esm/* vec3.fromValues */.eR.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
        const scanAxisNormal = esm/* vec3.create */.eR.create();
        esm/* vec3.cross */.eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
        const { XOffsetInSlideCoordinateSystem = 0, YOffsetInSlideCoordinateSystem = 0, ZOffsetInSlideCoordinateSystem = 0, } = maxImage.TotalPixelMatrixOriginSequence?.[0] || {};
        const origin = [
            XOffsetInSlideCoordinateSystem,
            YOffsetInSlideCoordinateSystem,
            ZOffsetInSlideCoordinateSystem,
        ];
        const xSpacing = width / columns;
        const ySpacing = height / rows;
        const xVoxels = columns;
        const yVoxels = rows;
        const zSpacing = depth;
        const zVoxels = 1;
        this.hasPixelSpacing = !!(width && height);
        return {
            bitsAllocated: 8,
            numberOfComponents: 3,
            origin,
            direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],
            dimensions: [xVoxels, yVoxels, zVoxels],
            spacing: [xSpacing, ySpacing, zSpacing],
            hasPixelSpacing: this.hasPixelSpacing,
            numVoxels: xVoxels * yVoxels * zVoxels,
            imagePlaneModule,
        };
    }
    async setFrameNumber(frame) {
    }
    setProperties(props) {
    }
    resetProperties() {
        this.setProperties({});
    }
    getScalarData() {
        return null;
    }
    getImageData() {
        const { metadata } = this;
        if (!metadata) {
            return null;
        }
        const { spacing } = metadata;
        const imageData = {
            getDirection: () => metadata.direction,
            getDimensions: () => metadata.dimensions,
            getRange: () => [0, 255],
            getScalarData: () => this.getScalarData(),
            getSpacing: () => metadata.spacing,
            worldToIndex: (point) => {
                const canvasPoint = this.worldToCanvas(point);
                const pixelCoord = this.canvasToIndex(canvasPoint);
                return [pixelCoord[0], pixelCoord[1], 0];
            },
            indexToWorld: (point) => {
                const canvasPoint = this.indexToCanvas([point[0], point[1]]);
                return this.canvasToWorld(canvasPoint);
            },
        };
        const imageDataReturn = {
            dimensions: metadata.dimensions,
            spacing,
            numberOfComponents: 3,
            origin: metadata.origin,
            direction: metadata.direction,
            metadata: {
                Modality: this.modality,
                FrameOfReferenceUID: this.frameOfReferenceUID,
            },
            hasPixelSpacing: this.hasPixelSpacing,
            calibration: this.calibration,
            preScale: {
                scaled: false,
            },
            scalarData: this.getScalarData(),
            imageData,
            voxelManager: {
                forEach: (callback, options) => {
                    return (0,pointInShapeCallback/* pointInShapeCallback */.ii)(options.imageData, {
                        pointInShapeFn: options.isInObject ?? (() => true),
                        callback: callback,
                        boundsIJK: options.boundsIJK,
                        returnPoints: options.returnPoints ?? false,
                    });
                },
            },
        };
        return imageDataReturn;
    }
    hasImageURI(imageURI) {
        return true;
    }
    setCamera(camera) {
        const previousCamera = this.getCamera();
        const { parallelScale, focalPoint } = camera;
        const view = this.getView();
        const { xSpacing } = this.internalCamera;
        if (parallelScale) {
            const worldToCanvasRatio = this.element.clientHeight / parallelScale;
            const resolution = 1 / xSpacing / worldToCanvasRatio;
            view.setResolution(resolution);
        }
        if (focalPoint) {
            const newCanvas = this.worldToCanvas(focalPoint);
            const newIndex = this.canvasToIndex(newCanvas);
            view.setCenter(newIndex);
        }
        const updatedCamera = this.getCamera();
        this.triggerCameraModifiedEventIfNecessary(previousCamera, updatedCamera);
    }
    getCurrentImageId() {
        return this.imageIds[0];
    }
    getFrameNumber() {
        return 1;
    }
    getCamera() {
        this.refreshRenderValues();
        const { resolution, xSpacing } = this.internalCamera;
        const canvasToWorldRatio = resolution * xSpacing;
        const canvasCenter = [
            this.element.clientWidth / 2,
            this.element.clientHeight / 2,
        ];
        const focalPoint = this.canvasToWorld(canvasCenter);
        return {
            parallelProjection: true,
            focalPoint,
            position: focalPoint,
            viewUp: [0, -1, 0],
            parallelScale: this.element.clientHeight * canvasToWorldRatio,
            viewPlaneNormal: [0, 0, 1],
        };
    }
    static { this.getDicomMicroscopyViewer = async () => {
        return (0,init/* peerImport */.a)('dicom-microscopy-viewer');
    }; }
    setDataIds(imageIds, options) {
        if (options?.miniNavigationOverlay !== false) {
            WSIViewport.addMiniNavigationOverlayCss();
        }
        const webClient = options?.webClient ||
            metaData.get(enums.MetadataModules.WADO_WEB_CLIENT, imageIds[0]);
        if (!webClient) {
            throw new Error(`To use setDataIds on WSI data, you must provide metaData.webClient for ${imageIds[0]}`);
        }
        return this.setWSI(imageIds, webClient);
    }
    async setWSI(imageIds, client) {
        this.microscopyElement.style.background = 'black';
        this.microscopyElement.innerText = 'Loading';
        this.imageIds = imageIds;
        const DicomMicroscopyViewer = await WSIViewport.getDicomMicroscopyViewer();
        this.frameOfReferenceUID = null;
        const metadataDicomweb = this.imageIds.map((imageId) => {
            const imageMetadata = client.getDICOMwebMetadata(imageId);
            Object.defineProperty(imageMetadata, 'isMultiframe', {
                value: imageMetadata.isMultiframe,
                enumerable: false,
            });
            Object.defineProperty(imageMetadata, 'frameNumber', {
                value: undefined,
                enumerable: false,
            });
            const imageType = imageMetadata['00080008']?.Value;
            if (imageType?.length === 1) {
                imageMetadata['00080008'].Value = imageType[0].split('\\');
            }
            const frameOfReference = imageMetadata['00200052']?.Value?.[0];
            if (!this.frameOfReferenceUID) {
                this.frameOfReferenceUID = frameOfReference;
            }
            else if (frameOfReference !== this.frameOfReferenceUID) {
                imageMetadata['00200052'].Value = [this.frameOfReferenceUID];
            }
            return imageMetadata;
        });
        const volumeImages = [];
        metadataDicomweb.forEach((m) => {
            const image = new DicomMicroscopyViewer.metadata.VLWholeSlideMicroscopyImage({
                metadata: m,
            });
            const imageFlavor = image.ImageType[2];
            if (imageFlavor === 'VOLUME' || imageFlavor === 'THUMBNAIL') {
                volumeImages.push(image);
            }
            else {
                console.log('Unknown image type', image.ImageType);
            }
        });
        this.metadataDicomweb = volumeImages;
        const viewer = new DicomMicroscopyViewer.viewer.VolumeImageViewer({
            client,
            metadata: volumeImages,
            controls: ['overview', 'position'],
            retrieveRendered: false,
            bindings: {},
        });
        viewer.render({ container: this.microscopyElement });
        this.metadata = this.getImageDataMetadata();
        viewer.deactivateDragPanInteraction();
        this.viewer = viewer;
        this.map = viewer[_map];
        this.map.on(EVENT_POSTRENDER, this.postrender);
        this.resize();
        this.microscopyElement.innerText = '';
        Object.assign(this.microscopyElement.style, {
            '--ol-partial-background-color': 'rgba(127, 127, 127, 0.7)',
            '--ol-foreground-color': '#000000',
            '--ol-subtle-foreground-color': '#000',
            '--ol-subtle-background-color': 'rgba(78, 78, 78, 0.5)',
            background: 'none',
        });
    }
    scroll(delta) {
        const camera = this.getCamera();
        this.setCamera({
            parallelScale: camera.parallelScale * (1 + 0.1 * delta),
        });
    }
    getSliceIndex() {
        return 0;
    }
    getView() {
        if (!this.viewer) {
            return;
        }
        const map = this.viewer[_map];
        const anyWindow = window;
        anyWindow.map = map;
        anyWindow.viewer = this.viewer;
        anyWindow.view = map?.getView();
        anyWindow.wsi = this;
        return map?.getView();
    }
    refreshRenderValues() {
        const view = this.getView();
        if (!view) {
            return;
        }
        const resolution = view.getResolution();
        if (!resolution || resolution < constants.EPSILON) {
            return;
        }
        const centerIndex = view.getCenter();
        const extent = view.getProjection().getExtent();
        const rotation = view.getRotation();
        const zoom = view.getZoom();
        const { metadata: { spacing: [xSpacing, ySpacing], }, } = this;
        const worldToCanvasRatio = 1 / resolution / xSpacing;
        Object.assign(this.internalCamera, {
            extent,
            centerIndex,
            worldToCanvasRatio,
            xSpacing,
            ySpacing,
            resolution,
            rotation,
            zoom,
        });
    }
    getZoom() {
        return this.getView()?.getZoom();
    }
    setZoom(zoom) {
        this.getView()?.setZoom(zoom);
    }
    getTransform() {
        this.refreshRenderValues();
        const { centerIndex: center, resolution, rotation } = this.internalCamera;
        const halfCanvas = [this.canvas.width / 2, this.canvas.height / 2];
        const transform = new rendering_transform/* Transform */.d();
        transform.translate(halfCanvas[0], halfCanvas[1]);
        transform.rotate(rotation);
        transform.scale(1 / resolution, -1 / resolution);
        transform.translate(-center[0], -center[1]);
        return transform;
    }
    getViewReferenceId() {
        return `imageId:${this.getCurrentImageId()}`;
    }
    getCurrentImageIdIndex() {
        return 0;
    }
    static { this.overlayCssId = 'overlayCss'; }
    static addMiniNavigationOverlayCss() {
        if (document.getElementById(this.overlayCssId)) {
            return;
        }
        const overlayCss = document.createElement('style');
        overlayCss.innerText = constants_microscopyViewportCss;
        overlayCss.setAttribute('id', this.overlayCssId);
        document.getElementsByTagName('head')[0].append(overlayCss);
    }
}
/* harmony default export */ const RenderingEngine_WSIViewport = (WSIViewport);


/***/ }),

/***/ 39536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   lD: () => (/* binding */ getRenderingEngine),
/* harmony export */   qO: () => (/* binding */ getRenderingEngines)
/* harmony export */ });
/* harmony import */ var _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5862);

function getRenderingEngine(id) {
    return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.get(id);
}
function getRenderingEngines() {
    return _renderingEngineCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getAll();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRenderingEngine);


/***/ }),

/***/ 12132:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ createViewport)
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setDefaultViewport.js
const state = {
    viewport: {},
};
/* harmony default export */ function setDefaultViewport(viewport) {
    state.viewport = viewport || {};
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/createViewport.js


function createDefaultDisplayedArea() {
    return {
        tlhc: {
            x: 1,
            y: 1,
        },
        brhc: {
            x: 1,
            y: 1,
        },
        rowPixelSpacing: 1,
        columnPixelSpacing: 1,
        presentationSizeMode: 'NONE',
    };
}
function createViewport() {
    const displayedArea = createDefaultDisplayedArea();
    const initialDefaultViewport = {
        scale: 1,
        translation: {
            x: 0,
            y: 0,
        },
        voi: {
            windowWidth: undefined,
            windowCenter: undefined,
            voiLUTFunction: enums.VOILUTFunctionType.LINEAR,
        },
        invert: false,
        pixelReplication: false,
        rotation: 0,
        hflip: false,
        vflip: false,
        modalityLUT: undefined,
        voiLUT: undefined,
        colormap: undefined,
        labelmap: false,
        displayedArea,
    };
    return Object.assign({}, initialDefaultViewport, state.viewport);
}


/***/ }),

/***/ 23681:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ doesImageNeedToBeRendered)
/* harmony export */ });
function doesImageNeedToBeRendered(enabledElement, image) {
    const lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;
    const lastRenderedViewport = enabledElement.renderingTools.lastRenderedViewport;
    return (image.imageId !== lastRenderedImageId ||
        !lastRenderedViewport ||
        lastRenderedViewport.windowCenter !==
            enabledElement.viewport.voi.windowCenter ||
        lastRenderedViewport.windowWidth !==
            enabledElement.viewport.voi.windowWidth ||
        lastRenderedViewport.invert !== enabledElement.viewport.invert ||
        lastRenderedViewport.rotation !== enabledElement.viewport.rotation ||
        lastRenderedViewport.hflip !== enabledElement.viewport.hflip ||
        lastRenderedViewport.vflip !== enabledElement.viewport.vflip ||
        lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT ||
        lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT ||
        lastRenderedViewport.colormap !== enabledElement.viewport.colormap);
}


/***/ }),

/***/ 57162:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15528);
/* harmony import */ var _getImageSize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62596);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(canvas, image, rotation = null) {
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(canvas, 'getImageScale: parameter canvas must not be undefined');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image, 'getImageScale: parameter image must not be undefined');
    const imageSize = (0,_getImageSize__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(image, rotation);
    const rowPixelSpacing = image.rowPixelSpacing || 1;
    const columnPixelSpacing = image.columnPixelSpacing || 1;
    let verticalRatio = 1;
    let horizontalRatio = 1;
    if (rowPixelSpacing < columnPixelSpacing) {
        horizontalRatio = columnPixelSpacing / rowPixelSpacing;
    }
    else {
        verticalRatio = rowPixelSpacing / columnPixelSpacing;
    }
    const verticalScale = canvas.height / imageSize.height / verticalRatio;
    const horizontalScale = canvas.width / imageSize.width / horizontalRatio;
    return {
        verticalScale,
        horizontalScale,
        scaleFactor: Math.min(horizontalScale, verticalScale),
    };
}


/***/ }),

/***/ 62596:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15528);

function isRotated(rotation) {
    return !(rotation === null ||
        rotation === undefined ||
        rotation === 0 ||
        rotation === 180);
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(image, rotation = null) {
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image, 'getImageSize: parameter image must not be undefined');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image.width, 'getImageSize: parameter image must have width');
    (0,_validator__WEBPACK_IMPORTED_MODULE_0__/* .validateParameterUndefinedOrNull */ .C)(image.height, 'getImageSize: parameter image must have height');
    if (isRotated(rotation)) {
        return {
            height: image.width,
            width: image.height,
        };
    }
    return {
        width: image.width,
        height: image.height,
    };
}


/***/ }),

/***/ 19704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ getLut)
});

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/computeAutoVoi.js
function computeAutoVoi(viewport, image) {
    if (hasVoi(viewport)) {
        return;
    }
    const maxVoi = image.maxPixelValue * image.slope + image.intercept;
    const minVoi = image.minPixelValue * image.slope + image.intercept;
    const ww = maxVoi - minVoi;
    const wc = (maxVoi + minVoi) / 2;
    if (viewport.voi === undefined) {
        viewport.voi = {
            windowWidth: ww,
            windowCenter: wc,
            voiLUTFunction: image.voiLUTFunction,
        };
    }
    else {
        viewport.voi.windowWidth = ww;
        viewport.voi.windowCenter = wc;
    }
}
function hasVoi(viewport) {
    const hasLut = viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;
    return (hasLut ||
        (viewport.voi.windowWidth !== undefined &&
            viewport.voi.windowCenter !== undefined));
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/lutMatches.js
function lutMatches(a, b) {
    if (!a && !b) {
        return true;
    }
    if (!a || !b) {
        return false;
    }
    return a.id === b.id;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getModalityLut.js
function generateLinearModalityLUT(slope, intercept) {
    return (storedPixelValue) => storedPixelValue * slope + intercept;
}
function generateNonLinearModalityLUT(modalityLUT) {
    const minValue = modalityLUT.lut[0];
    const maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];
    const maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;
    return (storedPixelValue) => {
        if (storedPixelValue < modalityLUT.firstValueMapped) {
            return minValue;
        }
        else if (storedPixelValue >= maxValueMapped) {
            return maxValue;
        }
        return modalityLUT.lut[storedPixelValue];
    };
}
/* harmony default export */ function getModalityLut(slope, intercept, modalityLUT) {
    if (modalityLUT) {
        return generateNonLinearModalityLUT(modalityLUT);
    }
    return generateLinearModalityLUT(slope, intercept);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.js
var getVOILut = __webpack_require__(44333);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateLut.js


/* harmony default export */ function generateLut(image, windowWidth, windowCenter, invert, modalityLUT, voiLUT) {
    const maxPixelValue = image.maxPixelValue;
    const minPixelValue = image.minPixelValue;
    const offset = Math.min(minPixelValue, 0);
    if (image.cachedLut === undefined) {
        const length = maxPixelValue - offset + 1;
        image.cachedLut = {};
        image.cachedLut.lutArray = new Uint8ClampedArray(length);
    }
    const lut = image.cachedLut.lutArray;
    const mlutfn = getModalityLut(image.slope, image.intercept, modalityLUT);
    const vlutfn = (0,getVOILut/* default */.A)(windowWidth, windowCenter, voiLUT);
    if (image.isPreScaled) {
        if (invert) {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = 255 - vlutfn(storedValue);
            }
        }
        else {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = vlutfn(storedValue);
            }
        }
    }
    else {
        if (invert) {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));
            }
        }
        else {
            for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
                lut[storedValue + -offset] = vlutfn(mlutfn(storedValue));
            }
        }
    }
    return lut;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js



/* harmony default export */ function getLut(image, viewport, invalidated) {
    if (image.cachedLut !== undefined &&
        image.cachedLut.windowCenter === viewport.voi.windowCenter &&
        image.cachedLut.windowWidth === viewport.voi.windowWidth &&
        lutMatches(image.cachedLut.modalityLUT, viewport.modalityLUT) &&
        lutMatches(image.cachedLut.voiLUT, viewport.voiLUT) &&
        image.cachedLut.invert === viewport.invert &&
        !invalidated) {
        return image.cachedLut.lutArray;
    }
    computeAutoVoi(viewport, image);
    generateLut(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);
    image.cachedLut.windowWidth = viewport.voi.windowWidth;
    image.cachedLut.windowCenter = viewport.voi.windowCenter;
    image.cachedLut.invert = viewport.invert;
    image.cachedLut.voiLUT = viewport.voiLUT;
    image.cachedLut.modalityLUT = viewport.modalityLUT;
    return image.cachedLut.lutArray;
}


/***/ }),

/***/ 44333:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function generateLinearVOILUT(windowWidth, windowCenter) {
    return function (modalityLutValue) {
        const value = ((modalityLutValue - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) *
            255.0;
        return Math.min(Math.max(value, 0), 255);
    };
}
function generateNonLinearVOILUT(voiLUT) {
    const bitsPerEntry = Math.max(...voiLUT.lut).toString(2).length;
    const shift = bitsPerEntry - 8;
    const minValue = voiLUT.lut[0] >> shift;
    const maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;
    const maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;
    return function (modalityLutValue) {
        if (modalityLutValue < voiLUT.firstValueMapped) {
            return minValue;
        }
        else if (modalityLutValue >= maxValueMapped) {
            return maxValue;
        }
        return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;
    };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(windowWidth, windowCenter, voiLUT) {
    if (voiLUT) {
        return generateNonLinearVOILUT(voiLUT);
    }
    return generateLinearVOILUT(windowWidth, windowCenter);
}


/***/ }),

/***/ 27810:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, image) {
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    renderCanvas.width = image.width;
    renderCanvas.height = image.height;
    const canvasContext = renderCanvas.getContext('2d');
    canvasContext.fillStyle = 'white';
    canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);
    const renderCanvasData = canvasContext.getImageData(0, 0, image.width, image.height);
    enabledElement.renderingTools.renderCanvasContext = canvasContext;
    enabledElement.renderingTools.renderCanvasData = renderCanvasData;
}


/***/ }),

/***/ 53586:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    if (window.performance) {
        return performance.now();
    }
    return Date.now();
}


/***/ }),

/***/ 48080:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ renderColorImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.js
var getVOILut = __webpack_require__(44333);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/generateColorLUT.js

function generateColorLUT(image, windowWidth, windowCenter, invert, voiLUT) {
    const maxPixelValue = image.maxPixelValue;
    const minPixelValue = image.minPixelValue;
    const offset = Math.min(minPixelValue, 0);
    if (image.cachedLut === undefined) {
        const length = maxPixelValue - offset + 1;
        image.cachedLut = {};
        image.cachedLut.lutArray = new Uint8ClampedArray(length);
    }
    const lut = image.cachedLut.lutArray;
    const vlutfn = (0,getVOILut/* default */.A)(Array.isArray(windowWidth) ? windowWidth[0] : windowWidth, Array.isArray(windowCenter) ? windowCenter[0] : windowCenter, voiLUT);
    if (invert) {
        for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
            lut[storedValue + -offset] = 255 - vlutfn(storedValue);
        }
    }
    else {
        for (let storedValue = minPixelValue; storedValue <= maxPixelValue; storedValue++) {
            lut[storedValue + -offset] = vlutfn(storedValue);
        }
    }
    return lut;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedColorPixelDataToCanvasImageData.js

/* harmony default export */ function storedColorPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    const numPixels = pixelData.length;
    start = (0,now/* default */.A)();
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedRGBAPixelDataToCanvasImageData.js

/* harmony default export */ function storedRGBAPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.getPixelData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    const numPixels = pixelData.length;
    start = (0,now/* default */.A)();
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] =
                pixelData[storedPixelDataIndex++];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] =
                pixelData[storedPixelDataIndex++];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderColorImage.js









function getLut(image, viewport) {
    if (image.cachedLut !== undefined &&
        image.cachedLut.windowCenter === viewport.voi.windowCenter &&
        image.cachedLut.windowWidth === viewport.voi.windowWidth &&
        image.cachedLut.invert === viewport.invert) {
        return image.cachedLut.lutArray;
    }
    generateColorLUT(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);
    image.cachedLut.windowWidth = viewport.voi.windowWidth;
    image.cachedLut.windowCenter = viewport.voi.windowCenter;
    image.cachedLut.invert = viewport.invert;
    return image.cachedLut.lutArray;
}
function getRenderCanvas(enabledElement, image, invalidated) {
    const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
    if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {
        enabledElement.renderingTools.renderCanvas = (0,getOrCreateCanvas/* createCanvas */.Nw)(null, image.width, image.height);
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    const { windowWidth, windowCenter } = enabledElement.viewport.voi;
    if ((windowWidth === 256 || windowWidth === 255) &&
        (windowCenter === 128 || windowCenter === 127) &&
        !enabledElement.viewport.invert &&
        image.getCanvas &&
        image.getCanvas()) {
        return image.getCanvas();
    }
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) && !invalidated) {
        return renderCanvas;
    }
    if (!enabledElement.renderingTools.renderCanvasContext ||
        renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    let start = (0,now/* default */.A)();
    const colorLUT = getLut(image, enabledElement.viewport);
    image.stats = image.stats || {};
    image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    if (image.rgba) {
        storedRGBAPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
    }
    else {
        storedColorPixelDataToCanvasImageData(image, colorLUT, renderCanvasData.data);
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderColorImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('renderColorImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('renderColorImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 92885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  j: () => (/* binding */ renderGrayscaleImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageData.js

/* harmony default export */ function storedPixelDataToCanvasImageData(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 3;
    let storedPixelDataIndex = 0;
    start = (0,now/* default */.A)();
    if (pixelData instanceof Int16Array) {
        if (minPixelValue < 0) {
            while (storedPixelDataIndex < numPixels) {
                canvasImageDataData[canvasImageDataIndex] =
                    lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
                canvasImageDataIndex += 4;
            }
        }
        else {
            while (storedPixelDataIndex < numPixels) {
                canvasImageDataData[canvasImageDataIndex] =
                    lut[pixelData[storedPixelDataIndex++]];
                canvasImageDataIndex += 4;
            }
        }
    }
    else if (pixelData instanceof Uint16Array) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataIndex += 4;
        }
    }
    else if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataIndex += 4;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            canvasImageDataData[canvasImageDataIndex] =
                lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataIndex += 4;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPET.js

/* harmony default export */ function storedPixelDataToCanvasImageDataPET(image, lutFunction, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    let canvasImageDataIndex = 3;
    let storedPixelDataIndex = 0;
    start = (0,now/* default */.A)();
    while (storedPixelDataIndex < numPixels) {
        canvasImageDataData[canvasImageDataIndex] = lutFunction(pixelData[storedPixelDataIndex++]);
        canvasImageDataIndex += 4;
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataRGBA.js

/* harmony default export */ function storedPixelDataToCanvasImageDataRGBA(image, lut, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let pixelValue;
    start = (0,now/* default */.A)();
    if (pixelData instanceof Int16Array) {
        if (minPixelValue < 0) {
            while (storedPixelDataIndex < numPixels) {
                pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = 255;
            }
        }
        else {
            while (storedPixelDataIndex < numPixels) {
                pixelValue = lut[pixelData[storedPixelDataIndex++]];
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = pixelValue;
                canvasImageDataData[canvasImageDataIndex++] = 255;
            }
        }
    }
    else if (pixelData instanceof Uint16Array) {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    else if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            pixelValue = lut[pixelData[storedPixelDataIndex++]];
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = pixelValue;
            canvasImageDataData[canvasImageDataIndex++] = 255;
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js + 4 modules
var getLut = __webpack_require__(19704);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderGrayscaleImage.js










function getRenderCanvas(enabledElement, image, invalidated, useAlphaChannel = true) {
    const canvasWasColor = enabledElement.renderingTools.lastRenderedIsColor;
    if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {
        enabledElement.renderingTools.renderCanvas = (0,getOrCreateCanvas/* createCanvas */.Nw)(null, image.width, image.height);
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) && !invalidated) {
        return renderCanvas;
    }
    if (renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    image.stats = image.stats || {};
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    let start = (0,now/* default */.A)();
    image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
    const { viewport } = enabledElement;
    if (viewport.modality === 'PT' && image.isPreScaled) {
        const { windowWidth, windowCenter } = viewport.voi;
        const minimum = windowCenter - windowWidth / 2;
        const maximum = windowCenter + windowWidth / 2;
        const range = maximum - minimum;
        const collectedMultiplierTerms = 255.0 / range;
        let petVOILutFunction;
        if (viewport.invert) {
            petVOILutFunction = (value) => 255 - (value - minimum) * collectedMultiplierTerms;
        }
        else {
            petVOILutFunction = (value) => (value - minimum) * collectedMultiplierTerms;
        }
        storedPixelDataToCanvasImageDataPET(image, petVOILutFunction, renderCanvasData.data);
    }
    else {
        const lut = (0,getLut/* default */.A)(image, viewport, invalidated);
        if (useAlphaChannel) {
            storedPixelDataToCanvasImageData(image, lut, renderCanvasData.data);
        }
        else {
            storedPixelDataToCanvasImageDataRGBA(image, lut, renderCanvasData.data);
        }
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderGrayscaleImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('drawImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('drawImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 71209:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  l: () => (/* binding */ renderPseudoColorImage)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.js
var setToPixelCoordinateSystem = __webpack_require__(79280);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/now.js
var now = __webpack_require__(53586);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.js
var initializeRenderCanvas = __webpack_require__(27810);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getLut.js + 4 modules
var getLut = __webpack_require__(19704);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.js
var saveLastRendered = __webpack_require__(81064);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.js
var doesImageNeedToBeRendered = __webpack_require__(23681);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/lookupTable.js
const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;
function HSVToRGB(hue, sat, val) {
    if (hue > 1) {
        throw new Error('HSVToRGB expects hue < 1');
    }
    const rgb = [];
    if (sat === 0) {
        rgb[0] = val;
        rgb[1] = val;
        rgb[2] = val;
        return rgb;
    }
    const hueCase = Math.floor(hue * 6);
    const frac = 6 * hue - hueCase;
    const lx = val * (1 - sat);
    const ly = val * (1 - sat * frac);
    const lz = val * (1 - sat * (1 - frac));
    switch (hueCase) {
        case 0:
        case 6:
            rgb[0] = val;
            rgb[1] = lz;
            rgb[2] = lx;
            break;
        case 1:
            rgb[0] = ly;
            rgb[1] = val;
            rgb[2] = lx;
            break;
        case 2:
            rgb[0] = lx;
            rgb[1] = val;
            rgb[2] = lz;
            break;
        case 3:
            rgb[0] = lx;
            rgb[1] = ly;
            rgb[2] = val;
            break;
        case 4:
            rgb[0] = lz;
            rgb[1] = lx;
            rgb[2] = val;
            break;
        case 5:
            rgb[0] = val;
            rgb[1] = lx;
            rgb[2] = ly;
            break;
    }
    return rgb;
}
function linearIndexLookupMain(v, p) {
    let dIndex;
    if (v < p.Range[0]) {
        dIndex = p.MaxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    }
    else if (v > p.Range[1]) {
        dIndex = p.MaxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    }
    else {
        dIndex = (v + p.Shift) * p.Scale;
    }
    return Math.floor(dIndex);
}
class LookupTable {
    constructor() {
        this.NumberOfColors = 256;
        this.Ramp = 'linear';
        this.TableRange = [0, 255];
        this.HueRange = [0, 0.66667];
        this.SaturationRange = [1, 1];
        this.ValueRange = [1, 1];
        this.AlphaRange = [1, 1];
        this.NaNColor = [128, 0, 0, 255];
        this.BelowRangeColor = [0, 0, 0, 255];
        this.UseBelowRangeColor = true;
        this.AboveRangeColor = [255, 255, 255, 255];
        this.UseAboveRangeColor = true;
        this.InputRange = [0, 255];
        this.Table = [];
    }
    setNumberOfTableValues(number) {
        this.NumberOfColors = number;
    }
    setRamp(ramp) {
        this.Ramp = ramp;
    }
    setTableRange(start, end) {
        this.TableRange[0] = start;
        this.TableRange[1] = end;
    }
    setHueRange(start, end) {
        this.HueRange[0] = start;
        this.HueRange[1] = end;
    }
    setSaturationRange(start, end) {
        this.SaturationRange[0] = start;
        this.SaturationRange[1] = end;
    }
    setValueRange(start, end) {
        this.ValueRange[0] = start;
        this.ValueRange[1] = end;
    }
    setRange(start, end) {
        this.InputRange[0] = start;
        this.InputRange[1] = end;
    }
    setAlphaRange(start, end) {
        this.AlphaRange[0] = start;
        this.AlphaRange[1] = end;
    }
    getColor(scalar) {
        return this.mapValue(scalar);
    }
    build(force) {
        if (this.Table.length > 1 && !force) {
            return;
        }
        this.Table = [];
        const maxIndex = this.NumberOfColors - 1;
        let hinc, sinc, vinc, ainc;
        if (maxIndex) {
            hinc = (this.HueRange[1] - this.HueRange[0]) / maxIndex;
            sinc = (this.SaturationRange[1] - this.SaturationRange[0]) / maxIndex;
            vinc = (this.ValueRange[1] - this.ValueRange[0]) / maxIndex;
            ainc = (this.AlphaRange[1] - this.AlphaRange[0]) / maxIndex;
        }
        else {
            hinc = sinc = vinc = ainc = 0.0;
        }
        for (let i = 0; i <= maxIndex; i++) {
            const hue = this.HueRange[0] + i * hinc;
            const sat = this.SaturationRange[0] + i * sinc;
            const val = this.ValueRange[0] + i * vinc;
            const alpha = this.AlphaRange[0] + i * ainc;
            const rgb = HSVToRGB(hue, sat, val);
            const c_rgba = [0, 0, 0, 0];
            switch (this.Ramp) {
                case 'scurve':
                    c_rgba[0] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[0]) * Math.PI)));
                    c_rgba[1] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[1]) * Math.PI)));
                    c_rgba[2] = Math.floor(127.5 * (1.0 + Math.cos((1.0 - rgb[2]) * Math.PI)));
                    c_rgba[3] = Math.floor(alpha * 255);
                    break;
                case 'linear':
                    c_rgba[0] = Math.floor(rgb[0] * 255 + 0.5);
                    c_rgba[1] = Math.floor(rgb[1] * 255 + 0.5);
                    c_rgba[2] = Math.floor(rgb[2] * 255 + 0.5);
                    c_rgba[3] = Math.floor(alpha * 255 + 0.5);
                    break;
                case 'sqrt':
                    c_rgba[0] = Math.floor(Math.sqrt(rgb[0]) * 255 + 0.5);
                    c_rgba[1] = Math.floor(Math.sqrt(rgb[1]) * 255 + 0.5);
                    c_rgba[2] = Math.floor(Math.sqrt(rgb[2]) * 255 + 0.5);
                    c_rgba[3] = Math.floor(Math.sqrt(alpha) * 255 + 0.5);
                    break;
                default:
                    throw new Error(`Invalid Ramp value (${this.Ramp})`);
            }
            this.Table.push(c_rgba);
        }
        this.buildSpecialColors();
    }
    buildSpecialColors() {
        const numberOfColors = this.NumberOfColors;
        const belowRangeColorIndex = numberOfColors + BELOW_RANGE_COLOR_INDEX;
        const aboveRangeColorIndex = numberOfColors + ABOVE_RANGE_COLOR_INDEX;
        const nanColorIndex = numberOfColors + NAN_COLOR_INDEX;
        if (this.UseBelowRangeColor || numberOfColors === 0) {
            this.Table[belowRangeColorIndex] = this.BelowRangeColor;
        }
        else {
            this.Table[belowRangeColorIndex] = this.Table[0];
        }
        if (this.UseAboveRangeColor || numberOfColors === 0) {
            this.Table[aboveRangeColorIndex] = this.AboveRangeColor;
        }
        else {
            this.Table[aboveRangeColorIndex] = this.Table[numberOfColors - 1];
        }
        this.Table[nanColorIndex] = this.NaNColor;
    }
    mapValue(v) {
        const index = this.getIndex(v);
        if (index < 0) {
            return this.NaNColor;
        }
        else if (index === 0) {
            if (this.UseBelowRangeColor && v < this.TableRange[0]) {
                return this.BelowRangeColor;
            }
        }
        else if (index === this.NumberOfColors - 1) {
            if (this.UseAboveRangeColor && v > this.TableRange[1]) {
                return this.AboveRangeColor;
            }
        }
        return this.Table[index];
    }
    getIndex(v) {
        const p = {
            Range: [],
            MaxIndex: this.NumberOfColors - 1,
            Shift: -this.TableRange[0],
            Scale: 1,
        };
        if (this.TableRange[1] <= this.TableRange[0]) {
            p.Scale = Number.MAX_VALUE;
        }
        else {
            p.Scale = p.MaxIndex / (this.TableRange[1] - this.TableRange[0]);
        }
        p.Range[0] = this.TableRange[0];
        p.Range[1] = this.TableRange[1];
        if (isNaN(v)) {
            return -1;
        }
        let index = linearIndexLookupMain(v, p);
        if (index === this.NumberOfColors + BELOW_RANGE_COLOR_INDEX) {
            index = 0;
        }
        else if (index === this.NumberOfColors + ABOVE_RANGE_COLOR_INDEX) {
            index = this.NumberOfColors - 1;
        }
        return index;
    }
    setTableValue(index, rgba, g, b, a) {
        let colorArray;
        if (typeof rgba === 'number' &&
            g !== undefined &&
            b !== undefined &&
            a !== undefined) {
            colorArray = [rgba, g, b, a];
        }
        else if (Array.isArray(rgba)) {
            colorArray = rgba;
        }
        else {
            throw new Error('Invalid arguments for setTableValue');
        }
        if (index < 0) {
            throw new Error(`Can't set the table value for negative index (${index})`);
        }
        if (index >= this.NumberOfColors) {
            throw new Error(`Index ${index} is greater than the number of colors ${this.NumberOfColors}`);
        }
        this.Table[index] = colorArray;
        if (index === 0 || index === this.NumberOfColors - 1) {
            this.buildSpecialColors();
        }
    }
}
/* harmony default export */ const lookupTable = (LookupTable);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/cpuColormaps.js
var cpuColormaps = __webpack_require__(21093);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/colormap.js


const COLOR_TRANSPARENT = [0, 0, 0, 0];
function linspace(a, b, n) {
    n = n === null ? 100 : n;
    const increment = (b - a) / (n - 1);
    const vector = [];
    while (n-- > 0) {
        vector.push(a);
        a += increment;
    }
    vector[vector.length - 1] = b;
    return vector;
}
function getRank(array, elem) {
    let left = 0;
    let right = array.length - 1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        const midElem = array[mid];
        if (midElem === elem) {
            return mid;
        }
        else if (elem < midElem) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return left;
}
function searchSorted(inputArray, values) {
    let i;
    const indexes = [];
    const len = values.length;
    inputArray.sort(function (a, b) {
        return a - b;
    });
    for (i = 0; i < len; i++) {
        indexes[i] = getRank(inputArray, values[i]);
    }
    return indexes;
}
function makeMappingArray(N, data, gamma) {
    let i;
    const x = [];
    const y0 = [];
    const y1 = [];
    const lut = [];
    gamma = gamma === null ? 1 : gamma;
    for (i = 0; i < data.length; i++) {
        const element = data[i];
        x.push((N - 1) * element[0]);
        y0.push(element[1]);
        y1.push(element[1]);
    }
    const xLinSpace = linspace(0, 1, N);
    for (i = 0; i < N; i++) {
        xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);
    }
    const xLinSpaceIndexes = searchSorted(x, xLinSpace);
    for (i = 1; i < N - 1; i++) {
        const index = xLinSpaceIndexes[i];
        const colorPercent = (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);
        const colorDelta = y0[index] - y1[index - 1];
        lut[i] = colorPercent * colorDelta + y1[index - 1];
    }
    lut[0] = y1[0];
    lut[N - 1] = y0[data.length - 1];
    return lut;
}
function createLinearSegmentedColormap(segmentedData, N, gamma) {
    let i;
    const lut = [];
    N = N === null ? 256 : N;
    gamma = gamma === null ? 1 : gamma;
    const redLut = makeMappingArray(N, segmentedData.red, gamma);
    const greenLut = makeMappingArray(N, segmentedData.green, gamma);
    const blueLut = makeMappingArray(N, segmentedData.blue, gamma);
    for (i = 0; i < N; i++) {
        const red = Math.round(redLut[i] * 255);
        const green = Math.round(greenLut[i] * 255);
        const blue = Math.round(blueLut[i] * 255);
        const rgba = [red, green, blue, 255];
        lut.push(rgba);
    }
    return lut;
}
function getColormapsList() {
    const colormaps = [];
    const keys = Object.keys(CPU_COLORMAPS);
    keys.forEach(function (key) {
        if (Object.prototype.hasOwnProperty.call(CPU_COLORMAPS, key)) {
            const colormap = CPU_COLORMAPS[key];
            colormaps.push({
                id: key,
                name: colormap.name,
            });
        }
    });
    colormaps.sort(function (a, b) {
        const aName = a.name.toLowerCase();
        const bName = b.name.toLowerCase();
        if (aName === bName) {
            return 0;
        }
        return aName < bName ? -1 : 1;
    });
    return colormaps;
}
function getColormap(id, colormapData) {
    let colormap = cpuColormaps/* default */.A[id];
    if (!colormap) {
        colormap = cpuColormaps/* default */.A[id] = colormapData || {
            name: '',
            colors: [],
        };
    }
    if (!colormap.colors && colormap.segmentedData) {
        colormap.colors = createLinearSegmentedColormap(colormap.segmentedData, colormap.numColors, colormap.gamma);
    }
    const cpuFallbackColormap = {
        getId() {
            return id;
        },
        getColorSchemeName() {
            return colormap.name;
        },
        setColorSchemeName(name) {
            colormap.name = name;
        },
        getNumberOfColors() {
            return colormap.colors.length;
        },
        setNumberOfColors(numColors) {
            while (colormap.colors.length < numColors) {
                colormap.colors.push(COLOR_TRANSPARENT);
            }
            colormap.colors.length = numColors;
        },
        getColor(index) {
            if (this.isValidIndex(index)) {
                return colormap.colors[index];
            }
            return COLOR_TRANSPARENT;
        },
        getColorRepeating(index) {
            const numColors = colormap.colors.length;
            index = numColors ? index % numColors : 0;
            return this.getColor(index);
        },
        setColor(index, rgba) {
            if (this.isValidIndex(index)) {
                colormap.colors[index] = rgba;
            }
        },
        addColor(rgba) {
            colormap.colors.push(rgba);
        },
        insertColor(index, rgba) {
            if (this.isValidIndex(index)) {
                colormap.colors.splice(index, 1, rgba);
            }
        },
        removeColor(index) {
            if (this.isValidIndex(index)) {
                colormap.colors.splice(index, 1);
            }
        },
        clearColors() {
            colormap.colors = [];
        },
        buildLookupTable(lut) {
            if (!lut) {
                return;
            }
            const numColors = colormap.colors.length;
            lut.setNumberOfTableValues(numColors);
            for (let i = 0; i < numColors; i++) {
                lut.setTableValue(i, colormap.colors[i]);
            }
        },
        createLookupTable() {
            const lut = new lookupTable();
            this.buildLookupTable(lut);
            return lut;
        },
        isValidIndex(index) {
            return index >= 0 && index < colormap.colors.length;
        },
    };
    return cpuFallbackColormap;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/colors/index.js




;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUT.js


function storedPixelDataToCanvasImageDataPseudocolorLUT(image, grayscaleLut, colorLUT, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let grayscale;
    let rgba;
    let clut;
    start = (0,now/* default */.A)();
    if (colorLUT instanceof lookupTable) {
        clut = colorLUT.Table;
    }
    else {
        clut = colorLUT;
    }
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            grayscale =
                grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}
/* harmony default export */ const rendering_storedPixelDataToCanvasImageDataPseudocolorLUT = (storedPixelDataToCanvasImageDataPseudocolorLUT);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUTPET.js


function storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, lutFunction, colorLUT, canvasImageDataData) {
    let start = (0,now/* default */.A)();
    const pixelData = image.voxelManager.getScalarData();
    image.stats.lastGetPixelDataTime = (0,now/* default */.A)() - start;
    const numPixels = pixelData.length;
    const minPixelValue = image.minPixelValue;
    let canvasImageDataIndex = 0;
    let storedPixelDataIndex = 0;
    let grayscale;
    let rgba;
    let clut;
    start = (0,now/* default */.A)();
    if (colorLUT instanceof lookupTable) {
        clut = colorLUT.Table;
    }
    else {
        clut = colorLUT;
    }
    if (minPixelValue < 0) {
        while (storedPixelDataIndex < numPixels) {
            grayscale = lutFunction(pixelData[storedPixelDataIndex++] + -minPixelValue);
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    else {
        while (storedPixelDataIndex < numPixels) {
            grayscale = lutFunction(pixelData[storedPixelDataIndex++]);
            rgba = clut[grayscale];
            canvasImageDataData[canvasImageDataIndex++] = rgba[0];
            canvasImageDataData[canvasImageDataIndex++] = rgba[1];
            canvasImageDataData[canvasImageDataIndex++] = rgba[2];
            canvasImageDataData[canvasImageDataIndex++] = rgba[3];
        }
    }
    image.stats.lastStoredPixelDataToCanvasImageDataTime = (0,now/* default */.A)() - start;
}
/* harmony default export */ const rendering_storedPixelDataToCanvasImageDataPseudocolorLUTPET = (storedPixelDataToCanvasImageDataPseudocolorLUTPET);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js
var clamp = __webpack_require__(84061);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/renderPseudoColorImage.js











function getRenderCanvas(enabledElement, image, invalidated) {
    if (!enabledElement.renderingTools.renderCanvas) {
        enabledElement.renderingTools.renderCanvas = (0,getOrCreateCanvas/* createCanvas */.Nw)(null, image.width, image.height);
    }
    const renderCanvas = enabledElement.renderingTools.renderCanvas;
    let colormap = enabledElement.viewport.colormap || enabledElement.options.colormap;
    if (enabledElement.options && enabledElement.options.colormap) {
        console.warn('enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead');
    }
    if (colormap && typeof colormap === 'string') {
        colormap = getColormap(colormap);
    }
    if (!colormap) {
        throw new Error('renderPseudoColorImage: colormap not found.');
    }
    const colormapId = colormap.getId();
    if (!(0,doesImageNeedToBeRendered/* default */.A)(enabledElement, image) &&
        !invalidated &&
        enabledElement.renderingTools.colormapId === colormapId) {
        return renderCanvas;
    }
    if (!enabledElement.renderingTools.renderCanvasContext ||
        renderCanvas.width !== image.width ||
        renderCanvas.height !== image.height) {
        (0,initializeRenderCanvas/* default */.A)(enabledElement, image);
    }
    let start = (0,now/* default */.A)();
    if (!enabledElement.renderingTools.colorLUT ||
        invalidated ||
        enabledElement.renderingTools.colormapId !== colormapId) {
        colormap.setNumberOfColors(256);
        enabledElement.renderingTools.colorLUT = colormap.createLookupTable();
        enabledElement.renderingTools.colormapId = colormapId;
    }
    const renderCanvasData = enabledElement.renderingTools.renderCanvasData;
    const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;
    const { viewport } = enabledElement;
    const colorLUT = enabledElement.renderingTools.colorLUT;
    if (viewport.modality === 'PT') {
        const { windowWidth, windowCenter } = viewport.voi;
        const minimum = windowCenter - windowWidth / 2;
        const maximum = windowCenter + windowWidth / 2;
        const range = maximum - minimum;
        const collectedMultiplierTerms = 255.0 / range;
        let petVOILutFunction;
        if (viewport.invert) {
            petVOILutFunction = (value) => {
                return (0,clamp/* clamp */.q)(Math.floor(255 - (value - minimum) * collectedMultiplierTerms), 0, 255);
            };
        }
        else {
            petVOILutFunction = (value) => {
                return (0,clamp/* clamp */.q)(Math.floor((value - minimum) * collectedMultiplierTerms), 0, 255);
            };
        }
        rendering_storedPixelDataToCanvasImageDataPseudocolorLUTPET(image, petVOILutFunction, colorLUT, renderCanvasData.data);
    }
    else {
        const lut = (0,getLut/* default */.A)(image, enabledElement.viewport, invalidated);
        image.stats = image.stats || {};
        image.stats.lastLutGenerateTime = (0,now/* default */.A)() - start;
        rendering_storedPixelDataToCanvasImageDataPseudocolorLUT(image, lut, colorLUT, renderCanvasData.data);
    }
    start = (0,now/* default */.A)();
    renderCanvasContext.putImageData(renderCanvasData, 0, 0);
    image.stats.lastPutImageDataTime = (0,now/* default */.A)() - start;
    return renderCanvas;
}
function renderPseudoColorImage(enabledElement, invalidated) {
    if (enabledElement === undefined) {
        throw new Error('drawImage: enabledElement parameter must not be undefined');
    }
    const image = enabledElement.image;
    if (image === undefined) {
        throw new Error('drawImage: image must be loaded before it can be drawn');
    }
    const context = enabledElement.canvas.getContext('2d');
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.fillStyle = 'black';
    context.fillRect(0, 0, enabledElement.canvas.width, enabledElement.canvas.height);
    context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;
    (0,setToPixelCoordinateSystem/* default */.A)(enabledElement, context);
    const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);
    const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;
    const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;
    const width = enabledElement.viewport.displayedArea.brhc.x - sx;
    const height = enabledElement.viewport.displayedArea.brhc.y - sy;
    context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);
    enabledElement.renderingTools = (0,saveLastRendered/* default */.A)(enabledElement);
}


/***/ }),

/***/ 81064:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement) {
    const imageId = enabledElement.image.imageId;
    const viewport = enabledElement.viewport;
    const isColor = enabledElement.image.color;
    enabledElement.renderingTools.lastRenderedImageId = imageId;
    enabledElement.renderingTools.lastRenderedIsColor = isColor;
    enabledElement.renderingTools.lastRenderedViewport = {
        windowCenter: viewport.voi.windowCenter,
        windowWidth: viewport.voi.windowWidth,
        invert: viewport.invert,
        rotation: viewport.rotation,
        hflip: viewport.hflip,
        vflip: viewport.vflip,
        modalityLUT: viewport.modalityLUT,
        voiLUT: viewport.voiLUT,
        colormap: viewport.colormap,
    };
    return enabledElement.renderingTools;
}


/***/ }),

/***/ 79280:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _calculateTransform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7808);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(enabledElement, context, scale) {
    if (enabledElement === undefined) {
        throw new Error('setToPixelCoordinateSystem: parameter enabledElement must not be undefined');
    }
    if (context === undefined) {
        throw new Error('setToPixelCoordinateSystem: parameter context must not be undefined');
    }
    const transform = (0,_calculateTransform__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(enabledElement, scale);
    const m = transform.getMatrix();
    context.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
}


/***/ }),

/***/ 45354:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ Transform)
/* harmony export */ });
class Transform {
    constructor() {
        this.reset();
    }
    getMatrix() {
        return this.m;
    }
    reset() {
        this.m = [1, 0, 0, 1, 0, 0];
    }
    clone() {
        const transform = new Transform();
        transform.m[0] = this.m[0];
        transform.m[1] = this.m[1];
        transform.m[2] = this.m[2];
        transform.m[3] = this.m[3];
        transform.m[4] = this.m[4];
        transform.m[5] = this.m[5];
        return transform;
    }
    multiply(matrix) {
        const m11 = this.m[0] * matrix[0] + this.m[2] * matrix[1];
        const m12 = this.m[1] * matrix[0] + this.m[3] * matrix[1];
        const m21 = this.m[0] * matrix[2] + this.m[2] * matrix[3];
        const m22 = this.m[1] * matrix[2] + this.m[3] * matrix[3];
        const dx = this.m[0] * matrix[4] + this.m[2] * matrix[5] + this.m[4];
        const dy = this.m[1] * matrix[4] + this.m[3] * matrix[5] + this.m[5];
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
        this.m[4] = dx;
        this.m[5] = dy;
    }
    invert() {
        const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
        const m0 = this.m[3] * d;
        const m1 = -this.m[1] * d;
        const m2 = -this.m[2] * d;
        const m3 = this.m[0] * d;
        const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
        const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        this.m[0] = m0;
        this.m[1] = m1;
        this.m[2] = m2;
        this.m[3] = m3;
        this.m[4] = m4;
        this.m[5] = m5;
    }
    rotate(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        const m11 = this.m[0] * c + this.m[2] * s;
        const m12 = this.m[1] * c + this.m[3] * s;
        const m21 = this.m[0] * -s + this.m[2] * c;
        const m22 = this.m[1] * -s + this.m[3] * c;
        this.m[0] = m11;
        this.m[1] = m12;
        this.m[2] = m21;
        this.m[3] = m22;
    }
    translate(x, y) {
        this.m[4] += this.m[0] * x + this.m[2] * y;
        this.m[5] += this.m[1] * x + this.m[3] * y;
    }
    scale(sx, sy) {
        this.m[0] *= sx;
        this.m[1] *= sx;
        this.m[2] *= sy;
        this.m[3] *= sy;
    }
    transformPoint(point) {
        const x = point[0];
        const y = point[1];
        return [
            x * this.m[0] + y * this.m[2] + this.m[4],
            x * this.m[1] + y * this.m[3] + this.m[5],
        ];
    }
}


/***/ }),

/***/ 15528:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ validateParameterUndefinedOrNull)
/* harmony export */ });
/* unused harmony export validateParameterUndefined */
function validateParameterUndefined(checkParam, errorMsg) {
    if (checkParam === undefined) {
        throw new Error(errorMsg);
    }
}
function validateParameterUndefinedOrNull(checkParam, errorMsg) {
    if (checkParam === undefined || checkParam === null) {
        throw new Error(errorMsg);
    }
}


/***/ }),

/***/ 61640:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ helpers_createVolumeActor)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var Prop3D = __webpack_require__(62502);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
var ColorTransferFunction = __webpack_require__(642);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var PiecewiseFunction = __webpack_require__(99341);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var Constants = __webpack_require__(20433);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js





const {
  InterpolationType,
  OpacityMode
} = Constants/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;
const VTK_MAX_VRCOMP = 4;

// ----------------------------------------------------------------------------
// vtkVolumeProperty methods
// ----------------------------------------------------------------------------

function vtkVolumeProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolumeProperty');
  publicAPI.getMTime = () => {
    let mTime = model.mtime;
    let time;
    for (let index = 0; index < VTK_MAX_VRCOMP; index++) {
      // Color MTimes
      if (model.componentData[index].colorChannels === 1) {
        if (model.componentData[index].grayTransferFunction) {
          // time that Gray transfer function was last modified
          time = model.componentData[index].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index].colorChannels === 3) {
        if (model.componentData[index].rGBTransferFunction) {
          // time that RGB transfer function was last modified
          time = model.componentData[index].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }

      // Opacity MTimes
      if (model.componentData[index].scalarOpacity) {
        // time that Scalar opacity transfer function was last modified
        time = model.componentData[index].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index].gradientOpacity) {
        if (!model.componentData[index].disableGradientOpacity) {
          // time that Gradient opacity transfer function was last modified
          time = model.componentData[index].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = index => {
    if (index < 0 || index > 3) {
      vtkErrorMacro('Bad index - must be between 0 and 3');
      return 0;
    }
    return model.componentData[index].colorChannels;
  };

  // Set the color of a volume to a gray transfer function
  publicAPI.setGrayTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].grayTransferFunction !== func) {
      model.componentData[index].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 1) {
      model.componentData[index].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };

  // Get the currently set gray transfer function. Create one if none set.
  publicAPI.getGrayTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].grayTransferFunction === null) {
      model.componentData[index].grayTransferFunction = PiecewiseFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].grayTransferFunction.addPoint(0, 0.0);
      model.componentData[index].grayTransferFunction.addPoint(1024, 1.0);
      if (model.componentData[index].colorChannels !== 1) {
        model.componentData[index].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index].grayTransferFunction;
  };

  // Set the color of a volume to an RGB transfer function
  publicAPI.setRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let modified = false;
    if (model.componentData[index].rGBTransferFunction !== func) {
      model.componentData[index].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 3) {
      model.componentData[index].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };

  // Get the currently set RGB transfer function. Create one if none set.
  publicAPI.getRGBTransferFunction = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].rGBTransferFunction === null) {
      model.componentData[index].rGBTransferFunction = ColorTransferFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].rGBTransferFunction.addRGBPoint(0, 0.0, 0.0, 0.0);
      model.componentData[index].rGBTransferFunction.addRGBPoint(1024, 1.0, 1.0, 1.0);
      if (model.componentData[index].colorChannels !== 3) {
        model.componentData[index].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index].rGBTransferFunction;
  };

  // Set the scalar opacity of a volume to a transfer function
  publicAPI.setScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.componentData[index].scalarOpacity !== func) {
      model.componentData[index].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };

  // Get the scalar opacity transfer function. Create one if none set.
  publicAPI.getScalarOpacity = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.componentData[index].scalarOpacity === null) {
      model.componentData[index].scalarOpacity = PiecewiseFunction/* default.newInstance */.Ay.newInstance();
      model.componentData[index].scalarOpacity.addPoint(0, 1.0);
      model.componentData[index].scalarOpacity.addPoint(1024, 1.0);
      publicAPI.modified();
    }
    return model.componentData[index].scalarOpacity;
  };
  publicAPI.setComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return false;
    }
    const val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function () {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro('Invalid index');
      return 0.0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = () => publicAPI.setInterpolationType(InterpolationType.NEAREST);
  publicAPI.setInterpolationTypeToLinear = () => publicAPI.setInterpolationType(InterpolationType.LINEAR);
  publicAPI.setInterpolationTypeToFastLinear = () => publicAPI.setInterpolationType(InterpolationType.FAST_LINEAR);
  publicAPI.getInterpolationTypeAsString = () => macros2.m.enumToString(InterpolationType, model.interpolationType);
  const sets = ['useGradientOpacity', 'scalarOpacityUnitDistance', 'gradientOpacityMinimumValue', 'gradientOpacityMinimumOpacity', 'gradientOpacityMaximumValue', 'gradientOpacityMaximumOpacity', 'opacityMode', 'forceNearestInterpolation'];
  sets.forEach(val => {
    const cap = macros2.m.capitalize(val);
    publicAPI[`set${cap}`] = (index, value) => {
      if (model.componentData[index][`${val}`] !== value) {
        model.componentData[index][`${val}`] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  const gets = ['useGradientOpacity', 'scalarOpacityUnitDistance', 'gradientOpacityMinimumValue', 'gradientOpacityMinimumOpacity', 'gradientOpacityMaximumValue', 'gradientOpacityMaximumOpacity', 'opacityMode', 'forceNearestInterpolation'];
  gets.forEach(val => {
    const cap = macros2.m.capitalize(val);
    publicAPI[`get${cap}`] = index => model.componentData[index][`${val}`];
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  colorMixPreset: null,
  independentComponents: true,
  interpolationType: InterpolationType.FAST_LINEAR,
  shade: false,
  ambient: 0.1,
  diffuse: 0.7,
  specular: 0.2,
  specularPower: 10.0,
  useLabelOutline: false,
  labelOutlineThickness: [1],
  labelOutlineOpacity: 1.0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (let i = 0; i < VTK_MAX_VRCOMP; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1.0,
        opacityMode: OpacityMode.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0.0,
        gradientOpacityMaximumValue: 1.0,
        gradientOpacityMaximumOpacity: 1.0,
        useGradientOpacity: false,
        componentWeight: 1.0,
        forceNearestInterpolation: false
      });
    }
  }
  macros2.m.setGet(publicAPI, model, ['colorMixPreset', 'independentComponents', 'interpolationType', 'shade', 'ambient', 'diffuse', 'specular', 'specularPower', 'useLabelOutline', 'labelOutlineOpacity']);
  macros2.m.setGetArray(publicAPI, model, ['labelOutlineThickness']);

  // Object methods
  vtkVolumeProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkVolumeProperty');

// ----------------------------------------------------------------------------

var vtkVolumeProperty$1 = {
  newInstance,
  extend,
  ...Constants/* default */.Ay
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js






const {
  vtkDebugMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkVolume methods
// ----------------------------------------------------------------------------

function vtkVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolume');
  publicAPI.getVolumes = () => publicAPI;
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.map(x => x);
      const bbox = [];
      BoundingBox/* default.getCorners */.Ay.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      esm/* mat4.transpose */.pB.transpose(tmp4, model.matrix);
      bbox.forEach(pt => esm/* vec3.transformMat4 */.eR.transformMat4(pt, pt, tmp4));

      /* eslint-disable no-multi-assign */
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      /* eslint-enable no-multi-assign */
      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Volume_DEFAULT_VALUES = {
  mapper: null,
  property: null,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function Volume_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Volume_DEFAULT_VALUES, initialValues);

  // Inheritance
  Prop3D/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  macros2.m.obj(model.boundsMTime);

  // Build VTK API
  macros2.m.set(publicAPI, model, ['property']);
  macros2.m.setGet(publicAPI, model, ['mapper']);
  macros2.m.getArray(publicAPI, model, ['bounds'], 6);

  // Object methods
  vtkVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Volume_newInstance = macros2.m.newInstance(Volume_extend, 'vtkVolume');

// ----------------------------------------------------------------------------

var vtkVolume$1 = {
  newInstance: Volume_newInstance,
  extend: Volume_extend
};



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js + 10 modules
var volumeLoader = __webpack_require__(87142);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeMapper.js
var createVolumeMapper = __webpack_require__(92099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setDefaultVolumeVOI.js
var setDefaultVolumeVOI = __webpack_require__(89821);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeActor.js






async function createVolumeActor(props, element, viewportId, suppressEvents = false) {
    const { volumeId, callback, blendMode } = props;
    const imageVolume = await (0,volumeLoader.loadVolume)(volumeId);
    if (!imageVolume) {
        throw new Error(`imageVolume with id: ${imageVolume.volumeId} does not exist`);
    }
    const { imageData, vtkOpenGLTexture } = imageVolume;
    const volumeMapper = (0,createVolumeMapper/* default */.A)(imageData, vtkOpenGLTexture);
    if (blendMode) {
        volumeMapper.setBlendMode(blendMode);
    }
    const volumeActor = vtkVolume$1.newInstance();
    volumeActor.setMapper(volumeMapper);
    const { numberOfComponents } = imageData.get('numberOfComponents');
    const volumeProperty = volumeActor.getProperty();
    volumeProperty.set({ viewportId: viewportId });
    if (numberOfComponents === 3) {
        volumeActor.getProperty().setIndependentComponents(false);
    }
    await (0,setDefaultVolumeVOI/* default */.A)(volumeActor, imageVolume);
    if (callback) {
        callback({ volumeActor, volumeId });
    }
    if (!suppressEvents) {
        triggerVOIModified(element, viewportId, volumeActor, volumeId);
    }
    return volumeActor;
}
function triggerVOIModified(element, viewportId, volumeActor, volumeId) {
    const voiRange = volumeActor
        .getProperty()
        .getRGBTransferFunction(0)
        .getRange();
    const voiModifiedEventDetail = {
        viewportId,
        range: {
            lower: voiRange[0],
            upper: voiRange[1],
        },
        volumeId,
    };
    (0,triggerEvent/* default */.A)(element, enums.Events.VOI_MODIFIED, voiModifiedEventDetail);
}
/* harmony default export */ const helpers_createVolumeActor = (createVolumeActor);


/***/ }),

/***/ 92099:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createVolumeMapper),
/* harmony export */   h: () => (/* binding */ convertMapperToNotSharedMapper)
/* harmony export */ });
/* harmony import */ var _vtkClasses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42295);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26896);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_VolumeMapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53387);
/* harmony import */ var _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42008);




function createVolumeMapper(imageData, vtkOpenGLTexture) {
    const volumeMapper = _vtkClasses__WEBPACK_IMPORTED_MODULE_0__/* .vtkSharedVolumeMapper */ .wu.newInstance();
    if ((0,_init__WEBPACK_IMPORTED_MODULE_1__/* .getConfiguration */ .D0)().rendering.preferSizeOverAccuracy) {
        volumeMapper.setPreferSizeOverAccuracy(true);
    }
    volumeMapper.setInputData(imageData);
    const spacing = imageData.getSpacing();
    const sampleDistance = (spacing[0] + spacing[1] + spacing[2]) / 6;
    volumeMapper.setMaximumSamplesPerRay(4000);
    volumeMapper.setSampleDistance(sampleDistance);
    volumeMapper.setScalarTexture(vtkOpenGLTexture);
    return volumeMapper;
}
function convertMapperToNotSharedMapper(sharedMapper) {
    const volumeMapper = _kitware_vtk_js_Rendering_Core_VolumeMapper__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    volumeMapper.setBlendMode(sharedMapper.getBlendMode());
    const imageData = sharedMapper.getInputData();
    const { voxelManager } = imageData.get('voxelManager');
    const values = voxelManager.getCompleteScalarDataArray();
    const scalarArray = _kitware_vtk_js_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        name: `Pixels`,
        values,
    });
    imageData.getPointData().setScalars(scalarArray);
    volumeMapper.setInputData(imageData);
    volumeMapper.setMaximumSamplesPerRay(sharedMapper.getMaximumSamplesPerRay());
    volumeMapper.setSampleDistance(sharedMapper.getSampleDistance());
    return volumeMapper;
}


/***/ }),

/***/ 30135:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   Nw: () => (/* binding */ createCanvas),
/* harmony export */   oI: () => (/* binding */ getOrCreateCanvas),
/* harmony export */   p8: () => (/* binding */ EPSILON)
/* harmony export */ });
/* unused harmony exports createViewportElement, setCanvasCreator */
const VIEWPORT_ELEMENT = 'viewport-element';
const CANVAS_CSS_CLASS = 'cornerstone-canvas';
const EPSILON = 1e-4;
let canvasCreator;
function createCanvas(element, width = 512, height = 512) {
    const canvas = canvasCreator
        ? canvasCreator(width, height)
        : document.createElement('canvas');
    if (!element) {
        return canvas;
    }
    canvas.style.position = 'absolute';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.imageRendering = 'pixelated';
    canvas.classList.add(CANVAS_CSS_CLASS);
    element.appendChild(canvas);
    return canvas;
}
function createViewportElement(element) {
    const div = document.createElement('div');
    div.style.position = 'relative';
    div.style.width = '100%';
    div.style.height = '100%';
    div.style.overflow = 'hidden';
    div.classList.add(VIEWPORT_ELEMENT);
    element.appendChild(div);
    return div;
}
function setCanvasCreator(canvasCreatorArg) {
    canvasCreator = canvasCreatorArg;
}
function getOrCreateCanvas(element) {
    const canvasSelector = `canvas.${CANVAS_CSS_CLASS}`;
    const viewportElement = `div.${VIEWPORT_ELEMENT}`;
    const internalDiv = element.querySelector(viewportElement) || createViewportElement(element);
    const existingCanvas = internalDiv.querySelector(canvasSelector);
    if (existingCanvas) {
        return existingCanvas;
    }
    const canvas = createCanvas(internalDiv);
    const rect = internalDiv.getBoundingClientRect();
    const devicePixelRatio = window.devicePixelRatio || 1;
    const width = Math.ceil(rect.width * devicePixelRatio);
    const height = Math.ceil(rect.height * devicePixelRatio);
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateCanvas);


/***/ }),

/***/ 40661:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ge: () => (/* reexport */ helpers_addImageSlicesToViewports),
  x: () => (/* reexport */ helpers_addVolumesToViewports),
  oI: () => (/* reexport */ getOrCreateCanvas/* getOrCreateCanvas */.oI),
  A7: () => (/* reexport */ helpers_setVolumesForViewports)
});

// UNUSED EXPORTS: EPSILON, createCanvas, createViewportElement, createVolumeActor, createVolumeMapper, setCanvasCreator, volumeNewImageEventDispatcher

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeActor.js + 2 modules
var createVolumeActor = __webpack_require__(61640);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/createVolumeMapper.js
var createVolumeMapper = __webpack_require__(92099);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
var BaseVolumeViewport = __webpack_require__(46347);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/setVolumesForViewports.js

async function setVolumesForViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {
    viewportIds.forEach((viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!(viewport instanceof BaseVolumeViewport/* default */.A)) {
            throw new Error('setVolumesForViewports only supports VolumeViewport and VolumeViewport3D');
        }
    });
    const setVolumePromises = viewportIds.map(async (viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        await viewport.setVolumes(volumeInputs, immediateRender, suppressEvents);
    });
    await Promise.all(setVolumePromises);
    return;
}
/* harmony default export */ const helpers_setVolumesForViewports = (setVolumesForViewports);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addVolumesToViewports.js

async function addVolumesToViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {
    for (const viewportId of viewportIds) {
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!(viewport instanceof BaseVolumeViewport/* default */.A)) {
            console.warn(`Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`);
            return;
        }
    }
    const addVolumePromises = viewportIds.map(async (viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);
    });
    await Promise.all(addVolumePromises);
    return;
}
/* harmony default export */ const helpers_addVolumesToViewports = (addVolumesToViewports);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/volumeNewImageEventDispatcher.js
var volumeNewImageEventDispatcher = __webpack_require__(90740);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addImageSlicesToViewports.js
function addImageSlicesToViewports(renderingEngine, stackInputs, viewportIds) {
    for (const viewportId of viewportIds) {
        const viewport = renderingEngine.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!viewport.addImages) {
            console.warn(`Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`);
            return;
        }
    }
    viewportIds.forEach((viewportId) => {
        const viewport = renderingEngine.getViewport(viewportId);
        viewport.addImages(stackInputs);
    });
}
/* harmony default export */ const helpers_addImageSlicesToViewports = (addImageSlicesToViewports);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js










/***/ }),

/***/ 89821:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _loaders_imageLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80068);
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74876);
/* harmony import */ var _utilities_windowLevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68136);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71851);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49038);





const PRIORITY = 0;
const REQUEST_TYPE = _enums__WEBPACK_IMPORTED_MODULE_3__.RequestType.Prefetch;
async function setDefaultVolumeVOI(volumeActor, imageVolume) {
    let voi = getVOIFromMetadata(imageVolume);
    if (!voi && imageVolume.imageIds.length) {
        voi = await getVOIFromMiddleSliceMinMax(imageVolume);
        voi = handlePreScaledVolume(imageVolume, voi);
    }
    if ((voi.lower === 0 && voi.upper === 0) ||
        voi.lower === undefined ||
        voi.upper === undefined) {
        return;
    }
    volumeActor
        .getProperty()
        .getRGBTransferFunction(0)
        .setMappingRange(voi.lower, voi.upper);
}
function handlePreScaledVolume(imageVolume, voi) {
    const imageIds = imageVolume.imageIds;
    const imageIdIndex = Math.floor(imageIds.length / 2);
    const imageId = imageIds[imageIdIndex];
    const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('generalSeriesModule', imageId) || {};
    if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {
        return {
            lower: 0,
            upper: 5,
        };
    }
    return voi;
}
function getVOIFromMetadata(imageVolume) {
    const { imageIds, metadata } = imageVolume;
    let voi;
    if (imageIds?.length) {
        const imageIdIndex = Math.floor(imageIds.length / 2);
        const imageId = imageIds[imageIdIndex];
        const voiLutModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('voiLutModule', imageId);
        if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {
            if (voiLutModule?.voiLUTFunction) {
                voi = {};
                voi.voiLUTFunction = voiLutModule?.voiLUTFunction;
            }
            const { windowWidth, windowCenter } = voiLutModule;
            const width = Array.isArray(windowWidth) ? windowWidth[0] : windowWidth;
            const center = Array.isArray(windowCenter)
                ? windowCenter[0]
                : windowCenter;
            if (width !== 0) {
                voi = { windowWidth: width, windowCenter: center };
            }
        }
    }
    else {
        voi = metadata.voiLut[0];
    }
    if (voi && (voi.windowWidth !== 0 || voi.windowCenter !== 0)) {
        const { lower, upper } = _utilities_windowLevel__WEBPACK_IMPORTED_MODULE_2__.toLowHighRange(Number(voi.windowWidth), Number(voi.windowCenter), voi.voiLUTFunction);
        return { lower, upper };
    }
    return undefined;
}
async function getVOIFromMiddleSliceMinMax(imageVolume) {
    const { imageIds } = imageVolume;
    const imageIdIndex = Math.floor(imageIds.length / 2);
    const imageId = imageVolume.imageIds[imageIdIndex];
    const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('generalSeriesModule', imageId) || {};
    const { modality } = generalSeriesModule;
    const modalityLutModule = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('modalityLutModule', imageId) || {};
    const scalingParameters = {
        rescaleSlope: modalityLutModule.rescaleSlope,
        rescaleIntercept: modalityLutModule.rescaleIntercept,
        modality,
    };
    let scalingParametersToUse;
    if (modality === 'PT') {
        const suvFactor = _metaData__WEBPACK_IMPORTED_MODULE_1__.get('scalingModule', imageId);
        if (suvFactor) {
            scalingParametersToUse = {
                ...scalingParameters,
                suvbw: suvFactor.suvbw,
            };
        }
    }
    const options = {
        priority: PRIORITY,
        requestType: REQUEST_TYPE,
        preScale: {
            scalingParameters: scalingParametersToUse,
        },
    };
    let image = _cache_cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getImage(imageId);
    if (!imageVolume.referencedImageIds?.length) {
        image = await (0,_loaders_imageLoader__WEBPACK_IMPORTED_MODULE_0__.loadAndCacheImage)(imageId, { ...options, ignoreCache: true });
    }
    let { min, max } = image.voxelManager.getMinMax();
    if (min?.length > 1) {
        min = Math.min(...min);
        max = Math.max(...max);
    }
    return {
        lower: min,
        upper: max,
    };
}
function _isCurrentImagePTPrescaled(modality, imageVolume) {
    if (modality !== 'PT' || !imageVolume.isPreScaled) {
        return false;
    }
    if (!imageVolume.scaling?.PT.suvbw) {
        return false;
    }
    return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setDefaultVolumeVOI);


/***/ }),

/***/ 90740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   g: () => (/* binding */ resetVolumeNewImageState)
/* harmony export */ });
/* harmony import */ var _utilities_getImageSliceDataForVolumeViewport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47476);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69372);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71851);
/* harmony import */ var _getRenderingEngine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39536);




const state = {};
function resetVolumeNewImageState(viewportId) {
    if (state[viewportId] !== undefined) {
        delete state[viewportId];
    }
}
function volumeNewImageEventDispatcher(cameraEvent) {
    const { renderingEngineId, viewportId } = cameraEvent.detail;
    const renderingEngine = (0,_getRenderingEngine__WEBPACK_IMPORTED_MODULE_3__/* .getRenderingEngine */ .lD)(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    if (!('setVolumes' in viewport)) {
        throw new Error(`volumeNewImageEventDispatcher: viewport does not have setVolumes method`);
    }
    if (state[viewport.id] === undefined) {
        state[viewport.id] = 0;
    }
    const sliceData = (0,_utilities_getImageSliceDataForVolumeViewport__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(viewport);
    if (!sliceData) {
        console.warn(`volumeNewImageEventDispatcher: sliceData is undefined for viewport ${viewport.id}`);
        return;
    }
    const { numberOfSlices, imageIndex } = sliceData;
    if (state[viewport.id] === imageIndex) {
        return;
    }
    state[viewport.id] = imageIndex;
    const eventDetail = {
        imageIndex,
        viewportId,
        renderingEngineId,
        numberOfSlices,
    };
    (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element, _enums__WEBPACK_IMPORTED_MODULE_2__.Events.VOLUME_NEW_IMAGE, eventDetail);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (volumeNewImageEventDispatcher);


/***/ }),

/***/ 56706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hS: () => (/* reexport */ StackViewport/* default */.A),
  PX: () => (/* reexport */ VolumeViewport/* default */.A),
  Ay: () => (/* binding */ esm_RenderingEngine)
});

// UNUSED EXPORTS: EPSILON, RenderingEngine, VolumeViewport3D, addImageSlicesToViewports, addVolumesToViewports, createCanvas, createViewportElement, createVolumeActor, createVolumeMapper, getOrCreateCanvas, getRenderingEngine, setCanvasCreator, setVolumesForViewports, volumeNewImageEventDispatcher

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events = __webpack_require__(32643);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/renderingEngineCache.js
var renderingEngineCache = __webpack_require__(5862);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/index.js + 26 modules
var vtkClasses = __webpack_require__(42295);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/ViewportType.js
var ViewportType = __webpack_require__(41864);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport.js + 1 modules
var VolumeViewport = __webpack_require__(94155);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/BaseVolumeViewport.js
var BaseVolumeViewport = __webpack_require__(46347);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/StackViewport.js + 12 modules
var StackViewport = __webpack_require__(58165);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VolumeViewport3D.js
var VolumeViewport3D = __webpack_require__(40893);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/VideoViewport.js + 3 modules
var VideoViewport = __webpack_require__(32501);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/WSIViewport.js + 1 modules
var WSIViewport = __webpack_require__(81466);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeToViewportClass.js






const viewportTypeToViewportClass = {
    [ViewportType/* default */.A.ORTHOGRAPHIC]: VolumeViewport/* default */.A,
    [ViewportType/* default */.A.PERSPECTIVE]: VolumeViewport/* default */.A,
    [ViewportType/* default */.A.STACK]: StackViewport/* default */.A,
    [ViewportType/* default */.A.VOLUME_3D]: VolumeViewport3D/* default */.A,
    [ViewportType/* default */.A.VIDEO]: VideoViewport/* default */.A,
    [ViewportType/* default */.A.WHOLE_SLIDE]: WSIViewport/* default */.A,
};
/* harmony default export */ const helpers_viewportTypeToViewportClass = (viewportTypeToViewportClass);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/viewportTypeUsesCustomRenderingPipeline.js

function viewportTypeUsesCustomRenderingPipeline(viewportType) {
    return helpers_viewportTypeToViewportClass[viewportType].useCustomRenderingPipeline;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/getOrCreateCanvas.js
var getOrCreateCanvas = __webpack_require__(30135);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 2 modules
var init = __webpack_require__(26896);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/RenderingEngine.js
















const VIEWPORT_MIN_SIZE = 2;
class RenderingEngine {
    constructor(id) {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this.renderFrameOfReference = (FrameOfReferenceUID) => {
            const viewports = this._getViewportsAsArray();
            const viewportIdsWithSameFrameOfReferenceUID = viewports.map((vp) => {
                if (vp.getFrameOfReferenceUID() === FrameOfReferenceUID) {
                    return vp.id;
                }
            });
            this.renderViewports(viewportIdsWithSameFrameOfReferenceUID);
        };
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            if (!this.useCPURendering) {
                this.performVtkDrawCall();
            }
            const viewports = this._getViewportsAsArray();
            const eventDetailArray = [];
            for (let i = 0; i < viewports.length; i++) {
                const viewport = viewports[i];
                if (this._needsRender.has(viewport.id)) {
                    const eventDetail = this.renderViewportUsingCustomOrVtkPipeline(viewport);
                    eventDetailArray.push(eventDetail);
                    viewport.setRendered();
                    this._needsRender.delete(viewport.id);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            eventDetailArray.forEach((eventDetail) => {
                if (!eventDetail?.element) {
                    return;
                }
                (0,triggerEvent/* default */.A)(eventDetail.element, Events/* default */.A.IMAGE_RENDERED, eventDetail);
            });
        };
        this.id = id ? id : (0,uuidv4/* default */.A)();
        this.useCPURendering = (0,init/* getShouldUseCPURendering */.LH)();
        renderingEngineCache/* default */.A.set(this);
        if (!(0,init/* isCornerstoneInitialized */.Dh)()) {
            throw new Error('@cornerstonejs/core is not initialized, run init() first');
        }
        if (!this.useCPURendering) {
            this.offscreenMultiRenderWindow =
                vtkClasses/* vtkOffscreenMultiRenderWindow */.Ig.newInstance();
            this.offScreenCanvasContainer = document.createElement('div');
            this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer);
        }
        this._viewports = new Map();
        this.hasBeenDestroyed = false;
    }
    enableElement(viewportInputEntry) {
        const viewportInput = this._normalizeViewportInputEntry(viewportInputEntry);
        this._throwIfDestroyed();
        const { element, viewportId } = viewportInput;
        if (!element) {
            throw new Error('No element provided');
        }
        const viewport = this.getViewport(viewportId);
        if (viewport) {
            this.disableElement(viewportId);
        }
        const { type } = viewportInput;
        const viewportUsesCustomRenderingPipeline = viewportTypeUsesCustomRenderingPipeline(type);
        if (!this.useCPURendering && !viewportUsesCustomRenderingPipeline) {
            this.enableVTKjsDrivenViewport(viewportInput);
        }
        else {
            this.addCustomViewport(viewportInput);
        }
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(element);
        const { background } = viewportInput.defaultOptions;
        this.fillCanvasWithBackgroundColor(canvas, background);
    }
    disableElement(viewportId) {
        this._throwIfDestroyed();
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            console.warn(`viewport ${viewportId} does not exist`);
            return;
        }
        this._resetViewport(viewport);
        if (!viewportTypeUsesCustomRenderingPipeline(viewport.type) &&
            !this.useCPURendering) {
            this.offscreenMultiRenderWindow.removeRenderer(viewportId);
        }
        this._removeViewport(viewportId);
        viewport.isDisabled = true;
        this._needsRender.delete(viewportId);
        const viewports = this.getViewports();
        if (!viewports.length) {
            this._clearAnimationFrame();
        }
    }
    setViewports(publicViewportInputEntries) {
        const viewportInputEntries = this._normalizeViewportInputEntries(publicViewportInputEntries);
        this._throwIfDestroyed();
        this._reset();
        const vtkDrivenViewportInputEntries = [];
        const customRenderingViewportInputEntries = [];
        viewportInputEntries.forEach((vpie) => {
            if (!this.useCPURendering &&
                !viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
                vtkDrivenViewportInputEntries.push(vpie);
            }
            else {
                customRenderingViewportInputEntries.push(vpie);
            }
        });
        this.setVtkjsDrivenViewports(vtkDrivenViewportInputEntries);
        this.setCustomViewports(customRenderingViewportInputEntries);
        viewportInputEntries.forEach((vp) => {
            const canvas = (0,getOrCreateCanvas/* default */.Ay)(vp.element);
            const { background } = vp.defaultOptions;
            this.fillCanvasWithBackgroundColor(canvas, background);
        });
    }
    resize(immediate = true, keepCamera = true) {
        this._throwIfDestroyed();
        const viewports = this._getViewportsAsArray();
        const vtkDrivenViewports = [];
        const customRenderingViewports = [];
        viewports.forEach((vpie) => {
            if (!viewportTypeUsesCustomRenderingPipeline(vpie.type)) {
                vtkDrivenViewports.push(vpie);
            }
            else {
                customRenderingViewports.push(vpie);
            }
        });
        if (vtkDrivenViewports.length) {
            this._resizeVTKViewports(vtkDrivenViewports, keepCamera, immediate);
        }
        if (customRenderingViewports.length) {
            this._resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera, immediate);
        }
    }
    getViewport(viewportId) {
        return this._viewports?.get(viewportId);
    }
    getViewports() {
        this._throwIfDestroyed();
        return this._getViewportsAsArray();
    }
    getStackViewport(viewportId) {
        this._throwIfDestroyed();
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            throw new Error(`Viewport with Id ${viewportId} does not exist`);
        }
        if (!(viewport instanceof StackViewport/* default */.A)) {
            throw new Error(`Viewport with Id ${viewportId} is not a StackViewport.`);
        }
        return viewport;
    }
    getStackViewports() {
        this._throwIfDestroyed();
        const viewports = this.getViewports();
        return viewports.filter((vp) => vp instanceof StackViewport/* default */.A);
    }
    getVolumeViewports() {
        this._throwIfDestroyed();
        const viewports = this.getViewports();
        const isVolumeViewport = (viewport) => {
            return viewport instanceof BaseVolumeViewport/* default */.A;
        };
        return viewports.filter(isVolumeViewport);
    }
    render() {
        const viewports = this.getViewports();
        const viewportIds = viewports.map((vp) => vp.id);
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderViewports(viewportIds) {
        this._setViewportsToBeRenderedNextFrame(viewportIds);
    }
    renderViewport(viewportId) {
        this._setViewportsToBeRenderedNextFrame([viewportId]);
    }
    destroy() {
        if (this.hasBeenDestroyed) {
            return;
        }
        if (!this.useCPURendering) {
            const viewports = this._getViewportsAsArray();
            viewports.forEach((vp) => {
                this.offscreenMultiRenderWindow.removeRenderer(vp.id);
            });
            this.offscreenMultiRenderWindow.delete();
            delete this.offscreenMultiRenderWindow;
        }
        this._reset();
        renderingEngineCache/* default */.A.delete(this.id);
        this.hasBeenDestroyed = true;
    }
    fillCanvasWithBackgroundColor(canvas, backgroundColor) {
        const ctx = canvas.getContext('2d');
        let fillStyle;
        if (backgroundColor) {
            const rgb = backgroundColor.map((f) => Math.floor(255 * f));
            fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }
        else {
            fillStyle = 'black';
        }
        ctx.fillStyle = fillStyle;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    _normalizeViewportInputEntry(viewportInputEntry) {
        const { type, defaultOptions } = viewportInputEntry;
        let options = defaultOptions;
        if (!options || Object.keys(options).length === 0) {
            options = {
                background: [0, 0, 0],
                orientation: null,
                displayArea: null,
            };
            if (type === ViewportType/* default */.A.ORTHOGRAPHIC) {
                options = {
                    ...options,
                    orientation: enums.OrientationAxis.AXIAL,
                };
            }
        }
        return {
            ...viewportInputEntry,
            defaultOptions: options,
        };
    }
    _normalizeViewportInputEntries(viewportInputEntries) {
        const normalizedViewportInputs = [];
        viewportInputEntries.forEach((viewportInput) => {
            normalizedViewportInputs.push(this._normalizeViewportInputEntry(viewportInput));
        });
        return normalizedViewportInputs;
    }
    _resizeUsingCustomResizeHandler(customRenderingViewports, keepCamera = true, immediate = true) {
        customRenderingViewports.forEach((vp) => {
            if (typeof vp.resize === 'function') {
                vp.resize();
            }
        });
        customRenderingViewports.forEach((vp) => {
            const prevCamera = vp.getCamera();
            vp.resetCamera();
            if (keepCamera) {
                vp.setCamera(prevCamera);
            }
        });
        if (immediate) {
            this.render();
        }
    }
    _resizeVTKViewports(vtkDrivenViewports, keepCamera = true, immediate = true) {
        const canvasesDrivenByVtkJs = vtkDrivenViewports.map((vp) => {
            return (0,getOrCreateCanvas/* default */.Ay)(vp.element);
        });
        canvasesDrivenByVtkJs.forEach((canvas) => {
            const devicePixelRatio = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;
        });
        if (canvasesDrivenByVtkJs.length) {
            const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
            this._resize(vtkDrivenViewports, offScreenCanvasWidth, offScreenCanvasHeight);
        }
        vtkDrivenViewports.forEach((vp) => {
            const prevCamera = vp.getCamera();
            const rotation = vp.getRotation();
            const { flipHorizontal } = prevCamera;
            vp.resetCameraForResize();
            const displayArea = vp.getDisplayArea();
            if (keepCamera) {
                if (displayArea) {
                    if (flipHorizontal) {
                        vp.setCamera({ flipHorizontal });
                    }
                    if (rotation) {
                        vp.setViewPresentation({ rotation });
                    }
                }
                else {
                    vp.setCamera(prevCamera);
                }
            }
        });
        if (immediate) {
            this.render();
        }
    }
    enableVTKjsDrivenViewport(viewportInputEntry) {
        const viewports = this._getViewportsAsArray();
        const viewportsDrivenByVtkJs = viewports.filter((vp) => viewportTypeUsesCustomRenderingPipeline(vp.type) === false);
        const canvasesDrivenByVtkJs = viewportsDrivenByVtkJs.map((vp) => vp.canvas);
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(viewportInputEntry.element);
        canvasesDrivenByVtkJs.push(canvas);
        const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(canvasesDrivenByVtkJs);
        const xOffset = this._resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight);
        const internalViewportEntry = { ...viewportInputEntry, canvas };
        this.addVtkjsDrivenViewport(internalViewportEntry, {
            offScreenCanvasWidth,
            offScreenCanvasHeight,
            xOffset,
        });
    }
    _removeViewport(viewportId) {
        const viewport = this.getViewport(viewportId);
        if (!viewport) {
            console.warn(`viewport ${viewportId} does not exist`);
            return;
        }
        this._viewports.delete(viewportId);
    }
    addVtkjsDrivenViewport(viewportInputEntry, offscreenCanvasProperties) {
        const { element, canvas, viewportId, type, defaultOptions } = viewportInputEntry;
        element.tabIndex = -1;
        const { offScreenCanvasWidth, offScreenCanvasHeight, xOffset } = offscreenCanvasProperties;
        const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight, } = this._getViewportCoordsOnOffScreenCanvas(viewportInputEntry, offScreenCanvasWidth, offScreenCanvasHeight, xOffset);
        this.offscreenMultiRenderWindow.addRenderer({
            viewport: [
                sxStartDisplayCoords,
                syStartDisplayCoords,
                sxEndDisplayCoords,
                syEndDisplayCoords,
            ],
            id: viewportId,
            background: defaultOptions.background
                ? defaultOptions.background
                : [0, 0, 0],
        });
        const viewportInput = {
            id: viewportId,
            element,
            renderingEngineId: this.id,
            type,
            canvas,
            sx,
            sy,
            sWidth,
            sHeight,
            defaultOptions: defaultOptions || {},
        };
        let viewport;
        if (type === ViewportType/* default */.A.STACK) {
            viewport = new StackViewport/* default */.A(viewportInput);
        }
        else if (type === ViewportType/* default */.A.ORTHOGRAPHIC ||
            type === ViewportType/* default */.A.PERSPECTIVE) {
            viewport = new VolumeViewport/* default */.A(viewportInput);
        }
        else if (type === ViewportType/* default */.A.VOLUME_3D) {
            viewport = new VolumeViewport3D/* default */.A(viewportInput);
        }
        else {
            throw new Error(`Viewport Type ${type} is not supported`);
        }
        this._viewports.set(viewportId, viewport);
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId: this.id,
        };
        if (!viewport.suppressEvents) {
            (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_ENABLED, eventDetail);
        }
    }
    addCustomViewport(viewportInputEntry) {
        const { element, viewportId, type, defaultOptions } = viewportInputEntry;
        element.tabIndex = -1;
        const canvas = (0,getOrCreateCanvas/* default */.Ay)(element);
        const { clientWidth, clientHeight } = canvas;
        if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
            canvas.width = clientWidth;
            canvas.height = clientHeight;
        }
        const viewportInput = {
            id: viewportId,
            renderingEngineId: this.id,
            element,
            type,
            canvas,
            sx: 0,
            sy: 0,
            sWidth: clientWidth,
            sHeight: clientHeight,
            defaultOptions: defaultOptions || {},
        };
        const ViewportType = helpers_viewportTypeToViewportClass[type];
        const viewport = new ViewportType(viewportInput);
        this._viewports.set(viewportId, viewport);
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId: this.id,
        };
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_ENABLED, eventDetail);
    }
    setCustomViewports(viewportInputEntries) {
        viewportInputEntries.forEach((vpie) => {
            this.addCustomViewport(vpie);
        });
    }
    setVtkjsDrivenViewports(viewportInputEntries) {
        if (viewportInputEntries.length) {
            const vtkDrivenCanvases = viewportInputEntries.map((vp) => (0,getOrCreateCanvas/* default */.Ay)(vp.element));
            vtkDrivenCanvases.forEach((canvas) => {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
            });
            const { offScreenCanvasWidth, offScreenCanvasHeight } = this._resizeOffScreenCanvas(vtkDrivenCanvases);
            let xOffset = 0;
            for (let i = 0; i < viewportInputEntries.length; i++) {
                const vtkDrivenViewportInputEntry = viewportInputEntries[i];
                const canvas = vtkDrivenCanvases[i];
                const internalViewportEntry = {
                    ...vtkDrivenViewportInputEntry,
                    canvas,
                };
                this.addVtkjsDrivenViewport(internalViewportEntry, {
                    offScreenCanvasWidth,
                    offScreenCanvasHeight,
                    xOffset,
                });
                xOffset += canvas.width;
            }
        }
    }
    _resizeOffScreenCanvas(canvasesDrivenByVtkJs) {
        const { offScreenCanvasContainer, offscreenMultiRenderWindow } = this;
        const offScreenCanvasHeight = Math.max(...canvasesDrivenByVtkJs.map((canvas) => canvas.height));
        let offScreenCanvasWidth = 0;
        canvasesDrivenByVtkJs.forEach((canvas) => {
            offScreenCanvasWidth += canvas.width;
        });
        offScreenCanvasContainer.width = offScreenCanvasWidth;
        offScreenCanvasContainer.height = offScreenCanvasHeight;
        offscreenMultiRenderWindow.resize();
        return { offScreenCanvasWidth, offScreenCanvasHeight };
    }
    _resize(viewportsDrivenByVtkJs, offScreenCanvasWidth, offScreenCanvasHeight) {
        let _xOffset = 0;
        for (let i = 0; i < viewportsDrivenByVtkJs.length; i++) {
            const viewport = viewportsDrivenByVtkJs[i];
            const { sxStartDisplayCoords, syStartDisplayCoords, sxEndDisplayCoords, syEndDisplayCoords, sx, sy, sWidth, sHeight, } = this._getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset);
            _xOffset += viewport.canvas.width;
            viewport.sx = sx;
            viewport.sy = sy;
            viewport.sWidth = sWidth;
            viewport.sHeight = sHeight;
            const renderer = this.offscreenMultiRenderWindow.getRenderer(viewport.id);
            renderer.setViewport([
                sxStartDisplayCoords,
                syStartDisplayCoords,
                sxEndDisplayCoords,
                syEndDisplayCoords,
            ]);
        }
        return _xOffset;
    }
    _getViewportCoordsOnOffScreenCanvas(viewport, offScreenCanvasWidth, offScreenCanvasHeight, _xOffset) {
        const { canvas } = viewport;
        const { width: sWidth, height: sHeight } = canvas;
        const sx = _xOffset;
        const sy = 0;
        const sxStartDisplayCoords = sx / offScreenCanvasWidth;
        const syStartDisplayCoords = sy + (offScreenCanvasHeight - sHeight) / offScreenCanvasHeight;
        const sWidthDisplayCoords = sWidth / offScreenCanvasWidth;
        const sHeightDisplayCoords = sHeight / offScreenCanvasHeight;
        return {
            sxStartDisplayCoords,
            syStartDisplayCoords,
            sxEndDisplayCoords: sxStartDisplayCoords + sWidthDisplayCoords,
            syEndDisplayCoords: syStartDisplayCoords + sHeightDisplayCoords,
            sx,
            sy,
            sWidth,
            sHeight,
        };
    }
    _getViewportsAsArray() {
        return Array.from(this._viewports.values());
    }
    _setViewportsToBeRenderedNextFrame(viewportIds) {
        viewportIds.forEach((viewportId) => {
            this._needsRender.add(viewportId);
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && !this._animationFrameSet) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    performVtkDrawCall() {
        const { offscreenMultiRenderWindow } = this;
        const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
        const renderers = offscreenMultiRenderWindow.getRenderers();
        if (!renderers.length) {
            return;
        }
        for (let i = 0; i < renderers.length; i++) {
            const { renderer, id } = renderers[i];
            if (this._needsRender.has(id)) {
                renderer.setDraw(true);
            }
            else {
                renderer.setDraw(false);
            }
        }
        renderWindow.render();
        for (let i = 0; i < renderers.length; i++) {
            renderers[i].renderer.setDraw(false);
        }
    }
    renderViewportUsingCustomOrVtkPipeline(viewport) {
        let eventDetail;
        if (viewport.sWidth < VIEWPORT_MIN_SIZE ||
            viewport.sHeight < VIEWPORT_MIN_SIZE) {
            console.warn('Viewport is too small', viewport.sWidth, viewport.sHeight);
            return;
        }
        if (viewportTypeUsesCustomRenderingPipeline(viewport.type) === true) {
            eventDetail =
                viewport.customRenderViewportToCanvas();
        }
        else {
            if (this.useCPURendering) {
                throw new Error('GPU not available, and using a viewport with no custom render pipeline.');
            }
            const { offscreenMultiRenderWindow } = this;
            const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
            const context = openGLRenderWindow.get3DContext();
            const offScreenCanvas = context.canvas;
            eventDetail = this._renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas);
        }
        return eventDetail;
    }
    _renderViewportFromVtkCanvasToOnscreenCanvas(viewport, offScreenCanvas) {
        const { element, canvas, sx, sy, sWidth, sHeight, id: viewportId, renderingEngineId, suppressEvents, } = viewport;
        const { width: dWidth, height: dHeight } = canvas;
        const onScreenContext = canvas.getContext('2d');
        onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
        return {
            element,
            suppressEvents,
            viewportId,
            renderingEngineId,
            viewportStatus: viewport.viewportStatus,
        };
    }
    _resetViewport(viewport) {
        const renderingEngineId = this.id;
        const { element, canvas, id: viewportId } = viewport;
        const eventDetail = {
            element,
            viewportId,
            renderingEngineId,
        };
        viewport.removeWidgets();
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.ELEMENT_DISABLED, eventDetail);
        element.removeAttribute('data-viewport-uid');
        element.removeAttribute('data-rendering-engine-uid');
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
    }
    _clearAnimationFrame() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
    }
    _reset() {
        const viewports = this._getViewportsAsArray();
        viewports.forEach((viewport) => {
            this._resetViewport(viewport);
        });
        this._clearAnimationFrame();
        this._viewports = new Map();
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _downloadOffScreenCanvas() {
        const dataURL = this._debugRender();
        _TEMPDownloadURI(dataURL);
    }
    _debugRender() {
        const { offscreenMultiRenderWindow } = this;
        const renderWindow = offscreenMultiRenderWindow.getRenderWindow();
        const renderers = offscreenMultiRenderWindow.getRenderers();
        for (let i = 0; i < renderers.length; i++) {
            renderers[i].renderer.setDraw(true);
        }
        renderWindow.render();
        const openGLRenderWindow = offscreenMultiRenderWindow.getOpenGLRenderWindow();
        const context = openGLRenderWindow.get3DContext();
        const offScreenCanvas = context.canvas;
        const dataURL = offScreenCanvas.toDataURL();
        this._getViewportsAsArray().forEach((viewport) => {
            const { sx, sy, sWidth, sHeight } = viewport;
            const canvas = viewport.canvas;
            const { width: dWidth, height: dHeight } = canvas;
            const onScreenContext = canvas.getContext('2d');
            onScreenContext.drawImage(offScreenCanvas, sx, sy, sWidth, sHeight, 0, 0, dWidth, dHeight);
        });
        return dataURL;
    }
}
/* harmony default export */ const RenderingEngine_RenderingEngine = (RenderingEngine);
function _TEMPDownloadURI(uri) {
    const link = document.createElement('a');
    link.download = 'viewport.png';
    link.href = uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
var getRenderingEngine = __webpack_require__(39536);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/index.js + 3 modules
var helpers = __webpack_require__(40661);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/index.js







/* harmony default export */ const esm_RenderingEngine = (RenderingEngine_RenderingEngine);


/***/ }),

/***/ 5862:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const cache = {};
const renderingEngineCache = {
    get: (id) => {
        return cache[id];
    },
    set: (re) => {
        const renderingEngineId = re.id;
        cache[renderingEngineId] = re;
    },
    delete: (id) => {
        return delete cache[id];
    },
    getAll: () => {
        const renderingEngineIds = Object.keys(cache);
        const renderingEngines = renderingEngineIds.map((id) => cache[id]);
        renderingEngines.sort((a, b) => {
            if (a.id[0] === '_' && b.id[0] !== '_') {
                return 1;
            }
            else if (a.id[0] !== '_' && b.id[0] === '_') {
                return -1;
            }
            else {
                return 0;
            }
        });
        return renderingEngines;
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (renderingEngineCache);


/***/ }),

/***/ 42295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ig: () => (/* reexport */ vtkClasses_vtkOffscreenMultiRenderWindow),
  wu: () => (/* reexport */ vtkClasses_vtkSharedVolumeMapper),
  uT: () => (/* reexport */ vtkClasses_vtkStreamingOpenGLTexture)
});

// UNUSED EXPORTS: vtkSlabCamera

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros.js
var macros = __webpack_require__(37290);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js


const DEFAULT_VIEW_API = 'WebGL';
const VIEW_CONSTRUCTORS = Object.create(null);

// ----------------------------------------------------------------------------
// static methods
// ----------------------------------------------------------------------------

function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}

// ----------------------------------------------------------------------------
// vtkRenderWindow methods
// ----------------------------------------------------------------------------

function vtkRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindow');

  // Add renderer
  publicAPI.addRenderer = renderer => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);

    // for (this->Renderers->InitTraversal(rsit);
    //      (aren = this->Renderers->GetNextRenderer(rsit)); )
    //   {
    //   aren->SetAllocatedRenderTime
    //     (1.0/(this->DesiredUpdateRate*this->Renderers->GetNumberOfItems()));
    //   }

    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeRenderer = renderer => {
    model.renderers = model.renderers.filter(r => r !== renderer);
    publicAPI.modified();
  };
  publicAPI.hasRenderer = ren => model.renderers.indexOf(ren) !== -1;

  // get an API specific view of this data
  publicAPI.newAPISpecificView = function (name) {
    let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };

  // Add renderer
  publicAPI.addView = view => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model._views.push(view);
    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeView = view => {
    model._views = model._views.filter(r => r !== view);
    publicAPI.modified();
  };
  publicAPI.hasView = view => model._views.indexOf(view) !== -1;

  // handle any pre render initializations
  publicAPI.preRender = () => {
    model.renderers.forEach(ren => {
      // make sure we have a camera
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = () => {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model._views.forEach(view => view.traverseAllPasses());
    }
  };
  publicAPI.getStatistics = () => {
    const results = {
      propCount: 0,
      invisiblePropCount: 0,
      gpuMemoryMB: 0
    };
    model._views.forEach(v => {
      if (v.getGraphicsMemoryInfo) results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
    });
    model.renderers.forEach(ren => {
      const props = ren.getViewProps();
      const gren = model._views[0].getViewNodeFor(ren);
      props.forEach(prop => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const gmpr = gren.getViewNodeFor(mpr);
            if (gmpr) {
              if (gmpr.getAllocatedGPUMemoryInBytes) {
                results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
              }
              const pcount = mpr.getPrimitiveCount();
              Object.keys(pcount).forEach(keyName => {
                if (!results[keyName]) {
                  results[keyName] = 0;
                }
                results[keyName] += pcount[keyName];
              });
            }
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map(keyName => `${keyName}: ${results[keyName]}`).join('\n');
    return results;
  };
  publicAPI.captureImages = function () {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    macros2.m.setImmediate(publicAPI.render);
    return model._views.map(view => view.captureNextImage ? view.captureNextImage(format, opts) : undefined).filter(i => !!i);
  };
  publicAPI.addRenderWindow = child => {
    if (model.childRenderWindows.includes(child)) {
      return false;
    }
    model.childRenderWindows.push(child);
    publicAPI.modified();
    return true;
  };
  publicAPI.removeRenderWindow = child => {
    const childIndex = model.childRenderWindows.findIndex(x => x === child);
    if (childIndex < 0) {
      return false;
    }
    model.childRenderWindows.splice(childIndex, 1);
    publicAPI.modified();
    return true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  defaultViewAPI: DEFAULT_VIEW_API,
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
  childRenderWindows: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['interactor', 'numberOfLayers', '_views', 'defaultViewAPI']);
  macros2.m.get(publicAPI, model, ['neverRendered']);
  macros2.m.getArray(publicAPI, model, ['renderers', 'childRenderWindows']);
  macros2.m.moveToProtected(publicAPI, model, ['views']);
  macros2.m.event(publicAPI, model, 'completion');

  // Object methods
  vtkRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkRenderWindow');

// ----------------------------------------------------------------------------

var vtkRenderWindow$1 = {
  newInstance,
  extend,
  registerViewConstructor,
  listViewAPIs,
  newAPISpecificView
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
var Framebuffer = __webpack_require__(32821);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js


// ----------------------------------------------------------------------------

function vtkRenderPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderPass');
  publicAPI.getOperation = () => model.currentOperation;
  publicAPI.setCurrentOperation = val => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${macros2.m.capitalize(model.currentOperation)}`;
  };
  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;

  // by default this class will traverse all of its
  // preDelegateOperations, then call its delegate render passes
  // the traverse all of its postDelegateOperations
  // any of those three arrays can be empty
  publicAPI.traverse = function (viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model._currentParent = parent;
    model.preDelegateOperations.forEach(val => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach(val => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach(val => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderPass_DEFAULT_VALUES = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};

// ----------------------------------------------------------------------------

function RenderPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['currentOperation']);
  macros2.m.setGet(publicAPI, model, ['delegates', '_currentParent', 'preDelegateOperations', 'postDelegateOperations']);
  macros2.m.moveToProtected(publicAPI, model, ['currentParent']);

  // Object methods
  vtkRenderPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderPass_newInstance = macros2.m.newInstance(RenderPass_extend, 'vtkRenderPass');

// ----------------------------------------------------------------------------

var vtkRenderPass$1 = {
  newInstance: RenderPass_newInstance,
  extend: RenderPass_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js + 1 modules
var Texture = __webpack_require__(79525);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js










const {
  Representation
} = Property/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------

function translucentShaderReplacement(shaders) {
  const substituteRes = ShaderProgram/* default.substitute */.A.substitute(shaders.Fragment, '//VTK::RenderPassFragmentShader::Impl', `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
  shaders.Fragment = substituteRes.result;
}
const oitpFragTemplate = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLOrderIndependentTranslucentPass');

  // build vertices etc
  publicAPI.createVertexBuffer = () => {
    // 4 corner points in clipping space in order (x, y, z) where z is always set to -1
    // prettier-ignore
    const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);

    // 4 corresponding corner points in texture space in order (x, y)
    const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);

    // a square defined as cell relation ship in order (cell_size, v1, v2, v3, v4)
    const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    const points = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName('points');
    const tcoords = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName('tcoords');
    const cells = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = viewNode => {
    const size = viewNode.getSize();
    const gl = viewNode.getContext();
    model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    model.framebuffer.create(...size);
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, 'Float32Array', null);
    model.translucentRTexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, 'Float32Array', null);
    model.translucentZTexture = Texture/* default.newInstance */.Ay.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size[0], size[1], 'Float32Array', null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = viewNode => {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'attribute vec2 tcoordTC;', 'varying vec2 tcoord;', 'void main() { tcoord = tcoordTC; gl_Position = vertexDC; }'].join('\n'), oitpFragTemplate, '');
  };
  publicAPI.createVBO = viewNode => {
    const gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    const program = model.copyShader;
    // prepare the vertex and triangle data for the image plane to render to

    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'tcoordTC', model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
    }
  };
  publicAPI.traverse = (viewNode, renNode, forwardPass) => {
    if (model.deleted) {
      return;
    }
    const size = viewNode.getSize();
    const gl = viewNode.getContext();

    // if we lack the webgl2 and half floatsupport just do
    // basic alpha blending
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension('EXT_color_buffer_half_float') && !gl.getExtension('EXT_color_buffer_float')) {
      publicAPI.setCurrentOperation('translucentPass');
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;

    // prepare framebuffer // allocate framebuffer if needed and bind it
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      const fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        // store framebuffer bindings to restore them later
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1.0]);
    gl.colorMask(false, false, false, false);

    // rerender the opaque pass to set the depth buffer
    // TODO remove when webgl1 is deprecated and instead
    // have the forward pass use a texture backed zbuffer
    if (forwardPass.getOpaqueActorCount() > 0) {
      // Don't use zBufferPass as it will also render the depth of translucent actors
      forwardPass.setCurrentOperation('opaqueZBufferPass');
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

    // make sure to clear the entire framebuffer as we will
    // be blitting the entire thing all of it needs good initial values
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
    gl.clearBufferfv(gl.COLOR, 1, [0.0, 0.0, 0.0, 0.0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);

    // basic gist is we accumulate color into RGB We compute final opacity
    // into A We store accumulated opacity into R of the R texture.
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);

    // now do the translucent rendering
    publicAPI.setCurrentOperation('translucentPass');
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    // gl.drawBuffers([gl.BACK]);

    // make sure the copy shader is ready
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }

    // make sure we have a VAO
    if (!model.copyVAO) {
      model.copyVAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();

    // make sure the VBO is up to date
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);

    // activate texture
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi('translucentRGBATexture', model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi('translucentRTexture', model.translucentRTexture.getTextureUnit());

    // render quad
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();

    // restore scissor + viewport from renderer
    const ts = renNode.getTiledSizeAndOrigin();
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
  };
  publicAPI.getShaderReplacement = () => {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = viewNode => {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const OrderIndependentTranslucentPass_DEFAULT_VALUES = {
  framebuffer: null,
  copyShader: null,
  tris: null
};

// ----------------------------------------------------------------------------

function OrderIndependentTranslucentPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, OrderIndependentTranslucentPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macros2.m.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  macros2.m.get(publicAPI, model, ['framebuffer']);

  // Object methods
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OrderIndependentTranslucentPass_newInstance = macros2.m.newInstance(OrderIndependentTranslucentPass_extend, 'vtkOpenGLOrderIndependentTranslucentPass');

// ----------------------------------------------------------------------------

var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: OrderIndependentTranslucentPass_newInstance,
  extend: OrderIndependentTranslucentPass_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js





// ----------------------------------------------------------------------------

function vtkForwardPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkForwardPass');

  // this pass implements a forward rendering pipeline
  // if both volumes and opaque geometry are present
  // it will mix the two together by capturing a zbuffer
  // first
  publicAPI.traverse = function (viewNode) {
    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model._currentParent = parent;

    // build
    publicAPI.setCurrentOperation('buildPass');
    viewNode.traverse(publicAPI);
    const numlayers = viewNode.getRenderable().getNumberOfLayers();

    // iterate over renderers
    const renderers = viewNode.getRenderable().getRenderersByReference();
    for (let i = 0; i < numlayers; i++) {
      for (let index = 0; index < renderers.length; index++) {
        const ren = renderers[index];
        const renNode = viewNode.getViewNodeFor(ren);
        if (ren.getDraw() && ren.getLayer() === i) {
          // check for both opaque and volume actors
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation('queryPass');
          renNode.traverse(publicAPI);

          // do we need to capture a zbuffer?
          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
            const size = viewNode.getFramebufferSize();
            // make sure the framebuffer is setup
            if (model.framebuffer === null) {
              model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            // opaqueZBufferPass only renders opaque actors
            // zBufferPass renders both translucent and opaque actors
            // we want to be able to pick translucent actors
            publicAPI.setCurrentOperation('zBufferPass');
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();

            // reset now that we have done it
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation('cameraPass');
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation('opaquePass');
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation('volumePass');
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation('overlayPass');
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = () => {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
  publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ForwardPass_DEFAULT_VALUES = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};

// ----------------------------------------------------------------------------

function ForwardPass_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ForwardPass_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']);

  // Object methods
  vtkForwardPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ForwardPass_newInstance = macros2.m.newInstance(ForwardPass_extend, 'vtkForwardPass');

// ----------------------------------------------------------------------------

var vtkForwardPass$1 = {
  newInstance: ForwardPass_newInstance,
  extend: ForwardPass_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var HardwareSelector_Constants = __webpack_require__(57703);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js + 3 modules
var DataSet = __webpack_require__(69147);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js



const {
  FieldAssociations
} = DataSet/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkHardwareSelector methods
// ----------------------------------------------------------------------------

function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push('vtkHardwareSelector');

  // get the source data that is used for generating a selection. This
  // must be called at least once before calling generateSelection. In
  // raster based backends this method will capture the buffers. You can
  // call this once and then make multiple calls to generateSelection.
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {};
  publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
    if (srcData) {
      return srcData.generateSelection(fx1, fy1, fx2, fy2);
    }
    return [];
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const HardwareSelector_DEFAULT_VALUES = {
  fieldAssociation: FieldAssociations.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};

// ----------------------------------------------------------------------------

function HardwareSelector_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, HardwareSelector_DEFAULT_VALUES, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['fieldAssociation', 'captureZValues']);

  // Object methods
  vtkHardwareSelector(publicAPI, model);
}

// ----------------------------------------------------------------------------

const HardwareSelector_newInstance = macros2.m.newInstance(HardwareSelector_extend, 'vtkHardwareSelector');

// ----------------------------------------------------------------------------

var vtkHardwareSelector$1 = {
  newInstance: HardwareSelector_newInstance,
  extend: HardwareSelector_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
/**
 * The (primary) property that describes the content of a selection
 * node's data. Other auxiliary description properties follow.
 * GLOBALIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * PEDIGREEIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * VALUES means the the selection list contains values from an
 * arbitrary attribute array (ignores any globalids attribute)
 * INDICES means that the selection list contains indexes into the
 * cell or point arrays.
 * FRUSTUM means the set of points and cells inside a frustum
 * LOCATIONS means the set of points and cells near a set of positions
 * THRESHOLDS means the points and cells with values within a set of ranges
 * getContentType() returns -1 if the content type is not set.
 */

// Specify how data arrays can be used by data objects
const SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
const SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants_Constants = {
  SelectionContent,
  SelectionField
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js



// ----------------------------------------------------------------------------
// vtkSelectionNode methods
// ----------------------------------------------------------------------------

function vtkSelectionNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSelectionNode');
  publicAPI.getBounds = () => model.points.getBounds();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SelectionNode_DEFAULT_VALUES = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};

// ----------------------------------------------------------------------------

function SelectionNode_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SelectionNode_DEFAULT_VALUES, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  model.properties = {};
  macros2.m.setGet(publicAPI, model, ['contentType', 'fieldType', 'properties', 'selectionList']);

  // Object specific methods
  vtkSelectionNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SelectionNode_newInstance = macros2.m.newInstance(SelectionNode_extend, 'vtkSelectionNode');

// ----------------------------------------------------------------------------

var vtkSelectionNode$1 = {
  newInstance: SelectionNode_newInstance,
  extend: SelectionNode_extend,
  ...Constants_Constants
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js







const {
  PassTypes
} = HardwareSelector_Constants/* default */.A;
const {
  SelectionContent: HardwareSelector_SelectionContent,
  SelectionField: HardwareSelector_SelectionField
} = vtkSelectionNode$1;
const {
  FieldAssociations: HardwareSelector_FieldAssociations
} = DataSet/* default */.Ay;
const {
  vtkErrorMacro: HardwareSelector_vtkErrorMacro
} = macros2.m;
const idOffset = 1;
function getInfoHash(info) {
  return `${info.propID} ${info.compositeID}`;
}
function getAlpha(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset + 3];
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  const r = pb[offset];
  const g = pb[offset + 1];
  const b = pb[offset + 2];
  return (b * 256 + g) * 256 + r;
}
function getID(low24, high8) {
  /* eslint-disable no-bitwise */
  let val = high8;
  val <<= 24;
  val |= low24;
  return val;
  /* eslint-enable no-bitwise */
}

function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  // Base case
  const maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }

    // offset inDisplayPosition based on the lower-left-corner of the Area.
    const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    const actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      // the pixel did not hit any actor.
      return null;
    }
    const info = {};
    info.valid = true;
    info.propID = actorid - idOffset;
    info.prop = buffdata.props[info.propID];
    let compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 0xffffff) {
      compositeID = 0;
    }
    info.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;
      info.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {
        return info;
      }
    }
    const low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);
    const high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);
    info.attributeID = getID(low24, high24);
    return info;
  }

  // Iterate over successively growing boxes.
  // They recursively call the base case to handle single pixels.
  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  const curPos = [0, 0];
  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (let dist = 1; dist < maxDist; ++dist) {
    // Vertical sides of box.
    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    // Horizontal sides of box.
    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }

  // nothing hit.
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}

//-----------------------------------------------------------------------------
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  const sel = [];
  let count = 0;
  dataMap.forEach((value, key) => {
    const child = vtkSelectionNode$1.newInstance();
    child.setContentType(HardwareSelector_SelectionContent.INDICES);
    switch (fieldassociation) {
      case HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(HardwareSelector_SelectionField.CELL);
        break;
      case HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(HardwareSelector_SelectionField.POINT);
        break;
      default:
        HardwareSelector_vtkErrorMacro('Unknown field association');
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}

//----------------------------------------------------------------------------
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  const x1 = Math.floor(fx1);
  const y1 = Math.floor(fy1);
  const x2 = Math.floor(fx2);
  const y2 = Math.floor(fy2);
  const dataMap = new Map();
  const outSelectedPosition = [0, 0];
  for (let yy = y1; yy <= y2; yy++) {
    for (let xx = x1; xx <= x2; xx++) {
      const pos = [xx, yy];
      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        const hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          const dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}

// ----------------------------------------------------------------------------
// vtkOpenGLHardwareSelector methods
// ----------------------------------------------------------------------------

function vtkOpenGLHardwareSelector(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHardwareSelector');

  //----------------------------------------------------------------------------
  publicAPI.releasePixBuffers = () => {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };

  //----------------------------------------------------------------------------
  publicAPI.beginSelection = () => {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model.maxAttributeId = 0;
    const size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      // this calls model.framebuffer.bind()
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        // this calls model.framebuffer.bind()
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      const gl = model._openGLRenderWindow.getContext();
      const originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    // Disable blending
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = () => {
    const gl = model._openGLRenderWindow.getContext();
    // Restore blending if it was enabled prior to the capture
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
    // assign the renderer
    model._renderer = renderer;

    // set area to all if no arguments provided
    if (fx1 === undefined) {
      const size = model._openGLRenderWindow.getSize();
      publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
    } else {
      publicAPI.setArea(fx1, fy1, fx2, fy2);
    }
    // just do capture buffers and package up the result
    if (!publicAPI.captureBuffers()) {
      return false;
    }
    const result = {
      area: [...model.area],
      pixBuffer: [...model.pixBuffer],
      captureZValues: model.captureZValues,
      zBuffer: model.zBuffer,
      props: [...model.props],
      fieldAssociation: model.fieldAssociation,
      renderer,
      openGLRenderWindow: model._openGLRenderWindow
    };
    result.generateSelection = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return generateSelectionWithData(result, ...args);
    };
    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.captureBuffers = () => {
    if (!model._renderer || !model._openGLRenderWindow) {
      HardwareSelector_vtkErrorMacro('Renderer and view must be set before calling Select.');
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);

    // todo revisit making selection part of core
    // then we can do this in core
    model._openGLRenderWindow.getRenderable().preRender();

    // int rgba[4];
    // rwin.getColorBufferSizes(rgba);
    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {
    //   vtkErrorMacro("Color buffer depth must be at least 8 bit. "
    //     "Currently: " << rgba[0] << ", " << rgba[1] << ", " <<rgba[2]);
    //   return false;
    // }
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });

    // Initialize renderer for selection.
    // change the renderer's background to black, which will indicate a miss
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);
    const rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    const pixelBufferSavedPasses = [];
    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        pixelBufferSavedPasses.push(model.currentPass);
      }
    }

    // Process pixel buffers
    pixelBufferSavedPasses.forEach(pass => {
      model.currentPass = pass;
      publicAPI.processPixelBuffers();
    });
    model.currentPass = PassTypes.MAX_KNOWN_PASS;
    publicAPI.endSelection();

    // restore original background
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });

    // restore image, not needed?
    // model._openGLRenderWindow.traverseAllPasses();
    return true;
  };
  publicAPI.processPixelBuffers = () => {
    model.props.forEach((prop, index) => {
      if (publicAPI.isPropHit(index)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
      }
    });
  };

  //----------------------------------------------------------------------------
  publicAPI.passRequired = pass => {
    if (pass === PassTypes.ID_HIGH24) {
      if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 0x00ffffff;
      }
      if (model.fieldAssociation === HardwareSelector_FieldAssociations.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 0x00ffffff;
      }
    }
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.savePixelBuffer = passNo => {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.buildPropHitList = pixelbuffer => {
    let offset = 0;
    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        let val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset * 4);
        }
        ++offset;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderProp = prop => {
    if (model.currentPass === PassTypes.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderCompositeIndex = index => {
    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };

  //----------------------------------------------------------------------------
  // TODO: make inline
  publicAPI.renderAttributeId = attribid => {
    if (attribid < 0) {
      // negative attribid is valid. It happens when rendering higher order
      // elements where new points are added for rendering smooth surfaces.
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;

    // if (model.currentPass < PassTypes.ID_LOW24) {
    //   return; // useless...
    // }
  };

  //----------------------------------------------------------------------------
  publicAPI.passTypeToString = type => macros2.m.enumToString(PassTypes, type);

  //----------------------------------------------------------------------------
  publicAPI.isPropHit = id => Boolean(model.hitProps[id]);
  publicAPI.setPropColorValueFromInt = val => {
    model.propColorValue[0] = val % 256 / 255.0;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;
  };

  // info has
  //   valid
  //   propId
  //   prop
  //   compositeID
  //   attributeID

  //----------------------------------------------------------------------------
  publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
    // Base case
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }

      // offset inDisplayPosition based on the lower-left-corner of the Area.
      const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      const actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        // the pixel did not hit any actor.
        return null;
      }
      const info = {};
      info.valid = true;
      info.propID = actorid - idOffset;
      info.prop = model.props[info.propID];
      let compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 0xffffff) {
        compositeID = 0;
      }
      info.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;
        info.displayPosition = inDisplayPosition;
      }

      // Skip attribute ids if alpha is zero (missed)
      if (model.pixBuffer[PassTypes.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {
          return info;
        }
      }
      const low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);
      const high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);
      info.attributeID = getID(low24, high24);
      return info;
    }

    // Iterate over successively growing boxes.
    // They recursively call the base case to handle single pixels.
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      // Vertical sides of box.
      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      // Horizontal sides of box.
      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }

    // nothing hit.
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };

  //----------------------------------------------------------------------------
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];
  publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo];

  //----------------------------------------------------------------------------

  publicAPI.attach = (openGLRenderWindow, renderer) => {
    model._openGLRenderWindow = openGLRenderWindow;
    model._renderer = renderer;
  };

  // override
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = function () {
    if (superSetArea(...arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const OpenGL_HardwareSelector_DEFAULT_VALUES = {
  area: undefined,
  // _renderer: null,
  // _openGLRenderWindow: null,
  // _openGLRenderer: null,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};

// ----------------------------------------------------------------------------

function OpenGL_HardwareSelector_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, OpenGL_HardwareSelector_DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macros2.m.setGetArray(publicAPI, model, ['area'], 4);
  macros2.m.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);
  macros2.m.setGetArray(publicAPI, model, ['propColorValue'], 3);
  macros2.m.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);
  macros2.m.event(publicAPI, model, 'event');

  // Object methods
  vtkOpenGLHardwareSelector(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OpenGL_HardwareSelector_newInstance = macros2.m.newInstance(OpenGL_HardwareSelector_extend, 'vtkOpenGLHardwareSelector');

// ----------------------------------------------------------------------------

var HardwareSelector_vtkHardwareSelector = {
  newInstance: OpenGL_HardwareSelector_newInstance,
  extend: OpenGL_HardwareSelector_extend,
  ...HardwareSelector_Constants/* default */.A
};



// EXTERNAL MODULE: ../../../node_modules/spark-md5/spark-md5.js
var spark_md5 = __webpack_require__(10989);
var spark_md5_default = /*#__PURE__*/__webpack_require__.n(spark_md5);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js




// ----------------------------------------------------------------------------

const SET_GET_FIELDS = ['lastShaderProgramBound', 'context', '_openGLRenderWindow'];

// ----------------------------------------------------------------------------
// vtkShaderCache methods
// ----------------------------------------------------------------------------

function vtkShaderCache(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderCache');
  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    // first handle renaming any Fragment shader inputs
    // if we have a geometry shader. By default fragment shaders
    // assume their inputs come from a Vertex Shader. When we
    // have a Geometry shader we rename the frament shader inputs
    // to come from the geometry shader

    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, 'VSOut', 'GSOut').result;
    }
    const gl2 = model._openGLRenderWindow.getWebgl2();
    let fragDepthString = '\n';
    let version = '#version 100\n';
    if (gl2) {
      version = '#version 300 es\n' + '#define attribute in\n' + '#define textureCube texture\n' + '#define texture2D texture\n' + '#define textureCubeLod textureLod\n' + '#define texture2DLod textureLod\n';
    } else {
      model.context.getExtension('OES_standard_derivatives');
      if (model.context.getExtension('EXT_frag_depth')) {
        fragDepthString = '#extension GL_EXT_frag_depth : enable\n';
      }
      if (model.context.getExtension('EXT_shader_texture_lod')) {
        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\n' + '#define textureCubeLod textureCubeLodEXT\n' + '#define texture2DLod texture2DLodEXT';
      }
    }
    nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, '//VTK::System::Dec', [`${version}\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
    let nVSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::System::Dec', [`${version}\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
    if (gl2) {
      nVSSource = ShaderProgram/* default.substitute */.A.substitute(nVSSource, 'varying', 'out').result;
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, 'varying', 'in').result;
      let shaderOutputs = '';
      let outputCount = 0;
      while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
        nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
        shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\n`;
        outputCount++;
      }
      nFSSource = ShaderProgram/* default.substitute */.A.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;
    }

    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\[0\\]',
    //   'gl_FragColor').result;

    const nGSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::System::Dec', version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };

  // return NULL if there is an issue
  publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
    const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shaderProgram);
  };
  publicAPI.readyShaderProgram = program => {
    if (!program) {
      return null;
    }

    // compile if needed
    if (!program.getCompiled() && !program.compileShader()) {
      return null;
    }

    // bind if needed
    if (!publicAPI.bindShaderProgram(program)) {
      return null;
    }
    return program;
  };
  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    // compute the MD5 and the check the map
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = spark_md5_default().hash(hashInput);

    // does it already exist?
    if (!(result in model.shaderPrograms)) {
      // create one
      const sps = ShaderProgram/* default */.A.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = win => {
    // NOTE:
    // In the current implementation as of October 26th, if a shader
    // program is created by ShaderCache then it should make sure
    // that it releases the graphics resources used by these programs.
    // It is not wisely for callers to do that since then they would
    // have to loop over all the programs were in use and invoke
    // release graphics resources individually.

    publicAPI.releaseCurrentShaderProgram();
    Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.cleanup());
    model.shaderPrograms = {};
  };
  publicAPI.releaseCurrentShaderProgram = () => {
    // release prior shader
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.cleanup();
      model.lastShaderProgramBound = null;
    }
  };
  publicAPI.bindShaderProgram = program => {
    if (model.lastShaderProgramBound === program) {
      return 1;
    }

    // release prior program
    if (model.lastShaderProgramBound) {
      model.lastShaderProgramBound.release();
    }
    program.bind();
    model.lastShaderProgramBound = program;
    return 1;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderCache_DEFAULT_VALUES = {
  lastShaderProgramBound: null,
  shaderPrograms: null,
  context: null
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function ShaderCache_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderCache_DEFAULT_VALUES, initialValues);

  // Internal objects
  model.shaderPrograms = {};

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, SET_GET_FIELDS);
  macros2.m.moveToProtected(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkShaderCache(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderCache_newInstance = macros2.m.newInstance(ShaderCache_extend, 'vtkShaderCache');

// ----------------------------------------------------------------------------

var vtkShaderCache$1 = {
  newInstance: ShaderCache_newInstance,
  extend: ShaderCache_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js


const {
  vtkErrorMacro: TextureUnitManager_vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkOpenGLTextureUnitManager methods
// ----------------------------------------------------------------------------

function vtkOpenGLTextureUnitManager(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTextureUnitManager');

  // ----------------------------------------------------------------------------
  // Description:
  // Delete the allocation table and check if it is not called before
  // all the texture units have been released.
  publicAPI.deleteTable = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        TextureUnitManager_vtkErrorMacro('some texture units  were not properly released');
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };

  // ----------------------------------------------------------------------------
  publicAPI.setContext = ctx => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (let i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Reserve a texture unit. It returns its number.
  // It returns -1 if the allocation failed (because there are no more
  // texture units left).
  // \post valid_result: result==-1 || result>=0 && result<this->GetNumberOfTextureUnits())
  // \post allocated: result==-1 || this->IsAllocated(result)
  publicAPI.allocate = () => {
    for (let i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = unit => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Tell if texture unit `textureUnitId' is already allocated.
  // \pre valid_id_range : textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  publicAPI.isAllocated = textureUnitId => model.textureUnits[textureUnitId];

  // ----------------------------------------------------------------------------
  // Description:
  // Release a texture unit.
  // \pre valid_id: textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  // \pre allocated_id: this->IsAllocated(textureUnitId)
  publicAPI.free = val => {
    model.textureUnits[val] = false;
  };
  publicAPI.freeAll = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      model.textureUnits[i] = false;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const TextureUnitManager_DEFAULT_VALUES = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};

// ----------------------------------------------------------------------------

function TextureUnitManager_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, TextureUnitManager_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  model.textureUnits = [];

  // Build VTK API
  macros2.m.get(publicAPI, model, ['numberOfTextureUnits']);
  macros2.m.setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLTextureUnitManager(publicAPI, model);
}

// ----------------------------------------------------------------------------

const TextureUnitManager_newInstance = macros2.m.newInstance(TextureUnitManager_extend, 'vtkOpenGLTextureUnitManager');

// ----------------------------------------------------------------------------

var vtkTextureUnitManager = {
  newInstance: TextureUnitManager_newInstance,
  extend: TextureUnitManager_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js



// ----------------------------------------------------------------------------
// vtkRenderWindowViewNode is intended to be a superclass for all api specific
// RenderWindows. It is intended to define a common API that can be invoked
// upon an api specific render window and provide some common method
// implementations. If your application requires communicating with an api specific
// view try to limit such interactions to methods defined in this class.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkRenderWindowViewNode methods
// ----------------------------------------------------------------------------

function vtkRenderWindowViewNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindowViewNode');
  publicAPI.getViewNodeFactory = () => null;
  publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
  publicAPI.getAspectRatioForRenderer = renderer => {
    const viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = (x, y, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = viewport => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = viewport => {
    const size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
  publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
  publicAPI.worldToDisplay = (x, y, z, renderer) => {
    const val = renderer.worldToView(x, y, z);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = (x, y, z, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x, y, z);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1.0), y / (size[1] - 1.0), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1.0), y * (size[1] - 1.0), z];
  };
  publicAPI.displayToLocalDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const x2 = x + vCoords[0] + 0.5;
    const y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };
  publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
  publicAPI.getContainerSize = () => {
    macros2.m.vtkErrorMacro('not implemented');
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    macros2.m.vtkErrorMacro('not implemented');
  };
  publicAPI.createSelector = () => {
    macros2.m.vtkErrorMacro('not implemented');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindowViewNode_DEFAULT_VALUES = {
  size: undefined,
  selector: undefined
};

// ----------------------------------------------------------------------------

function RenderWindowViewNode_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindowViewNode_DEFAULT_VALUES, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macros2.m.getArray(publicAPI, model, ['size'], 2);
  macros2.m.get(publicAPI, model, ['selector']);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkRenderWindowViewNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindowViewNode_newInstance = macros2.m.newInstance(RenderWindowViewNode_extend, 'vtkRenderWindowViewNode');

// ----------------------------------------------------------------------------

var vtkRenderWindowViewNode$1 = {
  newInstance: RenderWindowViewNode_newInstance,
  extend: RenderWindowViewNode_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
// This is used to access the underlying 3D context
const GET_UNDERLYING_CONTEXT = '__getUnderlyingContext';
function createContextProxyHandler() {
  const cache = new Map();
  const getParameterHandler = {
    apply(target, gl, args) {
      if (cache.has(args[0])) {
        return cache.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };

  // only supports single-value setters
  function cachedSetterHandler(key) {
    return {
      apply(target, gl, args) {
        cache.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }

  // When a property is accessed on the webgl context proxy,
  // it's accessed is intercepted. If the property name matches
  // any of the keys of `propHandlers`, then that handler is called
  // with the following arguments: (gl, prop, receiver, propValue)
  // - gl (WebGL2RenderingContext): the underlying webgl context
  // - propName (string): the property name
  // - receiver (Proxy): the webgl context proxy
  // - propValue (unknown): the value of `gl[propName]`

  const propHandlers = Object.create(null);

  // Sets getParameter(property) as a cached getter proxy.
  // propValue.bind(gl) is to avoid Illegal Invocation errors.
  propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);

  // Sets depthMask(flag) as a cached setter proxy.
  propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  return {
    get(gl, prop, receiver) {
      if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
      let value = Reflect.get(gl, prop, gl);
      if (value instanceof Function) {
        // prevents Illegal Invocation errors
        value = value.bind(gl);
      }
      const propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}
var ContextProxy = {
  createContextProxyHandler
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js












const {
  vtkDebugMacro,
  vtkErrorMacro: RenderWindow_vtkErrorMacro
} = macros2.m;
const SCREENSHOT_PLACEHOLDER = {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%',
  height: '100%'
};
const parentMethodsToProxy = ['activateTexture', 'deactivateTexture', 'disableCullFace', 'enableCullFace', 'get3DContext', 'getActiveFramebuffer', 'getContext', 'getDefaultTextureByteSize', 'getDefaultTextureInternalFormat', 'getDefaultToWebgl2', 'getGLInformations', 'getGraphicsMemoryInfo', 'getGraphicsResourceForObject', 'getHardwareMaximumLineWidth', 'getPixelData', 'getShaderCache', 'getTextureUnitForTexture', 'getTextureUnitManager', 'getWebgl2', 'makeCurrent', 'releaseGraphicsResources', 'registerGraphicsResourceUser', 'unregisterGraphicsResourceUser', 'restoreContext', 'setActiveFramebuffer', 'setContext', 'setDefaultToWebgl2', 'setGraphicsResourceForObject'];
function checkRenderTargetSupport(gl, format, type) {
  // create temporary frame buffer and texture
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

  // check frame buffer status
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  // clean up
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}

// ----------------------------------------------------------------------------
// Monitor the usage of GL context across vtkOpenGLRenderWindow instances
// ----------------------------------------------------------------------------

let GL_CONTEXT_COUNT = 0;
const GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
}
function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}
function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}
function _preventDefault(e) {
  e.preventDefault();
}

// ----------------------------------------------------------------------------
// vtkOpenGLRenderWindow methods
// ----------------------------------------------------------------------------

function vtkOpenGLRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderWindow');

  // Only create a cachingContextHandler if needed
  let cachingContextHandler;
  function getCachingContextHandler() {
    if (!cachingContextHandler) {
      cachingContextHandler = createContextProxyHandler();
    }
    return cachingContextHandler;
  }
  publicAPI.getViewNodeFactory = () => model.myFactory;

  // prevent default context lost handler
  model.canvas.addEventListener('webglcontextlost', _preventDefault, false);
  model.canvas.addEventListener('webglcontextrestored', publicAPI.restoreContext, false);

  // Auto update style
  const previousSize = [0, 0];
  function updateWindow() {
    // Canvas size
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute('width', model.size[0]);
        model.canvas.setAttribute('height', model.size[1]);
      }
    }

    // ImageStream size
    if (model.viewStream) {
      // If same size that's a NoOp
      model.viewStream.setSize(model.size[0], model.size[1]);
    }

    // Offscreen ?
    model.canvas.style.display = model.useOffScreen ? 'none' : 'block';

    // Cursor type
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';
    }

    // Invalidate cached DOM container size
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.addMissingNodes(model.renderable.getChildRenderWindowsByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach(child => {
        // Children can be openGl renderer or openGl render windows
        // Only openGl renderers have a method setOpenGLRenderWindow
        child.setOpenGLRenderWindow?.(publicAPI);
      });
    }
  };
  publicAPI.initialize = () => {
    if (!model.initialized) {
      // Set root parent if there is one
      // Some methods of the root parent are proxied (see parentMethodsToProxy)
      model.rootOpenGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (model.rootOpenGLRenderWindow) {
        // Initialize a 2D context that will copy the content of the root parent
        model.context2D = publicAPI.get2DContext();
      } else {
        // Initialize a 3D context that may be used by child render windows
        model.context = publicAPI.get3DContext();
        publicAPI.resizeFromChildRenderWindows();
        if (model.context) {
          createGLContext();
        }
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        // initialize blending for transparency
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
      }
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = el => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        RenderWindow_vtkErrorMacro('Error: canvas parent node does not match container');
      }

      // Remove canvas from previous container
      model.el.removeChild(model.canvas);

      // If the renderer has previously added
      // a background image, remove it from the DOM.
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);

        // If the renderer is set to use a background
        // image, attach it to the DOM.
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }

      // Trigger modified()
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = () => model.el;
  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const {
        width,
        height
      } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = () => {
    const fbSize = model.activeFramebuffer?.getSize();
    return fbSize || model.size;
  };
  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function () {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: 'high-performance'
    };
    let result = null;
    const webgl2Supported = typeof WebGL2RenderingContext !== 'undefined';
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext('webgl2', options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro('using webgl2');
      }
    }
    if (!result) {
      vtkDebugMacro('using webgl1');
      result = model.canvas.getContext('webgl', options) || model.canvas.getContext('experimental-webgl', options);
    }
    return new Proxy(result, getCachingContextHandler());
  };
  publicAPI.get2DContext = function () {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return model.canvas.getContext('2d', options);
  };
  publicAPI.restoreContext = () => {
    const rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation('Release');
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = texture => {
    // Only add if it isn't already there
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      RenderWindow_vtkErrorMacro('Hardware does not support the number of textures defined.');
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = texture => {
    // Only deactivate if it isn't already there
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      publicAPI.getTextureUnitManager().free(result);
      model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = texture => {
    const result = model._textureResourceIds.get(texture);
    if (result !== undefined) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureByteSize = function (vtkType) {
    let oglNorm16Ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let useHalfFloat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (model.webgl2) {
      switch (vtkType) {
        case Constants/* VtkDataTypes */.JA.CHAR:
        case Constants/* VtkDataTypes */.JA.SIGNED_CHAR:
        case Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR:
          return 1;
        case oglNorm16Ext:
        case useHalfFloat:
        case Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
        case Constants/* VtkDataTypes */.JA.SHORT:
        case Constants/* VtkDataTypes */.JA.VOID:
          // Used for unsigned int depth
          return 2;
        default:
          // For all other cases, assume float
          return 4;
      }
    }

    // webgl1 type support is limited to 1 byte
    return 1;
  };
  publicAPI.getDefaultTextureInternalFormat = function (vtktype, numComps) {
    let oglNorm16Ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let useHalfFloat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (model.webgl2) {
      switch (vtktype) {
        case Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case oglNorm16Ext && !useHalfFloat && Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_EXT;
            case 2:
              return oglNorm16Ext.RG16_EXT;
            case 3:
              return oglNorm16Ext.RGB16_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_EXT;
          }
        // prioritize norm16 over float
        case oglNorm16Ext && !useHalfFloat && Constants/* VtkDataTypes */.JA.SHORT:
          switch (numComps) {
            case 1:
              return oglNorm16Ext.R16_SNORM_EXT;
            case 2:
              return oglNorm16Ext.RG16_SNORM_EXT;
            case 3:
              return oglNorm16Ext.RGB16_SNORM_EXT;
            case 4:
            default:
              return oglNorm16Ext.RGBA16_SNORM_EXT;
          }
        case Constants/* VtkDataTypes */.JA.UNSIGNED_SHORT:
        case Constants/* VtkDataTypes */.JA.SHORT:
        case Constants/* VtkDataTypes */.JA.FLOAT:
        default:
          // useHalfFloat tells us if the texture can be accurately
          // rendered with 16 bits or not.
          switch (numComps) {
            case 1:
              return useHalfFloat ? model.context.R16F : model.context.R32F;
            case 2:
              return useHalfFloat ? model.context.RG16F : model.context.RG32F;
            case 3:
              return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
            case 4:
            default:
              return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
          }
      }
    }

    // webgl1 only supports four types
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = img => {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = value => {
    model.useBackgroundImage = value;

    // Add or remove the background image from the
    // DOM as specified.
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;
    // Copy current canvas to not modify the original
    const temporaryCanvas = document.createElement('canvas');
    const temporaryContext = temporaryCanvas.getContext('2d');
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);

    // Get current client rect to place canvas
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();
    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach(renderer => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach(viewProp => {
        // Check if the prop has a container that should have canvas
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName('canvas');
          // Go throughout all canvas and copy it into temporary main canvas
          for (let i = 0; i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function () {
    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
    let {
      resetCamera = false,
      size = null,
      scale = 1
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null
    };
    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady(imageURL => {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            // resize the main canvas back to its original size and show it
            model.size = model._screenshot.originalSize;

            // process the resize
            publicAPI.modified();

            // restore the saved camera parameters, if applicable
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach(_ref => {
                let {
                  restoreParamsFn,
                  arg
                } = _ref;
                return restoreParamsFn(arg);
              });
            }

            // Trigger a render at the original size
            publicAPI.traverseAllPasses();

            // Remove and clean up the placeholder, revealing the original
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          // Create a placeholder image overlay while we resize and render
          const tmpImg = document.createElement('img');
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);

          // hide the main canvas
          model.canvas.style.display = 'none';

          // remember the main canvas original size, then resize it
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model.rootOpenGLRenderWindow?.resizeFromChildRenderWindows();
          model._screenshot.size = null;

          // process the resize
          publicAPI.modified();
          if (resetCamera) {
            const isUserResetCamera = resetCamera !== true;

            // If resetCamera was requested, we first save camera parameters
            // from all the renderers, so we can restore them later
            model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {
              const camera = renderer.getActiveCamera();
              const params = camera.get('focalPoint', 'position', 'parallelScale');
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : undefined,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                // "clone" the params so we don't keep refs to properties
                arg: JSON.parse(JSON.stringify(params))
              };
            });

            // Perform the resetCamera() on each renderer only after capturing
            // the params from all active cameras, in case there happen to be
            // linked cameras among the renderers.
            model._screenshot.cameras.forEach(_ref2 => {
              let {
                resetCameraFn,
                resetCameraArgs
              } = _ref2;
              return resetCameraFn(resetCameraArgs);
            });
          }

          // Trigger a render at the custom size
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  let hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = () => {
    // We cache the result of this function because `getParameter` is slow
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    const gl = publicAPI.get3DContext();
    const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = () => {
    if (model._glInformation) {
      return model._glInformation;
    }
    const gl = publicAPI.get3DContext();
    const glTextureFloat = gl.getExtension('OES_texture_float');
    const glTextureHalfFloat = gl.getExtension('OES_texture_half_float');
    const glDebugRendererInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const glDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
    const glAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    const params = [['Max Vertex Attributes', 'MAX_VERTEX_ATTRIBS', gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ['Max Varying Vectors', 'MAX_VARYING_VECTORS', gl.getParameter(gl.MAX_VARYING_VECTORS)], ['Max Vertex Uniform Vectors', 'MAX_VERTEX_UNIFORM_VECTORS', gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ['Max Fragment Uniform Vectors', 'MAX_FRAGMENT_UNIFORM_VECTORS', gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ['Max Fragment Texture Image Units', 'MAX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ['Max Vertex Texture Image Units', 'MAX_VERTEX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ['Max Combined Texture Image Units', 'MAX_COMBINED_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ['Max 2D Texture Size', 'MAX_TEXTURE_SIZE', gl.getParameter(gl.MAX_TEXTURE_SIZE)], ['Max Cube Texture Size', 'MAX_CUBE_MAP_TEXTURE_SIZE', gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ['Max Texture Anisotropy', 'MAX_TEXTURE_MAX_ANISOTROPY_EXT', glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ['Point Size Range', 'ALIASED_POINT_SIZE_RANGE', gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(' - ')], ['Line Width Range', 'ALIASED_LINE_WIDTH_RANGE', gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(' - ')], ['Max Viewport Dimensions', 'MAX_VIEWPORT_DIMS', gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(' - ')], ['Max Renderbuffer Size', 'MAX_RENDERBUFFER_SIZE', gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ['Framebuffer Red Bits', 'RED_BITS', gl.getParameter(gl.RED_BITS)], ['Framebuffer Green Bits', 'GREEN_BITS', gl.getParameter(gl.GREEN_BITS)], ['Framebuffer Blue Bits', 'BLUE_BITS', gl.getParameter(gl.BLUE_BITS)], ['Framebuffer Alpha Bits', 'ALPHA_BITS', gl.getParameter(gl.ALPHA_BITS)], ['Framebuffer Depth Bits', 'DEPTH_BITS', gl.getParameter(gl.DEPTH_BITS)], ['Framebuffer Stencil Bits', 'STENCIL_BITS', gl.getParameter(gl.STENCIL_BITS)], ['Framebuffer Subpixel Bits', 'SUBPIXEL_BITS', gl.getParameter(gl.SUBPIXEL_BITS)], ['MSAA Samples', 'SAMPLES', gl.getParameter(gl.SAMPLES)], ['MSAA Sample Buffers', 'SAMPLE_BUFFERS', gl.getParameter(gl.SAMPLE_BUFFERS)], ['Supported Formats for UByte Render Targets     ', 'UNSIGNED_BYTE RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Half Float Render Targets', 'HALF FLOAT RENDER TARGET FORMATS', [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGBA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGB' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'ALPHA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Full Float Render Targets', 'FLOAT RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Max Multiple Render Targets Buffers', 'MAX_DRAW_BUFFERS_WEBGL', glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ['High Float Precision in Vertex Shader', 'HIGH_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Vertex Shader', 'MEDIUM_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Vertex Shader', 'LOW_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Float Precision in Fragment Shader', 'HIGH_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Fragment Shader', 'MEDIUM_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Fragment Shader', 'LOW_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Vertex Shader', 'HIGH_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Vertex Shader', 'MEDIUM_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Vertex Shader', 'LOW_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Fragment Shader', 'HIGH_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Fragment Shader', 'MEDIUM_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Fragment Shader', 'LOW_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['Supported Extensions', 'EXTENSIONS', gl.getSupportedExtensions().join('<br/>\t\t\t\t\t    ')], ['WebGL Renderer', 'RENDERER', gl.getParameter(gl.RENDERER)], ['WebGL Vendor', 'VENDOR', gl.getParameter(gl.VENDOR)], ['WebGL Version', 'VERSION', gl.getParameter(gl.VERSION)], ['Shading Language Version', 'SHADING_LANGUAGE_VERSION', gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ['Unmasked Renderer', 'UNMASKED_RENDERER', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ['Unmasked Vendor', 'UNMASKED_VENDOR', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ['WebGL Version', 'WEBGL_VERSION', model.webgl2 ? 2 : 1]];
    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    model._glInformation = result;
    return result;
  };
  publicAPI.traverseAllPasses = () => {
    if (model.renderPasses) {
      for (let index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    publicAPI.copyParentContent();
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    for (let i = 0; i < childrenRW.length; ++i) {
      publicAPI.getViewNodeFor(childrenRW[i])?.traverseAllPasses();
    }
  };
  publicAPI.copyParentContent = () => {
    const rootParent = model.rootOpenGLRenderWindow;
    if (!rootParent || !model.context2D || model.children.some(oglRenderer => !!oglRenderer.getSelector?.())) {
      return;
    }
    const parentCanvas = rootParent.getCanvas();
    const selfCanvas = model.canvas;
    model.context2D.drawImage(parentCanvas, 0, parentCanvas.height - selfCanvas.height,
    // source y axis is inverted
    selfCanvas.width, selfCanvas.height, 0, 0, selfCanvas.width, selfCanvas.height);
  };
  publicAPI.resizeFromChildRenderWindows = () => {
    // Adapt the size of the parent render window to the child render windows
    const childrenRW = model.renderable.getChildRenderWindowsByReference();
    if (childrenRW.length > 0) {
      const maxSize = [0, 0];
      for (let i = 0; i < childrenRW.length; ++i) {
        const childSize = publicAPI.getViewNodeFor(childrenRW[i])?.getSize();
        if (childSize) {
          maxSize[0] = childSize[0] > maxSize[0] ? childSize[0] : maxSize[0];
          maxSize[1] = childSize[1] > maxSize[1] ? childSize[1] : maxSize[1];
        }
      }
      publicAPI.setSize(...maxSize);
    }
  };
  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = stream => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      // Force background to be transparent + render
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;

      // Enable display of the background image
      publicAPI.setUseBackgroundImage(true);

      // Bind to remote stream
      model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = () => {
    const ret = HardwareSelector_vtkHardwareSelector.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  function clearEvents() {
    model.canvas.removeEventListener('webglcontextlost', _preventDefault);
    model.canvas.removeEventListener('webglcontextrestored', publicAPI.restoreContext);
  }
  publicAPI.delete = macros2.m.chain(() => {
    if (model.context) {
      deleteGLContext();
    }
    publicAPI.setContainer();
    publicAPI.setViewStream();
  }, clearEvents, publicAPI.delete);

  // Do not trigger modified for performance reasons
  publicAPI.setActiveFramebuffer = newActiveFramebuffer => {
    model.activeFramebuffer = newActiveFramebuffer;
  };
  const superSetSize = publicAPI.setSize;
  publicAPI.setSize = (width, height) => {
    const modified = superSetSize(width, height);
    if (modified) {
      publicAPI.invokeWindowResizeEvent({
        width,
        height
      });
    }
    return modified;
  };
  publicAPI.registerGraphicsResourceUser = (coreObject, newUser) => {
    // Try to create the graphics resource if it doesn't exist
    if (!model._graphicsResources.has(coreObject)) {
      publicAPI.setGraphicsResourceForObject(coreObject, null, null);
    }
    // Add newUser to the set of users
    const sharedResource = model._graphicsResources.get(coreObject);
    sharedResource?.users.add(newUser);
  };
  publicAPI.unregisterGraphicsResourceUser = (coreObject, oldUser) => {
    const sharedResource = model._graphicsResources.get(coreObject);
    if (!sharedResource) {
      return;
    }
    sharedResource.users.delete(oldUser);
    // Release graphics resources when the number of users reaches 0
    if (!sharedResource.users.size) {
      sharedResource.oglObject?.releaseGraphicsResources(publicAPI);
      model._graphicsResources.delete(coreObject);
    }
  };
  publicAPI.getGraphicsResourceForObject = coreObject => model._graphicsResources.get(coreObject);
  publicAPI.setGraphicsResourceForObject = (coreObject, oglObject, hash) => {
    if (!coreObject) {
      return;
    }
    const sharedResource = model._graphicsResources.get(coreObject);
    // Release the old resource
    sharedResource?.oglObject?.releaseGraphicsResources(publicAPI);
    // Keep the same users that have registered for this coreObject
    model._graphicsResources.set(coreObject, {
      coreObject,
      oglObject,
      hash,
      users: sharedResource?.users ?? new Set()
    });
  };
  publicAPI.getGraphicsMemoryInfo = () => {
    let memUsed = 0;
    model._graphicsResources.forEach(_ref3 => {
      let {
        oglObject
      } = _ref3;
      memUsed += oglObject.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
  publicAPI.releaseGraphicsResources = () => {
    // Clear the shader cache
    if (model.shaderCache !== null) {
      model.shaderCache.releaseGraphicsResources(publicAPI);
    }
    // Free cached graphics resources at the context level
    model._graphicsResources.forEach(_ref4 => {
      let {
        oglObject
      } = _ref4;
      oglObject.releaseGraphicsResources(publicAPI);
    });
    model._graphicsResources.clear();
    if (model.textureUnitManager !== null) {
      model.textureUnitManager.freeAll();
    }
    // Finally, ask the renderers to release prop resources
    model.renderable.getRenderersByReference().forEach(ren => {
      const glRen = publicAPI.getViewNodeFor(ren);
      glRen?.releaseGraphicsResources();
    });
  };

  // Proxy some methods if needed
  const publicAPIBeforeProxy = {
    ...publicAPI
  };
  parentMethodsToProxy.forEach(methodName => {
    publicAPI[methodName] = function () {
      if (model.rootOpenGLRenderWindow) {
        // Proxy only methods when the render window has a parent
        return model.rootOpenGLRenderWindow[methodName](...arguments);
      }
      return publicAPIBeforeProxy[methodName](...arguments);
    };
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindow_DEFAULT_VALUES = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  context2D: null,
  canvas: null,
  cursorVisibility: true,
  cursor: 'pointer',
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  // attempt webgl2 on by default
  activeFramebuffer: null,
  imageFormat: 'image/png',
  useOffScreen: false,
  useBackgroundImage: false
};

// ----------------------------------------------------------------------------

function RenderWindow_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindow_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);

  // Create internal instances
  if (!model.canvas) {
    model.canvas = document.createElement('canvas');
    model.canvas.style.width = '100%';
  }
  if (!model.selector) {
    model.selector = HardwareSelector_vtkHardwareSelector.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }

  // Create internal bgImage
  model.bgImage = new Image();
  model.bgImage.style.position = 'absolute';
  model.bgImage.style.left = '0';
  model.bgImage.style.top = '0';
  model.bgImage.style.width = '100%';
  model.bgImage.style.height = '100%';
  model.bgImage.style.zIndex = '-1';
  model._textureResourceIds = new Map();
  model._graphicsResources = new Map();
  model._glInformation = null;
  model.myFactory = ViewNodeFactory/* default.newInstance */.Ay.newInstance();
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);

  // setup default forward pass rendering
  model.renderPasses[0] = vtkForwardPass$1.newInstance();

  // Build VTK API
  macros2.m.get(publicAPI, model, ['shaderCache', 'textureUnitManager', 'webgl2', 'useBackgroundImage', 'activeFramebuffer', 'rootOpenGLRenderWindow']);
  macros2.m.setGet(publicAPI, model, ['initialized', 'context', 'context2D', 'canvas', 'renderPasses', 'notifyStartCaptureImage', 'defaultToWebgl2', 'cursor', 'useOffScreen']);
  macros2.m.setGetArray(publicAPI, model, ['size'], 2);
  macros2.m.event(publicAPI, model, 'imageReady');
  macros2.m.event(publicAPI, model, 'windowResizeEvent');

  // Object methods
  vtkOpenGLRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindow_newInstance = macros2.m.newInstance(RenderWindow_extend, 'vtkOpenGLRenderWindow');

// ----------------------------------------------------------------------------
// Register API specific RenderWindow implementation
// ----------------------------------------------------------------------------

registerViewConstructor('WebGL', RenderWindow_newInstance);

// ----------------------------------------------------------------------------

var RenderWindow_vtkRenderWindow = {
  newInstance: RenderWindow_newInstance,
  extend: RenderWindow_extend,
  pushMonitorGLContextCount,
  popMonitorGLContextCount
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkRenderWindow', RenderWindow_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
var Actor = __webpack_require__(80639);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
var Actor2D = __webpack_require__(58601);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var BufferObject = __webpack_require__(21081);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var PolyDataMapper = __webpack_require__(62939);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js









const {
  vtkErrorMacro: Glyph3DMapper_vtkErrorMacro
} = macros2.c;
const {
  Representation: Glyph3DMapper_Representation
} = Property/* default */.Ay;
const {
  ObjectType
} = BufferObject/* default */.Ay;
const {
  PassTypes: Glyph3DMapper_PassTypes
} = HardwareSelector_vtkHardwareSelector;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLGlyph3DMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      Glyph3DMapper_vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    if (model._openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension('ANGLE_instanced_arrays');
      model.hardwareSupport = !!model.extension;
    }
    // to test without extension support uncomment the next two lines
    // model.extension = null;
    // model.hardwareSupport = !!model.extension;

    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    let b0 = b[off];
    let b1 = b[off + 1];
    let b2 = b[off + 2];
    let b3 = b[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 4];
    b1 = b[off + 5];
    b2 = b[off + 6];
    b3 = b[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 8];
    b1 = b[off + 9];
    b2 = b[off + 10];
    b3 = b[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 12];
    b1 = b[off + 13];
    b2 = b[off + 14];
    b3 = b[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'attribute mat3 gNormal;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;
          VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * gNormal * normalMC;']).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');

      // create the material/color property declarations, and VS implementation
      // these are always defined
      let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity'];
      // add more for specular
      if (lastLightComplexity) {
        colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);
      }

      // now handle the more complex fragment shader implementation
      // the following are always defined variables.  We start
      // by assigning a default value from the uniform
      let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);
      }
      colorImpl = colorImpl.concat(['  opacity = opacityUniform;']);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);
      }
      if (!model.drawingEdges) {
        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 gColor;', 'varying vec4 vertexColorVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput = gColor;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;
        colorImpl = colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;']);
      }
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;

      // do we need the vertex in the shader in View Coordinates
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', 'vertexVCVSOutput = MCVCMatrix * gVertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
      } else {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['attribute mat4 gMatrix;', 'uniform mat4 MCPCMatrix;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vec4 gVertexMC = gMatrix * vertexMC;', '  gl_Position = MCPCMatrix * gVertexMC;']).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Picking::Dec', ['attribute vec3 mapperIndexVS;', 'varying vec3 mapperIndexVSOutput;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Picking::Impl', '  mapperIndexVSOutput = mapperIndexVS;').result;
      shaders.Vertex = VSSource;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Dec', ['varying vec3 mapperIndexVSOutput;', 'uniform vec3 mapperIndex;', 'uniform int picking;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Impl', ['  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);', '  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];']).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };
  publicAPI.updateGlyphShaderParameters = (normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) => {
    const program = cellBO.getProgram();
    if (normalMatrixUsed) {
      const a = model.normalMatrix;
      const b = narray;
      const ofs = p * 9;
      const out = model.tmpMat3;
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a10 = a[3];
      const a11 = a[4];
      const a12 = a[5];
      const a20 = a[6];
      const a21 = a[7];
      const a22 = a[8];
      const b00 = b[ofs];
      const b01 = b[ofs + 1];
      const b02 = b[ofs + 2];
      const b10 = b[ofs + 3];
      const b11 = b[ofs + 4];
      const b12 = b[ofs + 5];
      const b20 = b[ofs + 6];
      const b21 = b[ofs + 7];
      const b22 = b[ofs + 8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      program.setUniformMatrix3x3('normalMatrix', model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);
    program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);
      program.setUniformMatrix('MCVCMatrix', model.tmpMat4);
    }

    // set color
    if (carray) {
      const cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255.0;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255.0;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255.0;
      program.setUniform3fArray('ambientColorUniform', model.tmpColor);
      program.setUniform3fArray('diffuseColorUniform', model.tmpColor);
    }
    if (selector) {
      program.setUniform3fArray('mapperIndex', selector.getPropColorValue());
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Glyph3DMapper_Representation.SURFACE;

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLActor.getKeyMatrices();

    // precompute the actor+camera mats once
    esm/* mat3.multiply */.w0.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    esm/* mat4.multiply */.pB.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    esm/* mat4.multiply */.pB.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);
    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    const carray = model.renderable.getColorArray();
    const numPts = garray.length / 16;
    let compositePass = false;
    if (model._openGLRenderer.getSelector()) {
      if (model._openGLRenderer.getSelector().getCurrentPass() === Glyph3DMapper_PassTypes.COMPOSITE_INDEX_PASS) {
        compositePass = true;
      }
    }

    // for every primitive type
    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);
        model.lastBoundBO = model.primitives[i];
        model.primitives[i].updateShaders(ren, actor, publicAPI);
        const program = model.primitives[i].getProgram();
        const mode = model.primitives[i].getOpenGLMode(representation);
        const normalMatrixUsed = program.isUniformUsed('normalMatrix');
        const mcvcMatrixUsed = program.isUniformUsed('MCVCMatrix');
        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          // draw the array multiple times with different cam matrix
          for (let p = 0; p < numPts; ++p) {
            if (compositePass) {
              model._openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model._openGLRenderer.getSelector() : null);
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('gMatrix')) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, 'gMatrix', 0, 64, model.context.FLOAT, 4, false, 1)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gMatrix in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gMatrix');
      }
      if (cellBO.getProgram().isAttributeUsed('gNormal')) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, 'gNormal', 0, 36, model.context.FLOAT, 3, false, 1)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gNormal in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gNormal');
      }
      if (cellBO.getProgram().isAttributeUsed('gColor')) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, 'gColor', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          Glyph3DMapper_vtkErrorMacro('Error setting gColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gColor');
      }
      if (cellBO.getProgram().isAttributeUsed('mapperIndexVS')) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, 'mapperIndexVS', 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          Glyph3DMapper_vtkErrorMacro('Error setting mapperIndexVS in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('mapperIndexVS');
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    model.renderable.buildArrays();

    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (superClass.getNeedToRebuildShaders(cellBO, ren, actor) || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    if (model.hardwareSupport) {
      // update the buffer objects if needed
      const garray = model.renderable.getMatrixArray();
      const narray = model.renderable.getNormalArray();
      const carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.normalBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.colorBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.pickBuffer = BufferObject/* default.newInstance */.Ay.newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
        model.matrixBuffer.upload(garray, ObjectType.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        const numPts = garray.length / 16;
        const parray = new Uint8Array(4 * numPts);
        for (let i = 0; i < numPts; ++i) {
          let value = i + 1;
          const offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    return superClass.buildBufferObjects(ren, actor);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Glyph3DMapper_DEFAULT_VALUES = {
  normalMatrix: null,
  mcpcMatrix: null,
  mcwcMatrix: null
};

// ----------------------------------------------------------------------------

function Glyph3DMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Glyph3DMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  model.tmpMat3 = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.normalMatrix = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.mcpcMatrix = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.mcvcMatrix = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.tmpColor = [];
  model.glyphBOBuildTime = {};
  (0,macros2.o)(model.glyphBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Glyph3DMapper_newInstance = (0,macros2.n)(Glyph3DMapper_extend, 'vtkOpenGLGlyph3DMapper');

// ----------------------------------------------------------------------------

var vtkGlyph3DMapper = {
  newInstance: Glyph3DMapper_newInstance,
  extend: Glyph3DMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkGlyph3DMapper', Glyph3DMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var ImageMapper = __webpack_require__(6814);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js + 1 modules
var ImageCPRMapper = __webpack_require__(82967);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
var ImageSlice = __webpack_require__(64501);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var Skybox = __webpack_require__(92530);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var BufferObject_Constants = __webpack_require__(60003);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js
var vtkSphereMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS_glsl = __webpack_require__(23159);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js











const {
  vtkErrorMacro: SphereMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLSphereMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSphereMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkSphereMapperVS;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\n', 'uniform mat4 MCVCMatrix;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\n']).result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = ['uniform float invertedDepth;\n', 'uniform int cameraParallel;\n', 'varying float radiusVCVSOutput;\n', 'varying vec3 centerVCVSOutput;\n', 'uniform mat4 VCPCMatrix;\n'];
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;
    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Depth::Impl', [
    // compute the eye position and unit direction
    '  vec3 EyePos;\n', '  vec3 EyeDir;\n', '  if (cameraParallel != 0) {\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\n', '  else {\n', '    EyeDir = vertexVC.xyz;\n', '    EyePos = vec3(0.0,0.0,0.0);\n', '    float lengthED = length(EyeDir);\n', '    EyeDir = normalize(EyeDir);\n',
    // we adjust the EyePos to be closer if it is too far away
    // to prevent floating point precision noise
    '    if (lengthED > radiusVCVSOutput*3.0) {\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n', '    }\n',
    // translate to Sphere center
    '  EyePos = EyePos - centerVCVSOutput;\n',
    // scale to radius 1.0
    '  EyePos = EyePos/radiusVCVSOutput;\n',
    // find the intersection
    '  float b = 2.0*dot(EyePos,EyeDir);\n', '  float c = dot(EyePos,EyePos) - 1.0;\n', '  float d = b*b - 4.0*c;\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n', '  if (d < 0.0) { discard; }\n', '  else {\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\n',
    // compute the normal, for unit sphere this is just
    // the intersection point
    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n',
    // compute the intersection point in VC
    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n', '    }\n',
    // compute the pixel's depth
    // ' normalVCVSOutput = vec3(0,0,1);\n'
    '  vec4 pos = VCPCMatrix * vertexVC;\n', fragString]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Impl', '').result;
    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12,
      // 12:this->VBO->ColorOffset+sizeof(float)
      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {
        SphereMapper_vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
      }
    }
    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {
      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);
    }
    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {
      // apply scaling factor only if a scale array has been provided.
      const poly = model.currentInput;
      const pointData = poly.getPointData();
      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());
      } else {
        cellBO.getProgram().setUniformf('scaleFactor', 1.0);
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      if (!actor.getIsIdentity()) {
        const actMats = model.openGLActor.getKeyMatrices();
        const tmp4 = new Float64Array(16);
        esm/* mat4.multiply */.pB.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      } else {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
    }
    if (program.isUniformUsed('cameraParallel')) {
      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    const pointSize = 5; // x,y,z,orientation1,orientation2
    let scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    let colorData = null;
    let colorComponents = 0;
    let packedUCVBO = null;
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c.getData();
      packedUCVBO = new Uint8Array(3 * numPoints * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(BufferObject/* default.newInstance */.Ay.newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);
    const packedVBO = new Float32Array(pointSize * numPoints * 3);
    vbo.setStride(pointSize * 4);
    const cos30 = Math.cos((0,Core_Math.r)(30.0));
    let pointIdx = 0;
    let colorIdx = 0;

    //
    // Generate points and point data for sides
    //
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = -2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 0.0;
      packedVBO[vboIdx++] = 2.0 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    if (c) {
      vbo.getColorBO().upload(packedUCVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    }
    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SphereMapper_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function SphereMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SphereMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLSphereMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SphereMapper_newInstance = (0,macros2.n)(SphereMapper_extend, 'vtkOpenGLSphereMapper');

// ----------------------------------------------------------------------------

var vtkSphereMapper = {
  newInstance: SphereMapper_newInstance,
  extend: SphereMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkSphereMapper', SphereMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js
var vtkStickMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js










const {
  vtkErrorMacro: StickMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// vtkOpenGLStickMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLStickMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLStickMapper');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkStickMapperVS;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\n', 'uniform mat4 MCVCMatrix;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\n').result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = ['uniform int cameraParallel;\n', 'varying float radiusVCVSOutput;\n', 'varying vec3 orientVCVSOutput;\n', 'varying float lengthVCVSOutput;\n', 'varying vec3 centerVCVSOutput;\n', 'uniform mat4 VCPCMatrix;\n'];
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;
    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Depth::Impl', [
    // compute the eye position and unit direction
    '  vec3 EyePos;\n', '  vec3 EyeDir;\n', '  if (cameraParallel != 0) {\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\n', '  else {\n', '    EyeDir = vertexVC.xyz;\n', '    EyePos = vec3(0.0,0.0,0.0);\n', '    float lengthED = length(EyeDir);\n', '    EyeDir = normalize(EyeDir);\n',
    // we adjust the EyePos to be closer if it is too far away
    // to prevent floating point precision noise
    '    if (lengthED > radiusVCVSOutput*3.0) {\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n', '    }\n',
    // translate to Stick center
    '  EyePos = EyePos - centerVCVSOutput;\n',
    // rotate to new basis
    // base1, base2, orientVC
    '  vec3 base1;\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n', '  else {\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n',
    // scale by radius
    '  EyePos = EyePos/radiusVCVSOutput;\n',
    // find the intersection
    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n', '  float d = b*b - 4.0*a*c;\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n', '  if (d < 0.0) { discard; }\n', '  else {\n', '    float t =  (-b - sqrt(d))/(2.0*a);\n', '    float tz = EyePos.z + t*EyeDir.z;\n', '    vec3 iPoint = EyePos + t*EyeDir;\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n',
    // test for end cap
    '      float t2 = (-b + sqrt(d))/(2.0*a);\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n', '      else {\n', '        normalVCVSOutput = orientVCVSOutput;\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n', '        iPoint = EyePos + t3*EyeDir;\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n', '        }\n', '      }\n', '    else {\n',
    // The normal is the iPoint.xy rotated back into VC
    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n',
    // rescale rerotate and translate
    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n', '      }\n', '    }\n',
    //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\n'
    // compute the pixel's depth
    '  vec4 pos = VCPCMatrix * vertexVC;\n', fragString]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Normal::Impl', '').result;
    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('orientMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12,
        // after X Y Z
        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          StickMapper_vtkErrorMacro("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {
          StickMapper_vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24,
        // X Y Z OX OY OZ
        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {
          StickMapper_vtkErrorMacro("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }
    if (!actor.getIsIdentity()) {
      const actMats = model.openGLActor.getKeyMatrices();
      if (program.isUniformUsed('MCVCMatrix')) {
        const tmp4 = new Float64Array(16);
        esm/* mat4.multiply */.pB.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      }
      if (program.isUniformUsed('normalMatrix')) {
        const anorms = new Float64Array(9);
        esm/* mat3.multiply */.w0.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3('normalMatrix', anorms);
      }
    } else {
      if (program.isUniformUsed('MCVCMatrix')) {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
      if (program.isUniformUsed('normalMatrix')) {
        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);
      }
    }
    if (program.isUniformUsed('cameraParallel')) {
      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    const vbo = model.primitives[model.primTypes.Tris].getCABO();
    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    let pointSize = 3; // x,y,z

    // three more floats for orientation + 1 for radius
    pointSize += 4;
    let colorData = null;
    let colorComponents = 0;
    vbo.setColorBOStride(4);
    if (!vbo.getColorBO()) {
      vbo.setColorBO(BufferObject/* default.newInstance */.Ay.newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);
    vbo.setStride(pointSize * 4);

    // Create a buffer, and copy the data over.
    const packedVBO = new Float32Array(pointSize * numPoints * 12);
    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));
    let scales = null;
    let orientationArray = null;
    //
    // Generate points and point data for sides
    //
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      StickMapper_vtkErrorMacro(['Error setting orientationArray.\n', 'You have to specify the stick orientation']);
    }

    // Vertices
    // 013 - 032 - 324 - 453
    //
    //       _.4---_.5
    //    .-*   .-*
    //   2-----3
    //   |    /|
    //   |   / |
    //   |  /  |
    //   | /   |
    //   |/    |
    //   0-----1
    //
    // coord for each points
    // 0: 000
    // 1: 100
    // 2: 001
    // 3: 101
    // 4: 011
    // 5: 111

    // prettier-ignore
    const verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];
    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let length = model.renderable.getLength();
      let radius = model.renderable.getRadius();
      if (scales) {
        length = scales[i * 2];
        radius = scales[i * 2 + 1];
      }
      for (let j = 0; j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = radius;
        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;
        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, BufferObject_Constants/* ObjectType */.a.ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const StickMapper_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function StickMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, StickMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  PolyDataMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLStickMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const StickMapper_newInstance = (0,macros2.n)(StickMapper_extend, 'vtkOpenGLStickMapper');

// ----------------------------------------------------------------------------

var vtkStickMapper = {
  newInstance: StickMapper_newInstance,
  extend: StickMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkStickMapper', StickMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
var Volume = __webpack_require__(8126);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js + 2 modules
var VolumeMapper = __webpack_require__(95785);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
var SceneGraph_ViewNodeFactory = __webpack_require__(84784);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getBufferConfiguration.js
var getBufferConfiguration = __webpack_require__(99576);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js + 2 modules
var init = __webpack_require__(26896);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLVolumeMapper.js










function vtkStreamingOpenGLVolumeMapper(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLVolumeMapper');
    publicAPI.buildBufferObjects = (ren, actor) => {
        const image = model.currentInput;
        if (!image) {
            return;
        }
        const vprop = actor.getProperty();
        if (!model.jitterTexture.getHandle()) {
            const oTable = new Uint8Array(32 * 32);
            for (let i = 0; i < 32 * 32; ++i) {
                oTable[i] = 255.0 * Math.random();
            }
            model.jitterTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.jitterTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.jitterTexture.create2DFromRaw(32, 32, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
        }
        const { numberOfComponents: numIComps } = image.get('numberOfComponents');
        const useIndependentComps = publicAPI.useIndependentComponents(vprop);
        const scalarOpacityFunc = vprop.getScalarOpacity();
        const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
        let toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(scalarOpacityFunc, useIndependentComps, numIComps);
        const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
        if (reBuildOp) {
            model.opacityTexture = Texture/* default.newInstance */.Ay.newInstance();
            model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            const oWidth = 1024;
            const oSize = oWidth * 2 * numIComps;
            const ofTable = new Float32Array(oSize);
            const tmpTable = new Float32Array(oWidth);
            for (let c = 0; c < numIComps; ++c) {
                const ofun = vprop.getScalarOpacity(c);
                const opacityFactor = publicAPI.getCurrentSampleDistance(ren) /
                    vprop.getScalarOpacityUnitDistance(c);
                const oRange = ofun.getRange();
                ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
                for (let i = 0; i < oWidth; ++i) {
                    ofTable[c * oWidth * 2 + i] =
                        1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
                    ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
                }
            }
            model.opacityTexture.resetFormatAndType();
            model.opacityTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.opacityTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            if (model._openGLRenderWindow.getWebgl2() &&
                model.context.getExtension('OES_texture_float') &&
                model.context.getExtension('OES_texture_float_linear')) {
                model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.FLOAT, ofTable);
            }
            else {
                const oTable = new Uint8ClampedArray(oSize);
                for (let i = 0; i < oSize; ++i) {
                    oTable[i] = 255.0 * ofTable[i];
                }
                model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
            }
            if (scalarOpacityFunc) {
                model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
                if (scalarOpacityFunc !== model._scalarOpacityFunc) {
                    model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
                    model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
                }
                model._scalarOpacityFunc = scalarOpacityFunc;
            }
        }
        else {
            model.opacityTexture = opTex.oglObject;
        }
        const colorTransferFunc = vprop.getRGBTransferFunction();
        toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, useIndependentComps, numIComps);
        const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
        const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
        if (reBuildC) {
            model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
            model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            const cWidth = 1024;
            const cSize = cWidth * 2 * numIComps * 3;
            const cTable = new Uint8ClampedArray(cSize);
            const tmpTable = new Float32Array(cWidth * 3);
            for (let c = 0; c < numIComps; ++c) {
                const cfun = vprop.getRGBTransferFunction(c);
                const cRange = cfun.getRange();
                cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
                for (let i = 0; i < cWidth * 3; ++i) {
                    cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
                    cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
                }
            }
            model.colorTexture.resetFormatAndType();
            model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
            model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
            if (colorTransferFunc) {
                model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
                if (colorTransferFunc !== model._colorTransferFunc) {
                    model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
                    model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
                }
                model._colorTransferFunc = colorTransferFunc;
            }
        }
        else {
            model.colorTexture = cTex.oglObject;
        }
        publicAPI.updateLabelOutlineThicknessTexture(actor);
        toString = `${image.getMTime()}-${model.scalarTexture.getMTime()}`;
        if (model.scalarTextureString !== toString) {
            const dims = image.getDimensions();
            model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
            model.scalarTexture.enableUseHalfFloat(false);
            const previousTextureParameters = model.scalarTexture.getTextureParameters();
            const dataType = image.get('dataType').dataType;
            let shouldReset = true;
            if (previousTextureParameters?.dataType === dataType) {
                if (previousTextureParameters?.width === dims[0]) {
                    if (previousTextureParameters?.height === dims[1]) {
                        if (previousTextureParameters?.depth === dims[2]) {
                            shouldReset = false;
                        }
                    }
                }
            }
            if (shouldReset) {
                const norm16Ext = model.context.getExtension('EXT_texture_norm16');
                model.scalarTexture.setOglNorm16Ext((0,init/* getCanUseNorm16Texture */.up)() ? norm16Ext : null);
                model.scalarTexture.resetFormatAndType();
                model.scalarTexture.setTextureParameters({
                    width: dims[0],
                    height: dims[1],
                    depth: dims[2],
                    numberOfComponents: numIComps,
                    dataType,
                });
                model.scalarTexture.create3DFromRaw(dims[0], dims[1], dims[2], numIComps, dataType, null);
                model.scalarTexture.update3DFromRaw();
            }
            else {
                model.scalarTexture.deactivate();
                model.scalarTexture.update3DFromRaw();
            }
            model.scalarTextureString = toString;
        }
        if (!model.tris.getCABO().getElementCount()) {
            const ptsArray = new Float32Array(12);
            for (let i = 0; i < 4; i++) {
                ptsArray[i * 3] = (i % 2) * 2 - 1.0;
                ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
                ptsArray[i * 3 + 2] = -1.0;
            }
            const cellArray = new Uint16Array(8);
            cellArray[0] = 3;
            cellArray[1] = 0;
            cellArray[2] = 1;
            cellArray[3] = 3;
            cellArray[4] = 3;
            cellArray[5] = 0;
            cellArray[6] = 3;
            cellArray[7] = 2;
            const points = DataArray/* default.newInstance */.Ay.newInstance({
                numberOfComponents: 3,
                values: ptsArray,
            });
            points.setName('points');
            const cells = DataArray/* default.newInstance */.Ay.newInstance({
                numberOfComponents: 1,
                values: cellArray,
            });
            model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
                points,
                cellOffset: 0,
            });
        }
        model.VBOBuildTime.modified();
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
        if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||
            model.VBOBuildTime.getMTime() < actor.getMTime() ||
            model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||
            model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||
            model.VBOBuildTime.getMTime() < model.currentInput.getMTime() ||
            model.VBOBuildTime.getMTime() < model.scalarTexture?.getMTime() ||
            model.VBOBuildTime.getMTime() < model.colorTexture?.getMTime() ||
            model.VBOBuildTime.getMTime() <
                model.labelOutlineThicknessTexture?.getMTime() ||
            !model.scalarTexture?.getHandle() ||
            !model.colorTexture?.getHandle() ||
            !model.labelOutlineThicknessTexture?.getHandle()) {
            return true;
        }
        return false;
    };
}
const vtkStreamingOpenGLVolumeMapper_DEFAULT_VALUES = {};
function vtkStreamingOpenGLVolumeMapper_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLVolumeMapper_DEFAULT_VALUES, initialValues);
    VolumeMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    model.scalarTexture = initialValues.scalarTexture;
    model.previousState = {};
    vtkStreamingOpenGLVolumeMapper(publicAPI, model);
}
const vtkStreamingOpenGLVolumeMapper_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLVolumeMapper_extend, 'vtkStreamingOpenGLVolumeMapper');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLVolumeMapper = ({ newInstance: vtkStreamingOpenGLVolumeMapper_newInstance, extend: vtkStreamingOpenGLVolumeMapper_extend });

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLViewNodeFactory.js



















const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
    CLASS_MAPPING[className] = fn;
}
function vtkStreamingOpenGLViewNodeFactory(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLViewNodeFactory');
    publicAPI.createNode = (dataObject) => {
        if (dataObject.isDeleted()) {
            return null;
        }
        let cpt = 0;
        let className = dataObject.getClassName(cpt++);
        let isObject = false;
        const keys = Object.keys(model.overrides);
        while (className && !isObject) {
            if (keys.includes(className)) {
                isObject = true;
            }
            else {
                className = dataObject.getClassName(cpt++);
            }
        }
        if (!isObject) {
            return null;
        }
        const initialValues = model.getModelInitialValues(dataObject);
        const vn = model.overrides[className](initialValues);
        vn.setMyFactory(publicAPI);
        return vn;
    };
    model.overrides = CLASS_MAPPING;
    model.getModelInitialValues = (dataObject) => {
        const initialValues = {};
        const className = dataObject.getClassName();
        if (className === 'vtkSharedVolumeMapper') {
            initialValues.scalarTexture = dataObject.getScalarTexture();
        }
        return initialValues;
    };
}
const vtkStreamingOpenGLViewNodeFactory_DEFAULT_VALUES = {};
function vtkStreamingOpenGLViewNodeFactory_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLViewNodeFactory_DEFAULT_VALUES, initialValues);
    SceneGraph_ViewNodeFactory/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    vtkStreamingOpenGLViewNodeFactory(publicAPI, model);
    registerOverride('vtkActor', Actor/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkActor2D', Actor2D/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkCamera', Camera/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkGlyph3DMapper', vtkGlyph3DMapper.newInstance);
    registerOverride('vtkImageMapper', ImageMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkImageCPRMapper', ImageCPRMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkImageSlice', ImageSlice/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkMapper', PolyDataMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkPixelSpaceCallbackMapper', PixelSpaceCallbackMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkRenderer', Renderer/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSkybox', Skybox/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSphereMapper', vtkSphereMapper.newInstance);
    registerOverride('vtkStickMapper', vtkStickMapper.newInstance);
    registerOverride('vtkTexture', Texture/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkVolume', Volume/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkVolumeMapper', VolumeMapper/* default.newInstance */.Ay.newInstance);
    registerOverride('vtkSharedVolumeMapper', vtkClasses_vtkStreamingOpenGLVolumeMapper.newInstance);
}
const vtkStreamingOpenGLViewNodeFactory_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLViewNodeFactory_extend, 'vtkStreamingOpenGLViewNodeFactory');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLViewNodeFactory = ({ newInstance: vtkStreamingOpenGLViewNodeFactory_newInstance, extend: vtkStreamingOpenGLViewNodeFactory_extend });

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLRenderWindow.js



function vtkStreamingOpenGLRenderWindow(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLRenderWindow');
}
function vtkStreamingOpenGLRenderWindow_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, initialValues);
    RenderWindow_vtkRenderWindow.extend(publicAPI, model, initialValues);
    model.myFactory = vtkClasses_vtkStreamingOpenGLViewNodeFactory.newInstance();
    registerOverride('vtkRenderWindow', vtkStreamingOpenGLRenderWindow_newInstance);
    vtkStreamingOpenGLRenderWindow(publicAPI, model);
}
const vtkStreamingOpenGLRenderWindow_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLRenderWindow_extend, 'vtkStreamingOpenGLRenderWindow');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLRenderWindow = ({ newInstance: vtkStreamingOpenGLRenderWindow_newInstance, extend: vtkStreamingOpenGLRenderWindow_extend });

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js + 2 modules
var Core_Renderer = __webpack_require__(50036);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
const Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2
};
const Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  Thumbstick: 4,
  A: 5,
  B: 6,
  ApplicationMenu: 7 // Not exposed in WebXR API
};

const Axis = {
  Unknown: 0,
  TouchpadX: 1,
  TouchpadY: 2,
  ThumbstickX: 3,
  ThumbstickY: 4
};
var RenderWindowInteractor_Constants_Constants = {
  Device,
  Input,
  Axis
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js




const {
  Device: RenderWindowInteractor_Device,
  Input: RenderWindowInteractor_Input
} = RenderWindowInteractor_Constants_Constants;
const {
  vtkWarningMacro,
  vtkErrorMacro: RenderWindowInteractor_vtkErrorMacro,
  normalizeWheel,
  vtkOnceErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

const EMPTY_MOUSE_EVENT = {
  ctrlKey: false,
  altKey: false,
  shiftKey: false
};
const deviceInputMap = {
  'xr-standard': [RenderWindowInteractor_Input.Trigger, RenderWindowInteractor_Input.Grip, RenderWindowInteractor_Input.TrackPad, RenderWindowInteractor_Input.Thumbstick, RenderWindowInteractor_Input.A, RenderWindowInteractor_Input.B]
};
const handledEvents = ['StartAnimation', 'Animation', 'EndAnimation', 'PointerEnter', 'PointerLeave', 'MouseEnter', 'MouseLeave', 'StartMouseMove', 'MouseMove', 'EndMouseMove', 'LeftButtonPress', 'LeftButtonRelease', 'MiddleButtonPress', 'MiddleButtonRelease', 'RightButtonPress', 'RightButtonRelease', 'KeyPress', 'KeyDown', 'KeyUp', 'StartMouseWheel', 'MouseWheel', 'EndMouseWheel', 'StartPinch', 'Pinch', 'EndPinch', 'StartPan', 'Pan', 'EndPan', 'StartRotate', 'Rotate', 'EndRotate', 'Button3D', 'Move3D', 'StartPointerLock', 'EndPointerLock', 'StartInteraction', 'Interaction', 'EndInteraction', 'AnimationFrameRateUpdate'];
function preventDefault(event) {
  if (event.cancelable) {
    event.preventDefault();
  }
}
function pointerCacheToPositions(cache) {
  const positions = Object.create(null);
  cache.forEach(_ref => {
    let {
      pointerId,
      position
    } = _ref;
    positions[pointerId] = position;
  });
  return positions;
}

// ----------------------------------------------------------------------------
// vtkRenderWindowInteractor methods
// ----------------------------------------------------------------------------

function vtkRenderWindowInteractor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindowInteractor');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };

  // Initialize list of requesters
  const animationRequesters = new Set();

  // map from pointerId to { pointerId: number, position: [x, y] }
  const pointerCache = new Map();

  // Factor to apply on wheel spin.
  let wheelCoefficient = 1;

  // Public API methods

  //----------------------------------------------------------------------
  publicAPI.start = () => {
    // Let the compositing handle the event loop if it wants to.
    // if (publicAPI.HasObserver(vtkCommand::StartEvent) && !publicAPI.HandleEventLoop) {
    //   publicAPI.invokeEvent({ type: 'StartEvent' });
    //   return;
    // }

    // As a convenience, initialize if we aren't initialized yet.
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    // Pass execution to the subclass which will run the event loop,
    // this will not return until TerminateApp is called.
    publicAPI.startEventLoop();
  };

  //----------------------------------------------------------------------
  publicAPI.setRenderWindow = aren => {
    RenderWindowInteractor_vtkErrorMacro('you want to call setView(view) instead of setRenderWindow on a vtk.js interactor');
  };

  //----------------------------------------------------------------------
  publicAPI.setInteractorStyle = style => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };

  //---------------------------------------------------------------------
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = () => publicAPI.setEnabled(true);
  publicAPI.disable = () => publicAPI.setEnabled(false);
  publicAPI.startEventLoop = () => vtkWarningMacro('empty event loop');
  function updateCurrentRenderer(x, y) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x, y);
    }
  }
  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function _getScreenEventPositionFor(source) {
    const canvas = model._view.getCanvas();
    const bounds = canvas.getBoundingClientRect();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0
    };

    // if multitouch, do not update the current renderer
    if (pointerCache.size <= 1 || !model.currentRenderer) {
      updateCurrentRenderer(position.x, position.y);
    }
    return position;
  }
  // Allow user to override it
  const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
  function getModifierKeysFor(event) {
    return {
      controlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey
    };
  }
  function getKeysFor(event) {
    const modifierKeys = getModifierKeysFor(event);
    const keys = {
      key: event.key,
      keyCode: event.charCode,
      ...modifierKeys
    };
    return keys;
  }
  function getDeviceTypeFor(event) {
    return event.pointerType || '';
  }
  const _bindEvents = () => {
    if (model.container === null) {
      return;
    }
    const {
      container
    } = model;
    container.addEventListener('contextmenu', preventDefault);
    container.addEventListener('wheel', publicAPI.handleWheel);
    container.addEventListener('DOMMouseScroll', publicAPI.handleWheel);
    container.addEventListener('pointerenter', publicAPI.handlePointerEnter);
    container.addEventListener('pointerleave', publicAPI.handlePointerLeave);
    container.addEventListener('pointermove', publicAPI.handlePointerMove, {
      passive: false
    });
    container.addEventListener('pointerdown', publicAPI.handlePointerDown, {
      passive: false
    });
    container.addEventListener('pointerup', publicAPI.handlePointerUp);
    container.addEventListener('pointercancel', publicAPI.handlePointerCancel);
    document.addEventListener('keypress', publicAPI.handleKeyPress);
    document.addEventListener('keydown', publicAPI.handleKeyDown);
    document.addEventListener('keyup', publicAPI.handleKeyUp);
    document.addEventListener('pointerlockchange', publicAPI.handlePointerLockChange);

    // using touchAction is more performant than preventDefault
    // in a touchstart handler.
    container.style.touchAction = 'none';
    container.style.userSelect = 'none';
    // disables tap highlight for when cursor is pointer
    container.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
  };

  // For backward compatibility.
  // Necessary for using unbind/bindEvent without calling setContainer.
  publicAPI.bindEvents = container => {
    if (container === null) {
      return;
    }
    const res = superClass.setContainer(container);
    if (res) {
      _bindEvents();
    }
  };
  const _unbindEvents = () => {
    // Clear any previous timeouts and state variables that control mouse / touchpad behavior.
    clearTimeout(model.moveTimeoutID);
    clearTimeout(model.wheelTimeoutID);
    model.moveTimeoutID = 0;
    model.wheelTimeoutID = 0;
    wheelCoefficient = 1.0;
    const {
      container
    } = model;
    if (container) {
      container.removeEventListener('contextmenu', preventDefault);
      container.removeEventListener('wheel', publicAPI.handleWheel);
      container.removeEventListener('DOMMouseScroll', publicAPI.handleWheel);
      container.removeEventListener('pointerenter', publicAPI.handlePointerEnter);
      container.removeEventListener('pointerleave', publicAPI.handlePointerLeave);
      container.removeEventListener('pointermove', publicAPI.handlePointerMove, {
        passive: false
      });
      container.removeEventListener('pointerdown', publicAPI.handlePointerDown, {
        passive: false
      });
      container.removeEventListener('pointerup', publicAPI.handlePointerUp);
      container.removeEventListener('pointercancel', publicAPI.handlePointerCancel);
    }
    document.removeEventListener('keypress', publicAPI.handleKeyPress);
    document.removeEventListener('keydown', publicAPI.handleKeyDown);
    document.removeEventListener('keyup', publicAPI.handleKeyUp);
    document.removeEventListener('pointerlockchange', publicAPI.handlePointerLockChange);
    pointerCache.clear();
  };
  publicAPI.unbindEvents = () => {
    _unbindEvents();
    superClass.setContainer(null);
  };
  publicAPI.handleKeyPress = event => {
    const data = getKeysFor(event);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = event => {
    const data = getKeysFor(event);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = event => {
    const data = getKeysFor(event);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handlePointerEnter = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerEnterEvent(callData);
    if (callData.deviceType === 'mouse') {
      publicAPI.mouseEnterEvent(callData);
    }
  };
  publicAPI.handlePointerLeave = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    publicAPI.pointerLeaveEvent(callData);
    if (callData.deviceType === 'mouse') {
      publicAPI.mouseLeaveEvent(callData);
    }
  };
  publicAPI.handlePointerDown = event => {
    if (event.button > 2 || publicAPI.isPointerLocked()) {
      // ignore events from extra mouse buttons such as `back` and `forward`
      return;
    }
    if (model.preventDefaultOnPointerDown) {
      preventDefault(event);
    }
    if (event.target.hasPointerCapture(event.pointerId)) {
      event.target.releasePointerCapture(event.pointerId);
    }
    model.container.setPointerCapture(event.pointerId);
    if (pointerCache.has(event.pointerId)) {
      vtkWarningMacro('[RenderWindowInteractor] duplicate pointerId detected');
    }
    pointerCache.set(event.pointerId, {
      pointerId: event.pointerId,
      position: getScreenEventPositionFor(event)
    });
    switch (event.pointerType) {
      case 'pen':
      case 'touch':
        publicAPI.handleTouchStart(event);
        break;
      case 'mouse':
      default:
        publicAPI.handleMouseDown(event);
        break;
    }
  };
  publicAPI.handlePointerUp = event => {
    if (pointerCache.has(event.pointerId)) {
      if (model.preventDefaultOnPointerUp) {
        preventDefault(event);
      }
      pointerCache.delete(event.pointerId);
      model.container.releasePointerCapture(event.pointerId);
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchEnd(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerCancel = event => {
    if (pointerCache.has(event.pointerId)) {
      pointerCache.delete(event.pointerId);
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchEnd(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseUp(event);
          break;
      }
    }
  };
  publicAPI.handlePointerMove = event => {
    if (pointerCache.has(event.pointerId)) {
      const pointer = pointerCache.get(event.pointerId);
      pointer.position = getScreenEventPositionFor(event);
    }
    switch (event.pointerType) {
      case 'pen':
      case 'touch':
        publicAPI.handleTouchMove(event);
        break;
      case 'mouse':
      default:
        publicAPI.handleMouseMove(event);
        break;
    }
  };
  publicAPI.handleMouseDown = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        RenderWindowInteractor_vtkErrorMacro(`Unknown mouse button pressed: ${event.button}`);
        break;
    }
  };

  //----------------------------------------------------------------------
  publicAPI.requestPointerLock = () => {
    if (model.container) {
      model.container.requestPointerLock();
    }
  };

  //----------------------------------------------------------------------
  publicAPI.exitPointerLock = () => document.exitPointerLock?.();

  //----------------------------------------------------------------------
  publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;

  //----------------------------------------------------------------------
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };

  //----------------------------------------------------------------------
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    // outside the above test so that third-party code can redirect
    // the render to the appropriate class
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = requestor => {
    if (requestor === undefined) {
      RenderWindowInteractor_vtkErrorMacro(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };

  // continue animating for at least the specified duration of
  // milliseconds.
  publicAPI.extendAnimation = duration => {
    const newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
  publicAPI.cancelAnimation = function (requestor) {
    let skipWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro(`${requestStr} did not request an animation`);
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = () => {
    // cancel existing animation if any
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = () => {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10.0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
    // watch for when buttons change state and fire events
    xrSession.inputSources.forEach(inputSource => {
      const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      const targetRayPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.targetRaySpace, xrRefSpace);
      const gamepad = inputSource.gamepad;
      const hand = inputSource.handedness;
      if (!gamepad) {
        return;
      }
      if (!(gamepad.index in model.lastGamepadValues)) {
        model.lastGamepadValues[gamepad.index] = {
          left: {
            buttons: {}
          },
          right: {
            buttons: {}
          },
          none: {
            buttons: {}
          }
        };
      }
      for (let buttonIdx = 0; buttonIdx < gamepad.buttons.length; ++buttonIdx) {
        if (!(buttonIdx in model.lastGamepadValues[gamepad.index][hand].buttons)) {
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = false;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] !== gamepad.buttons[buttonIdx].pressed && gripPose != null) {
          publicAPI.button3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            pressed: gamepad.buttons[buttonIdx].pressed,
            device: inputSource.handedness === 'left' ? RenderWindowInteractor_Device.LeftController : RenderWindowInteractor_Device.RightController,
            input: deviceInputMap[gamepad.mapping] && deviceInputMap[gamepad.mapping][buttonIdx] ? deviceInputMap[gamepad.mapping][buttonIdx] : RenderWindowInteractor_Input.Trigger
          });
          model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] = gamepad.buttons[buttonIdx].pressed;
        }
        if (model.lastGamepadValues[gamepad.index][hand].buttons[buttonIdx] && gripPose != null) {
          publicAPI.move3DEvent({
            gamepad,
            position: gripPose.transform.position,
            orientation: gripPose.transform.orientation,
            targetPosition: targetRayPose.transform.position,
            targetOrientation: targetRayPose.transform.orientation,
            device: inputSource.handedness === 'left' ? RenderWindowInteractor_Device.LeftController : RenderWindowInteractor_Device.RightController
          });
        }
      }
    });
  };
  publicAPI.handleMouseMove = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }

    // start a timer to keep us animating while we get mouse move events
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1000.0 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1000.0 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1.0 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = event => {
    preventDefault(event);

    /**
     * wheel event values can vary significantly across browsers, platforms
     * and devices [1]. `normalizeWheel` uses facebook's solution from their
     * fixed-data-table repository [2].
     *
     * [1] https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel
     * [2] https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
     *
     * This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     */
    const callData = {
      ...normalizeWheel(event),
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };

    // Wheel events are thought to scroll pages (i.e. multiple lines at once).
    // See normalizeWheel() documentation for more context.
    // While trackpad wheel events are many small (<1) wheel spins,
    // mouse wheel events have absolute spin values higher than 1.
    // Here the first spin value is "recorded", and used to normalize
    // all the following mouse wheel events.
    if (model.wheelTimeoutID === 0) {
      // we attempt to distinguish between trackpads and mice
      // .3 will be larger than the first trackpad event,
      // but small enough to detect some common edge case mice
      if (Math.abs(callData.spinY) >= 0.3) {
        // Event is coming from mouse wheel
        wheelCoefficient = Math.abs(callData.spinY);
      } else {
        // Event is coming from trackpad
        wheelCoefficient = 1;
      }
    }
    callData.spinY /= wheelCoefficient;
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
      publicAPI.mouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    if (model.mouseScrollDebounceByPass) {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    } else {
      // start a timer to keep us animating while we get wheel events
      model.wheelTimeoutID = setTimeout(() => {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      }, 200);
    }
  };
  publicAPI.handleMouseUp = event => {
    const callData = {
      ...getModifierKeysFor(event),
      position: getScreenEventPositionFor(event),
      deviceType: getDeviceTypeFor(event)
    };
    switch (event.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        RenderWindowInteractor_vtkErrorMacro(`Unknown mouse button released: ${event.button}`);
        break;
    }
  };
  publicAPI.handleTouchStart = event => {
    const pointers = [...pointerCache.values()];
    // If multitouch
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      // did we just transition to multitouch?
      if (pointers.length === 2) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      // handle the gesture
      publicAPI.recognizeGesture('TouchStart', positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonPressEvent(callData);
    }
  };
  publicAPI.handleTouchMove = event => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures && pointers.length > 1) {
      const positions = pointerCacheToPositions(pointerCache);
      publicAPI.recognizeGesture('TouchMove', positions);
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = event => {
    const pointers = [...pointerCache.values()];
    if (model.recognizeGestures) {
      // No more fingers down
      if (pointers.length === 0) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event),
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      } else if (pointers.length === 1) {
        // If one finger left, end touch and start button press
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture('TouchEnd', positions);
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonPressEvent(callData);
      } else {
        // If more than one finger left, keep touch move
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture('TouchMove', positions);
      }
    } else if (pointers.length === 1) {
      const callData = {
        ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
        position: pointers[0].position,
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.leftButtonReleaseEvent(callData);
    }
  };
  publicAPI.setView = val => {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = () => model._view?.getRenderable()?.getRenderersByReference()?.[0];
  publicAPI.findPokedRenderer = function () {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    // The original order of renderers needs to remain as
    // the first one is the one we want to manipulate the camera on.
    const rc = model._view?.getRenderable()?.getRenderers();
    if (!rc || rc.length === 0) {
      return null;
    }
    rc.sort((a, b) => a.getLayer() - b.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;
    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x, y, aren)) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        viewportren = aren;
      }
    }

    // We must have a value.  If we found an interactive renderer before, that's
    // better than a non-interactive renderer.
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }

    // We must have a value.  If we found a renderer that is in the viewport,
    // that is better than any old viewport (but not as good as an interactive
    // one).
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }

    // We must have a value - take anything.
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };

  // only render if we are not animating. If we are animating
  // then renders will happen naturally anyhow and we definitely
  // do not want extra renders as the make the apparent interaction
  // rate slower.
  publicAPI.render = () => {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };

  // create the generic Event methods
  handledEvents.forEach(eventName => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = arg => {
      // Check that interactor enabled
      if (!model.enabled) {
        return;
      }

      // Check that a poked renderer exists
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }

      // Pass the eventName and the poked renderer
      const callData = {
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer(),
        // Add the arguments to the call data
        ...arg
      };

      // Call invoke
      publicAPI[`invoke${eventName}`](callData);
    };
  });

  // we know we are in multitouch now, so start recognizing
  publicAPI.recognizeGesture = (event, positions) => {
    // more than two pointers we ignore
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }

    // store the initial positions
    if (event === 'TouchStart') {
      Object.keys(positions).forEach(key => {
        model.startingEventPositions[key] = positions[key];
      });
      // we do not know what the gesture is yet
      model.currentGesture = 'Start';
      return;
    }

    // end the gesture if needed
    if (event === 'TouchEnd') {
      if (model.currentGesture === 'Pinch') {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === 'Rotate') {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === 'Pan') {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = 'Start';
      model.startingEventPositions = {};
      return;
    }

    // what are the two pointers we are working with
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach(key => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });

    // The meat of the algorithm
    // on move events we analyze them to determine what type
    // of movement it is and then deal with it.
    // calculate the distances
    const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));

    // calculate rotations
    let originalAngle = (0,Core_Math.A)(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    let newAngle = (0,Core_Math.A)(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));

    // angles are cyclic so watch for that, 1 and 359 are only 2 apart :)
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180.0 >= 360.0 ? newAngle - 180.0 : newAngle + 180.0;
    originalAngle = originalAngle + 180.0 >= 360.0 ? originalAngle - 180.0 : originalAngle + 180.0;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }

    // calculate the translations
    const trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2.0;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2.0;
    if (event === 'TouchMove') {
      // OK we want to
      // - immediately respond to the user
      // - allow the user to zoom without panning (saves focal point)
      // - allow the user to rotate without panning (saves focal point)

      // do we know what gesture we are doing yet? If not
      // see if we can figure it out
      if (model.currentGesture === 'Start') {
        // pinch is a move to/from the center point
        // rotate is a move along the circumference
        // pan is a move of the center point
        // compute the distance along each of these axes in pixels
        // the first to break thresh wins
        let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15.0) {
          thresh = 15.0;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360.0;
        const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = 'Pinch';
          const callData = {
            scale: 1.0,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = 'Rotate';
          const callData = {
            rotation: 0.0,
            touches: positions
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = 'Pan';
          const callData = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        // if we have found a specific type of movement then
        // handle it
        if (model.currentGesture === 'Rotate') {
          const callData = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(callData);
        }
        if (model.currentGesture === 'Pinch') {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(callData);
        }
        if (model.currentGesture === 'Pan') {
          const callData = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = () => {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = r => {
    model._forcedRenderer = !!r;
    model.currentRenderer = r;
  };
  publicAPI.setContainer = container => {
    _unbindEvents();
    const res = superClass.setContainer(container ?? null);
    if (res) {
      _bindEvents();
    }
    return res;
  };

  // Stop animating if the renderWindowInteractor is deleted.
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== 'undefined') {
      document.removeEventListener('visibilitychange', publicAPI.handleVisibilityChange);
    }
    if (model.container) {
      publicAPI.setContainer(null);
    }
    superClass.delete();
  };

  // Use the Page Visibility API to detect when we switch away from or back to
  // this tab, and reset the animationFrameStart. When tabs are not active, browsers
  // will stop calling requestAnimationFrame callbacks.
  if (typeof document.hidden !== 'undefined') {
    document.addEventListener('visibilitychange', publicAPI.handleVisibilityChange, false);
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const RenderWindowInteractor_DEFAULT_VALUES = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30.0,
  stillUpdateRate: 2.0,
  container: null,
  // _view: null,
  recognizeGestures: true,
  currentGesture: 'Start',
  animationRequest: null,
  lastFrameTime: 0.1,
  recentAnimationFrameRate: 10.0,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
  preventDefaultOnPointerDown: false,
  preventDefaultOnPointerUp: false,
  mouseScrollDebounceByPass: false
};

// ----------------------------------------------------------------------------

function RenderWindowInteractor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, RenderWindowInteractor_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);

  // run animation at least until this time
  model._animationExtendedEnd = 0;
  macros2.m.event(publicAPI, model, 'RenderEvent');
  handledEvents.forEach(eventName => macros2.m.event(publicAPI, model, eventName));

  // Create get-only macros
  macros2.m.get(publicAPI, model, ['initialized', 'interactorStyle', 'lastFrameTime', 'recentAnimationFrameRate', '_view']);

  // Create get-set macros
  macros2.m.setGet(publicAPI, model, ['container', 'lightFollowCamera', 'enabled', 'enableRender', 'recognizeGestures', 'desiredUpdateRate', 'stillUpdateRate', 'picker', 'preventDefaultOnPointerDown', 'preventDefaultOnPointerUp', 'mouseScrollDebounceByPass']);
  macros2.m.moveToProtected(publicAPI, model, ['view']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkRenderWindowInteractor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const RenderWindowInteractor_newInstance = macros2.m.newInstance(RenderWindowInteractor_extend, 'vtkRenderWindowInteractor');

// ----------------------------------------------------------------------------

var vtkRenderWindowInteractor$1 = {
  newInstance: RenderWindowInteractor_newInstance,
  extend: RenderWindowInteractor_extend,
  handledEvents,
  ...RenderWindowInteractor_Constants_Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Core_Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkOffscreenMultiRenderWindow.js










function vtkOffscreenMultiRenderWindow(publicAPI, model) {
    const invokeResize = publicAPI.invokeResize;
    delete publicAPI.invokeResize;
    model.renderWindow = vtkRenderWindow$1.newInstance();
    model.rendererMap = {};
    model.openGLRenderWindow = vtkClasses_vtkStreamingOpenGLRenderWindow.newInstance();
    model.renderWindow.addView(model.openGLRenderWindow);
    model.interactor = vtkRenderWindowInteractor$1.newInstance();
    model.interactor.setView(model.openGLRenderWindow);
    model.interactor.initialize();
    publicAPI.addRenderer = ({ viewport, id, background }) => {
        const renderer = Core_Renderer/* default.newInstance */.Ay.newInstance({
            viewport,
            background: background || model.background,
        });
        model.renderWindow.addRenderer(renderer);
        model.rendererMap[id] = renderer;
    };
    publicAPI.destroy = () => {
        const rwi = model.renderWindow.getInteractor();
        rwi.delete();
    };
    publicAPI.removeRenderer = (id) => {
        const renderer = publicAPI.getRenderer(id);
        model.renderWindow.removeRenderer(renderer);
        renderer.delete();
        delete model.rendererMap[id];
    };
    publicAPI.getRenderer = (id) => {
        return model.rendererMap[id];
    };
    publicAPI.getRenderers = () => {
        const { rendererMap } = model;
        const renderers = Object.keys(rendererMap).map((id) => {
            return { id, renderer: rendererMap[id] };
        });
        return renderers;
    };
    publicAPI.resize = () => {
        if (model.container) {
            const { width, height } = model.container;
            model.openGLRenderWindow.setSize(Math.floor(width), Math.floor(height));
            invokeResize();
            model.renderWindow.render();
        }
    };
    publicAPI.setContainer = (el) => {
        model.container = el;
        model.openGLRenderWindow.setContainer(model.container);
    };
    publicAPI.delete = macros/* default.chain */.Ay.chain(publicAPI.setContainer, publicAPI.destroy, model.openGLRenderWindow.delete, publicAPI.delete);
    publicAPI.resize();
}
const vtkOffscreenMultiRenderWindow_DEFAULT_VALUES = {
    background: [0.0, 0.0, 0.0],
    container: null,
};
function vtkOffscreenMultiRenderWindow_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkOffscreenMultiRenderWindow_DEFAULT_VALUES, initialValues);
    macros/* default.obj */.Ay.obj(publicAPI, model);
    macros/* default.get */.Ay.get(publicAPI, model, [
        'renderWindow',
        'openGLRenderWindow',
        'interactor',
        'container',
    ]);
    macros/* default.event */.Ay.event(publicAPI, model, 'resize');
    vtkOffscreenMultiRenderWindow(publicAPI, model);
}
const vtkOffscreenMultiRenderWindow_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkOffscreenMultiRenderWindow_extend);
/* harmony default export */ const vtkClasses_vtkOffscreenMultiRenderWindow = ({ newInstance: vtkOffscreenMultiRenderWindow_newInstance, extend: vtkOffscreenMultiRenderWindow_extend });

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js
var Core_VolumeMapper = __webpack_require__(53387);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js


function vtkSharedVolumeMapper(publicAPI, model) {
    model.classHierarchy.push('vtkSharedVolumeMapper');
    const superDelete = publicAPI.delete;
    publicAPI.delete = () => {
        model.scalarTexture = null;
        superDelete();
    };
}
const vtkSharedVolumeMapper_DEFAULT_VALUES = {
    scalarTexture: null,
};
function vtkSharedVolumeMapper_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkSharedVolumeMapper_DEFAULT_VALUES, initialValues);
    Core_VolumeMapper/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    macros/* default.setGet */.Ay.setGet(publicAPI, model, ['scalarTexture']);
    vtkSharedVolumeMapper(publicAPI, model);
}
const vtkSharedVolumeMapper_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkSharedVolumeMapper_extend, 'vtkSharedVolumeMapper');
/* harmony default export */ const vtkClasses_vtkSharedVolumeMapper = ({ newInstance: vtkSharedVolumeMapper_newInstance, extend: vtkSharedVolumeMapper_extend });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkStreamingOpenGLTexture.js




function convertDataType(data, targetDataType) {
    const Constructor = (0,getBufferConfiguration/* getConstructorFromType */.j)(targetDataType);
    const convertedData = new Constructor(data.length);
    convertedData.set(data);
    return convertedData;
}
function vtkStreamingOpenGLTexture(publicAPI, model) {
    model.classHierarchy.push('vtkStreamingOpenGLTexture');
    model.updatedFrames = [];
    model.volumeId = null;
    const superCreate3DFilterableFromRaw = publicAPI.create3DFilterableFromRaw;
    publicAPI.create3DFilterableFromRaw = (width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy) => {
        model.inputDataType = dataType;
        model.inputNumComps = numberOfComponents;
        superCreate3DFilterableFromRaw(width, height, depth, numberOfComponents, dataType, data, preferSizeOverAccuracy);
    };
    const superUpdate = publicAPI.updateVolumeInfoForGL;
    publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
        const isScalingApplied = superUpdate(dataType, numComps);
        model.volumeInfo.dataComputedScale = [1];
        model.volumeInfo.dataComputedOffset = [0];
        return isScalingApplied;
    };
    publicAPI.update3DFromRaw = () => {
        const { volumeId } = model;
        if (!volumeId) {
            return;
        }
        const volume = cache/* default */.Ay.getVolume(volumeId);
        model._openGLRenderWindow.activateTexture(publicAPI);
        publicAPI.createTexture();
        publicAPI.bind();
        if (volume.isDynamicVolume()) {
            updateDynamicVolumeTexture();
            return;
        }
        return (publicAPI.hasUpdatedFrames() && updateTextureImagesUsingVoxelManager());
    };
    const superModified = publicAPI.modified;
    publicAPI.setUpdatedFrame = (frameIndex) => {
        model.updatedFrames[frameIndex] = true;
        superModified();
    };
    publicAPI.modified = () => {
        superModified();
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        if (!volume) {
            return;
        }
        const imageIds = volume.imageIds;
        for (let i = 0; i < imageIds.length; i++) {
            model.updatedFrames[i] = true;
        }
    };
    function updateTextureImagesUsingVoxelManager() {
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        const imageIds = volume.imageIds;
        for (let i = 0; i < model.updatedFrames.length; i++) {
            if (model.updatedFrames[i]) {
                const image = cache/* default */.Ay.getImage(imageIds[i]);
                if (!image) {
                    continue;
                }
                let data = image.voxelManager.getScalarData();
                const gl = model.context;
                if (volume.dataType !== data.constructor.name) {
                    data = convertDataType(data, volume.dataType);
                }
                const [pixData] = publicAPI.updateArrayDataTypeForGL(volume.dataType, [
                    data,
                ]);
                publicAPI.bind();
                const zOffset = i;
                gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
                publicAPI.deactivate();
                model.updatedFrames[i] = null;
            }
        }
        if (model.generateMipmap) {
            model.context.generateMipmap(model.target);
        }
        publicAPI.deactivate();
        return true;
    }
    function updateDynamicVolumeTexture() {
        const volume = cache/* default */.Ay.getVolume(model.volumeId);
        const imageIds = volume.getCurrentDimensionGroupImageIds();
        if (!imageIds.length) {
            return false;
        }
        let constructor;
        for (let i = 0; i < imageIds.length; i++) {
            const imageId = imageIds[i];
            const image = cache/* default */.Ay.getImage(imageId);
            let data;
            if (!image) {
                constructor = (0,getBufferConfiguration/* getConstructorFromType */.j)(volume.dataType, true);
                data = new constructor(model.width * model.height);
            }
            else {
                data = image.voxelManager.getScalarData();
                constructor = data.constructor;
            }
            const gl = model.context;
            if (volume.dataType !== data.constructor.name) {
                data = convertDataType(data, volume.dataType);
            }
            const [pixData] = publicAPI.updateArrayDataTypeForGL(volume.dataType, [
                data,
            ]);
            publicAPI.bind();
            let zOffset = i;
            gl.texSubImage3D(model.target, 0, 0, 0, zOffset, model.width, model.height, 1, model.format, model.openGLDataType, pixData);
            publicAPI.deactivate();
        }
        if (model.generateMipmap) {
            model.context.generateMipmap(model.target);
        }
        publicAPI.deactivate();
        return true;
    }
    publicAPI.hasUpdatedFrames = () => !model.updatedFrames.length || model.updatedFrames.some((frame) => frame);
    publicAPI.getUpdatedFrames = () => model.updatedFrames;
    publicAPI.setVolumeId = (volumeId) => {
        model.volumeId = volumeId;
    };
    publicAPI.getVolumeId = () => model.volumeId;
    publicAPI.setTextureParameters = ({ width, height, depth, numberOfComponents, dataType, }) => {
        model.width ??= width;
        model.height ??= height;
        model.depth ??= depth;
        model.inputNumComps ??= numberOfComponents;
        model.inputDataType ??= dataType;
    };
    publicAPI.getTextureParameters = () => ({
        width: model.width,
        height: model.height,
        depth: model.depth,
        numberOfComponents: model.inputNumComps,
        dataType: model.inputDataType,
    });
}
const vtkStreamingOpenGLTexture_DEFAULT_VALUES = {
    updatedFrames: [],
};
function vtkStreamingOpenGLTexture_extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, vtkStreamingOpenGLTexture_DEFAULT_VALUES, initialValues);
    Texture/* default.extend */.Ay.extend(publicAPI, model, initialValues);
    vtkStreamingOpenGLTexture(publicAPI, model);
}
const vtkStreamingOpenGLTexture_newInstance = macros/* default.newInstance */.Ay.newInstance(vtkStreamingOpenGLTexture_extend, 'vtkStreamingOpenGLTexture');
/* harmony default export */ const vtkClasses_vtkStreamingOpenGLTexture = ({ newInstance: vtkStreamingOpenGLTexture_newInstance, extend: vtkStreamingOpenGLTexture_extend });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/vtkSlabCamera.js
var vtkSlabCamera = __webpack_require__(17232);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/vtkClasses/index.js







/***/ }),

/***/ 17232:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports newInstance, extend */
/* harmony import */ var _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37290);
/* harmony import */ var _kitware_vtk_js_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26719);
/* harmony import */ var _kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84607);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3823);




const DEFAULT_VALUES = {
    isPerformingCoordinateTransformation: false,
};
function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);
    _kitware_vtk_js_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
    _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__/* ["default"].setGet */ .Ay.setGet(publicAPI, model, ['isPerformingCoordinateTransformation']);
    vtkSlabCamera(publicAPI, model);
}
const newInstance = _kitware_vtk_js_macros__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance(extend, 'vtkSlabCamera');
function vtkSlabCamera(publicAPI, model) {
    model.classHierarchy.push('vtkSlabCamera');
    const tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    const tmpvec1 = new Float64Array(3);
    publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
        const result = gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.create */ .pB.create();
        if (model.projectionMatrix) {
            const scale = 1 / model.physicalScale;
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .vec3.set */ .eR.set(tmpvec1, scale, scale, scale);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.copy */ .pB.copy(result, model.projectionMatrix);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.transpose */ .pB.transpose(result, result);
            return result;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.identity */ .pB.identity(tmpMatrix);
        let cRange0 = model.clippingRange[0];
        let cRange1 = model.clippingRange[1];
        if (model.isPerformingCoordinateTransformation) {
            cRange0 = model.distance;
            cRange1 = model.distance + 0.1;
        }
        const cWidth = cRange1 - cRange0;
        const cRange = [
            cRange0 + ((nearz + 1) * cWidth) / 2.0,
            cRange0 + ((farz + 1) * cWidth) / 2.0,
        ];
        if (model.parallelProjection) {
            const width = model.parallelScale * aspect;
            const height = model.parallelScale;
            const xmin = (model.windowCenter[0] - 1.0) * width;
            const xmax = (model.windowCenter[0] + 1.0) * width;
            const ymin = (model.windowCenter[1] - 1.0) * height;
            const ymax = (model.windowCenter[1] + 1.0) * height;
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.ortho */ .pB.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
        }
        else if (model.useOffAxisProjection) {
            throw new Error('Off-Axis projection is not supported at this time');
        }
        else {
            const tmp = Math.tan(_kitware_vtk_js_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__/* ["default"].radiansFromDegrees */ .Ay.radiansFromDegrees(model.viewAngle) / 2.0);
            let width;
            let height;
            if (model.useHorizontalViewAngle === true) {
                width = cRange0 * tmp;
                height = (cRange0 * tmp) / aspect;
            }
            else {
                width = cRange0 * tmp * aspect;
                height = cRange0 * tmp;
            }
            const xmin = (model.windowCenter[0] - 1.0) * width;
            const xmax = (model.windowCenter[0] + 1.0) * width;
            const ymin = (model.windowCenter[1] - 1.0) * height;
            const ymax = (model.windowCenter[1] + 1.0) * height;
            const znear = cRange[0];
            const zfar = cRange[1];
            tmpMatrix[0] = (2.0 * znear) / (xmax - xmin);
            tmpMatrix[5] = (2.0 * znear) / (ymax - ymin);
            tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
            tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
            tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
            tmpMatrix[14] = -1.0;
            tmpMatrix[11] = (-2.0 * znear * zfar) / (zfar - znear);
            tmpMatrix[15] = 0.0;
        }
        gl_matrix__WEBPACK_IMPORTED_MODULE_3__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
        return result;
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ newInstance, extend });



/***/ }),

/***/ 49038:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports Cache, cache */
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69372);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39537);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32643);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71851);
/* harmony import */ var _utilities_fnv1aHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20286);






const ONE_GB = 1073741824;
class Cache {
    constructor() {
        this._imageCache = new Map();
        this._volumeCache = new Map();
        this._imageIdsToVolumeIdCache = new Map();
        this._referencedImageIdToImageIdCache = new Map();
        this._geometryCache = new Map();
        this._imageCacheSize = 0;
        this._maxCacheSize = 3 * ONE_GB;
        this._geometryCacheSize = 0;
        this.setMaxCacheSize = (newMaxCacheSize) => {
            if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {
                const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
                throw new Error(errorMessage);
            }
            this._maxCacheSize = newMaxCacheSize;
        };
        this.isCacheable = (byteLength) => {
            const bytesAvailable = this.getBytesAvailable();
            const purgableImageBytes = Array.from(this._imageCache.values()).reduce((total, image) => {
                if (!image.sharedCacheKey) {
                    return total + image.sizeInBytes;
                }
                return total;
            }, 0);
            const availableSpaceWithoutSharedCacheKey = bytesAvailable + purgableImageBytes;
            return availableSpaceWithoutSharedCacheKey >= byteLength;
        };
        this.getMaxCacheSize = () => this._maxCacheSize;
        this.getCacheSize = () => this._imageCacheSize;
        this._decacheImage = (imageId, force = false) => {
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                return;
            }
            if (cachedImage.sharedCacheKey && !force) {
                throw new Error('Cannot decache an image with a shared cache key. You need to manually decache the volume first.');
            }
            const { imageLoadObject } = cachedImage;
            if (cachedImage.image?.referencedImageId) {
                this._referencedImageIdToImageIdCache.delete(cachedImage.image.referencedImageId);
            }
            if (imageLoadObject?.cancelFn) {
                imageLoadObject.cancelFn();
            }
            if (imageLoadObject?.decache) {
                imageLoadObject.decache();
            }
            this._imageCache.delete(imageId);
        };
        this._decacheVolume = (volumeId) => {
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            const { volumeLoadObject, volume } = cachedVolume;
            if (!volume) {
                return;
            }
            if (volume.cancelLoading) {
                volume.cancelLoading();
            }
            if (volume.imageData) {
                volume.imageData.delete();
            }
            if (volumeLoadObject.cancelFn) {
                volumeLoadObject.cancelFn();
            }
            if (volume.imageIds) {
                volume.imageIds.forEach((imageId) => {
                    const cachedImage = this._imageCache.get(imageId);
                    if (cachedImage && cachedImage.sharedCacheKey === volumeId) {
                        cachedImage.sharedCacheKey = undefined;
                    }
                });
            }
            this._volumeCache.delete(volumeId);
        };
        this.purgeCache = () => {
            const imageIterator = this._imageCache.keys();
            this.purgeVolumeCache();
            while (true) {
                const { value: imageId, done } = imageIterator.next();
                if (done) {
                    break;
                }
                this.removeImageLoadObject(imageId, { force: true });
                (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            }
        };
        this.purgeVolumeCache = () => {
            const volumeIterator = this._volumeCache.keys();
            while (true) {
                const { value: volumeId, done } = volumeIterator.next();
                if (done) {
                    break;
                }
                this.removeVolumeLoadObject(volumeId);
                (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_REMOVED, {
                    volumeId,
                });
            }
        };
        this.getVolumeLoadObject = (volumeId) => {
            if (volumeId === undefined) {
                throw new Error('getVolumeLoadObject: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            cachedVolume.timeStamp = Date.now();
            return cachedVolume.volumeLoadObject;
        };
        this.putGeometryLoadObject = (geometryId, geometryLoadObject) => {
            if (geometryId === undefined) {
                throw new Error('putGeometryLoadObject: geometryId must not be undefined');
            }
            if (geometryLoadObject.promise === undefined) {
                throw new Error('putGeometryLoadObject: geometryLoadObject.promise must not be undefined');
            }
            if (this._geometryCache.has(geometryId)) {
                throw new Error('putGeometryLoadObject: geometryId already present in geometryCache');
            }
            if (geometryLoadObject.cancelFn &&
                typeof geometryLoadObject.cancelFn !== 'function') {
                throw new Error('putGeometryLoadObject: geometryLoadObject.cancel must be a function');
            }
            const cachedGeometry = {
                loaded: false,
                geometryId,
                geometryLoadObject,
                timeStamp: Date.now(),
                sizeInBytes: 0,
            };
            this._geometryCache.set(geometryId, cachedGeometry);
            return geometryLoadObject.promise
                .then((geometry) => {
                try {
                    this._putGeometryCommon(geometryId, geometry, cachedGeometry);
                }
                catch (error) {
                    console.debug(`Error in _putGeometryCommon for geometry ${geometryId}:`, error);
                    throw error;
                }
            })
                .catch((error) => {
                console.debug(`Error caching geometry ${geometryId}:`, error);
                this._geometryCache.delete(geometryId);
                throw error;
            });
        };
        this.getGeometry = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('getGeometry: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            cachedGeometry.timeStamp = Date.now();
            return cachedGeometry.geometry;
        };
        this.removeGeometryLoadObject = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('removeGeometryLoadObject: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                throw new Error('removeGeometryLoadObject: geometryId was not present in geometryCache');
            }
            this.decrementGeometryCacheSize(cachedGeometry.sizeInBytes);
            const eventDetails = {
                geometry: cachedGeometry,
                geometryId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.GEOMETRY_CACHE_GEOMETRY_REMOVED, eventDetails);
            this._decacheGeometry(geometryId);
        };
        this._decacheGeometry = (geometryId) => {
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            const { geometryLoadObject } = cachedGeometry;
            if (geometryLoadObject.cancelFn) {
                geometryLoadObject.cancelFn();
            }
            if (geometryLoadObject.decache) {
                geometryLoadObject.decache();
            }
            this._geometryCache.delete(geometryId);
        };
        this.incrementGeometryCacheSize = (increment) => {
            this._geometryCacheSize += increment;
        };
        this.decrementGeometryCacheSize = (decrement) => {
            this._geometryCacheSize -= decrement;
        };
        this.getImageByReferencedImageId = (referencedImageId) => {
            const imageId = this._referencedImageIdToImageIdCache.get(referencedImageId);
            if (imageId) {
                return this._imageCache.get(imageId)?.image;
            }
            return undefined;
        };
        this.getImage = (imageId, minQuality = _enums__WEBPACK_IMPORTED_MODULE_4__.ImageQualityStatus.FAR_REPLICATE) => {
            if (imageId === undefined) {
                throw new Error('getImage: imageId must not be undefined');
            }
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                return;
            }
            cachedImage.timeStamp = Date.now();
            if (cachedImage.image?.imageQualityStatus < minQuality) {
                return;
            }
            return cachedImage.image;
        };
        this.getVolume = (volumeId, allowPartialMatch = false) => {
            if (volumeId === undefined) {
                throw new Error('getVolume: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return allowPartialMatch
                    ? [...this._volumeCache.values()].find((cv) => cv.volumeId.includes(volumeId))?.volume
                    : undefined;
            }
            cachedVolume.timeStamp = Date.now();
            return cachedVolume.volume;
        };
        this.getVolumes = () => {
            const cachedVolumes = Array.from(this._volumeCache.values());
            return cachedVolumes.map((cachedVolume) => cachedVolume.volume);
        };
        this.filterVolumesByReferenceId = (volumeId) => {
            const cachedVolumes = this.getVolumes();
            return cachedVolumes.filter((volume) => {
                return volume.referencedVolumeId === volumeId;
            });
        };
        this.removeImageLoadObject = (imageId, { force = false } = {}) => {
            if (imageId === undefined) {
                throw new Error('removeImageLoadObject: imageId must not be undefined');
            }
            const cachedImage = this._imageCache.get(imageId);
            if (!cachedImage) {
                throw new Error('removeImageLoadObject: imageId was not present in imageCache');
            }
            this._decacheImage(imageId, force);
            this.incrementImageCacheSize(-cachedImage.sizeInBytes);
            const eventDetails = {
                image: cachedImage,
                imageId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);
        };
        this.removeVolumeLoadObject = (volumeId) => {
            if (volumeId === undefined) {
                throw new Error('removeVolumeLoadObject: volumeId must not be undefined');
            }
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                throw new Error('removeVolumeLoadObject: volumeId was not present in volumeCache');
            }
            const eventDetails = {
                volume: cachedVolume,
                volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);
            this._decacheVolume(volumeId);
        };
        this.incrementImageCacheSize = (increment) => {
            this._imageCacheSize += increment;
        };
        this.decrementImageCacheSize = (decrement) => {
            this._imageCacheSize -= decrement;
        };
        this.getGeometryLoadObject = (geometryId) => {
            if (geometryId === undefined) {
                throw new Error('getGeometryLoadObject: geometryId must not be undefined');
            }
            const cachedGeometry = this._geometryCache.get(geometryId);
            if (!cachedGeometry) {
                return;
            }
            cachedGeometry.timeStamp = Date.now();
            return cachedGeometry.geometryLoadObject;
        };
    }
    generateVolumeId(imageIds) {
        const imageURIs = imageIds.map(_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A).sort();
        let combinedHash = 0x811c9dc5;
        for (const id of imageURIs) {
            const idHash = (0,_utilities_fnv1aHash__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(id);
            for (let i = 0; i < idHash.length; i++) {
                combinedHash ^= idHash.charCodeAt(i);
                combinedHash +=
                    (combinedHash << 1) +
                        (combinedHash << 4) +
                        (combinedHash << 7) +
                        (combinedHash << 8) +
                        (combinedHash << 24);
            }
        }
        return `volume-${(combinedHash >>> 0).toString(36)}`;
    }
    getImageIdsForVolumeId(volumeId) {
        return Array.from(this._imageIdsToVolumeIdCache.entries())
            .filter(([_, id]) => id === volumeId)
            .map(([key]) => key);
    }
    getBytesAvailable() {
        return this.getMaxCacheSize() - this.getCacheSize();
    }
    decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {
        let bytesAvailable = this.getBytesAvailable();
        if (bytesAvailable >= numBytes) {
            return bytesAvailable;
        }
        const cachedImages = Array.from(this._imageCache.values()).filter((cachedImage) => !cachedImage.sharedCacheKey);
        function compare(a, b) {
            if (a.timeStamp > b.timeStamp) {
                return 1;
            }
            if (a.timeStamp < b.timeStamp) {
                return -1;
            }
            return 0;
        }
        cachedImages.sort(compare);
        const cachedImageIds = cachedImages.map((im) => im.imageId);
        let imageIdsToPurge = cachedImageIds;
        if (volumeImageIds) {
            imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));
        }
        for (const imageId of imageIdsToPurge) {
            this.removeImageLoadObject(imageId);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            bytesAvailable = this.getBytesAvailable();
            if (bytesAvailable >= numBytes) {
                return bytesAvailable;
            }
        }
        for (const imageId of cachedImageIds) {
            this.removeImageLoadObject(imageId);
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
            bytesAvailable = this.getBytesAvailable();
            if (bytesAvailable >= numBytes) {
                return bytesAvailable;
            }
        }
    }
    _putImageCommon(imageId, image, cachedImage) {
        if (!this._imageCache.has(imageId)) {
            console.warn('The image was purged from the cache before it completed loading.');
            return;
        }
        if (!image) {
            console.warn('Image is undefined');
            return;
        }
        if (image.sizeInBytes === undefined || Number.isNaN(image.sizeInBytes)) {
            throw new Error('_putImageCommon: image.sizeInBytes must not be undefined');
        }
        if (image.sizeInBytes.toFixed === undefined) {
            throw new Error('_putImageCommon: image.sizeInBytes is not a number');
        }
        if (!this.isCacheable(image.sizeInBytes)) {
            throw new Error(_enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.CACHE_SIZE_EXCEEDED);
        }
        this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);
        cachedImage.loaded = true;
        cachedImage.image = image;
        cachedImage.sizeInBytes = image.sizeInBytes;
        this.incrementImageCacheSize(cachedImage.sizeInBytes);
        const eventDetails = {
            image: cachedImage,
        };
        if (image.referencedImageId) {
            this._referencedImageIdToImageIdCache.set(image.referencedImageId, imageId);
        }
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.IMAGE_CACHE_IMAGE_ADDED, eventDetails);
        cachedImage.sharedCacheKey = image.sharedCacheKey;
    }
    async putImageLoadObject(imageId, imageLoadObject) {
        if (imageId === undefined) {
            console.error('putImageLoadObject: imageId must not be undefined');
            throw new Error('putImageLoadObject: imageId must not be undefined');
        }
        if (imageLoadObject.promise === undefined) {
            console.error('putImageLoadObject: imageLoadObject.promise must not be undefined');
            throw new Error('putImageLoadObject: imageLoadObject.promise must not be undefined');
        }
        const alreadyCached = this._imageCache.get(imageId);
        if (alreadyCached?.imageLoadObject) {
            console.warn(`putImageLoadObject: imageId ${imageId} already in cache`);
            throw new Error('putImageLoadObject: imageId already in cache');
        }
        if (imageLoadObject.cancelFn &&
            typeof imageLoadObject.cancelFn !== 'function') {
            console.error('putImageLoadObject: imageLoadObject.cancel must be a function');
            throw new Error('putImageLoadObject: imageLoadObject.cancel must be a function');
        }
        const cachedImage = {
            ...alreadyCached,
            loaded: false,
            imageId,
            sharedCacheKey: undefined,
            imageLoadObject,
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._imageCache.set(imageId, cachedImage);
        this._imageCache.set(imageId, cachedImage);
        return imageLoadObject.promise
            .then((image) => {
            try {
                this._putImageCommon(imageId, image, cachedImage);
            }
            catch (error) {
                console.debug(`Error in _putImageCommon for image ${imageId}:`, error);
                throw error;
            }
        })
            .catch((error) => {
            console.debug(`Error caching image ${imageId}:`, error);
            this._imageCache.delete(imageId);
            throw error;
        });
    }
    putImageSync(imageId, image) {
        if (imageId === undefined) {
            throw new Error('putImageSync: imageId must not be undefined');
        }
        if (this._imageCache.has(imageId)) {
            throw new Error('putImageSync: imageId already in cache');
        }
        const cachedImage = {
            loaded: false,
            imageId,
            sharedCacheKey: undefined,
            imageLoadObject: {
                promise: Promise.resolve(image),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._imageCache.set(imageId, cachedImage);
        try {
            this._putImageCommon(imageId, image, cachedImage);
        }
        catch (error) {
            this._imageCache.delete(imageId);
            throw error;
        }
    }
    getImageLoadObject(imageId) {
        if (imageId === undefined) {
            throw new Error('getImageLoadObject: imageId must not be undefined');
        }
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            return;
        }
        cachedImage.timeStamp = Date.now();
        return cachedImage.imageLoadObject;
    }
    isLoaded(imageId) {
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            return false;
        }
        return cachedImage.loaded;
    }
    getVolumeContainingImageId(imageId) {
        const volumeIds = Array.from(this._volumeCache.keys());
        const imageIdToUse = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
        for (const volumeId of volumeIds) {
            const cachedVolume = this._volumeCache.get(volumeId);
            if (!cachedVolume) {
                return;
            }
            const { volume } = cachedVolume;
            if (!volume.imageIds.length) {
                return;
            }
            const imageIdIndex = volume.getImageURIIndex(imageIdToUse);
            if (imageIdIndex > -1) {
                return { volume, imageIdIndex };
            }
        }
    }
    getCachedImageBasedOnImageURI(imageId) {
        const imageURIToUse = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
        const cachedImageIds = Array.from(this._imageCache.keys());
        const foundImageId = cachedImageIds.find((imageId) => {
            return (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId) === imageURIToUse;
        });
        if (!foundImageId) {
            return;
        }
        return this._imageCache.get(foundImageId);
    }
    _putVolumeCommon(volumeId, volume, cachedVolume) {
        if (!this._volumeCache.get(volumeId)) {
            console.warn('The volume was purged from the cache before it completed loading.');
            return;
        }
        cachedVolume.loaded = true;
        cachedVolume.volume = volume;
        volume.imageIds?.forEach((imageId) => {
            const image = this._imageCache.get(imageId);
            if (image) {
                image.sharedCacheKey = volumeId;
            }
        });
        const eventDetails = {
            volume: cachedVolume,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.VOLUME_CACHE_VOLUME_ADDED, eventDetails);
    }
    putVolumeSync(volumeId, volume) {
        if (volumeId === undefined) {
            throw new Error('putVolumeSync: volumeId must not be undefined');
        }
        if (this._volumeCache.has(volumeId)) {
            throw new Error('putVolumeSync: volumeId already in cache');
        }
        const cachedVolume = {
            loaded: false,
            volumeId,
            volumeLoadObject: {
                promise: Promise.resolve(volume),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._volumeCache.set(volumeId, cachedVolume);
        try {
            this._putVolumeCommon(volumeId, volume, cachedVolume);
        }
        catch (error) {
            this._volumeCache.delete(volumeId);
            throw error;
        }
    }
    async putVolumeLoadObject(volumeId, volumeLoadObject) {
        if (volumeId === undefined) {
            throw new Error('putVolumeLoadObject: volumeId must not be undefined');
        }
        if (volumeLoadObject.promise === undefined) {
            throw new Error('putVolumeLoadObject: volumeLoadObject.promise must not be undefined');
        }
        if (this._volumeCache.has(volumeId)) {
            throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);
        }
        if (volumeLoadObject.cancelFn &&
            typeof volumeLoadObject.cancelFn !== 'function') {
            throw new Error('putVolumeLoadObject: volumeLoadObject.cancel must be a function');
        }
        const cachedVolume = {
            loaded: false,
            volumeId,
            volumeLoadObject,
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._volumeCache.set(volumeId, cachedVolume);
        return volumeLoadObject.promise
            .then((volume) => {
            try {
                this._putVolumeCommon(volumeId, volume, cachedVolume);
            }
            catch (error) {
                console.error(`Error in _putVolumeCommon for volume ${volumeId}:`, error);
                this._volumeCache.delete(volumeId);
                throw error;
            }
        })
            .catch((error) => {
            this._volumeCache.delete(volumeId);
            throw error;
        });
    }
    _putGeometryCommon(geometryId, geometry, cachedGeometry) {
        if (!this._geometryCache.get(geometryId)) {
            console.warn('The geometry was purged from the cache before it completed loading.');
            return;
        }
        if (!geometry) {
            console.warn('Geometry is undefined');
            return;
        }
        if (geometry.sizeInBytes === undefined ||
            Number.isNaN(geometry.sizeInBytes)) {
            throw new Error('_putGeometryCommon: geometry.sizeInBytes must not be undefined');
        }
        if (geometry.sizeInBytes.toFixed === undefined) {
            throw new Error('_putGeometryCommon: geometry.sizeInBytes is not a number');
        }
        if (!this.isCacheable(geometry.sizeInBytes)) {
            throw new Error(_enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.CACHE_SIZE_EXCEEDED);
        }
        this.decacheIfNecessaryUntilBytesAvailable(geometry.sizeInBytes);
        cachedGeometry.loaded = true;
        cachedGeometry.geometry = geometry;
        cachedGeometry.sizeInBytes = geometry.sizeInBytes;
        this.incrementGeometryCacheSize(cachedGeometry.sizeInBytes);
        const eventDetails = {
            geometry: cachedGeometry,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums_Events__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.GEOMETRY_CACHE_GEOMETRY_ADDED, eventDetails);
    }
    putGeometrySync(geometryId, geometry) {
        if (geometryId === undefined) {
            throw new Error('putGeometrySync: geometryId must not be undefined');
        }
        if (this._geometryCache.has(geometryId)) {
            throw new Error('putGeometrySync: geometryId already in cache');
        }
        const cachedGeometry = {
            loaded: false,
            geometryId,
            geometryLoadObject: {
                promise: Promise.resolve(geometry),
            },
            timeStamp: Date.now(),
            sizeInBytes: 0,
        };
        this._geometryCache.set(geometryId, cachedGeometry);
        try {
            this._putGeometryCommon(geometryId, geometry, cachedGeometry);
        }
        catch (error) {
            this._geometryCache.delete(geometryId);
            throw error;
        }
    }
    setPartialImage(imageId, partialImage) {
        const cachedImage = this._imageCache.get(imageId);
        if (!cachedImage) {
            if (partialImage) {
                this._imageCache.set(imageId, {
                    image: partialImage,
                    imageId,
                    loaded: false,
                    timeStamp: Date.now(),
                    sizeInBytes: 0,
                });
            }
            return;
        }
        if (cachedImage.loaded) {
            cachedImage.loaded = false;
            cachedImage.imageLoadObject = null;
            this.incrementImageCacheSize(-cachedImage.sizeInBytes);
            cachedImage.sizeInBytes = 0;
            cachedImage.image = partialImage || cachedImage.image;
        }
        else {
            cachedImage.image = partialImage || cachedImage.image;
        }
    }
    getImageQuality(imageId) {
        const image = this._imageCache.get(imageId)?.image;
        return image
            ? image.imageQualityStatus || _enums__WEBPACK_IMPORTED_MODULE_4__.ImageQualityStatus.FULL_RESOLUTION
            : undefined;
    }
}
const cache = new Cache();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cache);



/***/ }),

/***/ 35637:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ BaseStreamingImageVolume)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71851);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51159);
/* harmony import */ var _utilities_ProgressiveIterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22191);
/* harmony import */ var _utilities_imageRetrieveMetadataProvider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17791);
/* harmony import */ var _utilities_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30169);
/* harmony import */ var _utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(91979);
/* harmony import */ var _utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69372);
/* harmony import */ var _ImageVolume__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(86252);
/* harmony import */ var _loaders_ProgressiveRetrieveImages__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36822);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(26896);
/* harmony import */ var _loaders_imageLoader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(80068);













const requestTypeDefault = _enums__WEBPACK_IMPORTED_MODULE_1__.RequestType.Prefetch;
class BaseStreamingImageVolume extends _ImageVolume__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(imageVolumeProperties, streamingProperties) {
        super(imageVolumeProperties);
        this.framesLoaded = 0;
        this.framesProcessed = 0;
        this.framesUpdated = 0;
        this.autoRenderOnLoad = true;
        this.cachedFrames = [];
        this.reRenderTarget = 0;
        this.reRenderFraction = 2;
        this.imagesLoader = this;
        this.cancelLoading = () => {
            const { loadStatus } = this;
            if (!loadStatus || !loadStatus.loading) {
                return;
            }
            loadStatus.loading = false;
            loadStatus.cancelled = true;
            this.clearLoadCallbacks();
            const filterFunction = ({ additionalDetails }) => {
                return additionalDetails.volumeId !== this.volumeId;
            };
            _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.filterRequests(filterFunction);
        };
        this.loadStatus = streamingProperties.loadStatus;
    }
    invalidateVolume(immediate) {
        const { vtkOpenGLTexture } = this;
        const { numFrames } = this;
        for (let i = 0; i < numFrames; i++) {
            vtkOpenGLTexture.setUpdatedFrame(i);
        }
        this.modified();
        if (immediate) {
            (0,_utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this.volumeId);
        }
    }
    clearLoadCallbacks() {
        this.loadStatus.callbacks = [];
    }
    callLoadStatusCallback(evt) {
        const { framesUpdated, framesProcessed, totalNumFrames } = evt;
        const { volumeId, reRenderFraction, loadStatus, metadata } = this;
        const { FrameOfReferenceUID } = metadata;
        if (this.autoRenderOnLoad) {
            if (framesUpdated > this.reRenderTarget ||
                framesProcessed === totalNumFrames) {
                this.reRenderTarget += reRenderFraction;
                (0,_utilities_autoLoad__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(volumeId);
            }
        }
        if (framesProcessed === totalNumFrames) {
            loadStatus.callbacks.forEach((callback) => callback(evt));
            const eventDetail = {
                FrameOfReferenceUID,
                volumeId: volumeId,
            };
            (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_VOLUME_LOADING_COMPLETED, eventDetail);
        }
    }
    updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus = _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
        const frameIndex = this.imageIdIndexToFrameIndex(imageIdIndex);
        const { cachedFrames, numFrames, totalNumFrames } = this;
        const { FrameOfReferenceUID } = this.metadata;
        const currentStatus = cachedFrames[frameIndex];
        if (currentStatus > imageQualityStatus) {
            return;
        }
        if (cachedFrames[frameIndex] === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const complete = imageQualityStatus === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION;
        cachedFrames[imageIdIndex] = imageQualityStatus;
        this.framesUpdated++;
        if (complete) {
            this.framesLoaded++;
            this.framesProcessed++;
        }
        const eventDetail = {
            FrameOfReferenceUID,
            volumeId: this.volumeId,
            numberOfFrames: numFrames,
            framesProcessed: this.framesProcessed,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_VOLUME_MODIFIED, eventDetail);
        if (complete && this.framesProcessed === this.totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: true,
            imageIdIndex,
            imageId,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
            complete,
            imageQualityStatus,
        });
        this.vtkOpenGLTexture.setUpdatedFrame(frameIndex);
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
    }
    successCallback(imageId, image) {
        const imageIdIndex = this.getImageIdIndex(imageId);
        const { imageQualityStatus } = image;
        if (this.loadStatus.cancelled) {
            console.warn('volume load cancelled, returning for imageIdIndex: ', imageIdIndex);
            return;
        }
        this.updateTextureAndTriggerEvents(imageIdIndex, imageId, imageQualityStatus);
        if (this.isDynamicVolume()) {
            this.checkDimensionGroupCompletion(imageIdIndex);
        }
    }
    errorCallback(imageId, permanent, error) {
        if (!permanent) {
            return;
        }
        const { totalNumFrames, numFrames } = this;
        const imageIdIndex = this.getImageIdIndex(imageId);
        this.framesProcessed++;
        if (this.framesProcessed === totalNumFrames) {
            this.loadStatus.loaded = true;
            this.loadStatus.loading = false;
        }
        this.callLoadStatusCallback({
            success: false,
            imageId,
            imageIdIndex,
            error,
            framesLoaded: this.framesLoaded,
            framesProcessed: this.framesProcessed,
            framesUpdated: this.framesUpdated,
            numFrames,
            totalNumFrames,
        });
        if (this.loadStatus.loaded) {
            this.loadStatus.callbacks = [];
        }
        const eventDetail = {
            error,
            imageIdIndex,
            imageId,
        };
        (0,_utilities_triggerEvent__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_LOAD_ERROR, eventDetail);
    }
    load(callback) {
        const { imageIds, loadStatus, numFrames } = this;
        const { transferSyntaxUID } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('transferSyntax', imageIds[0]) || {};
        const imageRetrieveConfiguration = _metaData__WEBPACK_IMPORTED_MODULE_0__.get(_utilities_imageRetrieveMetadataProvider__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.IMAGE_RETRIEVE_CONFIGURATION, this.volumeId, transferSyntaxUID, 'volume');
        this.imagesLoader = this.isDynamicVolume()
            ? this
            : imageRetrieveConfiguration
                ? (imageRetrieveConfiguration.create ||
                    _loaders_ProgressiveRetrieveImages__WEBPACK_IMPORTED_MODULE_10__/* ["default"].createProgressive */ .Ay.createProgressive)(imageRetrieveConfiguration)
                : this;
        if (loadStatus.loading === true) {
            return;
        }
        const { loaded } = this.loadStatus;
        const totalNumFrames = imageIds.length;
        if (loaded) {
            if (callback) {
                callback({
                    success: true,
                    framesLoaded: totalNumFrames,
                    framesProcessed: totalNumFrames,
                    numFrames,
                    totalNumFrames,
                });
            }
            return;
        }
        if (callback) {
            this.loadStatus.callbacks.push(callback);
        }
        this._prefetchImageIds();
    }
    getLoaderImageOptions(imageId) {
        const { transferSyntaxUID: transferSyntaxUID } = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('transferSyntax', imageId) || {};
        const imagePlaneModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('imagePlaneModule', imageId) || {};
        const { rows, columns } = imagePlaneModule;
        const imageIdIndex = this.getImageIdIndex(imageId);
        const modalityLutModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('modalityLutModule', imageId) || {};
        const generalSeriesModule = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('generalSeriesModule', imageId) || {};
        const scalingParameters = {
            rescaleSlope: modalityLutModule.rescaleSlope,
            rescaleIntercept: modalityLutModule.rescaleIntercept,
            modality: generalSeriesModule.modality,
        };
        const modality = scalingParameters.modality;
        if (modality === 'PT' || modality === 'RTDOSE') {
            const scalingFactor = _metaData__WEBPACK_IMPORTED_MODULE_0__.get('scalingModule', imageId);
            if (scalingFactor) {
                this._addScalingToVolume(scalingFactor);
                Object.assign(scalingParameters, scalingFactor);
            }
        }
        const floatAfterScale = (0,_utilities_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_6__/* .hasFloatScalingParameters */ .a)(scalingParameters);
        const allowFloatRendering = (0,_init__WEBPACK_IMPORTED_MODULE_11__/* .canRenderFloatTextures */ .lk)();
        this.isPreScaled = true;
        if (scalingParameters &&
            scalingParameters.rescaleSlope !== undefined &&
            scalingParameters.rescaleIntercept !== undefined) {
            const { rescaleSlope, rescaleIntercept } = scalingParameters;
            this.isPreScaled =
                typeof rescaleSlope === 'number' &&
                    typeof rescaleIntercept === 'number';
        }
        if (!allowFloatRendering && floatAfterScale) {
            this.isPreScaled = false;
        }
        const targetBuffer = {
            type: this.dataType,
            rows,
            columns,
        };
        return {
            targetBuffer,
            allowFloatRendering,
            preScale: {
                enabled: this.isPreScaled,
                scalingParameters,
            },
            transferPixelData: true,
            requestType: requestTypeDefault,
            transferSyntaxUID,
            additionalDetails: {
                imageId,
                imageIdIndex,
                volumeId: this.volumeId,
            },
        };
    }
    callLoadImage(imageId, imageIdIndex, options) {
        const { cachedFrames } = this;
        if (cachedFrames[imageIdIndex] === _enums__WEBPACK_IMPORTED_MODULE_1__.ImageQualityStatus.FULL_RESOLUTION) {
            return;
        }
        const handleImageCacheAdded = (event) => {
            const { image } = event.detail;
            if (image.imageId === imageId) {
                this.vtkOpenGLTexture.setUpdatedFrame(imageIdIndex);
                _eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.removeEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
            }
        };
        _eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.addEventListener(_enums__WEBPACK_IMPORTED_MODULE_1__.Events.IMAGE_CACHE_IMAGE_ADDED, handleImageCacheAdded);
        const uncompressedIterator = _utilities_ProgressiveIterator__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.as((0,_loaders_imageLoader__WEBPACK_IMPORTED_MODULE_12__.loadAndCacheImage)(imageId, options));
        return uncompressedIterator.forEach((image) => {
            this.successCallback(imageId, image);
        }, this.errorCallback.bind(this, imageIdIndex, imageId));
    }
    getImageIdsRequests(imageIds, priorityDefault) {
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        const requests = imageIds.map((imageId) => {
            const imageIdIndex = this.getImageIdIndex(imageId);
            const requestType = requestTypeDefault;
            const priority = priorityDefault;
            const options = this.getLoaderImageOptions(imageId);
            return {
                callLoadImage: this.callLoadImage.bind(this),
                imageId,
                imageIdIndex,
                options,
                priority,
                requestType,
                additionalDetails: {
                    volumeId: this.volumeId,
                },
            };
        });
        return requests;
    }
    getImageLoadRequests(priority) {
        throw new Error('Abstract method');
    }
    getImageIdsToLoad() {
        throw new Error('Abstract method');
    }
    loadImages() {
        this.loadStatus.loading = true;
        const requests = this.getImageLoadRequests(5);
        requests.reverse().forEach((request) => {
            if (!request) {
                return;
            }
            const { callLoadImage, imageId, imageIdIndex, options, priority, requestType, additionalDetails, } = request;
            _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.addRequest(callLoadImage.bind(this, imageId, imageIdIndex, options), requestType, additionalDetails, priority);
        });
        return Promise.resolve(true);
    }
    _prefetchImageIds() {
        this.loadStatus.loading = true;
        const imageIds = [...this.getImageIdsToLoad()];
        this.totalNumFrames = this.imageIds.length;
        const autoRenderPercentage = 2;
        if (this.autoRenderOnLoad) {
            this.reRenderFraction =
                this.totalNumFrames * (autoRenderPercentage / 100);
            this.reRenderTarget = this.reRenderFraction;
        }
        return this.imagesLoader.loadImages(imageIds, this).catch((e) => {
            console.debug('progressive loading failed to complete', e);
        });
    }
    _addScalingToVolume(suvFactor) {
        if (this.scaling) {
            return;
        }
        const { suvbw, suvlbm, suvbsa } = suvFactor;
        const petScaling = {};
        if (suvlbm) {
            petScaling.suvbwToSuvlbm = suvlbm / suvbw;
        }
        if (suvbsa) {
            petScaling.suvbwToSuvbsa = suvbsa / suvbw;
        }
        if (suvbw) {
            petScaling.suvbw = suvbw;
        }
        this.scaling = { PT: petScaling };
    }
    checkDimensionGroupCompletion(imageIdIndex) { }
}


/***/ }),

/***/ 86252:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   Q: () => (/* binding */ ImageVolume)
/* harmony export */ });
/* harmony import */ var _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58498);
/* harmony import */ var _utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39537);
/* harmony import */ var _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24623);
/* harmony import */ var _RenderingEngine_vtkClasses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42295);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49038);





class ImageVolume {
    constructor(props) {
        this._imageIdsIndexMap = new Map();
        this._imageURIsIndexMap = new Map();
        this.cornerstoneImageMetaData = null;
        this.isPreScaled = false;
        this.numTimePoints = null;
        this.numFrames = null;
        const { imageIds, scaling, dimensions, spacing, origin, direction, dataType, volumeId, referencedVolumeId, metadata, referencedImageIds, additionalDetails, voxelManager, numberOfComponents, } = props;
        if (!dataType) {
            throw new Error('Data type is required, please provide a data type as string such as "Uint8Array", "Float32Array", etc.');
        }
        let { imageData } = props;
        this.imageIds = imageIds;
        this.volumeId = volumeId;
        this.metadata = metadata;
        this.dimensions = dimensions;
        this.spacing = spacing;
        this.origin = origin;
        this.direction = direction;
        this.dataType = dataType;
        this.vtkOpenGLTexture = _RenderingEngine_vtkClasses__WEBPACK_IMPORTED_MODULE_3__/* .vtkStreamingOpenGLTexture */ .uT.newInstance();
        this.vtkOpenGLTexture.setVolumeId(volumeId);
        this.voxelManager =
            voxelManager ??
                _utilities_VoxelManager__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.createImageVolumeVoxelManager({
                    dimensions,
                    imageIds,
                    numberOfComponents,
                });
        this.numVoxels =
            this.dimensions[0] * this.dimensions[1] * this.dimensions[2];
        if (!imageData) {
            imageData = _kitware_vtk_js_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_0__/* ["default"].newInstance */ .Ay.newInstance();
            imageData.setDimensions(dimensions);
            imageData.setSpacing(spacing);
            imageData.setDirection(direction);
            imageData.setOrigin(origin);
        }
        imageData.set({
            dataType: dataType,
            voxelManager: this.voxelManager,
            id: volumeId,
            numberOfComponents: numberOfComponents || 1,
        });
        imageData.set({
            hasScalarVolume: false,
        });
        this.imageData = imageData;
        this.numFrames = this._getNumFrames();
        this._reprocessImageIds();
        if (scaling) {
            this.scaling = scaling;
        }
        if (referencedVolumeId) {
            this.referencedVolumeId = referencedVolumeId;
        }
        if (referencedImageIds) {
            this.referencedImageIds = referencedImageIds;
        }
        if (additionalDetails) {
            this.additionalDetails = additionalDetails;
        }
    }
    get sizeInBytes() {
        return this.voxelManager.sizeInBytes;
    }
    get imageIds() {
        return this._imageIds;
    }
    set imageIds(newImageIds) {
        this._imageIds = newImageIds;
        this._reprocessImageIds();
    }
    _reprocessImageIds() {
        this._imageIdsIndexMap.clear();
        this._imageURIsIndexMap.clear();
        this._imageIds.forEach((imageId, i) => {
            const imageURI = (0,_utilities_imageIdToURI__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageId);
            this._imageIdsIndexMap.set(imageId, i);
            this._imageURIsIndexMap.set(imageURI, i);
        });
    }
    isDynamicVolume() {
        return this.numTimePoints > 1;
    }
    getImageIdIndex(imageId) {
        return this._imageIdsIndexMap.get(imageId);
    }
    getImageIdByIndex(imageIdIndex) {
        return this._imageIds[imageIdIndex];
    }
    getImageURIIndex(imageURI) {
        return this._imageURIsIndexMap.get(imageURI);
    }
    load(callback) {
    }
    destroy() {
        this.imageData.delete();
        this.imageData = null;
        this.voxelManager.clear();
        this.vtkOpenGLTexture.releaseGraphicsResources();
        this.vtkOpenGLTexture.delete();
    }
    invalidate() {
        for (let i = 0; i < this.imageIds.length; i++) {
            this.vtkOpenGLTexture.setUpdatedFrame(i);
        }
        this.imageData.modified();
    }
    modified() {
        this.imageData.modified();
        this.vtkOpenGLTexture.modified();
        this.numFrames = this._getNumFrames();
    }
    removeFromCache() {
        _cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.removeVolumeLoadObject(this.volumeId);
    }
    getScalarDataLength() {
        return this.voxelManager.getScalarDataLength();
    }
    _getNumFrames() {
        if (!this.isDynamicVolume()) {
            return this.imageIds.length;
        }
        return this.numTimePoints;
    }
    imageIdIndexToFrameIndex(imageIdIndex) {
        return imageIdIndex % this.numFrames;
    }
    getCornerstoneImages() {
        const { imageIds } = this;
        return imageIds.map((imageId) => {
            return _cache__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getImage(imageId);
        });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageVolume);


/***/ }),

/***/ 29625:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  e: () => (/* binding */ Mesh)
});

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/BinaryHelper.js
var BinaryHelper = __webpack_require__(56413);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var DataAccessHelper = __webpack_require__(8906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js + 1 modules
var LiteHttpDataAccessHelper = __webpack_require__(67313);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/Geometry/PLYReader.js







// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

const PLYFormats = {
  ASCII: 'ascii',
  BINARY_BIG_ENDIAN: 'binary_big_endian',
  BINARY_LITTLE_ENDIAN: 'binary_little_endian'
};
const mapping = {
  diffuse_red: 'red',
  diffuse_green: 'green',
  diffuse_blue: 'blue'
};
const patterns = {
  patternHeader: /ply([\s\S]*)end_header\r?\n/,
  patternBody: /end_header\s([\s\S]*)$/
};
function parseHeader(data) {
  let headerText = '';
  let headerLength = 0;
  const result = patterns.patternHeader.exec(data);
  if (result !== null) {
    headerText = result[1];
    headerLength = result[0].length;
  }
  const header = {
    comments: [],
    elements: [],
    headerLength
  };
  const lines = headerText.split('\n');
  let elem;
  let lineType;
  let lineValues;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    line = line.trim();
    if (line !== '') {
      let property;
      lineValues = line.split(/\s+/);
      lineType = lineValues.shift();
      line = lineValues.join(' ');
      switch (lineType) {
        case 'format':
          header.format = lineValues[0];
          header.version = lineValues[1];
          break;
        case 'comment':
          header.comments.push(line);
          break;
        case 'element':
          if (elem !== undefined) {
            header.elements.push(elem);
          }
          elem = {};
          elem.name = lineValues[0];
          elem.count = parseInt(lineValues[1], 10);
          elem.properties = [];
          break;
        case 'property':
          property = {
            type: lineValues[0]
          };
          if (property.type === 'list') {
            property.name = lineValues[3];
            property.countType = lineValues[1];
            property.itemType = lineValues[2];
          } else {
            property.name = lineValues[1];
          }
          if (property.name in mapping) {
            property.name = mapping[property.name];
          }
          elem.properties.push(property);
          break;
        case 'obj_info':
          header.objInfo = line;
          break;
        default:
          console.warn('unhandled', lineType, lineValues);
          break;
      }
    }
  }
  if (elem !== undefined) {
    header.elements.push(elem);
  }
  return header;
}
function postProcess(buffer, elements) {
  const vertElement = elements.find(element => element.name === 'vertex');
  const faceElement = elements.find(element => element.name === 'face');
  let nbVerts = 0;
  let nbFaces = 0;
  if (vertElement) {
    nbVerts = vertElement.count;
  }
  if (faceElement) {
    nbFaces = faceElement.count;
  }
  const pointValues = new Float32Array(nbVerts * 3);
  const colorArray = new Uint8Array(nbVerts * 3);
  const tcoordsArray = new Float32Array(nbVerts * 2);
  const normalsArray = new Float32Array(nbVerts * 3);
  const hasColor = buffer.colors.length > 0;
  const hasVertTCoords = buffer.uvs.length > 0;
  const hasNorms = buffer.normals.length > 0;
  const hasFaceTCoords = buffer.faceVertexUvs.length > 0;
  for (let vertIdx = 0; vertIdx < nbVerts; vertIdx++) {
    let a = vertIdx * 3 + 0;
    let b = vertIdx * 3 + 1;
    const c = vertIdx * 3 + 2;
    pointValues[a] = buffer.vertices[a];
    pointValues[b] = buffer.vertices[b];
    pointValues[c] = buffer.vertices[c];
    if (hasColor) {
      colorArray[a] = buffer.colors[a];
      colorArray[b] = buffer.colors[b];
      colorArray[c] = buffer.colors[c];
    }
    if (hasVertTCoords) {
      a = vertIdx * 2 + 0;
      b = vertIdx * 2 + 1;
      tcoordsArray[a] = buffer.uvs[a];
      tcoordsArray[b] = buffer.uvs[b];
    }
    if (hasNorms) {
      normalsArray[a] = buffer.normals[a];
      normalsArray[b] = buffer.normals[b];
      normalsArray[c] = buffer.normals[c];
    }
  }
  if (!hasVertTCoords && hasFaceTCoords) {
    // don't use array.shift, because buffer.indices will be used later
    let idxVerts = 0;
    let idxCoord = 0;
    for (let faceIdx = 0; faceIdx < nbFaces; ++faceIdx) {
      const nbFaceVerts = buffer.indices[idxVerts++];
      const texcoords = buffer.faceVertexUvs[idxCoord++];
      if (texcoords && nbFaceVerts * 2 === texcoords.length) {
        // grab the vertex index
        for (let vertIdx = 0; vertIdx < nbFaceVerts; ++vertIdx) {
          const vert = buffer.indices[idxVerts++];
          // new texture stored at the current face
          tcoordsArray[vert * 2 + 0] = texcoords[vertIdx * 2 + 0];
          tcoordsArray[vert * 2 + 1] = texcoords[vertIdx * 2 + 1];
        }
      } else {
        idxVerts += nbFaceVerts;
      }
    }
  }
  const polydata = PolyData/* default.newInstance */.Ay.newInstance();
  polydata.getPoints().setData(pointValues, 3);
  if (hasColor) {
    polydata.getPointData().setScalars(DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 3,
      values: colorArray,
      name: 'Scalars'
    }));
  }
  if (hasVertTCoords || hasFaceTCoords) {
    const da = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoordsArray,
      name: 'TextureCoordinates'
    });
    const cpd = polydata.getPointData();
    cpd.addArray(da);
    cpd.setActiveTCoords(da.getName());
  }
  if (hasNorms) {
    polydata.getPointData().setNormals(DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 3,
      name: 'Normals',
      values: normalsArray
    }));
  }
  polydata.getPolys().setData(Uint32Array.from(buffer.indices));
  return polydata;
}
function parseNumber(n, type) {
  let r;
  switch (type) {
    case 'char':
    case 'uchar':
    case 'short':
    case 'ushort':
    case 'int':
    case 'uint':
    case 'int8':
    case 'uint8':
    case 'int16':
    case 'uint16':
    case 'int32':
    case 'uint32':
      r = parseInt(n, 10);
      break;
    case 'float':
    case 'double':
    case 'float32':
    case 'float64':
      r = parseFloat(n);
      break;
    default:
      console.log('Unsupported type');
      break;
  }
  return r;
}
function parseElement(properties, line) {
  const values = line.split(/\s+/);
  const element = {};
  for (let i = 0; i < properties.length; i++) {
    if (properties[i].type === 'list') {
      const list = [];
      const n = parseNumber(values.shift(), properties[i].countType);
      for (let j = 0; j < n; j++) {
        list.push(parseNumber(values.shift(), properties[i].itemType));
      }
      element[properties[i].name] = list;
    } else {
      element[properties[i].name] = parseNumber(values.shift(), properties[i].type);
    }
  }
  return element;
}
function handleElement(buffer, name, element) {
  if (name === 'vertex') {
    buffer.vertices.push(element.x, element.y, element.z);

    // Normals
    if ('nx' in element && 'ny' in element && 'nz' in element) {
      buffer.normals.push(element.nx, element.ny, element.nz);
    }

    // Uvs
    if ('s' in element && 't' in element) {
      buffer.uvs.push(element.s, element.t);
    } else if ('u' in element && 'v' in element) {
      buffer.uvs.push(element.u, element.v);
    } else if ('texture_u' in element && 'texture_v' in element) {
      buffer.uvs.push(element.texture_u, element.texture_v);
    }

    // Colors
    if ('red' in element && 'green' in element && 'blue' in element) {
      buffer.colors.push(element.red, element.green, element.blue);
    }
  } else if (name === 'face') {
    const vertexIndices = element.vertex_indices || element.vertex_index;
    const texcoord = element.texcoord;
    if (vertexIndices && vertexIndices.length > 0) {
      buffer.indices.push(vertexIndices.length);
      vertexIndices.forEach((val, idx) => {
        buffer.indices.push(val);
      });
    }
    buffer.faceVertexUvs.push(texcoord);
  }
}
function binaryRead(dataview, at, type, littleEndian) {
  let r;
  switch (type) {
    case 'int8':
    case 'char':
      r = [dataview.getInt8(at), 1];
      break;
    case 'uint8':
    case 'uchar':
      r = [dataview.getUint8(at), 1];
      break;
    case 'int16':
    case 'short':
      r = [dataview.getInt16(at, littleEndian), 2];
      break;
    case 'uint16':
    case 'ushort':
      r = [dataview.getUint16(at, littleEndian), 2];
      break;
    case 'int32':
    case 'int':
      r = [dataview.getInt32(at, littleEndian), 4];
      break;
    case 'uint32':
    case 'uint':
      r = [dataview.getUint32(at, littleEndian), 4];
      break;
    case 'float32':
    case 'float':
      r = [dataview.getFloat32(at, littleEndian), 4];
      break;
    case 'float64':
    case 'double':
      r = [dataview.getFloat64(at, littleEndian), 8];
      break;
    default:
      console.log('Unsupported type');
      break;
  }
  return r;
}
function binaryReadElement(dataview, at, properties, littleEndian) {
  const element = {};
  let result;
  let read = 0;
  for (let i = 0; i < properties.length; i++) {
    if (properties[i].type === 'list') {
      const list = [];
      result = binaryRead(dataview, at + read, properties[i].countType, littleEndian);
      const n = result[0];
      read += result[1];
      for (let j = 0; j < n; j++) {
        result = binaryRead(dataview, at + read, properties[i].itemType, littleEndian);
        list.push(result[0]);
        read += result[1];
      }
      element[properties[i].name] = list;
    } else {
      result = binaryRead(dataview, at + read, properties[i].type, littleEndian);
      element[properties[i].name] = result[0];
      read += result[1];
    }
  }
  return [element, read];
}

// ----------------------------------------------------------------------------
// vtkPLYReader methods
// ----------------------------------------------------------------------------

function vtkPLYReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPLYReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper/* default.get */.Ay.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      compression,
      progressCallback
    } = model;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }

  // Set DataSet url
  publicAPI.setUrl = function (url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      binary: true
    };
    model.url = url;

    // Remove the file in the URL
    const path = url.split('/');
    path.pop();
    model.baseURL = path.join('/');
    model.compression = option.compression;

    // Fetch metadata
    return publicAPI.loadData({
      progressCallback: option.progressCallback,
      binary: !!option.binary
    });
  };

  // Fetch the actual data arrays
  publicAPI.loadData = function () {
    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = content => {
    if (typeof content === 'string') {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsArrayBuffer(content);
    }
  };
  publicAPI.parseAsArrayBuffer = content => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }

    // Header
    const text = BinaryHelper/* default */.A.arrayBufferToString(content);
    const header = parseHeader(text);

    // ascii/binary detection
    const isBinary = header.format !== PLYFormats.ASCII;

    // Check if ascii format
    if (!isBinary) {
      publicAPI.parseAsText(content);
      return;
    }
    model.parseData = content;

    // Binary parsing
    const buffer = {
      indices: [],
      vertices: [],
      normals: [],
      uvs: [],
      faceVertexUvs: [],
      colors: []
    };
    const littleEndian = header.format === PLYFormats.BINARY_LITTLE_ENDIAN;
    const arraybuffer = content instanceof ArrayBuffer ? content : content.buffer;
    const body = new DataView(arraybuffer, header.headerLength);
    let result;
    let loc = 0;
    for (let elem = 0; elem < header.elements.length; elem++) {
      for (let idx = 0; idx < header.elements[elem].count; idx++) {
        result = binaryReadElement(body, loc, header.elements[elem].properties, littleEndian);
        loc += result[1];
        const element = result[0];
        handleElement(buffer, header.elements[elem].name, element);
      }
    }
    const polydata = postProcess(buffer, header.elements);

    // Add new output
    model.output[0] = polydata;
  };
  publicAPI.parseAsText = content => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;

    // Header
    const text = BinaryHelper/* default */.A.arrayBufferToString(content);
    const header = parseHeader(text);

    // ascii/binary detection
    const isBinary = header.format !== PLYFormats.ASCII;

    // Check if ascii format
    if (isBinary) {
      publicAPI.parseAsArrayBuffer(content);
      return;
    }

    // Text parsing
    const buffer = {
      indices: [],
      vertices: [],
      normals: [],
      uvs: [],
      faceVertexUvs: [],
      colors: []
    };
    const result = patterns.patternBody.exec(text);
    let body = '';
    if (result !== null) {
      body = result[1];
    }
    const lines = body.split('\n');
    let elem = 0;
    let idx = 0;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      line = line.trim();
      if (line !== '') {
        if (idx >= header.elements[elem].count) {
          elem++;
          idx = 0;
        }
        const element = parseElement(header.elements[elem].properties, line);
        handleElement(buffer, header.elements[elem].name, element);
        idx++;
      }
    }
    const polydata = postProcess(buffer, header.elements);

    // Add new output
    model.output[0] = polydata;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['url', 'baseURL']);
  macros2.m.setGet(publicAPI, model, ['dataAccessHelper']);
  macros2.m.algo(publicAPI, model, 0, 1);

  // vtkPLYReader methods
  vtkPLYReader(publicAPI, model);

  // To support destructuring
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkPLYReader');

// ----------------------------------------------------------------------------

var vtkPLYReader$1 = {
  extend,
  newInstance
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var MatrixBuilder = __webpack_require__(89265);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/Geometry/STLReader.js








// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

const {
  vtkErrorMacro
} = macros2.m;
function STLReader_parseHeader(headerString) {
  const headerSubStr = headerString.split(' ');
  const fieldValues = headerSubStr.filter(e => e.indexOf('=') > -1);
  const header = {};
  for (let i = 0; i < fieldValues.length; ++i) {
    const fieldValueStr = fieldValues[i];
    const fieldValueSubStr = fieldValueStr.split('=');
    if (fieldValueSubStr.length === 2) {
      header[fieldValueSubStr[0]] = fieldValueSubStr[1];
    }
  }
  return header;
}
function addValuesToArray(src, dst) {
  for (let i = 0; i < src.length; i++) {
    dst.push(src[i]);
  }
}

// facet normal ni nj nk
//     outer loop
//         vertex v1x v1y v1z
//         vertex v2x v2y v2z
//         vertex v3x v3y v3z
//     endloop
// endfacet
function readTriangle(lines, offset, points, cellArray, cellNormals) {
  const normalLine = lines[offset];
  if (normalLine === undefined) {
    return -1;
  }
  if (normalLine.indexOf('endfacet') !== -1) {
    return offset + 1;
  }
  if (normalLine.indexOf('facet') === -1) {
    return offset + 1; // Move to next line
  }

  let nbVertex = 0;
  let nbConsumedLines = 2;
  const firstVertexIndex = points.length / 3;
  const normal = normalLine.split(/[ \t]+/).filter(i => i).slice(-3).map(Number);
  addValuesToArray(normal, cellNormals);
  while (lines[offset + nbConsumedLines].indexOf('vertex') !== -1) {
    const line = lines[offset + nbConsumedLines];
    const coords = line.split(/[ \t]+/).filter(i => i).slice(-3).map(Number);
    addValuesToArray(coords, points);
    nbVertex++;
    nbConsumedLines++;
  }
  cellArray.push(nbVertex);
  for (let i = 0; i < nbVertex; i++) {
    cellArray.push(firstVertexIndex + i);
  }
  while (lines[offset + nbConsumedLines] && lines[offset + nbConsumedLines].indexOf('endfacet') !== -1) {
    nbConsumedLines++;
  }
  // +1 (endfacet) +1 (next facet)
  return offset + nbConsumedLines + 2;
}

// ----------------------------------------------------------------------------
// vtkSTLReader methods
// ----------------------------------------------------------------------------

function vtkSTLReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSTLReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper/* default.get */.Ay.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const compression = option.compression !== undefined ? option.compression : model.compression;
    const progressCallback = option.progressCallback !== undefined ? option.progressCallback : model.progressCallback;
    if (option.binary) {
      return model.dataAccessHelper.fetchBinary(url, {
        compression,
        progressCallback
      });
    }
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  function removeDuplicateVertices(tolerance) {
    const polydata = model.output[0];
    const points = polydata.getPoints().getData();
    const faces = polydata.getPolys().getData();
    if (!points || !faces) {
      console.warn('No valid polydata.');
      return;
    }
    const vMap = new Map();
    const vIndexMap = new Map();
    let vInc = 0;
    let pointsChanged = false;
    for (let i = 0; i < points.length; i += 3) {
      const k1 = (points[i] * 10 ** tolerance).toFixed(0);
      const k2 = (points[i + 1] * 10 ** tolerance).toFixed(0);
      const k3 = (points[i + 2] * 10 ** tolerance).toFixed(0);
      const key = `${k1},${k2},${k3}`;
      if (vMap.get(key) !== undefined) {
        vIndexMap.set(i / 3, vMap.get(key));
        pointsChanged = true;
      } else {
        vIndexMap.set(i / 3, vInc);
        vMap.set(key, vInc);
        vInc++;
      }
    }
    const outVerts = new Float32Array(vMap.size * 3);
    const keys = Array.from(vMap.keys());
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      const j = vMap.get(k) * 3;
      const coords = k.split(',').map(e => +e * 10 ** -tolerance);
      outVerts[j] = coords[0];
      outVerts[j + 1] = coords[1];
      outVerts[j + 2] = coords[2];
    }
    const outFaces = new Int32Array(faces);
    for (let i = 0; i < faces.length; i += 4) {
      outFaces[i] = 3;
      outFaces[i + 1] = vIndexMap.get(faces[i + 1]);
      outFaces[i + 2] = vIndexMap.get(faces[i + 2]);
      outFaces[i + 3] = vIndexMap.get(faces[i + 3]);
    }
    polydata.getPoints().setData(outVerts);
    polydata.getPolys().setData(outFaces);
    if (pointsChanged) {
      publicAPI.modified();
    }
  }

  // Set DataSet url
  publicAPI.setUrl = function (url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      binary: true
    };
    model.url = url;

    // Remove the file in the URL
    const path = url.split('/');
    path.pop();
    model.baseURL = path.join('/');

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = function () {
    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const promise = fetchData(model.url, option);
    promise.then(publicAPI.parse);
    return promise;
  };
  publicAPI.parse = content => {
    if (typeof content === 'string') {
      publicAPI.parseAsText(content);
    } else {
      publicAPI.parseAsArrayBuffer(content);
    }
  };
  publicAPI.parseAsArrayBuffer = content => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;

    // ascii/binary detection
    let isBinary = false;
    // 80=STL header, 4=uint32 of num of triangles (le)
    const dview = new DataView(content, 0, 80 + 4);
    const numTriangles = dview.getUint32(80, true);
    // 50 bytes per triangle
    isBinary = 84 + numTriangles * 50 === content.byteLength;

    // Check if ascii format
    if (!isBinary) {
      publicAPI.parseAsText(BinaryHelper/* default */.A.arrayBufferToString(content));
      return;
    }

    // Binary parsing
    // Header
    const headerData = content.slice(0, 80);
    const headerStr = BinaryHelper/* default */.A.arrayBufferToString(headerData);
    const header = STLReader_parseHeader(headerStr);

    // Data
    const dataView = new DataView(content, 84);
    // global.dataview = dataView;
    const nbFaces = (content.byteLength - 84) / 50;
    const pointValues = new Float32Array(nbFaces * 9);
    const normalValues = new Float32Array(nbFaces * 3);
    const cellValues = new Uint32Array(nbFaces * 4);
    const cellDataValues = new Uint16Array(nbFaces);
    let cellOffset = 0;
    for (let faceIdx = 0; faceIdx < nbFaces; faceIdx++) {
      const offset = faceIdx * 50;
      normalValues[faceIdx * 3 + 0] = dataView.getFloat32(offset + 0, true);
      normalValues[faceIdx * 3 + 1] = dataView.getFloat32(offset + 4, true);
      normalValues[faceIdx * 3 + 2] = dataView.getFloat32(offset + 8, true);
      pointValues[faceIdx * 9 + 0] = dataView.getFloat32(offset + 12, true);
      pointValues[faceIdx * 9 + 1] = dataView.getFloat32(offset + 16, true);
      pointValues[faceIdx * 9 + 2] = dataView.getFloat32(offset + 20, true);
      pointValues[faceIdx * 9 + 3] = dataView.getFloat32(offset + 24, true);
      pointValues[faceIdx * 9 + 4] = dataView.getFloat32(offset + 28, true);
      pointValues[faceIdx * 9 + 5] = dataView.getFloat32(offset + 32, true);
      pointValues[faceIdx * 9 + 6] = dataView.getFloat32(offset + 36, true);
      pointValues[faceIdx * 9 + 7] = dataView.getFloat32(offset + 40, true);
      pointValues[faceIdx * 9 + 8] = dataView.getFloat32(offset + 44, true);
      cellValues[cellOffset++] = 3;
      cellValues[cellOffset++] = faceIdx * 3 + 0;
      cellValues[cellOffset++] = faceIdx * 3 + 1;
      cellValues[cellOffset++] = faceIdx * 3 + 2;
      cellDataValues[faceIdx] = dataView.getUint16(offset + 48, true);
    }

    // Rotate points
    const orientationField = 'SPACE';
    if (orientationField in header && header[orientationField] !== 'LPS') {
      const XYZ = header[orientationField];
      const mat4 = new Float32Array(16);
      mat4[15] = 1;
      switch (XYZ[0]) {
        case 'L':
          mat4[0] = 1;
          break;
        case 'R':
          mat4[0] = -1;
          break;
        default:
          vtkErrorMacro(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      switch (XYZ[1]) {
        case 'P':
          mat4[5] = 1;
          break;
        case 'A':
          mat4[5] = -1;
          break;
        default:
          vtkErrorMacro(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      switch (XYZ[2]) {
        case 'S':
          mat4[10] = 1;
          break;
        case 'I':
          mat4[10] = -1;
          break;
        default:
          vtkErrorMacro(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
          return;
      }
      MatrixBuilder/* default */.A.buildFromDegree().setMatrix(mat4).apply(pointValues).apply(normalValues);
    }
    const polydata = PolyData/* default.newInstance */.Ay.newInstance();
    polydata.getPoints().setData(pointValues, 3);
    polydata.getPolys().setData(cellValues);
    polydata.getCellData().setScalars(DataArray/* default.newInstance */.Ay.newInstance({
      name: 'Attribute',
      values: cellDataValues
    }));
    polydata.getCellData().setNormals(DataArray/* default.newInstance */.Ay.newInstance({
      name: 'Normals',
      values: normalValues,
      numberOfComponents: 3
    }));

    // Add new output
    model.output[0] = polydata;
    if (model.removeDuplicateVertices >= 0) {
      removeDuplicateVertices(model.removeDuplicateVertices);
    }
  };
  publicAPI.parseAsText = content => {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    const lines = content.split('\n');
    let offset = 1;
    const points = [];
    const cellArray = [];
    const cellNormals = [];
    while (offset !== -1) {
      offset = readTriangle(lines, offset, points, cellArray, cellNormals);
    }
    const polydata = PolyData/* default.newInstance */.Ay.newInstance();
    polydata.getPoints().setData(Float32Array.from(points), 3);
    polydata.getPolys().setData(Uint32Array.from(cellArray));
    polydata.getCellData().setNormals(DataArray/* default.newInstance */.Ay.newInstance({
      name: 'Normals',
      values: Float32Array.from(cellNormals),
      numberOfComponents: 3
    }));

    // Add new output
    model.output[0] = polydata;
    if (model.removeDuplicateVertices >= 0) {
      removeDuplicateVertices(model.removeDuplicateVertices);
    }
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parse(model.parseData);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const STLReader_DEFAULT_VALUES = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
  removeDuplicateVertices: -1
};

// ----------------------------------------------------------------------------

function STLReader_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, STLReader_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['url', 'baseURL']);
  macros2.m.setGet(publicAPI, model, ['dataAccessHelper', 'removeDuplicateVertices']);
  macros2.m.algo(publicAPI, model, 0, 1);

  // vtkSTLReader methods
  vtkSTLReader(publicAPI, model);

  // To support destructuring
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}

// ----------------------------------------------------------------------------

const STLReader_newInstance = macros2.m.newInstance(STLReader_extend, 'vtkSTLReader');

// ----------------------------------------------------------------------------

var vtkSTLReader$1 = {
  extend: STLReader_extend,
  newInstance: STLReader_newInstance
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js + 4 modules
var XMLPolyDataReader = __webpack_require__(94199);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/Misc/OBJReader.js






// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + gz
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

// ----------------------------------------------------------------------------

const data = {};

// ----------------------------------------------------------------------------

function copyVector(src, srcOffset, dst, dstOffset, vectorSize) {
  for (let i = 0; i < vectorSize; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
}

// ----------------------------------------------------------------------------

function begin(splitMode) {
  data.splitOn = splitMode;
  data.pieces = [];
  data.v = [];
  data.vt = [];
  data.vn = [];
  data.f = [[]];
  data.size = 0;
}

// ----------------------------------------------------------------------------

function faceMap(str) {
  const idxs = str.split('/').map(i => Number(i));
  let vertexIdx = idxs[0] - 1;
  vertexIdx = vertexIdx < 0 ? vertexIdx + 1 + data.v.length / 3 : vertexIdx;
  let textCoordIdx = idxs[1] ? idxs[1] - 1 : vertexIdx;
  textCoordIdx = textCoordIdx < 0 ? textCoordIdx + 1 + data.vt.length / 2 : textCoordIdx;
  let vertexNormal = idxs[2] ? idxs[2] - 1 : vertexIdx;
  vertexNormal = vertexNormal < 0 ? vertexNormal + 1 + data.vn.length / 3 : vertexNormal;
  return [vertexIdx, textCoordIdx, vertexNormal];
}

// ----------------------------------------------------------------------------

function parseLine(line) {
  if (line[0] === '#') {
    return;
  }
  const tokens = line.split(/[ \t]+/);
  if (tokens[0] === data.splitOn) {
    tokens.shift();
    data.pieces.push(tokens.join(' ').trim());
    data.f.push([]);
    data.size++;
  } else if (tokens[0] === 'v') {
    data.v.push(Number(tokens[1]));
    data.v.push(Number(tokens[2]));
    data.v.push(Number(tokens[3]));
  } else if (tokens[0] === 'vt') {
    data.vt.push(Number(tokens[1]));
    data.vt.push(Number(tokens[2]));
  } else if (tokens[0] === 'vn') {
    data.vn.push(Number(tokens[1]));
    data.vn.push(Number(tokens[2]));
    data.vn.push(Number(tokens[3]));
  } else if (tokens[0] === 'f') {
    // Handle triangles for now
    if (data.size === 0) {
      data.size++;
    }
    const cells = data.f[data.size - 1];
    tokens.shift();
    const faces = tokens.filter(s => s.length > 0 && s !== '\r');
    const size = faces.length;
    cells.push(size);
    for (let i = 0; i < size; i++) {
      cells.push(faceMap(faces[i]));
    }
  }
}

// ----------------------------------------------------------------------------

function end(model) {
  const hasTcoords = !!data.vt.length;
  const hasNormals = !!data.vn.length;
  if (model.splitMode) {
    model.numberOfOutputs = data.size;
    for (let idx = 0; idx < data.size; idx++) {
      const polyIn = data.f[idx];
      const nbElems = polyIn.length;
      const nbPoints = data.v.length / 3;
      const keyPointId = {};
      let pointDuplicatesReferences;
      if (model.trackDuplicates) {
        // In trackDuplicates mode, we want the following point layout:
        // [pt0, pt1, pt2, ... ptN, pt0d1, pt0d2, pt1d1]
        const pointKeys = [];
        let duplicatesCount = 0;
        for (let offset = 0; offset < nbElems;) {
          const cellSize = polyIn[offset++];
          for (let pIdx = 0; pIdx < cellSize; pIdx++) {
            const [vIdx, tcIdx, nIdx] = polyIn[offset++];
            const key = `${vIdx}/${tcIdx}/${nIdx}`;
            if (keyPointId[key] === undefined) {
              if (pointKeys[vIdx] === undefined) {
                pointKeys[vIdx] = [key];
              } else {
                pointKeys[vIdx].push(key);
                ++duplicatesCount;
              }
              // will be overwritten for duplicates
              keyPointId[key] = vIdx;
            }
          }
        }
        pointDuplicatesReferences = new Uint16Array(nbPoints + duplicatesCount);
        let duplicates = 0;
        for (let pointId = 0; pointId < pointKeys.length; ++pointId) {
          const usageCount = pointKeys[pointId] ? pointKeys[pointId].length : 0;
          // Set the first duplicate index on the original point
          pointDuplicatesReferences[pointId] = usageCount > 1 ? nbPoints + duplicates : pointId;
          // Set the original index on each duplicated point
          for (let duplicateId = 1; duplicateId < usageCount; ++duplicateId) {
            const finalDuplicateId = nbPoints + duplicates++;
            pointDuplicatesReferences[finalDuplicateId] = pointId;
            // Associate the duplicate index to the key
            keyPointId[pointKeys[pointId][duplicateId]] = finalDuplicateId;
          }
        }
      }
      const ctMapping = {};
      const polydata = PolyData/* default.newInstance */.Ay.newInstance({
        name: data.pieces[idx]
      });
      const pts = [];
      const tc = [];
      const normals = [];
      const polys = [];
      let offset = 0;
      while (offset < nbElems) {
        const cellSize = polyIn[offset];
        polys.push(cellSize);
        for (let pIdx = 0; pIdx < cellSize; pIdx++) {
          const [vIdx, tcIdx, nIdx] = polyIn[offset + pIdx + 1];
          const key = `${vIdx}/${tcIdx}/${nIdx}`;
          if (ctMapping[key] === undefined) {
            const dstOffset = model.trackDuplicates ? keyPointId[key] : pts.length / 3;
            ctMapping[key] = dstOffset;
            copyVector(data.v, vIdx * 3, pts, dstOffset * 3, 3);
            if (hasTcoords) {
              copyVector(data.vt, tcIdx * 2, tc, dstOffset * 2, 2);
            }
            if (hasNormals) {
              copyVector(data.vn, nIdx * 3, normals, dstOffset * 3, 3);
            }
          }
          polys.push(ctMapping[key]);
        }
        offset += cellSize + 1;
      }
      polydata.getPoints().setData(Float32Array.from(pts), 3);
      if (model.trackDuplicates) {
        const duplicatesArray = DataArray/* default.newInstance */.Ay.newInstance({
          name: 'Duplicates',
          values: pointDuplicatesReferences
        });
        polydata.getPointData().addArray(duplicatesArray);
      }
      polydata.getPolys().setData(Uint32Array.from(polys));
      if (hasTcoords) {
        const tcoords = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 2,
          values: Float32Array.from(tc),
          name: 'TextureCoordinates'
        });
        polydata.getPointData().setTCoords(tcoords);
      }
      if (hasNormals) {
        const normalsArray = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 3,
          values: Float32Array.from(normals),
          name: 'Normals'
        });
        polydata.getPointData().setNormals(normalsArray);
      }

      // register in output
      model.output[idx] = polydata;
    }
  } else {
    model.numberOfOutputs = 1;
    const polydata = PolyData/* default.newInstance */.Ay.newInstance();
    polydata.getPoints().setData(Float32Array.from(data.v), 3);
    if (hasTcoords && data.v.length / 3 === data.vt.length / 2) {
      const tcoords = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 2,
        values: Float32Array.from(data.vt),
        name: 'TextureCoordinates'
      });
      polydata.getPointData().setTCoords(tcoords);
    }
    if (hasNormals && data.v.length === data.vn.length) {
      const normalsArray = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: Float32Array.from(data.vn),
        name: 'Normals'
      });
      polydata.getPointData().setNormals(normalsArray);
    }
    const polys = [];
    const polyIn = data.f[0];
    const nbElems = polyIn.length;
    let offset = 0;
    while (offset < nbElems) {
      const cellSize = polyIn[offset];
      polys.push(cellSize);
      for (let pIdx = 0; pIdx < cellSize; pIdx++) {
        const [vIdx] = polyIn[offset + pIdx + 1];
        polys.push(vIdx);
      }
      offset += cellSize + 1;
    }
    polydata.getPolys().setData(Uint32Array.from(polys));
    model.output[0] = polydata;
  }
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

function getPointDuplicateIds(polyData, pointId) {
  const res = [];
  const duplicates = polyData.getPointData().getArrayByName('Duplicates');
  if (duplicates == null) {
    return res;
  }
  const duplicatesData = duplicates.getData();
  const originalPointId = Math.min(pointId, duplicatesData[pointId]);
  res.push(originalPointId);
  let duplicateId = duplicatesData[originalPointId];
  if (duplicateId !== originalPointId) {
    // point has duplicates
    while (duplicateId < duplicatesData.length && duplicatesData[duplicateId] === originalPointId) {
      // Duplicated points must be next to each other and original point must
      // reference first duplicate
      res.push(duplicateId++);
    }
  }
  return res;
}
const STATIC = {
  getPointDuplicateIds
};

// ----------------------------------------------------------------------------
// vtkOBJReader methods
// ----------------------------------------------------------------------------

function vtkOBJReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOBJReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper/* default.get */.Ay.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return model.dataAccessHelper.fetchText(publicAPI, url, option);
  }

  // Set DataSet url
  publicAPI.setUrl = function (url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (url.indexOf('.obj') === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.obj`;
    } else {
      model.url = url;

      // Remove the file in the URL
      const path = url.split('/');
      path.pop();
      model.baseURL = path.join('/');
    }

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = function () {
    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return fetchData(model.url, option).then(content => publicAPI.isDeleted() ? false : publicAPI.parseAsText(content));
  };
  publicAPI.parseAsText = content => {
    if (!content) {
      return true;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    }
    model.parseData = content;
    model.numberOfOutputs = 0;
    begin(model.splitMode);
    content.split('\n').forEach(parseLine);
    end(model);
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsText(model.parseData);
  };

  // return Busy state
  publicAPI.isBusy = () => !!model.requestCount;
  publicAPI.getNumberOfOutputPorts = () => model.numberOfOutputs;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const OBJReader_DEFAULT_VALUES = {
  numberOfOutputs: 1,
  requestCount: 0,
  splitMode: null,
  trackDuplicates: false
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

function OBJReader_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, OBJReader_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['url', 'baseURL']);
  macros2.m.setGet(publicAPI, model, ['dataAccessHelper', 'splitMode', 'trackDuplicates']);
  macros2.m.algo(publicAPI, model, 0, 1);
  macros2.m.event(publicAPI, model, 'busy');

  // Object methods
  vtkOBJReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OBJReader_newInstance = macros2.m.newInstance(OBJReader_extend, 'vtkOBJReader');

// ----------------------------------------------------------------------------

var vtkOBJReader$1 = {
  newInstance: OBJReader_newInstance,
  extend: OBJReader_extend,
  ...STATIC
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
var Triangle = __webpack_require__(96703);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Core/PolyDataNormals.js






// ----------------------------------------------------------------------------
// vtkPolyDataNormals methods
// ----------------------------------------------------------------------------

function vtkPolyDataNormals(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyDataNormals');
  publicAPI.vtkPolyDataNormalsExecute = (numberOfPolys, polysData, pointsData) => {
    if (!pointsData) {
      return null;
    }
    const pointNormals = new Float32Array(pointsData.length);
    const cellNormals = new Float32Array(3 * numberOfPolys);
    let cellNormalComponent = 0;
    let numberOfPoints = 0;
    const polysDataLength = polysData.length;
    const cellPointIds = [0, 0, 0];
    const cellNormal = [0, 0, 0];
    for (let c = 0; c < polysDataLength; c += numberOfPoints + 1) {
      numberOfPoints = polysData[c];
      if (numberOfPoints < 3) {
        continue; // eslint-disable-line
      }

      for (let i = 1; i <= 3; ++i) {
        cellPointIds[i - 1] = 3 * polysData[c + i];
      }
      Triangle/* default */.Ay.computeNormal(pointsData.slice(cellPointIds[0], cellPointIds[0] + 3), pointsData.slice(cellPointIds[1], cellPointIds[1] + 3), pointsData.slice(cellPointIds[2], cellPointIds[2] + 3), cellNormal);
      cellNormals[cellNormalComponent++] = cellNormal[0];
      cellNormals[cellNormalComponent++] = cellNormal[1];
      cellNormals[cellNormalComponent++] = cellNormal[2];
      if (model.computePointNormals) {
        for (let i = 1; i <= numberOfPoints; ++i) {
          let pointId = 3 * polysData[c + i];
          pointNormals[pointId] += cellNormal[0];
          pointNormals[++pointId] += cellNormal[1];
          pointNormals[++pointId] += cellNormal[2];
        }
      }
    }

    // Normalize point normals.
    // A point normal is the sum of all the cell normals the point belongs to
    if (model.computePointNormals) {
      const pointNormal = [0, 0, 0];
      for (let i = 0; i < pointsData.length;) {
        pointNormal[0] = pointNormals[i];
        pointNormal[1] = pointNormals[i + 1];
        pointNormal[2] = pointNormals[i + 2];
        Core_Math.f.normalize(pointNormal);
        pointNormals[i++] = pointNormal[0];
        pointNormals[i++] = pointNormal[1];
        pointNormals[i++] = pointNormal[2];
      }
    }
    return [cellNormals, pointNormals];
  };
  publicAPI.requestData = (inData, outData) => {
    const numberOfInputs = publicAPI.getNumberOfInputPorts();
    if (!numberOfInputs) {
      return;
    }
    const input = inData[0];
    if (!input) {
      return;
    }
    const output = PolyData/* default.newInstance */.Ay.newInstance();
    output.setPoints(input.getPoints());
    output.setVerts(input.getVerts());
    output.setLines(input.getLines());
    output.setPolys(input.getPolys());
    output.setStrips(input.getStrips());
    output.getPointData().passData(input.getPointData());
    output.getCellData().passData(input.getCellData());
    output.getFieldData().passData(input.getFieldData());
    const [cellNormals, pointNormals] = publicAPI.vtkPolyDataNormalsExecute(input.getNumberOfPolys(), input.getPolys().getData(), input.getPoints().getData());
    if (model.computePointNormals) {
      const outputPointNormals = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        name: 'Normals',
        values: pointNormals
      });
      output.getPointData().setNormals(outputPointNormals);
    }
    if (model.computeCellNormals) {
      const outputCellNormals = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        name: 'Normals',
        values: cellNormals
      });
      output.getCellData().setNormals(outputCellNormals);
    }
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
function defaultValues(initialValues) {
  return {
    computeCellNormals: false,
    computePointNormals: true,
    ...initialValues
  };
}

// ----------------------------------------------------------------------------
function PolyDataNormals_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));

  /* Make this a VTK object */

  macros2.m.obj(publicAPI, model);

  /* Also make it an algorithm with one input and one output */

  macros2.m.algo(publicAPI, model, 1, 1);
  macros2.m.setGet(publicAPI, model, ['computeCellNormals', 'computePointNormals']);

  /* Object specific methods */

  vtkPolyDataNormals(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyDataNormals_newInstance = macros2.m.newInstance(PolyDataNormals_extend, 'vtkPolyDataNormals');

// ----------------------------------------------------------------------------

var vtkPolyDataNormals$1 = {
  newInstance: PolyDataNormals_newInstance,
  extend: PolyDataNormals_extend
};



// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Mesh.js









class Mesh {
    constructor(props) {
        this._color = [255, 255, 255];
        this._actors = [];
        this.id = props.id;
        this._color = props.color ?? this._color;
        this._format = props.format;
        const textDecoder = new TextDecoder();
        const normals = vtkPolyDataNormals$1.newInstance();
        const createActorWithMapper = (mapper) => {
            const actor = Actor/* default.newInstance */.Ay.newInstance();
            actor.setMapper(mapper);
            const property = Property/* default.newInstance */.Ay.newInstance();
            property.setColor(this._color[0] / 255, this._color[1] / 255, this._color[2] / 255);
            actor.setProperty(property);
            return actor;
        };
        if (this._format === enums.MeshType.PLY) {
            const mapper = Mapper/* default.newInstance */.Ay.newInstance();
            const reader = vtkPLYReader$1.newInstance();
            reader.parseAsArrayBuffer(props.arrayBuffer);
            mapper.setInputConnection(reader.getOutputPort());
            this._actors.push(createActorWithMapper(mapper));
        }
        else if (this._format === enums.MeshType.STL) {
            const mapper = Mapper/* default.newInstance */.Ay.newInstance();
            const reader = vtkSTLReader$1.newInstance();
            reader.parseAsArrayBuffer(props.arrayBuffer);
            normals.setInputConnection(reader.getOutputPort());
            mapper.setInputConnection(normals.getOutputPort());
            this._actors.push(createActorWithMapper(mapper));
        }
        else if (this._format === enums.MeshType.OBJ) {
            const reader = vtkOBJReader$1.newInstance({
                splitMode: props.materialUrl ? 'usemtl' : null,
            });
            reader.parseAsText(textDecoder.decode(props.arrayBuffer));
            const size = reader.getNumberOfOutputPorts();
            for (let i = 0; i < size; i++) {
                const source = reader.getOutputData(i);
                const mapper = Mapper/* default.newInstance */.Ay.newInstance();
                mapper.setInputData(source);
                this._actors.push(createActorWithMapper(mapper));
            }
        }
        else if (this._format === enums.MeshType.VTP) {
            const mapper = Mapper/* default.newInstance */.Ay.newInstance();
            const reader = XMLPolyDataReader/* default.newInstance */.Ay.newInstance();
            reader.parseAsArrayBuffer(props.arrayBuffer);
            mapper.setInputConnection(reader.getOutputPort());
            this._actors.push(createActorWithMapper(mapper));
        }
        this.sizeInBytes = this._getSizeInBytes();
    }
    _getSizeInBytes() {
        let size = 0;
        for (let i = 0; i < this._actors.length; i++) {
            const actor = this._actors[i];
            const mapper = actor.getMapper();
            const pd = mapper.getInputData();
            const points = pd.getPoints();
            const polys = pd.getPolys();
            const pointsLength = points.getData().length;
            const polysLength = polys.getData().length;
            size += pointsLength * 4 + polysLength * 4;
        }
        return size;
    }
    get defaultActor() {
        return this._actors[0];
    }
    get actors() {
        return this._actors;
    }
    get color() {
        return this._color;
    }
    get format() {
        return this._format;
    }
}


/***/ }),

/***/ 1271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71851);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10364);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10297);
/* harmony import */ var _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35637);




class StreamingDynamicImageVolume extends _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A {
    constructor(imageVolumeProperties, streamingProperties) {
        super(imageVolumeProperties, streamingProperties);
        this._dimensionGroupNumber = 1;
        this._loadedDimensionGroups = new Set();
        this._getImageIdRequests = (imageIds, priority) => {
            return this.getImageIdsRequests(imageIds, priority);
        };
        this.getImageLoadRequests = (priority) => {
            const imageIds = this.getImageIdsToLoad();
            return this._getImageIdRequests(imageIds, priority);
        };
        const { imageIdGroups, splittingTag } = imageVolumeProperties;
        this._splittingTag = splittingTag;
        this._imageIdGroups = imageIdGroups;
        this.numDimensionGroups = this._imageIdGroups.length;
        this.numTimePoints = this.numDimensionGroups;
    }
    _getImageIdsToLoad() {
        const imageIdGroups = this._imageIdGroups;
        const initialImageIdGroupIndex = this._dimensionGroupNumber - 1;
        const imageIds = [...imageIdGroups[initialImageIdGroupIndex]];
        let leftIndex = initialImageIdGroupIndex - 1;
        let rightIndex = initialImageIdGroupIndex + 1;
        while (leftIndex >= 0 || rightIndex < imageIdGroups.length) {
            if (leftIndex >= 0) {
                imageIds.push(...imageIdGroups[leftIndex--]);
            }
            if (rightIndex < imageIdGroups.length) {
                imageIds.push(...imageIdGroups[rightIndex++]);
            }
        }
        return imageIds;
    }
    getImageIdsToLoad() {
        return this._getImageIdsToLoad();
    }
    get dimensionGroupNumber() {
        return this._dimensionGroupNumber;
    }
    set timePointIndex(index) {
        console.warn('Warning: timePointIndex is deprecated. Please use dimensionGroupNumber instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.');
        this.dimensionGroupNumber = index + 1;
    }
    set dimensionGroupNumber(dimensionGroupNumber) {
        if (this._dimensionGroupNumber === dimensionGroupNumber) {
            return;
        }
        this._dimensionGroupNumber = dimensionGroupNumber;
        this.voxelManager.setDimensionGroupNumber(dimensionGroupNumber);
        this.invalidateVolume(true);
        (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_eventTarget__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED, {
            volumeId: this.volumeId,
            dimensionGroupNumber: dimensionGroupNumber,
            numDimensionGroups: this.numDimensionGroups,
            imageIdGroupIndex: dimensionGroupNumber - 1,
            numImageIdGroups: this.numDimensionGroups,
            splittingTag: this.splittingTag,
        });
        (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_eventTarget__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED, {
            volumeId: this.volumeId,
            timePointIndex: dimensionGroupNumber - 1,
            numTimePoints: this.numDimensionGroups,
            imageIdGroupIndex: dimensionGroupNumber - 1,
            numImageIdGroups: this.numDimensionGroups,
            splittingTag: this.splittingTag,
        });
    }
    get timePointIndex() {
        console.warn('Warning: timePointIndex is deprecated. Please use dimensionGroupNumber instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.');
        return this._dimensionGroupNumber - 1;
    }
    scroll(delta) {
        const newDimensionGroupNumber = this._dimensionGroupNumber + delta;
        if (newDimensionGroupNumber < 1) {
            this.dimensionGroupNumber = this.numDimensionGroups;
        }
        else if (newDimensionGroupNumber > this.numDimensionGroups) {
            this.dimensionGroupNumber = 1;
        }
        else {
            this.dimensionGroupNumber = newDimensionGroupNumber;
        }
    }
    getCurrentDimensionGroupImageIds() {
        return this._imageIdGroups[this._dimensionGroupNumber - 1];
    }
    getCurrentTimePointImageIds() {
        console.warn('Warning: getCurrentTimePointImageIds is deprecated. Please use getCurrentDimensionGroupImageIds instead.');
        return this.getCurrentDimensionGroupImageIds();
    }
    flatImageIdIndexToTimePointIndex(flatImageIdIndex) {
        console.warn('Warning: flatImageIdIndexToTimePointIndex is deprecated. Please use flatImageIdIndexToDimensionGroupNumber instead.');
        return this.flatImageIdIndexToDimensionGroupNumber(flatImageIdIndex) - 1;
    }
    flatImageIdIndexToDimensionGroupNumber(flatImageIdIndex) {
        return Math.floor(flatImageIdIndex / this._imageIdGroups[0].length) + 1;
    }
    flatImageIdIndexToImageIdIndex(flatImageIdIndex) {
        return flatImageIdIndex % this._imageIdGroups[0].length;
    }
    get splittingTag() {
        return this._splittingTag;
    }
    isTimePointLoaded(timePointIndex) {
        console.warn('Warning: isTimePointLoaded is deprecated. Please use isDimensionGroupLoaded instead. Note that timePointIndex is zero-based while dimensionGroupNumber starts at 1.');
        return this.isDimensionGroupLoaded(timePointIndex + 1);
    }
    isDimensionGroupLoaded(dimensionGroupNumber) {
        return this._loadedDimensionGroups.has(dimensionGroupNumber);
    }
    markDimensionGroupAsLoaded(dimensionGroupNumber) {
        this._loadedDimensionGroups.add(dimensionGroupNumber);
        (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_eventTarget__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED, {
            volumeId: this.volumeId,
            dimensionGroupNumber: dimensionGroupNumber,
        });
        (0,_utilities__WEBPACK_IMPORTED_MODULE_2__.triggerEvent)(_eventTarget__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_0__.Events.DYNAMIC_VOLUME_TIME_POINT_LOADED, {
            volumeId: this.volumeId,
            timePointIndex: dimensionGroupNumber - 1,
        });
    }
    checkTimePointCompletion(imageIdIndex) {
        console.warn('Warning: checkTimePointCompletion is deprecated. Please use checkDimensionGroupCompletion instead.');
        this.checkDimensionGroupCompletion(imageIdIndex);
    }
    checkDimensionGroupCompletion(imageIdIndex) {
        const dimensionGroupNumber = this.flatImageIdIndexToDimensionGroupNumber(imageIdIndex);
        const imageIdsInDimensionGroup = this._imageIdGroups[dimensionGroupNumber - 1];
        const allLoaded = imageIdsInDimensionGroup.every((imageId) => {
            const index = this.getImageIdIndex(imageId);
            return this.cachedFrames[index] === _enums__WEBPACK_IMPORTED_MODULE_0__.ImageQualityStatus.FULL_RESOLUTION;
        });
        if (allLoaded && !this.isDimensionGroupLoaded(dimensionGroupNumber)) {
            this.markDimensionGroupAsLoaded(dimensionGroupNumber);
        }
    }
}


/***/ }),

/***/ 50180:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ StreamingImageVolume)
/* harmony export */ });
/* harmony import */ var _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35637);

class StreamingImageVolume extends _BaseStreamingImageVolume__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {
    constructor(imageVolumeProperties, streamingProperties) {
        if (!imageVolumeProperties.imageIds) {
            imageVolumeProperties.imageIds = streamingProperties.imageIds;
        }
        super(imageVolumeProperties, streamingProperties);
        this.getImageIdsToLoad = () => {
            const { imageIds } = this;
            this.numFrames = imageIds.length;
            return imageIds;
        };
    }
    getScalarData() {
        return this.voxelManager.getScalarData();
    }
    getImageLoadRequests(priority) {
        const { imageIds } = this;
        return this.getImageIdsRequests(imageIds, priority);
    }
}


/***/ }),

/***/ 90808:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export Surface */
class Surface {
    constructor(props) {
        this._color = [200, 0, 0];
        this.id = props.id;
        this._points = props.points;
        this._polys = props.polys;
        this._color = props.color ?? this._color;
        this.frameOfReferenceUID = props.frameOfReferenceUID;
        this._segmentIndex = props.segmentIndex;
        this.sizeInBytes = this._getSizeInBytes();
        this._updateCentroid();
        this._visible = true;
    }
    _getSizeInBytes() {
        return this._points.length * 4 + this._polys.length * 4;
    }
    _updateCentroid() {
        const numberOfPoints = this._points.length / 3;
        let sumX = 0, sumY = 0, sumZ = 0;
        for (let i = 0; i < this._points.length; i += 3) {
            sumX += this._points[i];
            sumY += this._points[i + 1];
            sumZ += this._points[i + 2];
        }
        this._centroid = [
            sumX / numberOfPoints,
            sumY / numberOfPoints,
            sumZ / numberOfPoints,
        ];
    }
    get color() {
        return this._color;
    }
    set color(color) {
        this._color = color;
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        this._updateCentroid();
    }
    get polys() {
        return this._polys;
    }
    set polys(polys) {
        this._polys = polys;
    }
    get segmentIndex() {
        return this._segmentIndex;
    }
    get visible() {
        return this._visible;
    }
    set visible(visible) {
        this._visible = visible;
    }
    get centroid() {
        return this._centroid;
    }
    get flatPointsArray() {
        return this._points;
    }
    get totalNumberOfPoints() {
        return this._points.length / 3;
    }
}


/***/ }),

/***/ 21093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const colormapsData = {
    hotIron: {
        name: 'Hot Iron',
        numOfColors: 256,
        colors: [
            [0, 0, 0, 255],
            [2, 0, 0, 255],
            [4, 0, 0, 255],
            [6, 0, 0, 255],
            [8, 0, 0, 255],
            [10, 0, 0, 255],
            [12, 0, 0, 255],
            [14, 0, 0, 255],
            [16, 0, 0, 255],
            [18, 0, 0, 255],
            [20, 0, 0, 255],
            [22, 0, 0, 255],
            [24, 0, 0, 255],
            [26, 0, 0, 255],
            [28, 0, 0, 255],
            [30, 0, 0, 255],
            [32, 0, 0, 255],
            [34, 0, 0, 255],
            [36, 0, 0, 255],
            [38, 0, 0, 255],
            [40, 0, 0, 255],
            [42, 0, 0, 255],
            [44, 0, 0, 255],
            [46, 0, 0, 255],
            [48, 0, 0, 255],
            [50, 0, 0, 255],
            [52, 0, 0, 255],
            [54, 0, 0, 255],
            [56, 0, 0, 255],
            [58, 0, 0, 255],
            [60, 0, 0, 255],
            [62, 0, 0, 255],
            [64, 0, 0, 255],
            [66, 0, 0, 255],
            [68, 0, 0, 255],
            [70, 0, 0, 255],
            [72, 0, 0, 255],
            [74, 0, 0, 255],
            [76, 0, 0, 255],
            [78, 0, 0, 255],
            [80, 0, 0, 255],
            [82, 0, 0, 255],
            [84, 0, 0, 255],
            [86, 0, 0, 255],
            [88, 0, 0, 255],
            [90, 0, 0, 255],
            [92, 0, 0, 255],
            [94, 0, 0, 255],
            [96, 0, 0, 255],
            [98, 0, 0, 255],
            [100, 0, 0, 255],
            [102, 0, 0, 255],
            [104, 0, 0, 255],
            [106, 0, 0, 255],
            [108, 0, 0, 255],
            [110, 0, 0, 255],
            [112, 0, 0, 255],
            [114, 0, 0, 255],
            [116, 0, 0, 255],
            [118, 0, 0, 255],
            [120, 0, 0, 255],
            [122, 0, 0, 255],
            [124, 0, 0, 255],
            [126, 0, 0, 255],
            [128, 0, 0, 255],
            [130, 0, 0, 255],
            [132, 0, 0, 255],
            [134, 0, 0, 255],
            [136, 0, 0, 255],
            [138, 0, 0, 255],
            [140, 0, 0, 255],
            [142, 0, 0, 255],
            [144, 0, 0, 255],
            [146, 0, 0, 255],
            [148, 0, 0, 255],
            [150, 0, 0, 255],
            [152, 0, 0, 255],
            [154, 0, 0, 255],
            [156, 0, 0, 255],
            [158, 0, 0, 255],
            [160, 0, 0, 255],
            [162, 0, 0, 255],
            [164, 0, 0, 255],
            [166, 0, 0, 255],
            [168, 0, 0, 255],
            [170, 0, 0, 255],
            [172, 0, 0, 255],
            [174, 0, 0, 255],
            [176, 0, 0, 255],
            [178, 0, 0, 255],
            [180, 0, 0, 255],
            [182, 0, 0, 255],
            [184, 0, 0, 255],
            [186, 0, 0, 255],
            [188, 0, 0, 255],
            [190, 0, 0, 255],
            [192, 0, 0, 255],
            [194, 0, 0, 255],
            [196, 0, 0, 255],
            [198, 0, 0, 255],
            [200, 0, 0, 255],
            [202, 0, 0, 255],
            [204, 0, 0, 255],
            [206, 0, 0, 255],
            [208, 0, 0, 255],
            [210, 0, 0, 255],
            [212, 0, 0, 255],
            [214, 0, 0, 255],
            [216, 0, 0, 255],
            [218, 0, 0, 255],
            [220, 0, 0, 255],
            [222, 0, 0, 255],
            [224, 0, 0, 255],
            [226, 0, 0, 255],
            [228, 0, 0, 255],
            [230, 0, 0, 255],
            [232, 0, 0, 255],
            [234, 0, 0, 255],
            [236, 0, 0, 255],
            [238, 0, 0, 255],
            [240, 0, 0, 255],
            [242, 0, 0, 255],
            [244, 0, 0, 255],
            [246, 0, 0, 255],
            [248, 0, 0, 255],
            [250, 0, 0, 255],
            [252, 0, 0, 255],
            [254, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 2, 0, 255],
            [255, 4, 0, 255],
            [255, 6, 0, 255],
            [255, 8, 0, 255],
            [255, 10, 0, 255],
            [255, 12, 0, 255],
            [255, 14, 0, 255],
            [255, 16, 0, 255],
            [255, 18, 0, 255],
            [255, 20, 0, 255],
            [255, 22, 0, 255],
            [255, 24, 0, 255],
            [255, 26, 0, 255],
            [255, 28, 0, 255],
            [255, 30, 0, 255],
            [255, 32, 0, 255],
            [255, 34, 0, 255],
            [255, 36, 0, 255],
            [255, 38, 0, 255],
            [255, 40, 0, 255],
            [255, 42, 0, 255],
            [255, 44, 0, 255],
            [255, 46, 0, 255],
            [255, 48, 0, 255],
            [255, 50, 0, 255],
            [255, 52, 0, 255],
            [255, 54, 0, 255],
            [255, 56, 0, 255],
            [255, 58, 0, 255],
            [255, 60, 0, 255],
            [255, 62, 0, 255],
            [255, 64, 0, 255],
            [255, 66, 0, 255],
            [255, 68, 0, 255],
            [255, 70, 0, 255],
            [255, 72, 0, 255],
            [255, 74, 0, 255],
            [255, 76, 0, 255],
            [255, 78, 0, 255],
            [255, 80, 0, 255],
            [255, 82, 0, 255],
            [255, 84, 0, 255],
            [255, 86, 0, 255],
            [255, 88, 0, 255],
            [255, 90, 0, 255],
            [255, 92, 0, 255],
            [255, 94, 0, 255],
            [255, 96, 0, 255],
            [255, 98, 0, 255],
            [255, 100, 0, 255],
            [255, 102, 0, 255],
            [255, 104, 0, 255],
            [255, 106, 0, 255],
            [255, 108, 0, 255],
            [255, 110, 0, 255],
            [255, 112, 0, 255],
            [255, 114, 0, 255],
            [255, 116, 0, 255],
            [255, 118, 0, 255],
            [255, 120, 0, 255],
            [255, 122, 0, 255],
            [255, 124, 0, 255],
            [255, 126, 0, 255],
            [255, 128, 4, 255],
            [255, 130, 8, 255],
            [255, 132, 12, 255],
            [255, 134, 16, 255],
            [255, 136, 20, 255],
            [255, 138, 24, 255],
            [255, 140, 28, 255],
            [255, 142, 32, 255],
            [255, 144, 36, 255],
            [255, 146, 40, 255],
            [255, 148, 44, 255],
            [255, 150, 48, 255],
            [255, 152, 52, 255],
            [255, 154, 56, 255],
            [255, 156, 60, 255],
            [255, 158, 64, 255],
            [255, 160, 68, 255],
            [255, 162, 72, 255],
            [255, 164, 76, 255],
            [255, 166, 80, 255],
            [255, 168, 84, 255],
            [255, 170, 88, 255],
            [255, 172, 92, 255],
            [255, 174, 96, 255],
            [255, 176, 100, 255],
            [255, 178, 104, 255],
            [255, 180, 108, 255],
            [255, 182, 112, 255],
            [255, 184, 116, 255],
            [255, 186, 120, 255],
            [255, 188, 124, 255],
            [255, 190, 128, 255],
            [255, 192, 132, 255],
            [255, 194, 136, 255],
            [255, 196, 140, 255],
            [255, 198, 144, 255],
            [255, 200, 148, 255],
            [255, 202, 152, 255],
            [255, 204, 156, 255],
            [255, 206, 160, 255],
            [255, 208, 164, 255],
            [255, 210, 168, 255],
            [255, 212, 172, 255],
            [255, 214, 176, 255],
            [255, 216, 180, 255],
            [255, 218, 184, 255],
            [255, 220, 188, 255],
            [255, 222, 192, 255],
            [255, 224, 196, 255],
            [255, 226, 200, 255],
            [255, 228, 204, 255],
            [255, 230, 208, 255],
            [255, 232, 212, 255],
            [255, 234, 216, 255],
            [255, 236, 220, 255],
            [255, 238, 224, 255],
            [255, 240, 228, 255],
            [255, 242, 232, 255],
            [255, 244, 236, 255],
            [255, 246, 240, 255],
            [255, 248, 244, 255],
            [255, 250, 248, 255],
            [255, 252, 252, 255],
            [255, 255, 255, 255],
        ],
    },
    pet: {
        name: 'PET',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 2, 1, 255],
            [0, 4, 3, 255],
            [0, 6, 5, 255],
            [0, 8, 7, 255],
            [0, 10, 9, 255],
            [0, 12, 11, 255],
            [0, 14, 13, 255],
            [0, 16, 15, 255],
            [0, 18, 17, 255],
            [0, 20, 19, 255],
            [0, 22, 21, 255],
            [0, 24, 23, 255],
            [0, 26, 25, 255],
            [0, 28, 27, 255],
            [0, 30, 29, 255],
            [0, 32, 31, 255],
            [0, 34, 33, 255],
            [0, 36, 35, 255],
            [0, 38, 37, 255],
            [0, 40, 39, 255],
            [0, 42, 41, 255],
            [0, 44, 43, 255],
            [0, 46, 45, 255],
            [0, 48, 47, 255],
            [0, 50, 49, 255],
            [0, 52, 51, 255],
            [0, 54, 53, 255],
            [0, 56, 55, 255],
            [0, 58, 57, 255],
            [0, 60, 59, 255],
            [0, 62, 61, 255],
            [0, 65, 63, 255],
            [0, 67, 65, 255],
            [0, 69, 67, 255],
            [0, 71, 69, 255],
            [0, 73, 71, 255],
            [0, 75, 73, 255],
            [0, 77, 75, 255],
            [0, 79, 77, 255],
            [0, 81, 79, 255],
            [0, 83, 81, 255],
            [0, 85, 83, 255],
            [0, 87, 85, 255],
            [0, 89, 87, 255],
            [0, 91, 89, 255],
            [0, 93, 91, 255],
            [0, 95, 93, 255],
            [0, 97, 95, 255],
            [0, 99, 97, 255],
            [0, 101, 99, 255],
            [0, 103, 101, 255],
            [0, 105, 103, 255],
            [0, 107, 105, 255],
            [0, 109, 107, 255],
            [0, 111, 109, 255],
            [0, 113, 111, 255],
            [0, 115, 113, 255],
            [0, 117, 115, 255],
            [0, 119, 117, 255],
            [0, 121, 119, 255],
            [0, 123, 121, 255],
            [0, 125, 123, 255],
            [0, 128, 125, 255],
            [1, 126, 127, 255],
            [3, 124, 129, 255],
            [5, 122, 131, 255],
            [7, 120, 133, 255],
            [9, 118, 135, 255],
            [11, 116, 137, 255],
            [13, 114, 139, 255],
            [15, 112, 141, 255],
            [17, 110, 143, 255],
            [19, 108, 145, 255],
            [21, 106, 147, 255],
            [23, 104, 149, 255],
            [25, 102, 151, 255],
            [27, 100, 153, 255],
            [29, 98, 155, 255],
            [31, 96, 157, 255],
            [33, 94, 159, 255],
            [35, 92, 161, 255],
            [37, 90, 163, 255],
            [39, 88, 165, 255],
            [41, 86, 167, 255],
            [43, 84, 169, 255],
            [45, 82, 171, 255],
            [47, 80, 173, 255],
            [49, 78, 175, 255],
            [51, 76, 177, 255],
            [53, 74, 179, 255],
            [55, 72, 181, 255],
            [57, 70, 183, 255],
            [59, 68, 185, 255],
            [61, 66, 187, 255],
            [63, 64, 189, 255],
            [65, 63, 191, 255],
            [67, 61, 193, 255],
            [69, 59, 195, 255],
            [71, 57, 197, 255],
            [73, 55, 199, 255],
            [75, 53, 201, 255],
            [77, 51, 203, 255],
            [79, 49, 205, 255],
            [81, 47, 207, 255],
            [83, 45, 209, 255],
            [85, 43, 211, 255],
            [86, 41, 213, 255],
            [88, 39, 215, 255],
            [90, 37, 217, 255],
            [92, 35, 219, 255],
            [94, 33, 221, 255],
            [96, 31, 223, 255],
            [98, 29, 225, 255],
            [100, 27, 227, 255],
            [102, 25, 229, 255],
            [104, 23, 231, 255],
            [106, 21, 233, 255],
            [108, 19, 235, 255],
            [110, 17, 237, 255],
            [112, 15, 239, 255],
            [114, 13, 241, 255],
            [116, 11, 243, 255],
            [118, 9, 245, 255],
            [120, 7, 247, 255],
            [122, 5, 249, 255],
            [124, 3, 251, 255],
            [126, 1, 253, 255],
            [128, 0, 255, 255],
            [130, 2, 252, 255],
            [132, 4, 248, 255],
            [134, 6, 244, 255],
            [136, 8, 240, 255],
            [138, 10, 236, 255],
            [140, 12, 232, 255],
            [142, 14, 228, 255],
            [144, 16, 224, 255],
            [146, 18, 220, 255],
            [148, 20, 216, 255],
            [150, 22, 212, 255],
            [152, 24, 208, 255],
            [154, 26, 204, 255],
            [156, 28, 200, 255],
            [158, 30, 196, 255],
            [160, 32, 192, 255],
            [162, 34, 188, 255],
            [164, 36, 184, 255],
            [166, 38, 180, 255],
            [168, 40, 176, 255],
            [170, 42, 172, 255],
            [171, 44, 168, 255],
            [173, 46, 164, 255],
            [175, 48, 160, 255],
            [177, 50, 156, 255],
            [179, 52, 152, 255],
            [181, 54, 148, 255],
            [183, 56, 144, 255],
            [185, 58, 140, 255],
            [187, 60, 136, 255],
            [189, 62, 132, 255],
            [191, 64, 128, 255],
            [193, 66, 124, 255],
            [195, 68, 120, 255],
            [197, 70, 116, 255],
            [199, 72, 112, 255],
            [201, 74, 108, 255],
            [203, 76, 104, 255],
            [205, 78, 100, 255],
            [207, 80, 96, 255],
            [209, 82, 92, 255],
            [211, 84, 88, 255],
            [213, 86, 84, 255],
            [215, 88, 80, 255],
            [217, 90, 76, 255],
            [219, 92, 72, 255],
            [221, 94, 68, 255],
            [223, 96, 64, 255],
            [225, 98, 60, 255],
            [227, 100, 56, 255],
            [229, 102, 52, 255],
            [231, 104, 48, 255],
            [233, 106, 44, 255],
            [235, 108, 40, 255],
            [237, 110, 36, 255],
            [239, 112, 32, 255],
            [241, 114, 28, 255],
            [243, 116, 24, 255],
            [245, 118, 20, 255],
            [247, 120, 16, 255],
            [249, 122, 12, 255],
            [251, 124, 8, 255],
            [253, 126, 4, 255],
            [255, 128, 0, 255],
            [255, 130, 4, 255],
            [255, 132, 8, 255],
            [255, 134, 12, 255],
            [255, 136, 16, 255],
            [255, 138, 20, 255],
            [255, 140, 24, 255],
            [255, 142, 28, 255],
            [255, 144, 32, 255],
            [255, 146, 36, 255],
            [255, 148, 40, 255],
            [255, 150, 44, 255],
            [255, 152, 48, 255],
            [255, 154, 52, 255],
            [255, 156, 56, 255],
            [255, 158, 60, 255],
            [255, 160, 64, 255],
            [255, 162, 68, 255],
            [255, 164, 72, 255],
            [255, 166, 76, 255],
            [255, 168, 80, 255],
            [255, 170, 85, 255],
            [255, 172, 89, 255],
            [255, 174, 93, 255],
            [255, 176, 97, 255],
            [255, 178, 101, 255],
            [255, 180, 105, 255],
            [255, 182, 109, 255],
            [255, 184, 113, 255],
            [255, 186, 117, 255],
            [255, 188, 121, 255],
            [255, 190, 125, 255],
            [255, 192, 129, 255],
            [255, 194, 133, 255],
            [255, 196, 137, 255],
            [255, 198, 141, 255],
            [255, 200, 145, 255],
            [255, 202, 149, 255],
            [255, 204, 153, 255],
            [255, 206, 157, 255],
            [255, 208, 161, 255],
            [255, 210, 165, 255],
            [255, 212, 170, 255],
            [255, 214, 174, 255],
            [255, 216, 178, 255],
            [255, 218, 182, 255],
            [255, 220, 186, 255],
            [255, 222, 190, 255],
            [255, 224, 194, 255],
            [255, 226, 198, 255],
            [255, 228, 202, 255],
            [255, 230, 206, 255],
            [255, 232, 210, 255],
            [255, 234, 214, 255],
            [255, 236, 218, 255],
            [255, 238, 222, 255],
            [255, 240, 226, 255],
            [255, 242, 230, 255],
            [255, 244, 234, 255],
            [255, 246, 238, 255],
            [255, 248, 242, 255],
            [255, 250, 246, 255],
            [255, 252, 250, 255],
            [255, 255, 255, 255],
        ],
    },
    hotMetalBlue: {
        name: 'Hot Metal Blue',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 0, 2, 255],
            [0, 0, 4, 255],
            [0, 0, 6, 255],
            [0, 0, 8, 255],
            [0, 0, 10, 255],
            [0, 0, 12, 255],
            [0, 0, 14, 255],
            [0, 0, 16, 255],
            [0, 0, 17, 255],
            [0, 0, 19, 255],
            [0, 0, 21, 255],
            [0, 0, 23, 255],
            [0, 0, 25, 255],
            [0, 0, 27, 255],
            [0, 0, 29, 255],
            [0, 0, 31, 255],
            [0, 0, 33, 255],
            [0, 0, 35, 255],
            [0, 0, 37, 255],
            [0, 0, 39, 255],
            [0, 0, 41, 255],
            [0, 0, 43, 255],
            [0, 0, 45, 255],
            [0, 0, 47, 255],
            [0, 0, 49, 255],
            [0, 0, 51, 255],
            [0, 0, 53, 255],
            [0, 0, 55, 255],
            [0, 0, 57, 255],
            [0, 0, 59, 255],
            [0, 0, 61, 255],
            [0, 0, 63, 255],
            [0, 0, 65, 255],
            [0, 0, 67, 255],
            [0, 0, 69, 255],
            [0, 0, 71, 255],
            [0, 0, 73, 255],
            [0, 0, 75, 255],
            [0, 0, 77, 255],
            [0, 0, 79, 255],
            [0, 0, 81, 255],
            [0, 0, 83, 255],
            [0, 0, 84, 255],
            [0, 0, 86, 255],
            [0, 0, 88, 255],
            [0, 0, 90, 255],
            [0, 0, 92, 255],
            [0, 0, 94, 255],
            [0, 0, 96, 255],
            [0, 0, 98, 255],
            [0, 0, 100, 255],
            [0, 0, 102, 255],
            [0, 0, 104, 255],
            [0, 0, 106, 255],
            [0, 0, 108, 255],
            [0, 0, 110, 255],
            [0, 0, 112, 255],
            [0, 0, 114, 255],
            [0, 0, 116, 255],
            [0, 0, 117, 255],
            [0, 0, 119, 255],
            [0, 0, 121, 255],
            [0, 0, 123, 255],
            [0, 0, 125, 255],
            [0, 0, 127, 255],
            [0, 0, 129, 255],
            [0, 0, 131, 255],
            [0, 0, 133, 255],
            [0, 0, 135, 255],
            [0, 0, 137, 255],
            [0, 0, 139, 255],
            [0, 0, 141, 255],
            [0, 0, 143, 255],
            [0, 0, 145, 255],
            [0, 0, 147, 255],
            [0, 0, 149, 255],
            [0, 0, 151, 255],
            [0, 0, 153, 255],
            [0, 0, 155, 255],
            [0, 0, 157, 255],
            [0, 0, 159, 255],
            [0, 0, 161, 255],
            [0, 0, 163, 255],
            [0, 0, 165, 255],
            [0, 0, 167, 255],
            [3, 0, 169, 255],
            [6, 0, 171, 255],
            [9, 0, 173, 255],
            [12, 0, 175, 255],
            [15, 0, 177, 255],
            [18, 0, 179, 255],
            [21, 0, 181, 255],
            [24, 0, 183, 255],
            [26, 0, 184, 255],
            [29, 0, 186, 255],
            [32, 0, 188, 255],
            [35, 0, 190, 255],
            [38, 0, 192, 255],
            [41, 0, 194, 255],
            [44, 0, 196, 255],
            [47, 0, 198, 255],
            [50, 0, 200, 255],
            [52, 0, 197, 255],
            [55, 0, 194, 255],
            [57, 0, 191, 255],
            [59, 0, 188, 255],
            [62, 0, 185, 255],
            [64, 0, 182, 255],
            [66, 0, 179, 255],
            [69, 0, 176, 255],
            [71, 0, 174, 255],
            [74, 0, 171, 255],
            [76, 0, 168, 255],
            [78, 0, 165, 255],
            [81, 0, 162, 255],
            [83, 0, 159, 255],
            [85, 0, 156, 255],
            [88, 0, 153, 255],
            [90, 0, 150, 255],
            [93, 2, 144, 255],
            [96, 4, 138, 255],
            [99, 6, 132, 255],
            [102, 8, 126, 255],
            [105, 9, 121, 255],
            [108, 11, 115, 255],
            [111, 13, 109, 255],
            [114, 15, 103, 255],
            [116, 17, 97, 255],
            [119, 19, 91, 255],
            [122, 21, 85, 255],
            [125, 23, 79, 255],
            [128, 24, 74, 255],
            [131, 26, 68, 255],
            [134, 28, 62, 255],
            [137, 30, 56, 255],
            [140, 32, 50, 255],
            [143, 34, 47, 255],
            [146, 36, 44, 255],
            [149, 38, 41, 255],
            [152, 40, 38, 255],
            [155, 41, 35, 255],
            [158, 43, 32, 255],
            [161, 45, 29, 255],
            [164, 47, 26, 255],
            [166, 49, 24, 255],
            [169, 51, 21, 255],
            [172, 53, 18, 255],
            [175, 55, 15, 255],
            [178, 56, 12, 255],
            [181, 58, 9, 255],
            [184, 60, 6, 255],
            [187, 62, 3, 255],
            [190, 64, 0, 255],
            [194, 66, 0, 255],
            [198, 68, 0, 255],
            [201, 70, 0, 255],
            [205, 72, 0, 255],
            [209, 73, 0, 255],
            [213, 75, 0, 255],
            [217, 77, 0, 255],
            [221, 79, 0, 255],
            [224, 81, 0, 255],
            [228, 83, 0, 255],
            [232, 85, 0, 255],
            [236, 87, 0, 255],
            [240, 88, 0, 255],
            [244, 90, 0, 255],
            [247, 92, 0, 255],
            [251, 94, 0, 255],
            [255, 96, 0, 255],
            [255, 98, 3, 255],
            [255, 100, 6, 255],
            [255, 102, 9, 255],
            [255, 104, 12, 255],
            [255, 105, 15, 255],
            [255, 107, 18, 255],
            [255, 109, 21, 255],
            [255, 111, 24, 255],
            [255, 113, 26, 255],
            [255, 115, 29, 255],
            [255, 117, 32, 255],
            [255, 119, 35, 255],
            [255, 120, 38, 255],
            [255, 122, 41, 255],
            [255, 124, 44, 255],
            [255, 126, 47, 255],
            [255, 128, 50, 255],
            [255, 130, 53, 255],
            [255, 132, 56, 255],
            [255, 134, 59, 255],
            [255, 136, 62, 255],
            [255, 137, 65, 255],
            [255, 139, 68, 255],
            [255, 141, 71, 255],
            [255, 143, 74, 255],
            [255, 145, 76, 255],
            [255, 147, 79, 255],
            [255, 149, 82, 255],
            [255, 151, 85, 255],
            [255, 152, 88, 255],
            [255, 154, 91, 255],
            [255, 156, 94, 255],
            [255, 158, 97, 255],
            [255, 160, 100, 255],
            [255, 162, 103, 255],
            [255, 164, 106, 255],
            [255, 166, 109, 255],
            [255, 168, 112, 255],
            [255, 169, 115, 255],
            [255, 171, 118, 255],
            [255, 173, 121, 255],
            [255, 175, 124, 255],
            [255, 177, 126, 255],
            [255, 179, 129, 255],
            [255, 181, 132, 255],
            [255, 183, 135, 255],
            [255, 184, 138, 255],
            [255, 186, 141, 255],
            [255, 188, 144, 255],
            [255, 190, 147, 255],
            [255, 192, 150, 255],
            [255, 194, 153, 255],
            [255, 196, 156, 255],
            [255, 198, 159, 255],
            [255, 200, 162, 255],
            [255, 201, 165, 255],
            [255, 203, 168, 255],
            [255, 205, 171, 255],
            [255, 207, 174, 255],
            [255, 209, 176, 255],
            [255, 211, 179, 255],
            [255, 213, 182, 255],
            [255, 215, 185, 255],
            [255, 216, 188, 255],
            [255, 218, 191, 255],
            [255, 220, 194, 255],
            [255, 222, 197, 255],
            [255, 224, 200, 255],
            [255, 226, 203, 255],
            [255, 228, 206, 255],
            [255, 229, 210, 255],
            [255, 231, 213, 255],
            [255, 233, 216, 255],
            [255, 235, 219, 255],
            [255, 237, 223, 255],
            [255, 239, 226, 255],
            [255, 240, 229, 255],
            [255, 242, 232, 255],
            [255, 244, 236, 255],
            [255, 246, 239, 255],
            [255, 248, 242, 255],
            [255, 250, 245, 255],
            [255, 251, 249, 255],
            [255, 253, 252, 255],
            [255, 255, 255, 255],
        ],
    },
    pet20Step: {
        name: 'PET 20 Step',
        numColors: 256,
        colors: [
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [0, 0, 0, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [96, 0, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 80, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [48, 48, 112, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [80, 80, 128, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [96, 96, 176, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [112, 112, 192, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [128, 128, 224, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 96, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [48, 144, 48, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [80, 192, 80, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [64, 224, 64, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [224, 224, 80, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 208, 96, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 176, 64, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [208, 144, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [192, 96, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [176, 48, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 0, 0, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
            [255, 255, 255, 255],
        ],
    },
    gray: {
        name: 'Gray',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [1, 1, 1],
            ],
        },
    },
    jet: {
        name: 'Jet',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.35, 0, 0],
                [0.66, 1, 1],
                [0.89, 1, 1],
                [1, 0.5, 0.5],
            ],
            green: [
                [0, 0, 0],
                [0.125, 0, 0],
                [0.375, 1, 1],
                [0.64, 1, 1],
                [0.91, 0, 0],
                [1, 0, 0],
            ],
            blue: [
                [0, 0.5, 0.5],
                [0.11, 1, 1],
                [0.34, 1, 1],
                [0.65, 0, 0],
                [1, 0, 0],
            ],
        },
    },
    hsv: {
        name: 'HSV',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [0.15873, 1, 1],
                [0.174603, 0.96875, 0.96875],
                [0.333333, 0.03125, 0.03125],
                [0.349206, 0, 0],
                [0.666667, 0, 0],
                [0.68254, 0.03125, 0.03125],
                [0.84127, 0.96875, 0.96875],
                [0.857143, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.15873, 0.9375, 0.9375],
                [0.174603, 1, 1],
                [0.507937, 1, 1],
                [0.666667, 0.0625, 0.0625],
                [0.68254, 0, 0],
                [1, 0, 0],
            ],
            blue: [
                [0, 0, 0],
                [0.333333, 0, 0],
                [0.349206, 0.0625, 0.0625],
                [0.507937, 1, 1],
                [0.84127, 1, 1],
                [0.857143, 0.9375, 0.9375],
                [1, 0.09375, 0.09375],
            ],
        },
    },
    hot: {
        name: 'Hot',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.0416, 0.0416],
                [0.365079, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.365079, 0, 0],
                [0.746032, 1, 1],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [0.746032, 0, 0],
                [1, 1, 1],
            ],
        },
    },
    cool: {
        name: 'Cool',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 1, 1],
                [1, 0, 0],
            ],
            blue: [
                [0, 1, 1],
                [1, 1, 1],
            ],
        },
    },
    spring: {
        name: 'Spring',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 1, 1],
                [1, 0, 0],
            ],
        },
    },
    summer: {
        name: 'Summer',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            green: [
                [0, 0.5, 0.5],
                [1, 1, 1],
            ],
            blue: [
                [0, 0.4, 0.4],
                [1, 0.4, 0.4],
            ],
        },
    },
    autumn: {
        name: 'Autumn',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [1, 0, 0],
            ],
        },
    },
    winter: {
        name: 'Winter',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [1, 0, 0],
            ],
            green: [
                [0, 0, 0],
                [1, 1, 1],
            ],
            blue: [
                [0, 1, 1],
                [1, 0.5, 0.5],
            ],
        },
    },
    bone: {
        name: 'Bone',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.746032, 0.652778, 0.652778],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [0.365079, 0.319444, 0.319444],
                [0.746032, 0.777778, 0.777778],
                [1, 1, 1],
            ],
            blue: [
                [0, 0, 0],
                [0.365079, 0.444444, 0.444444],
                [1, 1, 1],
            ],
        },
    },
    copper: {
        name: 'Copper',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.809524, 1, 1],
                [1, 1, 1],
            ],
            green: [
                [0, 0, 0],
                [1, 0.7812, 0.7812],
            ],
            blue: [
                [0, 0, 0],
                [1, 0.4975, 0.4975],
            ],
        },
    },
    spectral: {
        name: 'Spectral',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0, 0],
                [0.05, 0.4667, 0.4667],
                [0.1, 0.5333, 0.5333],
                [0.15, 0, 0],
                [0.2, 0, 0],
                [0.25, 0, 0],
                [0.3, 0, 0],
                [0.35, 0, 0],
                [0.4, 0, 0],
                [0.45, 0, 0],
                [0.5, 0, 0],
                [0.55, 0, 0],
                [0.6, 0, 0],
                [0.65, 0.7333, 0.7333],
                [0.7, 0.9333, 0.9333],
                [0.75, 1, 1],
                [0.8, 1, 1],
                [0.85, 1, 1],
                [0.9, 0.8667, 0.8667],
                [0.95, 0.8, 0.8],
                [1, 0.8, 0.8],
            ],
            green: [
                [0, 0, 0],
                [0.05, 0, 0],
                [0.1, 0, 0],
                [0.15, 0, 0],
                [0.2, 0, 0],
                [0.25, 0.4667, 0.4667],
                [0.3, 0.6, 0.6],
                [0.35, 0.6667, 0.6667],
                [0.4, 0.6667, 0.6667],
                [0.45, 0.6, 0.6],
                [0.5, 0.7333, 0.7333],
                [0.55, 0.8667, 0.8667],
                [0.6, 1, 1],
                [0.65, 1, 1],
                [0.7, 0.9333, 0.9333],
                [0.75, 0.8, 0.8],
                [0.8, 0.6, 0.6],
                [0.85, 0, 0],
                [0.9, 0, 0],
                [0.95, 0, 0],
                [1, 0.8, 0.8],
            ],
            blue: [
                [0, 0, 0],
                [0.05, 0.5333, 0.5333],
                [0.1, 0.6, 0.6],
                [0.15, 0.6667, 0.6667],
                [0.2, 0.8667, 0.8667],
                [0.25, 0.8667, 0.8667],
                [0.3, 0.8667, 0.8667],
                [0.35, 0.6667, 0.6667],
                [0.4, 0.5333, 0.5333],
                [0.45, 0, 0],
                [0.5, 0, 0],
                [0.55, 0, 0],
                [0.6, 0, 0],
                [0.65, 0, 0],
                [0.7, 0, 0],
                [0.75, 0, 0],
                [0.8, 0, 0],
                [0.85, 0, 0],
                [0.9, 0, 0],
                [0.95, 0, 0],
                [1, 0.8, 0.8],
            ],
        },
    },
    coolwarm: {
        name: 'CoolWarm',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.2298057, 0.2298057],
                [0.03125, 0.26623388, 0.26623388],
                [0.0625, 0.30386891, 0.30386891],
                [0.09375, 0.342804478, 0.342804478],
                [0.125, 0.38301334, 0.38301334],
                [0.15625, 0.424369608, 0.424369608],
                [0.1875, 0.46666708, 0.46666708],
                [0.21875, 0.509635204, 0.509635204],
                [0.25, 0.552953156, 0.552953156],
                [0.28125, 0.596262162, 0.596262162],
                [0.3125, 0.639176211, 0.639176211],
                [0.34375, 0.681291281, 0.681291281],
                [0.375, 0.722193294, 0.722193294],
                [0.40625, 0.761464949, 0.761464949],
                [0.4375, 0.798691636, 0.798691636],
                [0.46875, 0.833466556, 0.833466556],
                [0.5, 0.865395197, 0.865395197],
                [0.53125, 0.897787179, 0.897787179],
                [0.5625, 0.924127593, 0.924127593],
                [0.59375, 0.944468518, 0.944468518],
                [0.625, 0.958852946, 0.958852946],
                [0.65625, 0.96732803, 0.96732803],
                [0.6875, 0.969954137, 0.969954137],
                [0.71875, 0.966811177, 0.966811177],
                [0.75, 0.958003065, 0.958003065],
                [0.78125, 0.943660866, 0.943660866],
                [0.8125, 0.923944917, 0.923944917],
                [0.84375, 0.89904617, 0.89904617],
                [0.875, 0.869186849, 0.869186849],
                [0.90625, 0.834620542, 0.834620542],
                [0.9375, 0.795631745, 0.795631745],
                [0.96875, 0.752534934, 0.752534934],
                [1, 0.705673158, 0.705673158],
            ],
            green: [
                [0, 0.298717966, 0.298717966],
                [0.03125, 0.353094838, 0.353094838],
                [0.0625, 0.406535296, 0.406535296],
                [0.09375, 0.458757618, 0.458757618],
                [0.125, 0.50941904, 0.50941904],
                [0.15625, 0.558148092, 0.558148092],
                [0.1875, 0.604562568, 0.604562568],
                [0.21875, 0.648280772, 0.648280772],
                [0.25, 0.688929332, 0.688929332],
                [0.28125, 0.726149107, 0.726149107],
                [0.3125, 0.759599947, 0.759599947],
                [0.34375, 0.788964712, 0.788964712],
                [0.375, 0.813952739, 0.813952739],
                [0.40625, 0.834302879, 0.834302879],
                [0.4375, 0.849786142, 0.849786142],
                [0.46875, 0.860207984, 0.860207984],
                [0.5, 0.86541021, 0.86541021],
                [0.53125, 0.848937047, 0.848937047],
                [0.5625, 0.827384882, 0.827384882],
                [0.59375, 0.800927443, 0.800927443],
                [0.625, 0.769767752, 0.769767752],
                [0.65625, 0.734132809, 0.734132809],
                [0.6875, 0.694266682, 0.694266682],
                [0.71875, 0.650421156, 0.650421156],
                [0.75, 0.602842431, 0.602842431],
                [0.78125, 0.551750968, 0.551750968],
                [0.8125, 0.49730856, 0.49730856],
                [0.84375, 0.439559467, 0.439559467],
                [0.875, 0.378313092, 0.378313092],
                [0.90625, 0.312874446, 0.312874446],
                [0.9375, 0.24128379, 0.24128379],
                [0.96875, 0.157246067, 0.157246067],
                [1, 0.01555616, 0.01555616],
            ],
            blue: [
                [0, 0.753683153, 0.753683153],
                [0.03125, 0.801466763, 0.801466763],
                [0.0625, 0.84495867, 0.84495867],
                [0.09375, 0.883725899, 0.883725899],
                [0.125, 0.917387822, 0.917387822],
                [0.15625, 0.945619588, 0.945619588],
                [0.1875, 0.968154911, 0.968154911],
                [0.21875, 0.98478814, 0.98478814],
                [0.25, 0.995375608, 0.995375608],
                [0.28125, 0.999836203, 0.999836203],
                [0.3125, 0.998151185, 0.998151185],
                [0.34375, 0.990363227, 0.990363227],
                [0.375, 0.976574709, 0.976574709],
                [0.40625, 0.956945269, 0.956945269],
                [0.4375, 0.931688648, 0.931688648],
                [0.46875, 0.901068838, 0.901068838],
                [0.5, 0.865395561, 0.865395561],
                [0.53125, 0.820880546, 0.820880546],
                [0.5625, 0.774508472, 0.774508472],
                [0.59375, 0.726736146, 0.726736146],
                [0.625, 0.678007945, 0.678007945],
                [0.65625, 0.628751763, 0.628751763],
                [0.6875, 0.579375448, 0.579375448],
                [0.71875, 0.530263762, 0.530263762],
                [0.75, 0.481775914, 0.481775914],
                [0.78125, 0.434243684, 0.434243684],
                [0.8125, 0.387970225, 0.387970225],
                [0.84375, 0.343229596, 0.343229596],
                [0.875, 0.300267182, 0.300267182],
                [0.90625, 0.259301199, 0.259301199],
                [0.9375, 0.220525627, 0.220525627],
                [0.96875, 0.184115123, 0.184115123],
                [1, 0.150232812, 0.150232812],
            ],
        },
    },
    blues: {
        name: 'Blues',
        numColors: 256,
        gamma: 1,
        segmentedData: {
            red: [
                [0, 0.9686274528503418, 0.9686274528503418],
                [0.125, 0.87058824300765991, 0.87058824300765991],
                [0.25, 0.7764706015586853, 0.7764706015586853],
                [0.375, 0.61960786581039429, 0.61960786581039429],
                [0.5, 0.41960784792900085, 0.41960784792900085],
                [0.625, 0.25882354378700256, 0.25882354378700256],
                [0.75, 0.12941177189350128, 0.12941177189350128],
                [0.875, 0.031372550874948502, 0.031372550874948502],
                [1, 0.031372550874948502, 0.031372550874948502],
            ],
            green: [
                [0, 0.9843137264251709, 0.9843137264251709],
                [0.125, 0.92156863212585449, 0.92156863212585449],
                [0.25, 0.85882353782653809, 0.85882353782653809],
                [0.375, 0.7921568751335144, 0.7921568751335144],
                [0.5, 0.68235296010971069, 0.68235296010971069],
                [0.625, 0.57254904508590698, 0.57254904508590698],
                [0.75, 0.44313725829124451, 0.44313725829124451],
                [0.875, 0.31764706969261169, 0.31764706969261169],
                [1, 0.18823529779911041, 0.18823529779911041],
            ],
            blue: [
                [0, 1, 1],
                [0.125, 0.9686274528503418, 0.9686274528503418],
                [0.25, 0.93725490570068359, 0.93725490570068359],
                [0.375, 0.88235294818878174, 0.88235294818878174],
                [0.5, 0.83921569585800171, 0.83921569585800171],
                [0.625, 0.7764706015586853, 0.7764706015586853],
                [0.75, 0.70980393886566162, 0.70980393886566162],
                [0.875, 0.61176472902297974, 0.61176472902297974],
                [1, 0.41960784792900085, 0.41960784792900085],
            ],
        },
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (colormapsData);


/***/ }),

/***/ 19325:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  EPSILON: () => (/* reexport */ epsilon),
  MPR_CAMERA_VALUES: () => (/* reexport */ constants_mprCameraValues),
  RENDERING_DEFAULTS: () => (/* reexport */ rendering),
  VIEWPORT_PRESETS: () => (/* reexport */ viewportPresets)
});

// UNUSED EXPORTS: BACKGROUND_COLORS, CPU_COLORMAPS

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/cpuColormaps.js
var cpuColormaps = __webpack_require__(21093);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/rendering.js
const RENDERING_DEFAULTS = {
    MINIMUM_SLAB_THICKNESS: 5e-2,
    MAXIMUM_RAY_DISTANCE: 1e6,
};
Object.freeze(RENDERING_DEFAULTS);
/* harmony default export */ const rendering = (RENDERING_DEFAULTS);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/epsilon.js
const EPSILON = 1e-3;
/* harmony default export */ const epsilon = (EPSILON);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepFreeze.js
function deepFreeze(object) {
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames) {
        const value = object[name];
        if (value && typeof value === 'object') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
/* harmony default export */ const utilities_deepFreeze = (deepFreeze);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/mprCameraValues.js

const MPR_CAMERA_VALUES = {
    axial: {
        viewPlaneNormal: [0, 0, -1],
        viewUp: [0, -1, 0],
        viewRight: [1, 0, 0],
    },
    sagittal: {
        viewPlaneNormal: [1, 0, 0],
        viewUp: [0, 0, 1],
        viewRight: [0, 1, 0],
    },
    coronal: {
        viewPlaneNormal: [0, -1, 0],
        viewUp: [0, 0, 1],
        viewRight: [1, 0, 0],
    },
};
const mprCameraValues = utilities_deepFreeze(MPR_CAMERA_VALUES);
/* harmony default export */ const constants_mprCameraValues = (mprCameraValues);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/viewportPresets.js
const presets = [
    {
        name: 'CT-AAA',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-AAA2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Bone',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Bones',
        gradientOpacity: '4 0 1 985.12 1',
        specularPower: '1',
        scalarOpacity: '8 -1000 0 152.19 0 278.93 0.190476 952 0.2',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cardiac3',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Chest-Contrast-Enhanced',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Chest-Vessels',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries-2',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Coronary-Arteries-3',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Cropped-Volume-Bone',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -2048 0 -451 0 -450 1 1050 1 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Fat',
        gradientOpacity: '6 0 1 985.12 1 988 1',
        specularPower: '1',
        scalarOpacity: '14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Liver-Vasculature',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Lung',
        gradientOpacity: '6 0 1 985.12 1 988 1',
        specularPower: '1',
        scalarOpacity: '12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-MIP',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0 -637.62 0 700 1 3071 1',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Muscle',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'CT-Pulmonary-Arteries',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Soft-Tissue',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '10 -2048 0 -167.01 0 -160 1 240 1 3661 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'CT-Air',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '10',
        scalarOpacity: '8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0',
        specular: '0.2',
        shade: '1',
        ambient: '0.1',
        colorTransfer: '16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ',
        diffuse: '0.9',
        interpolation: '1',
    },
    {
        name: 'MR-Angio',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-Default',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5',
        specular: '0',
        shade: '1',
        ambient: '0.2',
        colorTransfer: '24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-MIP',
        gradientOpacity: '4 0 1 255 1',
        specularPower: '1',
        scalarOpacity: '8 0 0 98.3725 0 416.637 1 2800 1',
        specular: '0',
        shade: '0',
        ambient: '0.2',
        colorTransfer: '16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1',
        diffuse: '1',
        interpolation: '1',
    },
    {
        name: 'MR-T2-Brain',
        gradientOpacity: '4 0 1 160.25 1',
        specularPower: '40',
        scalarOpacity: '10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1',
        specular: '0.5',
        shade: '1',
        ambient: '0.3',
        colorTransfer: '16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1',
        diffuse: '0.6',
        interpolation: '1',
    },
    {
        name: 'DTI-FA-Brain',
        gradientOpacity: '4 0 1 0.9950 1',
        specularPower: '40',
        scalarOpacity: '16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0',
        specular: '0.5',
        shade: '1',
        ambient: '0.3',
        colorTransfer: '28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0',
        diffuse: '0.9',
        interpolation: '1',
    },
];
/* harmony default export */ const viewportPresets = (presets);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/backgroundColors.js
const backgroundColors = {
    slicer3D: [160 / 255, 164 / 255, 217 / 255],
};
/* harmony default export */ const constants_backgroundColors = ((/* unused pure expression or super */ null && (backgroundColors)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/constants/index.js









/***/ }),

/***/ 63591:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export BlendModes */
/* harmony import */ var _kitware_vtk_js_Rendering_Core_VolumeMapper_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67737);

const { BlendMode } = _kitware_vtk_js_Rendering_Core_VolumeMapper_Constants__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay;
var BlendModes;
(function (BlendModes) {
    BlendModes[BlendModes["COMPOSITE"] = BlendMode.COMPOSITE_BLEND] = "COMPOSITE";
    BlendModes[BlendModes["MAXIMUM_INTENSITY_BLEND"] = BlendMode.MAXIMUM_INTENSITY_BLEND] = "MAXIMUM_INTENSITY_BLEND";
    BlendModes[BlendModes["MINIMUM_INTENSITY_BLEND"] = BlendMode.MINIMUM_INTENSITY_BLEND] = "MINIMUM_INTENSITY_BLEND";
    BlendModes[BlendModes["AVERAGE_INTENSITY_BLEND"] = BlendMode.AVERAGE_INTENSITY_BLEND] = "AVERAGE_INTENSITY_BLEND";
    BlendModes[BlendModes["LABELMAP_EDGE_PROJECTION_BLEND"] = BlendMode.LABELMAP_EDGE_PROJECTION_BLEND] = "LABELMAP_EDGE_PROJECTION_BLEND";
})(BlendModes || (BlendModes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlendModes);


/***/ }),

/***/ 38059:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export CalibrationTypes */
var CalibrationTypes;
(function (CalibrationTypes) {
    CalibrationTypes["NOT_APPLICABLE"] = "";
    CalibrationTypes["ERMF"] = "ERMF";
    CalibrationTypes["USER"] = "User";
    CalibrationTypes["PROJECTION"] = "Proj";
    CalibrationTypes["REGION"] = "Region";
    CalibrationTypes["ERROR"] = "Error";
    CalibrationTypes["UNCALIBRATED"] = "Uncalibrated";
    CalibrationTypes["CALIBRATED"] = "Calibrated";
    CalibrationTypes["UNKNOWN"] = "Unknown";
})(CalibrationTypes || (CalibrationTypes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrationTypes);


/***/ }),

/***/ 86066:
/***/ (() => {

"use strict";
var ContourType;
(function (ContourType) {
    ContourType["CLOSED_PLANAR"] = "CLOSED_PLANAR";
    ContourType["OPEN_PLANAR"] = "OPEN_PLANAR";
})(ContourType || (ContourType = {}));
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (ContourType)));


/***/ }),

/***/ 91369:
/***/ (() => {

"use strict";
var DynamicOperatorType;
(function (DynamicOperatorType) {
    DynamicOperatorType["SUM"] = "SUM";
    DynamicOperatorType["AVERAGE"] = "AVERAGE";
    DynamicOperatorType["SUBTRACT"] = "SUBTRACT";
})(DynamicOperatorType || (DynamicOperatorType = {}));
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (DynamicOperatorType)));


/***/ }),

/***/ 32643:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["ERROR_EVENT"] = "CORNERSTONE_ERROR";
    Events["CACHE_SIZE_EXCEEDED"] = "CACHE_SIZE_EXCEEDED";
    Events["IMAGE_LOAD_ERROR"] = "IMAGE_LOAD_ERROR";
    Events["CAMERA_MODIFIED"] = "CORNERSTONE_CAMERA_MODIFIED";
    Events["CAMERA_RESET"] = "CORNERSTONE_CAMERA_RESET";
    Events["VOI_MODIFIED"] = "CORNERSTONE_VOI_MODIFIED";
    Events["PRESET_MODIFIED"] = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED";
    Events["DISPLAY_AREA_MODIFIED"] = "CORNERSTONE_DISPLAY_AREA_MODIFIED";
    Events["ELEMENT_DISABLED"] = "CORNERSTONE_ELEMENT_DISABLED";
    Events["ELEMENT_ENABLED"] = "CORNERSTONE_ELEMENT_ENABLED";
    Events["IMAGE_RENDERED"] = "CORNERSTONE_IMAGE_RENDERED";
    Events["IMAGE_VOLUME_MODIFIED"] = "CORNERSTONE_IMAGE_VOLUME_MODIFIED";
    Events["IMAGE_VOLUME_LOADING_COMPLETED"] = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED";
    Events["IMAGE_LOADED"] = "CORNERSTONE_IMAGE_LOADED";
    Events["IMAGE_RETRIEVAL_STAGE"] = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE";
    Events["IMAGE_LOAD_FAILED"] = "CORNERSTONE_IMAGE_LOAD_FAILED";
    Events["VOLUME_VIEWPORT_NEW_VOLUME"] = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME";
    Events["VOLUME_LOADED"] = "CORNERSTONE_VOLUME_LOADED";
    Events["VOLUME_LOADED_FAILED"] = "CORNERSTONE_VOLUME_LOADED_FAILED";
    Events["IMAGE_CACHE_IMAGE_ADDED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED";
    Events["IMAGE_CACHE_IMAGE_REMOVED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED";
    Events["VOLUME_CACHE_VOLUME_ADDED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED";
    Events["VOLUME_CACHE_VOLUME_REMOVED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED";
    Events["STACK_NEW_IMAGE"] = "CORNERSTONE_STACK_NEW_IMAGE";
    Events["VOLUME_NEW_IMAGE"] = "CORNERSTONE_VOLUME_NEW_IMAGE";
    Events["PRE_STACK_NEW_IMAGE"] = "CORNERSTONE_PRE_STACK_NEW_IMAGE";
    Events["IMAGE_SPACING_CALIBRATED"] = "CORNERSTONE_IMAGE_SPACING_CALIBRATED";
    Events["VIEWPORT_NEW_IMAGE_SET"] = "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET";
    Events["STACK_VIEWPORT_SCROLL"] = "CORNERSTONE_STACK_VIEWPORT_SCROLL";
    Events["STACK_SCROLL_OUT_OF_BOUNDS"] = "STACK_SCROLL_OUT_OF_BOUNDS";
    Events["GEOMETRY_CACHE_GEOMETRY_ADDED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED";
    Events["GEOMETRY_CACHE_GEOMETRY_REMOVED"] = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED";
    Events["VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS"] = "VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS";
    Events["VOLUME_VIEWPORT_SCROLL"] = "VOLUME_VIEWPORT_SCROLL";
    Events["CLIPPING_PLANES_UPDATED"] = "CORNERSTONE_CLIPPING_PLANES_UPDATED";
    Events["WEB_WORKER_PROGRESS"] = "CORNERSTONE_WEB_WORKER_PROGRESS";
    Events["COLORMAP_MODIFIED"] = "CORNERSTONE_COLORMAP_MODIFIED";
    Events["DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED"] = "DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED";
    Events["DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED"] = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED";
    Events["DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED"] = "DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED";
    Events["DYNAMIC_VOLUME_TIME_POINT_LOADED"] = "DYNAMIC_VOLUME_TIME_POINT_LOADED";
    Events["GEOMETRY_LOADED"] = "GEOMETRY_LOADED";
    Events["GEOMETRY_LOAD_PROGRESS"] = "GEOMETRY_LOAD_PROGRESS";
    Events["GEOMETRY_LOADED_FAILED"] = "GEOMETRY_LOADED_FAILED";
    Events["ACTORS_CHANGED"] = "CORNERSTONE_ACTORS_CHANGED";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 91346:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var GeometryType;
(function (GeometryType) {
    GeometryType["CONTOUR"] = "CONTOUR";
    GeometryType["SURFACE"] = "SURFACE";
    GeometryType["MESH"] = "MESH";
})(GeometryType || (GeometryType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeometryType);


/***/ }),

/***/ 77474:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ImageQualityStatus;
(function (ImageQualityStatus) {
    ImageQualityStatus[ImageQualityStatus["FAR_REPLICATE"] = 1] = "FAR_REPLICATE";
    ImageQualityStatus[ImageQualityStatus["ADJACENT_REPLICATE"] = 3] = "ADJACENT_REPLICATE";
    ImageQualityStatus[ImageQualityStatus["SUBRESOLUTION"] = 6] = "SUBRESOLUTION";
    ImageQualityStatus[ImageQualityStatus["LOSSY"] = 7] = "LOSSY";
    ImageQualityStatus[ImageQualityStatus["FULL_RESOLUTION"] = 8] = "FULL_RESOLUTION";
})(ImageQualityStatus || (ImageQualityStatus = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageQualityStatus);


/***/ }),

/***/ 29310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var InterpolationType;
(function (InterpolationType) {
    InterpolationType[InterpolationType["NEAREST"] = 0] = "NEAREST";
    InterpolationType[InterpolationType["LINEAR"] = 1] = "LINEAR";
    InterpolationType[InterpolationType["FAST_LINEAR"] = 2] = "FAST_LINEAR";
})(InterpolationType || (InterpolationType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterpolationType);


/***/ }),

/***/ 32731:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var MeshType;
(function (MeshType) {
    MeshType["PLY"] = "PLY";
    MeshType["STL"] = "STL";
    MeshType["OBJ"] = "OBJ";
    MeshType["VTP"] = "VTP";
})(MeshType || (MeshType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeshType);


/***/ }),

/***/ 69850:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var MetadataModules;
(function (MetadataModules) {
    MetadataModules["CALIBRATION"] = "calibrationModule";
    MetadataModules["CINE"] = "cineModule";
    MetadataModules["GENERAL_IMAGE"] = "generalImageModule";
    MetadataModules["GENERAL_SERIES"] = "generalSeriesModule";
    MetadataModules["GENERAL_STUDY"] = "generalStudyModule";
    MetadataModules["IMAGE_PIXEL"] = "imagePixelModule";
    MetadataModules["IMAGE_PLANE"] = "imagePlaneModule";
    MetadataModules["IMAGE_URL"] = "imageUrlModule";
    MetadataModules["MODALITY_LUT"] = "modalityLutModule";
    MetadataModules["MULTIFRAME"] = "multiframeModule";
    MetadataModules["NM_MULTIFRAME_GEOMETRY"] = "nmMultiframeGeometryModule";
    MetadataModules["OVERLAY_PLANE"] = "overlayPlaneModule";
    MetadataModules["PATIENT"] = "patientModule";
    MetadataModules["PATIENT_STUDY"] = "patientStudyModule";
    MetadataModules["PET_IMAGE"] = "petImageModule";
    MetadataModules["PET_ISOTOPE"] = "petIsotopeModule";
    MetadataModules["PET_SERIES"] = "petSeriesModule";
    MetadataModules["SOP_COMMON"] = "sopCommonModule";
    MetadataModules["ULTRASOUND_ENHANCED_REGION"] = "ultrasoundEnhancedRegionModule";
    MetadataModules["VOI_LUT"] = "voiLutModule";
    MetadataModules["WADO_WEB_CLIENT"] = "wadoWebClient";
})(MetadataModules || (MetadataModules = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MetadataModules);


/***/ }),

/***/ 18735:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var OrientationAxis;
(function (OrientationAxis) {
    OrientationAxis["AXIAL"] = "axial";
    OrientationAxis["CORONAL"] = "coronal";
    OrientationAxis["SAGITTAL"] = "sagittal";
    OrientationAxis["ACQUISITION"] = "acquisition";
})(OrientationAxis || (OrientationAxis = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrientationAxis);


/***/ }),

/***/ 43213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var RequestType;
(function (RequestType) {
    RequestType["Interaction"] = "interaction";
    RequestType["Thumbnail"] = "thumbnail";
    RequestType["Prefetch"] = "prefetch";
    RequestType["Compute"] = "compute";
})(RequestType || (RequestType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RequestType);


/***/ }),

/***/ 82501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var VOILUTFunctionType;
(function (VOILUTFunctionType) {
    VOILUTFunctionType["LINEAR"] = "LINEAR";
    VOILUTFunctionType["SAMPLED_SIGMOID"] = "SIGMOID";
    VOILUTFunctionType["LINEAR_EXACT"] = "LINEAR_EXACT";
})(VOILUTFunctionType || (VOILUTFunctionType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VOILUTFunctionType);


/***/ }),

/***/ 13545:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpeedUnit: () => (/* binding */ SpeedUnit)
/* harmony export */ });
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit["FRAME"] = "f";
    SpeedUnit["SECOND"] = "s";
})(SpeedUnit || (SpeedUnit = {}));



/***/ }),

/***/ 1814:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ViewportStatus;
(function (ViewportStatus) {
    ViewportStatus["NO_DATA"] = "noData";
    ViewportStatus["LOADING"] = "loading";
    ViewportStatus["PRE_RENDER"] = "preRender";
    ViewportStatus["RESIZE"] = "resize";
    ViewportStatus["RENDERED"] = "rendered";
})(ViewportStatus || (ViewportStatus = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ViewportStatus);


/***/ }),

/***/ 41864:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ViewportType;
(function (ViewportType) {
    ViewportType["STACK"] = "stack";
    ViewportType["ORTHOGRAPHIC"] = "orthographic";
    ViewportType["PERSPECTIVE"] = "perspective";
    ViewportType["VOLUME_3D"] = "volume3d";
    ViewportType["VIDEO"] = "video";
    ViewportType["WHOLE_SLIDE"] = "wholeSlide";
})(ViewportType || (ViewportType = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ViewportType);


/***/ }),

/***/ 6796:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var VoxelManagerEnum;
(function (VoxelManagerEnum) {
    VoxelManagerEnum["RLE"] = "RLE";
    VoxelManagerEnum["Volume"] = "Volume";
})(VoxelManagerEnum || (VoxelManagerEnum = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VoxelManagerEnum);


/***/ }),

/***/ 10364:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class CornerstoneEventTarget {
    constructor() {
        this.listeners = {};
        this.debouncedListeners = {};
    }
    reset() {
        this.listeners = {};
        this.debouncedListeners = {};
    }
    addEventListenerOnce(type, callback) {
        const onceWrapper = (event) => {
            this.removeEventListener(type, onceWrapper);
            callback.call(this, event);
        };
        this.addEventListener(type, onceWrapper);
    }
    addEventListener(type, callback) {
        if (!this.listeners[type]) {
            this.listeners[type] = [];
        }
        if (this.listeners[type].indexOf(callback) !== -1) {
            return;
        }
        this.listeners[type].push(callback);
    }
    addEventListenerDebounced(type, callback, delay) {
        this.debouncedListeners[type] = this.debouncedListeners[type] || {};
        const debouncedCallbacks = this.debouncedListeners[type];
        if (!debouncedCallbacks[callback]) {
            const handle = (event) => {
                if (debouncedCallbacks[callback]) {
                    clearTimeout(debouncedCallbacks[callback].timeoutId);
                }
                debouncedCallbacks[callback].timeoutId = setTimeout(() => {
                    callback.call(this, event);
                }, delay);
            };
            debouncedCallbacks[callback] = {
                original: callback,
                handle,
                timeoutId: null,
            };
            this.addEventListener(type, handle);
        }
    }
    removeEventListenerDebounced(type, callback) {
        if (this.debouncedListeners[type]?.[callback]) {
            const debounced = this.debouncedListeners[type][callback];
            this.removeEventListener(type, debounced.handle);
            clearTimeout(debounced.timeoutId);
            delete this.debouncedListeners[type][callback];
        }
    }
    removeEventListener(type, callback) {
        if (!this.listeners[type]) {
            return;
        }
        const stack = this.listeners[type];
        const stackLength = stack.length;
        for (let i = 0; i < stackLength; i++) {
            if (stack[i] === callback) {
                stack.splice(i, 1);
                return;
            }
        }
    }
    dispatchEvent(event) {
        if (!this.listeners[event.type]) {
            return !event.defaultPrevented;
        }
        const stack = this.listeners[event.type].slice();
        const stackLength = stack.length;
        for (let i = 0; i < stackLength; i++) {
            try {
                stack[i].call(this, event);
            }
            catch (error) {
                console.error(`error in event listener of type:  ${event.type}`, error);
            }
        }
        return !event.defaultPrevented;
    }
}
const eventTarget = new CornerstoneEventTarget();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (eventTarget);


/***/ }),

/***/ 86846:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ getEnabledElement),
/* harmony export */   b1: () => (/* binding */ getEnabledElementByIds),
/* harmony export */   yj: () => (/* binding */ getEnabledElementByViewportId),
/* harmony export */   zb: () => (/* binding */ getEnabledElements)
/* harmony export */ });
/* harmony import */ var _RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39536);

function getEnabledElement(element) {
    if (!element) {
        return;
    }
    const { viewportUid, renderingEngineUid } = element.dataset;
    return getEnabledElementByIds(viewportUid, renderingEngineUid);
}
function getEnabledElementByIds(viewportId, renderingEngineId) {
    if (!renderingEngineId || !viewportId) {
        return;
    }
    const renderingEngine = (0,_RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay)(renderingEngineId);
    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {
        return;
    }
    const viewport = renderingEngine.getViewport(viewportId);
    if (!viewport) {
        return;
    }
    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
    return {
        viewport,
        renderingEngine,
        viewportId,
        renderingEngineId,
        FrameOfReferenceUID,
    };
}
function getEnabledElementByViewportId(viewportId) {
    const renderingEngines = (0,_RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .getRenderingEngines */ .qO)();
    for (let i = 0; i < renderingEngines.length; i++) {
        const renderingEngine = renderingEngines[i];
        const viewport = renderingEngine.getViewport(viewportId);
        if (viewport) {
            return getEnabledElementByIds(viewportId, renderingEngine.id);
        }
    }
}
function getEnabledElements() {
    const enabledElements = [];
    const renderingEngines = (0,_RenderingEngine_getRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .getRenderingEngines */ .qO)();
    renderingEngines.forEach((renderingEngine) => {
        const viewports = renderingEngine.getViewports();
        viewports.forEach(({ element }) => {
            enabledElements.push(getEnabledElement(element));
        });
    });
    return enabledElements;
}


/***/ }),

/***/ 26896:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  lk: () => (/* binding */ canRenderFloatTextures),
  up: () => (/* binding */ getCanUseNorm16Texture),
  D0: () => (/* binding */ getConfiguration),
  LH: () => (/* binding */ getShouldUseCPURendering),
  G_: () => (/* binding */ getWebWorkerManager),
  Dh: () => (/* binding */ isCornerstoneInitialized),
  a: () => (/* binding */ peerImport)
});

// UNUSED EXPORTS: init, resetInitialization, resetUseCPURendering, setConfiguration, setPreferSizeOverAccuracy, setUseCPURendering

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/getRenderingEngine.js
var getRenderingEngine = __webpack_require__(39536);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepMerge.js
var utilities_deepMerge = __webpack_require__(74268);
// EXTERNAL MODULE: ../../../node_modules/comlink/dist/esm/comlink.mjs
var comlink = __webpack_require__(99178);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/requestPoolManager.js
var requestPoolManager = __webpack_require__(24743);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/webWorkerManager/webWorkerManager.js



class CentralizedWorkerManager {
    constructor() {
        this.workerRegistry = {};
        this.workerPoolManager = new requestPoolManager/* RequestPoolManager */.R('webworker');
    }
    registerWorker(workerName, workerFn, options = {}) {
        const { maxWorkerInstances = 1, overwrite = false, autoTerminateOnIdle = {
            enabled: false,
            idleTimeThreshold: 3000,
        }, } = options;
        if (this.workerRegistry[workerName] && !overwrite) {
            console.warn(`Worker type '${workerName}' is already registered...`);
            return;
        }
        if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {
            clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);
        }
        const workerProperties = {
            workerFn: null,
            instances: [],
            loadCounters: [],
            lastActiveTime: [],
            nativeWorkers: [],
            autoTerminateOnIdle: autoTerminateOnIdle.enabled,
            idleCheckIntervalId: null,
            idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,
        };
        workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);
        workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);
        for (let i = 0; i < maxWorkerInstances; i++) {
            const worker = workerFn();
            workerProperties.instances.push(comlink/* wrap */.LV(worker));
            workerProperties.nativeWorkers.push(worker);
            workerProperties.workerFn = workerFn;
        }
        this.workerRegistry[workerName] = workerProperties;
    }
    getNextWorkerAPI(workerName) {
        const workerProperties = this.workerRegistry[workerName];
        if (!workerProperties) {
            console.error(`Worker type '${workerName}' is not registered.`);
            return null;
        }
        const workerInstances = workerProperties.instances.filter((instance) => instance !== null);
        let minLoadIndex = 0;
        let minLoadValue = workerProperties.loadCounters[0] || 0;
        for (let i = 1; i < workerInstances.length; i++) {
            const currentLoadValue = workerProperties.loadCounters[i] || 0;
            if (currentLoadValue < minLoadValue) {
                minLoadIndex = i;
                minLoadValue = currentLoadValue;
            }
        }
        if (workerProperties.instances[minLoadIndex] === null) {
            const worker = workerProperties.workerFn();
            workerProperties.instances[minLoadIndex] = comlink/* wrap */.LV(worker);
            workerProperties.nativeWorkers[minLoadIndex] = worker;
        }
        workerProperties.loadCounters[minLoadIndex] += 1;
        return {
            api: workerProperties.instances[minLoadIndex],
            index: minLoadIndex,
        };
    }
    executeTask(workerName, methodName, args = {}, { requestType = enums.RequestType.Compute, priority = 0, options = {}, callbacks = [], } = {}) {
        return new Promise((resolve, reject) => {
            const requestFn = async () => {
                const { api, index } = this.getNextWorkerAPI(workerName);
                if (!api) {
                    const error = new Error(`No available worker instance for '${workerName}'`);
                    console.error(error);
                    reject(error);
                    return;
                }
                try {
                    let finalCallbacks = [];
                    if (callbacks.length) {
                        finalCallbacks = callbacks.map((cb) => {
                            return comlink/* proxy */.BX(cb);
                        });
                    }
                    const workerProperties = this.workerRegistry[workerName];
                    workerProperties.processing = true;
                    const results = await api[methodName](args, ...finalCallbacks);
                    workerProperties.processing = false;
                    workerProperties.lastActiveTime[index] = Date.now();
                    if (workerProperties.autoTerminateOnIdle &&
                        !workerProperties.idleCheckIntervalId &&
                        workerProperties.idleTimeThreshold) {
                        workerProperties.idleCheckIntervalId = setInterval(() => {
                            this.terminateIdleWorkers(workerName, workerProperties.idleTimeThreshold);
                        }, workerProperties.idleTimeThreshold);
                    }
                    resolve(results);
                }
                catch (err) {
                    console.error(`Error executing method '${methodName}' on worker '${workerName}':`, err);
                    reject(err);
                }
                finally {
                    this.workerRegistry[workerName].loadCounters[index]--;
                }
            };
            this.workerPoolManager.addRequest(requestFn, requestType, options, priority);
        });
    }
    terminateIdleWorkers(workerName, idleTimeThreshold) {
        const workerProperties = this.workerRegistry[workerName];
        if (workerProperties.processing) {
            return;
        }
        const now = Date.now();
        workerProperties.instances.forEach((_, index) => {
            const lastActiveTime = workerProperties.lastActiveTime[index];
            const isWorkerActive = lastActiveTime !== null && workerProperties.loadCounters[index] > 0;
            const idleTime = now - lastActiveTime;
            if (!isWorkerActive && idleTime > idleTimeThreshold) {
                this.terminateWorkerInstance(workerName, index);
            }
        });
    }
    terminate(workerName) {
        const workerProperties = this.workerRegistry[workerName];
        if (!workerProperties) {
            console.error(`Worker type '${workerName}' is not registered.`);
            return;
        }
        workerProperties.instances.forEach((_, index) => {
            this.terminateWorkerInstance(workerName, index);
        });
    }
    terminateWorkerInstance(workerName, index) {
        const workerProperties = this.workerRegistry[workerName];
        const workerInstance = workerProperties.instances[index];
        if (workerInstance !== null) {
            workerInstance[comlink/* releaseProxy */.A2]();
            workerProperties.nativeWorkers[index].terminate();
            workerProperties.instances[index] = null;
            workerProperties.lastActiveTime[index] = null;
        }
    }
}
/* harmony default export */ const webWorkerManager = (CentralizedWorkerManager);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/textureSupport.js
const canvasSize = 4;
const texWidth = 5;
const texHeight = 1;
const pixelToCheck = (/* unused pure expression or super */ null && ([1, 1]));
function main({ ext, filterType, texData, internalFormat, glDataType }) {
    try {
        const canvas = document.createElement('canvas');
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            return false;
        }
        const vs = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
        const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
        let extToUse;
        if (ext) {
            extToUse = gl.getExtension(ext);
            if (!extToUse) {
                return false;
            }
        }
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vs);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            return false;
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fs);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            return false;
        }
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            return false;
        }
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat(gl, extToUse), texWidth, texHeight, 0, gl.RED, glDataType(gl, extToUse), texData);
        const filter = filterType === 'LINEAR' ? gl.LINEAR : gl.NEAREST;
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
        gl.useProgram(program);
        gl.drawArrays(gl.POINTS, 0, 1);
        const pixel = new Uint8Array(4);
        gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
        const [r, g, b] = pixel;
        const webglLoseContext = gl.getExtension('WEBGL_lose_context');
        if (webglLoseContext) {
            webglLoseContext.loseContext();
        }
        return r === g && g === b && r !== 0;
    }
    catch (e) {
        return false;
    }
}
function textureSupport_getSupportedTextureFormats() {
    const norm16TexData = new Int16Array([
        32767, 2000, 3000, 4000, 5000, 16784, 7000, 8000, 9000, 32767,
    ]);
    return {
        norm16: main({
            ext: 'EXT_texture_norm16',
            filterType: 'NEAREST',
            texData: norm16TexData,
            internalFormat: (gl, ext) => ext.R16_SNORM_EXT,
            glDataType: (gl) => gl.SHORT,
        }),
        norm16Linear: main({
            ext: 'EXT_texture_norm16',
            filterType: 'LINEAR',
            texData: norm16TexData,
            internalFormat: (gl, ext) => ext.R16_SNORM_EXT,
            glDataType: (gl) => gl.SHORT,
        }),
    };
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/init.js

let csRenderInitialized = false;



const defaultConfig = {
    gpuTier: { tier: 2 },
    isMobile: false,
    rendering: {
        useCPURendering: false,
        preferSizeOverAccuracy: false,
        strictZSpacingForVolumeViewport: true,
    },
    peerImport: (moduleId) => null,
};
let config = {
    ...defaultConfig,
    rendering: { ...defaultConfig.rendering },
};
let init_webWorkerManager = null;
let canUseNorm16Texture = false;
function _getGLContext() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') ||
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl');
    return gl;
}
function _hasActiveWebGLContext() {
    const gl = _getGLContext();
    return (gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext);
}
function _hasNorm16TextureSupport() {
    const supportedTextureFormats = getSupportedTextureFormats();
    return supportedTextureFormats.norm16 && supportedTextureFormats.norm16Linear;
}
function isIOS() {
    if (/iPad|iPhone|iPod/.test(navigator.platform)) {
        return true;
    }
    else {
        return (navigator.maxTouchPoints &&
            navigator.maxTouchPoints > 2 &&
            navigator.platform.includes('MacIntel'));
    }
}
function init(configuration = config) {
    if (csRenderInitialized) {
        return csRenderInitialized;
    }
    canUseNorm16Texture = _hasNorm16TextureSupport();
    config = deepMerge(defaultConfig, configuration);
    if (isIOS()) {
        if (configuration.rendering?.preferSizeOverAccuracy) {
            config.rendering.preferSizeOverAccuracy = true;
        }
        else {
            console.log('norm16 texture not supported, you can turn on the preferSizeOverAccuracy flag to use native data type, but be aware of the inaccuracy of the rendering in high bits');
        }
    }
    const hasWebGLContext = _hasActiveWebGLContext();
    if (!hasWebGLContext) {
        console.log('CornerstoneRender: GPU not detected, using CPU rendering');
        config.rendering.useCPURendering = true;
    }
    else {
        console.log('CornerstoneRender: using GPU rendering');
    }
    csRenderInitialized = true;
    if (!init_webWorkerManager) {
        init_webWorkerManager = new CentralizedWebWorkerManager();
    }
    return csRenderInitialized;
}
function getCanUseNorm16Texture() {
    return canUseNorm16Texture;
}
function setUseCPURendering(status, updateViewports = true) {
    config.rendering.useCPURendering = status;
    csRenderInitialized = true;
    if (updateViewports) {
        _updateRenderingPipelinesForAllViewports();
    }
}
function setPreferSizeOverAccuracy(status) {
    config.rendering.preferSizeOverAccuracy = status;
    csRenderInitialized = true;
    _updateRenderingPipelinesForAllViewports();
}
function canRenderFloatTextures() {
    if (!isIOS()) {
        return true;
    }
    return false;
}
function resetUseCPURendering() {
    config.rendering.useCPURendering = !_hasActiveWebGLContext();
    _updateRenderingPipelinesForAllViewports();
}
function getShouldUseCPURendering() {
    return config.rendering.useCPURendering;
}
function isCornerstoneInitialized() {
    return csRenderInitialized;
}
function resetInitialization() {
    csRenderInitialized = false;
}
function getConfiguration() {
    return config;
}
function setConfiguration(c) {
    config = c;
    _updateRenderingPipelinesForAllViewports();
}
function _updateRenderingPipelinesForAllViewports() {
    getRenderingEngines().forEach((engine) => {
        engine.getViewports().forEach((viewport) => {
            viewport.updateRenderingPipeline();
        });
    });
}
function getWebWorkerManager() {
    if (!init_webWorkerManager) {
        init_webWorkerManager = new webWorkerManager();
    }
    return init_webWorkerManager;
}
async function peerImport(moduleId) {
    return config.peerImport(moduleId);
}



/***/ }),

/***/ 36822:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ke: () => (/* binding */ createProgressive),
  Ay: () => (/* binding */ loaders_ProgressiveRetrieveImages)
});

// UNUSED EXPORTS: ProgressiveRetrieveImages, interleavedRetrieveStages, sequentialRetrieveStages, singleRetrieveStages

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/singleRetrieve.js
const singleRetrieveStages = [
    {
        id: 'initialImages',
        retrieveType: 'single',
    },
];
/* harmony default export */ const singleRetrieve = (singleRetrieveStages);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/sequentialRetrieve.js
const sequentialRetrieveStages = [
    {
        id: 'lossySequential',
        retrieveType: 'singleFast',
    },
    {
        id: 'finalSequential',
        retrieveType: 'singleFinal',
    },
];
/* harmony default export */ const sequentialRetrieve = (sequentialRetrieveStages);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/configuration/interleavedRetrieve.js

const nearbyFrames = [
    {
        offset: -1,
        imageQualityStatus: enums.ImageQualityStatus.ADJACENT_REPLICATE,
    },
    {
        offset: +1,
        imageQualityStatus: enums.ImageQualityStatus.ADJACENT_REPLICATE,
    },
    { offset: +2, imageQualityStatus: enums.ImageQualityStatus.FAR_REPLICATE },
];
const interleavedRetrieveConfiguration = [
    {
        id: 'initialImages',
        positions: [0.5, 0, -1],
        retrieveType: 'default',
        requestType: enums.RequestType.Thumbnail,
        priority: 5,
        nearbyFrames,
    },
    {
        id: 'quarterThumb',
        decimate: 4,
        offset: 3,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFast',
        priority: 6,
        nearbyFrames,
    },
    {
        id: 'halfThumb',
        decimate: 4,
        offset: 1,
        priority: 7,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFast',
        nearbyFrames,
    },
    {
        id: 'quarterFull',
        decimate: 4,
        offset: 2,
        priority: 8,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'halfFull',
        decimate: 4,
        offset: 0,
        priority: 9,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'threeQuarterFull',
        decimate: 4,
        offset: 1,
        priority: 10,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'finalFull',
        decimate: 4,
        offset: 3,
        priority: 11,
        requestType: enums.RequestType.Thumbnail,
        retrieveType: 'multipleFinal',
    },
    {
        id: 'errorRetrieve',
    },
];
/* harmony default export */ const interleavedRetrieve = (interleavedRetrieveConfiguration);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js
var ProgressiveIterator = __webpack_require__(22191);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js
var decimate = __webpack_require__(63470);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = __webpack_require__(51159);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/fillNearbyFrames.js

function fillNearbyFrames(listener, request, image) {
    if (!request?.nearbyRequests?.length) {
        return;
    }
    for (const nearbyItem of request.nearbyRequests) {
        try {
            const { itemId: targetId, imageQualityStatus } = nearbyItem;
            const currentStatus = cache/* default */.Ay.getImageQuality(targetId);
            if (currentStatus !== undefined && currentStatus >= imageQualityStatus) {
                continue;
            }
            const nearbyImage = {
                ...image,
                imageId: targetId,
                imageQualityStatus,
            };
            cache/* default */.Ay.setPartialImage(targetId, nearbyImage);
            listener.successCallback(targetId, nearbyImage);
        }
        catch (e) {
            console.warn("Couldn't fill nearby item ", nearbyItem.itemId, e);
        }
    }
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/ProgressiveRetrieveImages.js













class ProgressiveRetrieveImages {
    static { this.createProgressive = createProgressive; }
    static { this.interleavedRetrieveStages = {
        stages: interleavedRetrieve,
    }; }
    static { this.singleRetrieveStages = {
        stages: singleRetrieve,
    }; }
    static { this.sequentialRetrieveStages = {
        stages: sequentialRetrieve,
    }; }
    constructor(imageRetrieveConfiguration) {
        this.stages = imageRetrieveConfiguration.stages || singleRetrieve;
        this.retrieveOptions = imageRetrieveConfiguration.retrieveOptions || {};
    }
    loadImages(imageIds, listener) {
        const instance = new ProgressiveRetrieveImagesInstance(this, imageIds, listener);
        return instance.loadImages();
    }
}
class ProgressiveRetrieveImagesInstance {
    constructor(configuration, imageIds, listener) {
        this.outstandingRequests = 0;
        this.stageStatusMap = new Map();
        this.displayedIterator = new ProgressiveIterator/* default */.A('displayed');
        this.stages = configuration.stages;
        this.retrieveOptions = configuration.retrieveOptions;
        this.imageIds = imageIds;
        this.listener = listener;
    }
    async loadImages() {
        const interleaved = this.createStageRequests();
        this.outstandingRequests = interleaved.length;
        for (const request of interleaved) {
            this.addRequest(request);
        }
        if (this.outstandingRequests === 0) {
            return Promise.resolve(null);
        }
        return this.displayedIterator.getDonePromise();
    }
    sendRequest(request, options) {
        const { imageId, next } = request;
        const errorCallback = (reason, done) => {
            this.listener.errorCallback(imageId, complete || !next, reason);
            if (done) {
                this.updateStageStatus(request.stage, reason);
            }
        };
        const loadedPromise = (options.loader || imageLoader.loadAndCacheImage)(imageId, options);
        const uncompressedIterator = ProgressiveIterator/* default */.A.as(loadedPromise);
        let complete = false;
        uncompressedIterator
            .forEach(async (image, done) => {
            const oldStatus = cache/* default */.Ay.getImageQuality(imageId);
            if (!image) {
                console.warn('No image retrieved', imageId);
                return;
            }
            const { imageQualityStatus } = image;
            complete ||= imageQualityStatus === enums.ImageQualityStatus.FULL_RESOLUTION;
            if (oldStatus !== undefined && oldStatus > imageQualityStatus) {
                this.updateStageStatus(request.stage, null, true);
                return;
            }
            this.listener.successCallback(imageId, image);
            this.displayedIterator.add(image);
            if (done) {
                this.updateStageStatus(request.stage);
            }
            fillNearbyFrames(this.listener, request, image);
        }, errorCallback)
            .finally(() => {
            if (!complete && next) {
                cache/* default */.Ay.setPartialImage(imageId);
                this.addRequest(next, options.streamingData);
            }
            else {
                if (!complete) {
                    this.listener.errorCallback(imageId, true, "Couldn't decode");
                }
                this.outstandingRequests--;
                for (let skip = next; skip; skip = skip.next) {
                    this.updateStageStatus(skip.stage, null, true);
                }
            }
            if (this.outstandingRequests <= 0) {
                this.displayedIterator.resolve();
            }
        });
        const doneLoad = uncompressedIterator.getDonePromise();
        return doneLoad.catch((e) => null);
    }
    addRequest(request, streamingData = {}) {
        const { imageId, stage } = request;
        const baseOptions = this.listener.getLoaderImageOptions(imageId);
        if (!baseOptions) {
            return;
        }
        const { retrieveType = 'default' } = stage;
        const { retrieveOptions: keyedRetrieveOptions } = this;
        const retrieveOptions = keyedRetrieveOptions[retrieveType] || keyedRetrieveOptions.default;
        const options = {
            ...baseOptions,
            retrieveType,
            retrieveOptions,
            streamingData,
        };
        const priority = stage.priority ?? -5;
        const requestType = stage.requestType || enums.RequestType.Interaction;
        const additionalDetails = { imageId };
        imageLoadPoolManager/* default */.A.addRequest(this.sendRequest.bind(this, request, options), requestType, additionalDetails, priority);
    }
    updateStageStatus(stage, failure, skipped = false) {
        const { id } = stage;
        const stageStatus = this.stageStatusMap.get(id);
        if (!stageStatus) {
            return;
        }
        stageStatus.imageLoadPendingCount--;
        if (failure) {
            stageStatus.imageLoadFailedCount++;
        }
        else if (!skipped) {
            stageStatus.totalImageCount++;
        }
        if (!skipped && !stageStatus.stageStartTime) {
            stageStatus.stageStartTime = Date.now();
        }
        if (!stageStatus.imageLoadPendingCount) {
            const { imageLoadFailedCount: numberOfFailures, totalImageCount: numberOfImages, stageStartTime = Date.now(), startTime, } = stageStatus;
            const detail = {
                stageId: id,
                numberOfFailures,
                numberOfImages,
                stageDurationInMS: stageStartTime ? Date.now() - stageStartTime : null,
                startDurationInMS: Date.now() - startTime,
            };
            (0,triggerEvent/* default */.A)(eventTarget/* default */.A, enums.Events.IMAGE_RETRIEVAL_STAGE, detail);
            this.stageStatusMap.delete(id);
        }
    }
    createStageRequests() {
        const interleaved = new Array();
        const imageRequests = new Map();
        const addStageInstance = (stage, position) => {
            const index = position < 0
                ? this.imageIds.length + position
                : position < 1
                    ? Math.floor((this.imageIds.length - 1) * position)
                    : position;
            const imageId = this.imageIds[index];
            if (!imageId) {
                throw new Error(`No value found to add to requests at ${position}`);
            }
            const request = {
                imageId,
                stage,
                index,
                nearbyRequests: this.findNearbyRequests(index, stage),
            };
            this.addStageStatus(stage);
            const existingRequest = imageRequests.get(imageId);
            if (existingRequest) {
                existingRequest.next = request;
            }
            else {
                interleaved.push(request);
            }
            imageRequests.set(imageId, request);
        };
        for (const stage of this.stages) {
            const indices = stage.positions ||
                (0,decimate/* default */.A)(this.imageIds, stage.decimate || 1, stage.offset ?? 0);
            indices.forEach((index) => {
                addStageInstance(stage, index);
            });
        }
        return interleaved;
    }
    findNearbyRequests(index, stage) {
        const nearby = new Array();
        if (!stage.nearbyFrames) {
            return nearby;
        }
        for (const nearbyItem of stage.nearbyFrames) {
            const nearbyIndex = index + nearbyItem.offset;
            if (nearbyIndex < 0 || nearbyIndex >= this.imageIds.length) {
                continue;
            }
            nearby.push({
                itemId: this.imageIds[nearbyIndex],
                imageQualityStatus: nearbyItem.imageQualityStatus,
                index: nearbyIndex,
            });
        }
        return nearby;
    }
    addStageStatus(stage) {
        const { id } = stage;
        const stageStatus = this.stageStatusMap.get(id) || {
            stageId: id,
            startTime: Date.now(),
            stageStartTime: null,
            totalImageCount: 0,
            imageLoadFailedCount: 0,
            imageLoadPendingCount: 0,
        };
        stageStatus.imageLoadPendingCount++;
        this.stageStatusMap.set(id, stageStatus);
        return stageStatus;
    }
}
function createProgressive(configuration) {
    return new ProgressiveRetrieveImages(configuration);
}
/* harmony default export */ const loaders_ProgressiveRetrieveImages = (ProgressiveRetrieveImages);


/***/ }),

/***/ 56074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ cornerstoneMeshLoader)
/* harmony export */ });
/* harmony import */ var _utils_mesh_createMesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97994);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71851);
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10364);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10297);




function fetchArrayBuffer({ url, signal, onload, loaderOptions, }) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        const defaultHeaders = {};
        const beforeSendHeaders = loaderOptions.beforeSend(xhr, defaultHeaders);
        const headers = Object.assign({}, defaultHeaders, beforeSendHeaders);
        xhr.responseType = 'arraybuffer';
        Object.keys(headers).forEach(function (key) {
            if (headers[key] === null) {
                return;
            }
            xhr.setRequestHeader(key, headers[key]);
        });
        const onLoadHandler = function (e) {
            if (onload && typeof onload === 'function') {
                onload();
            }
            if (signal) {
                signal.removeEventListener('abort', onAbortHandler);
            }
            resolve(xhr.response);
        };
        const onAbortHandler = () => {
            xhr.abort();
            xhr.removeEventListener('load', onLoadHandler);
            reject(new Error('Request aborted'));
        };
        xhr.addEventListener('load', onLoadHandler);
        const onProgress = (loaded, total) => {
            const data = { url, loaded, total };
            (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.triggerEvent)(_eventTarget__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.GEOMETRY_LOAD_PROGRESS, { data });
        };
        xhr.onprogress = function (e) {
            onProgress(e.loaded, e.total);
        };
        if (signal && signal.aborted) {
            xhr.abort();
            reject(new Error('Request aborted'));
        }
        else if (signal) {
            signal.addEventListener('abort', onAbortHandler);
        }
        xhr.send();
    });
}
function cornerstoneMeshLoader(meshId, options, loaderOptions) {
    const promise = new Promise((resolve, reject) => {
        fetchAndProcessMeshData(meshId, options, loaderOptions)
            .then(resolve)
            .catch(reject);
    });
    return {
        promise: promise,
        cancelFn: undefined,
        decache: () => { },
    };
}
async function fetchAndProcessMeshData(meshId, options, loaderOptions) {
    const parts = meshId.split(':');
    const url = parts.slice(1).join(':');
    const meshBuffer = await fetchArrayBuffer({ url, loaderOptions });
    if (!options || !('geometryData' in options)) {
        throw new Error('Mesh must have a geometryData');
    }
    return (0,_utils_mesh_createMesh__WEBPACK_IMPORTED_MODULE_0__/* .createMesh */ .q)(url, {
        ...options.geometryData,
        arrayBuffer: meshBuffer,
    });
}



/***/ }),

/***/ 55509:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export cornerstoneStreamingDynamicImageVolumeLoader */
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50584);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10297);


function cornerstoneStreamingDynamicImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a 4D streaming image volume');
    }
    const { imageIds } = options;
    const { splittingTag, imageIdGroups } = splitImageIdsBy4DTags(imageIds);
    const middleIndex = Math.floor(imageIdGroups.length / 2);
    const volumeProps = generateVolumePropsFromImageIds(imageIdGroups[middleIndex], volumeId);
    const { metadata: volumeMetadata, dimensions, spacing, direction, sizeInBytes, origin, numberOfComponents, dataType, } = volumeProps;
    const scanAxisNormal = direction.slice(6, 9);
    const sortedImageIdGroups = imageIdGroups.map((imageIds) => {
        const sortedImageIds = sortImageIdsAndGetSpacing(imageIds, scanAxisNormal).sortedImageIds;
        return sortedImageIds;
    });
    const sortedFlatImageIds = sortedImageIdGroups.flat();
    const voxelManager = VoxelManager.createScalarDynamicVolumeVoxelManager({
        dimensions,
        imageIdGroups: sortedImageIdGroups,
        dimensionGroupNumber: 1,
        numberOfComponents,
    });
    let streamingImageVolume = new StreamingDynamicImageVolume({
        volumeId,
        metadata: volumeMetadata,
        dimensions,
        spacing,
        origin,
        direction,
        sizeInBytes,
        imageIds: sortedFlatImageIds,
        imageIdGroups: sortedImageIdGroups,
        splittingTag,
        voxelManager,
        numberOfComponents,
        dataType,
    }, {
        imageIds: sortedFlatImageIds,
        loadStatus: {
            loaded: false,
            loading: false,
            cancelled: false,
            cachedFrames: [],
            callbacks: [],
        },
    });
    return {
        promise: Promise.resolve(streamingImageVolume),
        decache: () => {
            streamingImageVolume.destroy();
            streamingImageVolume = null;
        },
        cancel: () => {
            streamingImageVolume.cancelLoading();
        },
    };
}



/***/ }),

/***/ 55500:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ cornerstoneStreamingImageVolumeLoader)
/* harmony export */ });
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49038);
/* harmony import */ var _cache_classes_StreamingImageVolume__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50180);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71851);
/* harmony import */ var _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51159);
/* harmony import */ var _utilities_generateVolumePropsFromImageIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9734);
/* harmony import */ var _imageLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(80068);






function cornerstoneStreamingImageVolumeLoader(volumeId, options) {
    if (!options || !options.imageIds || !options.imageIds.length) {
        throw new Error('ImageIds must be provided to create a streaming image volume');
    }
    async function getStreamingImageVolume() {
        if (options.imageIds[0].split(':')[0] === 'wadouri') {
            const [middleImageIndex, lastImageIndex] = [
                Math.floor(options.imageIds.length / 2),
                options.imageIds.length - 1,
            ];
            const indexesToPrefetch = [0, middleImageIndex, lastImageIndex];
            await Promise.all(indexesToPrefetch.map((index) => {
                if (_cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.isLoaded(options.imageIds[index])) {
                    return Promise.resolve(true);
                }
                return new Promise((resolve, reject) => {
                    const imageId = options.imageIds[index];
                    _requestPool_imageLoadPoolManager__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A.addRequest(async () => {
                        (0,_imageLoader__WEBPACK_IMPORTED_MODULE_5__.loadImage)(imageId)
                            .then(() => {
                            console.log(`Prefetched imageId: ${imageId}`);
                            resolve(true);
                        })
                            .catch((err) => {
                            reject(err);
                        });
                    }, _enums__WEBPACK_IMPORTED_MODULE_2__.RequestType.Prefetch, { volumeId }, 1);
                });
            })).catch(console.error);
        }
        const volumeProps = (0,_utilities_generateVolumePropsFromImageIds__WEBPACK_IMPORTED_MODULE_4__/* .generateVolumePropsFromImageIds */ .D)(options.imageIds, volumeId);
        const { dimensions, spacing, origin, direction, metadata, imageIds, dataType, numberOfComponents, } = volumeProps;
        const streamingImageVolume = new _cache_classes_StreamingImageVolume__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A({
            volumeId,
            metadata,
            dimensions,
            spacing,
            origin,
            direction,
            imageIds,
            dataType,
            numberOfComponents,
        }, {
            imageIds,
            loadStatus: {
                loaded: false,
                loading: false,
                cancelled: false,
                cachedFrames: [],
                callbacks: [],
            },
        });
        return streamingImageVolume;
    }
    const streamingImageVolumePromise = getStreamingImageVolume();
    return {
        promise: streamingImageVolumePromise,
        decache: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.destroy();
                streamingImageVolume = null;
            });
        },
        cancel: () => {
            streamingImageVolumePromise.then((streamingImageVolume) => {
                streamingImageVolume.cancelLoading();
            });
        },
    };
}



/***/ }),

/***/ 89926:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: createAndCacheGeometry, getOptions, loadAndCacheGeometry, loadGeometry, registerGeometryLoader, registerUnknownGeometryLoader, setOptions

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
var Actor = __webpack_require__(80639);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
var Actor2D = __webpack_require__(58601);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/d3-scale/src/index.js + 55 modules
var src = __webpack_require__(95583);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Core_Actor = __webpack_require__(7019);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper = __webpack_require__(82409);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
var Texture = __webpack_require__(61433);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js











// ----------------------------------------------------------------------------
// vtkCubeAxesActor
// ----------------------------------------------------------------------------
// faces are -x x -y y -z z
// point 0 is 0,0,0 and then +x fastest changing, +y then +z
const faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
const faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
const edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
const edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
const faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];

//
// Developer note: This class is broken into the main class and a helper
// class. The main class holds view independent properties (those properties
// that do not change as the view's resolution/aspect ratio change). The
// helper class is instantiated one per view and holds properties that can
// depend on view specific values such as resolution. The helper class code
// could have been left to the View specific implementation (such as
// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by
// multiple rendering backends.
//

// some shared temp variables to reduce heap allocs
const ptv3 = new Float64Array(3);
const pt2v3 = new Float64Array(3);
const tmpv3 = new Float64Array(3);
const tmp2v3 = new Float64Array(3);
const xDir = new Float64Array(3);
const yDir = new Float64Array(3);
const invmat = new Float64Array(16);
function applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultGenerateTicks(dataBounds) {
  const ticks = [];
  const tickStrings = [];
  for (let i = 0; i < 3; i++) {
    const scale = src/* scaleLinear */.m4().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
    ticks[i] = scale.ticks(5);
    const format = scale.tickFormat(5);
    tickStrings[i] = ticks[i].map(format);
  }
  return {
    ticks,
    tickStrings
  };
}

// many properties of this actor depend on the API specific view The main
// dependency being the resolution as that drives what font sizes to use.
// Bacause of this we need to do some of the calculations in a API specific
// subclass. But... we don't want a lot of duplicated code between WebGL and
// WebGPU for example so we have this helper class, that is designed to be
// fairly API independent so that API specific views can call this to do
// most of the work.
function vtkCubeAxesActorHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeAxesActorHelper');
  publicAPI.setRenderable = renderable => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.tmActor.addTexture(model.renderable.getTmTexture());
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    publicAPI.modified();
  };

  // called by updateTexturePolyData
  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
    const value = model.renderable.get_tmAtlas().get(text);
    if (!value) {
      return;
    }
    const coords = model.renderable.getTextPolyData().getPoints().getData();

    // compute pixel to distance factors
    const size = model.lastSize;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
    // moving 0.1 in NDC
    tmpv3[0] += 0.1;
    esm/* vec3.transformMat4 */.eR.transformMat4(pt2v3, tmpv3, imat);
    // results in WC move of
    esm/* vec3.subtract */.eR.subtract(xDir, pt2v3, ptv3);
    tmpv3[0] -= 0.1;
    tmpv3[1] += 0.1;
    esm/* vec3.transformMat4 */.eR.transformMat4(pt2v3, tmpv3, imat);
    // results in WC move of
    esm/* vec3.subtract */.eR.subtract(yDir, pt2v3, ptv3);
    for (let i = 0; i < 3; i++) {
      xDir[i] /= 0.5 * 0.1 * size[0];
      yDir[i] /= 0.5 * 0.1 * size[1];
    }

    // have to find the four corners of the texture polygon for this label
    // convert anchor point to View Coords
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    // horizontal left, right, or middle alignment based on dir[0]
    if (dir[0] < -0.5) {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset - value.width);
    } else if (dir[0] > 0.5) {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset);
    } else {
      esm/* vec3.scale */.eR.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);
    }
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    esm/* vec3.scale */.eR.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, xDir, value.width);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, yDir, value.height);
    esm/* vec3.add */.eR.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    esm/* vec3.scale */.eR.scale(tmpv3, xDir, value.width);
    esm/* vec3.subtract */.eR.subtract(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;

    // add the two triangles to represent the quad
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };

  // update the polydata associated with drawing the text labels
  // specifically the quads used for each label and their associated tcoords
  // etc. This changes every time the camera viewpoint changes
  publicAPI.updateTexturePolyData = () => {
    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
    esm/* mat4.transpose */.pB.transpose(cmat, cmat);

    // update the polydata
    const numLabels = model.renderable.getTextValues().length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    esm/* mat4.invert */.pB.invert(invmat, cmat);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    let ptIdx = 0;
    let textIdx = 0;
    let axisIdx = 0;
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const textValues = model.renderable.getTextValues();
    while (ptIdx < coords.length / 3) {
      // compute the direction to move out
      ptv3[0] = coords[ptIdx * 3];
      ptv3[1] = coords[ptIdx * 3 + 1];
      ptv3[2] = coords[ptIdx * 3 + 2];
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
      ptv3[0] = coords[ptIdx * 3 + 3];
      ptv3[1] = coords[ptIdx * 3 + 4];
      ptv3[2] = coords[ptIdx * 3 + 5];
      esm/* vec3.transformMat4 */.eR.transformMat4(tmp2v3, ptv3, cmat);
      esm/* vec3.subtract */.eR.subtract(tmpv3, tmpv3, tmp2v3);
      const dir = [tmpv3[0], tmpv3[1]];
      (0,Core_Math.Q)(dir);

      // write the axis label
      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
      ptIdx += 2;
      textIdx++;

      // write the tick labels
      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
        ptIdx++;
        textIdx++;
      }
      axisIdx++;
    }
    const tcoordDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: 'TextureCoordinates'
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    // has the size changed?
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    model.camera = camera;

    // compute bounds for label quads whenever the camera changes
    publicAPI.updateTexturePolyData();
  };
}
const newCubeAxesActorHelper = macros2.m.newInstance(function (publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  model.tmPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.tmMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmActor = Core_Actor/* default.newInstance */.Ay.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  macros2.m.setGet(publicAPI, model, ['renderable']);
  macros2.m.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);
  model.forceUpdate = false;
  model.lastRedrawTime = {};
  macros2.m.obj(model.lastRedrawTime, {
    mtime: 0
  });
  model.lastRebuildTime = {};
  macros2.m.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];

  // internal variables
  model.lastTickBounds = [];
  vtkCubeAxesActorHelper(publicAPI, model);
}, 'vtkCubeAxesActorHelper');
function vtkCubeAxesActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeAxesActor');
  publicAPI.setCamera = cam => {
    if (model.camera === cam) {
      return;
    }
    if (model.cameraModifiedSub) {
      model.cameraModifiedSub.unsubscribe();
      model.cameraModifiedSub = null;
    }
    model.camera = cam;
    if (cam) {
      model.cameraModifiedSub = cam.onModified(publicAPI.update);
    }
    publicAPI.update();
    publicAPI.modified();
  };

  // estimate from a camera model what faces to draw
  // return true if the list of faces to draw has changed
  publicAPI.computeFacesToDraw = () => {
    const cmat = model.camera.getViewMatrix();
    esm/* mat4.transpose */.pB.transpose(cmat, cmat);
    let changed = false;
    const length = BoundingBox/* default.getDiagonalLength */.Ay.getDiagonalLength(model.dataBounds);
    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);
    for (let f = 0; f < 6; f++) {
      let drawit = false;
      const faceAxis = Math.floor(f / 2);
      const otherAxis1 = (faceAxis + 1) % 3;
      const otherAxis2 = (faceAxis + 2) % 3;
      // only for non degenerate axes
      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
        // for each face transform the center and off center to get a direction vector
        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];
        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
        esm/* vec3.transformMat4 */.eR.transformMat4(tmpv3, ptv3, cmat);
        ptv3[faceAxis] = model.dataBounds[f];
        esm/* vec3.transformMat4 */.eR.transformMat4(tmp2v3, ptv3, cmat);
        esm/* vec3.subtract */.eR.subtract(tmpv3, tmp2v3, tmpv3);
        esm/* vec3.normalize */.eR.normalize(tmpv3, tmpv3);
        // tmpv3 now holds the face normal vector
        drawit = tmpv3[2] > faceDot;
        // for perspctive we need the view direction to the plane
        if (!model.camera.getParallelProjection()) {
          esm/* vec3.normalize */.eR.normalize(tmp2v3, tmp2v3);
          drawit = esm/* vec3.dot */.eR.dot(tmp2v3, tmpv3) > faceDot;
        }
      }
      if (drawit !== model.lastFacesToDraw[f]) {
        model.lastFacesToDraw[f] = drawit;
        changed = true;
      }
    }
    return changed;
  };

  // update the polydata that represents the boundingd edges and gridlines
  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {
    // compute the number of points and lines required
    let numPts = 0;
    let numLines = 0;
    numPts += 8; // always start with the 8 cube points

    // count edgesToDraw
    let numEdgesToDraw = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        numEdgesToDraw++;
      }
    }
    numLines += numEdgesToDraw;

    // add values for gridlines
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;
          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;
        }
      }
    }

    // now allocate the memory
    const points = new Float64Array(numPts * 3);
    const lines = new Uint32Array(numLines * 3);
    let ptIdx = 0;
    let lineIdx = 0;

    // add the 8 corner points
    for (let z = 0; z < 2; z++) {
      for (let y = 0; y < 2; y++) {
        for (let x = 0; x < 2; x++) {
          points[ptIdx * 3] = model.dataBounds[x];
          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
          ptIdx++;
        }
      }
    }

    // draw the edges
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        lines[lineIdx * 3] = 2;
        lines[lineIdx * 3 + 1] = edgePoints[e][0];
        lines[lineIdx * 3 + 2] = edgePoints[e][1];
        lineIdx++;
      }
    }

    // now handle gridlines
    // grid lines are tick[axis1] + ticks[axes2] lines each having two points
    // for simplicity we don;t worry about duplicating points, this is tiny

    if (model.gridLines) {
      // for each visible face
      // add the points
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          const faceIdx = Math.floor(f / 2);
          let aticks = ticks[faceAxes[f][0]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
          aticks = ticks[faceAxes[f][1]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
        }
      }
    }
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getLines().setData(lines, 1);
    model.polyData.getLines().modified();
    model.polyData.modified();
  };

  // update the data that represents where to put the labels
  // in world coordinates. This only changes when faces to draw changes
  // of dataBounds changes
  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {
    // count outside edgesToDraw
    let textPointCount = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] === 1) {
        textPointCount += 2;
        textPointCount += ticks[edgeAxes[e]].length;
      }
    }
    const points = model.polyData.getPoints().getData();
    const textPoints = new Float64Array(textPointCount * 3);
    let ptIdx = 0;
    let textIdx = 0;
    let axisCount = 0;
    for (let f = 0; f < 6; f++) {
      if (facesToDraw[f]) {
        for (let e = 0; e < 4; e++) {
          const edgeIdx = faceEdges[f][e];
          if (edgesToDraw[edgeIdx] === 1) {
            const edgeAxis = edgeAxes[edgeIdx];
            // add a middle point on the edge
            const ptIdx1 = edgePoints[edgeIdx][0] * 3;
            const ptIdx2 = edgePoints[edgeIdx][1] * 3;
            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
            ptIdx++;
            // add a middle face point, we use this to
            // move the labels away from the edge in the right direction
            const faceIdx = Math.floor(f / 2);
            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
            ptIdx++;
            // set the text
            model.textValues[textIdx] = model.axisLabels[edgeAxis];
            textIdx++;

            // now add the tick marks along the edgeAxis
            const otherAxis1 = (edgeAxis + 1) % 3;
            const otherAxis2 = (edgeAxis + 2) % 3;
            const aticks = ticks[edgeAxis];
            const atickStrings = tickStrings[edgeAxis];
            model.tickCounts[axisCount] = aticks.length;
            for (let t = 0; t < aticks.length; t++) {
              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
              ptIdx++;
              // set the text
              model.textValues[textIdx] = atickStrings[t];
              textIdx++;
            }
            axisCount++;
          }
        }
      }
    }
    model.textPolyData.getPoints().setData(textPoints, 3);
    model.textPolyData.modified();
  };

  // main method to rebuild the cube axes, gets called on camera modify
  // and changes to key members
  publicAPI.update = () => {
    // Can't do anything if we don't have a camera...
    if (!model.camera) {
      return;
    }

    // compute what faces to draw
    const facesChanged = publicAPI.computeFacesToDraw();
    const facesToDraw = model.lastFacesToDraw;

    // have the bounds changed?
    let boundsChanged = false;
    for (let i = 0; i < 6; i++) {
      if (model.dataBounds[i] !== model.lastTickBounds[i]) {
        boundsChanged = true;
        model.lastTickBounds[i] = model.dataBounds[i];
      }
    }

    // did something significant change? If so rebuild a lot of things
    if (facesChanged || boundsChanged || model.forceUpdate) {
      // compute the edges to draw
      // for each drawn face, mark edges, all single mark edges we draw
      const edgesToDraw = new Array(12).fill(0);
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            edgesToDraw[faceEdges[f][e]]++;
          }
        }
      }

      // compute tick marks for axes
      const t = model.generateTicks(model.dataBounds);

      // update gridlines / edge lines
      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);

      // compute label world coords and text
      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);

      // rebuild the texture only when force or changed bounds, face
      // visibility changes do to change the atlas
      if (boundsChanged || model.forceUpdate) {
        publicAPI.updateTextureAtlas(t.tickStrings);
      }
    }
    model.forceUpdate = false;
  };

  // create the texture map atlas that contains the rendering of
  // all the text strings. Only needs to be called when the text strings
  // have changed (labels and ticks)
  publicAPI.updateTextureAtlas = tickStrings => {
    // compute the width and height we need

    // set the text properties
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';

    // first the three labels
    model._tmAtlas.clear();
    let maxWidth = 0;
    let totalHeight = 1; // start one pixel in so we have a border
    for (let i = 0; i < 3; i++) {
      if (!model._tmAtlas.has(model.axisLabels[i])) {
        applyTextStyle(model.tmContext, model.axisTextStyle);
        const metrics = model.tmContext.measureText(model.axisLabels[i]);
        const entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.axisTextStyle
        };
        model._tmAtlas.set(model.axisLabels[i], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
      }
      // and the ticks
      applyTextStyle(model.tmContext, model.tickTextStyle);
      for (let t = 0; t < tickStrings[i].length; t++) {
        if (!model._tmAtlas.has(tickStrings[i][t])) {
          const metrics = model.tmContext.measureText(tickStrings[i][t]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          model._tmAtlas.set(tickStrings[i][t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
      }
    }

    // always use power of two to avoid interpolation
    // in cases where PO2 is required
    maxWidth = (0,Core_Math.R)(maxWidth);
    totalHeight = (0,Core_Math.R)(totalHeight);

    // set the tcoord values
    model._tmAtlas.forEach(value => {
      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
    });

    // make sure we have power of two dimensions
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

    // draw the text onto the texture
    model._tmAtlas.forEach((value, key) => {
      applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
  };

  // Make sure the data is correct
  publicAPI.onModified(() => {
    model.forceUpdate = true;
    publicAPI.update();
  });
  publicAPI.setTickTextStyle = tickStyle => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = axisStyle => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.get_tmAtlas = () => model._tmAtlas;

  // try to get the bounds for the annotation. This is complicated
  // as it relies on the pixel size of the window. Every time the camera
  // changes the bounds change. This method simplifies by just expanding
  // the grid bounds by a user specified factor.
  publicAPI.getBounds = () => {
    publicAPI.update();
    BoundingBox/* default.setBounds */.Ay.setBounds(model.bounds, model.gridActor.getBounds());
    BoundingBox/* default.scaleAboutCenter */.Ay.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
    return model.bounds;
  };

  // Make sure the grid share the actor property
  const _setProp = macros2.m.chain(publicAPI.setProperty, model.gridActor.setProperty);
  publicAPI.setProperty = p => _setProp(p)[0];
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function defaultValues(publicAPI, model, initialValues) {
  return {
    boundsScaleFactor: 1.3,
    camera: null,
    dataBounds: [...BoundingBox/* default */.Ay.INIT_BOUNDS],
    faceVisibilityAngle: 8,
    gridLines: true,
    axisLabels: null,
    axisTitlePixelOffset: 35.0,
    tickLabelPixelOffset: 12.0,
    generateTicks: defaultGenerateTicks,
    ...initialValues,
    axisTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 18,
      fontFamily: 'serif',
      ...initialValues?.axisTextStyle
    },
    tickTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 14,
      fontFamily: 'serif',
      ...initialValues?.tickTextStyle
    }
  };
}

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Inheritance
  Core_Actor/* default.extend */.Ay.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));

  // internal variables
  model.lastFacesToDraw = [false, false, false, false, false, false];
  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];
  model.tickCounts = [];
  model.textValues = [];
  model.lastTickBounds = [];
  model.tmCanvas = document.createElement('canvas');
  model.tmContext = model.tmCanvas.getContext('2d');
  model._tmAtlas = new Map();

  // for texture atlas
  model.tmTexture = Texture/* default.newInstance */.Ay.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  publicAPI.getProperty().setDiffuse(0.0);
  publicAPI.getProperty().setAmbient(1.0);
  model.gridMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.polyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.gridMapper.setInputData(model.polyData);
  model.gridActor = Core_Actor/* default.newInstance */.Ay.newInstance();
  model.gridActor.setMapper(model.gridMapper);
  model.gridActor.setProperty(publicAPI.getProperty());
  model.gridActor.setParentProp(publicAPI);
  model.textPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  macros2.m.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset', 'generateTicks']);
  macros2.m.setGetArray(publicAPI, model, ['dataBounds'], 6);
  macros2.m.setGetArray(publicAPI, model, ['axisLabels'], 3);
  macros2.m.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);

  // Object methods
  vtkCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkCubeAxesActor');

// ----------------------------------------------------------------------------

var vtkCubeAxesActor$1 = {
  newInstance,
  extend,
  newCubeAxesActorHelper,
  defaultGenerateTicks
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js





// ----------------------------------------------------------------------------
// vtkOpenGLCubeAxesActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLCubeAxesActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function CubeAxesActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

  // Object methods
  vtkOpenGLCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CubeAxesActor_newInstance = (0,macros2.n)(CubeAxesActor_extend, 'vtkOpenGLCubeAxesActor');

// ----------------------------------------------------------------------------

var index = {
  newInstance: CubeAxesActor_newInstance,
  extend: CubeAxesActor_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkCubeAxesActor', CubeAxesActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var PolyDataMapper = __webpack_require__(62939);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
var AbstractMapper = __webpack_require__(85311);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var LookupTable = __webpack_require__(72879);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var Constants = __webpack_require__(33395);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper2D.js





const {
  ColorMode,
  ScalarMode,
  GetArray
} = Constants/* default */.Ay;

// ---------------------------------------------------------------------------
// vtkMapper2D methods
// ---------------------------------------------------------------------------

function vtkMapper2D(publicAPI, model) {
  // Set out className
  model.classHierarchy.push('vtkMapper2D');
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = LookupTable/* default.newInstance */.Ay.newInstance();
  };
  publicAPI.getColorModeAsString = () => macros2.m.enumToString(ColorMode, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macros2.m.enumToString(ScalarMode, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    // make sure we have an input
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    let scalars = null;
    let cellFlag = false;

    // get scalar data and point/cell attribute according to scalar mode
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.mapScalars = (input, alpha) => {
    const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorMapColors = null;
      return;
    }

    // we want to only recompute when something has changed
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Mapper2D_DEFAULT_VALUES = {
  static: false,
  lookupTable: null,
  scalarVisibility: false,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME

  renderTime: 0,
  colorByArrayName: null,
  transformCoordinate: null,
  viewSpecificProperties: null,
  customShaderAttributes: []
};

// ----------------------------------------------------------------------------
function Mapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Mapper2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  AbstractMapper/* default.extend */.A.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['colorMapColors']);
  macros2.m.setGet(publicAPI, model, ['arrayAccessMode', 'colorByArrayName', 'colorMode', 'lookupTable', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'transformCoordinate', 'useLookupTableScalarRange', 'viewSpecificProperties', 'customShaderAttributes' // point data array names that will be transferred to the VBO
  ]);

  macros2.m.setGetArray(publicAPI, model, ['scalarRange'], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }

  // Object methods
  vtkMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Mapper2D_newInstance = macros2.m.newInstance(Mapper2D_extend, 'vtkMapper2D');

// ----------------------------------------------------------------------------

var vtkMapper2D$1 = {
  newInstance: Mapper2D_newInstance,
  extend: Mapper2D_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
const DisplayLocation = {
  BACKGROUND: 0,
  FOREGROUND: 1
};
var Constants_Constants = {
  DisplayLocation
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js














// import { mat3, mat4, vec3 } from 'gl-matrix';
const {
  primTypes
} = Helper/* default */.Ay;
const {
  ScalarMode: PolyDataMapper2D_ScalarMode
} = vtkMapper2D$1;
const {
  vtkErrorMacro
} = macros2.c;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};

// ----------------------------------------------------------------------------
// vtkOpenGLPolyDataMapper2D methods
// ----------------------------------------------------------------------------

function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLPolyDataMapper2D');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.openGLActor2D = publicAPI.getFirstAncestorOfType('vtkOpenGLActor2D');
      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };
  publicAPI.overlayPass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyData2DVS;
    shaders.Fragment = vtkPolyData2DFS;
    shaders.Geometry = '';
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor2D.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    if (model._openGLRenderer.getSelector()) {
      switch (model._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      // We must figure out how the scalars should be mapped to the polydata.
      if ((scalarMode === PolyDataMapper2D_ScalarMode.USE_CELL_DATA || scalarMode === PolyDataMapper2D_ScalarMode.USE_CELL_FIELD_DATA || scalarMode === PolyDataMapper2D_ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== PolyDataMapper2D_ScalarMode.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor2D.getActiveTextures()) {
      tcoords = null;
    }
    const transformCoordinate = model.renderable.getTransformCoordinate();
    const view = ren.getRenderWindow().getViews()[0];
    const vsize = view.getViewportSize(ren);
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${c ? c.getMTime() : 1}` + `D${tcoords ? tcoords.getMTime() : 1}` + `E${transformCoordinate ? ren.getMTime() : 1}` + `F${vsize}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      let points = poly.getPoints();
      if (transformCoordinate) {
        const p = Points/* default.newInstance */.Ay.newInstance();
        const numPts = points.getNumberOfPoints();
        p.setNumberOfPoints(numPts);
        const point = [];
        for (let i = 0; i < numPts; ++i) {
          points.getPoint(i, point);
          transformCoordinate.setValue(point);
          const v = transformCoordinate.getComputedDoubleViewportValue(ren);
          p.setPoint(i, v[0], v[1], 0.0);
        }
        points = p;
      }
      const options = {
        points,
        tcoords,
        colors: c,
        cellOffset: 0,
        haveCellScalars: model.haveCellSCalars,
        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
      };
      options.cellOffset += model.primitives[primTypes.Points].getCABO().createVBO(poly.getVerts(), 'verts', representation, options);
      options.cellOffset += model.primitives[primTypes.Lines].getCABO().createVBO(poly.getLines(), 'lines', representation, options);
      options.cellOffset += model.primitives[primTypes.Tris].getCABO().createVBO(poly.getPolys(), 'polys', representation, options);
      options.cellOffset += model.primitives[primTypes.TriStrips].getCABO().createVBO(poly.getStrips(), 'strips', representation, options);
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    gl.depthMask(true);

    // for every primitive type
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.lastBoundBO = model.primitives[i];
        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.lastBoundBO) {
      model.lastBoundBO.getVAO().release();
    }
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    if (model.haveCellScalars) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['uniform samplerBuffer texture1;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);']).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', ['in vec4 diffuseColor;', 'out vec4 fcolorVSOutput;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', ['fcolorVSOutput = diffuseColor;']).result;
      GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput[];\n', 'out vec4 fcolorGSOutput;']).result;
      GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::Color::Impl', ['fcolorGSOutput = fcolorVSOutput[i];']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = fcolorVSOutput;']).result;
    } else {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Dec', ['uniform vec4 diffuseColor;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = diffuseColor;']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
      if (tcdim === 1) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', ['in float tcoordMC;', 'out float tcoordVCVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput[];\n', 'out float tcoordVCGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, ['//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));']).result;
      } else if (tcdim === 2) {
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordMC;', 'out vec2 tcoordVCVSOutput;']).result;
        VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];\n', 'out vec2 tcoordVCGSOutput;']).result;
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::TCoord::Impl', ['tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);']).result;
      }
      if (model.haveCellScalars) {
        GSSource = ShaderProgram/* default.substitute */.A.substitute(GSSource, '//VTK::PrimID::Impl', ['gl_PrimitiveID = gl_PrimitiveIDIn;']).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Dec', ['uniform vec3 mapperIndex;', 'uniform int picking;']).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    // replace common shader code
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach(object => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isAttributeUsed('vertexWC')) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
        vtkErrorMacro('Error setting vertexWC in shader VAO.');
      }
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('tcoordMC');
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
        cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
      }
      const tus = model.openGLActor2D.getActiveTextures();
      if (tus) {
        for (let index = 0; index < tus.length; ++index) {
          const tex = tus[index];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }

      // handle wide lines
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
      cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const c = model.renderable.getColorMapColors();
    if (!c || c.getNumberOfComponents() === 0) {
      const program = cellBO.getProgram();
      const ppty = actor.getProperty();
      const opacity = ppty.getOpacity();
      const dColor = ppty.getColor();
      const diffuseColor = [dColor[0], dColor[1], dColor[2], opacity];
      program.setUniform4f('diffuseColor', diffuseColor);
    }
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    // no-op
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;

    // Get the position of the actor
    const view = ren.getRenderWindow().getViews()[0];
    const size = view.getViewportSize(ren);
    const vport = ren.getViewport();
    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);

    // Get the window info
    // Assume tile viewport is 0 1 based on vtkOpenGLRenderer
    const tileViewport = [0.0, 0.0, 1.0, 1.0];
    const visVP = [0.0, 0.0, 1.0, 1.0];
    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
    if (visVP[0] >= visVP[2]) {
      return;
    }
    if (visVP[1] >= visVP[3]) {
      return;
    }
    size[0] = (0,Core_Math.P)(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
    size[1] = (0,Core_Math.P)(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
    const winSize = model._openGLRenderer.getParent().getSize();
    const xoff = (0,Core_Math.P)(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
    const yoff = (0,Core_Math.P)(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);

    // set ortho projection
    const left = -xoff;
    let right = -xoff + size[0];
    const bottom = -yoff;
    let top = -yoff + size[1];

    // it's an error to call glOrtho with
    // either left==right or top==bottom
    if (left === right) {
      right = left + 1.0;
    }
    if (bottom === top) {
      top = bottom + 1.0;
    }

    // compute the combined ModelView matrix and send it down to save time in the shader
    const tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
    tmpMat4[0] = 2.0 / (right - left);
    tmpMat4[1 * 4 + 1] = 2.0 / (top - bottom);
    tmpMat4[0 * 4 + 3] = -1.0 * (right + left) / (right - left);
    tmpMat4[1 * 4 + 3] = -1.0 * (top + bottom) / (top - bottom);
    tmpMat4[2 * 4 + 2] = 0.0;
    tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1.0 : 1.0;
    tmpMat4[3 * 4 + 3] = 1.0;
    esm/* mat4.transpose */.pB.transpose(tmpMat4, tmpMat4);
    program.setUniformMatrix('WCVCMatrix', safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach(prim => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    // Return in MB
    return memUsed;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyDataMapper2D_DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null
};

// ----------------------------------------------------------------------------

function PolyDataMapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = Helper/* default.newInstance */.Ay.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['context']);
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLPolyDataMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyDataMapper2D_newInstance = (0,macros2.n)(PolyDataMapper2D_extend, 'vtkOpenGLPolyDataMapper2D');

// ----------------------------------------------------------------------------

var vtkPolyDataMapper2D = {
  newInstance: PolyDataMapper2D_newInstance,
  extend: PolyDataMapper2D_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkMapper2D', PolyDataMapper2D_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var ScalarsToColors = __webpack_require__(80993);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js










const {
  VectorMode
} = ScalarsToColors/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkScalarBarActor
//
// Note log scales are currently not supported
//
// Developer note: This class is broken into the main class and a helper
// class. The main class holds view independent properties (those properties
// that do not change as the view's resolution/aspect ratio change). The
// helper class is instantiated one per view and holds properties that can
// depend on view specific values such as resolution. The helper class code
// could have been left to the View specific implementation (such as
// vtkWebGPUScalarBarActor) but is instead placed here to it can be shared by
// multiple rendering backends.
//
// ----------------------------------------------------------------------------

function ScalarBarActor_applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}

// ----------------------------------------------------------------------------
// Default autoLayout function
// ----------------------------------------------------------------------------

// compute good values to use based on window size etc a bunch of heuristics
// here with hand tuned constants These values worked for me but really this
// method could be redically changed. The basic gist is
// 1) compute a resonable font size
// 2) render the text atlas using those font sizes
// 3) pick horizontal or vertical bsed on window size
// 4) based on the size of the title and tick labels rendered
//    compute the box size and position such that
//    the text will all fit nicely and the bar will be a resonable size
// 5) compute the bar segments based on the above settings
//
// Note that this function can and should read values from the
// ScalarBarActor but should only write values to the view dependent helper
// instance that is provided as those values are the ones that will be used
// for rendering.
//
function defaultAutoLayout(publicAPI, model) {
  return helper => {
    // we don't do a linear scale, the proportions for
    // a 700 pixel window differ from a 1400
    const lastSize = helper.getLastSize();
    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
    const axisTextStyle = helper.getAxisTextStyle();
    const tickTextStyle = helper.getTickTextStyle();
    Object.assign(axisTextStyle, model.axisTextStyle);
    Object.assign(tickTextStyle, model.tickTextStyle);

    // compute a reasonable font size first
    axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
    if (helper.getLastAspectRatio() > 1.0) {
      tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
    } else {
      tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
    }

    // rebuild the text atlas
    const textSizes = helper.updateTextureAtlas();

    // now compute the boxSize and pixel offsets, different algorithm
    // for horizonal versus vertical
    helper.setTopTitle(false);
    const boxSize = helper.getBoxSizeByReference();

    // if vertical
    if (helper.getLastAspectRatio() > 1.0) {
      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);

      // if the title will fit within the width of the bar then that looks
      // nicer to put it at the top (helper.topTitle), otherwise rotate it
      // and place it sideways
      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
        helper.setTopTitle(true);
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2.0 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
      } else {
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2.0 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
      }
      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
    } else {
      // horizontal
      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
      const titleHeight =
      // total offset from top of bar (includes ticks)
      2.0 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];
      const tickWidth = 2.0 * textSizes.tickWidth / lastSize[0];
      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
      boxSize[1] = titleHeight;
      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
    }

    // recomute bar segments based on positioning
    helper.recomputeBarSegments(textSizes);
  };
}

// ----------------------------------------------------------------------------
// Default generateTicks function
// ----------------------------------------------------------------------------

// This function returns the default function used to generate vtkScalarBarActor ticks.
// The default function makes use of d3.scaleLinear() to generate 5 tick marks between
// the minimum and maximum values of the scalar bar. Customize this behavior by passing
// a function to vtkScalarBarActor.newInstance({ generateTicks: customGenerateTicks })
// or by calling scalarBarActor.setGenerateTicks(customGenerateTicks).
function ScalarBarActor_defaultGenerateTicks(publicApi, model) {
  return helper => {
    const lastTickBounds = helper.getLastTickBounds();
    const scale = src/* scaleLinear */.m4().domain([lastTickBounds[0], lastTickBounds[1]]);
    const ticks = scale.ticks(5);
    const format = scale.tickFormat(5);
    helper.setTicks(ticks);
    helper.setTickStrings(ticks.map(format));
  };
}

// many properties of this actor depend on the API specific view The main
// dependency being the resolution as that drives what font sizes to use.
// Bacause of this we need to do some of the calculations in a API specific
// subclass. But... we don't want a lot of duplicated code between WebGL and
// WebGPU for example so we have this helper class, that is designed to be
// fairly API independent so that API specific views can call this to do
// most of the work.
function vtkScalarBarActorHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarBarActorHelper');
  publicAPI.setRenderable = renderable => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.barActor.setProperty(renderable.getProperty());
    model.barActor.setParentProp(renderable);
    model.barActor.setCoordinateSystemToDisplay();
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    model.tmActor.setCoordinateSystemToDisplay();
    model.generateTicks = renderable.generateTicks;
    model.axisTextStyle = {
      ...renderable.getAxisTextStyle()
    };
    model.tickTextStyle = {
      ...renderable.getTickTextStyle()
    };
    publicAPI.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    // has the size changed?
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    const scalarsToColors = model.renderable.getScalarsToColors();
    if (!scalarsToColors || !model.renderable.getVisibility()) {
      return;
    }

    // make sure the lut is assigned to our mapper
    model.barMapper.setLookupTable(scalarsToColors);

    // camera should be the same for all views
    model.camera = camera;
    model.renderWindow = renderWindow;

    // did something significant change? If so rebuild a lot of things
    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
      const range = scalarsToColors.getMappingRange();
      model.lastTickBounds = [...range];

      // compute tick marks for axes (update for log scale)
      model.renderable.getGenerateTicks()(publicAPI);
      if (model.renderable.getAutomated()) {
        model.renderable.getAutoLayout()(publicAPI);
      } else {
        // copy values from renderable
        model.axisTextStyle = {
          ...model.renderable.getAxisTextStyle()
        };
        model.tickTextStyle = {
          ...model.renderable.getTickTextStyle()
        };
        model.barPosition = [...model.renderable.getBarPosition()];
        model.barSize = [...model.renderable.getBarSize()];
        model.boxPosition = [...model.renderable.getBoxPosition()];
        model.boxSize = [...model.renderable.getBoxSize()];
        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();

        // rebuild the texture only when force or changed bounds, face
        // visibility changes do to change the atlas
        const textSizes = publicAPI.updateTextureAtlas();

        // recompute bar segments based on positioning
        publicAPI.recomputeBarSegments(textSizes);
      }
      publicAPI.updatePolyDataForLabels();
      publicAPI.updatePolyDataForBarSegments();
      model.lastRebuildTime.modified();
      model.forceUpdate = false;
    }
  };

  // create the texture map atlas that contains the rendering of
  // all the text strings. Only needs to be called when the text strings
  // have changed (labels and ticks)
  publicAPI.updateTextureAtlas = () => {
    // set the text properties
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';

    // return some factors about the text atlas
    const results = {};

    // first the axislabel
    const newTmAtlas = new Map();
    let maxWidth = 0;
    let totalHeight = 1; // start one pixel in so we have a border
    ScalarBarActor_applyTextStyle(model.tmContext, model.axisTextStyle);
    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
    let entry = {
      height: metrics.actualBoundingBoxAscent + 2,
      startingHeight: totalHeight,
      width: metrics.width + 2,
      textStyle: model.axisTextStyle
    };
    newTmAtlas.set(model.renderable.getAxisLabel(), entry);
    totalHeight += entry.height;
    maxWidth = entry.width;
    results.titleWidth = entry.width;
    results.titleHeight = entry.height;

    // and the ticks, NaN Below and Above
    results.tickWidth = 0;
    results.tickHeight = 0;
    ScalarBarActor_applyTextStyle(model.tmContext, model.tickTextStyle);
    const strings = [...publicAPI.getTickStrings(), 'NaN', 'Below', 'Above'];
    for (let t = 0; t < strings.length; t++) {
      if (!newTmAtlas.has(strings[t])) {
        metrics = model.tmContext.measureText(strings[t]);
        entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.tickTextStyle
        };
        newTmAtlas.set(strings[t], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
        if (results.tickWidth < entry.width) {
          results.tickWidth = entry.width;
        }
        if (results.tickHeight < entry.height) {
          results.tickHeight = entry.height;
        }
      }
    }

    // always use power of two to avoid interpolation
    // in cases where PO2 is required
    maxWidth = (0,Core_Math.R)(maxWidth);
    totalHeight = (0,Core_Math.R)(totalHeight);

    // set the tcoord values
    newTmAtlas.forEach(value => {
      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
    });

    // make sure we have power of two dimensions
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = 'bottom';
    model.tmContext.textAlign = 'left';
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

    // draw the text onto the texture
    newTmAtlas.forEach((value, key) => {
      ScalarBarActor_applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    // mark as modified since the canvas typically doesn't change
    model.tmTexture.modified();
    model._tmAtlas = newTmAtlas;
    return results;
  };
  publicAPI.computeBarSize = textSizes => {
    // compute orientation
    model.vertical = model.boxSize[1] > model.boxSize[0];
    const tickHeight = 2.0 * textSizes.tickHeight / model.lastSize[1];
    const segSize = [1, 1];

    // horizontal and vertical have different astetics so adjust based on
    // orientation
    if (model.vertical) {
      const tickWidth = 2.0 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
      if (model.topTitle) {
        const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0] - tickWidth;
        model.barSize[1] = model.boxSize[1] - titleHeight;
      } else {
        // rotated title so width is based off height
        const titleWidth = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
        model.barSize[1] = model.boxSize[1];
      }
      model.barPosition[0] = model.boxPosition[0] + tickWidth;
      model.barPosition[1] = model.boxPosition[1];
      segSize[1] = tickHeight;
    } else {
      const tickWidth = (2.0 * textSizes.tickWidth - 8) / model.lastSize[0];
      const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
      model.barSize[0] = model.boxSize[0];
      model.barPosition[0] = model.boxPosition[0];
      model.barSize[1] = model.boxSize[1] - titleHeight;
      model.barPosition[1] = model.boxPosition[1];
      segSize[0] = tickWidth;
    }
    return segSize;
  };

  // based on all the settins compute a barSegments array
  // containing the segments of the scalar bar
  // each segment contains
  //   corners[4][2]
  //   title - e.g. NaN, Above, ticks
  //   scalars - the normalized scalars values to use for that segment
  //
  // Note that the bar consumes the space in the box that remains after
  // leaving room for the text labels
  publicAPI.recomputeBarSegments = textSizes => {
    // first compute the barSize/Position
    const segSize = publicAPI.computeBarSize(textSizes);
    model.barSegments = [];
    const startPos = [0.0, 0.0];

    // horizontal and vertical have different astetics so adjust based on
    // orientation
    const barAxis = model.vertical ? 1 : 0;
    const segSpace = model.vertical ? 0.01 : 0.02;
    function pushSeg(title, scalars) {
      model.barSegments.push({
        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
        scalars,
        title
      });
      startPos[barAxis] += segSize[barAxis] + segSpace;
    }
    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
      pushSeg('NaN', [NaN, NaN, NaN, NaN]);
    }
    if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {
      pushSeg('Below', [-0.1, -0.1, -0.1, -0.1]);
    }
    const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();

    // extra space around the ticks section
    startPos[barAxis] += segSpace;
    const oldSegSize = segSize[barAxis];
    segSize[barAxis] = haveAbove ? 1.0 - 2.0 * segSpace - segSize[barAxis] - startPos[barAxis] : 1.0 - segSpace - startPos[barAxis];
    pushSeg('ticks', model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
      segSize[barAxis] = oldSegSize;
      startPos[barAxis] += segSpace;
      pushSeg('Above', [1.1, 1.1, 1.1, 1.1]);
    }
  };

  // called by updatePolyDataForLabels
  // modifies class constants tmp2v3
  const tmp2v3 = new Float64Array(3);

  // anchor point = pos
  // H alignment = left, middle, right
  // V alignment = bottom, middle, top
  // Text Orientation = horizontal, vertical
  // orientation
  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
    const value = model._tmAtlas.get(text);
    if (!value) {
      return;
    }
    // have to find the four corners of the texture polygon for this label
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;

    // get achor point in pixels
    tmp2v3[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
    tmp2v3[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
    tmp2v3[2] = pos[2];
    tmp2v3[0] += offset[0];
    tmp2v3[1] += offset[1];

    // get text size in display pixels
    const textSize = [];
    const textAxes = orientation === 'vertical' ? [1, 0] : [0, 1];
    if (orientation === 'vertical') {
      textSize[0] = value.width;
      textSize[1] = -value.height;
      // update anchor point based on alignment
      if (alignment[0] === 'middle') {
        tmp2v3[1] -= value.width / 2.0;
      } else if (alignment[0] === 'right') {
        tmp2v3[1] -= value.width;
      }
      if (alignment[1] === 'middle') {
        tmp2v3[0] += value.height / 2.0;
      } else if (alignment[1] === 'top') {
        tmp2v3[0] += value.height;
      }
    } else {
      textSize[0] = value.width;
      textSize[1] = value.height;
      // update anchor point based on alignment
      if (alignment[0] === 'middle') {
        tmp2v3[0] -= value.width / 2.0;
      } else if (alignment[0] === 'right') {
        tmp2v3[0] -= value.width;
      }
      if (alignment[1] === 'middle') {
        tmp2v3[1] -= value.height / 2.0;
      } else if (alignment[1] === 'top') {
        tmp2v3[1] -= value.height;
      }
    }
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    tmp2v3[textAxes[0]] += textSize[0];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    tmp2v3[textAxes[1]] += textSize[1];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    tmp2v3[textAxes[0]] -= textSize[0];
    results.points[ptIdx * 3] = tmp2v3[0];
    results.points[ptIdx * 3 + 1] = tmp2v3[1];
    results.points[ptIdx * 3 + 2] = tmp2v3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;

    // add the two triangles to represent the quad
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };

  // update the polydata associated with drawing the text labels
  // specifically the quads used for each label and their associated tcoords
  // etc. This changes every time the camera viewpoint changes
  const tmpv3 = new Float64Array(3);
  publicAPI.updatePolyDataForLabels = () => {
    // update the polydata
    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };

    // compute the direction vector
    const offsetAxis = model.vertical ? 0 : 1;
    const spacedAxis = model.vertical ? 1 : 0;
    tmpv3[2] = -0.99; // near plane

    // draw the title
    const alignment = model.vertical ? ['right', 'middle'] : ['middle', 'bottom'];
    let dir = [0, 1];
    const tickOffsets = [0, 0];
    if (model.vertical) {
      tickOffsets[0] = -model.tickLabelPixelOffset;
      if (model.topTitle) {
        tmpv3[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
        tmpv3[1] = model.barPosition[1] + model.barSize[1];

        // write the axis label
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
      } else {
        tmpv3[0] = model.barPosition[0] + model.barSize[0];
        tmpv3[1] = model.barPosition[1] + 0.5 * model.barSize[1];

        // write the axis label
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'top'], 'vertical', [model.axisTitlePixelOffset, 0], results);
      }
      dir = [-1, 0];
    } else {
      tickOffsets[1] = model.tickLabelPixelOffset;
      tmpv3[0] = model.barPosition[0] + 0.5 * model.barSize[0];
      tmpv3[1] = model.barPosition[1] + model.barSize[1];
      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
    }
    tmpv3[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
    tmpv3[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;

    // draw bar segment labels
    let tickSeg = null;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      if (seg.title === 'ticks') {
        // handle ticks below
        tickSeg = seg;
      } else {
        tmpv3[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
        publicAPI.createPolyDataForOneLabel(seg.title, tmpv3, alignment, 'horizontal', tickOffsets, results);
      }
    }

    // write the tick labels
    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
    const ticks = publicAPI.getTicks();
    const tickStrings = publicAPI.getTickStrings();
    for (let t = 0; t < ticks.length; t++) {
      const tickPos = (ticks[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
      tmpv3[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv3, alignment, 'horizontal', tickOffsets, results);
    }
    const tcoordDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: 'TextureCoordinates'
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updatePolyDataForBarSegments = () => {
    const scalarsToColors = model.renderable.getScalarsToColors();
    let numberOfExtraColors = 0;
    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {
      numberOfExtraColors += 1;
    }
    const numPts = 4 * (1 + numberOfExtraColors);
    const numQuads = numPts;

    // handle vector component mode
    let numComps = 1;
    if (scalarsToColors.getVectorMode() === VectorMode.COMPONENT) {
      numComps = scalarsToColors.getVectorComponent() + 1;
    }

    // create the colored bars
    const points = new Float64Array(numPts * 3);
    const cells = new Uint16Array(numQuads * 5);
    const scalars = new Float32Array(numPts * numComps);
    let ptIdx = 0;
    let cellIdx = 0;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      for (let e = 0; e < 4; e++) {
        tmpv3[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
        tmpv3[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
        points[ptIdx * 3] = (0.5 * tmpv3[0] + 0.5) * model.lastSize[0];
        points[ptIdx * 3 + 1] = (0.5 * tmpv3[1] + 0.5) * model.lastSize[1];
        points[ptIdx * 3 + 2] = tmpv3[2];
        for (let nc = 0; nc < numComps; nc++) {
          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
        }
        ptIdx++;
      }
      cells[cellIdx * 5] = 4;
      cells[cellIdx * 5 + 1] = ptIdx - 4;
      cells[cellIdx * 5 + 2] = ptIdx - 3;
      cells[cellIdx * 5 + 3] = ptIdx - 2;
      cells[cellIdx * 5 + 4] = ptIdx - 1;
      cellIdx++;
    }
    const scalarsDA = DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents: numComps,
      values: scalars,
      name: 'Scalars'
    });
    model.polyData.getPointData().setScalars(scalarsDA);
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getPolys().setData(cells, 1);
    model.polyData.getPolys().modified();
    model.polyData.modified();
  };
}
const newScalarBarActorHelper = macros2.m.newInstance(function (publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);

  // Inheritance
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['axisTitlePixelOffset', 'tickLabelPixelOffset', 'renderable', 'topTitle', 'ticks', 'tickStrings']);
  macros2.m.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'lastTickBounds', 'axisTextStyle', 'tickTextStyle', 'barActor', 'tmActor']);
  macros2.m.getArray(publicAPI, model, ['boxPosition', 'boxSize']);
  macros2.m.setArray(publicAPI, model, ['boxPosition', 'boxSize'], 2);
  model.forceUpdate = false;
  model.lastRebuildTime = {};
  macros2.m.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.tmCanvas = document.createElement('canvas');
  model.tmContext = model.tmCanvas.getContext('2d');
  model._tmAtlas = new Map();
  model.barMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.barMapper.setInterpolateScalarsBeforeMapping(true);
  model.barMapper.setUseLookupTableScalarRange(true);
  model.polyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.barMapper.setInputData(model.polyData);
  model.barActor = Core_Actor/* default.newInstance */.Ay.newInstance();
  model.barActor.setMapper(model.barMapper);

  // for texture atlas
  model.tmPolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.tmMapper = Mapper/* default.newInstance */.Ay.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmTexture = Texture/* default.newInstance */.Ay.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  model.tmActor = Core_Actor/* default.newInstance */.Ay.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  model.tmActor.addTexture(model.tmTexture);
  model.barPosition = [0, 0];
  model.barSize = [0, 0];
  model.boxPosition = [0.88, -0.92];
  model.boxSize = [0.1, 1.1];

  // internal variables
  model.lastTickBounds = [];
  vtkScalarBarActorHelper(publicAPI, model);
}, 'vtkScalarBarActorHelper');

//
// Now we define the public class that the application sets view independent
// properties on. This class is fairly small as it mainly just holds
// properties setter and getters leaving all calculations to the helper
// class.
//
function vtkScalarBarActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarBarActor');
  publicAPI.setTickTextStyle = tickStyle => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = axisStyle => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.resetAutoLayoutToDefault = () => {
    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
  };
  publicAPI.resetGenerateTicksToDefault = () => {
    publicAPI.setGenerateTicks(ScalarBarActor_defaultGenerateTicks());
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function ScalarBarActor_defaultValues(initialValues) {
  return {
    automated: true,
    autoLayout: null,
    axisLabel: 'Scalar Value',
    barPosition: [0, 0],
    barSize: [0, 0],
    boxPosition: [0.88, -0.92],
    boxSize: [0.1, 1.1],
    scalarToColors: null,
    axisTitlePixelOffset: 36.0,
    axisTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 18,
      fontFamily: 'serif'
    },
    tickLabelPixelOffset: 14.0,
    tickTextStyle: {
      fontColor: 'white',
      fontStyle: 'normal',
      fontSize: 14,
      fontFamily: 'serif'
    },
    generateTicks: null,
    drawNanAnnotation: true,
    drawBelowRangeSwatch: true,
    drawAboveRangeSwatch: true,
    ...initialValues
  };
}

// ----------------------------------------------------------------------------

function ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ScalarBarActor_defaultValues(initialValues));
  if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);
  if (!model.generateTicks) model.generateTicks = ScalarBarActor_defaultGenerateTicks();

  // Inheritance
  Core_Actor/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  publicAPI.getProperty().setDiffuse(0.0);
  publicAPI.getProperty().setAmbient(1.0);
  macros2.m.setGet(publicAPI, model, ['automated', 'autoLayout', 'axisTitlePixelOffset', 'axisLabel', 'scalarsToColors', 'tickLabelPixelOffset', 'generateTicks', 'drawNanAnnotation', 'drawBelowRangeSwatch', 'drawAboveRangeSwatch']);
  macros2.m.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle']);
  macros2.m.getArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize']);
  macros2.m.setArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize'], 2);

  // Object methods
  vtkScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ScalarBarActor_newInstance = macros2.m.newInstance(ScalarBarActor_extend, 'vtkScalarBarActor');

// ----------------------------------------------------------------------------

var vtkScalarBarActor$1 = {
  newInstance: ScalarBarActor_newInstance,
  extend: ScalarBarActor_extend,
  newScalarBarActorHelper
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js





// ----------------------------------------------------------------------------
// vtkOpenGLScalarBarActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLScalarBarActor(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLScalarBarActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ScalarBarActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function OpenGL_ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ScalarBarActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

  // Object methods
  vtkOpenGLScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const OpenGL_ScalarBarActor_newInstance = (0,macros2.n)(OpenGL_ScalarBarActor_extend, 'vtkOpenGLScalarBarActor');

// ----------------------------------------------------------------------------

var ScalarBarActor_index = {
  newInstance: OpenGL_ScalarBarActor_newInstance,
  extend: OpenGL_ScalarBarActor_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkScalarBarActor', OpenGL_ScalarBarActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var Skybox = __webpack_require__(92530);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js + 1 modules
var OpenGL_Texture = __webpack_require__(79525);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
var WebGPU_Camera = __webpack_require__(26910);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js + 1 modules
var WebGPU_Renderer = __webpack_require__(24210);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop.js + 1 modules
var Prop = __webpack_require__(46985);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var WebGPU_ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js






const {
  CoordinateSystem
} = Prop/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift, only apply stabilized coords with world coordinates
      model.bufferShift[0] = mcwc[3];
      model.bufferShift[1] = mcwc[7];
      model.bufferShift[2] = mcwc[11];
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);
      } else {
        // we use bcwc BEFORE the translate below (just to get transposed mcvc)
        esm/* mat4.copy */.pB.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        // zero out translation
        model.keyMatrices.normalMatrix[3] = 0.0;
        model.keyMatrices.normalMatrix[7] = 0.0;
        model.keyMatrices.normalMatrix[11] = 0.0;
        esm/* mat4.invert */.pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        esm/* mat4.transpose */.pB.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }

      // only need the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      if (model.renderable.getCoordinateSystem() === CoordinateSystem.WORLD) {
        esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        esm/* mat4.copy */.pB.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Actor_DEFAULT_VALUES = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};

// ----------------------------------------------------------------------------

function Actor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Actor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);
  model.bufferShift = [0, 0, 0, 0];

  // Object methods
  vtkWebGPUActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Actor_newInstance = macros2.m.newInstance(Actor_extend);

// ----------------------------------------------------------------------------

var Actor_index = {
  newInstance: Actor_newInstance,
  extend: Actor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkActor', Actor_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js






const {
  CoordinateSystem: Actor2D_CoordinateSystem
} = Prop/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUActor2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUActor2D');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      // compute the net shift, only apply stabilized coords with world coordinates
      model.bufferShift[0] = 0.0;
      model.bufferShift[1] = 0.0;
      model.bufferShift[2] = 0.0;
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === Actor2D_CoordinateSystem.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      esm/* mat4.identity */.pB.identity(model.keyMatrices.bcwc);
      esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);

      // only meed the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      if (model.renderable.getCoordinateSystem() === Actor2D_CoordinateSystem.WORLD) {
        esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        esm/* mat4.copy */.pB.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Actor2D_DEFAULT_VALUES = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: undefined,
  bufferShift: undefined
};

// ----------------------------------------------------------------------------

function Actor2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Actor2D_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);
  model.bufferShift = [0, 0, 0, 0];

  // Object methods
  vtkWebGPUActor2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Actor2D_newInstance = macros2.m.newInstance(Actor2D_extend);

// ----------------------------------------------------------------------------

var Actor2D_index = {
  newInstance: Actor2D_newInstance,
  extend: Actor2D_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkActor2D', Actor2D_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js





// ----------------------------------------------------------------------------
// vtkWebGPUCubeAxesActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUCubeAxesActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CubeAxesActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function WebGPU_CubeAxesActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CubeAxesActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

  // Object methods
  vtkWebGPUCubeAxesActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_CubeAxesActor_newInstance = (0,macros2.n)(WebGPU_CubeAxesActor_extend, 'vtkWebGPUCubeAxesActor');

// ----------------------------------------------------------------------------

var CubeAxesActor_index = {
  newInstance: WebGPU_CubeAxesActor_newInstance,
  extend: WebGPU_CubeAxesActor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkCubeAxesActor', WebGPU_CubeAxesActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js + 3 modules
var BufferManager = __webpack_require__(49767);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js




const {
  DisplayLocation: Property2D_DisplayLocation
} = Constants_Constants;

// ----------------------------------------------------------------------------
// vtkProperty2D methods
// ----------------------------------------------------------------------------

function vtkProperty2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProperty2D');
  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(Property2D_DisplayLocation.BACKGROUND);
  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(Property2D_DisplayLocation.FOREGROUND);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Property_Constants/* Representation */.YL.POINTS);
  publicAPI.getRepresentationAsString = () => macros2.m.enumToString(Property_Constants/* Representation */.YL, model.representation);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const Property2D_DEFAULT_VALUES = {
  color: [1, 1, 1],
  opacity: 1,
  pointSize: 1,
  lineWidth: 1,
  representation: Property_Constants/* Representation */.YL.SURFACE,
  displayLocation: Property2D_DisplayLocation.FOREGROUND
};

// ----------------------------------------------------------------------------

function Property2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Property2D_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['opacity', 'lineWidth', 'pointSize', 'displayLocation', 'representation']);
  macros2.m.setGetArray(publicAPI, model, ['color'], 3);

  // Object methods
  vtkProperty2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Property2D_newInstance = macros2.m.newInstance(Property2D_extend, 'vtkProperty2D');

// ----------------------------------------------------------------------------

var vtkProperty2D$1 = {
  newInstance: Property2D_newInstance,
  extend: Property2D_extend,
  ...Constants_Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js + 3 modules
var SimpleMapper = __webpack_require__(32603);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js













const {
  BufferUsage,
  PrimitiveTypes
} = BufferManager/* default */.Ay;
const {
  Representation
} = Property/* default */.Ay;
const {
  ScalarMode: CellArrayMapper_ScalarMode
} = Mapper/* default */.Ay;
const {
  CoordinateSystem: CellArrayMapper_CoordinateSystem
} = Prop/* default */.Ay;
const {
  DisplayLocation: CellArrayMapper_DisplayLocation
} = vtkProperty2D$1;
const vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
const vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var pi: f32 = 3.14159265359; 
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var pi: f32 = 3.14159265359; 

  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;
  
  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  
  var L: vec3<f32> = normalize(direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf*incoming*angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); 
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// TODO: find some way to reduce the number of arguments going in here
fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = color * (1.0 / (dist*dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  
  // Cones.x is the inner phi and cones.y is the outer phi
  var theta: f32 = mdot(normalize(direction), L);
  var epsilon: f32 = cones.x - cones.y;
  var intensity: f32 = (theta - cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist*dist;

  var incoming: vec3<f32> = color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
function isEdges(hash) {
  // edge pipelines have "edge" in them
  return hash.indexOf('edge') >= 0;
}

// ----------------------------------------------------------------------------
// vtkWebGPUCellArrayMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUCellArrayMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCellArrayMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (model.is2D) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
        model.forceZValue = true;
      } else {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
        model.forceZValue = false;
      }
      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
      model.useRendererMatrix = model.coordinateSystem !== CellArrayMapper_CoordinateSystem.DISPLAY;
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  };

  // Renders myself
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.updateUBO = () => {
    // make sure the data is up to date
    const actor = model.WebGPUActor.getRenderable();
    const ppty = actor.getProperty();
    const utime = model.UBO.getSendTime();
    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {
      // Matricies
      const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);
      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);
      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);
      if (model.is2D) {
        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === CellArrayMapper_DisplayLocation.FOREGROUND ? 1.0 : 0.0);
        const aColor = ppty.getColorByReference();
        model.UBO.setValue('AmbientIntensity', 1.0);
        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        model.UBO.setValue('DiffuseIntensity', 0.0);
        model.UBO.setValue('SpecularIntensity', 0.0);
      } else {
        // Base Colors
        let aColor = ppty.getAmbientColorByReference();
        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());
        model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());
        aColor = ppty.getDiffuseColorByReference();
        model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        // Roughness
        model.UBO.setValue('Roughness', ppty.getRoughness());
        model.UBO.setValue('BaseIOR', ppty.getBaseIOR());
        // Metallic
        model.UBO.setValue('Metallic', ppty.getMetallic());
        // Normal
        model.UBO.setValue('NormalStrength', ppty.getNormalStrength());
        // Emission
        model.UBO.setValue('Emission', ppty.getEmission());
        // Specular
        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());
        aColor = ppty.getSpecularColorByReference();
        model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      }
      // Edge and line rendering
      const aColor = ppty.getEdgeColorByReference?.();
      if (aColor) {
        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      }
      model.UBO.setValue('LineWidth', ppty.getLineWidth());
      model.UBO.setValue('Opacity', ppty.getOpacity());
      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());
      const device = model.WebGPURenderWindow.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.haveWideLines = () => {
    const actor = model.WebGPUActor.getRenderable();
    const representation = actor.getProperty().getRepresentation();
    if (actor.getProperty().getLineWidth() <= 1.0) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Verts) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {
      return representation === Representation.WIREFRAME;
    }
    return true;
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
    let code = vDesc.getCode();
    if (model.useRendererMatrix) {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;
      if (model.forceZValue) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
      }
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;
      if (model.forceZValue) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
      }
    }
    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');
      // widen the edge
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',
      // could become a setting
      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const normalBuffer = vertexInput.getBuffer('normalMC');
    const actor = model.WebGPUActor.getRenderable();
    if (normalBuffer) {
      const vDesc = pipeline.getShaderDescription('vertex');
      if (!vDesc.hasOutput('normalVC')) {
        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput('tangentVC')) {
        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput('bitangentVC')) {
        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);
      }
      let code = vDesc.getCode();
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',
      // This is just an approximation, but it happens to work extremely well
      // It only works well for normals that are head on and not super angled though
      // Definitely needs to be replaced
      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      if (actor.getProperty().getNormalTexture()) {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;
      } else {
        code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;
      }
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);

  // we only apply lighting when there is a "var normal" declaration in the
  // fragment shader code. That is the lighting trigger.
  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
    if (hash.includes('sel')) return;
    const vDesc = pipeline.getShaderDescription('vertex');
    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
    const renderer = model.WebGPURenderer.getRenderable();
    const fDesc = pipeline.getShaderDescription('fragment');
    let code = fDesc.getCode();

    // Code that runs if the fragment shader includes normals
    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {
      const lightingCode = [
      // Constants
      '  var pi: f32 = 3.14159265359;',
      // Vectors needed for light calculations
      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',
      // Values needed for light calculations
      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',
      // Need to have a different way of sampling greyscale values aside from .r
      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',
      // Split diffuse and specular components
      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',
      // Summing diffuse and specular components of directional lights
      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',
      // Final variables for combining specular and diffuse
      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1.0, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1.0), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];
      if (renderer.getEnvironmentTexture()?.getImageLoaded()) {
        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',
        // Level multiplier should be set by UBO
        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',
        // Manual mip smoothing since not all formats support smooth level sampling
        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',
        // Multipy by baseColor may be changed
        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');
      }
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Light::Impl', lightingCode).result;
      fDesc.setCode(code);
      // If theres no normals, just set the specular color to be flat
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    // By default, set the colors to be flat
    if (isEdges(hash)) {
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;
      fDesc.setCode(code);
      return;
    }

    // If there's no vertex color buffer return the shader as is
    const colorBuffer = vertexInput.getBuffer('colorVI');
    if (!colorBuffer) return;

    // Modifies the vertex shader to include the vertex colors and interpolation in the outputs
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;
    vDesc.setCode(code);

    // Sets the fragment shader to accept the color inputs from the vertex shader
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    if (!vertexInput.hasAttribute('tcoord')) return;
    const vDesc = pipeline.getShaderDescription('vertex');
    const tcoords = vertexInput.getBuffer('tcoord');
    const numComp = Types/* default */.A.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
    let code = vDesc.getCode();
    vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    const actor = model.WebGPUActor.getRenderable();
    const checkDims = texture => {
      if (!texture) return false;
      const dims = texture.getDimensionality();
      return dims === numComp;
    };
    const usedTextures = [];
    if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {
      if (
      // Chained or statements here are questionable
      checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {
        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getRoughnessTexture())) {
        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getMetallicTexture())) {
        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getNormalTexture())) {
        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {
        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');
      }
    }
    if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {
      if (checkDims(actor.getProperty().getEmissionTexture())) {
        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');
      }
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes('sel')) {
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();
      // by default there are no composites, so just 0
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);
  publicAPI.getUsage = (rep, i) => {
    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {
      return BufferUsage.Verts;
    }
    if (i === PrimitiveTypes.Lines) {
      return BufferUsage.Lines;
    }
    if (rep === Representation.WIREFRAME) {
      if (i === PrimitiveTypes.Triangles) {
        return BufferUsage.LinesFromTriangles;
      }
      return BufferUsage.LinesFromStrips;
    }
    if (i === PrimitiveTypes.Triangles) {
      return BufferUsage.Triangles;
    }
    if (i === PrimitiveTypes.TriangleStrips) {
      return BufferUsage.Strips;
    }
    if (i === PrimitiveTypes.TriangleEdges) {
      return BufferUsage.LinesFromTriangles;
    }

    // only strip edges left which are lines
    return BufferUsage.LinesFromStrips;
  };
  publicAPI.getHashFromUsage = usage => `pt${usage}`;
  publicAPI.getTopologyFromUsage = usage => {
    switch (usage) {
      case BufferUsage.Triangles:
        return 'triangle-list';
      case BufferUsage.Verts:
        return 'point-list';
      case BufferUsage.Lines:
      default:
        return 'line-list';
    }
  };

  // TODO: calculate tangents
  publicAPI.buildVertexInput = () => {
    const pd = model.currentInput;
    const cells = model.cellArray;
    const primType = model.primitiveType;
    const actor = model.WebGPUActor.getRenderable();
    let representation = actor.getProperty().getRepresentation();
    const device = model.WebGPURenderWindow.getDevice();
    let edges = false;
    if (primType === PrimitiveTypes.TriangleEdges) {
      edges = true;
      representation = Representation.WIREFRAME;
    }
    const vertexInput = model.vertexInput;
    const points = pd.getPoints();
    let indexBuffer;

    // get the flat mapping indexBuffer for the cells
    if (cells) {
      const buffRequest = {
        hash: `R${representation}P${primType}${cells.getMTime()}`,
        usage: BufferUsage.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation
      };
      indexBuffer = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    }

    // hash = all things that can change the values on the buffer
    // since mtimes are unique we can use
    // - indexBuffer mtime - because cells drive how we pack
    // - relevant dataArray mtime - the source data
    // - shift - not currently captured
    // - scale - not currently captured
    // - format
    // - usage
    // - packExtra - covered by format

    // points
    if (points) {
      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      const buffRequest = {
        hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,
        usage: BufferUsage.PointArray,
        format: 'float32x4',
        dataArray: points,
        indexBuffer,
        shift,
        packExtra: true
      };
      const buff = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.addBuffer(buff, ['vertexBC']);
    } else {
      vertexInput.removeBufferIfPresent('vertexBC');
    }

    // normals, only used for surface rendering
    const usage = publicAPI.getUsage(representation, primType);
    model._usesCellNormals = false;
    if (!model.is2D && (
    // no lighting on Property2D
    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {
      const normals = pd.getPointData().getNormals();
      // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html
      // Need to find some way of using precomputed tangents (or computing new ones)
      const buffRequest = {
        format: 'snorm8x4',
        indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };
      if (normals) {
        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = normals;
        buffRequest.usage = BufferUsage.PointArray;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['normalMC']);
      } else if (primType === PrimitiveTypes.Triangles) {
        model._usesCellNormals = true;
        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = points;
        buffRequest.cells = cells;
        buffRequest.usage = BufferUsage.NormalsFromPoints;
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['normalMC']);
      } else {
        vertexInput.removeBufferIfPresent('normalMC');
      }
    } else {
      vertexInput.removeBufferIfPresent('normalMC');
    }

    // deal with colors but only if modified
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c = model.renderable.getColorMapColors();
      if (c && !edges) {
        const scalarMode = model.renderable.getScalarMode();
        let haveCellScalars = false;
        // We must figure out how the scalars should be mapped to the polydata.
        if ((scalarMode === CellArrayMapper_ScalarMode.USE_CELL_DATA || scalarMode === CellArrayMapper_ScalarMode.USE_CELL_FIELD_DATA || scalarMode === CellArrayMapper_ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== CellArrayMapper_ScalarMode.USE_POINT_FIELD_DATA && c) {
          haveCellScalars = true;
        }
        const buffRequest = {
          usage: BufferUsage.PointArray,
          format: 'unorm8x4',
          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
          dataArray: c,
          indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        };
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['colorVI']);
        haveColors = true;
      }
    }
    if (!haveColors) {
      vertexInput.removeBufferIfPresent('colorVI');
    }
    let tcoords = null;
    if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }
    if (tcoords && !edges) {
      const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());
      vertexInput.addBuffer(buff, ['tcoord']);
    } else {
      vertexInput.removeBufferIfPresent('tcoord');
    }
  };
  publicAPI.updateTextures = () => {
    // we keep track of new and used textures so
    // that we can clean up any unused textures so we don't hold onto them
    const usedTextures = [];
    const newTextures = [];

    // do we have a scalar color texture
    const idata = model.renderable.getColorTextureMap?.();
    if (idata) {
      if (!model.colorTexture) {
        model.colorTexture = Texture/* default.newInstance */.Ay.newInstance({
          label: 'polyDataColor'
        });
      }
      model.colorTexture.setInputData(idata);
      newTextures.push(['Diffuse', model.colorTexture]);
    }

    // actor textures?
    const actor = model.WebGPUActor.getRenderable();
    const renderer = model.WebGPURenderer.getRenderable();

    // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()
    const textures = [];

    // Feels like there should be a better way than individually adding all
    if (actor.getProperty().getDiffuseTexture?.()) {
      const pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];
      textures.push(pair);
    }
    if (actor.getTextures()[0]) {
      const pair = ['Diffuse', actor.getTextures()[0]];
      textures.push(pair);
    }
    if (model.colorTexture) {
      const pair = ['Diffuse', model.colorTexture];
      textures.push(pair);
    }
    if (actor.getProperty().getRoughnessTexture?.()) {
      const pair = ['Roughness', actor.getProperty().getRoughnessTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getMetallicTexture?.()) {
      const pair = ['Metallic', actor.getProperty().getMetallicTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getNormalTexture?.()) {
      const pair = ['Normal', actor.getProperty().getNormalTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getAmbientOcclusionTexture?.()) {
      const pair = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];
      textures.push(pair);
    }
    if (actor.getProperty().getEmissionTexture?.()) {
      const pair = ['Emission', actor.getProperty().getEmissionTexture()];
      textures.push(pair);
    }
    if (renderer.getEnvironmentTexture?.()) {
      const pair = ['Environment', renderer.getEnvironmentTexture()];
      textures.push(pair);
    }
    for (let i = 0; i < textures.length; i++) {
      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {
        newTextures.push(textures[i]);
      }
      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {
        newTextures.push(textures[i]);
      }
    }
    for (let i = 0; i < newTextures.length; i++) {
      const srcTexture = newTextures[i][1];
      const textureName = newTextures[i][0];
      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash
      if (newTex.getReady()) {
        // is this a new texture
        let found = false;
        for (let t = 0; t < model.textures.length; t++) {
          if (model.textures[t] === newTex) {
            found = true;
            usedTextures[t] = true;
          }
        }
        if (!found) {
          usedTextures[model.textures.length] = true;
          const tview = newTex.createView(`${textureName}Texture`);
          model.textures.push(newTex);
          model.textureViews.push(tview);
          const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';
          let addressMode = null;
          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';
          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';
          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';
          if (textureName !== 'Environment') {
            tview.addSampler(model.device, {
              addressModeU: addressMode,
              addressModeV: addressMode,
              addressModeW: addressMode,
              minFilter: interpolate,
              magFilter: interpolate
            });
          } else {
            tview.addSampler(model.device, {
              addressModeU: 'repeat',
              addressModeV: 'clamp-to-edge',
              addressModeW: 'repeat',
              minFilter: interpolate,
              magFilter: interpolate,
              mipmapFilter: 'linear'
            });
          }
        }
      }
    }

    // remove unused textures
    for (let i = model.textures.length - 1; i >= 0; i--) {
      if (!usedTextures[i]) {
        model.textures.splice(i, 1);
        model.textureViews.splice(i, 1);
      }
    }
  };

  // compute a unique hash for a pipeline, this needs to be unique enough to
  // capture any pipeline code changes (which includes shader changes)
  // or vertex input changes/ bind groups/ etc
  publicAPI.computePipelineHash = () => {
    let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;
    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {
      pipelineHash += 'edge';
    } else {
      if (model.vertexInput.hasAttribute(`normalMC`)) {
        pipelineHash += `n`;
      }
      if (model.vertexInput.hasAttribute(`colorVI`)) {
        pipelineHash += `c`;
      }
      if (model.vertexInput.hasAttribute(`tcoord`)) {
        const tcoords = model.vertexInput.getBuffer('tcoord');
        const numComp = Types/* default */.A.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
        pipelineHash += `t${numComp}`;
      }
      if (model.textures.length) {
        pipelineHash += `tx${model.textures.length}`;
      }
    }
    if (model._usesCellNormals) {
      pipelineHash += `cn`;
    }
    if (model.SSBO) {
      pipelineHash += `ssbo`;
    }
    const uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };
  publicAPI.updateBuffers = () => {
    // handle textures if not edges
    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {
      publicAPI.updateTextures();
    }
    const actor = model.WebGPUActor.getRenderable();
    const rep = actor.getProperty().getRepresentation();

    // handle per primitive type
    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    const vbo = model.vertexInput.getBuffer('vertexBC');
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();
    if (publicAPI.haveWideLines()) {
      const ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));
    } else {
      publicAPI.setNumberOfInstances(1);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CellArrayMapper_DEFAULT_VALUES = {
  is2D: false,
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
};

// ----------------------------------------------------------------------------

function CellArrayMapper_extend(publicAPI, model) {
  let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CellArrayMapper_DEFAULT_VALUES, initiaLalues);

  // Inheritance
  SimpleMapper/* default.extend */.Ay.extend(publicAPI, model, initiaLalues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model._tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // UBO
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'mapperUBO'
  });
  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');
  model.UBO.addEntry('AmbientColor', 'vec4<f32>');
  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');
  model.UBO.addEntry('EdgeColor', 'vec4<f32>');
  model.UBO.addEntry('SpecularColor', 'vec4<f32>');
  model.UBO.addEntry('AmbientIntensity', 'f32');
  model.UBO.addEntry('DiffuseIntensity', 'f32');
  model.UBO.addEntry('Roughness', 'f32');
  model.UBO.addEntry('Metallic', 'f32');
  model.UBO.addEntry('Ambient', 'f32');
  model.UBO.addEntry('Normal', 'f32');
  model.UBO.addEntry('Emission', 'f32');
  model.UBO.addEntry('NormalStrength', 'f32');
  model.UBO.addEntry('BaseIOR', 'f32');
  model.UBO.addEntry('SpecularIntensity', 'f32');
  model.UBO.addEntry('LineWidth', 'f32');
  model.UBO.addEntry('Opacity', 'f32');
  model.UBO.addEntry('ZValue', 'f32');
  model.UBO.addEntry('PropID', 'u32');
  model.UBO.addEntry('ClipNear', 'f32');
  model.UBO.addEntry('ClipFar', 'f32');
  model.UBO.addEntry('Time', 'u32');

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);
  model.textures = [];

  // Object methods
  vtkWebGPUCellArrayMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CellArrayMapper_newInstance = (0,macros2.n)(CellArrayMapper_extend, 'vtkWebGPUCellArrayMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUCellArrayMapper$1 = {
  newInstance: CellArrayMapper_newInstance,
  extend: CellArrayMapper_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js






const {
  PrimitiveTypes: PolyDataMapper_PrimitiveTypes
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUPolyDataMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPolyDataMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPolyDataMapper');
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1.0);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = poly => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

    // we instantiate a cell array mapper for each cellArray that has cells
    // and they handle the rendering of that cell array
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PolyDataMapper_PrimitiveTypes.Points; i <= PolyDataMapper_PrimitiveTypes.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
      for (let i = PolyDataMapper_PrimitiveTypes.TriangleEdges; i <= PolyDataMapper_PrimitiveTypes.TriangleStripEdges; i++) {
        if (prims[i - 2].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i - 2]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(model.primitives[i - 2].getCellOffset());
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyDataMapper_DEFAULT_VALUES = {
  primitives: null
};

// ----------------------------------------------------------------------------

function PolyDataMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.primitives = [];

  // Object methods
  vtkWebGPUPolyDataMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyDataMapper_newInstance = (0,macros2.n)(PolyDataMapper_extend, 'vtkWebGPUPolyDataMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUPolyDataMapper$1 = {
  newInstance: PolyDataMapper_newInstance,
  extend: PolyDataMapper_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkMapper', PolyDataMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js






const {
  PrimitiveTypes: PolyDataMapper2D_PrimitiveTypes
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// vtkWebGPUPolyDataMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPolyDataMapper2D');
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1.0);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = poly => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

    // we instantiate a cell array mapper for each cellArray that has cells
    // and they handle the rendering of that cell array
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PolyDataMapper2D_PrimitiveTypes.Points; i <= PolyDataMapper2D_PrimitiveTypes.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMapper.setIs2D(true);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function PolyDataMapper2D_defaultValues(initialValues) {
  return {
    primitives: [],
    ...initialValues
  };
}

// ----------------------------------------------------------------------------
function WebGPU_PolyDataMapper2D_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyDataMapper2D_defaultValues(initialValues));

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.primitives = [];

  // Object methods
  vtkWebGPUPolyDataMapper2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_PolyDataMapper2D_newInstance = (0,macros2.n)(WebGPU_PolyDataMapper2D_extend, 'vtkWebGPUPolyDataMapper2D');

// ----------------------------------------------------------------------------

var PolyDataMapper2D_index = {
  newInstance: WebGPU_PolyDataMapper2D_newInstance,
  extend: WebGPU_PolyDataMapper2D_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkMapper2D', WebGPU_PolyDataMapper2D_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js





// ----------------------------------------------------------------------------
// vtkWebGPUScalarBarActor methods
// ----------------------------------------------------------------------------

function vtkWebGPUScalarBarActor(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUScalarBarActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const WebGPU_ScalarBarActor_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function WebGPU_ScalarBarActor_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, WebGPU_ScalarBarActor_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

  // Object methods
  vtkWebGPUScalarBarActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const WebGPU_ScalarBarActor_newInstance = (0,macros2.n)(WebGPU_ScalarBarActor_extend, 'vtkWebGPUScalarBarActor');

// ----------------------------------------------------------------------------

var WebGPU_ScalarBarActor_index = {
  newInstance: WebGPU_ScalarBarActor_newInstance,
  extend: WebGPU_ScalarBarActor_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkScalarBarActor', WebGPU_ScalarBarActor_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var HalfFloat = __webpack_require__(97888);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
var Sampler = __webpack_require__(20461);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js




// ----------------------------------------------------------------------------
// vtkWebGPUTextureView methods
// ----------------------------------------------------------------------------

/* eslint-disable no-bitwise */

function vtkWebGPUTextureView(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUTextureView');
  publicAPI.create = (texture, options) => {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || '2d';
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = (textureHandle, options) => {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || '2d';
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = (binding, group) => {
    let ttype = 'f32';
    if (model.bindGroupLayoutEntry.texture.sampleType === 'sint') {
      ttype = 'i32';
    } else if (model.bindGroupLayoutEntry.texture.sampleType === 'uint') {
      ttype = 'u32';
    }
    let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
    if (model.bindGroupLayoutEntry.texture.sampleType === 'depth') {
      result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
    }
    return result;
  };
  publicAPI.addSampler = (device, options) => {
    const newSamp = Sampler/* default.newInstance */.Ay.newInstance({
      label: `${model.label}Sampler`
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = () => {
    // check if the handle changed
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };

  // if the texture has changed then get a new view
  publicAPI.getHandle = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const TextureView_DEFAULT_VALUES = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};

// ----------------------------------------------------------------------------

function TextureView_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, TextureView_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    texture: {
      sampleType: 'float',
      viewDimension: '2d'
      // multisampled: false,
    }
  };

  model.bindGroupTime = {};
  macros2.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  macros2.m.get(publicAPI, model, ['bindGroupTime', 'texture']);
  macros2.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'label', 'sampler']);
  vtkWebGPUTextureView(publicAPI, model);
}

// ----------------------------------------------------------------------------

const TextureView_newInstance = macros2.m.newInstance(TextureView_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUTextureView$1 = {
  newInstance: TextureView_newInstance,
  extend: TextureView_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js







const {
  BufferUsage: Texture_BufferUsage
} = BufferManager/* default */.Ay;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkWebGPUTexture methods
// ----------------------------------------------------------------------------

function vtkWebGPUTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUTexture');
  publicAPI.create = (device, options) => {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    const dimension = model.depth === 1 ? '2d' : '3d';
    model.format = options.format ? options.format : 'rgba8unorm';
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    /* eslint-disable no-undef */
    /* eslint-disable no-bitwise */
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    /* eslint-enable no-undef */
    /* eslint-enable no-bitwise */
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      // 'rgba8unorm',
      usage: model.usage,
      label: model.label,
      dimension,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = (device, handle, options) => {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : 'rgba8unorm';
    /* eslint-disable no-undef */
    /* eslint-disable no-bitwise */
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    /* eslint-enable no-undef */
    /* eslint-enable no-bitwise */
  };

  publicAPI.writeImageData = req => {
    let nativeArray = [];
    if (req.canvas) {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source: req.canvas,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true
      }, [model.width, model.height, model.depth]);
      model.ready = true;
      return;
    }
    if (req.jsImageData && !req.nativeArray) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = 'rgba8unorm';
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    let bufferBytesPerRow = model.width * tDetails.stride;
    const fixAll = (arr, height, depth) => {
      // bytesPerRow must be a multiple of 256 so we might need to rebuild
      // the data here before passing to the buffer. e.g. if it is unorm8x4 then
      // we need to have width be a multiple of 64
      const inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;

      // is this a half float texture?
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';

      // if we need to copy the data
      if (halfFloat || inWidthInBytes % 256) {
        const inArray = arr;
        const inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
        const outBytesPerElement = tDetails.elementSize;
        const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        const outWidth = outWidthInBytes / outBytesPerElement;
        const outArray = macros2.m.newTypedArray(halfFloat ? 'Uint16Array' : inArray.constructor.name, outWidth * height * depth);
        for (let v = 0; v < height * depth; v++) {
          if (halfFloat) {
            for (let i = 0; i < inWidth; i++) {
              outArray[v * outWidth + i] = HalfFloat/* default */.A.toHalf(inArray[v * inWidth + i]);
            }
          } else {
            outArray.set(inArray.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      }
      return [arr, inWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    if (req.image) {
      const canvas = document.createElement('canvas');
      canvas.width = req.image.width;
      canvas.height = req.image.height;
      const ctx = canvas.getContext('2d');
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
      nativeArray = imageData.data;
    }
    const cmdEnc = model.device.createCommandEncoder();
    if (publicAPI.getDimensionality() !== 3) {
      // Non-3D, supports mipmaps
      const mips = Texture/* default */.Ay.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
      let currentWidth = model.width;
      let currentHeight = model.height;
      for (let m = 0; m <= model.mipLevel; m++) {
        const fix = fixAll(mips[m], currentHeight, 1);
        bufferBytesPerRow = fix[1];
        const buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          nativeArray: fix[0],
          /* eslint-disable no-undef */
          usage: Texture_BufferUsage.Texture
          /* eslint-enable no-undef */
        };

        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: currentHeight
        }, {
          texture: model.handle,
          mipLevel: m
        }, [currentWidth, currentHeight, 1]);
        currentWidth /= 2;
        currentHeight /= 2;
      }
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    } else {
      // 3D, no mipmaps
      const fix = fixAll(nativeArray, model.height, model.depth);
      bufferBytesPerRow = fix[1];
      const buffRequest = {
        dataArray: req.dataArray ? req.dataArray : null,
        /* eslint-disable no-undef */
        usage: Texture_BufferUsage.Texture
        /* eslint-enable no-undef */
      };

      buffRequest.nativeArray = fix[0];
      const buff = model.device.getBufferManager().getBuffer(buffRequest);
      cmdEnc.copyBufferToTexture({
        buffer: buff.getHandle(),
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        texture: model.handle
      }, [model.width, model.height, model.depth]);
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    }
  };

  // when data is pulled out of this texture what scale must be applied to
  // get back to the original source data. For formats such as r8unorm we
  // have to multiply by 255.0, for formats such as r16float it is 1.0
  publicAPI.getScale = () => {
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';
    return halfFloat ? 1.0 : 255.0;
  };
  publicAPI.getNumberOfComponents = () => {
    const tDetails = Types/* default */.A.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = () => {
    let dims = 0;
    if (model.width > 1) dims++;
    if (model.height > 1) dims++;
    if (model.depth > 1) dims++;
    return dims;
  };
  publicAPI.resizeToMatch = tex => {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function (width, height) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function (label) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // if options is missing values try to add them in
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? '2d' : '3d';
    }
    const view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Texture_DEFAULT_VALUES = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};

// ----------------------------------------------------------------------------

function Texture_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Texture_DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['handle', 'ready', 'width', 'height', 'depth', 'format', 'usage']);
  macros2.m.setGet(publicAPI, model, ['device', 'label']);
  vtkWebGPUTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Texture_newInstance = macros2.m.newInstance(Texture_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUTexture$1 = {
  newInstance: Texture_newInstance,
  extend: Texture_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
var WebGPU_PixelSpaceCallbackMapper = __webpack_require__(77489);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Profiles/Geometry.js






















// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache_cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/validateContourSet.js
function validateContourSet_validateContourSet(contourSetData) {
    if (!contourSetData || contourSetData.data.length === 0) {
        throw new Error('Invalid contour set data, see publicContourSetData type for more info');
    }
    if (!contourSetData.id) {
        throw new Error('Invalid contour set data, each contour set must have an id');
    }
    if (!contourSetData.data || !Array.isArray(contourSetData.data)) {
        throw new Error('Invalid contour set data, each contour set must have an array of contours');
    }
    contourSetData.data.forEach((contourData) => {
        if (!contourData.points || !Array.isArray(contourData.points)) {
            throw new Error('Invalid contour set data, each contour must have an array of points');
        }
        contourData.points.forEach((point) => {
            if (!point || !Array.isArray(point) || point.length !== 3) {
                throw new Error('Invalid contour set data, each point must be an array of length 3');
            }
        });
    });
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Contour.js
class Contour_Contour {
    constructor(props) {
        const { points, type } = props.data;
        this.id = props.id;
        this._points = points;
        this._type = type;
        this._color = props.color;
        this._segmentIndex = props.segmentIndex;
        this.sizeInBytes = this._getSizeInBytes();
    }
    _getSizeInBytes() {
        return this._points.length * 3;
    }
    get points() {
        return this._points;
    }
    set points(value) {
        this._points = value;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    get segmentIndex() {
        return this._segmentIndex;
    }
    set segmentIndex(value) {
        this._segmentIndex = value;
    }
    get flatPointsArray() {
        return this._points.map((point) => [...point]).flat();
    }
}
/* harmony default export */ const classes_Contour = ((/* unused pure expression or super */ null && (Contour_Contour)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ContourSet.js

class ContourSet_ContourSet {
    constructor(props) {
        this._color = [200, 0, 0];
        this.id = props.id;
        this._contours = [];
        this._color = props.color ?? this._color;
        this.frameOfReferenceUID = props.frameOfReferenceUID;
        this._segmentIndex = props.segmentIndex;
        this._createEachContour(props.data);
        this.sizeInBytes = this._getSizeInBytes();
    }
    _createEachContour(contourDataArray) {
        contourDataArray.forEach((contourData) => {
            const { points, type, color } = contourData;
            const contour = new Contour({
                id: `${this.id}-segment-${this._segmentIndex}`,
                data: {
                    points,
                    type,
                    segmentIndex: this._segmentIndex,
                    color: color ?? this._color,
                },
                segmentIndex: this._segmentIndex,
                color: color ?? this._color,
            });
            this._contours.push(contour);
        });
        this._updateContourSetCentroid();
    }
    _updateContourSetCentroid() {
        const numberOfPoints = this.totalNumberOfPoints;
        const flatPointsArray = this.flatPointsArray;
        const sumOfPoints = flatPointsArray.reduce((acc, point) => {
            return [acc[0] + point[0], acc[1] + point[1], acc[2] + point[2]];
        }, [0, 0, 0]);
        const centroid = [
            sumOfPoints[0] / numberOfPoints,
            sumOfPoints[1] / numberOfPoints,
            sumOfPoints[2] / numberOfPoints,
        ];
        const closestPoint = flatPointsArray.reduce((closestPoint, point) => {
            const distanceToPoint = this._getDistance(centroid, point);
            const distanceToClosestPoint = this._getDistance(centroid, closestPoint);
            if (distanceToPoint < distanceToClosestPoint) {
                return point;
            }
            else {
                return closestPoint;
            }
        }, flatPointsArray[0]);
        this._centroid = closestPoint;
    }
    _getSizeInBytes() {
        return this._contours.reduce((sizeInBytes, contour) => {
            return sizeInBytes + contour.sizeInBytes;
        }, 0);
    }
    _getDistance(pointA, pointB) {
        return Math.sqrt((pointA[0] - pointB[0]) ** 2 +
            (pointA[1] - pointB[1]) ** 2 +
            (pointA[2] - pointB[2]) ** 2);
    }
    get centroid() {
        return this._centroid;
    }
    get segmentIndex() {
        return this._segmentIndex;
    }
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
        this._contours.forEach((contour) => {
            if (contour instanceof Contour) {
                contour.color = value;
            }
        });
    }
    get contours() {
        return this._contours;
    }
    get flatPointsArray() {
        return this._contours.flatMap((contour) => contour.points);
    }
    get numberOfContours() {
        return this._contours.length;
    }
    get totalNumberOfPoints() {
        return this._contours.reduce((numberOfPoints, contour) => {
            return numberOfPoints + contour.points.length;
        }, 0);
    }
    get numberOfPointsArray() {
        return this._contours.map((contour) => contour.points.length);
    }
    getPointsInContour(contourIndex) {
        return this._contours[contourIndex].points;
    }
    getNumberOfPointsInAContour(contourIndex) {
        return this.getPointsInContour(contourIndex).length;
    }
}
/* harmony default export */ const classes_ContourSet = ((/* unused pure expression or super */ null && (ContourSet_ContourSet)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/createContourSet.js



function createContourSet_createContourSet(geometryId, contourSetData) {
    validateContourSet(contourSetData);
    const contourSet = new ContourSet({
        id: contourSetData.id,
        data: contourSetData.data,
        color: contourSetData.color,
        frameOfReferenceUID: contourSetData.frameOfReferenceUID,
        segmentIndex: contourSetData.segmentIndex ?? 1,
    });
    const geometry = {
        id: geometryId,
        type: GeometryType.CONTOUR,
        data: contourSet,
        sizeInBytes: contourSet.sizeInBytes,
    };
    return geometry;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/validateSurface.js
function validateSurface_validateSurface(surfaceData) {
    if (!surfaceData.id) {
        throw new Error('Surface must have an id');
    }
    if (surfaceData.points?.length === 0) {
        throw new Error('Surface must have non-empty points array');
    }
    if (surfaceData.polys?.length === 0) {
        throw new Error('Surface must have non-empty polys array');
    }
    if (!surfaceData.frameOfReferenceUID) {
        throw new Error('Surface must have a frameOfReferenceUID');
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Surface.js
var classes_Surface = __webpack_require__(90808);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/createSurface.js



function createSurface_createSurface(geometryId, surfaceData) {
    validateSurface(surfaceData);
    const surface = new Surface({
        id: surfaceData.id,
        points: surfaceData.points,
        polys: surfaceData.polys,
        color: surfaceData.color,
        frameOfReferenceUID: surfaceData.frameOfReferenceUID,
        segmentIndex: surfaceData.segmentIndex ?? 1,
    });
    const geometry = {
        id: geometryId,
        type: GeometryType.SURFACE,
        data: surface,
        sizeInBytes: surface.sizeInBytes,
    };
    return geometry;
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/mesh/createMesh.js + 2 modules
var mesh_createMesh = __webpack_require__(97994);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var enums_Events = __webpack_require__(32643);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var esm_eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var utilities_triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneMeshLoader.js
var cornerstoneMeshLoader = __webpack_require__(56074);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/geometryLoader.js










let loaderOptions = {
    beforeSend(xhr) {
    },
};
function setOptions(newOptions) {
    loaderOptions = Object.assign(loaderOptions, newOptions);
}
function getOptions() {
    return loaderOptions;
}
const geometryLoaders = {};
let unknownGeometryLoader;
function loadGeometryFromGeometryLoader(geometryId, options) {
    const colonIndex = geometryId.indexOf(':');
    const scheme = geometryId.substring(0, colonIndex);
    let loader = geometryLoaders[scheme];
    if (loader === undefined || loader === null) {
        if (unknownGeometryLoader == null ||
            typeof unknownGeometryLoader !== 'function') {
            throw new Error(`No geometry loader for scheme ${scheme} has been registered`);
        }
        loader = unknownGeometryLoader;
    }
    const geometryLoadObject = loader(geometryId, options, loaderOptions);
    geometryLoadObject.promise.then(function (geometry) {
        triggerEvent(eventTarget, Events.GEOMETRY_LOADED, { geometry });
    }, function (error) {
        const errorObject = {
            geometryId,
            error,
        };
        triggerEvent(eventTarget, Events.GEOMETRY_LOADED_FAILED, errorObject);
    });
    return geometryLoadObject;
}
function loadGeometry(geometryId, options) {
    if (geometryId === undefined) {
        throw new Error('loadGeometry: parameter geometryId must not be undefined');
    }
    let geometryLoadObject = cache.getGeometryLoadObject(geometryId);
    if (geometryLoadObject !== undefined) {
        return geometryLoadObject.promise;
    }
    geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);
    return geometryLoadObject.promise;
}
async function loadAndCacheGeometry(geometryId, options) {
    if (geometryId === undefined) {
        throw new Error('createAndCacheGeometry: parameter geometryId must not be undefined');
    }
    let geometryLoadObject = cache.getGeometryLoadObject(geometryId);
    if (geometryLoadObject !== undefined) {
        return geometryLoadObject.promise;
    }
    geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);
    await cache.putGeometryLoadObject(geometryId, geometryLoadObject);
    return geometryLoadObject.promise;
}
function createAndCacheGeometry(geometryId, options) {
    if (geometryId === undefined) {
        throw new Error('createAndCacheGeometry: parameter geometryId must not be undefined');
    }
    let geometry = cache.getGeometry(geometryId);
    if (geometry) {
        return geometry;
    }
    if (options.type === GeometryType.CONTOUR) {
        geometry = createContourSet(geometryId, options.geometryData);
    }
    else if (options.type === GeometryType.SURFACE) {
        geometry = createSurface(geometryId, options.geometryData);
    }
    else if (options.type === GeometryType.MESH) {
        createMesh(geometryId, options.geometryData).then((mesh) => {
            geometry = mesh;
        });
    }
    else {
        throw new Error(`Unknown geometry type: ${options.type}`);
    }
    cache.putGeometrySync(geometryId, geometry);
    return geometry;
}
function registerGeometryLoader(scheme, geometryLoader) {
    geometryLoaders[scheme] = geometryLoader;
}
function registerUnknownGeometryLoader(geometryLoader) {
    const oldGeometryLoader = unknownGeometryLoader;
    unknownGeometryLoader = geometryLoader;
    return oldGeometryLoader;
}
registerGeometryLoader('mesh', cornerstoneMeshLoader/* cornerstoneMeshLoader */.R);


/***/ }),

/***/ 97994:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  q: () => (/* binding */ createMesh)
});

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/index.js + 1 modules
var enums = __webpack_require__(71851);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Mesh.js + 4 modules
var Mesh = __webpack_require__(29625);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/mesh/validateMesh.js

function validateMesh(meshData) {
    if (!meshData.id) {
        throw new Error('Mesh must have an id');
    }
    if (!meshData.arrayBuffer) {
        throw new Error('Mesh must have an arrayBuffer');
    }
    if (!(meshData.format in enums.MeshType)) {
        throw new Error(`Mesh format must be one of the following: ${Object.values(enums.MeshType).join(', ')}`);
    }
}

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var DataAccessHelper = __webpack_require__(8906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
var Texture = __webpack_require__(61433);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js + 1 modules
var LiteHttpDataAccessHelper = __webpack_require__(67313);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/Misc/MTLReader.js





// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + gz
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

// ----------------------------------------------------------------------------
// vtkMTLReader methods
// ----------------------------------------------------------------------------

function vtkMTLReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkMTLReader');
  function imageReady() {
    model.requestCount--;
    if (model.requestCount === 0) {
      publicAPI.invokeBusy(false);
    }
  }
  function parseLine(line) {
    if (line[0] === '#' || line.length === 0) {
      return;
    }
    const tokens = line.split(/[ \t]+/).map(s => s.trim()).filter(s => s.length);
    if (tokens[0] === 'newmtl') {
      tokens.shift();
      model.currentMaterial = tokens.join(' ').trim();
    } else if (model.currentMaterial) {
      if (tokens.length < 2) {
        return;
      }
      if (!model.materials[model.currentMaterial]) {
        model.materials[model.currentMaterial] = {};
      }
      model.materials[model.currentMaterial][tokens[0]] = tokens.slice(1);
      if (tokens[0] === 'map_Kd') {
        const image = new Image();
        image.onload = () => setTimeout(imageReady, 0);
        image.src = [model.baseURL, tokens[1]].join('/');
        model.materials[model.currentMaterial].image = image;
        model.requestCount++;
      }
    }
  }

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper/* default.get */.Ay.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url, options) {
    return model.dataAccessHelper.fetchText(publicAPI, url, options);
  }

  // Set DataSet url
  publicAPI.setUrl = function (url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (url.indexOf('.mtl') === -1 && !option.fullpath) {
      model.baseURL = url;
      model.url = `${url}/index.mtl`;
    } else {
      model.url = url;

      // Remove the file in the URL
      const path = url.split('/');
      path.pop();
      model.baseURL = path.join('/');
    }

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = option => new Promise((resolve, reject) => {
    fetchData(model.url, option).then(content => {
      publicAPI.parseAsText(content);
      resolve();
    }, err => {
      reject();
    });
  });
  publicAPI.parseAsText = content => {
    publicAPI.modified();
    model.materials = {};
    content.split('\n').forEach(parseLine);
  };

  // return Busy state
  publicAPI.isBusy = () => !!model.requestCount;
  publicAPI.getMaterialNames = () => Object.keys(model.materials);
  publicAPI.getMaterial = name => model.materials[name];
  publicAPI.listImages = () => Object.keys(model.materials).map(name => model.materials[name].map_Kd).filter(fileName => !!fileName).map(s => s[0].trim());
  publicAPI.setImageSrc = (imagePath, src) => new Promise((resolve, reject) => {
    const selectedName = Object.keys(model.materials).find(name => model.materials[name].map_Kd && model.materials[name].map_Kd[0].trim() === imagePath.trim());
    const material = model.materials[selectedName];
    if (material && material.image) {
      material.image.src = src;
      material.image.onload = () => setTimeout(resolve, 0);
    } else {
      resolve();
    }
  });
  publicAPI.applyMaterialToActor = (name, actor) => {
    const material = model.materials[name];
    if (material && actor) {
      const white = [1, 1, 1];
      const actorProp = {
        ambientColor: material.Ka ? material.Ka.map(i => Number(i)) : white,
        specularColor: material.Ks ? material.Ks.map(i => Number(i)) : white,
        diffuseColor: material.Kd ? material.Kd.map(i => Number(i)) : white,
        opacity: material.d ? Number(material.d) : 1,
        specularPower: material.Ns ? Number(material.Ns) : 1
      };
      const illum = Number(material.illum || 2);
      ['ambient', 'diffuse', 'specular'].forEach((k, idx) => {
        actorProp[k] = idx <= illum ? 1.0 : 0.0;
      });
      if (material.image) {
        const texture = Texture/* default.newInstance */.Ay.newInstance({
          interpolate: model.interpolateTextures
        });
        texture.setImage(material.image);
        actor.addTexture(texture);
      }
      actor.getProperty().set(actorProp);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfOutputs: 1,
  requestCount: 0,
  materials: {},
  interpolateTextures: true
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,macros2.o)(publicAPI, model);
  (0,macros2.g)(publicAPI, model, ['url', 'baseURL']);
  (0,macros2.e)(publicAPI, model, ['dataAccessHelper', 'interpolateTextures', 'splitGroup']);
  (0,macros2.f)(publicAPI, model, 'busy');

  // Object methods
  vtkMTLReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,macros2.n)(extend, 'vtkMTLReader');

// ----------------------------------------------------------------------------

var vtkMTLReader$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/mesh/createMesh.js





function createMesh(geometryId, meshData) {
    validateMesh(meshData);
    const mesh = new Mesh/* Mesh */.e({
        ...meshData,
    });
    const geometry = {
        id: geometryId,
        type: enums.GeometryType.MESH,
        data: mesh,
        sizeInBytes: mesh.sizeInBytes,
    };
    switch (meshData.format) {
        case enums.MeshType.PLY:
            if (meshData.materialUrl) {
                const img = new Image();
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        try {
                            const texture = Texture/* default.newInstance */.Ay.newInstance();
                            texture.setInterpolate(true);
                            texture.setImage(img);
                            mesh.defaultActor.addTexture(texture);
                            resolve(geometry);
                        }
                        catch (error) {
                            reject(error);
                        }
                    };
                    img.onerror = (error) => reject(error);
                    img.src = meshData.materialUrl;
                });
            }
            return Promise.resolve(geometry);
        case enums.MeshType.OBJ:
            if (meshData.materialUrl) {
                const reader = vtkMTLReader$1.newInstance();
                return reader
                    .setUrl(meshData.materialUrl)
                    .then(() => {
                    for (let i = 0; i < mesh.actors.length; i++) {
                        const actor = mesh.actors[i];
                        const mapper = actor.getMapper();
                        if (mapper) {
                            const inputData = mapper.getInputData();
                            if (inputData) {
                                const name = inputData.get('name').name;
                                reader.applyMaterialToActor(name, actor);
                            }
                        }
                    }
                    return geometry;
                })
                    .catch((error) => {
                    throw new Error(`Failed to load material: ${error}`);
                });
            }
            return Promise.resolve(geometry);
        case enums.MeshType.STL:
        case enums.MeshType.VTP:
            return Promise.resolve(geometry);
        default:
            return Promise.reject(new Error(`Unsupported format: ${meshData.format}`));
    }
}


/***/ }),

/***/ 87142:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createAndCacheDerivedLabelmapVolume: () => (/* binding */ createAndCacheDerivedLabelmapVolume),
  createAndCacheDerivedVolume: () => (/* binding */ createAndCacheDerivedVolume),
  createAndCacheVolume: () => (/* binding */ createAndCacheVolume),
  createAndCacheVolumeFromImages: () => (/* binding */ createAndCacheVolumeFromImages),
  createAndCacheVolumeFromImagesSync: () => (/* binding */ createAndCacheVolumeFromImagesSync),
  createLocalLabelmapVolume: () => (/* binding */ createLocalLabelmapVolume),
  createLocalVolume: () => (/* binding */ createLocalVolume),
  getUnknownVolumeLoaderSchema: () => (/* binding */ getUnknownVolumeLoaderSchema),
  getVolumeLoaderSchemes: () => (/* binding */ getVolumeLoaderSchemes),
  loadVolume: () => (/* binding */ loadVolume),
  registerUnknownVolumeLoader: () => (/* binding */ registerUnknownVolumeLoader),
  registerVolumeLoader: () => (/* binding */ registerVolumeLoader)
});

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera = __webpack_require__(38475);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer = __webpack_require__(63819);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var CellArray = __webpack_require__(35056);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js




const {
  vtkErrorMacro
} = macros2.m;
class SegmentAgregator {
  constructor() {
    this.segmentMapping = {};
    this.segments = [null]; // to force first id to be 1
    this.faces = [];
  }
  addSegment(segment) {
    const first = segment[0];
    const last = segment[segment.length - 1];
    if (first === last || segment.length < 2) {
      return;
    }
    const mappingFirst = this.segmentMapping[first];
    const mappingLast = this.segmentMapping[last];
    if (mappingFirst !== undefined && mappingLast !== undefined) {
      if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {
        // This make a closing loop
        const idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;
        const seg = this.segments[idx];
        if (mappingFirst > 0) {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.push(segment[i]);
          }
        } else {
          for (let i = 1; i < segment.length - 1; i++) {
            seg.unshift(segment[segment.length - 1 - i]);
          }
        }
        this.faces.push(seg);
        this.segments[idx] = null;
        this.segmentMapping[first] = undefined;
        this.segmentMapping[last] = undefined;
      } else {
        // we need to merge segments
        // strategie:
        // => remove and add them again in special order to induce merge
        const idxHead = Math.abs(mappingFirst);
        const idxTail = Math.abs(mappingLast);
        const segHead = this.segments[idxHead];
        const segTail = this.segments[idxTail];
        this.segments[idxHead] = null;
        this.segments[idxTail] = null;
        this.segmentMapping[segHead[0]] = undefined;
        this.segmentMapping[segTail[0]] = undefined;
        this.segmentMapping[segHead[segHead.length - 1]] = undefined;
        this.segmentMapping[segTail[segTail.length - 1]] = undefined;

        // This will lead to a single segment
        this.addSegment(segment);
        this.addSegment(segHead);
        this.addSegment(segTail);
      }
    } else if (mappingFirst !== undefined) {
      if (mappingFirst > 0) {
        // The head of our segment match the tail of the existing one
        const seg = this.segments[mappingFirst];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[i]);
        }
        // record new tail
        this.segmentMapping[last] = mappingFirst;
      } else {
        // our segment should be reverted and put on the front of the existing one
        const seg = this.segments[-mappingFirst];
        // record new head
        this.segmentMapping[last] = mappingFirst;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[i]);
        }
      }
      // Erase used connection
      this.segmentMapping[first] = undefined;
    } else if (mappingLast !== undefined) {
      if (mappingLast > 0) {
        // The tail of our segment match the tail of the existing one
        const seg = this.segments[mappingLast];
        for (let i = 1; i < segment.length; i++) {
          seg.push(segment[segment.length - 1 - i]);
        }
        // record new tail
        this.segmentMapping[first] = mappingLast;
      } else {
        // our segment should be reverted and put on the front of the existing one
        const seg = this.segments[-mappingLast];

        // record new head
        this.segmentMapping[first] = mappingLast;
        for (let i = 1; i < segment.length; i++) {
          seg.unshift(segment[segment.length - i - 1]);
        }
      }
      // Erase used connection
      this.segmentMapping[last] = undefined;
    } else {
      // store segment for now
      const id = this.segments.length;
      this.segments.push(segment);
      this.segmentMapping[first] = -id;
      this.segmentMapping[last] = id;
    }
  }
}

// ----------------------------------------------------------------------------
// vtkClosedPolyLineToSurfaceFilter methods
// ----------------------------------------------------------------------------

function vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter');

  // --------------------------------------------------------------------------

  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input) {
      vtkErrorMacro('Invalid or missing input');
      return;
    }
    const output = PolyData/* default.newInstance */.Ay.newInstance();
    output.shallowCopy(input);

    // Extract faces
    const agregator = new SegmentAgregator();
    const lines = input.getLines().getData();
    let offset = 0;
    while (offset < lines.length) {
      const lineSize = lines[offset++];
      const lineSegment = [];
      for (let i = 0; i < lineSize; i++) {
        lineSegment.push(lines[offset + i]);
      }
      agregator.addSegment(lineSegment);
      offset += lineSize;
    }

    // Create CellArray for polys
    const {
      faces
    } = agregator;
    let cellArraySize = faces.length;
    for (let i = 0; i < faces.length; i++) {
      cellArraySize += faces[i].length;
    }
    const cellArray = new Uint16Array(cellArraySize);
    offset = 0;
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      cellArray[offset++] = face.length;
      for (let j = 0; j < face.length; j++) {
        cellArray[offset++] = face[j];
      }
    }
    output.setPolys(CellArray/* default.newInstance */.Ay.newInstance({
      values: cellArray,
      name: 'faces'
    }));
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  macros2.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  macros2.m.algo(publicAPI, model, 1, 1);

  // Object specific methods
  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter');

// ----------------------------------------------------------------------------

var vtkClosedPolyLineToSurfaceFilter$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Core/Cutter.js
var Cutter = __webpack_require__(61088);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Filters/Sources/CubeSource.js
var CubeSource = __webpack_require__(56748);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Filters/General/ImageDataOutlineFilter.js



const {
  vtkErrorMacro: ImageDataOutlineFilter_vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkImageDataOutlineFilter methods
// ----------------------------------------------------------------------------

function vtkImageDataOutlineFilter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageDataOutlineFilter');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input || !input.isA('vtkImageData')) {
      ImageDataOutlineFilter_vtkErrorMacro('Invalid or missing input');
      return;
    }

    // First create a cube polydata in the index-space of the image.
    // The benefit of using `getSpatialExtent` call is that it automatically
    // takes care of 0.5 voxel padding as required by an vtkImageData representation.
    const spatialExt = input.getSpatialExtent();
    if (!spatialExt) {
      ImageDataOutlineFilter_vtkErrorMacro('Unable to fetch spatial extents of input image.');
      return;
    }
    model._cubeSource.setBounds(spatialExt);

    // Then apply index-to-world transform to the cube to create the outline.
    model._cubeSource.setMatrix(input.getIndexToWorld());
    outData[0] = model._cubeSource.getOutputData();
  };
  publicAPI.getMTime = () => Math.max(superClass.getMTime(), model._cubeSource.getMTime());

  // Forward calls for [set/get]Generate[Faces/Lines] functions to cubeSource:
  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageDataOutlineFilter_DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function ImageDataOutlineFilter_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageDataOutlineFilter_DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  macros2.m.obj(publicAPI, model);

  // Also make it an algorithm with one input and one output
  macros2.m.algo(publicAPI, model, 1, 1);

  // Internal persistent objects
  model._cubeSource = CubeSource/* default.newInstance */.Ay.newInstance();
  macros2.m.moveToProtected(publicAPI, model, ['cubeSource', 'tmpOut']);

  // Object specific methods
  vtkImageDataOutlineFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageDataOutlineFilter_newInstance = macros2.m.newInstance(ImageDataOutlineFilter_extend, 'vtkImageDataOutlineFilter');

// ----------------------------------------------------------------------------

var vtkImageDataOutlineFilter$1 = {
  newInstance: ImageDataOutlineFilter_newInstance,
  extend: ImageDataOutlineFilter_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js + 1 modules
var Texture = __webpack_require__(79525);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js + 1 modules
var Plane = __webpack_require__(75127);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js
var Constants = __webpack_require__(35341);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/Transform/Transform.js





// ----------------------------------------------------------------------------
// vtkTransform methods
// ----------------------------------------------------------------------------
// eslint-disable-next-line import/no-mutable-exports
let Transform_newInstance;
function vtkTransform(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkAbstractTransform', 'vtkHomogeneousTransform', 'vtkTransform');
  publicAPI.transformPoint = (point, out) => {
    esm/* vec3.transformMat4 */.eR.transformMat4(out, point, model.matrix);
    return out;
  };
  publicAPI.transformPoints = (points, out) => {
    const inPoint = new Float64Array(3);
    const outPoint = new Float64Array(3);
    for (let i = 0; i < points.length; i += 3) {
      inPoint[0] = points[i];
      inPoint[1] = points[i + 1];
      inPoint[2] = points[i + 2];
      esm/* vec3.transformMat4 */.eR.transformMat4(outPoint, inPoint, model.matrix);
      out[i] = outPoint[0];
      out[i + 1] = outPoint[1];
      out[i + 2] = outPoint[2];
    }
    return out;
  };

  /**
   * Sets the internal state of the transform to PreMultiply.
   * All subsequent operations will occur before those already represented in the current transformation.
   * In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */
  publicAPI.preMultiply = () => {
    publicAPI.setPreMultiplyFlag(true);
  };

  /**
   * Sets the internal state of the transform to PostMultiply.
   * All subsequent operations will occur after those already represented in the current transformation.
   * In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */
  publicAPI.postMultiply = () => {
    publicAPI.setPreMultiplyFlag(false);
  };
  publicAPI.transformMatrix = (matrix, out) => {
    if (model.preMultiplyFlag) {
      esm/* mat4.multiply */.pB.multiply(out, model.matrix, matrix);
    } else {
      esm/* mat4.multiply */.pB.multiply(out, matrix, model.matrix);
    }
    return out;
  };

  // Apply the transform to each matrix in the same way as transformMatrix
  // `matrices` can be a contiguous array of float or an array of array
  publicAPI.transformMatrices = (matrices, out) => {
    const inMat = new Float64Array(16);
    const outMat = new Float64Array(16);
    const transform = model.preMultiplyFlag ? () => esm/* mat4.multiply */.pB.multiply(outMat, model.matrix, inMat) : () => esm/* mat4.multiply */.pB.multiply(outMat, inMat, model.matrix);
    for (let i = 0; i < matrices.length; i += 16) {
      for (let j = 0; j < 16; ++j) {
        inMat[j] = matrices[i + j];
      }
      transform();
      for (let j = 0; j < 16; ++j) {
        out[i + j] = outMat[j];
      }
    }
    return out;
  };
  publicAPI.getInverse = () => Transform_newInstance({
    matrix: Core_Math.f.invertMatrix(Array.from(model.matrix), [], 4),
    preMultiplyFlag: model.preMultiplyFlag
  });
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Transform_DEFAULT_VALUES = {
  preMultiplyFlag: false,
  matrix: [...Constants/* IDENTITY */.zK]
};

// ----------------------------------------------------------------------------

function Transform_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Transform_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['preMultiplyFlag']);
  macros2.m.setGetArray(publicAPI, model, ['matrix'], 16);
  vtkTransform(publicAPI, model);
}

// ----------------------------------------------------------------------------
Transform_newInstance = macros2.m.newInstance(Transform_extend, 'vtkTransform');

// ----------------------------------------------------------------------------

var vtkTransform$1 = {
  newInstance: Transform_newInstance,
  extend: Transform_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperVS.glsl.js
var vtkImageResliceMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkImageResliceMapperFS.glsl.js
var vtkImageResliceMapperFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var ImageProperty_Constants = __webpack_require__(91732);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataArray_Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
var CoincidentTopologyHelper = __webpack_require__(57285);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Static = __webpack_require__(7698);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js


























const {
  vtkErrorMacro: ImageResliceMapper_vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
  matrixType.identity(tmpMat);
  return matrixArray.reduce((res, matrix, index) => {
    if (index === 0) {
      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
    }
    return matrix ? matrixType.multiply(res, res, matrix) : res;
  }, tmpMat);
}

// ----------------------------------------------------------------------------
// vtkOpenGLImageResliceMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageResliceMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageResliceMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const ren = model._openGLRenderer.getRenderable();
      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == Static/* Resolve */.XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };

  // Renders myself
  publicAPI.render = () => {
    const actor = model._openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    if (!model.currentInput) {
      ImageResliceMapper_vtkErrorMacro('No input!');
      return;
    }
    publicAPI.updateResliceGeometry();
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);
    const iType = actor.getProperty().getInterpolationType();
    if (iType === ImageProperty_Constants/* InterpolationType */.V.NEAREST) {
      model.openGLTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.openGLTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
    } else {
      model.openGLTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.openGLTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
    }

    // No buffer objects bound.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // render the texture
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();

    // update shaders if required
    publicAPI.updateShaders(model.tris, ren, actor);

    // Finally draw
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffer objects if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const numComp = scalars.getNumberOfComponents();
    let toString = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    const updatedExtents = model.renderable.getUpdatedExtents();
    const hasUpdatedExtents = !!updatedExtents.length;
    if (reBuildTex && !hasUpdatedExtents) {
      model.openGLTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the image scalar texture
      // Use norm16 for the 3D texture if the extension is available
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.openGLTexture.resetFormatAndType();

      // Build the image scalar texture
      const dims = image.getDimensions();
      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, false, updatedExtents);
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.openGLTexture, toString);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.openGLTexture = tex.oglObject;
    }
    if (hasUpdatedExtents) {
      // If hasUpdatedExtents, then the texture is partially updated.
      // clear the array to acknowledge the update.
      model.renderable.setUpdatedExtents([]);
      const dims = image.getDimensions();
      model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, false, updatedExtents);
    }
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = ppty.getPiecewiseFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    // rebuild opacity tfun?
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== toString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, DataArray_Constants/* VtkDataTypes */.JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, toString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }
    const vboString = `${model.resliceGeom.getMTime()}A${model.renderable.getSlabThickness()}`;
    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {
      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: model.resliceGeom.getPoints().getData()
      });
      points.setName('points');
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: model.resliceGeom.getPolys().getData()
      });
      const options = {
        points,
        cellOffset: 0
      };
      if (model.renderable.getSlabThickness() > 0.0) {
        const n = model.resliceGeom.getPointData().getNormals();
        if (!n) {
          ImageResliceMapper_vtkErrorMacro('Slab mode requested without normals');
        } else {
          options.normals = n;
        }
      }
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, options);
    }
    model.VBOBuildString = vboString;
    model.VBOBuildTime.modified();
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      // Set the 3D texture
      if (program.isUniformUsed('texture1')) {
        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());
      }

      // Set the plane vertex attributes
      if (program.isAttributeUsed('vertexWC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          ImageResliceMapper_vtkErrorMacro('Error setting vertexWC in shader VAO.');
        }
      }

      // If we are doing slab mode, we need normals
      if (program.isAttributeUsed('normalWC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          ImageResliceMapper_vtkErrorMacro('Error setting normalWC in shader VAO.');
        }
      }
      if (program.isUniformUsed('slabThickness')) {
        program.setUniformf('slabThickness', model.renderable.getSlabThickness());
      }
      if (program.isUniformUsed('spacing')) {
        program.setUniform3fv('spacing', model.currentInput.getSpacing());
      }
      if (program.isUniformUsed('slabType')) {
        program.setUniformi('slabType', model.renderable.getSlabType());
      }
      if (program.isUniformUsed('slabType')) {
        program.setUniformi('slabType', model.renderable.getSlabType());
      }
      if (program.isUniformUsed('slabTrapezoid')) {
        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;

      // Set the world->texture matrix
      if (program.isUniformUsed('WCTCMatrix')) {
        const image = model.currentInput;
        const dim = image.getDimensions();
        esm/* mat4.copy */.pB.copy(model.tmpMat4, image.getIndexToWorld());
        esm/* mat4.translate */.pB.translate(model.tmpMat4, model.tmpMat4, [-0.5, -0.5, -0.5]);
        esm/* mat4.scale */.pB.scale(model.tmpMat4, model.tmpMat4, dim);
        esm/* mat4.invert */.pB.invert(model.tmpMat4, model.tmpMat4);
        if (inverseShiftScaleMatrix) {
          esm/* mat4.multiply */.pB.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        }
        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);
      }
      if (program.isUniformUsed('vboScaling')) {
        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale() ?? [1, 1, 1]);
      }
      cellBO.getAttributeUpdateTime().modified();
    }

    // Depth request
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    // [WMVP]C == {world, model, view, projection} coordinates
    // e.g. WCPC == world to projection coordinate transformation
    const keyMats = model._openGLCamera.getKeyMatrices(ren);
    const actMats = model._openGLImageSlice.getKeyMatrices();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const program = cellBO.getProgram();
    if (program.isUniformUsed('MCPCMatrix')) {
      esm/* mat4.identity */.pB.identity(model.tmpMat4);
      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      esm/* mat4.identity */.pB.identity(model.tmpMat4);
      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], esm/* mat4 */.pB, model.tmpMat4));
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);

    // Component mix
    // Independent components: Mixed according to component weights
    // Dependent components: Mixed using the following logic:
    //    - 2 comps => LA
    //    - 3 comps => RGB + opacity from pwf
    //    - 4 comps => RGBA
    const numComp = model.openGLTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }

    // Color opacity map
    const volInfo = model.openGLTexture.getVolumeInfo();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = volInfo.scale[i] / cw;
      const shift = (volInfo.offset[i] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale);
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    program.setUniformi('colorTexture1', texColorUnit);

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length;
        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    program.setUniformi('pwfTexture1', texOpacityUnit);

    // Background color
    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed
    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const slabTh = model.renderable.getSlabThickness();
    const slabType = model.renderable.getSlabType();
    const slabTrap = model.renderable.getSlabTrapezoidIntegration();

    // has the render pass shader replacement changed? Two options
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      model.lastSlabThickness = slabTh;
      model.lastSlabType = slabType;
      model.lastSlabTrapezoidIntegration = slabTrap;
      return true;
    }
    return false;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkImageResliceMapperVS;
    shaders.Fragment = vtkImageResliceMapperFS;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
      shaders.Fragment = FSSource;
    }
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];
    const slabThickness = model.renderable.getSlabThickness();
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;
    const tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;',
    // color shift and scale
    'uniform float cshift0;', 'uniform float cscale0;',
    // pwf shift and scale
    'uniform float pwfshift0;', 'uniform float pwfscale0;',
    // color and pwf textures
    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',
    // opacity
    'uniform float opacity;',
    // background color
    'uniform vec4 backgroundColor;'];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          ImageResliceMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    if (slabThickness > 0.0) {
      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);
      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;
    let tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];
    if (slabThickness > 0.0) {
      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          ImageResliceMapper_vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    shaders.Geometry = GSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    const GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const slabThickness = model.renderable.getSlabThickness();
    let posVCVSDec = ['attribute vec4 vertexWC;'];
    // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.
    posVCVSDec = posVCVSDec.concat([`//${publicAPI.getMTime()}${model.resliceGeomUpdateString}`]);
    if (slabThickness > 0.0) {
      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;
    let posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];
    if (slabThickness > 0.0) {
      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
    let posVCFSDec = [];
    if (slabThickness > 0.0) {
      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };

  /**
   * Returns true if the normal is almost axis aligned.
   * Has a side effect to normalize the vector.
   */
  function isVectorAxisAligned(n) {
    Core_Math.f.normalize(n);
    const tmpN = [0, 0, 0];
    for (let i = 0; i < 3; ++i) {
      esm/* vec3.zero */.eR.zero(tmpN);
      tmpN[i] = 1.0;
      const dotP = Core_Math.f.dot(n, tmpN);
      if (dotP < -0.999999 || dotP > 0.999999) {
        return [true, i];
      }
    }
    return [false, 2];
  }
  publicAPI.updateResliceGeometry = () => {
    let resGeomString = '';
    const image = model.currentInput;
    const imageBounds = image?.getBounds();
    // Orthogonal slicing by default
    let orthoSlicing = true;
    let orthoAxis = 2;
    const slicePD = model.renderable.getSlicePolyData();
    const slicePlane = model.renderable.getSlicePlane();
    if (slicePD) {
      resGeomString = resGeomString.concat(`PolyData${slicePD.getMTime()}`);
    } else if (slicePlane) {
      resGeomString = resGeomString.concat(`Plane${slicePlane.getMTime()}`);
      // Compute a world-to-image-orientation matrix.
      const w2io = esm/* mat3.create */.w0.create();
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
        // Ignore the translation component since we are
        // using it on vectors rather than positions.
        esm/* mat3.set */.w0.set(w2io, ...image.getDirection());
        esm/* mat3.invert */.w0.invert(w2io, w2io);
      }
      // Check to see if we can bypass oblique slicing related bounds computation
      // transform the cutting plane normal to image local coords
      const imageLocalNormal = [...slicePlane.getNormal()];
      esm/* vec3.transformMat3 */.eR.transformMat3(imageLocalNormal, imageLocalNormal, w2io);
      [orthoSlicing, orthoAxis] = isVectorAxisAligned(imageLocalNormal);
    } else {
      // Create a default slice plane here
      const plane = Plane/* default.newInstance */.Ay.newInstance();
      plane.setNormal(0, 0, 1);
      let bds = [0, 1, 0, 1, 0, 1];
      if (image) {
        bds = imageBounds;
      }
      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));
      model.renderable.setSlicePlane(plane);
      resGeomString = resGeomString.concat(`Plane${slicePlane?.getMTime()}`);
      if (image) {
        resGeomString = resGeomString.concat(`Image${image.getMTime()}`);
      }
    }
    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {
      if (slicePD) {
        if (!model.resliceGeom) {
          model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
        }
        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);
        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);
        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());
      } else if (slicePlane) {
        if (!orthoSlicing) {
          model.outlineFilter.setInputData(image);
          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());
          model.cutter.setCutFunction(slicePlane);
          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());
          model.lineToSurfaceFilter.update();
          if (!model.resliceGeom) {
            model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
          }
          const planePD = model.lineToSurfaceFilter.getOutputData();
          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);
          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);
          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals());
          // The above method does not generate point normals
          // Set it manually here.
          const n = slicePlane.getNormal();
          const npts = model.resliceGeom.getNumberOfPoints();
          Core_Math.f.normalize(n);
          const normalsData = new Float32Array(npts * 3);
          for (let i = 0; i < npts; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          const normals = DataArray/* default.newInstance */.Ay.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: 'Normals'
          });
          model.resliceGeom.getPointData().setNormals(normals);
        } else {
          // Since the image-local normal is axis-aligned, we
          // can quickly construct the cutting plane using indexToWorld transforms.
          const ptsArray = new Float32Array(12);
          const indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);
          const otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();
          const ext = image.getSpatialExtent();
          let ptIdx = 0;
          for (let i = 0; i < 2; ++i) {
            for (let j = 0; j < 2; ++j) {
              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];
              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];
              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + i];
              ptIdx += 3;
            }
          }
          model.transform.setMatrix(image.getIndexToWorld());
          model.transform.transformPoints(ptsArray, ptsArray);
          const cellArray = new Uint16Array(8);
          cellArray[0] = 3;
          cellArray[1] = 0;
          cellArray[2] = 1;
          cellArray[3] = 3;
          cellArray[4] = 3;
          cellArray[5] = 0;
          cellArray[6] = 3;
          cellArray[7] = 2;
          const n = slicePlane.getNormal();
          Core_Math.f.normalize(n);
          const normalsData = new Float32Array(12);
          for (let i = 0; i < 4; ++i) {
            normalsData[3 * i] = n[0];
            normalsData[3 * i + 1] = n[1];
            normalsData[3 * i + 2] = n[2];
          }
          if (!model.resliceGeom) {
            model.resliceGeom = PolyData/* default.newInstance */.Ay.newInstance();
          }
          model.resliceGeom.getPoints().setData(ptsArray, 3);
          model.resliceGeom.getPolys().setData(cellArray, 1);
          const normals = DataArray/* default.newInstance */.Ay.newInstance({
            numberOfComponents: 3,
            values: normalsData,
            name: 'Normals'
          });
          model.resliceGeom.getPointData().setNormals(normals);
        }
      } else {
        ImageResliceMapper_vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');
      }
      model.resliceGeomUpdateString = resGeomString;
      model.resliceGeom?.modified();
    }
  };
  publicAPI.setOpenGLTexture = oglTex => {
    if (oglTex) {
      model.openGLTexture = oglTex;
      model._externalOpenGLTexture = true;
    }
  };
  publicAPI.delete = (0,macros2.h)(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageResliceMapper_DEFAULT_VALUES = {
  VBOBuildTime: {},
  VBOBuildString: null,
  haveSeenDepthRequest: false,
  lastHaveSeenDepthRequest: false,
  lastIndependentComponents: false,
  lastTextureComponents: 0,
  lastSlabThickness: 0,
  lastSlabTrapezoidIntegration: 0,
  lastSlabType: -1,
  openGLTexture: null,
  colorTextureString: null,
  pwfTextureString: null,
  resliceGeom: null,
  resliceGeomUpdateString: null,
  tris: null,
  colorTexture: null,
  pwfTexture: null,
  _externalOpenGLTexture: false
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
};

// ----------------------------------------------------------------------------

function ImageResliceMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageResliceMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.openGLTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime);
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // Implicit plane to polydata related cache:
  model.outlineFilter = vtkImageDataOutlineFilter$1.newInstance();
  model.outlineFilter.setGenerateFaces(true);
  model.outlineFilter.setGenerateLines(false);
  model.cubePolyData = PolyData/* default.newInstance */.Ay.newInstance();
  model.cutter = Cutter/* default.newInstance */.Ay.newInstance();
  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter$1.newInstance();
  model.transform = vtkTransform$1.newInstance();
  (0,macros2.g)(publicAPI, model, ['openGLTexture']);

  // Object methods
  vtkOpenGLImageResliceMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageResliceMapper_newInstance = (0,macros2.n)(ImageResliceMapper_extend, 'vtkOpenGLImageResliceMapper');

// ----------------------------------------------------------------------------

var vtkImageResliceMapper = {
  newInstance: ImageResliceMapper_newInstance,
  extend: ImageResliceMapper_extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkImageResliceMapper', ImageResliceMapper_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var ImageMapper = __webpack_require__(6814);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js + 1 modules
var ImageCPRMapper = __webpack_require__(82967);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
var ImageSlice = __webpack_require__(64501);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
var Volume = __webpack_require__(8126);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js + 2 modules
var VolumeMapper = __webpack_require__(95785);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper = __webpack_require__(68464);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
var WebGPU_Camera = __webpack_require__(26910);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js + 1 modules
var WebGPU_Renderer = __webpack_require__(24210);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var ImageMapper_Constants = __webpack_require__(94520);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
var FullScreenQuad = __webpack_require__(94363);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
var Sampler = __webpack_require__(20461);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var WebGPU_ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js










// const { vtkErrorMacro } = macro;
const {
  SlicingMode
} = ImageMapper_Constants/* default */.A;
const imgFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function computeFnToString(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return '0';
}

// ----------------------------------------------------------------------------
// vtkWebGPUImageMapper methods
// ----------------------------------------------------------------------------

const tmpMat4 = new Float64Array(16);
const tmp2Mat4 = new Float64Array(16);
const tmp3Mat4 = new Float64Array(16);
const ptsArray1 = new Float64Array(4);
const ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUImageMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      const ren = model.WebGPURenderer.getRenderable();
      // is slice set by the camera
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = () => {
    const ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = 'img2';
    } else {
      model.dimensions = 3;
      model.pipelineHash = 'img3';
    }
  };
  publicAPI.updateUBO = () => {
    const utime = model.UBO.getSendTime();
    const actor = model.WebGPUImageSlice.getRenderable();
    const volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      // compute the SCTCMatrix
      const image = volMapr.getInputData();
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      esm/* mat4.identity */.pB.identity(tmpMat4);
      esm/* mat4.translate */.pB.translate(tmpMat4, tmpMat4, center);
      // tmpMat4 is now SC->World

      const mcwcmat = actor.getMatrix();
      esm/* mat4.transpose */.pB.transpose(tmp2Mat4, mcwcmat);
      esm/* mat4.invert */.pB.invert(tmp2Mat4, tmp2Mat4);
      // tmp2Mat4 is now world to model

      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      // tmp4Mat is now SC->Model

      // the method on the data is world to index but the volume is in
      // model coordinates so really in this context it is model to index
      const modelToIndex = image.getWorldToIndex();
      esm/* mat4.multiply */.pB.multiply(tmpMat4, modelToIndex, tmpMat4);
      // tmpMat4 is now SC -> Index, save this as we need it later
      esm/* mat4.invert */.pB.invert(tmp3Mat4, tmpMat4);

      // need translation and scale
      esm/* mat4.fromTranslation */.pB.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      const dims = image.getDimensions();
      esm/* mat4.identity */.pB.identity(tmp2Mat4);
      esm/* mat4.scale */.pB.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);
      esm/* mat4.multiply */.pB.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      // tmpMat4 is now SC -> Tcoord

      model.UBO.setArray('SCTCMatrix', tmpMat4);

      // need to compute the plane here in world coordinates
      // then pass that down in the UBO
      const ext = model.currentInput.getExtent();

      // Find what IJK axis and what direction to slice along
      const {
        ijkMode
      } = model.renderable.getClosestIJKAxis();

      // Find the IJK slice
      let nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        // If not IJK slicing, get the IJK slice from the XYZ position/slice
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      let axis0 = 2;
      let axis1 = 0;
      let axis2 = 1;
      if (ijkMode === SlicingMode.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray('Origin', ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      esm/* vec4.subtract */.ln.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1.0;
      model.UBO.setArray('Axis1', ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1.0;
      esm/* vec4.transformMat4 */.ln.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      esm/* vec4.subtract */.ln.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1.0;
      model.UBO.setArray('Axis2', ptsArray2);

      // three levels of shift scale combined into one
      // for performance in the fragment shader
      const cScale = [1, 1, 1, 1];
      const cShift = [0, 0, 0, 0];
      const tView = model.textureViews[0];
      const tScale = tView.getTexture().getScale();
      const numComp = tView.getTexture().getNumberOfComponents();
      for (let i = 0; i < numComp; i++) {
        let cw = actor.getProperty().getColorWindow();
        let cl = actor.getProperty().getColorLevel();
        const target = 0;
        const cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          const cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray('cScale', cScale);
      model.UBO.setArray('cShift', cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = () => {
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    const numIComps = 1;
    const cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(model.rowLength * 3);
        for (let c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (let i = 0; i < model.rowLength; i++) {
              const idx = c * model.rowLength * 8 + i * 4;
              colorArray[idx] = 255.0 * tmpTable[i * 3];
              colorArray[idx + 1] = 255.0 * tmpTable[i * 3 + 1];
              colorArray[idx + 2] = 255.0 * tmpTable[i * 3 + 2];
              colorArray[idx + 3] = 255.0;
              for (let j = 0; j < 4; j++) {
                colorArray[idx + model.rowLength * 4 + j] = colorArray[idx + j];
              }
            }
          }
        }
      } else {
        for (let i = 0; i < model.rowLength; ++i) {
          const grey = 255.0 * i / (model.rowLength - 1);
          colorArray[i * 4] = grey;
          colorArray[i * 4 + 1] = grey;
          colorArray[i * 4 + 2] = grey;
          colorArray[i * 4 + 3] = 255.0;
          for (let j = 0; j < 4; j++) {
            colorArray[i * 4 + model.rowLength * 4 + j] = colorArray[i * 4 + j];
          }
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: 'rgba8unorm'
        };
        const newTex = model.device.getTextureManager().getTexture(treq);
        const tview = newTex.createView('tfunTexture');
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  const superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = () => {
    superClassUpdateBuffers();
    const newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    const tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      const tview = newTex.createView('imgTexture');
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();

    // set interpolation on the texture based on property setting
    const actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    const iType = actorProperty.getInterpolationType() === ImageProperty_Constants/* InterpolationType */.V.NEAREST ? 'nearest' : 'linear';
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = Sampler/* default.newInstance */.Ay.newInstance({
        label: 'clampSampler'
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  const sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    let code = vDesc.getCode();
    const lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];
    if (model.dimensions === 2) {
      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');
    } else {
      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');
    }
    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', lines).result;
    vDesc.setCode(code);
  };
  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    if (model.dimensions === 2) {
      vDesc.addOutput('vec2<f32>', 'tcoordVS');
    } else {
      vDesc.addOutput('vec3<f32>', 'tcoordVS');
    }
  };
  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = (hash, pipeline, vertexInput) => {
    const fDesc = pipeline.getShaderDescription('fragment');
    let code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    } else {
      code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var computedColor: vec4<f32> =`, `      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);`, `//VTK::Image::Sample`]).result;
    }
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Image::Sample', [`    var coord: vec2<f32> =`, `      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);`, `    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);`]).result;
    fDesc.setCode(code);
  };
  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageMapper_DEFAULT_VALUES = {
  rowLength: 1024
};

// ----------------------------------------------------------------------------

function ImageMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  FullScreenQuad/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'mapperUBO'
  });
  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('Origin', 'vec4<f32>');
  model.UBO.addEntry('Axis2', 'vec4<f32>');
  model.UBO.addEntry('Axis1', 'vec4<f32>');
  model.UBO.addEntry('cScale', 'vec4<f32>');
  model.UBO.addEntry('cShift', 'vec4<f32>');
  model.lutBuildTime = {};
  (0,macros2.o)(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.imagematinv = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime);

  // Object methods
  vtkWebGPUImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageMapper_newInstance = (0,macros2.n)(ImageMapper_extend, 'vtkWebGPUImageMapper');

// ----------------------------------------------------------------------------

var index = {
  newInstance: ImageMapper_newInstance,
  extend: ImageMapper_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkImageMapper', ImageMapper_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js





// ----------------------------------------------------------------------------
// vtkWebGPUImageSlice methods
// ----------------------------------------------------------------------------

function vtkWebGPUImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUImageSlice');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = wgpuRen => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift
      const center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        esm/* mat4.identity */.pB.identity(model.keyMatrices.normalMatrix);
      } else {
        // we use bcwc BEFORE the translate below (just to get transposed mcvc)
        esm/* mat4.copy */.pB.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        // zero out translation
        model.keyMatrices.normalMatrix[3] = 0.0;
        model.keyMatrices.normalMatrix[7] = 0.0;
        model.keyMatrices.normalMatrix[11] = 0.0;
        esm/* mat4.invert */.pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        esm/* mat4.transpose */.pB.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }

      // only meed the buffer shift to get to world
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

      // to get to stabilized we also need the center
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ImageSlice_DEFAULT_VALUES = {
  bufferShift: undefined,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: undefined
};

// ----------------------------------------------------------------------------

function ImageSlice_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ImageSlice_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  (0,macros2.o)(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  (0,macros2.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: esm/* mat4.identity */.pB.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  (0,macros2.g)(publicAPI, model, ['propID', 'keyMatricesTime']);

  // Object methods
  vtkWebGPUImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ImageSlice_newInstance = (0,macros2.n)(ImageSlice_extend, 'vtkWebGPUImageSlice');

// ----------------------------------------------------------------------------

var ImageSlice_index = {
  newInstance: ImageSlice_newInstance,
  extend: ImageSlice_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkImageSlice', ImageSlice_newInstance);



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js





// ----------------------------------------------------------------------------
// vtkWebGPUVolume methods
// ----------------------------------------------------------------------------

function vtkWebGPUVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUVolume');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
      // for the future if we support hardware selection of volumes
      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }

      // Check for the special case when the mapper's bounds are unknown
      const bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };

  // used in the method below
  const idx = new Float64Array(3);
  const vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = (result, offset) => {
    const input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    const extent = input.getExtent();
    const m = model.renderable.getMatrix();
    let count = 0;
    for (let iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (let iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (let ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          let poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = wgpuRen => {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();

      // compute the net shift
      const center = wgpuRen.getStabilizedCenterByReference();
      esm/* mat4.transpose */.pB.transpose(model.keyMatrices.bcwc, mcwc);

      // to get to stabilized we also need the center
      esm/* mat4.translate */.pB.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Volume_DEFAULT_VALUES = {
  propID: undefined,
  keyMatricesTime: null
};

// ----------------------------------------------------------------------------

function Volume_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Volume_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macros2.m.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macros2.m.get(publicAPI, model, ['propID', 'keyMatricesTime']);

  // Object methods
  vtkWebGPUVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Volume_newInstance = macros2.m.newInstance(Volume_extend, 'vtkWebGPUVolume');

// ----------------------------------------------------------------------------

var Volume_index = {
  newInstance: Volume_newInstance,
  extend: Volume_extend
};

// Register ourself to WebGPU backend if imported
(0,WebGPU_ViewNodeFactory/* registerOverride */.c9)('vtkVolume', Volume_newInstance);



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
var WebGPU_PixelSpaceCallbackMapper = __webpack_require__(77489);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Profiles/Volume.js
















// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ImageVolume.js
var ImageVolume = __webpack_require__(86252);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var cache = __webpack_require__(49038);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events = __webpack_require__(32643);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var eventTarget = __webpack_require__(10364);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
var triggerEvent = __webpack_require__(69372);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/uuidv4.js
var uuidv4 = __webpack_require__(80221);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/VoxelManager.js
var VoxelManager = __webpack_require__(24623);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js
var imageLoader = __webpack_require__(80068);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/utilities/generateVolumePropsFromImageIds.js
var generateVolumePropsFromImageIds = __webpack_require__(9734);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/cornerstoneStreamingImageVolumeLoader.js
var cornerstoneStreamingImageVolumeLoader = __webpack_require__(55500);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js











const volumeLoaders = {};
let unknownVolumeLoader = cornerstoneStreamingImageVolumeLoader/* cornerstoneStreamingImageVolumeLoader */.F;
function loadVolumeFromVolumeLoader(volumeId, options) {
    const colonIndex = volumeId.indexOf(':');
    const scheme = volumeId.substring(0, colonIndex);
    let loader = volumeLoaders[scheme];
    if (loader === undefined || loader === null) {
        if (unknownVolumeLoader == null ||
            typeof unknownVolumeLoader !== 'function') {
            throw new Error(`No volume loader for scheme ${scheme} has been registered`);
        }
        loader = unknownVolumeLoader;
    }
    const volumeLoadObject = loader(volumeId, options);
    volumeLoadObject.promise.then(function (volume) {
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.VOLUME_LOADED, { volume });
    }, function (error) {
        const errorObject = {
            volumeId,
            error,
        };
        (0,triggerEvent/* default */.A)(eventTarget/* default */.A, Events/* default */.A.VOLUME_LOADED_FAILED, errorObject);
    });
    return volumeLoadObject;
}
function loadVolume(volumeId, options = { imageIds: [] }) {
    if (volumeId === undefined) {
        throw new Error('loadVolume: parameter volumeId must not be undefined');
    }
    let volumeLoadObject = cache/* default */.Ay.getVolumeLoadObject(volumeId);
    if (volumeLoadObject !== undefined) {
        return volumeLoadObject.promise;
    }
    volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);
    return volumeLoadObject.promise.then((volume) => {
        return volume;
    });
}
async function createAndCacheVolume(volumeId, options) {
    if (volumeId === undefined) {
        throw new Error('createAndCacheVolume: parameter volumeId must not be undefined');
    }
    let volumeLoadObject = cache/* default */.Ay.getVolumeLoadObject(volumeId);
    if (volumeLoadObject !== undefined) {
        return volumeLoadObject.promise;
    }
    volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);
    cache/* default */.Ay.putVolumeLoadObject(volumeId, volumeLoadObject);
    return volumeLoadObject.promise;
}
function createAndCacheDerivedVolume(referencedVolumeId, options) {
    const referencedVolume = cache/* default */.Ay.getVolume(referencedVolumeId);
    if (!referencedVolume) {
        throw new Error(`Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`);
    }
    let { volumeId } = options;
    const { voxelRepresentation } = options;
    if (volumeId === undefined) {
        volumeId = (0,uuidv4/* default */.A)();
    }
    const { metadata, dimensions, spacing, origin, direction } = referencedVolume;
    const referencedImageIds = referencedVolume.isDynamicVolume()
        ? referencedVolume.getCurrentDimensionGroupImageIds()
        : referencedVolume.imageIds ?? [];
    const derivedImages = (0,imageLoader.createAndCacheDerivedImages)(referencedImageIds, {
        targetBuffer: options.targetBuffer,
        voxelRepresentation,
    });
    const dataType = derivedImages[0].dataType;
    const derivedVolumeImageIds = derivedImages.map((image) => image.imageId);
    const derivedVolume = new ImageVolume/* ImageVolume */.Q({
        volumeId,
        dataType,
        metadata: structuredClone(metadata),
        dimensions: [dimensions[0], dimensions[1], dimensions[2]],
        spacing,
        origin,
        direction,
        referencedVolumeId,
        imageIds: derivedVolumeImageIds,
        referencedImageIds: referencedVolume.imageIds ?? [],
    });
    cache/* default */.Ay.putVolumeSync(volumeId, derivedVolume);
    return derivedVolume;
}
async function createAndCacheVolumeFromImages(volumeId, imageIds) {
    if (imageIds === undefined) {
        throw new Error('createAndCacheVolumeFromImages: parameter imageIds must not be undefined');
    }
    if (volumeId === undefined) {
        throw new Error('createAndCacheVolumeFromImages: parameter volumeId must not be undefined');
    }
    const cachedVolume = cache/* default */.Ay.getVolume(volumeId);
    if (cachedVolume) {
        return cachedVolume;
    }
    const imageIdsToLoad = imageIds.filter((imageId) => !cache/* default */.Ay.getImage(imageId));
    if (imageIdsToLoad.length === 0) {
        return createAndCacheVolumeFromImagesSync(volumeId, imageIds);
    }
    const volume = (await createAndCacheVolume(volumeId, {
        imageIds,
    }));
    return volume;
}
function createAndCacheVolumeFromImagesSync(volumeId, imageIds) {
    if (imageIds === undefined) {
        throw new Error('createAndCacheVolumeFromImagesSync: parameter imageIds must not be undefined');
    }
    if (volumeId === undefined) {
        throw new Error('createAndCacheVolumeFromImagesSync: parameter volumeId must not be undefined');
    }
    const cachedVolume = cache/* default */.Ay.getVolume(volumeId);
    if (cachedVolume) {
        return cachedVolume;
    }
    const volumeProps = (0,generateVolumePropsFromImageIds/* generateVolumePropsFromImageIds */.D)(imageIds, volumeId);
    const derivedVolume = new ImageVolume/* ImageVolume */.Q({
        volumeId,
        dataType: volumeProps.dataType,
        metadata: structuredClone(volumeProps.metadata),
        dimensions: volumeProps.dimensions,
        spacing: volumeProps.spacing,
        origin: volumeProps.origin,
        direction: volumeProps.direction,
        referencedVolumeId: volumeProps.referencedVolumeId,
        imageIds: volumeProps.imageIds,
        referencedImageIds: volumeProps.referencedImageIds,
    });
    cache/* default */.Ay.putVolumeSync(volumeId, derivedVolume);
    return derivedVolume;
}
function createLocalVolume(volumeId, options = {}) {
    const { metadata, dimensions, spacing, origin, direction, scalarData, targetBuffer, preventCache = false, } = options;
    const cachedVolume = cache/* default */.Ay.getVolume(volumeId);
    if (cachedVolume) {
        return cachedVolume;
    }
    const sliceLength = dimensions[0] * dimensions[1];
    const dataType = scalarData
        ? scalarData.constructor.name
        : targetBuffer?.type ?? 'Float32Array';
    const totalNumberOfVoxels = sliceLength * dimensions[2];
    let byteLength;
    switch (dataType) {
        case 'Uint8Array':
        case 'Int8Array':
            byteLength = totalNumberOfVoxels;
            break;
        case 'Uint16Array':
        case 'Int16Array':
            byteLength = totalNumberOfVoxels * 2;
            break;
        case 'Float32Array':
            byteLength = totalNumberOfVoxels * 4;
            break;
    }
    const isCacheable = cache/* default */.Ay.isCacheable(byteLength);
    if (!isCacheable) {
        throw new Error(`Cannot created derived volume: Volume with id ${volumeId} is not cacheable.`);
    }
    const imageIds = [];
    const derivedImages = [];
    for (let i = 0; i < dimensions[2]; i++) {
        const imageId = `${volumeId}_slice_${i}`;
        imageIds.push(imageId);
        const sliceData = scalarData.subarray(i * sliceLength, (i + 1) * sliceLength);
        const derivedImage = (0,imageLoader.createAndCacheLocalImage)(imageId, {
            scalarData: sliceData,
            dimensions: [dimensions[0], dimensions[1]],
            spacing: [spacing[0], spacing[1]],
            origin,
            direction,
            targetBuffer: { type: dataType },
        });
        derivedImages.push(derivedImage);
    }
    const imageVolume = new ImageVolume/* ImageVolume */.Q({
        volumeId,
        metadata: structuredClone(metadata),
        dimensions: [dimensions[0], dimensions[1], dimensions[2]],
        spacing,
        origin,
        direction,
        imageIds,
        dataType,
    });
    const voxelManager = VoxelManager/* default */.A.createImageVolumeVoxelManager({
        imageIds,
        dimensions,
        numberOfComponents: 1,
        id: volumeId,
    });
    imageVolume.voxelManager = voxelManager;
    if (!preventCache) {
        cache/* default */.Ay.putVolumeSync(volumeId, imageVolume);
    }
    return imageVolume;
}
function registerVolumeLoader(scheme, volumeLoader) {
    volumeLoaders[scheme] = volumeLoader;
}
function getVolumeLoaderSchemes() {
    return Object.keys(volumeLoaders);
}
function registerUnknownVolumeLoader(volumeLoader) {
    const oldVolumeLoader = unknownVolumeLoader;
    unknownVolumeLoader = volumeLoader;
    return oldVolumeLoader;
}
function getUnknownVolumeLoaderSchema() {
    return unknownVolumeLoader.name;
}
function createAndCacheDerivedLabelmapVolume(referencedVolumeId, options = {}) {
    return createAndCacheDerivedVolume(referencedVolumeId, {
        ...options,
        targetBuffer: {
            type: 'Uint8Array',
            ...options?.targetBuffer,
        },
    });
}
function createLocalLabelmapVolume(options, volumeId, preventCache = false) {
    if (!options.scalarData) {
        options.scalarData = new Uint8Array(options.dimensions[0] * options.dimensions[1] * options.dimensions[2]);
    }
    return createLocalVolume(volumeId, { ...options, preventCache });
}


/***/ }),

/***/ 74876:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addProvider: () => (/* binding */ addProvider),
/* harmony export */   get: () => (/* binding */ getMetaData),
/* harmony export */   removeAllProviders: () => (/* binding */ removeAllProviders),
/* harmony export */   removeProvider: () => (/* binding */ removeProvider)
/* harmony export */ });
const providers = [];
function addProvider(provider, priority = 0) {
    let i;
    for (i = 0; i < providers.length; i++) {
        if (providers[i].priority <= priority) {
            break;
        }
    }
    providers.splice(i, 0, {
        priority,
        provider,
    });
}
function removeProvider(provider) {
    for (let i = 0; i < providers.length; i++) {
        if (providers[i].provider === provider) {
            providers.splice(i, 1);
            break;
        }
    }
}
function removeAllProviders() {
    while (providers.length > 0) {
        providers.pop();
    }
}
function getMetaData(type, ...queries) {
    for (let i = 0; i < providers.length; i++) {
        const result = providers[i].provider(type, ...queries);
        if (result !== undefined) {
            return result;
        }
    }
}



/***/ }),

/***/ 51159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24743);
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43213);


const imageLoadPoolManager = new _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__/* .RequestPoolManager */ .R('imageLoadPool');
imageLoadPoolManager.grabDelay = 0;
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Interaction, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Thumbnail, 1000);
imageLoadPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Prefetch, 1000);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageLoadPoolManager);


/***/ }),

/***/ 91073:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24743);
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43213);


const imageRetrievalPoolManager = new _requestPoolManager__WEBPACK_IMPORTED_MODULE_0__/* .RequestPoolManager */ .R('imageRetrievalPool');
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Interaction, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Thumbnail, 200);
imageRetrievalPoolManager.setMaxSimultaneousRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Prefetch, 200);
imageRetrievalPoolManager.grabDelay = 0;
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (imageRetrievalPoolManager)));


/***/ }),

/***/ 24743:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ RequestPoolManager)
/* harmony export */ });
/* harmony import */ var _enums_RequestType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43213);
/* harmony import */ var _utilities_uuidv4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80221);


class RequestPoolManager {
    constructor(id) {
        this.numRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 0,
        };
        this.id = id ? id : (0,_utilities_uuidv4__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)();
        this.requestPool = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: { 0: [] },
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: { 0: [] },
        };
        this.grabDelay = 5;
        this.awake = false;
        this.numRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 0,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 0,
        };
        this.maxNumRequests = {
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction]: 6,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail]: 6,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch]: 5,
            [_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute]: 1000,
        };
    }
    setMaxSimultaneousRequests(type, maxNumRequests) {
        this.maxNumRequests[type] = maxNumRequests;
    }
    getMaxSimultaneousRequests(type) {
        return this.maxNumRequests[type];
    }
    destroy() {
        if (this.timeoutHandle) {
            window.clearTimeout(this.timeoutHandle);
        }
    }
    addRequest(requestFn, type, additionalDetails, priority = 0) {
        const requestDetails = {
            requestFn,
            type,
            additionalDetails,
        };
        if (this.requestPool[type][priority] === undefined) {
            this.requestPool[type][priority] = [];
        }
        this.requestPool[type][priority].push(requestDetails);
        this.startGrabbing();
    }
    filterRequests(filterFunction) {
        Object.keys(this.requestPool).forEach((type) => {
            const requestType = this.requestPool[type];
            Object.keys(requestType).forEach((priority) => {
                requestType[priority] = requestType[priority].filter((requestDetails) => {
                    return filterFunction(requestDetails);
                });
            });
        });
    }
    clearRequestStack(type) {
        if (!this.requestPool[type]) {
            throw new Error(`No category for the type ${type} found`);
        }
        this.requestPool[type] = { 0: [] };
    }
    sendRequests(type) {
        const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];
        let syncImageCount = 0;
        for (let i = 0; i < requestsToSend; i++) {
            const requestDetails = this.getNextRequest(type);
            if (requestDetails === null) {
                return false;
            }
            else if (requestDetails) {
                this.numRequests[type]++;
                this.awake = true;
                let requestResult;
                try {
                    requestResult = requestDetails.requestFn();
                }
                catch (e) {
                    console.warn('sendRequest failed', e);
                }
                if (requestResult?.finally) {
                    requestResult.finally(() => {
                        this.numRequests[type]--;
                        this.startAgain();
                    });
                }
                else {
                    this.numRequests[type]--;
                    syncImageCount++;
                }
            }
        }
        if (syncImageCount) {
            this.startAgain();
        }
        return true;
    }
    getNextRequest(type) {
        const interactionPriorities = this.getSortedPriorityGroups(type);
        for (const priority of interactionPriorities) {
            if (this.requestPool[type][priority].length) {
                return this.requestPool[type][priority].shift();
            }
        }
        return null;
    }
    startGrabbing() {
        const hasRemainingInteractionRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Interaction);
        const hasRemainingThumbnailRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Thumbnail);
        const hasRemainingPrefetchRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Prefetch);
        const hasRemainingComputeRequests = this.sendRequests(_enums_RequestType__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.Compute);
        if (!hasRemainingInteractionRequests &&
            !hasRemainingThumbnailRequests &&
            !hasRemainingPrefetchRequests &&
            !hasRemainingComputeRequests) {
            this.awake = false;
        }
    }
    startAgain() {
        if (!this.awake) {
            return;
        }
        if (this.grabDelay !== undefined) {
            if (!this.timeoutHandle) {
                this.timeoutHandle = window.setTimeout(() => {
                    this.timeoutHandle = null;
                    this.startGrabbing();
                }, this.grabDelay);
            }
        }
        else {
            this.startGrabbing();
        }
    }
    getSortedPriorityGroups(type) {
        const priorities = Object.keys(this.requestPool[type])
            .map(Number)
            .filter((priority) => this.requestPool[type][priority].length)
            .sort((a, b) => a - b);
        return priorities;
    }
    getRequestPool() {
        return this.requestPool;
    }
}



/***/ }),

/***/ 24623:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ VoxelManager)
/* harmony export */ });
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49038);
/* harmony import */ var _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67645);
/* harmony import */ var _isEqual__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74638);
/* harmony import */ var _pointInShapeCallback__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56577);




const DEFAULT_RLE_SIZE = 5 * 1024;
class VoxelManager {
    get id() {
        return this._id;
    }
    constructor(dimensions, options) {
        this.modifiedSlices = new Set();
        this.boundsIJK = [
            [Infinity, -Infinity],
            [Infinity, -Infinity],
            [Infinity, -Infinity],
        ];
        this.scalarData = null;
        this._sliceDataCache = null;
        this.getAtIJK = (i, j, k) => {
            const index = this.toIndex([i, j, k]);
            return this._get(index);
        };
        this.setAtIJK = (i, j, k, v) => {
            const index = this.toIndex([i, j, k]);
            const changed = this._set(index, v);
            if (changed !== false) {
                this.modifiedSlices.add(k);
                VoxelManager.addBounds(this.boundsIJK, [i, j, k]);
            }
            return changed;
        };
        this.getAtIJKPoint = ([i, j, k]) => this.getAtIJK(i, j, k);
        this.setAtIJKPoint = ([i, j, k], v) => {
            this.setAtIJK(i, j, k, v);
        };
        this.getAtIndex = (index) => this._get(index);
        this.setAtIndex = (index, v) => {
            const changed = this._set(index, v);
            if (changed !== false) {
                const pointIJK = this.toIJK(index);
                this.modifiedSlices.add(pointIJK[2]);
                VoxelManager.addBounds(this.boundsIJK, pointIJK);
            }
            return changed;
        };
        this.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(this.dimensions[2] / 2);
            return this.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        this.forEach = (callback, options = {}) => {
            const isInObjectBoundsIJK = options.boundsIJK || this.getBoundsIJK();
            const isInObject = options.isInObject || this.isInObject || (() => true);
            const returnPoints = options.returnPoints || false;
            const useLPSTransform = options.imageData;
            const iMin = Math.min(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
            const iMax = Math.max(isInObjectBoundsIJK[0][0], isInObjectBoundsIJK[0][1]);
            const jMin = Math.min(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
            const jMax = Math.max(isInObjectBoundsIJK[1][0], isInObjectBoundsIJK[1][1]);
            const kMin = Math.min(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
            const kMax = Math.max(isInObjectBoundsIJK[2][0], isInObjectBoundsIJK[2][1]);
            const pointsInShape = [];
            if (useLPSTransform) {
                const pointsInShape = (0,_pointInShapeCallback__WEBPACK_IMPORTED_MODULE_3__/* .iterateOverPointsInShapeVoxelManager */ .X6)({
                    voxelManager: this,
                    imageData: options.imageData,
                    bounds: [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ],
                    pointInShapeFn: isInObject,
                    callback,
                    returnPoints,
                });
                return pointsInShape;
            }
            if (this.map) {
                if (this.map instanceof _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A) {
                    return this.rleForEach(callback, options);
                }
                for (const index of this.map.keys()) {
                    const pointIJK = this.toIJK(index);
                    if (!isInObject(null, pointIJK)) {
                        continue;
                    }
                    const value = this._get(index);
                    if (returnPoints) {
                        pointsInShape.push({
                            value,
                            index,
                            pointIJK,
                            pointLPS: null,
                        });
                    }
                    callback({ value, index, pointIJK, pointLPS: null });
                }
                return pointsInShape;
            }
            else {
                for (let k = kMin; k <= kMax; k++) {
                    const kIndex = k * this.frameSize;
                    for (let j = jMin; j <= jMax; j++) {
                        const jIndex = kIndex + j * this.width;
                        for (let i = iMin, index = jIndex + i; i <= iMax; i++, index++) {
                            const value = this.getAtIndex(index);
                            const pointIJK = [i, j, k];
                            if (!isInObject(null, pointIJK)) {
                                continue;
                            }
                            if (returnPoints) {
                                pointsInShape.push({
                                    value,
                                    index,
                                    pointIJK,
                                    pointLPS: null,
                                });
                            }
                            callback({ value, index, pointIJK: [i, j, k], pointLPS: null });
                        }
                    }
                }
                return pointsInShape;
            }
        };
        this.getSliceData = ({ sliceIndex, slicePlane, }) => {
            const [width, height, depth] = this.dimensions;
            const frameSize = width * height;
            const startIndex = sliceIndex * frameSize;
            let sliceSize;
            const SliceDataConstructor = this.getConstructor();
            function isValidConstructor(ctor) {
                return typeof ctor === 'function';
            }
            if (!isValidConstructor(SliceDataConstructor)) {
                return new Uint8Array(0);
            }
            let sliceData;
            switch (slicePlane) {
                case 0:
                    sliceSize = height * depth;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < height; i++) {
                        for (let j = 0; j < depth; j++) {
                            const index = sliceIndex + i * width + j * frameSize;
                            this.setSliceDataValue(sliceData, i * depth + j, this._get(index));
                        }
                    }
                    break;
                case 1:
                    sliceSize = width * depth;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < width; i++) {
                        for (let j = 0; j < depth; j++) {
                            const index = i + sliceIndex * width + j * frameSize;
                            this.setSliceDataValue(sliceData, i + j * width, this._get(index));
                        }
                    }
                    break;
                case 2:
                    sliceSize = width * height;
                    sliceData = new SliceDataConstructor(sliceSize);
                    for (let i = 0; i < sliceSize; i++) {
                        this.setSliceDataValue(sliceData, i, this._get(startIndex + i));
                    }
                    break;
                default:
                    throw new Error('Oblique plane - todo - implement as ortho normal vector');
            }
            return sliceData;
        };
        this.dimensions = dimensions;
        this.width = dimensions[0];
        this.frameSize = this.width * dimensions[1];
        this._get = options._get;
        this._set = options._set;
        this._id = options._id || '';
        this._getConstructor = options._getConstructor;
        this.numberOfComponents = this.numberOfComponents || 1;
        this.scalarData = options.scalarData;
        this._getScalarData = options._getScalarData;
        this._updateScalarData = options._updateScalarData;
    }
    getMinMax() {
        let min, max;
        const callback = ({ value: v }) => {
            const isArray = Array.isArray(v);
            if (min === undefined) {
                min = isArray ? [...v] : v;
                max = isArray ? [...v] : v;
            }
            if (isArray) {
                for (let i = 0; i < v.length; i++) {
                    min[i] = Math.min(min[i], v[i]);
                    max[i] = Math.max(max[i], v[i]);
                }
            }
            else {
                min = Math.min(min, v);
                max = Math.max(max, v);
            }
        };
        this.forEach(callback, { boundsIJK: this.getDefaultBounds() });
        return { min, max };
    }
    toIJK(index) {
        return [
            index % this.width,
            Math.floor((index % this.frameSize) / this.width),
            Math.floor(index / this.frameSize),
        ];
    }
    toIndex(ijk) {
        return ijk[0] + ijk[1] * this.width + ijk[2] * this.frameSize;
    }
    getDefaultBounds() {
        return this.dimensions.map((dimension) => [0, dimension - 1]);
    }
    getBoundsIJK() {
        if (this.boundsIJK[0][0] < this.dimensions[0]) {
            return this.boundsIJK;
        }
        return this.getDefaultBounds();
    }
    rleForEach(callback, options) {
        const boundsIJK = options?.boundsIJK || this.getBoundsIJK();
        const { isWithinObject } = options || {};
        const map = this.map;
        if (!map) {
            console.warn('No map found, you need to use a map voxel manager to use rleForEach');
            return;
        }
        map.defaultValue = undefined;
        for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {
            for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {
                const row = map.getRun(j, k);
                if (!row) {
                    continue;
                }
                for (const rle of row) {
                    const { start, end, value } = rle;
                    const baseIndex = this.toIndex([0, j, k]);
                    for (let i = start; i < end; i++) {
                        const callbackArguments = {
                            value,
                            index: baseIndex + i,
                            pointIJK: [i, j, k],
                        };
                        if (isWithinObject?.(callbackArguments) === false) {
                            continue;
                        }
                        callback(callbackArguments);
                    }
                }
            }
        }
    }
    getScalarData(storeScalarData = false) {
        if (this.scalarData) {
            this._updateScalarData?.(this.scalarData);
            return this.scalarData;
        }
        if (this._getScalarData) {
            const scalarData = this._getScalarData();
            if (storeScalarData) {
                console.log('Not transient, should store value', scalarData);
            }
            return scalarData;
        }
        throw new Error('No scalar data available');
    }
    setScalarData(newScalarData) {
        this.scalarData = newScalarData;
    }
    getScalarDataLength() {
        if (this.scalarData) {
            return this.scalarData.length;
        }
        if (this._getScalarDataLength) {
            return this._getScalarDataLength();
        }
        throw new Error('No scalar data available');
    }
    get sizeInBytes() {
        return this.getScalarDataLength() * this.bytePerVoxel;
    }
    get bytePerVoxel() {
        if (this.scalarData) {
            return this.scalarData.BYTES_PER_ELEMENT;
        }
        const value = this._get(0);
        return value.BYTES_PER_ELEMENT;
    }
    clearBounds() {
        this.boundsIJK.map((bound) => {
            bound[0] = Infinity;
            bound[1] = -Infinity;
        });
    }
    clear() {
        this.map?.clear();
        this.clearBounds();
        this.modifiedSlices.clear();
        this.points?.clear();
    }
    getConstructor() {
        if (this.scalarData) {
            return this.scalarData.constructor;
        }
        if (this._getConstructor) {
            return this._getConstructor();
        }
        console.warn('No scalar data available or can be used to get the constructor');
        return Float32Array;
    }
    getArrayOfModifiedSlices() {
        return Array.from(this.modifiedSlices);
    }
    resetModifiedSlices() {
        this.modifiedSlices.clear();
    }
    setBounds(bounds) {
        this.boundsIJK = bounds;
    }
    static addBounds(bounds, point) {
        if (!bounds) {
            bounds = [
                [Infinity, -Infinity],
                [Infinity, -Infinity],
                [Infinity, -Infinity],
            ];
        }
        bounds[0][0] = Math.min(point[0], bounds[0][0]);
        bounds[0][1] = Math.max(point[0], bounds[0][1]);
        bounds[1][0] = Math.min(point[1], bounds[1][0]);
        bounds[1][1] = Math.max(point[1], bounds[1][1]);
        bounds[2][0] = Math.min(point[2], bounds[2][0]);
        bounds[2][1] = Math.max(point[2], bounds[2][1]);
    }
    addPoint(point) {
        const index = Array.isArray(point)
            ? point[0] + this.width * point[1] + this.frameSize * point[2]
            : point;
        if (!this.points) {
            this.points = new Set();
        }
        this.points.add(index);
    }
    getPoints() {
        return this.points
            ? [...this.points].map((index) => this.toIJK(index))
            : [];
    }
    setSliceDataValue(sliceData, index, value) {
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                sliceData[index * value.length + i] = this.toNumber(value[i]);
            }
        }
        else {
            sliceData[index] = this.toNumber(value);
        }
    }
    toNumber(value) {
        if (typeof value === 'number') {
            return value;
        }
        if (Array.isArray(value)) {
            return value[0] || 0;
        }
        return 0;
    }
    static _createRGBScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents = 3, id, }) {
        const voxels = new VoxelManager(dimensions, {
            _get: (index) => {
                index *= numberOfComponents;
                return [
                    scalarData[index++],
                    scalarData[index++],
                    scalarData[index++],
                ];
            },
            _id: id || '_createRGBScalarVolumeVoxelManager',
            _set: (index, v) => {
                index *= 3;
                const isChanged = !(0,_isEqual__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay)(scalarData[index], v);
                scalarData[index++] = v[0];
                scalarData[index++] = v[1];
                scalarData[index++] = v[2];
                return isChanged;
            },
            numberOfComponents,
            scalarData,
        });
        voxels.clear = () => {
            scalarData.fill(0);
        };
        return voxels;
    }
    static createImageVolumeVoxelManager({ dimensions, imageIds, numberOfComponents = 1, id, }) {
        const pixelsPerSlice = dimensions[0] * dimensions[1];
        function getPixelInfo(index) {
            const sliceIndex = Math.floor(index / pixelsPerSlice);
            if (sliceIndex < 0 || sliceIndex >= dimensions[2]) {
                return {};
            }
            const imageId = imageIds[sliceIndex];
            if (!imageId) {
                console.warn(`ImageId not found for sliceIndex: ${sliceIndex}`);
                return { pixelData: null, pixelIndex: null };
            }
            const image = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImage(imageId);
            if (!image) {
                console.warn(`Image not found for imageId: ${imageId}`);
                return { pixelData: null, pixelIndex: null };
            }
            const voxelManager = image.voxelManager;
            const pixelIndex = index % pixelsPerSlice;
            return { voxelManager, pixelIndex };
        }
        function getVoxelValue(index) {
            const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(index);
            if (!imageVoxelManager || pixelIndex === null) {
                return null;
            }
            return imageVoxelManager.getAtIndex(pixelIndex);
        }
        function setVoxelValue(index, v) {
            const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(index);
            if (!imageVoxelManager || pixelIndex === null) {
                return false;
            }
            const currentValue = imageVoxelManager.getAtIndex(pixelIndex);
            const isChanged = !(0,_isEqual__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay)(v, currentValue);
            if (!isChanged) {
                return isChanged;
            }
            imageVoxelManager.setAtIndex(pixelIndex, v);
            return true;
        }
        const _getConstructor = () => {
            const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(0);
            if (!imageVoxelManager || pixelIndex === null) {
                return null;
            }
            return imageVoxelManager.getConstructor();
        };
        const voxelManager = new VoxelManager(dimensions, {
            _get: getVoxelValue,
            _set: setVoxelValue,
            numberOfComponents,
            _getConstructor,
            _id: id || 'createImageVolumeVoxelManager',
        });
        voxelManager.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            return voxelManager.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        voxelManager.clear = () => {
            for (const imageId of imageIds) {
                const image = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImage(imageId);
                image.voxelManager.clear();
            }
        };
        voxelManager.getRange = () => {
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (const imageId of imageIds) {
                const image = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImage(imageId);
                if (!image) {
                    continue;
                }
                if (image.minPixelValue < minValue) {
                    minValue = image.minPixelValue;
                }
                if (image.maxPixelValue > maxValue) {
                    maxValue = image.maxPixelValue;
                }
            }
            if (minValue === Infinity && maxValue === -Infinity) {
                return [0, 0];
            }
            return [minValue, maxValue];
        };
        voxelManager._getScalarDataLength = () => {
            const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo(0);
            if (!imageVoxelManager || pixelIndex === null) {
                return 0;
            }
            return imageVoxelManager.getScalarDataLength() * dimensions[2];
        };
        voxelManager.getCompleteScalarDataArray = () => {
            const ScalarDataConstructor = voxelManager._getConstructor();
            if (!ScalarDataConstructor) {
                return new Uint8Array(0);
            }
            const dataLength = voxelManager.getScalarDataLength();
            const scalarData = new ScalarDataConstructor(dataLength);
            const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
            for (let sliceIndex = 0; sliceIndex < dimensions[2]; sliceIndex++) {
                const { voxelManager: imageVoxelManager, pixelIndex } = getPixelInfo((sliceIndex * sliceSize) / numberOfComponents);
                if (imageVoxelManager && pixelIndex !== null) {
                    const sliceStart = sliceIndex * sliceSize;
                    const pixelData = imageVoxelManager.getScalarData();
                    if (numberOfComponents === 1) {
                        scalarData.set(pixelData, sliceStart);
                    }
                    else {
                        for (let i = 0; i < pixelData.length; i += numberOfComponents) {
                            for (let j = 0; j < numberOfComponents; j++) {
                                scalarData[sliceStart + i + j] = pixelData[i + j];
                            }
                        }
                    }
                }
            }
            return scalarData;
        };
        voxelManager.setCompleteScalarDataArray = (scalarData) => {
            const sliceSize = dimensions[0] * dimensions[1] * numberOfComponents;
            const SliceDataConstructor = voxelManager._getConstructor();
            let minValue = Infinity;
            let maxValue = -Infinity;
            for (let sliceIndex = 0; sliceIndex < dimensions[2]; sliceIndex++) {
                const { voxelManager: imageVoxelManager } = getPixelInfo((sliceIndex * sliceSize) / numberOfComponents);
                if (imageVoxelManager && SliceDataConstructor) {
                    const sliceStart = sliceIndex * sliceSize;
                    const sliceEnd = sliceStart + sliceSize;
                    const sliceData = new SliceDataConstructor(sliceSize);
                    sliceData.set(scalarData.subarray(sliceStart, sliceEnd));
                    if (imageVoxelManager.scalarData) {
                        imageVoxelManager.scalarData.set(sliceData);
                        imageVoxelManager.modifiedSlices.add(sliceIndex);
                    }
                    else {
                        for (let i = 0; i < sliceSize; i++) {
                            imageVoxelManager.setAtIndex(i, sliceData[i]);
                        }
                    }
                    for (let i = 0; i < sliceData.length; i++) {
                        const value = sliceData[i];
                        minValue = Math.min(minValue, value);
                        maxValue = Math.max(maxValue, value);
                    }
                    const imageId = imageIds[sliceIndex];
                    const image = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImage(imageId);
                    if (image) {
                        image.minPixelValue = minValue;
                        image.maxPixelValue = maxValue;
                    }
                }
            }
            for (let k = 0; k < dimensions[2]; k++) {
                voxelManager.modifiedSlices.add(k);
            }
            voxelManager.boundsIJK = [
                [0, dimensions[0] - 1],
                [0, dimensions[1] - 1],
                [0, dimensions[2] - 1],
            ];
        };
        return voxelManager;
    }
    static createScalarVolumeVoxelManager({ dimensions, scalarData, numberOfComponents, id, }) {
        if (dimensions.length !== 3) {
            throw new Error('Dimensions must be provided as [number, number, number] for [width, height, depth]');
        }
        if (!numberOfComponents) {
            numberOfComponents =
                scalarData.length / dimensions[0] / dimensions[1] / dimensions[2];
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        if (numberOfComponents > 1) {
            return VoxelManager._createRGBScalarVolumeVoxelManager({
                dimensions,
                scalarData,
                numberOfComponents,
                id,
            });
        }
        return VoxelManager._createNumberVolumeVoxelManager({
            dimensions,
            scalarData,
            id,
        });
    }
    static createScalarDynamicVolumeVoxelManager({ imageIdGroups, dimensions, dimensionGroupNumber = 1, timePoint = 0, numberOfComponents = 1, id, }) {
        let activeDimensionGroup = 0;
        if (dimensionGroupNumber !== undefined) {
            activeDimensionGroup = dimensionGroupNumber - 1;
        }
        else if (timePoint !== undefined) {
            console.warn('Warning: timePoint parameter is deprecated. Please use dimensionGroupNumber instead. timePoint is zero-based while dimensionGroupNumber starts at 1.');
            activeDimensionGroup = timePoint;
        }
        if (!numberOfComponents) {
            const firstImage = _cache_cache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay.getImage(imageIdGroups[0][0]);
            if (!firstImage) {
                throw new Error('Unable to determine number of components: No image found');
            }
            numberOfComponents =
                firstImage.getPixelData().length / (dimensions[0] * dimensions[1]);
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        const voxelGroups = imageIdGroups.map((imageIds) => {
            return VoxelManager.createImageVolumeVoxelManager({
                dimensions,
                imageIds,
                numberOfComponents,
                id,
            });
        });
        const voxelManager = new VoxelManager(dimensions, {
            _get: (index) => voxelGroups[activeDimensionGroup]._get(index),
            _set: (index, v) => voxelGroups[activeDimensionGroup]._set(index, v),
            numberOfComponents,
            _id: id || 'createScalarDynamicVolumeVoxelManager',
        });
        voxelManager.getScalarDataLength = () => {
            return voxelGroups[activeDimensionGroup].getScalarDataLength();
        };
        voxelManager.getConstructor = () => {
            return voxelGroups[activeDimensionGroup].getConstructor();
        };
        voxelManager.getRange = () => {
            return voxelGroups[activeDimensionGroup].getRange();
        };
        voxelManager.getMiddleSliceData = () => {
            return voxelGroups[activeDimensionGroup].getMiddleSliceData();
        };
        voxelManager.setTimePoint = (newTimePoint) => {
            console.warn('Warning: setTimePoint is deprecated. Please use setDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.');
            voxelManager.setDimensionGroupNumber(newTimePoint + 1);
        };
        voxelManager.setDimensionGroupNumber = (newDimensionGroupNumber) => {
            activeDimensionGroup = newDimensionGroupNumber - 1;
            voxelManager._get = (index) => voxelGroups[activeDimensionGroup]._get(index);
            voxelManager._set = (index, v) => voxelGroups[activeDimensionGroup]._set(index, v);
        };
        voxelManager.getAtIndexAndTimePoint = (index, tp) => {
            console.warn('Warning: getAtIndexAndTimePoint is deprecated. Please use getAtIndexAndDimensionGroup instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.');
            return voxelManager.getAtIndexAndDimensionGroup(index, tp + 1);
        };
        voxelManager.getAtIndexAndDimensionGroup = (index, dimensionGroupNumber) => {
            return voxelGroups[dimensionGroupNumber - 1]._get(index);
        };
        voxelManager.getTimePointScalarData = (tp) => {
            console.warn('Warning: getTimePointScalarData is deprecated. Please use getDimensionGroupScalarData instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.');
            return voxelManager.getDimensionGroupScalarData(tp + 1);
        };
        voxelManager.getDimensionGroupScalarData = (dimensionGroupNumber) => {
            return voxelGroups[dimensionGroupNumber - 1].getCompleteScalarDataArray();
        };
        voxelManager.getCurrentTimePointScalarData = () => {
            console.warn('Warning: getCurrentTimePointScalarData is deprecated. Please use getCurrentDimensionGroupScalarData instead.');
            return voxelManager.getCurrentDimensionGroupScalarData();
        };
        voxelManager.getCurrentDimensionGroupScalarData = () => {
            return voxelGroups[activeDimensionGroup].getCompleteScalarDataArray();
        };
        voxelManager.getCurrentTimePoint = () => {
            console.warn('Warning: getCurrentTimePoint is deprecated. Please use getCurrentDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1.');
            return activeDimensionGroup;
        };
        voxelManager.getCurrentDimensionGroupNumber = () => {
            return activeDimensionGroup + 1;
        };
        return voxelManager;
    }
    static createImageVoxelManager({ width, height, scalarData, numberOfComponents = 1, id, }) {
        const dimensions = [width, height, 1];
        if (!numberOfComponents) {
            numberOfComponents = scalarData.length / width / height;
            if (numberOfComponents > 4 ||
                numberOfComponents < 1 ||
                numberOfComponents === 2) {
                throw new Error(`Number of components ${numberOfComponents} must be 1, 3 or 4`);
            }
        }
        if (numberOfComponents > 1) {
            return VoxelManager._createRGBScalarVolumeVoxelManager({
                dimensions,
                scalarData,
                numberOfComponents,
                id,
            });
        }
        return VoxelManager._createNumberVolumeVoxelManager({
            dimensions,
            scalarData,
            id,
        });
    }
    static _createNumberVolumeVoxelManager({ dimensions, scalarData, id, }) {
        const voxels = new VoxelManager(dimensions, {
            _get: (index) => scalarData[index],
            _set: (index, v) => {
                const isChanged = scalarData[index] !== v;
                scalarData[index] = v;
                return isChanged;
            },
            _getConstructor: () => scalarData.constructor,
            _id: id || '_createNumberVolumeVoxelManager',
        });
        voxels.scalarData = scalarData;
        voxels.clear = () => {
            voxels.scalarData.fill(0);
        };
        voxels.getMiddleSliceData = () => {
            const middleSliceIndex = Math.floor(dimensions[2] / 2);
            return voxels.getSliceData({
                sliceIndex: middleSliceIndex,
                slicePlane: 2,
            });
        };
        return voxels;
    }
    static createMapVoxelManager({ dimension, id, }) {
        const map = new Map();
        const voxelManager = new VoxelManager(dimension, {
            _get: map.get.bind(map),
            _set: (index, v) => map.set(index, v) && true,
            _id: id || 'createMapVoxelManager',
        });
        voxelManager.map = map;
        return voxelManager;
    }
    static createHistoryVoxelManager(sourceVoxelManager, id) {
        const map = new Map();
        const { dimensions } = sourceVoxelManager;
        const voxelManager = new VoxelManager(dimensions, {
            _get: (index) => map.get(index),
            _set: function (index, v) {
                if (!map.has(index)) {
                    const oldV = this.sourceVoxelManager.getAtIndex(index);
                    if (oldV === v) {
                        return false;
                    }
                    map.set(index, oldV);
                }
                else if (v === map.get(index)) {
                    map.delete(index);
                }
                this.sourceVoxelManager.setAtIndex(index, v);
            },
            _id: id || 'createHistoryVoxelManager',
        });
        voxelManager.map = map;
        voxelManager.scalarData = sourceVoxelManager.scalarData;
        voxelManager.sourceVoxelManager = sourceVoxelManager;
        return voxelManager;
    }
    static createRLEHistoryVoxelManager(sourceVoxelManager, id) {
        const { dimensions } = sourceVoxelManager;
        const map = new _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(dimensions[0], dimensions[1], dimensions[2]);
        const voxelManager = new VoxelManager(dimensions, {
            _get: (index) => map.get(index),
            _set: function (index, v) {
                const originalV = map.get(index);
                if (originalV === undefined) {
                    const oldV = this.sourceVoxelManager.getAtIndex(index);
                    if (oldV === v || (oldV === undefined && v === 0) || v === null) {
                        return false;
                    }
                    map.set(index, oldV ?? 0);
                }
                else if (v === originalV || v === null) {
                    map.delete(index);
                    v = originalV;
                }
                this.sourceVoxelManager.setAtIndex(index, v);
            },
            _getScalarData: _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.getScalarData,
            _updateScalarData: (scalarData) => {
                map.updateScalarData(scalarData);
                return scalarData;
            },
            _id: id || 'createRLEHistoryVoxelManager',
        });
        voxelManager.map = map;
        voxelManager.sourceVoxelManager = sourceVoxelManager;
        return voxelManager;
    }
    static createLazyVoxelManager({ dimensions, planeFactory, id, }) {
        const map = new Map();
        const [width, height] = dimensions;
        const planeSize = width * height;
        const voxelManager = new VoxelManager(dimensions, {
            _get: (index) => map.get(Math.floor(index / planeSize))[index % planeSize],
            _set: (index, v) => {
                const k = Math.floor(index / planeSize);
                let layer = map.get(k);
                if (!layer) {
                    layer = planeFactory(width, height);
                    map.set(k, layer);
                }
                layer[index % planeSize] = v;
                return true;
            },
            _id: id || 'createLazyVoxelManager',
        });
        voxelManager.map = map;
        return voxelManager;
    }
    static createRLEVolumeVoxelManager({ dimensions, id, }) {
        const [width, height, depth] = dimensions;
        const map = new _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A(width, height, depth);
        const voxelManager = new VoxelManager(dimensions, {
            _get: (index) => map.get(index),
            _set: (index, v) => {
                map.set(index, v);
                return true;
            },
            _getScalarData: _RLEVoxelMap__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.getScalarData,
            _updateScalarData: (scalarData) => {
                map.updateScalarData(scalarData);
                return scalarData;
            },
            _id: id || 'createRLEVolumeVoxelManager',
        });
        voxelManager.map = map;
        voxelManager.getPixelData = map.getPixelData.bind(map);
        return voxelManager;
    }
    static createRLEImageVoxelManager({ dimensions, id, }) {
        const [width, height] = dimensions;
        return VoxelManager.createRLEVolumeVoxelManager({
            dimensions: [width, height, 1],
            id,
        });
    }
    static addInstanceToImage(image) {
        const { width, height } = image;
        const scalarData = image.voxelManager.getScalarData();
        if (scalarData.length >= width * height) {
            image.voxelManager = VoxelManager.createScalarVolumeVoxelManager({
                dimensions: [width, height, 1],
                scalarData,
            });
            return;
        }
        image.voxelManager = VoxelManager.createRLEVolumeVoxelManager({
            dimensions: [width, height, 1],
        });
        image.getPixelData = image.voxelManager.getPixelData;
        image.sizeInBytes = DEFAULT_RLE_SIZE;
    }
}


/***/ }),

/***/ 87784:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ createPositionCallback)
/* harmony export */ });
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9175);
/* harmony import */ var _PointsManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13876);


function createPositionCallback(imageData) {
    const currentPos = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.create();
    const dimensions = imageData.getDimensions();
    const positionI = _PointsManager__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.create3(dimensions[0]);
    const positionJ = _PointsManager__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.create3(dimensions[1]);
    const positionK = _PointsManager__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.create3(dimensions[2]);
    const direction = imageData.getDirection();
    const rowCosines = direction.slice(0, 3);
    const columnCosines = direction.slice(3, 6);
    const scanAxisNormal = direction.slice(6, 9);
    const spacing = imageData.getSpacing();
    const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;
    const worldPosStart = imageData.indexToWorld([0, 0, 0]);
    const rowStep = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.fromValues(rowCosines[0] * rowSpacing, rowCosines[1] * rowSpacing, rowCosines[2] * rowSpacing);
    const columnStep = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.fromValues(columnCosines[0] * columnSpacing, columnCosines[1] * columnSpacing, columnCosines[2] * columnSpacing);
    const scanAxisStep = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.fromValues(scanAxisNormal[0] * scanAxisSpacing, scanAxisNormal[1] * scanAxisSpacing, scanAxisNormal[2] * scanAxisSpacing);
    const scaled = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.create();
    for (let i = 0; i < dimensions[0]; i++) {
        positionI.push(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.add(scaled, worldPosStart, gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.scale(scaled, rowStep, i)));
    }
    for (let j = 0; j < dimensions[1]; j++) {
        positionJ.push(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.scale(scaled, columnStep, j));
    }
    for (let k = 0; k < dimensions[2]; k++) {
        positionK.push(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_0__.scale(scaled, scanAxisStep, k));
    }
    const dataI = positionI.getTypedArray();
    const dataJ = positionJ.getTypedArray();
    const dataK = positionK.getTypedArray();
    return (ijk, destPoint = currentPos) => {
        const [i, j, k] = ijk;
        const offsetI = i * 3;
        const offsetJ = j * 3;
        const offsetK = k * 3;
        destPoint[0] = dataI[offsetI] + dataJ[offsetJ] + dataK[offsetK];
        destPoint[1] = dataI[offsetI + 1] + dataJ[offsetJ + 1] + dataK[offsetK + 1];
        destPoint[2] = dataI[offsetI + 2] + dataJ[offsetJ + 2] + dataK[offsetK + 2];
        return destPoint;
    };
}


/***/ }),

/***/ 74268:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isMergeableObject = (val) => {
    const nonNullObject = val && typeof val === 'object';
    return (nonNullObject &&
        Object.prototype.toString.call(val) !== '[object RegExp]' &&
        Object.prototype.toString.call(val) !== '[object Date]');
};
const emptyTarget = (val) => {
    const isEmpty = Array.isArray(val) ? [] : {};
    return isEmpty;
};
const cloneIfNecessary = (value, optionsArgument) => {
    const clone = optionsArgument && optionsArgument.clone === true;
    return clone && isMergeableObject(value)
        ? deepMerge(emptyTarget(value), value, optionsArgument)
        : value;
};
const defaultArrayMerge = (target, source, optionsArgument) => {
    const destination = target.slice();
    source.forEach(function (e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        }
        else if (isMergeableObject(e)) {
            destination[i] = deepMerge(target[i], e, optionsArgument);
        }
        else if (target.indexOf(e) === -1) {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        }
    });
    return destination;
};
const mergeObject = (target, source, optionsArgument) => {
    const destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        }
        else {
            destination[key] = deepMerge(target[key], source[key], optionsArgument);
        }
    });
    return destination;
};
const deepMerge = (target = {}, source = {}, optionsArgument = undefined) => {
    const array = Array.isArray(source);
    const options = optionsArgument || { arrayMerge: defaultArrayMerge };
    const arrayMerge = options.arrayMerge || defaultArrayMerge;
    if (array) {
        return Array.isArray(target)
            ? arrayMerge(target, source, optionsArgument)
            : cloneIfNecessary(source, optionsArgument);
    }
    return mergeObject(target, source, optionsArgument);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepMerge);


/***/ }),

/***/ 9734:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ generateVolumePropsFromImageIds)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _makeVolumeMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1865);
/* harmony import */ var _sortImageIdsAndGetSpacing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90537);
/* harmony import */ var _getScalingParameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32173);
/* harmony import */ var _hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30169);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26896);
/* harmony import */ var _cache_cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(49038);







const constructorToTypedArray = {
    Uint8Array: 'Uint8Array',
    Int16Array: 'Int16Array',
    Uint16Array: 'Uint16Array',
    Float32Array: 'Float32Array',
};
function generateVolumePropsFromImageIds(imageIds, volumeId) {
    const volumeMetadata = (0,_makeVolumeMetadata__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(imageIds);
    const { ImageOrientationPatient, PixelSpacing, Columns, Rows } = volumeMetadata;
    const rowCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(ImageOrientationPatient[0], ImageOrientationPatient[1], ImageOrientationPatient[2]);
    const colCosineVec = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.fromValues */ .eR.fromValues(ImageOrientationPatient[3], ImageOrientationPatient[4], ImageOrientationPatient[5]);
    const scanAxisNormal = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.create */ .eR.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(scanAxisNormal, rowCosineVec, colCosineVec);
    const { zSpacing, origin, sortedImageIds } = (0,_sortImageIdsAndGetSpacing__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(imageIds, scanAxisNormal);
    const numFrames = imageIds.length;
    const spacing = [PixelSpacing[1], PixelSpacing[0], zSpacing];
    const dimensions = [Columns, Rows, numFrames].map((it) => Math.floor(it));
    const direction = [
        ...rowCosineVec,
        ...colCosineVec,
        ...scanAxisNormal,
    ];
    return {
        dimensions,
        spacing,
        origin,
        dataType: _determineDataType(sortedImageIds, volumeMetadata),
        direction,
        metadata: volumeMetadata,
        imageIds: sortedImageIds,
        volumeId,
        voxelManager: null,
        numberOfComponents: volumeMetadata.PhotometricInterpretation === 'RGB' ? 3 : 1,
    };
}
function _determineDataType(imageIds, volumeMetadata) {
    const { BitsAllocated, PixelRepresentation } = volumeMetadata;
    const signed = PixelRepresentation === 1;
    const cachedDataType = _getDataTypeFromCache(imageIds);
    if (cachedDataType) {
        return cachedDataType;
    }
    const [firstIndex, middleIndex, lastIndex] = [
        0,
        Math.floor(imageIds.length / 2),
        imageIds.length - 1,
    ];
    const scalingParameters = [firstIndex, middleIndex, lastIndex].map((index) => (0,_getScalingParameters__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(imageIds[index]));
    const hasNegativeRescale = scalingParameters.some((params) => params.rescaleIntercept < 0 || params.rescaleSlope < 0);
    const floatAfterScale = scalingParameters.some((params) => (0,_hasFloatScalingParameters__WEBPACK_IMPORTED_MODULE_4__/* .hasFloatScalingParameters */ .a)(params));
    const canRenderFloat = (0,_init__WEBPACK_IMPORTED_MODULE_5__/* .canRenderFloatTextures */ .lk)();
    switch (BitsAllocated) {
        case 8:
            return 'Uint8Array';
        case 16:
            if (canRenderFloat && floatAfterScale) {
                return 'Float32Array';
            }
            if (signed || hasNegativeRescale) {
                return 'Int16Array';
            }
            if (!signed && !hasNegativeRescale) {
                return 'Uint16Array';
            }
            return 'Float32Array';
        case 24:
            return 'Uint8Array';
        case 32:
            return 'Float32Array';
        default:
            throw new Error(`Bits allocated of ${BitsAllocated} is not defined to generate scalarData for the volume.`);
    }
}
function _getDataTypeFromCache(imageIds) {
    const indices = [0, Math.floor(imageIds.length / 2), imageIds.length - 1];
    const images = indices.map((i) => _cache_cache__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay.getImage(imageIds[i]));
    if (!images.every(Boolean)) {
        return null;
    }
    const constructorName = images[0].getPixelData().constructor.name;
    if (images.every((img) => img.getPixelData().constructor.name === constructorName) &&
        constructorName in constructorToTypedArray) {
        return constructorToTypedArray[constructorName];
    }
    return null;
}



/***/ }),

/***/ 27119:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _metaData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74876);

let state = {};
const metadataProvider = {
    add: (imageId, payload) => {
        metadataProvider.addRaw(imageId, {
            ...payload,
            metadata: structuredClone(payload.metadata),
        });
    },
    addRaw: (imageId, payload) => {
        const type = payload.type;
        if (!state[imageId]) {
            state[imageId] = {};
        }
        state[imageId][type] = payload.metadata;
    },
    get: (type, imageId) => {
        return state[imageId]?.[type];
    },
    clear: () => {
        state = {};
    },
};
(0,_metaData__WEBPACK_IMPORTED_MODULE_0__.addProvider)(metadataProvider.get);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (metadataProvider);


/***/ }),

/***/ 99576:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ getBufferConfiguration),
/* harmony export */   j: () => (/* binding */ getConstructorFromType)
/* harmony export */ });
function getConstructorFromType(bufferType, isVolumeBuffer) {
    switch (bufferType) {
        case 'Float32Array':
            return Float32Array;
        case 'Uint8Array':
            return Uint8Array;
        case 'Uint32Array':
            return Uint32Array;
        case 'Uint16Array':
        case 'Int16Array':
            if (!isVolumeBuffer) {
                return bufferType === 'Uint16Array' ? Uint16Array : Int16Array;
            }
            else {
                console.debug(`${bufferType} is not supported for volume rendering, switching back to Float32Array`);
                return Float32Array;
            }
        default:
            if (bufferType) {
                throw new Error('TargetBuffer should be Float32Array, Uint8Array, Uint16Array, Int16Array, or Uint32Array');
            }
            else {
                return Float32Array;
            }
    }
}
function getBufferConfiguration(targetBufferType, length, options = {}) {
    const { isVolumeBuffer = false } = options;
    const TypedArrayConstructor = getConstructorFromType(targetBufferType, isVolumeBuffer);
    const bytesPerElement = TypedArrayConstructor.BYTES_PER_ELEMENT;
    const numBytes = length * bytesPerElement;
    return { numBytes, TypedArrayConstructor };
}



/***/ }),

/***/ 58977:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ logit)
/* harmony export */ });
const logit = (y, wc, ww) => {
    return wc - (ww / 4) * Math.log((1 - y) / y);
};


/***/ }),

/***/ 69372:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ triggerEvent)
/* harmony export */ });
/* harmony import */ var _eventTarget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10364);

function triggerEvent(el = _eventTarget__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A, type, detail = null) {
    if (!type) {
        throw new Error('Event type was not defined');
    }
    const event = new CustomEvent(type, {
        detail,
        cancelable: true,
    });
    return el?.dispatchEvent(event);
}


/***/ }),

/***/ 80221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ uuidv4)
/* harmony export */ });
function uuidv4() {
    if (typeof crypto.randomUUID === 'function') {
        return crypto.randomUUID();
    }
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^
        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
}


/***/ }),

/***/ 36625:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qy: () => (/* binding */ getPolySeg),
/* harmony export */   zj: () => (/* binding */ getConfig)
/* harmony export */ });
/* unused harmony exports setConfig, getAddOns */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94021);


let config = {};
function getConfig() {
    return config;
}
function setConfig(newConfig) {
    config = newConfig;
}
function getAddOns() {
    return config.addons;
}
let polysegInitialized = false;
function getPolySeg() {
    if (!config.addons?.polySeg) {
        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');
        return null;
    }
    const polyseg = config.addons.polySeg;
    if (!polysegInitialized) {
        polyseg.init();
        polysegInitialized = true;
    }
    return polyseg;
}


/***/ }),

/***/ 94430:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MouseCursor),
/* harmony export */   i: () => (/* binding */ standardCursorNames)
/* harmony export */ });
const DEFINED_CURSORS = Symbol('DefinedCursors');
const STANDARD_CURSORS = new Set([
    'alias',
    'all-scroll',
    'auto',
    'cell',
    'col-resize',
    'context-menu',
    'copy',
    'crosshair',
    'default',
    'e-resize',
    'ew-resize',
    'grab',
    'grabbing',
    'help',
    'move',
    'ne-resize',
    'nesw-resize',
    'no-drop',
    'none',
    'not-allowed',
    'n-resize',
    'ns-resize',
    'nw-resize',
    'nwse-resize',
    'pointer',
    'progress',
    'row-resize',
    'se-resize',
    's-resize',
    'sw-resize',
    'text',
    'vertical-text',
    'wait',
    'w-resize',
    'zoom-in',
    'zoom-out',
]);
class MouseCursor {
    constructor(name, fallback) {
        this.name = name + '';
        this.fallback = fallback;
    }
    getName() {
        return this.name + '';
    }
    addFallbackStyleProperty(style) {
        const { fallback } = this;
        if (fallback instanceof MouseCursor) {
            return `${style}, ${fallback.getStyleProperty()}`;
        }
        return style + '';
    }
    getStyleProperty() {
        return this.addFallbackStyleProperty(this.name) + '';
    }
    static getDefinedCursor(name) {
        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
        let mouseCursor = definedCursors.get(name);
        if (mouseCursor instanceof MouseCursor) {
            return mouseCursor;
        }
        if (STANDARD_CURSORS.has(name)) {
            mouseCursor = new MouseCursor(name);
            definedCursors.set(name, mouseCursor);
            return mouseCursor;
        }
    }
    static setDefinedCursor(name, cursor) {
        if (cursor instanceof MouseCursor) {
            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);
            definedCursors.set(name, cursor);
            return true;
        }
        return false;
    }
}
function getDefinedCursors(context, symbol) {
    let definedCursors = context[symbol];
    if (!(definedCursors instanceof Map)) {
        definedCursors = new Map();
        Object.defineProperty(context, symbol, { value: definedCursors });
    }
    return definedCursors;
}
const standardCursorNames = STANDARD_CURSORS.values();



/***/ }),

/***/ 7001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hideElementCursor: () => (/* binding */ hideElementCursor),
/* harmony export */   resetElementCursor: () => (/* binding */ resetElementCursor)
/* harmony export */ });
/* unused harmony exports initElementCursor, setElementCursor */
/* harmony import */ var _MouseCursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94430);

const ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');
function initElementCursor(element, cursor) {
    _getElementCursors(element)[0] = cursor;
    _setElementCursor(element, cursor);
}
function _setElementCursor(element, cursor) {
    const cursors = _getElementCursors(element);
    cursors[1] = cursors[0];
    cursors[0] = cursor;
    element.style.cursor = (cursor instanceof _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A
        ? cursor
        : _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('auto')).getStyleProperty();
}
function resetElementCursor(element) {
    _setElementCursor(element, _getElementCursors(element)[1]);
}
function hideElementCursor(element) {
    _setElementCursor(element, _MouseCursor__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getDefinedCursor('none'));
}
function _getElementCursors(element) {
    let map = _getElementCursors[ELEMENT_CURSORS_MAP];
    if (!(map instanceof WeakMap)) {
        map = new WeakMap();
        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {
            value: map,
        });
    }
    let cursors = map.get(element);
    if (!cursors) {
        cursors = [null, null];
        map.set(element, cursors);
    }
    return cursors;
}



/***/ }),

/***/ 79475:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: CursorNames, CursorSVG, ImageMouseCursor, MouseCursor, SVGMouseCursor, elementCursor, registerCursor, setCursorForElement

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js
var cursors_MouseCursor = __webpack_require__(94430);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js


const DEFAULT_NAME = 'image-cursor';
class ImageMouseCursor extends cursors_MouseCursor/* default */.A {
    constructor(url, x, y, name, fallback) {
        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);
        this.url = url;
        this.x = Number(x) || 0;
        this.y = Number(y) || 0;
    }
    getStyleProperty() {
        const { url, x, y } = this;
        let style = `url('${url}')`;
        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {
            style += ` ${x} ${y}`;
        }
        return this.addFallbackStyleProperty(style);
    }
    static getUniqueInstanceName(prefix) {
        return `${prefix}-${esm.utilities.getRuntimeId(ImageMouseCursor)}`;
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js
const BASE = {
    iconContent: '',
    iconSize: 16,
    viewBox: {
        x: 16,
        y: 16,
    },
    mousePoint: {
        x: 8,
        y: 8,
    },
    mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `,
};
const SEGMENTATION_CURSOR_BOUNDARIES = {
    x: 127,
    y: 60,
};
const MINUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`;
const PLUS_RECT = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`;
const SCISSOR_ICON = `<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>`;
const RECTANGLE_ICON = `<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>`;
const CIRCLE_ICON = `<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>`;
const CursorSVG = {
    Angle: extend(BASE, {
        name: 'Angle',
        iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    ArrowAnnotate: extend(BASE, {
        name: 'ArrowAnnotate',
        iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Bidirectional: extend(BASE, {
        name: 'Bidirectional',
        iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
        viewBox: {
            x: 48,
            y: 48,
        },
    }),
    CobbAngle: extend(BASE, {
        name: 'CobbAngle',
        iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    CircleROI: extend(BASE, {
        name: 'CircleROI',
        iconContent: `<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    EllipticalROI: extend(BASE, {
        name: 'EllipticalROI',
        iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
        viewBox: {
            x: 32,
            y: 32,
        },
    }),
    FreehandROI: extend(BASE, {
        name: 'FreehandROI',
        iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    FreehandROISculptor: extend(BASE, {
        name: 'FreehandROISculptor',
        iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Length: extend(BASE, {
        name: 'Length',
        iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Height: extend(BASE, {
        name: 'Height',
        iconContent: `<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />`,
        viewBox: {
            x: 24,
            y: 24,
        },
    }),
    Probe: extend(BASE, {
        name: 'Probe',
        iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    RectangleROI: extend(BASE, {
        name: 'RectangleROI',
        iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Label: extend(BASE, {
        name: 'Label',
        iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Crosshairs: extend(BASE, {
        name: 'Crosshairs',
        iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Eraser: extend(BASE, {
        name: 'Eraser',
        iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
        viewBox: {
            x: 2048,
            y: 1792,
        },
    }),
    Magnify: extend(BASE, {
        name: 'Magnify',
        iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
        viewBox: {
            x: 512,
            y: 512,
        },
    }),
    Pan: extend(BASE, {
        name: 'Pan',
        iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    Rotate: extend(BASE, {
        name: 'Rotate',
        iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    StackScroll: extend(BASE, {
        name: 'StackScroll',
        iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
        viewBox: {
            x: 24,
            y: 28,
        },
    }),
    WindowLevelRegion: extend(BASE, {
        name: 'WindowLevelRegion',
        iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
        viewBox: {
            x: 1792,
            y: 1792,
        },
    }),
    WindowLevel: extend(BASE, {
        name: 'WindowLevel',
        iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
        viewBox: {
            x: 18,
            y: 18,
        },
    }),
    Zoom: extend(BASE, {
        name: 'Zoom',
        iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
        viewBox: {
            x: 640,
            y: 512,
        },
    }),
    SegmentationFreeHandEraseInside: extend(BASE, {
        name: 'SegmentationFreeHandEraseInside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillInside: extend(BASE, {
        name: 'SegmentationFreeHandFillInside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandEraseOutside: extend(BASE, {
        name: 'SegmentationFreeHandEraseOutside',
        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationFreeHandFillOutside: extend(BASE, {
        name: 'SegmentationFreeHandFillOutside',
        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    SegmentationRectangleEraseInside: extend(BASE, {
        name: 'SegmentationRectangleEraseInside',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    RectangleScissor: extend(BASE, {
        name: 'RectangleScissor',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_INSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.FILL_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_OUTSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'RectangleScissor.ERASE_INSIDE': extend(BASE, {
        name: 'RectangleScissor.ERASE_INSIDE',
        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    CircleScissor: extend(BASE, {
        name: 'CircleScissor',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_INSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_INSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.ERASE_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
    'CircleScissor.FILL_OUTSIDE': extend(BASE, {
        name: 'CircleScissor.FILL_OUTSIDE',
        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,
        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,
    }),
};
function extend(base, values) {
    return Object.assign(Object.create(base), {
        ...values,
        name: values.name || base.name,
    });
}
function registerCursor(toolName, iconContent, viewBox) {
    CursorSVG[toolName] = extend(BASE, {
        iconContent,
        viewBox,
    });
}
function getDefinedSVGCursorDescriptor(name) {
    return CursorSVG[name];
}
const svgCursorNames = Object.keys(CursorSVG);


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js




const PROPERTY = 'color';
const STATE = enums.AnnotationStyleStates.Highlighted;
const MODE = enums.ToolModes.Active;
class SVGMouseCursor_SVGMouseCursor extends ImageMouseCursor {
    constructor(url, x, y, name, fallback) {
        super(url, x, y, name, fallback);
    }
    static getDefinedCursor(name, pointer = false, color) {
        if (!color) {
            color = (0,helpers/* getStyleProperty */.h)(PROPERTY, {}, STATE, MODE);
        }
        const urn = getCursorURN(name, pointer, color);
        let cursor = super.getDefinedCursor(urn);
        if (!cursor) {
            const descriptor = getDefinedSVGCursorDescriptor(name);
            if (descriptor) {
                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));
                super.setDefinedCursor(urn, cursor);
            }
        }
        return cursor;
    }
}
function format(template, dictionary) {
    const dict = Object(dictionary);
    const defined = Object.prototype.hasOwnProperty.bind(dict);
    return (template + '').replace(/\{\{(\w+)\}\}/g, (match, key) => {
        return defined(key) ? dict[key] + '' : '';
    });
}
function getCursorURN(name, pointer, color) {
    const type = pointer ? 'pointer' : 'cursor';
    return `${type}:${name}/${color}`;
}
function createSVGMouseCursor(descriptor, name, pointer, color, fallback) {
    const { x, y } = descriptor.mousePoint;
    return new SVGMouseCursor_SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);
}
function createSVGIconUrl(descriptor, pointer, options) {
    const blob = createSVGIconBlob(descriptor, pointer, options);
    const url = URL.createObjectURL(blob);
    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;
    return urn;
}
function createSVGIconBlob(descriptor, pointer, options) {
    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);
    return new Blob([svgString], { type: 'image/svg+xml' });
}
function createSVGIcon(descriptor, options) {
    const { iconContent, iconSize, viewBox } = descriptor;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${iconSize}" height="${iconSize}" viewBox="0 0
      ${viewBox.x} ${viewBox.y}">
      ${iconContent}
    </svg>`;
    return format(svgString, options);
}
function createSVGIconWithPointer(descriptor, options) {
    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;
    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);
    const svgSize = 16 + iconSize;
    const svgString = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">
      <g>${mousePointerGroupString}</g>
      <g transform="translate(16, 16) scale(${scale})">${iconContent}</g>
    </svg>`;
    return format(svgString, options);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js



function setCursorForElement(element, cursorName) {
    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
    if (!cursor) {
        cursor = MouseCursor.getDefinedCursor(cursorName);
    }
    if (!cursor) {
        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);
        cursor = MouseCursor.getDefinedCursor(cursorName);
    }
    setElementCursor(element, cursor);
}
/* harmony default export */ const cursors_setCursorForElement = ((/* unused pure expression or super */ null && (setCursorForElement)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js






const CursorNames = [...svgCursorNames, ...cursors_MouseCursor/* standardCursorNames */.i];



/***/ }),

/***/ 85856:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _drawEllipseByCoordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95074);


function drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {
    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];
    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];
    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];
    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];
    drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (drawEllipse)));


/***/ }),

/***/ 94042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {
    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({
        color: 'rgb(0, 255, 0)',
        handleRadius: '6',
        width: '2',
        lineWidth: undefined,
        fill: 'transparent',
        type: 'circle',
        opacity: 1,
    }, options);
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);
    let attributes;
    if (type === 'circle') {
        attributes = {
            cx: `${handle[0]}`,
            cy: `${handle[1]}`,
            r: handleRadius,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            opacity: opacity,
        };
    }
    else if (type === 'rect') {
        const handleRadiusFloat = parseFloat(handleRadius);
        const side = handleRadiusFloat * 1.5;
        const x = handle[0] - side * 0.5;
        const y = handle[1] - side * 0.5;
        attributes = {
            x: `${x}`,
            y: `${y}`,
            width: `${side}`,
            height: `${side}`,
            stroke: color,
            fill,
            'stroke-width': strokeWidth,
            rx: `${side * 0.1}`,
            opacity: opacity,
        };
    }
    else {
        throw new Error(`Unsupported handle type: ${type}`);
    }
    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingHandleElement) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingHandleElement);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newHandleElement = document.createElementNS(svgns, type);
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newHandleElement);
        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawHandle);


/***/ }),

/***/ 92118:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawLine)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {
    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'line', lineUID);
    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    const layerId = svgDrawingHelper.svgLayerElement.id;
    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';
    const attributes = {
        x1: `${start[0]}`,
        y1: `${start[1]}`,
        x2: `${end[0]}`,
        y2: `${end[1]}`,
        stroke: color,
        style: dropShadowStyle,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newLine = document.createElementNS(svgns, 'line');
        if (dataId !== '') {
            newLine.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newLine);
        svgDrawingHelper.appendNode(newLine, svgNodeHash);
    }
}


/***/ }),

/***/ 17311:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawPath)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {
    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);
    const pointsArrays = hasSubArrays ? points : [points];
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'path', pathUID);
    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {
        const points = pointsArrays[i];
        const numPoints = points.length;
        if (numPoints < 2) {
            continue;
        }
        for (let j = 0; j < numPoints; j++) {
            const point = points[j];
            const cmd = j ? 'L' : 'M';
            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
        }
        if (closePath) {
            pointsAttribute += 'Z ';
        }
    }
    if (!pointsAttribute) {
        return;
    }
    const attributes = {
        d: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingNode) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingNode);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newNode = document.createElementNS(svgns, 'path');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newNode);
        svgDrawingHelper.appendNode(newNode, svgNodeHash);
    }
}


/***/ }),

/***/ 98812:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawPolyline)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56442);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85899);



function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {
    if (points.length < 2) {
        return;
    }
    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;
    const strokeWidth = lineWidth || width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'polyline', polylineUID);
    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);
    let pointsAttribute = '';
    for (const point of points) {
        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;
    }
    if (closePath) {
        const firstPoint = points[0];
        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;
    }
    const attributes = {
        points: pointsAttribute,
        stroke: color,
        fill: fillColor,
        'fill-opacity': fillOpacity,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
        'marker-start': markerStartId ? `url(#${markerStartId})` : '',
        'marker-end': markerEndId ? `url(#${markerEndId})` : '',
    };
    if (existingPolyLine) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, existingPolyLine);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const newPolyLine = document.createElementNS(svgns, 'polyline');
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, newPolyLine);
        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);
    }
}


/***/ }),

/***/ 75076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ drawRectByCoordinates)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);
/* harmony import */ var _setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56442);



function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {
    const { color, width: _width, lineWidth, lineDash, } = Object.assign({
        color: 'rgb(0, 255, 0)',
        width: '2',
        lineWidth: undefined,
        lineDash: undefined,
    }, options);
    const strokeWidth = lineWidth || _width;
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'rect', rectangleUID);
    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);
    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;
    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);
    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);
    const center = [
        (bottomRight[0] + topLeft[0]) / 2,
        (bottomRight[1] + topLeft[1]) / 2,
    ];
    const leftEdgeCenter = [
        (bottomLeft[0] + topLeft[0]) / 2,
        (bottomLeft[1] + topLeft[1]) / 2,
    ];
    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *
        180) /
        Math.PI;
    const attributes = {
        x: `${center[0] - width / 2}`,
        y: `${center[1] - height / 2}`,
        width: `${width}`,
        height: `${height}`,
        stroke: color,
        fill: 'transparent',
        transform: `rotate(${angle} ${center[0]} ${center[1]})`,
        'stroke-width': strokeWidth,
        'stroke-dasharray': lineDash,
    };
    if (existingRect) {
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, existingRect);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const svgRectElement = document.createElementNS(svgns, 'rect');
        if (dataId !== '') {
            svgRectElement.setAttribute('data-id', dataId);
        }
        (0,_setNewAttributesIfValid__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(attributes, svgRectElement);
        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);
    }
}


/***/ }),

/***/ 26290:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97181);
/* harmony import */ var _setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85899);


function drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {
    const mergedOptions = Object.assign({
        fontFamily: 'Helvetica, Arial, sans-serif',
        fontSize: '14px',
        color: 'rgb(255, 255, 0)',
        background: '',
        padding: 25,
        centerX: false,
        centerY: true,
    }, options);
    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);
    return textGroupBoundingBox;
}
function _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {
    const { padding, color, fontFamily, fontSize, background } = options;
    let textGroupBoundingBox;
    const [x, y] = [position[0] + padding, position[1] + padding];
    const svgns = 'http://www.w3.org/2000/svg';
    const svgNodeHash = (0,_getHash__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotationUID, 'text', textUID);
    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);
    if (existingTextGroup) {
        const textElement = existingTextGroup.querySelector('text');
        const textSpans = Array.from(textElement.children);
        for (let i = 0; i < textSpans.length; i++) {
            const textSpanElement = textSpans[i];
            const text = textLines[i] || '';
            textSpanElement.textContent = text;
        }
        if (textLines.length > textSpans.length) {
            for (let i = 0; i < textLines.length - textSpans.length; i++) {
                const textLine = textLines[i + textSpans.length];
                const textSpan = _createTextSpan(textLine);
                textElement.appendChild(textSpan);
            }
            existingTextGroup.appendChild(textElement);
            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);
        }
        const textAttributes = {
            fill: color,
            'font-size': fontSize,
            'font-family': fontFamily,
        };
        const textGroupAttributes = {
            transform: `translate(${x} ${y})`,
        };
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(textAttributes, textElement);
        (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(textGroupAttributes, existingTextGroup);
        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);
        svgDrawingHelper.setNodeTouched(svgNodeHash);
    }
    else {
        const textGroup = document.createElementNS(svgns, 'g');
        textGroup.setAttribute('data-annotation-uid', annotationUID);
        textGroup.setAttribute('transform', `translate(${x} ${y})`);
        const textElement = _createTextElement(svgDrawingHelper, options);
        for (let i = 0; i < textLines.length; i++) {
            const textLine = textLines[i];
            const textSpan = _createTextSpan(textLine);
            textElement.appendChild(textSpan);
        }
        textGroup.appendChild(textElement);
        svgDrawingHelper.appendNode(textGroup, svgNodeHash);
        textGroupBoundingBox = _drawTextBackground(textGroup, background);
    }
    return Object.assign({}, textGroupBoundingBox, {
        x,
        y,
        height: textGroupBoundingBox.height + padding,
        width: textGroupBoundingBox.width + padding,
    });
}
function _createTextElement(svgDrawingHelper, options) {
    const { color, fontFamily, fontSize } = options;
    const svgns = 'http://www.w3.org/2000/svg';
    const textElement = document.createElementNS(svgns, 'text');
    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';
    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;
    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;
    textElement.setAttribute('x', '0');
    textElement.setAttribute('y', '0');
    textElement.setAttribute('fill', color);
    textElement.setAttribute('font-family', fontFamily);
    textElement.setAttribute('font-size', fontSize);
    textElement.setAttribute('style', combinedStyle);
    textElement.setAttribute('pointer-events', 'visible');
    return textElement;
}
function _createTextSpan(text) {
    const svgns = 'http://www.w3.org/2000/svg';
    const textSpanElement = document.createElementNS(svgns, 'tspan');
    textSpanElement.setAttribute('x', '0');
    textSpanElement.setAttribute('dy', '1.2em');
    textSpanElement.textContent = text;
    return textSpanElement;
}
function _drawTextBackground(group, color) {
    let element = group.querySelector('rect.background');
    if (!color) {
        if (element) {
            group.removeChild(element);
        }
        return group.getBBox();
    }
    if (!element) {
        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        element.setAttribute('class', 'background');
        group.insertBefore(element, group.firstChild);
    }
    const bBox = group.getBBox();
    const attributes = {
        x: `${bBox.x}`,
        y: `${bBox.y}`,
        width: `${bBox.width}`,
        height: `${bBox.height}`,
        fill: color,
    };
    (0,_setAttributesIfNecessary__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(attributes, element);
    return bBox;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drawTextBox);


/***/ }),

/***/ 85899:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export setAttributesIfNecessary */
function setAttributesIfNecessary(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const currentValue = svgNode.getAttribute(key);
        const newValue = attributes[key];
        if (newValue === undefined || newValue === '') {
            svgNode.removeAttribute(key);
        }
        else if (currentValue !== newValue) {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setAttributesIfNecessary);


/***/ }),

/***/ 56442:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export setNewAttributesIfValid */
function setNewAttributesIfValid(attributes, svgNode) {
    Object.keys(attributes).forEach((key) => {
        const newValue = attributes[key];
        if (newValue !== undefined && newValue !== '') {
            svgNode.setAttribute(key, newValue);
        }
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setNewAttributesIfValid);


/***/ }),

/***/ 94021:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Events;
(function (Events) {
    Events["TOOL_ACTIVATED"] = "CORNERSTONE_TOOLS_TOOL_ACTIVATED";
    Events["TOOLGROUP_VIEWPORT_ADDED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED";
    Events["TOOLGROUP_VIEWPORT_REMOVED"] = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED";
    Events["TOOL_MODE_CHANGED"] = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED";
    Events["CROSSHAIR_TOOL_CENTER_CHANGED"] = "CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED";
    Events["ANNOTATION_ADDED"] = "CORNERSTONE_TOOLS_ANNOTATION_ADDED";
    Events["ANNOTATION_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED";
    Events["ANNOTATION_MODIFIED"] = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED";
    Events["ANNOTATION_REMOVED"] = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED";
    Events["ANNOTATION_SELECTION_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE";
    Events["ANNOTATION_LOCK_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE";
    Events["ANNOTATION_VISIBILITY_CHANGE"] = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE";
    Events["ANNOTATION_RENDERED"] = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED";
    Events["ANNOTATION_INTERPOLATION_PROCESS_COMPLETED"] = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED";
    Events["INTERPOLATED_ANNOTATIONS_REMOVED"] = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED";
    Events["SEGMENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED";
    Events["SEGMENTATION_RENDERED"] = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED";
    Events["SEGMENTATION_REPRESENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED";
    Events["SEGMENTATION_ADDED"] = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED";
    Events["SEGMENTATION_REPRESENTATION_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED";
    Events["SEGMENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED";
    Events["SEGMENTATION_REPRESENTATION_REMOVED"] = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED";
    Events["SEGMENTATION_DATA_MODIFIED"] = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED";
    Events["HISTORY_UNDO"] = "CORNERSTONE_TOOLS_HISTORY_UNDO";
    Events["HISTORY_REDO"] = "CORNERSTONE_TOOLS_HISTORY_REDO";
    Events["KEY_DOWN"] = "CORNERSTONE_TOOLS_KEY_DOWN";
    Events["KEY_UP"] = "CORNERSTONE_TOOLS_KEY_UP";
    Events["MOUSE_DOWN"] = "CORNERSTONE_TOOLS_MOUSE_DOWN";
    Events["MOUSE_UP"] = "CORNERSTONE_TOOLS_MOUSE_UP";
    Events["MOUSE_DOWN_ACTIVATE"] = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE";
    Events["MOUSE_DRAG"] = "CORNERSTONE_TOOLS_MOUSE_DRAG";
    Events["MOUSE_MOVE"] = "CORNERSTONE_TOOLS_MOUSE_MOVE";
    Events["MOUSE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_CLICK";
    Events["MOUSE_DOUBLE_CLICK"] = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK";
    Events["MOUSE_WHEEL"] = "CORNERSTONE_TOOLS_MOUSE_WHEEL";
    Events["TOUCH_START"] = "CORNERSTONE_TOOLS_TOUCH_START";
    Events["TOUCH_START_ACTIVATE"] = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE";
    Events["TOUCH_PRESS"] = "CORNERSTONE_TOOLS_TOUCH_PRESS";
    Events["TOUCH_DRAG"] = "CORNERSTONE_TOOLS_TOUCH_DRAG";
    Events["TOUCH_END"] = "CORNERSTONE_TOOLS_TOUCH_END";
    Events["TOUCH_TAP"] = "CORNERSTONE_TOOLS_TAP";
    Events["TOUCH_SWIPE"] = "CORNERSTONE_TOOLS_SWIPE";
})(Events || (Events = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);


/***/ }),

/***/ 18682:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var SegmentationRepresentations;
(function (SegmentationRepresentations) {
    SegmentationRepresentations["Labelmap"] = "Labelmap";
    SegmentationRepresentations["Contour"] = "Contour";
    SegmentationRepresentations["Surface"] = "Surface";
})(SegmentationRepresentations || (SegmentationRepresentations = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SegmentationRepresentations);


/***/ }),

/***/ 84093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var StrategyCallbacks;
(function (StrategyCallbacks) {
    StrategyCallbacks["OnInteractionStart"] = "onInteractionStart";
    StrategyCallbacks["OnInteractionEnd"] = "onInteractionEnd";
    StrategyCallbacks["Preview"] = "preview";
    StrategyCallbacks["RejectPreview"] = "rejectPreview";
    StrategyCallbacks["AcceptPreview"] = "acceptPreview";
    StrategyCallbacks["Fill"] = "fill";
    StrategyCallbacks["Interpolate"] = "interpolate";
    StrategyCallbacks["StrategyFunction"] = "strategyFunction";
    StrategyCallbacks["CreateIsInThreshold"] = "createIsInThreshold";
    StrategyCallbacks["Initialize"] = "initialize";
    StrategyCallbacks["INTERNAL_setValue"] = "setValue";
    StrategyCallbacks["AddPreview"] = "addPreview";
    StrategyCallbacks["ComputeInnerCircleRadius"] = "computeInnerCircleRadius";
    StrategyCallbacks["GetStatistics"] = "getStatistics";
    StrategyCallbacks["EnsureImageVolumeFor3DManipulation"] = "ensureImageVolumeFor3DManipulation";
    StrategyCallbacks["EnsureSegmentationVolumeFor3DManipulation"] = "ensureSegmentationVolumeFor3DManipulation";
})(StrategyCallbacks || (StrategyCallbacks = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StrategyCallbacks);


/***/ }),

/***/ 66452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ MouseBindings),
/* harmony export */   q: () => (/* binding */ KeyboardBindings)
/* harmony export */ });
var MouseBindings;
(function (MouseBindings) {
    MouseBindings[MouseBindings["Primary"] = 1] = "Primary";
    MouseBindings[MouseBindings["Secondary"] = 2] = "Secondary";
    MouseBindings[MouseBindings["Primary_And_Secondary"] = 3] = "Primary_And_Secondary";
    MouseBindings[MouseBindings["Auxiliary"] = 4] = "Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Auxiliary"] = 5] = "Primary_And_Auxiliary";
    MouseBindings[MouseBindings["Secondary_And_Auxiliary"] = 6] = "Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Primary_And_Secondary_And_Auxiliary"] = 7] = "Primary_And_Secondary_And_Auxiliary";
    MouseBindings[MouseBindings["Fourth_Button"] = 8] = "Fourth_Button";
    MouseBindings[MouseBindings["Fifth_Button"] = 16] = "Fifth_Button";
    MouseBindings[MouseBindings["Wheel"] = 524288] = "Wheel";
    MouseBindings[MouseBindings["Wheel_Primary"] = 524289] = "Wheel_Primary";
})(MouseBindings || (MouseBindings = {}));
var KeyboardBindings;
(function (KeyboardBindings) {
    KeyboardBindings[KeyboardBindings["Shift"] = 16] = "Shift";
    KeyboardBindings[KeyboardBindings["Ctrl"] = 17] = "Ctrl";
    KeyboardBindings[KeyboardBindings["Alt"] = 18] = "Alt";
    KeyboardBindings[KeyboardBindings["Meta"] = 91] = "Meta";
    KeyboardBindings[KeyboardBindings["ShiftCtrl"] = 1617] = "ShiftCtrl";
    KeyboardBindings[KeyboardBindings["ShiftAlt"] = 1618] = "ShiftAlt";
    KeyboardBindings[KeyboardBindings["ShiftMeta"] = 1691] = "ShiftMeta";
    KeyboardBindings[KeyboardBindings["CtrlAlt"] = 1718] = "CtrlAlt";
    KeyboardBindings[KeyboardBindings["CtrlMeta"] = 1791] = "CtrlMeta";
    KeyboardBindings[KeyboardBindings["AltMeta"] = 1891] = "AltMeta";
})(KeyboardBindings || (KeyboardBindings = {}));



/***/ }),

/***/ 49892:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ToolModes;
(function (ToolModes) {
    ToolModes["Active"] = "Active";
    ToolModes["Passive"] = "Passive";
    ToolModes["Enabled"] = "Enabled";
    ToolModes["Disabled"] = "Disabled";
})(ToolModes || (ToolModes = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ToolModes);


/***/ }),

/***/ 99737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AnnotationStyleStates: () => (/* reexport */ enums_AnnotationStyleStates),
  ChangeTypes: () => (/* reexport */ ChangeTypes/* default */.A),
  Events: () => (/* reexport */ Events/* default */.A),
  KeyboardBindings: () => (/* reexport */ ToolBindings/* KeyboardBindings */.q),
  MouseBindings: () => (/* reexport */ ToolBindings/* MouseBindings */.i),
  SegmentationRepresentations: () => (/* reexport */ SegmentationRepresentations/* default */.A),
  StrategyCallbacks: () => (/* reexport */ StrategyCallbacks/* default */.A),
  ToolModes: () => (/* reexport */ ToolModes/* default */.A),
  WorkerTypes: () => (/* reexport */ WorkerTypes)
});

// UNUSED EXPORTS: Swipe

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js
var ToolBindings = __webpack_require__(66452);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js
var ToolModes = __webpack_require__(49892);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js
var AnnotationStyleStates;
(function (AnnotationStyleStates) {
    AnnotationStyleStates["Default"] = "";
    AnnotationStyleStates["Highlighted"] = "Highlighted";
    AnnotationStyleStates["Selected"] = "Selected";
    AnnotationStyleStates["Locked"] = "Locked";
    AnnotationStyleStates["AutoGenerated"] = "AutoGenerated";
})(AnnotationStyleStates || (AnnotationStyleStates = {}));
/* harmony default export */ const enums_AnnotationStyleStates = (AnnotationStyleStates);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var Events = __webpack_require__(94021);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js
var Touch = __webpack_require__(10401);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js
var StrategyCallbacks = __webpack_require__(84093);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js
var ChangeTypes = __webpack_require__(75183);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js
var WorkerTypes_ChangeTypes;
(function (ChangeTypes) {
    ChangeTypes["POLYSEG_CONTOUR_TO_LABELMAP"] = "Converting Contour to Labelmap";
    ChangeTypes["POLYSEG_SURFACE_TO_LABELMAP"] = "Converting Surfaces to Labelmap";
    ChangeTypes["POLYSEG_CONTOUR_TO_SURFACE"] = "Converting Contour to Surface";
    ChangeTypes["POLYSEG_LABELMAP_TO_SURFACE"] = "Converting Labelmap to Surface";
    ChangeTypes["SURFACE_CLIPPING"] = "Clipping Surfaces";
    ChangeTypes["COMPUTE_STATISTICS"] = "Computing Statistics";
    ChangeTypes["INTERPOLATE_LABELMAP"] = "Interpolating Labelmap";
    ChangeTypes["COMPUTE_LARGEST_BIDIRECTIONAL"] = "Computing Largest Bidirectional";
    ChangeTypes["GENERATE_CONTOUR_SETS"] = "Generating Contour Sets";
})(WorkerTypes_ChangeTypes || (WorkerTypes_ChangeTypes = {}));
/* harmony default export */ const WorkerTypes = (WorkerTypes_ChangeTypes);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js












/***/ }),

/***/ 39011:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ annotationRenderingEngine)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17328);
/* harmony import */ var _utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(39848);




const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_1__.ToolModes;
class AnnotationRenderingEngine {
    constructor() {
        this._needsRender = new Set();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._renderFlaggedViewports = () => {
            this._throwIfDestroyed();
            const elements = Array.from(this._viewportElements.values());
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                if (this._needsRender.has(element)) {
                    this._triggerRender(element);
                    this._needsRender.delete(element);
                    if (this._needsRender.size === 0) {
                        break;
                    }
                }
            }
            this._animationFrameSet = false;
            this._animationFrameHandle = null;
            this._render();
        };
        this._viewportElements = new Map();
    }
    addViewportElement(viewportId, element) {
        this._viewportElements.set(viewportId, element);
    }
    removeViewportElement(viewportId, element) {
        this._viewportElements.delete(viewportId);
        this._needsRender.delete(element);
        this._reset();
    }
    renderViewport(element) {
        this._setViewportsToBeRenderedNextFrame([element]);
    }
    _throwIfDestroyed() {
        if (this.hasBeenDestroyed) {
            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');
        }
    }
    _setAllViewportsToBeRenderedNextFrame() {
        const elements = [...this._viewportElements.values()];
        elements.forEach((element) => {
            this._needsRender.add(element);
        });
        this._renderFlaggedViewports();
    }
    _setViewportsToBeRenderedNextFrame(elements) {
        const elementsEnabled = [...this._viewportElements.values()];
        elements.forEach((element) => {
            if (elementsEnabled.indexOf(element) !== -1) {
                this._needsRender.add(element);
            }
        });
        this._render();
    }
    _render() {
        if (this._needsRender.size > 0 && this._animationFrameSet === false) {
            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);
            this._animationFrameSet = true;
        }
    }
    _triggerRender(element) {
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        if (!enabledElement) {
            return;
        }
        const renderingEngine = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getRenderingEngine)(enabledElement.renderingEngineId);
        if (!renderingEngine) {
            console.warn('rendering Engine has been destroyed');
            return;
        }
        const enabledTools = (0,_utilities_getToolsWithModesForElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element, [
            Active,
            Passive,
            Enabled,
        ]);
        const { renderingEngineId, viewportId } = enabledElement;
        const eventDetail = {
            element,
            renderingEngineId,
            viewportId,
        };
        (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_2__.draw)(element, (svgDrawingHelper) => {
            let anyRendered = false;
            const handleDrawSvg = (tool) => {
                if (tool.renderAnnotation) {
                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);
                    anyRendered = anyRendered || rendered;
                }
            };
            enabledTools.forEach(handleDrawSvg);
            if (anyRendered) {
                (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(element, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_RENDERED, { ...eventDetail });
            }
        });
    }
    _reset() {
        window.cancelAnimationFrame(this._animationFrameHandle);
        this._needsRender.clear();
        this._animationFrameSet = false;
        this._animationFrameHandle = null;
        this._setAllViewportsToBeRenderedNextFrame();
    }
}
const annotationRenderingEngine = new AnnotationRenderingEngine();



/***/ }),

/***/ 67013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ defaultFrameOfReferenceSpecificAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

class FrameOfReferenceSpecificAnnotationManager {
    constructor(uid) {
        this.getGroupKey = (annotationGroupSelector) => {
            if (typeof annotationGroupSelector === 'string') {
                return annotationGroupSelector;
            }
            const element = annotationGroupSelector;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            if (!enabledElement) {
                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');
            }
            return enabledElement.FrameOfReferenceUID;
        };
        this._imageVolumeModifiedHandler = (evt) => {
            const eventDetail = evt.detail;
            const { FrameOfReferenceUID } = eventDetail;
            const annotations = this.annotations;
            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];
            if (!frameOfReferenceSpecificAnnotations) {
                return;
            }
            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                toolSpecificAnnotations.forEach((annotation) => {
                    const invalidated = annotation.invalidated;
                    if (invalidated !== undefined) {
                        annotation.invalidated = true;
                    }
                });
            });
        };
        this.getFramesOfReference = () => {
            return Object.keys(this.annotations);
        };
        this.getAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (!annotations[groupKey]) {
                return [];
            }
            if (toolName) {
                return annotations[groupKey][toolName]
                    ? annotations[groupKey][toolName]
                    : [];
            }
            return annotations[groupKey];
        };
        this.getAnnotation = (annotationUID) => {
            const annotations = this.annotations;
            for (const frameOfReferenceUID in annotations) {
                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];
                for (const toolName in frameOfReferenceAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];
                    for (const annotation of toolSpecificAnnotations) {
                        if (annotationUID === annotation.annotationUID) {
                            return annotation;
                        }
                    }
                }
            }
        };
        this.getNumberOfAnnotations = (groupKey, toolName) => {
            const annotations = this.getAnnotations(groupKey, toolName);
            if (!annotations.length) {
                return 0;
            }
            if (toolName) {
                return annotations.length;
            }
            let total = 0;
            for (const toolName in annotations) {
                total += annotations[toolName].length;
            }
            return total;
        };
        this.addAnnotation = (annotation, groupKey) => {
            const { metadata } = annotation;
            const { FrameOfReferenceUID, toolName } = metadata;
            groupKey = groupKey || FrameOfReferenceUID;
            const annotations = this.annotations;
            let frameOfReferenceSpecificAnnotations = annotations[groupKey];
            if (!frameOfReferenceSpecificAnnotations) {
                annotations[groupKey] = {};
                frameOfReferenceSpecificAnnotations = annotations[groupKey];
            }
            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            if (!toolSpecificAnnotations) {
                frameOfReferenceSpecificAnnotations[toolName] = [];
                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
            }
            if (this.preprocessingFn) {
                annotation = this.preprocessingFn(annotation);
            }
            toolSpecificAnnotations.push(annotation);
        };
        this.removeAnnotation = (annotationUID) => {
            const { annotations } = this;
            for (const groupKey in annotations) {
                const groupAnnotations = annotations[groupKey];
                for (const toolName in groupAnnotations) {
                    const toolAnnotations = groupAnnotations[toolName];
                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);
                    if (index !== -1) {
                        toolAnnotations.splice(index, 1);
                        if (toolAnnotations.length === 0) {
                            delete groupAnnotations[toolName];
                        }
                    }
                }
                if (Object.keys(groupAnnotations).length === 0) {
                    delete annotations[groupKey];
                }
            }
        };
        this.removeAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            const removedAnnotations = [];
            if (!annotations[groupKey]) {
                return removedAnnotations;
            }
            if (toolName) {
                const annotationsForTool = annotations[groupKey][toolName];
                for (const annotation of annotationsForTool) {
                    this.removeAnnotation(annotation.annotationUID);
                    removedAnnotations.push(annotation);
                }
            }
            else {
                for (const toolName in annotations[groupKey]) {
                    const annotationsForTool = annotations[groupKey][toolName];
                    for (const annotation of annotationsForTool) {
                        this.removeAnnotation(annotation.annotationUID);
                        removedAnnotations.push(annotation);
                    }
                }
            }
            return removedAnnotations;
        };
        this.saveAnnotations = (groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    return;
                }
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                return structuredClone(toolSpecificAnnotations);
            }
            else if (groupKey) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                return structuredClone(frameOfReferenceSpecificAnnotations);
            }
            return structuredClone(annotations);
        };
        this.restoreAnnotations = (state, groupKey, toolName) => {
            const annotations = this.annotations;
            if (groupKey && toolName) {
                let frameOfReferenceSpecificAnnotations = annotations[groupKey];
                if (!frameOfReferenceSpecificAnnotations) {
                    annotations[groupKey] = {};
                    frameOfReferenceSpecificAnnotations = annotations[groupKey];
                }
                frameOfReferenceSpecificAnnotations[toolName] = state;
            }
            else if (groupKey) {
                annotations[groupKey] = state;
            }
            else {
                this.annotations = structuredClone(state);
            }
        };
        this.getAllAnnotations = () => {
            return Object.values(this.annotations)
                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))
                .flat(2);
        };
        this.getNumberOfAllAnnotations = () => {
            let count = 0;
            const annotations = this.annotations;
            for (const groupKey in annotations) {
                const frameOfReferenceSpecificAnnotations = annotations[groupKey];
                for (const toolName in frameOfReferenceSpecificAnnotations) {
                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];
                    count += toolSpecificAnnotations.length;
                }
            }
            return count;
        };
        this.removeAllAnnotations = () => {
            const removedAnnotations = [];
            for (const annotation of this.getAllAnnotations()) {
                this.removeAnnotation(annotation.annotationUID);
                removedAnnotations.push(annotation);
            }
            return removedAnnotations;
        };
        if (!uid) {
            uid = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
        }
        this.annotations = {};
        this.uid = uid;
        _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget.addEventListener(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
    }
    setPreprocessingFn(preprocessingFn) {
        this.preprocessingFn = preprocessingFn;
    }
}
const defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');

/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (FrameOfReferenceSpecificAnnotationManager)));


/***/ }),

/***/ 2076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationLocked: () => (/* binding */ checkAndSetAnnotationLocked),
/* harmony export */   isAnnotationLocked: () => (/* binding */ isAnnotationLocked)
/* harmony export */ });
/* unused harmony exports setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



const globalLockedAnnotationUIDsSet = new Set();
function setAnnotationLocked(annotationUID, locked = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (locked) {
            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
        else {
            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);
        }
    }
    publish(detail, globalLockedAnnotationUIDsSet);
}
function unlockAllAnnotations() {
    const detail = makeEventDetail();
    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);
    publish(detail, globalLockedAnnotationUIDsSet);
}
function getAnnotationsLocked() {
    return Array.from(globalLockedAnnotationUIDsSet);
}
function isAnnotationLocked(annotationUID) {
    return globalLockedAnnotationUIDsSet.has(annotationUID);
}
function getAnnotationsLockedCount() {
    return globalLockedAnnotationUIDsSet.size;
}
function checkAndSetAnnotationLocked(annotationUID) {
    const isLocked = isAnnotationLocked(annotationUID);
    setAnnotationLocked(annotationUID, isLocked);
    return isLocked;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        locked: [],
    });
}
function lock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (!lockedAnnotationUIDsSet.has(annotationUID)) {
        lockedAnnotationUIDsSet.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = true;
        }
    }
}
function unlock(annotationUID, lockedAnnotationUIDsSet, detail) {
    if (lockedAnnotationUIDsSet.delete(annotationUID)) {
        detail.removed.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isLocked = false;
        }
    }
}
function clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {
    lockedAnnotationUIDsSet.forEach((annotationUID) => {
        unlock(annotationUID, lockedAnnotationUIDsSet, detail);
    });
}
function publish(detail, lockedAnnotationUIDsSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_LOCK_CHANGE, detail);
    }
}



/***/ }),

/***/ 17343:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deselectAnnotation: () => (/* binding */ deselectAnnotation),
/* harmony export */   isAnnotationSelected: () => (/* binding */ isAnnotationSelected),
/* harmony export */   setAnnotationSelected: () => (/* binding */ setAnnotationSelected)
/* harmony export */ });
/* unused harmony exports getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



const selectedAnnotationUIDs = new Set();
function setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {
    if (selected) {
        selectAnnotation(annotationUID, preserveSelected);
    }
    else {
        deselectAnnotation(annotationUID);
    }
}
function selectAnnotation(annotationUID, preserveSelected = false) {
    const detail = makeEventDetail();
    if (!preserveSelected) {
        clearSelectionSet(selectedAnnotationUIDs, detail);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {
        selectedAnnotationUIDs.add(annotationUID);
        detail.added.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
        if (annotation) {
            annotation.isSelected = true;
        }
    }
    publish(detail, selectedAnnotationUIDs);
}
function deselectAnnotation(annotationUID) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (selectedAnnotationUIDs.delete(annotationUID)) {
            detail.removed.push(annotationUID);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(annotationUID);
            annotation.isSelected = false;
        }
    }
    else {
        clearSelectionSet(selectedAnnotationUIDs, detail);
    }
    publish(detail, selectedAnnotationUIDs);
}
function getAnnotationsSelected() {
    return Array.from(selectedAnnotationUIDs);
}
function getAnnotationsSelectedByToolName(toolName) {
    return getAnnotationsSelected().filter((annotationUID) => {
        const annotation = getAnnotation(annotationUID);
        return annotation?.metadata?.toolName === toolName;
    });
}
function isAnnotationSelected(annotationUID) {
    return selectedAnnotationUIDs.has(annotationUID);
}
function getAnnotationsSelectedCount() {
    return selectedAnnotationUIDs.size;
}
function makeEventDetail() {
    return Object.freeze({
        added: [],
        removed: [],
        selection: [],
    });
}
function clearSelectionSet(selectionSet, detail) {
    selectionSet.forEach((value) => {
        if (selectionSet.delete(value)) {
            detail.removed.push(value);
            const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotation)(value);
            if (annotation) {
                annotation.isSelected = false;
            }
        }
    });
}
function publish(detail, selectionSet) {
    if (detail.added.length > 0 || detail.removed.length > 0) {
        selectionSet.forEach((item) => void detail.selection.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_SELECTION_CHANGE, detail);
    }
}



/***/ }),

/***/ 82056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAnnotation: () => (/* binding */ addAnnotation),
/* harmony export */   addChildAnnotation: () => (/* binding */ addChildAnnotation),
/* harmony export */   clearParentAnnotation: () => (/* binding */ clearParentAnnotation),
/* harmony export */   getAllAnnotations: () => (/* binding */ getAllAnnotations),
/* harmony export */   getAnnotation: () => (/* binding */ getAnnotation),
/* harmony export */   getAnnotationManager: () => (/* binding */ getAnnotationManager),
/* harmony export */   getAnnotations: () => (/* binding */ getAnnotations),
/* harmony export */   getChildAnnotations: () => (/* binding */ getChildAnnotations),
/* harmony export */   getNumberOfAnnotations: () => (/* binding */ getNumberOfAnnotations),
/* harmony export */   getParentAnnotation: () => (/* binding */ getParentAnnotation),
/* harmony export */   invalidateAnnotation: () => (/* binding */ invalidateAnnotation),
/* harmony export */   removeAllAnnotations: () => (/* binding */ removeAllAnnotations),
/* harmony export */   removeAnnotation: () => (/* binding */ removeAnnotation),
/* harmony export */   removeAnnotations: () => (/* binding */ removeAnnotations),
/* harmony export */   setAnnotationManager: () => (/* binding */ setAnnotationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _helpers_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44049);


let defaultManager;
function getAnnotationManager() {
    return defaultManager;
}
function setAnnotationManager(annotationManager) {
    defaultManager = annotationManager;
}
function getAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getAnnotations(groupKey, toolName);
}
function getAnnotation(annotationUID) {
    const manager = getAnnotationManager();
    return manager.getAnnotation(annotationUID);
}
function getAllAnnotations() {
    const manager = getAnnotationManager();
    return manager.getAllAnnotations();
}
function clearParentAnnotation(annotation) {
    const { annotationUID: childUID, parentAnnotationUID } = annotation;
    if (!parentAnnotationUID) {
        return;
    }
    const parentAnnotation = getAnnotation(parentAnnotationUID);
    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);
    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);
    annotation.parentAnnotationUID = undefined;
}
function addChildAnnotation(parentAnnotation, childAnnotation) {
    const { annotationUID: parentUID } = parentAnnotation;
    const { annotationUID: childUID } = childAnnotation;
    clearParentAnnotation(childAnnotation);
    if (!parentAnnotation.childAnnotationUIDs) {
        parentAnnotation.childAnnotationUIDs = [];
    }
    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {
        return;
    }
    parentAnnotation.childAnnotationUIDs.push(childUID);
    childAnnotation.parentAnnotationUID = parentUID;
}
function getParentAnnotation(annotation) {
    return annotation.parentAnnotationUID
        ? getAnnotation(annotation.parentAnnotationUID)
        : undefined;
}
function getChildAnnotations(annotation) {
    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);
}
function addAnnotation(annotation, annotationGroupSelector) {
    if (!annotation.annotationUID) {
        annotation.annotationUID = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4();
    }
    const manager = getAnnotationManager();
    if (annotationGroupSelector instanceof HTMLDivElement) {
        const groupKey = manager.getGroupKey(annotationGroupSelector);
        manager.addAnnotation(annotation, groupKey);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForElement)(annotation, annotationGroupSelector);
    }
    else {
        manager.addAnnotation(annotation, undefined);
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationAddedForFOR)(annotation);
    }
    return annotation.annotationUID;
}
function getNumberOfAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    return manager.getNumberOfAnnotations(groupKey, toolName);
}
function removeAnnotation(annotationUID) {
    if (!annotationUID) {
        return;
    }
    const manager = getAnnotationManager();
    const annotation = manager.getAnnotation(annotationUID);
    if (!annotation) {
        return;
    }
    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));
    manager.removeAnnotation(annotationUID);
    (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({ annotation, annotationManagerUID: manager.uid });
}
function removeAllAnnotations() {
    const manager = getAnnotationManager();
    const removedAnnotations = manager.removeAllAnnotations();
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function removeAnnotations(toolName, annotationGroupSelector) {
    const manager = getAnnotationManager();
    const groupKey = manager.getGroupKey(annotationGroupSelector);
    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);
    for (const annotation of removedAnnotations) {
        (0,_helpers_state__WEBPACK_IMPORTED_MODULE_1__.triggerAnnotationRemoved)({
            annotation,
            annotationManagerUID: manager.uid,
        });
    }
}
function invalidateAnnotation(annotation) {
    let currAnnotation = annotation;
    while (currAnnotation) {
        currAnnotation.invalidated = true;
        currAnnotation = currAnnotation.parentAnnotationUID
            ? getAnnotation(currAnnotation.parentAnnotationUID)
            : undefined;
    }
}



/***/ }),

/***/ 29601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAndSetAnnotationVisibility: () => (/* binding */ checkAndSetAnnotationVisibility),
/* harmony export */   isAnnotationVisible: () => (/* binding */ isAnnotationVisible)
/* harmony export */ });
/* unused harmony exports setAnnotationVisibility, showAllAnnotations */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _annotationSelection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17343);
/* harmony import */ var _annotationState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82056);




const globalHiddenAnnotationUIDsSet = new Set();
function setAnnotationVisibility(annotationUID, visible = true) {
    const detail = makeEventDetail();
    if (annotationUID) {
        if (visible) {
            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
        else {
            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);
        }
    }
    publish(detail);
}
function showAllAnnotations() {
    const detail = makeEventDetail();
    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {
        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);
    });
    publish(detail);
}
function isAnnotationVisible(annotationUID) {
    const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
    if (annotation) {
        return !globalHiddenAnnotationUIDsSet.has(annotationUID);
    }
}
function makeEventDetail() {
    return Object.freeze({
        lastVisible: [],
        lastHidden: [],
        hidden: [],
    });
}
function show(annotationUID, annotationUIDsSet, detail) {
    if (annotationUIDsSet.delete(annotationUID)) {
        detail.lastVisible.push(annotationUID);
        const annotation = (0,_annotationState__WEBPACK_IMPORTED_MODULE_3__.getAnnotation)(annotationUID);
        annotation.isVisible = true;
    }
}
function hide(annotationUID, annotationUIDsSet, detail) {
    if (!annotationUIDsSet.has(annotationUID)) {
        annotationUIDsSet.add(annotationUID);
        if ((0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.isAnnotationSelected)(annotationUID)) {
            (0,_annotationSelection__WEBPACK_IMPORTED_MODULE_2__.deselectAnnotation)(annotationUID);
        }
        detail.lastHidden.push(annotationUID);
    }
}
function publish(detail) {
    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {
        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_VISIBILITY_CHANGE, detail);
    }
}
function checkAndSetAnnotationVisibility(annotationUID) {
    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);
    setAnnotationVisibility(annotationUID, isVisible);
    return isVisible;
}



/***/ }),

/***/ 8710:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class ToolStyle {
    constructor() {
        const defaultConfig = {
            color: 'rgb(255, 255, 0)',
            colorHighlighted: 'rgb(0, 255, 0)',
            colorSelected: 'rgb(0, 220, 0)',
            colorLocked: 'rgb(209, 193, 90)',
            lineWidth: '1',
            lineDash: '',
            shadow: true,
            textBoxVisibility: true,
            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
            textBoxFontSize: '14px',
            textBoxColor: 'rgb(255, 255, 0)',
            textBoxColorHighlighted: 'rgb(0, 255, 0)',
            textBoxColorSelected: 'rgb(0, 255, 0)',
            textBoxColorLocked: 'rgb(209, 193, 90)',
            textBoxBackground: '',
            textBoxLinkLineWidth: '1',
            textBoxLinkLineDash: '2,3',
            textBoxShadow: true,
            markerSize: '10',
            angleArcLineDash: '',
        };
        this._initializeConfig(defaultConfig);
    }
    getAnnotationToolStyles(annotationUID) {
        return this.config.annotations && this.config.annotations[annotationUID];
    }
    getViewportToolStyles(viewportId) {
        return this.config.viewports && this.config.viewports[viewportId];
    }
    getToolGroupToolStyles(toolGroupId) {
        return this.config.toolGroups && this.config.toolGroups[toolGroupId];
    }
    getDefaultToolStyles() {
        return this.config.default;
    }
    setAnnotationStyles(annotationUID, styles) {
        let annotationSpecificStyles = this.config.annotations;
        if (!annotationSpecificStyles) {
            this.config = {
                ...this.config,
                annotations: {},
            };
            annotationSpecificStyles = this.config.annotations;
        }
        annotationSpecificStyles[annotationUID] = styles;
    }
    setViewportToolStyles(viewportId, styles) {
        let viewportSpecificStyles = this.config.viewports;
        if (!viewportSpecificStyles) {
            this.config = {
                ...this.config,
                viewports: {},
            };
            viewportSpecificStyles = this.config.viewports;
        }
        viewportSpecificStyles[viewportId] = styles;
    }
    setToolGroupToolStyles(toolGroupId, styles) {
        let toolGroupSpecificStyles = this.config.toolGroups;
        if (!toolGroupSpecificStyles) {
            this.config = {
                ...this.config,
                toolGroups: {},
            };
            toolGroupSpecificStyles = this.config.toolGroups;
        }
        toolGroupSpecificStyles[toolGroupId] = styles;
    }
    setDefaultToolStyles(styles) {
        this.config.default = styles;
    }
    getStyleProperty(toolStyle, specifications) {
        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;
        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);
    }
    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {
        if (annotationUID) {
            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);
            if (annotationToolStyles) {
                if (annotationToolStyles[property] !== undefined) {
                    return annotationToolStyles[property];
                }
            }
        }
        if (viewportId) {
            const viewportToolStyles = this.getViewportToolStyles(viewportId);
            if (viewportToolStyles) {
                if (viewportToolStyles[toolName] &&
                    viewportToolStyles[toolName][property] !== undefined) {
                    return viewportToolStyles[toolName][property];
                }
                if (viewportToolStyles.global &&
                    viewportToolStyles.global[property] !== undefined) {
                    return viewportToolStyles.global[property];
                }
            }
        }
        if (toolGroupId) {
            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);
            if (toolGroupToolStyles) {
                if (toolGroupToolStyles[toolName] &&
                    toolGroupToolStyles[toolName][property] !== undefined) {
                    return toolGroupToolStyles[toolName][property];
                }
                if (toolGroupToolStyles.global &&
                    toolGroupToolStyles.global[property] !== undefined) {
                    return toolGroupToolStyles.global[property];
                }
            }
        }
        const globalStyles = this.getDefaultToolStyles();
        if (globalStyles[toolName] &&
            globalStyles[toolName][property] !== undefined) {
            return globalStyles[toolName][property];
        }
        if (globalStyles.global && globalStyles.global[property] !== undefined) {
            return globalStyles.global[property];
        }
    }
    _initializeConfig(config) {
        const toolStyles = {};
        for (const name in config) {
            toolStyles[name] = config[name];
        }
        this.config = {
            default: {
                global: toolStyles,
            },
        };
    }
}
const toolStyle = new ToolStyle();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toolStyle);


/***/ }),

/***/ 76712:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ getStyleProperty)
/* harmony export */ });
/* harmony import */ var _ToolStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8710);

function getHierarchalPropertyStyles(property, state, mode) {
    const list = [`${property}`];
    if (state) {
        list.push(`${list[0]}${state}`);
    }
    if (mode) {
        list.push(`${list[list.length - 1]}${mode}`);
    }
    return list;
}
function getStyleProperty(property, styleSpecifier, state, mode) {
    const alternatives = getHierarchalPropertyStyles(property, state, mode);
    for (let i = alternatives.length - 1; i >= 0; --i) {
        const style = _ToolStyle__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getStyleProperty(alternatives[i], styleSpecifier);
        if (style !== undefined) {
            return style;
        }
    }
}



/***/ }),

/***/ 49310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getState: () => (/* reexport */ config_getState)
});

// UNUSED EXPORTS: getFont, style

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js



function getState(annotation) {
    if (annotation) {
        if (annotation.data && annotation.highlighted) {
            return enums.AnnotationStyleStates.Highlighted;
        }
        if ((0,annotationSelection.isAnnotationSelected)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Selected;
        }
        if ((0,annotationLocking.isAnnotationLocked)(annotation.annotationUID)) {
            return enums.AnnotationStyleStates.Locked;
        }
        if (annotation.data && annotation.autoGenerated) {
            return enums.AnnotationStyleStates.AutoGenerated;
        }
    }
    return enums.AnnotationStyleStates.Default;
}
/* harmony default export */ const config_getState = (getState);

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js
var helpers = __webpack_require__(76712);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js

function getFont(styleSpecifier, state, mode) {
    const fontSize = getStyleProperty('textBoxFontSize', styleSpecifier, state, mode);
    const fontFamily = getStyleProperty('textBoxFontFamily', styleSpecifier, state, mode);
    return `${fontSize}px ${fontFamily}`;
}
/* harmony default export */ const config_getFont = ((/* unused pure expression or super */ null && (getFont)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js
var ToolStyle = __webpack_require__(8710);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js






/***/ }),

/***/ 44049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerAnnotationAddedForElement: () => (/* binding */ triggerAnnotationAddedForElement),
/* harmony export */   triggerAnnotationAddedForFOR: () => (/* binding */ triggerAnnotationAddedForFOR),
/* harmony export */   triggerAnnotationCompleted: () => (/* binding */ triggerAnnotationCompleted),
/* harmony export */   triggerAnnotationModified: () => (/* binding */ triggerAnnotationModified),
/* harmony export */   triggerAnnotationRemoved: () => (/* binding */ triggerAnnotationRemoved),
/* harmony export */   triggerContourAnnotationCompleted: () => (/* binding */ triggerContourAnnotationCompleted)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77609);



function triggerAnnotationAddedForElement(annotation, element) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { renderingEngine, viewportId } = enabledElement;
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId: renderingEngine.id,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationAddedForFOR(annotation) {
    const { toolName } = annotation.metadata;
    const toolGroups = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_2__.getToolGroupsWithToolName)(toolName);
    if (!toolGroups.length) {
        return;
    }
    const viewportsToRender = [];
    toolGroups.forEach((toolGroup) => {
        toolGroup.viewportsInfo.forEach((viewportInfo) => {
            const { renderingEngineId, viewportId } = viewportInfo;
            const { FrameOfReferenceUID } = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByIds)(viewportId, renderingEngineId);
            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {
                viewportsToRender.push(viewportInfo);
            }
        });
    });
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_ADDED;
    const eventDetail = { annotation };
    if (!viewportsToRender.length) {
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
        return;
    }
    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {
        eventDetail.viewportId = viewportId;
        eventDetail.renderingEngineId = renderingEngineId;
        (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
    });
}
function triggerAnnotationRemoved(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_REMOVED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationModified(annotation, element, changeType = _enums__WEBPACK_IMPORTED_MODULE_1__.ChangeTypes.HandlesUpdated) {
    const enabledElement = element && (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
    const { viewportId, renderingEngineId } = enabledElement || {};
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_MODIFIED;
    const eventDetail = {
        annotation,
        viewportId,
        renderingEngineId,
        changeType,
    };
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}
function triggerAnnotationCompleted(annotation) {
    const eventDetail = {
        annotation,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {
    const eventDetail = {
        annotation,
        contourHoleProcessingEnabled,
    };
    _triggerAnnotationCompleted(eventDetail);
}
function _triggerAnnotationCompleted(eventDetail) {
    const eventType = _enums__WEBPACK_IMPORTED_MODULE_1__.Events.ANNOTATION_COMPLETED;
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, eventType, eventDetail);
}



/***/ }),

/***/ 47807:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  state: () => (/* binding */ annotation_state)
});

// UNUSED EXPORTS: AnnotationGroup, FrameOfReferenceSpecificAnnotationManager, config, locking, selection, visibility

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js + 2 modules
var config = __webpack_require__(49310);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js
var annotationLocking = __webpack_require__(2076);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js
var annotationSelection = __webpack_require__(17343);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js
var annotationState = __webpack_require__(82056);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js
var state = __webpack_require__(44049);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js
var annotationVisibility = __webpack_require__(29601);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js
var FrameOfReferenceSpecificAnnotationManager = __webpack_require__(67013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js
var enums_Events = __webpack_require__(94021);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js



class AnnotationGroup {
    constructor() {
        this.annotationUIDs = new Set();
        this._isVisible = true;
        this.visibleFilter = this.unboundVisibleFilter.bind(this);
    }
    unboundVisibleFilter(uid) {
        return !this._isVisible || !this.annotationUIDs.has(uid);
    }
    has(uid) {
        return this.annotationUIDs.has(uid);
    }
    setVisible(isVisible = true, baseEvent, filter) {
        if (this._isVisible === isVisible) {
            return;
        }
        this._isVisible = isVisible;
        this.annotationUIDs.forEach((uid) => {
            const annotation = getAnnotation(uid);
            if (!annotation) {
                this.annotationUIDs.delete(uid);
                return;
            }
            if (annotation.isVisible === isVisible) {
                return;
            }
            if (!isVisible && filter?.(uid) === false) {
                return;
            }
            annotation.isVisible = isVisible;
            const eventDetail = {
                ...baseEvent,
                annotation,
            };
            triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);
        });
    }
    get isVisible() {
        return this._isVisible;
    }
    findNearby(uid, direction) {
        const uids = [...this.annotationUIDs];
        if (uids.length === 0) {
            return null;
        }
        if (!uid) {
            return uids[direction === 1 ? 0 : uids.length - 1];
        }
        const index = uids.indexOf(uid);
        if (index === -1 ||
            index + direction < 0 ||
            index + direction >= uids.length) {
            return null;
        }
        return uids[index + direction];
    }
    add(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));
    }
    remove(...annotationUIDs) {
        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));
    }
    clear() {
        this.annotationUIDs.clear();
    }
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js + 1 modules
var resetAnnotationManager = __webpack_require__(97);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js









const annotation_state = {
    ...annotationState,
    ...state,
    resetAnnotationManager: resetAnnotationManager/* resetAnnotationManager */.c,
};



/***/ }),

/***/ 60740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ getActiveSegmentIndex)
/* harmony export */ });
/* harmony import */ var _getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function getActiveSegmentIndex(segmentationId) {
    const segmentation = (0,_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    if (segmentation) {
        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);
        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;
    }
    return undefined;
}


/***/ }),

/***/ 50409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ getColorLUT)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getColorLUT(index) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getColorLUT(index);
}


/***/ }),

/***/ 97577:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aF: () => (/* binding */ getCurrentLabelmapImageIdsForViewport),
/* harmony export */   vl: () => (/* binding */ getCurrentLabelmapImageIdForViewport)
/* harmony export */ });
/* unused harmony export getLabelmapImageIdsForImageId */
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {
    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
    return imageIds[0];
}
function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);
}
function getLabelmapImageIdsForImageId(imageId, segmentationId) {
    const segmentationStateManager = defaultSegmentationStateManager;
    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);
}


/***/ }),

/***/ 33283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    return segmentationStateManager.getSegmentation(segmentationId);
}


/***/ }),

/***/ 58859:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ getViewportIdsWithSegmentation)
/* harmony export */ });
/* harmony import */ var _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59475);

function getViewportIdsWithSegmentation(segmentationId) {
    const segmentationStateManager = _SegmentationStateManager__WEBPACK_IMPORTED_MODULE_0__/* .defaultSegmentationStateManager */ ._6;
    const state = segmentationStateManager.getState();
    const viewportSegRepresentations = state.viewportSegRepresentations;
    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)
        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))
        .map(([viewportId]) => viewportId);
    return viewportIdsWithSegmentation;
}


/***/ }),

/***/ 59452:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DU: () => (/* binding */ getSurfaceRepresentationUID),
/* harmony export */   ED: () => (/* binding */ getLabelmapActorEntries),
/* harmony export */   Qe: () => (/* binding */ getLabelmapActorUID),
/* harmony export */   Th: () => (/* binding */ getSurfaceActorEntry),
/* harmony export */   wV: () => (/* binding */ getLabelmapActorEntry)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);


function getActorEntry(viewportId, segmentationId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors[0] : undefined;
}
function getActorEntries(viewportId, filterFn) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { renderingEngine, viewport } = enabledElement;
    if (!renderingEngine || !viewport) {
        return;
    }
    const actors = viewport.getActors();
    const filteredActors = actors.filter(filterFn);
    return filteredActors.length > 0 ? filteredActors : undefined;
}
function getLabelmapActorUID(viewportId, segmentationId) {
    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);
    return actorEntry?.uid;
}
function getLabelmapActorEntries(viewportId, segmentationId) {
    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getLabelmapActorEntry(viewportId, segmentationId) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap}`));
}
function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {
    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===
        getSurfaceRepresentationUID(segmentationId, segmentIndex));
}
function getSurfaceRepresentationUID(segmentationId, segmentIndex) {
    return `${segmentationId}-${_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Surface}-${segmentIndex}`;
}


/***/ }),

/***/ 91963:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wV: () => (/* reexport safe */ _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__.wV)
/* harmony export */ });
/* harmony import */ var _validateSegmentationInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9711);
/* harmony import */ var _getSegmentationActor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59452);





/***/ }),

/***/ 49906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   triggerSegmentationDataModified: () => (/* reexport safe */ _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__.Q),
/* harmony export */   triggerSegmentationModified: () => (/* reexport safe */ _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__.G),
/* harmony export */   triggerSegmentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__.B),
/* harmony export */   triggerSegmentationRepresentationModified: () => (/* reexport safe */ _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__.r),
/* harmony export */   triggerSegmentationRepresentationRemoved: () => (/* reexport safe */ _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__.O)
/* harmony export */ });
/* harmony import */ var _events_triggerSegmentationDataModified__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98798);
/* harmony import */ var _events_triggerSegmentationModified__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9726);
/* harmony import */ var _events_triggerSegmentationRemoved__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1485);
/* harmony import */ var _events_triggerSegmentationRepresentationModified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44951);
/* harmony import */ var _events_triggerSegmentationRepresentationRemoved__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65290);








/***/ }),

/***/ 77609:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getToolGroup: () => (/* reexport */ ToolGroupManager_getToolGroup),
  getToolGroupForViewport: () => (/* reexport */ getToolGroupForViewport/* default */.A),
  getToolGroupsWithToolName: () => (/* reexport */ getToolGroupsWithToolName/* default */.A)
});

// UNUSED EXPORTS: createToolGroup, destroy, destroyToolGroup, getAllToolGroups

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js
var store_state = __webpack_require__(85204);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/lodash.get/index.js
var lodash_get = __webpack_require__(93008);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js + 4 modules
var cursors = __webpack_require__(79475);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js
var elementCursor = __webpack_require__(7001);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js

function getToolGroup_getToolGroup(toolGroupId) {
    return store_state/* state */.wk.toolGroups.find((s) => s.id === toolGroupId);
}
/* harmony default export */ const ToolGroupManager_getToolGroup = (getToolGroup_getToolGroup);

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js








const { Active, Passive, Enabled, Disabled } = enums.ToolModes;
const PRIMARY_BINDINGS = [{ mouseButton: enums.MouseBindings.Primary }];
class ToolGroup_ToolGroup {
    constructor(id) {
        this.viewportsInfo = [];
        this.toolOptions = {};
        this.currentActivePrimaryToolName = null;
        this.prevActivePrimaryToolName = null;
        this.restoreToolOptions = {};
        this._toolInstances = {};
        this.id = id;
    }
    getViewportIds() {
        return this.viewportsInfo.map(({ viewportId }) => viewportId);
    }
    getViewportsInfo() {
        return this.viewportsInfo.slice();
    }
    getToolInstance(toolInstanceName) {
        const toolInstance = this._toolInstances[toolInstanceName];
        if (!toolInstance) {
            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);
            return;
        }
        return toolInstance;
    }
    getToolInstances() {
        return this._toolInstances;
    }
    hasTool(toolName) {
        return !!this._toolInstances[toolName];
    }
    addTool(toolName, configuration = {}) {
        const toolDefinition = state.tools[toolName];
        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';
        const localToolInstance = this.toolOptions[toolName];
        if (!hasToolName) {
            console.warn('Tool with configuration did not produce a toolName: ', configuration);
            return;
        }
        if (!toolDefinition) {
            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
            return;
        }
        if (localToolInstance) {
            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);
            return;
        }
        const { toolClass: ToolClass } = toolDefinition;
        const toolProps = {
            name: toolName,
            toolGroupId: this.id,
            configuration,
        };
        const instantiatedTool = new ToolClass(toolProps);
        this._toolInstances[toolName] = instantiatedTool;
    }
    addToolInstance(toolName, parentClassName, configuration = {}) {
        let ToolClassToUse = state.tools[toolName]
            ?.toolClass;
        if (!ToolClassToUse) {
            const ParentClass = state.tools[parentClassName]
                .toolClass;
            class ToolInstance extends ParentClass {
            }
            ToolInstance.toolName = toolName;
            ToolClassToUse = ToolInstance;
            state.tools[toolName] = {
                toolClass: ToolInstance,
            };
        }
        this.addTool(ToolClassToUse.toolName, configuration);
    }
    addViewport(viewportId, renderingEngineId) {
        if (typeof viewportId !== 'string') {
            throw new Error('viewportId must be defined and be a string');
        }
        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);
        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {
            this.viewportsInfo.push({
                viewportId,
                renderingEngineId: renderingEngineUIDToUse,
            });
        }
        const toolName = this.getActivePrimaryMouseButtonTool();
        const runtimeSettings = Settings.getRuntimeSettings();
        if (runtimeSettings.get('useCursors')) {
            this.setViewportsCursorByToolName(toolName);
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId: renderingEngineUIDToUse,
        };
        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);
    }
    removeViewports(renderingEngineId, viewportId) {
        const indices = [];
        this.viewportsInfo.forEach((vpInfo, index) => {
            let match = false;
            if (vpInfo.renderingEngineId === renderingEngineId) {
                match = true;
                if (viewportId && vpInfo.viewportId !== viewportId) {
                    match = false;
                }
            }
            if (match) {
                indices.push(index);
            }
        });
        if (indices.length) {
            for (let i = indices.length - 1; i >= 0; i--) {
                this.viewportsInfo.splice(indices[i], 1);
            }
        }
        const eventDetail = {
            toolGroupId: this.id,
            viewportId,
            renderingEngineId,
        };
        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);
    }
    setActiveStrategy(toolName, strategyName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);
            return;
        }
        toolInstance.setActiveStrategy(strategyName);
    }
    setToolMode(toolName, mode, options = {}) {
        if (!toolName) {
            console.warn('setToolMode: toolName must be defined');
            return;
        }
        if (mode === ToolModes.Active) {
            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);
            return;
        }
        if (mode === ToolModes.Passive) {
            this.setToolPassive(toolName);
            return;
        }
        if (mode === ToolModes.Enabled) {
            this.setToolEnabled(toolName);
            return;
        }
        if (mode === ToolModes.Disabled) {
            this.setToolDisabled(toolName);
            return;
        }
        console.warn('setToolMode: mode must be defined');
    }
    setToolActive(toolName, toolBindingsOptions = {}) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        if (!toolInstance) {
            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);
            return;
        }
        const prevBindings = this.toolOptions[toolName]
            ? this.toolOptions[toolName].bindings
            : [];
        const newBindings = toolBindingsOptions.bindings
            ? toolBindingsOptions.bindings
            : [];
        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {
            const TouchBinding = binding.numTouchPoints !== undefined;
            const MouseBinding = binding.mouseButton !== undefined;
            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&
                (TouchBinding || MouseBinding)) {
                unique.push(binding);
            }
            return unique;
        }, []);
        const toolOptions = {
            bindings: bindingsToUse,
            mode: Active,
        };
        this.toolOptions[toolName] = toolOptions;
        this._toolInstances[toolName].mode = Active;
        const runtimeSettings = Settings.getRuntimeSettings();
        const useCursor = runtimeSettings.get('useCursors');
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {
            this.setViewportsCursorByToolName(toolName);
        }
        else {
            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();
            if (!activeToolIdentifier && useCursor) {
                const cursor = MouseCursor.getDefinedCursor('default');
                this._setCursorForViewports(cursor);
            }
        }
        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {
            if (this.prevActivePrimaryToolName === null) {
                this.prevActivePrimaryToolName = toolName;
            }
            else {
                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;
            }
            this.currentActivePrimaryToolName = toolName;
        }
        if (typeof toolInstance.onSetToolActive === 'function') {
            toolInstance.onSetToolActive();
        }
        this._renderViewports();
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            toolBindingsOptions,
        };
        triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);
        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);
    }
    setToolPassive(toolName, options) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const prevToolOptions = this.getToolOptions(toolName);
        const toolOptions = Object.assign({
            bindings: prevToolOptions ? prevToolOptions.bindings : [],
        }, prevToolOptions, {
            mode: Passive,
        });
        const matchBindings = Array.isArray(options?.removeAllBindings)
            ? options.removeAllBindings
            : this.getDefaultPrimaryBindings();
        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&
            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));
        let mode = Passive;
        if (toolOptions.bindings.length !== 0) {
            mode = Active;
            toolOptions.mode = mode;
        }
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = mode;
        if (typeof toolInstance.onSetToolPassive === 'function') {
            toolInstance.onSetToolPassive();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Passive);
    }
    setToolEnabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Enabled,
        };
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Enabled;
        if (typeof toolInstance.onSetToolEnabled === 'function') {
            toolInstance.onSetToolEnabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Enabled);
    }
    setToolDisabled(toolName) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);
            return;
        }
        const toolOptions = {
            bindings: [],
            mode: Disabled,
        };
        this.restoreToolOptions[toolName] = this.toolOptions[toolName];
        this.toolOptions[toolName] = toolOptions;
        toolInstance.mode = Disabled;
        if (typeof toolInstance.onSetToolDisabled === 'function') {
            toolInstance.onSetToolDisabled();
        }
        this._renderViewports();
        this._triggerToolModeChangedEvent(toolName, Disabled);
    }
    getToolOptions(toolName) {
        const toolOptionsForTool = this.toolOptions[toolName];
        if (toolOptionsForTool === undefined) {
            return;
        }
        return toolOptionsForTool;
    }
    getActivePrimaryMouseButtonTool() {
        return Object.keys(this.toolOptions).find((toolName) => {
            const toolOptions = this.toolOptions[toolName];
            return (toolOptions.mode === Active &&
                this._hasMousePrimaryButtonBinding(toolOptions));
        });
    }
    setViewportsCursorByToolName(toolName, strategyName) {
        const cursor = this._getCursor(toolName, strategyName);
        this._setCursorForViewports(cursor);
    }
    _getCursor(toolName, strategyName) {
        let cursorName;
        let cursor;
        if (strategyName) {
            cursorName = `${toolName}.${strategyName}`;
            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
            if (cursor) {
                return cursor;
            }
        }
        cursorName = `${toolName}`;
        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        cursorName = toolName;
        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);
        if (cursor) {
            return cursor;
        }
        return MouseCursor.getDefinedCursor('default');
    }
    _setCursorForViewports(cursor) {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
            if (!enabledElement) {
                return;
            }
            const { viewport } = enabledElement;
            initElementCursor(viewport.element, cursor);
        });
    }
    setToolConfiguration(toolName, configuration, overwrite) {
        const toolInstance = this._toolInstances[toolName];
        if (toolInstance === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return false;
        }
        let _configuration;
        if (overwrite) {
            _configuration = configuration;
        }
        else {
            _configuration = Object.assign(toolInstance.configuration, configuration);
        }
        toolInstance.configuration = _configuration;
        if (typeof toolInstance.onSetToolConfiguration === 'function') {
            toolInstance.onSetToolConfiguration();
        }
        this._renderViewports();
        return true;
    }
    getDefaultMousePrimary() {
        return MouseBindings.Primary;
    }
    getDefaultPrimaryBindings() {
        return PRIMARY_BINDINGS;
    }
    getToolConfiguration(toolName, configurationPath) {
        if (this._toolInstances[toolName] === undefined) {
            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);
            return;
        }
        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath) ||
            this._toolInstances[toolName].configuration;
        return utilities.deepClone(_configuration);
    }
    getPrevActivePrimaryToolName() {
        return this.prevActivePrimaryToolName;
    }
    setActivePrimaryTool(toolName) {
        const activeToolName = this.getCurrentActivePrimaryToolName();
        this.setToolDisabled(activeToolName);
        this.setToolActive(toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
        });
    }
    getCurrentActivePrimaryToolName() {
        return this.currentActivePrimaryToolName;
    }
    clone(newToolGroupId, fnToolFilter = null) {
        let toolGroup = getToolGroup(newToolGroupId);
        if (toolGroup) {
            console.debug(`ToolGroup ${newToolGroupId} already exists`);
            return toolGroup;
        }
        toolGroup = new ToolGroup_ToolGroup(newToolGroupId);
        state.toolGroups.push(toolGroup);
        fnToolFilter = fnToolFilter ?? (() => true);
        Object.keys(this._toolInstances)
            .filter(fnToolFilter)
            .forEach((toolName) => {
            const sourceToolInstance = this._toolInstances[toolName];
            const sourceToolOptions = this.toolOptions[toolName];
            const sourceToolMode = sourceToolInstance.mode;
            toolGroup.addTool(toolName);
            toolGroup.setToolMode(toolName, sourceToolMode, {
                bindings: sourceToolOptions.bindings ?? [],
            });
        });
        return toolGroup;
    }
    _hasMousePrimaryButtonBinding(toolOptions) {
        const primaryBindings = this.getDefaultPrimaryBindings();
        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));
    }
    _renderViewports() {
        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {
            getRenderingEngine(renderingEngineId).renderViewport(viewportId);
        });
    }
    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {
        const eventDetail = {
            toolGroupId: this.id,
            toolName,
            mode,
            toolBindingsOptions,
        };
        triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);
    }
    _findRenderingEngine(viewportId, renderingEngineId) {
        const renderingEngines = getRenderingEngines();
        if (renderingEngines?.length === 0) {
            throw new Error('No rendering engines found.');
        }
        if (renderingEngineId) {
            return renderingEngineId;
        }
        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));
        if (matchingEngines.length === 0) {
            if (renderingEngines.length === 1) {
                return renderingEngines[0].id;
            }
            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        if (matchingEngines.length > 1) {
            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');
        }
        return matchingEngines[0].id;
    }
}
function hasSameBinding(binding1, binding2) {
    if (binding1.mouseButton !== binding2.mouseButton) {
        return false;
    }
    if (binding1.numTouchPoints !== binding2.numTouchPoints) {
        return false;
    }
    return binding1.modifierKey === binding2.modifierKey;
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js


function createToolGroup(toolGroupId) {
    const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);
    if (toolGroupWithIdExists) {
        console.warn(`'${toolGroupId}' already exists.`);
        return;
    }
    const toolGroup = new ToolGroup(toolGroupId);
    state.toolGroups.push(toolGroup);
    return toolGroup;
}
/* harmony default export */ const ToolGroupManager_createToolGroup = ((/* unused pure expression or super */ null && (createToolGroup)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js

function destroyToolGroup_destroyToolGroup(toolGroupId) {
    const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);
    if (toolGroupIndex > -1) {
        state.toolGroups.splice(toolGroupIndex, 1);
    }
}
/* harmony default export */ const ToolGroupManager_destroyToolGroup = ((/* unused pure expression or super */ null && (destroyToolGroup_destroyToolGroup)));

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js


function destroy() {
    const toolGroups = [...state.toolGroups];
    for (const toolGroup of toolGroups) {
        destroyToolGroup(toolGroup.id);
    }
    state.toolGroups = [];
}
/* harmony default export */ const ToolGroupManager_destroy = ((/* unused pure expression or super */ null && (destroy)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js
var getToolGroupForViewport = __webpack_require__(65136);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js

function getAllToolGroups() {
    return state.toolGroups;
}
/* harmony default export */ const ToolGroupManager_getAllToolGroups = ((/* unused pure expression or super */ null && (getAllToolGroups)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js
var getToolGroupsWithToolName = __webpack_require__(88029);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js










/***/ }),

/***/ 68040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gx: () => (/* binding */ addTool)
/* harmony export */ });
/* unused harmony exports hasTool, hasToolByName, removeTool */
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85204);

function addTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);
    }
    if (!_state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName]) {
        _state__WEBPACK_IMPORTED_MODULE_0__/* .state */ .wk.tools[toolName] = {
            toolClass: ToolClass,
        };
    }
}
function hasTool(ToolClass) {
    const toolName = ToolClass.toolName;
    return !!(toolName && state.tools[toolName]);
}
function hasToolByName(toolName) {
    return !!(toolName && state.tools[toolName]);
}
function removeTool(ToolClass) {
    const toolName = ToolClass.toolName;
    if (!toolName) {
        throw new Error(`No tool found for: ${ToolClass.name}`);
    }
    if (!state.tools[toolName] !== undefined) {
        delete state.tools[toolName];
    }
    else {
        throw new Error(`${toolName} cannot be removed because it has not been added`);
    }
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (addTool)));


/***/ }),

/***/ 85204:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wk: () => (/* binding */ state)
/* harmony export */ });
/* unused harmony exports resetCornerstoneToolsState, default */
/* harmony import */ var _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48145);

const defaultState = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
let state = {
    isInteractingWithTool: false,
    isMultiPartToolActive: false,
    tools: {},
    toolGroups: [],
    synchronizers: [],
    svgNodeCache: _svgNodeCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A,
    enabledElements: [],
    handleRadius: 6,
};
function resetCornerstoneToolsState() {
    resetSvgNodeCache();
    state = {
        ...structuredClone({
            ...defaultState,
            svgNodeCache: {},
        }),
        svgNodeCache: {
            ...defaultState.svgNodeCache,
        },
    };
}



/***/ }),

/***/ 6030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37234);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);
/* harmony import */ var _utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56069);
/* harmony import */ var _utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94418);
/* harmony import */ var _stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(76712);
/* harmony import */ var _stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(49310);







class AnnotationDisplayTool extends _BaseTool__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
    constructor() {
        super(...arguments);
        this.onImageSpacingCalibrated = (evt) => {
            const { element, imageId } = evt.detail;
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            const annotationManager = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getAnnotationManager)();
            const framesOfReference = annotationManager.getFramesOfReference();
            framesOfReference.forEach((frameOfReference) => {
                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);
                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];
                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {
                    return;
                }
                toolSpecificAnnotations.forEach((annotation) => {
                    if (!annotation.metadata?.referencedImageId) {
                        return;
                    }
                    const referencedImageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(annotation.metadata.referencedImageId);
                    if (referencedImageURI === imageURI) {
                        annotation.invalidated = true;
                        annotation.data.cachedStats = {};
                    }
                });
                (0,_utilities_triggerAnnotationRender__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(element);
            });
        };
    }
    filterInteractableAnnotationsForElement(element, annotations) {
        if (!annotations?.length) {
            return [];
        }
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        return (0,_utilities_planar_filterAnnotationsForDisplay__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewport, annotations);
    }
    createAnnotation(evt) {
        const eventDetail = evt.detail;
        const { currentPoints, element } = eventDetail;
        const { world: worldPos } = currentPoints;
        const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
        const { viewport } = enabledElement;
        const camera = viewport.getCamera();
        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;
        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);
        const viewReference = viewport.getViewReference({ points: [worldPos] });
        return {
            highlighted: true,
            invalidated: true,
            metadata: {
                toolName: this.getToolName(),
                ...viewReference,
                referencedImageId,
                viewUp,
                cameraPosition,
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [],
                    activeHandleIndex: null,
                    textBox: {
                        hasMoved: false,
                        worldPosition: [0, 0, 0],
                        worldBoundingBox: {
                            topLeft: [0, 0, 0],
                            topRight: [0, 0, 0],
                            bottomLeft: [0, 0, 0],
                            bottomRight: [0, 0, 0],
                        },
                    },
                },
            },
        };
    }
    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {
        const targetId = this.getTargetId(viewport);
        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];
        if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
            referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
        }
        return referencedImageId;
    }
    getStyle(property, specifications, annotation) {
        return (0,_stateManagement_annotation_config_helpers__WEBPACK_IMPORTED_MODULE_5__/* .getStyleProperty */ .h)(property, specifications, (0,_stateManagement_annotation_config__WEBPACK_IMPORTED_MODULE_6__.getState)(annotation), this.mode);
    }
}
AnnotationDisplayTool.toolName = 'AnnotationDisplayTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnnotationDisplayTool);


/***/ }),

/***/ 37234:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49892);


const { DefaultHistoryMemo } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.HistoryMemo;
class BaseTool {
    static { this.defaults = {
        configuration: {
            strategies: {},
            defaultStrategy: undefined,
            activeStrategy: undefined,
            strategyOptions: {},
        },
    }; }
    constructor(toolProps, defaultToolProps) {
        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);
        const initialProps = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(mergedDefaults, toolProps);
        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;
        this.toolGroupId = toolGroupId;
        this.supportedInteractionTypes = supportedInteractionTypes || [];
        this.configuration = Object.assign({}, configuration);
        this.mode = _enums_ToolModes__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Disabled;
    }
    static mergeDefaultProps(defaultProps = {}, additionalProps) {
        if (!additionalProps) {
            return defaultProps;
        }
        return _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(defaultProps, additionalProps);
    }
    get toolName() {
        return this.getToolName();
    }
    getToolName() {
        return this.constructor.toolName;
    }
    applyActiveStrategy(enabledElement, operationData) {
        const { strategies, activeStrategy } = this.configuration;
        return strategies[activeStrategy]?.call(this, enabledElement, operationData);
    }
    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {
        const { strategies, activeStrategy } = this.configuration;
        if (!strategies[activeStrategy]) {
            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);
        }
        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);
    }
    setConfiguration(newConfiguration) {
        this.configuration = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.deepMerge(this.configuration, newConfiguration);
    }
    setActiveStrategy(strategyName) {
        this.setConfiguration({ activeStrategy: strategyName });
    }
    getTargetImageData(targetId) {
        if (targetId.startsWith('imageId:')) {
            const imageId = targetId.split('imageId:')[1];
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(imageId);
            let viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            viewports = viewports.filter((viewport) => {
                return viewport.getCurrentImageId() === imageId;
            });
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('volumeId:')) {
            const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithVolumeId(volumeId);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else if (targetId.startsWith('videoId:')) {
            const imageURI = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.imageIdToURI(targetId);
            const viewports = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getViewportsWithImageURI(imageURI);
            if (!viewports || !viewports.length) {
                return;
            }
            return viewports[0].getImageData();
        }
        else {
            throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
        }
    }
    getTargetId(viewport) {
        const targetId = viewport.getViewReferenceId?.();
        if (targetId) {
            return targetId;
        }
        throw new Error('getTargetId: viewport must have a getViewReferenceId method');
    }
    undo() {
        this.doneEditMemo();
        DefaultHistoryMemo.undo();
    }
    redo() {
        DefaultHistoryMemo.redo();
    }
    static createZoomPanMemo(viewport) {
        const state = {
            pan: viewport.getPan(),
            zoom: viewport.getZoom(),
        };
        const zoomPanMemo = {
            restoreMemo: () => {
                const currentPan = viewport.getPan();
                const currentZoom = viewport.getZoom();
                viewport.setZoom(state.zoom);
                viewport.setPan(state.pan);
                viewport.render();
                state.pan = currentPan;
                state.zoom = currentZoom;
            },
        };
        DefaultHistoryMemo.push(zoomPanMemo);
        return zoomPanMemo;
    }
    doneEditMemo() {
        if (this.memo?.commitMemo?.()) {
            DefaultHistoryMemo.push(this.memo);
        }
        this.memo = null;
    }
}
BaseTool.toolName = 'BaseTool';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseTool);


/***/ }),

/***/ 25894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22384);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);
/* harmony import */ var _removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(87420);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27479);
/* harmony import */ var _utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25758);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82056);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3823);










const polySegConversionInProgressForViewportId = new Map();
const processedViewportSegmentations = new Map();
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeContourFromElement__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportId, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, contourRepresentation) {
    const { segmentationId } = contourRepresentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let contourData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour];
    const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)();
    if (!contourData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour) &&
        !polySegConversionInProgressForViewportId.get(viewport.id)) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        contourData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_6__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Contour, () => polySeg.computeContourData(segmentationId, { viewport }), () => undefined);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    else if (!contourData && !(0,_config__WEBPACK_IMPORTED_MODULE_5__/* .getPolySeg */ .Qy)()) {
        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!contourData) {
        return;
    }
    if (!contourData.geometryIds?.length) {
        return;
    }
    let hasContourDataButNotMatchingViewport = false;
    const viewportNormal = viewport.getCamera().viewPlaneNormal;
    if (contourData.annotationUIDsMap) {
        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);
    }
    if (contourData.geometryIds.length > 0) {
        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);
    }
    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();
    if (hasContourDataButNotMatchingViewport &&
        !polySegConversionInProgressForViewportId.get(viewport.id) &&
        !viewportProcessed.has(segmentationId) &&
        viewport.viewportStatus === _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.ViewportStatus.RENDERED) {
        polySegConversionInProgressForViewportId.set(viewport.id, true);
        const segmentIndices = (0,_utilities_segmentation_getUniqueSegmentIndices__WEBPACK_IMPORTED_MODULE_7__/* .getUniqueSegmentIndices */ .O)(segmentationId);
        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {
            segmentIndices,
            viewport,
        });
        const geometryIds = surfacesInfo.geometryIds;
        const pointsAndPolys = [];
        for (const geometryId of geometryIds.values()) {
            const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
            const data = geometry.data;
            pointsAndPolys.push({
                points: data.points,
                polys: data.polys,
                segmentIndex: data.segmentIndex,
                id: data.segmentIndex,
            });
        }
        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);
        const rawResults = polySeg.extractContourData(polyDataCache);
        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);
        contourData.annotationUIDsMap = new Map([
            ...contourData.annotationUIDsMap,
            ...annotationUIDsMap,
        ]);
        viewportProcessed.add(segmentationId);
        processedViewportSegmentations.set(viewport.id, viewportProcessed);
        polySegConversionInProgressForViewportId.set(viewport.id, false);
    }
    (0,_contourHandler_handleContourSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .handleContourSegmentation */ .d)(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);
}
function _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {
    let validGeometry = null;
    let geometryData = null;
    for (const geometryId of geometryIds) {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry) {
            continue;
        }
        const data = geometry.data;
        if (data.contours?.[0]?.points?.length >= 3) {
            validGeometry = geometry;
            geometryData = data;
            break;
        }
    }
    if (!validGeometry || !geometryData) {
        return false;
    }
    const contours = geometryData.contours;
    const points = contours[0].points;
    const point1 = points[0];
    const point2 = points[1];
    const point3 = points[2];
    let normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.cross */ .eR.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), point2, point1), gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.sub */ .eR.sub(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), point3, point1));
    normal = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.normalize */ .eR.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.create */ .eR.create(), normal);
    const dotProduct = gl_matrix__WEBPACK_IMPORTED_MODULE_9__/* .vec3.dot */ .eR.dot(normal, viewportNormal);
    return Math.abs(dotProduct) > 0.9;
}
function _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {
    const annotationUIDs = Array.from(annotationUIDsMap.values())
        .flat()
        .map((uidSet) => Array.from(uidSet))
        .flat();
    const randomAnnotationUIDs = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getRandomSampleFromArray(annotationUIDs, 3);
    for (const annotationUID of randomAnnotationUIDs) {
        const annotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_8__.getAnnotation)(annotationUID);
        if (annotation?.metadata) {
            if (!annotation.metadata.viewPlaneNormal) {
                continue;
            }
            const annotationNormal = annotation.metadata.viewPlaneNormal;
            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +
                viewportNormal[1] * annotationNormal[1] +
                viewportNormal[2] * annotationNormal[2]);
            if (Math.abs(dotProduct - 1) > 0.01) {
                return false;
            }
        }
    }
    return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});


/***/ }),

/***/ 684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports MAX_NUMBER_COLORS, render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63597);
/* harmony import */ var _removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88234);
/* harmony import */ var _stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26228);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50409);
/* harmony import */ var _stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97577);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92686);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18682);
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(47098);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(59452);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(27479);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(49906);
/* harmony import */ var _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(59475);
















const MAX_NUMBER_COLORS = 255;
const labelMapConfigCache = new Map();
let polySegConversionInProgress = false;
function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    labelMapConfigCache.forEach((value, key) => {
        if (key.includes(segmentationId)) {
            labelMapConfigCache.delete(key);
        }
    });
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeLabelmapFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, config } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_6__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        console.warn('No segmentation found for segmentationId: ', segmentationId);
        return;
    }
    let labelmapData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap];
    let labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    if (!labelmapData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap) &&
        !polySegConversionInProgress) {
        polySegConversionInProgress = true;
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)();
        labelmapData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_13__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => null, () => {
            _stateManagement_segmentation_SegmentationStateManager__WEBPACK_IMPORTED_MODULE_15__/* .defaultSegmentationStateManager */ ._6.processLabelmapRepresentationAddition(viewport.id, segmentationId);
            setTimeout(() => {
                (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_14__.triggerSegmentationDataModified)(segmentationId);
            }, 0);
        });
        if (!labelmapData) {
            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);
        }
        polySegConversionInProgress = false;
    }
    else if (!labelmapData && !(0,_config__WEBPACK_IMPORTED_MODULE_12__/* .getPolySeg */ .Qy)()) {
        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!labelmapData) {
        return;
    }
    if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.VolumeViewport) {
        if (!labelmapActorEntries?.length) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    }
    else {
        const labelmapImageIds = (0,_stateManagement_segmentation_getCurrentLabelmapImageIdForViewport__WEBPACK_IMPORTED_MODULE_5__/* .getCurrentLabelmapImageIdsForViewport */ .aF)(viewport.id, segmentationId);
        if (!labelmapImageIds?.length) {
            return;
        }
        if (!labelmapActorEntries) {
            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);
        }
        labelmapActorEntries = (0,_stateManagement_segmentation_helpers_getSegmentationActor__WEBPACK_IMPORTED_MODULE_11__/* .getLabelmapActorEntries */ .ED)(viewport.id, segmentationId);
    }
    if (!labelmapActorEntries?.length) {
        return;
    }
    for (const labelmapActorEntry of labelmapActorEntries) {
        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);
    }
}
function _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {
    const { segmentationId } = segmentationRepresentation;
    const { cfun, ofun } = segmentationRepresentation.config;
    const { colorLUTIndex } = segmentationRepresentation;
    const activeSegmentation = (0,_stateManagement_segmentation_activeSegmentation__WEBPACK_IMPORTED_MODULE_3__.getActiveSegmentation)(viewportId);
    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;
    const labelmapStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getStyle({
        viewportId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
        segmentationId,
    });
    const renderInactiveSegmentations = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getRenderInactiveSegmentations(viewportId);
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_4__/* .getColorLUT */ .B)(colorLUTIndex);
    const numColors = Math.min(256, colorLUT.length);
    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);
    const segmentsHidden = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_9__/* .internalGetHiddenSegmentIndices */ .s)(viewportId, {
        segmentationId,
        type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
    });
    for (let i = 0; i < numColors; i++) {
        const segmentIndex = i;
        const segmentColor = colorLUT[segmentIndex];
        const perSegmentStyle = _stateManagement_segmentation_SegmentationStyle__WEBPACK_IMPORTED_MODULE_7__/* .segmentationStyle */ .Y.getStyle({
            viewportId,
            type: _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.Labelmap,
            segmentationId,
            segmentIndex,
        });
        const segmentSpecificLabelmapConfig = perSegmentStyle;
        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);
        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {
            fillAlpha,
            renderFill,
            renderOutline,
            segmentColor,
            outlineWidth,
            segmentsHidden: segmentsHidden,
            cfun,
            ofun,
        });
        if (forceColorUpdate) {
            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);
        }
        if (forceOpacityUpdate) {
            if (renderFill) {
                const segmentOpacity = segmentsHidden.has(segmentIndex)
                    ? 0
                    : (segmentColor[3] / 255) * fillAlpha;
                ofun.removePoint(segmentIndex);
                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);
            }
            else {
                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);
            }
        }
    }
    ofun.setClamping(false);
    const labelmapActor = labelmapActorEntry.actor;
    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };
    if (preLoad) {
        preLoad({ cfun, ofun, actor: labelmapActor });
    }
    else {
        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);
        labelmapActor.getProperty().setScalarOpacity(0, ofun);
        labelmapActor.getProperty().setInterpolationTypeToNearest();
    }
    if (renderOutline) {
        labelmapActor.getProperty().setUseLabelOutline(renderOutline);
        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);
        const activeSegmentIndex = (0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_10__/* .getActiveSegmentIndex */ .Q)(segmentationRepresentation.segmentationId);
        const outlineWidths = new Array(numColors - 1);
        for (let i = 1; i < numColors; i++) {
            const isHidden = segmentsHidden.has(i);
            if (isHidden) {
                outlineWidths[i - 1] = 0;
                continue;
            }
            outlineWidths[i - 1] =
                i === activeSegmentIndex
                    ? outlineWidth + activeSegmentOutlineWidthDelta
                    : outlineWidth;
        }
        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);
        labelmapActor.modified();
        labelmapActor.getProperty().modified();
        labelmapActor.getMapper().modified();
    }
    else {
        labelmapActor
            .getProperty()
            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));
    }
    const visible = isActiveLabelmap || renderInactiveSegmentations;
    labelmapActor.setVisibility(visible);
}
function _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {
    const segmentLabelmapConfig = segmentsLabelmapConfig || {};
    const configToUse = {
        ...labelmapConfig,
        ...segmentLabelmapConfig,
    };
    const fillAlpha = isActiveLabelmap
        ? configToUse.fillAlpha
        : configToUse.fillAlphaInactive;
    const outlineWidth = isActiveLabelmap
        ? configToUse.outlineWidth
        : configToUse.outlineWidthInactive;
    const renderFill = isActiveLabelmap
        ? configToUse.renderFill
        : configToUse.renderFillInactive;
    const renderOutline = isActiveLabelmap
        ? configToUse.renderOutline
        : configToUse.renderOutlineInactive;
    const outlineOpacity = isActiveLabelmap
        ? configToUse.outlineOpacity
        : configToUse.outlineOpacityInactive;
    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;
    return {
        fillAlpha,
        outlineWidth,
        renderFill,
        renderOutline,
        outlineOpacity,
        activeSegmentOutlineWidthDelta,
    };
}
function _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {
    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;
    const oldConfig = labelMapConfigCache.get(cacheUID);
    if (!oldConfig) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
        return {
            forceOpacityUpdate: true,
            forceColorUpdate: true,
        };
    }
    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;
    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||
        oldSegmentColor[1] !== segmentColor[1] ||
        oldSegmentColor[2] !== segmentColor[2];
    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||
        oldFillAlpha !== fillAlpha ||
        oldRenderFill !== renderFill ||
        oldRenderOutline !== renderOutline ||
        oldOutlineWidth !== outlineWidth ||
        oldSegmentsHidden !== segmentsHidden;
    if (forceOpacityUpdate || forceColorUpdate) {
        labelMapConfigCache.set(cacheUID, {
            fillAlpha,
            renderFill,
            renderOutline,
            outlineWidth,
            segmentColor: segmentColor.slice(),
            segmentsHidden: new Set(segmentsHidden),
            cfunMTime: cfun.getMTime(),
            ofunMTime: ofun.getMTime(),
        });
    }
    return {
        forceOpacityUpdate,
        forceColorUpdate,
    };
}
async function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {
    const result = await (0,_addLabelmapToElement__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport.element, labelmapData, segmentationId, config);
    return result || undefined;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 67014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports render, removeRepresentation */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18682);
/* harmony import */ var _removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20552);
/* harmony import */ var _addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18796);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33283);
/* harmony import */ var _stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50409);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36625);
/* harmony import */ var _utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27479);
/* harmony import */ var _stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(47098);









function removeRepresentation(viewportId, segmentationId, renderImmediate = false) {
    const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElementByViewportId)(viewportId);
    if (!enabledElement) {
        return;
    }
    const { viewport } = enabledElement;
    (0,_removeSurfaceFromElement__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewport.element, segmentationId);
    if (!renderImmediate) {
        return;
    }
    viewport.render();
}
async function render(viewport, representation) {
    const { segmentationId, type } = representation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_4__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        return;
    }
    let SurfaceData = segmentation.representationData[_enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface];
    if (!SurfaceData &&
        (0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)()?.canComputeRequestedRepresentation(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface)) {
        const polySeg = (0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)();
        SurfaceData = await (0,_utilities_segmentation_computeAndAddRepresentation__WEBPACK_IMPORTED_MODULE_7__/* .computeAndAddRepresentation */ .d)(segmentationId, _enums_SegmentationRepresentations__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }), () => polySeg.updateSurfaceData(segmentationId, { viewport }));
        if (!SurfaceData) {
            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);
        }
    }
    else if (!SurfaceData && !(0,_config__WEBPACK_IMPORTED_MODULE_6__/* .getPolySeg */ .Qy)()) {
        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
    }
    if (!SurfaceData) {
        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);
        return;
    }
    const { geometryIds } = SurfaceData;
    if (!geometryIds?.size) {
        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);
    }
    const { colorLUTIndex } = representation;
    const colorLUT = (0,_stateManagement_segmentation_getColorLUT__WEBPACK_IMPORTED_MODULE_5__/* .getColorLUT */ .B)(colorLUTIndex);
    const surfaces = [];
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        if (!geometry?.data) {
            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const { segmentIndex } = geometry.data;
        const hiddenSegments = (0,_stateManagement_segmentation_helpers_internalGetHiddenSegmentIndices__WEBPACK_IMPORTED_MODULE_8__/* .internalGetHiddenSegmentIndices */ .s)(viewport.id, {
            segmentationId,
            type,
        });
        const isHidden = hiddenSegments.has(segmentIndex);
        const surface = geometry.data;
        const color = colorLUT[segmentIndex];
        surface.color = color.slice(0, 3);
        surface.visible = !isHidden;
        surfaces.push(surface);
        (0,_addOrUpdateSurfaceToElement__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewport.element, surface, segmentationId);
    });
    viewport.render();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    render,
    removeRepresentation,
});



/***/ }),

/***/ 67847:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4096);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3823);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60810);
/* harmony import */ var _utilities_throttle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27730);
/* harmony import */ var _utilities_drawing__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(473);
/* harmony import */ var _utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(35489);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(29601);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4010);
/* harmony import */ var _utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(18990);
/* harmony import */ var _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(73262);
/* harmony import */ var _utilities_planar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(13165);
/* harmony import */ var _utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(40634);



















const { transformWorldToIndex } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
class RectangleROIStartEndThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        configuration: {
            storePointData: false,
            numSlicesToPropagate: 10,
            computePointsInsideVolume: false,
            getTextLines: defaultGetTextLines,
            statsCalculator: _utilities_math_basic__WEBPACK_IMPORTED_MODULE_16__.BasicStatsCalculator,
            showTextBox: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            let referencedImageId, imageVolume, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                throw new Error('Stack Viewport Not implemented');
            }
            else {
                const targetId = this.getTargetId(viewport);
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const spacingInNormal = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);
            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);
            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                    spacingInNormal,
                },
                data: {
                    label: '',
                    startCoordinate: startCoord,
                    endCoordinate: endCoord,
                    cachedStats: {
                        pointsInVolume: [],
                        projectionPoints: [],
                        projectionPointsImageIds: [referencedImageId],
                        statistics: [],
                    },
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    labelmapUID: null,
                },
            };
            this._computeProjectionPoints(annotation, imageVolume);
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_6__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this._endCallback = (evt) => {
            const eventDetail = evt.detail;
            const { element } = eventDetail;
            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;
            const { data } = annotation;
            if (newAnnotation && !hasMoved) {
                return;
            }
            data.handles.activeHandleIndex = null;
            this._deactivateModify(element);
            this._deactivateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_11__.resetElementCursor)(element);
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            this.editData = null;
            this.isDrawing = false;
            if (this.isHandleOutsideImage &&
                this.configuration.preventHandleOutsideImage) {
                (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .removeAnnotation */ .O8)(annotation.annotationUID);
            }
            const targetId = this.getTargetId(enabledElement.viewport);
            const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
            if (this.configuration.calculatePointsInsideVolume) {
                this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
            }
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A)(viewportIdsToRender);
            if (newAnnotation) {
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationCompleted)(annotation);
            }
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_3__/* .getAnnotations */ .Rh)(this.getToolName(), viewport.element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = (0,_utilities_planar__WEBPACK_IMPORTED_MODULE_17__.filterAnnotationsWithinSamePlane)(annotations, viewport.getCamera());
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data, metadata } = annotation;
                const { startCoordinate, endCoordinate } = data;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                const focalPoint = viewport.getCamera().focalPoint;
                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;
                let startCoord = startCoordinate;
                let endCoord = endCoordinate;
                if (Array.isArray(startCoordinate)) {
                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);
                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);
                    data.handles.points.forEach((point) => {
                        point[indexOfDirection] = startCoord;
                    });
                    data.startCoordinate = startCoord;
                }
                if (Array.isArray(endCoordinate)) {
                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);
                    data.endCoordinate = endCoord;
                    data.endCoordinate = endCoord;
                }
                const roundedStartCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(startCoord);
                const roundedEndCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(endCoord);
                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);
                const roundedCoord = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundToPrecision(coord);
                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||
                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {
                    continue;
                }
                if (annotation.invalidated) {
                    this._throttledCalculateCachedStats(annotation, enabledElement);
                }
                let firstOrLastSlice = false;
                if (roundedCoord === roundedStartCoord ||
                    roundedCoord === roundedEndCoord) {
                    firstOrLastSlice = true;
                }
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_10__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_4__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null &&
                    firstOrLastSlice) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                let lineDashToUse = lineDash;
                if (!firstOrLastSlice) {
                    lineDashToUse = 2;
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash: lineDashToUse,
                    lineWidth,
                });
                renderStatus = true;
                if (this.configuration.showTextBox &&
                    this.configuration.calculatePointsInsideVolume) {
                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);
                    if (!options.visibility) {
                        data.handles.textBox = {
                            hasMoved: false,
                            worldPosition: [0, 0, 0],
                            worldBoundingBox: {
                                topLeft: [0, 0, 0],
                                topRight: [0, 0, 0],
                                bottomLeft: [0, 0, 0],
                                bottomRight: [0, 0, 0],
                            },
                        };
                        continue;
                    }
                    const textLines = this.configuration.getTextLines(data, { metadata });
                    if (!textLines || textLines.length === 0) {
                        continue;
                    }
                    if (!data.handles.textBox.hasMoved) {
                        const canvasTextBoxCoords = (0,_utilities_drawing__WEBPACK_IMPORTED_MODULE_8__.getTextBoxCoordsCanvas)(canvasCoordinates);
                        data.handles.textBox.worldPosition =
                            viewport.canvasToWorld(canvasTextBoxCoords);
                    }
                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);
                    const textBoxUID = '1';
                    const boundingBox = (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_5__.drawLinkedTextBox)(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);
                    const { x: left, y: top, width, height } = boundingBox;
                    data.handles.textBox.worldBoundingBox = {
                        topLeft: viewport.canvasToWorld([left, top]),
                        topRight: viewport.canvasToWorld([left + width, top]),
                        bottomLeft: viewport.canvasToWorld([left, top + height]),
                        bottomRight: viewport.canvasToWorld([left + width, top + height]),
                    };
                }
            }
            return renderStatus;
        };
        this._throttledCalculateCachedStats = (0,_utilities_throttle__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this._calculateCachedStatsTool, 100, { trailing: true });
    }
    _computeProjectionPoints(annotation, imageVolume) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, spacingInNormal } = metadata;
        const { imageData } = imageVolume;
        const { startCoordinate, endCoordinate } = data;
        const { points } = data.handles;
        const startIJK = transformWorldToIndex(imageData, points[0]);
        const endIJK = transformWorldToIndex(imageData, points[0]);
        const startWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(startIJK, startWorld);
        const endWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        imageData.indexToWorldVec3(endIJK, endWorld);
        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {
            startWorld[2] = startCoordinate;
            endWorld[2] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {
            startWorld[0] = startCoordinate;
            endWorld[0] = endCoordinate;
        }
        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {
            startWorld[1] = startCoordinate;
            endWorld[1] = endCoordinate;
        }
        const distance = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.distance */ .eR.distance(startWorld, endWorld);
        const newProjectionPoints = [];
        for (let dist = 0; dist < distance; dist += spacingInNormal) {
            newProjectionPoints.push(points.map((point) => {
                const newPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
                gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);
                return Array.from(newPoint);
            }));
        }
        data.cachedStats.projectionPoints = newProjectionPoints;
    }
    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {
        const { data, metadata } = annotation;
        const { viewPlaneNormal, viewUp } = metadata;
        const { viewport } = enabledElement;
        const projectionPoints = data.cachedStats.projectionPoints;
        const pointsInsideVolume = [[]];
        const image = this.getTargetImageData(targetId);
        const worldPos1 = data.handles.points[0];
        const worldPos2 = data.handles.points[3];
        const { worldWidth, worldHeight } = (0,_utilities_planar_getWorldWidthAndHeightFromCorners__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A)(viewPlaneNormal, viewUp, worldPos1, worldPos2);
        const measureInfo = (0,_utilities_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__/* .getCalibratedLengthUnitsAndScale */ .Op)(image, data.habdles);
        const area = Math.abs(worldWidth * worldHeight) /
            (measureInfo.scale * measureInfo.scale);
        const modalityUnitOptions = {
            isPreScaled: (0,_utilities_viewport_isViewportPreScaled__WEBPACK_IMPORTED_MODULE_15__/* .isViewportPreScaled */ .u)(viewport, targetId),
            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),
        };
        const modalityUnit = (0,_utilities_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_18__/* .getPixelValueUnits */ .j)(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);
        for (let i = 0; i < projectionPoints.length; i++) {
            if (!imageVolume) {
                continue;
            }
            const projectionPoint = projectionPoints[i][0];
            const { dimensions, imageData, voxelManager } = imageVolume;
            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);
            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);
            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
            worldPos1Index[0] = Math.floor(worldPos1Index[0]);
            worldPos1Index[1] = Math.floor(worldPos1Index[1]);
            worldPos1Index[2] = Math.floor(worldPos1Index[2]);
            worldPos1Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);
            worldPos2Index[0] = Math.floor(worldPos2Index[0]);
            worldPos2Index[1] = Math.floor(worldPos2Index[1]);
            worldPos2Index[2] = Math.floor(worldPos2Index[2]);
            worldPos2Index[indexOfProjection] =
                worldProjectionPointIndex[indexOfProjection];
            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {
                this.isHandleOutsideImage = false;
                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);
                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);
                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);
                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);
                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);
                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);
                const boundsIJK = [
                    [iMin, iMax],
                    [jMin, jMax],
                    [kMin, kMax],
                ];
                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {
                    boundsIJK,
                    imageData,
                    returnPoints: this.configuration.storePointData,
                });
                pointsInsideVolume.push(pointsInShape);
            }
        }
        const stats = this.configuration.statsCalculator.getStatistics();
        data.cachedStats.pointsInVolume = pointsInsideVolume;
        data.cachedStats.statistics = {
            Modality: metadata.Modality,
            area,
            mean: stats.mean?.value,
            stdDev: stats.stdDev?.value,
            max: stats.max?.value,
            statsArray: stats.array,
            areaUnit: measureInfo.areaUnit,
            modalityUnit,
        };
    }
    _calculateCachedStatsTool(annotation, enabledElement) {
        const data = annotation.data;
        const { viewport } = enabledElement;
        const { cachedStats } = data;
        const targetId = this.getTargetId(viewport);
        const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(targetId.split(/volumeId:|\?/)[1]);
        this._computeProjectionPoints(annotation, imageVolume);
        if (this.configuration.calculatePointsInsideVolume) {
            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);
        }
        annotation.invalidated = false;
        (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_13__.triggerAnnotationModified)(annotation, viewport.element);
        return cachedStats;
    }
    _getStartCoordinate(worldPos, viewPlaneNormal) {
        const startPos = worldPos;
        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);
        return startCoord;
    }
    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {
        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;
        const endPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.create */ .eR.create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_2__/* .vec3.scaleAndAdd */ .eR.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);
        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);
        return endCoord;
    }
    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {
        const viewplaneNormalAbs = [
            Math.abs(viewPlaneNormal[0]),
            Math.abs(viewPlaneNormal[1]),
            Math.abs(viewPlaneNormal[2]),
        ];
        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));
        return indexOfDirection;
    }
    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {
        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);
        return pos[indexOfDirection];
    }
}
function defaultGetTextLines(data, _context = {}) {
    const cachedVolumeStats = data.cachedStats.statistics;
    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;
    if (mean === undefined) {
        return;
    }
    const textLines = [];
    textLines.push(`Area: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(area)} ${areaUnit}`);
    textLines.push(`Mean: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(mean)} ${modalityUnit}`);
    textLines.push(`Max: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(max)} ${modalityUnit}`);
    textLines.push(`Std Dev: ${_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.roundNumber(stdDev)} ${modalityUnit}`);
    return textLines;
}
RectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (RectangleROIStartEndThresholdTool)));


/***/ }),

/***/ 40336:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6802);
/* harmony import */ var _stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2076);
/* harmony import */ var _drawingSvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17328);
/* harmony import */ var _utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60810);
/* harmony import */ var _cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7001);
/* harmony import */ var _utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58640);
/* harmony import */ var _stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(29601);
/* harmony import */ var _stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44049);
/* harmony import */ var _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4010);










class RectangleROIThresholdTool extends _annotation_RectangleROITool__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A {
    constructor(toolProps = {}, defaultToolProps = {
        supportedInteractionTypes: ['Mouse', 'Touch'],
        configuration: {
            shadow: true,
            preventHandleOutsideImage: false,
        },
    }) {
        super(toolProps, defaultToolProps);
        this.addNewAnnotation = (evt) => {
            const eventDetail = evt.detail;
            const { currentPoints, element } = eventDetail;
            const worldPos = currentPoints.world;
            const enabledElement = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElement)(element);
            const { viewport, renderingEngine } = enabledElement;
            this.isDrawing = true;
            const camera = viewport.getCamera();
            const { viewPlaneNormal, viewUp } = camera;
            const targetId = this.getTargetId(viewport);
            let referencedImageId, volumeId;
            if (viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.StackViewport) {
                referencedImageId = targetId.split('imageId:')[1];
            }
            else {
                volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getVolumeId(targetId);
                const imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
                referencedImageId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
            }
            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
            const annotation = {
                highlighted: true,
                invalidated: true,
                metadata: {
                    viewPlaneNormal: [...viewPlaneNormal],
                    enabledElement,
                    viewUp: [...viewUp],
                    FrameOfReferenceUID,
                    referencedImageId,
                    toolName: this.getToolName(),
                    volumeId,
                },
                data: {
                    label: '',
                    handles: {
                        textBox: {
                            hasMoved: false,
                            worldPosition: null,
                            worldBoundingBox: null,
                        },
                        points: [
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                            [...worldPos],
                        ],
                        activeHandleIndex: null,
                    },
                    segmentationId: null,
                },
            };
            (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .addAnnotation */ .lC)(annotation, element);
            const viewportIdsToRender = (0,_utilities_viewportFilters__WEBPACK_IMPORTED_MODULE_4__.getViewportIdsWithToolToRender)(element, this.getToolName());
            this.editData = {
                annotation,
                viewportIdsToRender,
                handleIndex: 3,
                newAnnotation: true,
                hasMoved: false,
            };
            this._activateDraw(element);
            (0,_cursors_elementCursor__WEBPACK_IMPORTED_MODULE_5__.hideElementCursor)(element);
            evt.preventDefault();
            (0,_utilities_triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(viewportIdsToRender);
            return annotation;
        };
        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {
            let renderStatus = false;
            const { viewport } = enabledElement;
            const { element } = viewport;
            let annotations = (0,_stateManagement__WEBPACK_IMPORTED_MODULE_1__/* .getAnnotations */ .Rh)(this.getToolName(), element);
            if (!annotations?.length) {
                return renderStatus;
            }
            annotations = this.filterInteractableAnnotationsForElement(element, annotations);
            if (!annotations?.length) {
                return renderStatus;
            }
            const styleSpecifier = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: enabledElement.viewport.id,
            };
            for (let i = 0; i < annotations.length; i++) {
                const annotation = annotations[i];
                const { annotationUID, data } = annotation;
                const { points, activeHandleIndex } = data.handles;
                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));
                styleSpecifier.annotationUID = annotationUID;
                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);
                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);
                const color = this.getStyle('color', styleSpecifier, annotation);
                if (!viewport.getRenderingEngine()) {
                    console.warn('Rendering Engine has been destroyed');
                    return renderStatus;
                }
                (0,_stateManagement_annotation_helpers_state__WEBPACK_IMPORTED_MODULE_8__.triggerAnnotationModified)(annotation, element);
                let activeHandleCanvasCoords;
                if (!(0,_stateManagement_annotation_annotationVisibility__WEBPACK_IMPORTED_MODULE_7__.isAnnotationVisible)(annotationUID)) {
                    continue;
                }
                if (!(0,_stateManagement_annotation_annotationLocking__WEBPACK_IMPORTED_MODULE_2__.isAnnotationLocked)(annotationUID) &&
                    !this.editData &&
                    activeHandleIndex !== null) {
                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];
                }
                if (activeHandleCanvasCoords) {
                    const handleGroupUID = '0';
                    (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawHandles)(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {
                        color,
                    });
                }
                const rectangleUID = '0';
                (0,_drawingSvg__WEBPACK_IMPORTED_MODULE_3__.drawRect)(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {
                    color,
                    lineDash,
                    lineWidth,
                });
                renderStatus = true;
            }
            return renderStatus;
        };
    }
}
RectangleROIThresholdTool.toolName = 'RectangleROIThreshold';
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (RectangleROIThresholdTool)));


/***/ }),

/***/ 62753:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84093);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83075);




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.EnsureImageVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        let referencedImageIds;
        if (viewport) {
            referencedImageIds = viewport.getImageIds();
            const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
            if (!isValidVolumeForSphere) {
                throw new Error('Volume is not reconstructable for sphere manipulation');
            }
        }
        else {
            const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(operationData.segmentationId);
            const imageIds = segmentation.representationData
                .Labelmap.imageIds;
            referencedImageIds = imageIds.map((imageId) => {
                const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
                return image.referencedImageId;
            });
        }
        const imageVolume = (0,_utilities_segmentation_getOrCreateImageVolume__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(referencedImageIds);
        if (!imageVolume) {
            throw new Error('Failed to create or get image volume');
        }
        operationData.imageVoxelManager = imageVolume.voxelManager;
        operationData.imageData = imageVolume.imageData;
    },
});


/***/ }),

/***/ 38732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84093);
/* harmony import */ var _utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30722);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    [_enums_StrategyCallbacks__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.EnsureSegmentationVolumeFor3DManipulation]: (data) => {
        const { operationData, viewport } = data;
        const { segmentationId, imageIds: segImageIds } = operationData;
        const referencedImageIds = viewport
            ? viewport.getImageIds()
            : segImageIds.map((imageId) => _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId).referencedImageId);
        const isValidVolumeForSphere = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
        if (!isValidVolumeForSphere) {
            throw new Error('Volume is not reconstructable for sphere manipulation');
        }
        const segVolume = (0,_utilities_segmentation_getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(segmentationId);
        if (!segVolume) {
            return;
        }
        operationData.segmentationVoxelManager = segVolume.voxelManager;
        operationData.segmentationImageData = segVolume.imageData;
        return;
    },
});


/***/ }),

/***/ 93126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ ContourWindingDirection)
/* harmony export */ });
var ContourWindingDirection;
(function (ContourWindingDirection) {
    ContourWindingDirection[ContourWindingDirection["CounterClockwise"] = -1] = "CounterClockwise";
    ContourWindingDirection[ContourWindingDirection["Unknown"] = 0] = "Unknown";
    ContourWindingDirection[ContourWindingDirection["Clockwise"] = 1] = "Clockwise";
})(ContourWindingDirection || (ContourWindingDirection = {}));


/***/ }),

/***/ 87063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ getBoundingBoxAroundShapeWorld),
/* harmony export */   g: () => (/* binding */ getBoundingBoxAroundShapeIJK)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { EPSILON } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS;
function calculateBoundingBox(points, dimensions, isWorld = false) {
    let xMin = Infinity;
    let xMax = isWorld ? -Infinity : 0;
    let yMin = Infinity;
    let yMax = isWorld ? -Infinity : 0;
    let zMin = Infinity;
    let zMax = isWorld ? -Infinity : 0;
    const is3D = points[0]?.length === 3;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        xMin = Math.min(p[0], xMin);
        xMax = Math.max(p[0], xMax);
        yMin = Math.min(p[1], yMin);
        yMax = Math.max(p[1], yMax);
        if (is3D) {
            zMin = Math.min(p[2] ?? zMin, zMin);
            zMax = Math.max(p[2] ?? zMax, zMax);
        }
    }
    if (dimensions) {
        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);
        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);
        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);
        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);
        if (is3D && dimensions.length === 3) {
            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);
            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);
        }
    }
    else if (!isWorld) {
        xMin = Math.max(0, xMin);
        xMax = Math.min(Infinity, xMax);
        yMin = Math.max(0, yMin);
        yMax = Math.min(Infinity, yMax);
        if (is3D) {
            zMin = Math.max(0, zMin);
            zMax = Math.min(Infinity, zMax);
        }
    }
    return is3D
        ? [
            [xMin, xMax],
            [yMin, yMax],
            [zMin, zMax],
        ]
        : [[xMin, xMax], [yMin, yMax], null];
}
function getBoundingBoxAroundShapeIJK(points, dimensions) {
    return calculateBoundingBox(points, dimensions, false);
}
function getBoundingBoxAroundShapeWorld(points, clipBounds) {
    return calculateBoundingBox(points, clipBounds, true);
}


/***/ }),

/***/ 62854:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function areSameSegment(firstAnnotation, secondAnnotation) {
    const { segmentation: firstSegmentation } = firstAnnotation.data;
    const { segmentation: secondSegmentation } = secondAnnotation.data;
    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&
        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);
}


/***/ }),

/***/ 78130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function isContourSegmentationAnnotation(annotation) {
    return !!annotation.data?.segmentation;
}


/***/ }),

/***/ 37354:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ removeContourSegmentationAnnotation)
/* harmony export */ });
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33283);

function removeContourSegmentationAnnotation(annotation) {
    if (!annotation.data.segmentation) {
        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');
    }
    const { segmentationId, segmentIndex } = annotation.data.segmentation;
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_0__/* .getSegmentation */ .T)(segmentationId);
    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};
    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);
    if (!annotationsUIDsSet) {
        return;
    }
    annotationsUIDsSet.delete(annotation.annotationUID);
    if (!annotationsUIDsSet.size) {
        annotationUIDsMap.delete(segmentIndex);
    }
}


/***/ }),

/***/ 93843:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function calculatePerimeter(polyline, closed) {
    let perimeter = 0;
    for (let i = 0; i < polyline.length - 1; i++) {
        const point1 = polyline[i];
        const point2 = polyline[i + 1];
        perimeter += Math.sqrt(Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2));
    }
    if (closed) {
        const firstPoint = polyline[0];
        const lastPoint = polyline[polyline.length - 1];
        perimeter += Math.sqrt(Math.pow(lastPoint[0] - firstPoint[0], 2) +
            Math.pow(lastPoint[1] - firstPoint[1], 2));
    }
    return perimeter;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calculatePerimeter);


/***/ }),

/***/ 15451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getContourHolesDataCanvas)
/* harmony export */ });
/* harmony import */ var _getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55659);

function getContourHolesDataCanvas(annotation, viewport) {
    const worldHoleContours = (0,_getContourHolesDataWorld__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(annotation);
    const canvasHoleContours = [];
    worldHoleContours.forEach((worldHoleContour) => {
        const numPoints = worldHoleContour.length;
        const canvasHoleContour = new Array(numPoints);
        for (let i = 0; i < numPoints; i++) {
            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);
        }
        canvasHoleContours.push(canvasHoleContour);
    });
    return canvasHoleContours;
}


/***/ }),

/***/ 55659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getContourHolesDataWorld)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82056);

function getContourHolesDataWorld(annotation) {
    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];
    return childAnnotationUIDs.map((uid) => (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_0__.getAnnotation)(uid).data.contour.polyline);
}


/***/ }),

/***/ 54889:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: AnnotationToPointData, acceptAutogeneratedInterpolations, areCoplanarContours, calculatePerimeter, contourFinder, detectContourHoles, findHandlePolylineIndex, generateContourSetsFromLabelmap, getContourHolesDataCanvas, getContourHolesDataWorld, getDeduplicatedVTKPolyDataPoints, updateContourPolyline

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js

function areCoplanarContours(firstAnnotation, secondAnnotation) {
    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;
    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;
    const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);
    const parallelPlanes = glMatrix.equals(1, Math.abs(dot));
    if (!parallelPlanes) {
        return false;
    }
    const { polyline: firstPolyline } = firstAnnotation.data.contour;
    const { polyline: secondPolyline } = secondAnnotation.data.contour;
    const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);
    const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);
    return glMatrix.equals(firstDistance, secondDistance);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js
var contourFinder = __webpack_require__(46228);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js
var getDeduplicatedVTKPolyDataPoints = __webpack_require__(37546);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js
const getIsPointInsidePolygon = (point, vertices) => {
    const x = point[0];
    const y = point[1];
    let inside = false;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i][0], yi = vertices[i][1];
        const xj = vertices[j][0], yj = vertices[j][1];
        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
        if (intersect) {
            inside = !inside;
        }
    }
    return inside;
};
function checkEnclosed(outerContour, innerContour, points) {
    const vertices = [];
    outerContour.contourPoints.forEach((point) => {
        vertices.push([points[point][0], points[point][1]]);
    });
    let pointsNotEnclosed = 0;
    innerContour.contourPoints.forEach((point) => {
        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);
        if (!result) {
            pointsNotEnclosed++;
        }
    });
    return pointsNotEnclosed === 0;
}
function processContourHoles(contours, points, useXOR = true) {
    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');
    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');
    const contourWithHoles = [];
    let contourWithoutHoles = [];
    closedContours.forEach((contour, index) => {
        const holes = [];
        closedContours.forEach((hContour, hIndex) => {
            if (index != hIndex) {
                if (checkEnclosed(contour, hContour, points)) {
                    holes.push(hIndex);
                }
            }
        });
        if (holes.length > 0) {
            contourWithHoles.push({
                contour,
                holes,
            });
        }
        else {
            contourWithoutHoles.push(index);
        }
    });
    if (useXOR) {
        contourWithHoles.forEach((contourHoleSet) => {
            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';
            retContours.push(contourHoleSet.contour);
            contourHoleSet.holes.forEach((holeIndex) => {
                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';
                retContours.push(closedContours[holeIndex]);
                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {
                    return contourIndex !== holeIndex;
                });
            });
        });
        contourWithoutHoles.forEach((contourIndex) => {
            retContours.push(closedContours[contourIndex]);
        });
    }
    else {
    }
    return retContours;
}
/* harmony default export */ const detectContourHoles = ({ processContourHoles });

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var dist_esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js
var SegmentationRepresentations = __webpack_require__(18682);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js
var utilities_registerComputeWorker = __webpack_require__(44460);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js
var utilsForWorker = __webpack_require__(54285);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js
var segmentation_getOrCreateSegmentationVolume = __webpack_require__(30722);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js






const { Labelmap } = SegmentationRepresentations/* default */.A;
async function generateContourSetsFromLabelmap({ segmentations }) {
    registerComputeWorker();
    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 0);
    const { representationData, segments = [0, 1], segmentationId, } = segmentations;
    let { volumeId: segVolumeId } = representationData[Labelmap];
    if (!segVolumeId) {
        const segVolume = getOrCreateSegmentationVolume(segmentationId);
        if (segVolume) {
            segVolumeId = segVolume.volumeId;
        }
    }
    const vol = cornerstoneCache.getVolume(segVolumeId);
    if (!vol) {
        console.warn(`No volume found for ${segVolumeId}`);
        return;
    }
    const voxelManager = vol.voxelManager;
    const segScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segScalarData,
        dimensions: vol.dimensions,
        spacing: vol.imageData.getSpacing(),
        origin: vol.imageData.getOrigin(),
        direction: vol.imageData.getDirection(),
    };
    const indices = Array.isArray(segments)
        ? segments
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment)
        : Object.values(segments)
            .filter((segment) => segment !== null)
            .map((segment) => segment.segmentIndex || segment);
    const contourSets = await getWebWorkerManager().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {
        segmentation: segmentationInfo,
        indices,
        mode: 'individual',
    });
    const refImages = vol.imageIds.map((imageId) => {
        const refImageId = cache.getImage(imageId)?.referencedImageId;
        return refImageId ? cache.getImage(refImageId) : undefined;
    });
    const refImageDataMetadata = refImages.map((image) => {
        return utilities.getImageDataMetadata(image);
    });
    const processedContourSets = contourSets
        .map((contourSet) => {
        const segment = segments[contourSet.segment.segmentIndex] || {};
        if (!contourSet.sliceContours.length) {
            return null;
        }
        const p1 = contourSet.sliceContours[0].polyData.points[0];
        let refImageId;
        if (p1) {
            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {
                const { scanAxisNormal, origin } = imageDataMetadata;
                const plane = utilities.planar.planeEquation(scanAxisNormal, origin);
                return utilities.planar.isPointOnPlane(p1, plane);
            });
            if (refImageIndex !== -1) {
                refImageId = refImages[refImageIndex].imageId;
            }
        }
        return {
            label: segment.label,
            color: segment.color,
            metadata: {
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            },
            sliceContours: contourSet.sliceContours.map((contourData) => ({
                contours: contourData.contours,
                polyData: contourData.polyData,
                FrameNumber: contourData.sliceIndex + 1,
                sliceIndex: contourData.sliceIndex,
                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,
                referencedImageId: refImageId,
            })),
        };
    })
        .filter((contourSet) => contourSet !== null);
    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 100);
    return processedContourSets;
}


// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js
var RectangleROIStartEndThreshold = __webpack_require__(109);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js

function validateAnnotation(annotation) {
    if (!annotation?.data) {
        throw new Error('Tool data is empty');
    }
    if (!annotation.metadata || annotation.metadata.referencedImageId) {
        throw new Error('Tool data is not associated with any imageId');
    }
}
class AnnotationToPointData {
    static { this.TOOL_NAMES = {}; }
    constructor() {
    }
    static convert(annotation, index, metadataProvider) {
        validateAnnotation(annotation);
        const { toolName } = annotation.metadata;
        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];
        if (!toolClass) {
            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);
        }
        const ContourSequence = toolClass.getContourSequence(annotation, metadataProvider);
        const color = [
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
            Math.floor(Math.random() * 255),
        ];
        return {
            ReferencedROINumber: index + 1,
            ROIDisplayColor: color,
            ContourSequence,
        };
    }
    static register(toolClass) {
        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;
    }
}
AnnotationToPointData.register(RectangleROIStartEndThreshold/* default */.A);
/* harmony default export */ const contours_AnnotationToPointData = ((/* unused pure expression or super */ null && (AnnotationToPointData)));

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js
var getContourHolesDataWorld = __webpack_require__(55659);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js
var getContourHolesDataCanvas = __webpack_require__(15451);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js
var updateContourPolyline = __webpack_require__(72967);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js
var InterpolationManager_InterpolationManager = __webpack_require__(27740);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js

function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {
    InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);
}

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js
var findHandlePolylineIndex = __webpack_require__(98013);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js
var calculatePerimeter = __webpack_require__(93843);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/index.js















/***/ }),

/***/ 72967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ updateContourPolyline)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95527);
/* harmony import */ var _stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82056);



function updateContourPolyline(annotation, polylineData, transforms, options) {
    const { canvasToWorld, worldToCanvas } = transforms;
    const { data } = annotation;
    const { targetWindingDirection } = polylineData;
    let { points: polyline } = polylineData;
    let windingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    if (options?.decimate?.enabled) {
        polyline = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.decimate(polylineData.points, options?.decimate?.epsilon);
    }
    let { closed } = polylineData;
    const numPoints = polyline.length;
    const polylineWorldPoints = new Array(numPoints);
    const currentPolylineWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(polyline);
    const parentAnnotation = (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.getParentAnnotation)(annotation);
    if (closed === undefined) {
        let currentClosedState = false;
        if (polyline.length > 3) {
            const lastToFirstDist = _math__WEBPACK_IMPORTED_MODULE_1__.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);
            currentClosedState = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isEqual(0, lastToFirstDist);
        }
        closed = currentClosedState;
    }
    if (options?.updateWindingDirection !== false) {
        let updatedWindingDirection = parentAnnotation
            ? parentAnnotation.data.contour.windingDirection * -1
            : targetWindingDirection;
        if (updatedWindingDirection === undefined) {
            updatedWindingDirection = windingDirection;
        }
        if (updatedWindingDirection !== windingDirection) {
            polyline.reverse();
        }
        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);
        if (handlePoints.length > 2) {
            const currentHandlesWindingDirection = _math__WEBPACK_IMPORTED_MODULE_1__.polyline.getWindingDirection(handlePoints);
            if (currentHandlesWindingDirection !== updatedWindingDirection) {
                data.handles.points.reverse();
            }
        }
        windingDirection = updatedWindingDirection;
    }
    for (let i = 0; i < numPoints; i++) {
        polylineWorldPoints[i] = canvasToWorld(polyline[i]);
    }
    data.contour.polyline = polylineWorldPoints;
    data.contour.closed = closed;
    data.contour.windingDirection = windingDirection;
    (0,_stateManagement_annotation_annotationState__WEBPACK_IMPORTED_MODULE_2__.invalidateAnnotation)(annotation);
}


/***/ }),

/***/ 40634:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ getPixelValueUnitsImageId),
/* harmony export */   j: () => (/* binding */ getPixelValueUnits)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getPixelValueUnitsImageId(imageId, options) {
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);
}
function getPixelValueUnits(modality, imageId, options) {
    if (modality === 'CT') {
        return 'HU';
    }
    else if (modality === 'PT') {
        return _handlePTModality(imageId, options);
    }
    else {
        return '';
    }
}
function _handlePTModality(imageId, options) {
    if (!options.isPreScaled) {
        return 'raw';
    }
    if (options.isSuvScaled) {
        return 'SUV';
    }
    const generalSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('generalSeriesModule', imageId);
    if (generalSeriesModule?.modality === 'PT') {
        const petSeriesModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('petSeriesModule', imageId);
        return petSeriesModule?.units || 'unitless';
    }
    return 'unknown';
}



/***/ }),

/***/ 15295:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getViewportsForAnnotation)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function getViewportsForAnnotation(annotation) {
    const { metadata } = annotation;
    return (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getEnabledElements)()
        .filter((enabledElement) => {
        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
            const viewport = enabledElement.viewport;
            const { viewPlaneNormal, viewUp } = viewport.getCamera();
            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&
                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));
        }
        return;
    })
        .map((enabledElement) => enabledElement.viewport);
}


/***/ }),

/***/ 92984:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addCanvasPointsToArray: () => (/* reexport safe */ _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__.A),
/* harmony export */   containsPoint: () => (/* reexport safe */ _containsPoint__WEBPACK_IMPORTED_MODULE_1__.A),
/* harmony export */   containsPoints: () => (/* reexport safe */ _containsPoints__WEBPACK_IMPORTED_MODULE_2__.A),
/* harmony export */   decimate: () => (/* reexport safe */ _decimate__WEBPACK_IMPORTED_MODULE_11__.A),
/* harmony export */   getAABB: () => (/* reexport safe */ _getAABB__WEBPACK_IMPORTED_MODULE_3__.A),
/* harmony export */   getArea: () => (/* reexport safe */ _getArea__WEBPACK_IMPORTED_MODULE_4__.A),
/* harmony export */   getClosestLineSegmentIntersection: () => (/* reexport safe */ _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__.A),
/* harmony export */   getFirstLineSegmentIntersectionIndexes: () => (/* reexport safe */ _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__.A),
/* harmony export */   getLineSegmentIntersectionsCoordinates: () => (/* reexport safe */ _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__.A),
/* harmony export */   getLineSegmentIntersectionsIndexes: () => (/* reexport safe */ _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__.A),
/* harmony export */   getNormal2: () => (/* reexport safe */ _getNormal2__WEBPACK_IMPORTED_MODULE_8__.A),
/* harmony export */   getNormal3: () => (/* reexport safe */ _getNormal3__WEBPACK_IMPORTED_MODULE_7__.A),
/* harmony export */   getSignedArea: () => (/* reexport safe */ _getSignedArea__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   getSubPixelSpacingAndXYDirections: () => (/* reexport safe */ _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__.A),
/* harmony export */   getWindingDirection: () => (/* reexport safe */ _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__.A),
/* harmony export */   intersectPolyline: () => (/* reexport safe */ _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__.A),
/* harmony export */   isClosed: () => (/* reexport safe */ _isClosed__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   isPointInsidePolyline3D: () => (/* reexport safe */ _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__.i),
/* harmony export */   mergePolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.S),
/* harmony export */   pointCanProjectOnLine: () => (/* reexport safe */ _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__.A),
/* harmony export */   pointsAreWithinCloseContourProximity: () => (/* reexport safe */ _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__.A),
/* harmony export */   projectTo2D: () => (/* reexport safe */ _projectTo2D__WEBPACK_IMPORTED_MODULE_21__.p),
/* harmony export */   subtractPolylines: () => (/* reexport safe */ _combinePolyline__WEBPACK_IMPORTED_MODULE_9__.Y)
/* harmony export */ });
/* harmony import */ var _isClosed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19246);
/* harmony import */ var _containsPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46513);
/* harmony import */ var _containsPoints__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42436);
/* harmony import */ var _getAABB__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98122);
/* harmony import */ var _getArea__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86909);
/* harmony import */ var _getSignedArea__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63113);
/* harmony import */ var _getWindingDirection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4239);
/* harmony import */ var _getNormal3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43490);
/* harmony import */ var _getNormal2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(11377);
/* harmony import */ var _combinePolyline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(68385);
/* harmony import */ var _intersectPolyline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(405);
/* harmony import */ var _decimate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(99944);
/* harmony import */ var _getFirstLineSegmentIntersectionIndexes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(4338);
/* harmony import */ var _getLineSegmentIntersectionsIndexes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(37135);
/* harmony import */ var _getLineSegmentIntersectionsCoordinates__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(50932);
/* harmony import */ var _getClosestLineSegmentIntersection__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(32979);
/* harmony import */ var _getSubPixelSpacingAndXYDirections__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(61785);
/* harmony import */ var _pointsAreWithinCloseContourProximity__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82265);
/* harmony import */ var _addCanvasPointsToArray__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(97792);
/* harmony import */ var _pointCanProjectOnLine__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(80514);
/* harmony import */ var _isPointInsidePolyline3D__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(8361);
/* harmony import */ var _projectTo2D__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(28502);

























/***/ }),

/***/ 90554:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ findClosestPoint)
/* harmony export */ });
function findClosestPoint(sourcePoints, targetPoint) {
    let minPoint = [0, 0];
    let minDistance = Number.MAX_SAFE_INTEGER;
    sourcePoints.forEach(function (sourcePoint) {
        const distance = _distanceBetween(targetPoint, sourcePoint);
        if (distance < minDistance) {
            minDistance = distance;
            minPoint = [...sourcePoint];
        }
    });
    return minPoint;
}
function _distanceBetween(p1, p2) {
    const [x1, y1] = p1;
    const [x2, y2] = p2;
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}


/***/ }),

/***/ 27963:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ normalizeViewportPlane)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

const { isEqual } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const acquisitionMapping = {
    toIJK: (ijkPrime) => ijkPrime,
    fromIJK: (ijk) => ijk,
    type: 'acquistion',
};
const jkMapping = {
    toIJK: ([j, k, i]) => [i, j, k],
    fromIJK: ([i, j, k]) => [j, k, i],
    type: 'jk',
};
const ikMapping = {
    toIJK: ([i, k, j]) => [i, j, k],
    fromIJK: ([i, j, k]) => [i, k, j],
    type: 'ik',
};
function normalizeViewportPlane(viewport, boundsIJK) {
    if (!(viewport instanceof _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.BaseVolumeViewport)) {
        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };
    }
    const { viewPlaneNormal } = viewport.getCamera();
    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||
        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);
    if (!mapping) {
        return {
            toIJK: null,
            boundsIJKPrime: null,
            fromIJK: null,
            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,
        };
    }
    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };
}


/***/ }),

/***/ 37162:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);
/* harmony import */ var _boundingBox_extend2DBoundingBoxInViewAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76802);



function getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {
    const AllBoundsIJK = [];
    annotations.forEach((annotation) => {
        const { data } = annotation;
        const { points } = data.handles;
        const { imageData, dimensions } = referenceVolume;
        let pointsToUse = points;
        if (data.cachedStats?.projectionPoints) {
            const { projectionPoints } = data.cachedStats;
            pointsToUse = [].concat(...projectionPoints);
        }
        const rectangleCornersIJK = pointsToUse.map((world) => csUtils.transformWorldToIndex(imageData, world));
        let boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, dimensions);
        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {
            boundsIJK = extend2DBoundingBoxInViewAxis(boundsIJK, options.numSlicesToProject);
        }
        AllBoundsIJK.push(boundsIJK);
    });
    if (AllBoundsIJK.length === 1) {
        return AllBoundsIJK[0];
    }
    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {
        return {
            iMin: Math.min(accumulator.iMin, currentValue.iMin),
            jMin: Math.min(accumulator.jMin, currentValue.jMin),
            kMin: Math.min(accumulator.kMin, currentValue.kMin),
            iMax: Math.max(accumulator.iMax, currentValue.iMax),
            jMax: Math.max(accumulator.jMax, currentValue.jMax),
            kMax: Math.max(accumulator.kMax, currentValue.kMax),
        };
    }, {
        iMin: Infinity,
        jMin: Infinity,
        kMin: Infinity,
        iMax: -Infinity,
        jMax: -Infinity,
        kMax: -Infinity,
    });
    return boundsIJK;
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (getBoundsIJKFromRectangleAnnotations)));


/***/ }),

/***/ 44460:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ registerComputeWorker)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36625);


let registered = false;
function registerComputeWorker() {
    if (registered) {
        return;
    }
    registered = true;
    const workerFn = () => {
        return new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(3694), __webpack_require__.b), {
            name: 'compute',
            type: undefined,
        });
    };
    const workerManager = (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)();
    const config = (0,_config__WEBPACK_IMPORTED_MODULE_1__/* .getConfig */ .zj)();
    const computeWorkerConfig = config.computeWorker;
    const options = {
        maxWorkerInstances: 1,
        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {
            enabled: true,
            idleTimeThreshold: 2000,
        },
    };
    workerManager.registerWorker('compute', workerFn, options);
}


/***/ }),

/***/ 27740:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ InterpolationManager)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47807);
/* harmony import */ var _contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51893);
/* harmony import */ var _contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(73816);
/* harmony import */ var _deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56229);
/* harmony import */ var _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75183);
/* harmony import */ var _getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40133);
/* harmony import */ var _contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85263);








const { uuidv4 } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const ChangeTypesForInterpolation = [
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.HandlesUpdated,
    _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.InterpolationUpdated,
];
class InterpolationManager {
    static { this.toolNames = []; }
    static addTool(toolName) {
        if (!this.toolNames.includes(toolName)) {
            this.toolNames.push(toolName);
        }
    }
    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {
        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;
        for (const toolName of toolNames || InterpolationManager.toolNames) {
            const annotations = _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__.state.getAnnotations(toolName, annotationGroupSelector);
            if (!annotations?.length) {
                continue;
            }
            for (const annotation of annotations) {
                const { interpolationUID, data, autoGenerated, metadata } = annotation;
                if (interpolationUID) {
                    annotation.interpolationCompleted = true;
                }
                if (!autoGenerated) {
                    continue;
                }
                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
                    continue;
                }
                if (sliceIndex !== undefined &&
                    metadata &&
                    sliceIndex !== metadata.sliceIndex) {
                    continue;
                }
                if (segmentationId &&
                    segmentationId !== data.segmentation.segmentationId) {
                    continue;
                }
                (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__/* .addContourSegmentationAnnotation */ .V)(annotation);
                annotation.autoGenerated = false;
            }
        }
    }
    static { this.handleAnnotationCompleted = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn('Unable to find viewport for', annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        const hasInterpolationUID = !!annotation.interpolationUID;
        annotation.autoGenerated = false;
        if (hasInterpolationUID) {
            (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportData);
            (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
            return;
        }
        const filterData = [
            {
                key: 'segmentIndex',
                value: annotation.data.segmentation.segmentIndex,
                parentKey: (annotation) => annotation.data.segmentation,
            },
            {
                key: 'viewPlaneNormal',
                value: annotation.metadata.viewPlaneNormal,
                parentKey: (annotation) => annotation.metadata,
            },
            {
                key: 'viewUp',
                value: annotation.metadata.viewUp,
                parentKey: (annotation) => annotation.metadata,
            },
        ];
        let interpolationAnnotations = (0,_contours_interpolation_getInterpolationDataCollection__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(viewportData, filterData);
        const { sliceIndex } = annotation.metadata;
        const skipUIDs = new Set();
        interpolationAnnotations.forEach((interpolationAnnotation) => {
            if (interpolationAnnotation.interpolationCompleted ||
                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {
                const { interpolationUID } = interpolationAnnotation;
                skipUIDs.add(interpolationUID);
            }
        });
        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));
        annotation.interpolationUID =
            interpolationAnnotations[0]?.interpolationUID || uuidv4();
        viewportData.interpolationUID = annotation.interpolationUID;
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
    }; }
    static { this.handleAnnotationUpdate = (evt) => {
        const annotation = evt.detail.annotation;
        const { changeType = _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.HandlesUpdated } = evt.detail;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName, originalToolName } = annotation.metadata;
        if ((!this.toolNames.includes(toolName) &&
            !this.toolNames.includes(originalToolName)) ||
            !ChangeTypesForInterpolation.includes(changeType)) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn('Unable to find matching viewport for annotation interpolation', annotation);
            return;
        }
        if (annotation.autoGenerated) {
            (0,_contourSegmentation_addContourSegmentationAnnotation__WEBPACK_IMPORTED_MODULE_7__/* .addContourSegmentationAnnotation */ .V)(annotation);
            annotation.autoGenerated = false;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
            isInterpolationUpdate: changeType === _enums_ChangeTypes__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.InterpolationUpdated,
        };
        (0,_contours_interpolation_interpolate__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(viewportData);
    }; }
    static { this.handleAnnotationDelete = (evt) => {
        const annotation = evt.detail.annotation;
        if (!annotation?.metadata) {
            return;
        }
        const { toolName } = annotation.metadata;
        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {
            return;
        }
        const viewport = (0,_getViewportForAnnotation__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(annotation);
        if (!viewport) {
            console.warn("No viewport, can't delete interpolated results", annotation);
            return;
        }
        const sliceData = getSliceData(viewport);
        const viewportData = {
            viewport,
            sliceData,
            annotation,
            interpolationUID: annotation.interpolationUID,
        };
        annotation.autoGenerated = false;
        (0,_deleteRelatedAnnotations__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(viewportData);
    }; }
}
function getSliceData(viewport) {
    const sliceData = {
        numberOfSlices: viewport.getNumberOfSlices(),
        imageIndex: viewport.getCurrentImageIdIndex(),
    };
    return sliceData;
}


/***/ }),

/***/ 68915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   C3: () => (/* binding */ InstanceVolumetricCalculator)
/* harmony export */ });
/* unused harmony export VolumetricCalculator */
/* harmony import */ var _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69013);
/* harmony import */ var _getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4096);


const TEST_MAX_LOCATIONS = 10;
function createVolumetricState() {
    return {
        maxIJKs: [],
    };
}
function volumetricStatsCallback(state, data) {
    const { value } = data;
    const { maxIJKs } = state;
    const length = maxIJKs.length;
    if (typeof value !== 'number' ||
        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {
        return;
    }
    const dataCopy = {
        value: data.value,
        pointLPS: data.pointLPS
            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]
            : undefined,
        pointIJK: data.pointIJK
            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]
            : undefined,
    };
    if (!length || value >= maxIJKs[length - 1].value) {
        maxIJKs.push(dataCopy);
    }
    else {
        for (let i = 0; i < length; i++) {
            if (value <= maxIJKs[i].value) {
                maxIJKs.splice(i, 0, dataCopy);
                break;
            }
        }
    }
    if (length >= TEST_MAX_LOCATIONS) {
        maxIJKs.splice(0, 1);
    }
}
function volumetricGetStatistics(state, stats, options) {
    const { spacing, calibration } = options;
    const { volumeUnit } = (0,_getCalibratedUnits__WEBPACK_IMPORTED_MODULE_1__/* .getCalibratedLengthUnitsAndScale */ .Op)({
        calibration,
        hasPixelSpacing: true,
    }, []);
    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] * 1000 : 1;
    stats.volume = {
        value: Array.isArray(stats.count.value)
            ? stats.count.value.map((v) => v * volumeScale)
            : stats.count.value * volumeScale,
        unit: volumeUnit,
        name: 'volume',
        label: 'Volume',
    };
    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);
    stats.array.push(stats.volume);
    state.maxIJKs = [];
    return stats;
}
class VolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__/* .BasicStatsCalculator */ .O {
    static { this.volumetricState = createVolumetricState(); }
    static statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    static statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    static getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
class InstanceVolumetricCalculator extends _math_basic_BasicStatsCalculator__WEBPACK_IMPORTED_MODULE_0__/* .InstanceBasicStatsCalculator */ .B {
    constructor(options) {
        super(options);
        this.volumetricState = createVolumetricState();
    }
    statsInit(options) {
        super.statsInit(options);
        this.volumetricState = createVolumetricState();
    }
    statsCallback(data) {
        super.statsCallback(data);
        volumetricStatsCallback(this.volumetricState, data);
    }
    getStatistics(options) {
        const optionsWithUnit = {
            ...options,
            unit: options?.unit || 'none',
            calibration: options?.calibration,
            hasPixelSpacing: options?.hasPixelSpacing,
        };
        const stats = super.getStatistics(optionsWithUnit);
        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VolumetricCalculator);


/***/ }),

/***/ 17014:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports setBrushSizeForToolGroup, getBrushSizeForToolGroup */
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15327);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14957);




function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {
    const toolGroup = getToolGroup(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);
    brushBasedToolInstances.forEach((tool) => {
        tool.configuration.brushSize = brushSize;
        tool.invalidateBrushCursor();
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);
    if (!viewportsInfoArray.length) {
        return;
    }
    const { renderingEngineId } = viewportsInfoArray[0];
    const viewportIds = toolGroup.getViewportIds();
    const renderingEngine = getRenderingEngine(renderingEngineId);
    triggerAnnotationRenderForViewportIds(viewportIds);
}
function getBrushSizeForToolGroup(toolGroupId, toolName) {
    const toolGroup = getToolGroup(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.brushSize;
}


/***/ }),

/***/ 49492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports setBrushThresholdForToolGroup, getBrushThresholdForToolGroup */
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77609);
/* harmony import */ var _triggerAnnotationRenderForViewportIds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58640);
/* harmony import */ var _getBrushToolInstances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14957);



function setBrushThresholdForToolGroup(toolGroupId, threshold) {
    const toolGroup = getToolGroup(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);
    brushBasedToolInstances.forEach((tool) => {
        const activeStrategy = tool.configuration.activeStrategy;
        if (!activeStrategy.toLowerCase().includes('threshold')) {
            return;
        }
        tool.configuration = {
            ...tool.configuration,
            threshold: {
                ...tool.configuration.threshold,
                ...threshold,
            },
        };
    });
    const viewportsInfo = toolGroup.getViewportsInfo();
    if (!viewportsInfo.length) {
        return;
    }
    const viewportIds = toolGroup.getViewportIds();
    triggerAnnotationRenderForViewportIds(viewportIds);
}
function getBrushThresholdForToolGroup(toolGroupId) {
    const toolGroup = getToolGroup(toolGroupId);
    if (toolGroup === undefined) {
        return;
    }
    const toolInstances = toolGroup._toolInstances;
    if (!Object.keys(toolInstances).length) {
        return;
    }
    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);
    const brushToolInstance = brushBasedToolInstances[0];
    if (!brushToolInstance) {
        return;
    }
    return brushToolInstance.configuration.threshold.range;
}


/***/ }),

/***/ 88274:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: computeMetabolicStats

// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/core/dist/esm/index.js + 1 modules
var esm = __webpack_require__(15327);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js
var utilsForWorker = __webpack_require__(54285);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/enums/index.js + 2 modules
var enums = __webpack_require__(99737);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js
var utilities_registerComputeWorker = __webpack_require__(44460);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js
var segmentation_createMergedLabelmapForIndex = __webpack_require__(4334);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js
var segmentation_getSegmentation = __webpack_require__(33283);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js
var segmentation_getOrCreateSegmentationVolume = __webpack_require__(30722);
// EXTERNAL MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js
var segmentation_getOrCreateImageVolume = __webpack_require__(83075);
;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js



function getReferenceVolumeForSegmentation_getReferenceVolumeForSegmentation(segmentationId) {
    const segmentation = getSegmentation(segmentationId);
    if (!segmentation) {
        return null;
    }
    let referenceImageIds;
    const labelmap = segmentation.representationData.Labelmap;
    if ('imageIds' in labelmap) {
        const { imageIds } = labelmap;
        const firstImage = cache.getImage(imageIds[0]);
        const volumeInfo = cache.getVolumeContainingImageId(firstImage.referencedImageId);
        if (volumeInfo?.volume) {
            return volumeInfo.volume;
        }
        referenceImageIds = imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);
    }
    else if ('volumeId' in labelmap) {
        const { volumeId, referencedVolumeId } = labelmap;
        if (referencedVolumeId) {
            const refVolume = cache.getVolume(referencedVolumeId);
            if (refVolume) {
                return refVolume;
            }
        }
        const segVolume = cache.getVolume(volumeId);
        if (segVolume) {
            referenceImageIds = segVolume.imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);
        }
    }
    return getOrCreateImageVolume(referenceImageIds);
}

;// CONCATENATED MODULE: ../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js








async function computeMetabolicStats({ segmentationIds, segmentIndex, }) {
    registerComputeWorker();
    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);
    const segmentation = getSegmentation(segmentationIds[0]);
    const { imageIds: segImageIds } = segmentation.representationData
        .Labelmap;
    const isValidVolume = utilities.isValidVolume(segImageIds);
    if (!isValidVolume) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const stats = await calculateForVolume({
        segmentationIds,
        segmentIndex,
    });
    return stats;
}
async function calculateForVolume({ segmentationIds, segmentIndex }) {
    const labelmapVolumes = segmentationIds.map((id) => {
        return getOrCreateSegmentationVolume(id);
    });
    const mergedLabelmap = createMergedLabelmapForIndex(labelmapVolumes, segmentIndex);
    if (!mergedLabelmap) {
        throw new Error('Invalid volume - TMTV cannot be calculated');
    }
    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;
    const spacing = imageData.getSpacing();
    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions,
        spacing,
        origin,
        direction,
    };
    const referenceVolume = getReferenceVolumeForSegmentation(segmentationIds[0]);
    const imageInfo = {
        dimensions: referenceVolume.dimensions,
        spacing: referenceVolume.spacing,
        origin: referenceVolume.origin,
        direction: referenceVolume.direction,
        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),
    };
    if (imageInfo.scalarData.length === 0 ||
        segmentationInfo.scalarData.length === 0) {
        return {
            [segmentIndex]: {
                name: 'TMTV',
                value: 0,
            },
        };
    }
    const stats = await getWebWorkerManager().executeTask('compute', 'computeMetabolicStats', {
        segmentationInfo,
        imageInfo,
    });
    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);
    return stats;
}



/***/ }),

/***/ 13276:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _contours__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54889);
/* harmony import */ var _findLargestBidirectional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60199);
/* harmony import */ var _getOrCreateSegmentationVolume__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30722);



async function contourAndFindLargestBidirectional(segmentation) {
    const contours = await generateContourSetsFromLabelmap({
        segmentations: segmentation,
    });
    if (!contours?.length || !contours[0].sliceContours.length) {
        return;
    }
    const { segments = [
        null,
        { label: 'Unspecified', color: null, containedSegmentIndices: null },
    ], } = segmentation;
    const vol = getOrCreateSegmentationVolume(segmentation.segmentationId);
    if (!vol) {
        return;
    }
    const segmentIndex = segments.findIndex((it) => !!it);
    if (segmentIndex === -1) {
        return;
    }
    segments[segmentIndex].segmentIndex = segmentIndex;
    return findLargestBidirectional(contours[0], vol.volumeId, segments[segmentIndex]);
}


/***/ }),

/***/ 14514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
function createBidirectionalToolData(bidirectionalData, viewport) {
    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;
    const [major0, major1] = majorAxis;
    const [minor0, minor1] = minorAxis;
    const points = [major0, major1, minor0, minor1];
    const bidirectionalToolData = {
        highlighted: true,
        invalidated: true,
        metadata: {
            toolName: 'Bidirectional',
            ...viewport.getViewReference({ sliceIndex }),
        },
        data: {
            handles: {
                points,
                textBox: {
                    hasMoved: false,
                    worldPosition: [0, 0, 0],
                    worldBoundingBox: {
                        topLeft: [0, 0, 0],
                        topRight: [0, 0, 0],
                        bottomLeft: [0, 0, 0],
                        bottomRight: [0, 0, 0],
                    },
                },
                activeHandleIndex: null,
            },
            label,
            cachedStats: {},
        },
        isLocked: false,
        isVisible: true,
    };
    return bidirectionalToolData;
}


/***/ }),

/***/ 2397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLabelmapMemo: () => (/* binding */ createLabelmapMemo)
/* harmony export */ });
/* unused harmony exports restoreMemo, createRleMemo */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49906);
/* harmony import */ var _enums_Events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94021);



const { VoxelManager, RLEVoxelMap } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
function createLabelmapMemo(segmentationId, segmentationVoxelManager) {
    return createRleMemo(segmentationId, segmentationVoxelManager);
}
function restoreMemo(isUndo) {
    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;
    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;
    useVoxelManager.forEach(({ value, pointIJK }) => {
        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);
    });
    const slices = useVoxelManager.getArrayOfModifiedSlices();
    (0,_stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_1__.triggerSegmentationDataModified)(this.segmentationId, slices);
}
function createRleMemo(segmentationId, segmentationVoxelManager) {
    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    const state = {
        segmentationId,
        restoreMemo,
        commitMemo,
        segmentationVoxelManager,
        voxelManager,
        id: _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.uuidv4(),
        operationType: 'labelmap',
    };
    return state;
}
function commitMemo() {
    if (this.redoVoxelManager) {
        return true;
    }
    if (!this.voxelManager.modifiedSlices.size) {
        return false;
    }
    const { segmentationVoxelManager } = this;
    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);
    for (const key of this.voxelManager.modifiedSlices.keys()) {
        undoVoxelManager.modifiedSlices.add(key);
    }
    this.undoVoxelManager = undoVoxelManager;
    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({
        dimensions: this.segmentationVoxelManager.dimensions,
    });
    this.redoVoxelManager = redoVoxelManager;
    undoVoxelManager.forEach(({ index, pointIJK, value }) => {
        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);
        if (currentValue === value) {
            return;
        }
        redoVoxelManager.setAtIndex(index, currentValue);
    });
    return true;
}


/***/ }),

/***/ 97492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export default */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

async function createLabelmapVolumeForViewport(input) {
    const { viewportId, renderingEngineId, options } = input;
    let { segmentationId } = input;
    const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);
    if (!enabledElement) {
        throw new Error('element disabled');
    }
    const { viewport } = enabledElement;
    if (!(viewport instanceof VolumeViewport)) {
        throw new Error('Segmentation only supports VolumeViewport');
    }
    const { uid } = viewport.getDefaultActor();
    if (segmentationId === undefined) {
        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? csUtils.uuidv4().slice(0, 8)}`;
    }
    if (options) {
        const properties = structuredClone(options);
        await volumeLoader.createLocalVolume(segmentationId, properties);
    }
    else {
        const volumeId = viewport.getVolumeId();
        volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {
            volumeId: segmentationId,
        });
    }
    return segmentationId;
}


/***/ }),

/***/ 4334:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {
    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {
        if (!csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||
            !csUtils.isEqual(direction, labelmaps[0].direction) ||
            !csUtils.isEqual(spacing, labelmaps[0].spacing) ||
            !csUtils.isEqual(origin, labelmaps[0].origin)) {
            throw new Error('labelmaps must have the same size and shape');
        }
    });
    const labelmap = labelmaps[0];
    const arrayType = labelmap.voxelManager.getConstructor();
    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());
    labelmaps.forEach((labelmap) => {
        const voxelManager = labelmap.voxelManager;
        const scalarDataLength = voxelManager.getScalarDataLength();
        for (let i = 0; i < scalarDataLength; i++) {
            if (voxelManager.getAtIndex(i) === segmentIndex) {
                outputData[i] = segmentIndex;
            }
        }
    });
    const options = {
        scalarData: outputData,
        metadata: labelmap.metadata,
        spacing: labelmap.spacing,
        origin: labelmap.origin,
        direction: labelmap.direction,
        dimensions: labelmap.dimensions,
    };
    const cachedVolume = cache.getVolume(volumeId);
    let mergedVolume;
    if (cachedVolume) {
        mergedVolume = cachedVolume;
        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);
    }
    else {
        mergedVolume = volumeLoader.createLocalVolume(volumeId, options);
    }
    return mergedVolume;
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (createMergedLabelmapForIndex)));


/***/ }),

/***/ 83075:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getOrCreateImageVolume(referencedImageIds) {
    if (!referencedImageIds || referencedImageIds.length <= 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(referencedImageIds);
    if (!isValidVolume) {
        return;
    }
    const volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(referencedImageIds);
    let imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
    if (imageVolume) {
        return imageVolume;
    }
    imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);
    return imageVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateImageVolume);


/***/ }),

/***/ 30722:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33283);


function getOrCreateSegmentationVolume(segmentationId) {
    const { representationData } = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentation */ .T)(segmentationId);
    let { volumeId } = representationData.Labelmap;
    let segVolume;
    if (volumeId) {
        segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(volumeId);
        if (segVolume) {
            return segVolume;
        }
    }
    const { imageIds: labelmapImageIds } = representationData.Labelmap;
    volumeId = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.generateVolumeId(labelmapImageIds);
    if (!labelmapImageIds || labelmapImageIds.length === 1) {
        return;
    }
    const isValidVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(labelmapImageIds);
    if (!isValidVolume) {
        return;
    }
    segVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);
    return segVolume;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getOrCreateSegmentationVolume);


/***/ }),

/***/ 12853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ getReferenceVolumeForSegmentationVolume)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {
    const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationVolumeId);
    if (!segmentationVolume) {
        return null;
    }
    const referencedVolumeId = segmentationVolume.referencedVolumeId;
    let imageVolume;
    if (referencedVolumeId) {
        imageVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(referencedVolumeId);
    }
    else {
        const imageIds = segmentationVolume.imageIds;
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        const referencedImageId = image.referencedImageId;
        const volumeInfo = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolumeContainingImageId(referencedImageId);
        imageVolume = volumeInfo?.volume;
    }
    return imageVolume;
}


/***/ }),

/***/ 78773:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export getSegmentLargestBidirectional */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44460);
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54285);




async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {
    registerComputeWorker();
    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);
    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segImageIds, reconstructableVolume, indices } = segData;
    const bidirectionalData = reconstructableVolume
        ? await calculateVolumeBidirectional({
            operationData,
            indices,
            mode,
        })
        : await calculateStackBidirectional({
            segImageIds,
            indices,
            mode,
        });
    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);
    return bidirectionalData;
}
async function calculateVolumeBidirectional({ operationData, indices, mode }) {
    const strategyData = prepareVolumeStrategyDataForWorker(operationData);
    const { segmentationVoxelManager, segmentationImageData } = strategyData;
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
    });
    return bidirectionalData;
}
async function calculateStackBidirectional({ segImageIds, indices, mode }) {
    const { segmentationInfo } = prepareStackDataForWorker(segImageIds);
    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {
        segmentationInfo,
        indices,
        mode,
        isStack: true,
    });
    return bidirectionalData;
}


/***/ }),

/***/ 38440:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _utilsForWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54285);
/* harmony import */ var _getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40634);
/* harmony import */ var _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68915);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99737);
/* harmony import */ var _registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44460);






const radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);
async function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {
    (0,_registerComputeWorker__WEBPACK_IMPORTED_MODULE_5__/* .registerComputeWorker */ .D)();
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const segData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .getSegmentationDataForWorker */ .yR)(segmentationId, segmentIndices);
    if (!segData) {
        return;
    }
    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;
    const { refImageId, modalityUnitOptions } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .getImageReferenceInfo */ .FI)(segVolumeId, segImageIds);
    const unit = (0,_getPixelValueUnits__WEBPACK_IMPORTED_MODULE_2__/* .getPixelValueUnitsImageId */ .N)(refImageId, modalityUnitOptions);
    const stats = reconstructableVolume
        ? await calculateVolumeStatistics({
            operationData,
            indices,
            unit,
            mode,
        })
        : await calculateStackStatistics({
            segImageIds,
            indices,
            unit,
            mode,
        });
    return stats;
}
async function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {
    const strategyData = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .prepareVolumeStrategyDataForWorker */ .o9)(operationData);
    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;
    if (!segmentationVoxelManager || !segmentationImageData) {
        return;
    }
    const spacing = segmentationImageData.getSpacing();
    const { boundsIJK: boundsOrig } = segmentationVoxelManager;
    if (!boundsOrig) {
        return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.getStatistics({ spacing });
    }
    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();
    const segmentationInfo = {
        scalarData: segmentationScalarData,
        dimensions: segmentationImageData.getDimensions(),
        spacing: segmentationImageData.getSpacing(),
        origin: segmentationImageData.getOrigin(),
        direction: segmentationImageData.getDirection(),
    };
    const imageInfo = {
        scalarData: imageVoxelManager.getCompleteScalarDataArray(),
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
    if (!imageInfo.scalarData?.length) {
        return;
    }
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsVolume', {
        segmentationInfo,
        imageInfo,
        indices,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
const updateStatsArray = (stats, newStat) => {
    if (!stats.array) {
        return;
    }
    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);
    if (existingIndex !== -1) {
        stats.array[existingIndex] = newStat;
    }
    else {
        stats.array.push(newStat);
    }
};
const processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {
    stats.mean.unit = unit;
    stats.max.unit = unit;
    stats.min.unit = unit;
    if (unit !== 'SUV') {
        return stats;
    }
    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));
    for (const testMax of stats.maxIJKs) {
        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);
        if (!testStats) {
            continue;
        }
        const { mean } = testStats;
        if (!stats.peakValue || stats.peakValue.value <= mean.value) {
            stats.peakValue = {
                name: 'peakValue',
                label: 'Peak Value',
                value: mean.value,
                unit,
            };
            stats.peakPoint = {
                name: 'peakLPS',
                label: 'Peak SUV Point',
                value: testMax.pointLPS ? [...testMax.pointLPS] : null,
                unit: null,
            };
            updateStatsArray(stats, stats.peakValue);
            updateStatsArray(stats, stats.peakPoint);
        }
    }
    if (stats.volume && stats.mean) {
        const mtv = stats.volume.value;
        const suvMean = stats.mean.value;
        stats.lesionGlycolysis = {
            name: 'lesionGlycolysis',
            label: 'Lesion Glycolysis',
            value: mtv * suvMean,
            unit: `${stats.volume.unit}·${unit}`,
        };
        updateStatsArray(stats, stats.lesionGlycolysis);
    }
    return stats;
};
async function calculateStackStatistics({ segImageIds, indices, unit, mode }) {
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 0);
    const { segmentationInfo, imageInfo } = (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .prepareStackDataForWorker */ .Dn)(segImageIds);
    const stats = await (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.getWebWorkerManager)().executeTask('compute', 'calculateSegmentsStatisticsStack', {
        segmentationInfo,
        imageInfo,
        indices,
        mode,
    });
    (0,_utilsForWorker__WEBPACK_IMPORTED_MODULE_1__/* .triggerWorkerProgress */ .sg)(_enums__WEBPACK_IMPORTED_MODULE_4__.WorkerTypes.COMPUTE_STATISTICS, 100);
    const spacing = segmentationInfo[0].spacing;
    const segmentationImageData = segmentationInfo[0];
    const imageVoxelManager = imageInfo[0].voxelManager;
    if (mode === 'collective') {
        return processSegmentationStatistics({
            stats,
            unit,
            spacing,
            segmentationImageData,
            imageVoxelManager,
        });
    }
    else {
        const finalStats = {};
        Object.entries(stats).forEach(([segmentIndex, stat]) => {
            finalStats[segmentIndex] = processSegmentationStatistics({
                stats: stat,
                unit,
                spacing,
                segmentationImageData,
                imageVoxelManager,
            });
        });
        return finalStats;
    }
}
function getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {
    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;
    if (!centerIJK) {
        return;
    }
    const boundsIJK = centerIJK.map((ijk, idx) => [
        ijk - radiusIJK[idx],
        ijk + radiusIJK[idx],
    ]);
    const testFunction = (_pointLPS, pointIJK) => {
        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];
        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];
        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];
        const radius = i * i + j * j + k * k;
        return radius <= 1;
    };
    const statsFunction = ({ pointIJK, pointLPS }) => {
        const value = imageVoxels.getAtIJKPoint(pointIJK);
        if (value === undefined) {
            return;
        }
        _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.statsCallback({ value, pointLPS, pointIJK });
    };
    _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.statsInit({ storePointData: false });
    _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.pointInShapeCallback(segData, {
        pointInShapeFn: testFunction,
        callback: statsFunction,
        boundsIJK,
    });
    return _VolumetricCalculator__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.getStatistics({ spacing });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getStatistics);


/***/ }),

/***/ 25758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ getUniqueSegmentIndices)
/* harmony export */ });
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99737);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64063);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33283);




function getUniqueSegmentIndices(segmentationId) {
    const cachedResult = (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .getCachedSegmentIndices */ .R1)(segmentationId);
    if (cachedResult) {
        return cachedResult;
    }
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_3__/* .getSegmentation */ .T)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
    }
    let indices;
    if (segmentation.representationData.Labelmap) {
        indices = handleLabelmapSegmentation(segmentation, segmentationId);
    }
    else if (segmentation.representationData.Contour) {
        indices = handleContourSegmentation(segmentation);
    }
    else if (segmentation.representationData.Surface) {
        indices = handleSurfaceSegmentation(segmentation);
    }
    else {
        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);
    }
    (0,_utilities__WEBPACK_IMPORTED_MODULE_2__/* .setCachedSegmentIndices */ .Dm)(segmentationId, indices);
    return indices;
}
function handleLabelmapSegmentation(segmentation, segmentationId) {
    const labelmapData = segmentation.representationData[_enums__WEBPACK_IMPORTED_MODULE_1__.SegmentationRepresentations.Labelmap];
    const keySet = new Set();
    if (labelmapData.imageIds) {
        addImageSegmentIndices(keySet, labelmapData.imageIds);
    }
    else {
        addVolumeSegmentIndices(keySet, segmentationId);
    }
    return Array.from(keySet)
        .map(Number)
        .sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
    const volume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segmentationId);
    volume.voxelManager.forEach(({ value }) => {
        if (value !== 0) {
            keySet.add(value);
        }
    });
}
function addImageSegmentIndices(keySet, imageIds) {
    imageIds.forEach((segmentationImageId) => {
        const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segmentationImageId);
        const scalarData = image.voxelManager.getScalarData();
        scalarData.forEach((segmentIndex) => {
            if (segmentIndex !== 0) {
                keySet.add(segmentIndex);
            }
        });
    });
}
function handleContourSegmentation(segmentation) {
    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};
    if (!geometryIds) {
        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
    }
    const indices = new Set([...annotationUIDsMap.keys()]);
    geometryIds.forEach((geometryId) => {
        const geometry = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getGeometry(geometryId);
        indices.add(geometry.data.segmentIndex);
    });
    return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];
    return Array.from(geometryIds.keys())
        .map(Number)
        .sort((a, b) => a - b);
}



/***/ }),

/***/ 67912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ IslandRemoval)
/* harmony export */ });
/* unused harmony export SegmentationEnum */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27963);


const { RLEVoxelMap, VoxelManager } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities;
const MAX_IMAGE_SIZE = 65535;
var SegmentationEnum;
(function (SegmentationEnum) {
    SegmentationEnum[SegmentationEnum["SEGMENT"] = -1] = "SEGMENT";
    SegmentationEnum[SegmentationEnum["ISLAND"] = -2] = "ISLAND";
    SegmentationEnum[SegmentationEnum["INTERIOR"] = -3] = "INTERIOR";
    SegmentationEnum[SegmentationEnum["EXTERIOR"] = -4] = "EXTERIOR";
    SegmentationEnum[SegmentationEnum["INTERIOR_SMALL"] = -5] = "INTERIOR_SMALL";
    SegmentationEnum[SegmentationEnum["INTERIOR_TEST"] = -6] = "INTERIOR_TEST";
})(SegmentationEnum || (SegmentationEnum = {}));
class IslandRemoval {
    constructor(options) {
        this.fillInternalEdge = false;
        this.maxInternalRemove = 128;
        this.maxInternalRemove =
            options?.maxInternalRemove ?? this.maxInternalRemove;
        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;
    }
    initialize(viewport, segmentationVoxels, options) {
        const hasSource = !!segmentationVoxels.sourceVoxelManager;
        const segmentationVoxelManager = hasSource
            ? segmentationVoxels.sourceVoxelManager
            : segmentationVoxels;
        const previewVoxelManager = hasSource
            ? segmentationVoxels
            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);
        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;
        const clickedPoints = options.points || segmentationVoxelManager.getPoints();
        if (!clickedPoints?.length) {
            return;
        }
        const boundsIJK = segmentationVoxelManager
            .getBoundsIJK()
            .map((bound, i) => [
            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),
            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),
        ]);
        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {
            return;
        }
        const { toIJK, fromIJK, boundsIJKPrime, error } = (0,_normalizeViewportPlane__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(viewport, boundsIJK);
        if (error) {
            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);
            return;
        }
        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);
        const segmentSet = new RLEVoxelMap(width, height, depth);
        const getter = (i, j, k) => {
            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));
            const oldVal = segmentationVoxelManager.getAtIndex(index);
            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {
                return SegmentationEnum.SEGMENT;
            }
        };
        segmentSet.fillFrom(getter, boundsIJKPrime);
        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };
        this.segmentSet = segmentSet;
        this.previewVoxelManager = previewVoxelManager;
        this.segmentIndex = segmentIndex;
        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;
        this.selectedPoints = clickedPoints;
        return true;
    }
    floodFillSegmentIsland() {
        const { selectedPoints: clickedPoints, segmentSet } = this;
        let floodedCount = 0;
        const { fromIJK } = segmentSet.normalizer;
        clickedPoints.forEach((clickedPoint) => {
            const ijkPrime = fromIJK(clickedPoint);
            const index = segmentSet.toIndex(ijkPrime);
            const [iPrime, jPrime, kPrime] = ijkPrime;
            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {
                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);
            }
        });
        return floodedCount;
    }
    removeExternalIslands() {
        const { previewVoxelManager, segmentSet } = this;
        const { toIJK } = segmentSet.normalizer;
        const callback = (index, rle) => {
            const [, jPrime, kPrime] = segmentSet.toIJK(index);
            if (rle.value !== SegmentationEnum.ISLAND) {
                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);
                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);
                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);
                }
            }
        };
        segmentSet.forEach(callback, { rowModified: true });
    }
    removeInternalIslands() {
        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;
        const { height, normalizer, width } = segmentSet;
        const { toIJK } = normalizer;
        segmentSet.forEachRow((baseIndex, row) => {
            let lastRle;
            for (const rle of [...row]) {
                if (rle.value !== SegmentationEnum.ISLAND) {
                    continue;
                }
                if (!lastRle) {
                    if (this.fillInternalEdge && rle.start > 0) {
                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {
                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                        }
                    }
                    lastRle = rle;
                    continue;
                }
                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
                lastRle = rle;
            }
            if (this.fillInternalEdge && lastRle?.end < width) {
                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {
                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);
                }
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;
            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;
            const isLast = jPrime === height - 1;
            const isFirst = jPrime === 0;
            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||
                (isFirst && this.fillInternalEdge);
            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);
            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {
                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });
            }
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR) {
                return;
            }
            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);
            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);
            const isBig = size > this.maxInternalRemove;
            const newType = isBig
                ? SegmentationEnum.EXTERIOR
                : SegmentationEnum.INTERIOR_SMALL;
            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);
        });
        segmentSet.forEach((baseIndex, rle) => {
            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {
                return;
            }
            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {
                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));
                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);
            }
        });
        return previewVoxelManager.getArrayOfModifiedSlices();
    }
    static covers(rle, row) {
        if (!row) {
            return false;
        }
        let { start } = rle;
        const { end } = rle;
        for (const rowRle of row) {
            if (start >= rowRle.start && start < rowRle.end) {
                start = rowRle.end;
                if (start >= end) {
                    return true;
                }
            }
        }
        return false;
    }
}


/***/ }),

/***/ 52323:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47807);
/* harmony import */ var _tools_segmentation_RectangleROIStartEndThresholdTool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67847);
/* harmony import */ var _tools_segmentation_RectangleROIThresholdTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40336);
/* harmony import */ var _thresholdVolumeByRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8582);
/* harmony import */ var _rectangleROITool_getBoundsIJKFromRectangleAnnotations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37162);





function rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {
    const annotations = annotationUIDs.map((annotationUID) => {
        return state.getAnnotation(annotationUID);
    });
    _validateAnnotations(annotations);
    let boundsIJK;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||
            i === 0) {
            boundsIJK = getBoundsIJKFromRectangleAnnotations(annotations, thresholdVolumeInformation[i].volume, options);
        }
    }
    const outputSegmentationVolume = thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });
    outputSegmentationVolume.modified();
    return outputSegmentationVolume;
}
function _validateAnnotations(annotations) {
    const validToolNames = [
        RectangleROIThresholdTool.toolName,
        RectangleROIStartEndThresholdTool.toolName,
    ];
    for (const annotation of annotations) {
        const name = annotation.metadata.toolName;
        if (!validToolNames.includes(name)) {
            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');
        }
    }
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (rectangleROIThresholdVolumeByRange)));


/***/ }),

/***/ 22592:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, defaultGetSegment */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_annotation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47807);
/* harmony import */ var _contourAndFindLargestBidirectional__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13276);
/* harmony import */ var _createBidirectionalToolData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14514);
/* harmony import */ var _tools_annotation_BidirectionalTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25072);
/* harmony import */ var _stateManagement_segmentation_getSegmentations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70758);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60740);







async function segmentContourAction(element, configuration) {
    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');
    const { data: configurationData } = configuration;
    const enabledElement = getEnabledElement(element);
    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);
    if (!segment) {
        return;
    }
    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();
    const segmentationsList = getSegmentations();
    const { segmentIndex, segmentationId } = segment;
    const bidirectionals = annotationState.getAnnotations(this.toolName || BidirectionalTool.toolName, FrameOfReferenceUID);
    let hasExistingActiveSegment = false;
    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {
        const segment = existingBidirectionalItem.data.segment;
        if (!segment) {
            return false;
        }
        if (segment.segmentationId === segmentationId &&
            segment.segmentIndex === segmentIndex) {
            hasExistingActiveSegment = true;
            existingBidirectionalItem.data.segment = segment;
        }
        return true;
    });
    if (!hasExistingActiveSegment) {
        existingLargestBidirectionals.push({
            data: { segment },
        });
    }
    let newBidirectional;
    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {
        const segments = [];
        const updateSegment = existingLargestBidirectional.data
            .segment;
        const { segmentIndex, segmentationId } = updateSegment;
        segments[segmentIndex] = updateSegment;
        annotationState.removeAnnotation(existingLargestBidirectional.annotationUID);
        const bidirectionalData = await contourAndFindLargestBidirectional({
            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),
            segments,
        });
        if (!bidirectionalData) {
            return;
        }
        const bidirectionalToolData = createBidirectionalToolData(bidirectionalData, enabledElement.viewport);
        bidirectionalToolData.annotationUID =
            existingLargestBidirectional.annotationUID;
        bidirectionalToolData.data.segment = updateSegment;
        const annotationUID = annotationState.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);
        if (updateSegment.segmentIndex === segment.segmentIndex &&
            updateSegment.segmentationId === segment.segmentationId) {
            newBidirectional = bidirectionalData;
            const { style } = segment;
            if (style) {
                annotationConfig.style.setAnnotationStyles(annotationUID, style);
            }
        }
    });
    if (newBidirectional) {
        const { sliceIndex } = newBidirectional;
        const imageIds = enabledElement.viewport.getImageIds();
        utilities.jumpToSlice(element, {
            imageIndex: imageIds.length - 1 - sliceIndex,
        });
        enabledElement.viewport.render();
    }
    else {
        console.warn('No bidirectional found');
    }
    return newBidirectional;
}
function defaultGetSegment(enabledElement, configuration) {
    const segmentationsList = getSegmentations();
    if (!segmentationsList.length) {
        return;
    }
    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;
    const segmentIndex = configuration.segmentIndex ?? getActiveSegmentIndex(segmentationId);
    if (!segmentIndex) {
        return;
    }
    const segmentData = configuration.segmentData?.get(segmentIndex);
    return {
        label: `Segment ${segmentIndex}`,
        segmentIndex,
        segmentationId,
        ...segmentData,
    };
}


/***/ }),

/***/ 73706:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49906);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64063);


function thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');
    }
    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);
    const { voxelManager } = volumeInfoList[baseVolumeIdx];
    const refVoxelManager = voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const segVoxelManager = segmentationVolume.voxelManager;
    volumeInfoList.forEach((volumeInfo) => {
        const { volumeSize } = volumeInfo;
        if (volumeSize === scalarDataLength) {
            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);
        }
        else {
            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);
        }
    });
    triggerSegmentationDataModified(segmentationId);
    return segmentationVolume;
}
function _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {
    const { imageData, lower, upper, dimensions } = volumeInfo;
    let total, overlaps, range;
    const segScalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < segScalarDataLength; i++) {
        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {
            const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));
            const callbackOverlap = ({ value }) => {
                total = total + 1;
                if (value >= range.lower && value <= range.upper) {
                    overlaps = overlaps + 1;
                }
            };
            total = 0;
            overlaps = 0;
            range = { lower, upper };
            let overlapTest = false;
            segVoxelManager.forEach(callbackOverlap, {
                imageData,
                boundsIJK: overlapBounds,
            });
            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;
            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);
        }
    }
    return { total, range, overlaps };
}
function _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {
    const { lower, upper } = volumeInfo;
    const scalarDataLength = segVoxelManager.getScalarDataLength();
    for (let i = 0; i < scalarDataLength; i++) {
        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {
            const value = refVoxelManager.getAtIndex(i);
            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);
        }
    }
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (thresholdSegmentationByRange)));


/***/ }),

/***/ 8582:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var _stateManagement_segmentation_triggerSegmentationEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49906);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64063);


function thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {
    const { imageData: segmentationImageData } = segmentationVolume;
    const { overwrite, boundsIJK, segmentationId } = options;
    if (!segmentationId) {
        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');
    }
    const overlapType = options?.overlapType || 0;
    const segVoxelManager = segmentationVolume.voxelManager;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    if (overwrite) {
        for (let i = 0; i < scalarDataLength; i++) {
            segVoxelManager.setAtIndex(i, 0);
        }
    }
    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);
    let overlaps, total, range;
    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {
        const callbackOverlap = ({ value }) => {
            total = total + 1;
            if (value >= range.lower && value <= range.upper) {
                overlaps = overlaps + 1;
            }
        };
        const { imageData, dimensions, lower, upper } = volumeInfo;
        const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);
        total = 0;
        overlaps = 0;
        range = { lower, upper };
        let overlapTest = false;
        const { voxelManager } = imageData.get('voxelManager');
        voxelManager.forEach(callbackOverlap, {
            imageData,
            boundsIJK: overlapBounds,
        });
        if (overlapType === 0) {
            overlapTest = overlaps > 0;
        }
        else if (overlapType == 1) {
            overlapTest = overlaps === total;
        }
        return overlapTest;
    };
    const testRange = (volumeInfo, pointIJK) => {
        const { imageData, lower, upper } = volumeInfo;
        const voxelManager = imageData.get('voxelManager').voxelManager;
        const offset = voxelManager.toIndex(pointIJK);
        const value = voxelManager.getAtIndex(offset);
        if (value <= lower || value >= upper) {
            return false;
        }
        else {
            return true;
        }
    };
    const callback = ({ index, pointIJK, pointLPS }) => {
        let insert = volumeInfoList.length > 0;
        for (let i = 0; i < volumeInfoList.length; i++) {
            if (volumeInfoList[i].volumeSize === scalarDataLength) {
                insert = testRange(volumeInfoList[i], pointIJK);
            }
            else {
                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);
            }
            if (!insert) {
                break;
            }
        }
        if (insert) {
            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);
        }
    };
    const voxelManager = segmentationVolume.voxelManager;
    voxelManager.forEach(callback, {
        imageData: segmentationImageData,
        boundsIJK,
    });
    triggerSegmentationDataModified(options.segmentationId);
    return segmentationVolume;
}
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (thresholdVolumeByRange)));


/***/ }),

/***/ 64063:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dm: () => (/* binding */ setCachedSegmentIndices),
/* harmony export */   HM: () => (/* binding */ setSegmentationDirty),
/* harmony export */   R1: () => (/* binding */ getCachedSegmentIndices)
/* harmony export */ });
/* unused harmony exports getVoxelOverlap, processVolumes, setSegmentationClean */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _boundingBox_getBoundingBoxAroundShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87063);


const equalsCheck = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};
function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {
    const halfSpacingX = voxelSpacing[0] / 2;
    const halfSpacingY = voxelSpacing[1] / 2;
    const halfSpacingZ = voxelSpacing[2] / 2;
    const voxelCornersIJK = new Array(8);
    voxelCornersIJK[0] = csUtils.transformWorldToIndex(imageData, [
        voxelCenter[0] - halfSpacingX,
        voxelCenter[1] - halfSpacingY,
        voxelCenter[2] - halfSpacingZ,
    ]);
    const offsets = [
        [1, -1, -1],
        [-1, 1, -1],
        [1, 1, -1],
        [-1, -1, 1],
        [1, -1, 1],
        [-1, 1, 1],
        [1, 1, 1],
    ];
    for (let i = 0; i < 7; i++) {
        const [xOff, yOff, zOff] = offsets[i];
        voxelCornersIJK[i + 1] = csUtils.transformWorldToIndex(imageData, [
            voxelCenter[0] + xOff * halfSpacingX,
            voxelCenter[1] + yOff * halfSpacingY,
            voxelCenter[2] + zOff * halfSpacingZ,
        ]);
    }
    return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);
}
function processVolumes(segmentationVolume, thresholdVolumeInformation) {
    const { spacing: segmentationSpacing } = segmentationVolume;
    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();
    const volumeInfoList = [];
    let baseVolumeIdx = 0;
    for (let i = 0; i < thresholdVolumeInformation.length; i++) {
        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;
        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();
        if (volumeSize === scalarDataLength &&
            equalsCheck(spacing, segmentationSpacing)) {
            baseVolumeIdx = i;
        }
        const lower = thresholdVolumeInformation[i].lower;
        const upper = thresholdVolumeInformation[i].upper;
        volumeInfoList.push({
            imageData,
            lower,
            upper,
            spacing,
            dimensions,
            volumeSize,
            voxelManager,
        });
    }
    return {
        volumeInfoList,
        baseVolumeIdx,
    };
}
const segmentIndicesCache = new Map();
const setSegmentationDirty = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = true;
    }
};
const setSegmentationClean = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = false;
    }
};
const getCachedSegmentIndices = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached && !cached.isDirty) {
        return cached.indices;
    }
    return null;
};
const setCachedSegmentIndices = (segmentationId, indices) => {
    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
};


/***/ }),

/***/ 54285:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dn: () => (/* binding */ prepareStackDataForWorker),
/* harmony export */   FI: () => (/* binding */ getImageReferenceInfo),
/* harmony export */   o9: () => (/* binding */ prepareVolumeStrategyDataForWorker),
/* harmony export */   sg: () => (/* binding */ triggerWorkerProgress),
/* harmony export */   yR: () => (/* binding */ getSegmentationDataForWorker)
/* harmony export */ });
/* unused harmony export prepareImageInfo */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);
/* harmony import */ var _stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60740);
/* harmony import */ var _stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33283);
/* harmony import */ var _tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40905);
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38732);
/* harmony import */ var _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62753);






const triggerWorkerProgress = (workerType, progress) => {
    (0,_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.triggerEvent)(_cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.eventTarget, _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: workerType,
    });
};
const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {
    const segmentation = (0,_stateManagement_segmentation_getSegmentation__WEBPACK_IMPORTED_MODULE_2__/* .getSegmentation */ .T)(segmentationId);
    const { representationData } = segmentation;
    const { Labelmap } = representationData;
    if (!Labelmap) {
        console.debug('No labelmap found for segmentation', segmentationId);
        return null;
    }
    const segVolumeId = Labelmap.volumeId;
    const segImageIds = Labelmap.imageIds;
    const operationData = {
        segmentationId,
        volumeId: segVolumeId,
        imageIds: segImageIds,
    };
    let reconstructableVolume = false;
    if (segImageIds) {
        const refImageIds = segImageIds.map((imageId) => {
            const image = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageId);
            return image.referencedImageId;
        });
        reconstructableVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.isValidVolume(refImageIds);
    }
    let indices = segmentIndices;
    if (!indices) {
        indices = [(0,_stateManagement_segmentation_getActiveSegmentIndex__WEBPACK_IMPORTED_MODULE_1__/* .getActiveSegmentIndex */ .Q)(segmentationId)];
    }
    else if (!Array.isArray(indices)) {
        indices = [indices, 255];
    }
    return {
        operationData,
        segVolumeId,
        segImageIds,
        reconstructableVolume,
        indices,
    };
};
const prepareVolumeStrategyDataForWorker = (operationData) => {
    return (0,_tools_segmentation_strategies_utils_getStrategyData__WEBPACK_IMPORTED_MODULE_3__/* .getStrategyData */ .S)({
        operationData,
        strategy: {
            ensureSegmentationVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureSegmentationVolume__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.ensureSegmentationVolumeFor3DManipulation,
            ensureImageVolumeFor3DManipulation: _tools_segmentation_strategies_compositions_ensureImageVolume__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A.ensureImageVolumeFor3DManipulation,
        },
    });
};
const prepareImageInfo = (imageVoxelManager, imageData) => {
    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();
    return {
        scalarData: imageScalarData,
        dimensions: imageData.getDimensions(),
        spacing: imageData.getSpacing(),
        origin: imageData.getOrigin(),
        direction: imageData.getDirection(),
    };
};
const prepareStackDataForWorker = (segImageIds) => {
    const segmentationInfo = [];
    const imageInfo = [];
    for (const segImageId of segImageIds) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageId);
        const segPixelData = segImage.getPixelData();
        const { origin, direction, spacing, dimensions } = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.utilities.getImageDataMetadata(segImage);
        segmentationInfo.push({
            scalarData: segPixelData,
            dimensions,
            spacing,
            origin,
            direction,
        });
        const refImageId = segImage.referencedImageId;
        if (refImageId) {
            const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
            if (!refImage) {
                continue;
            }
            const refPixelData = refImage.getPixelData();
            const refVoxelManager = refImage.voxelManager;
            const refSpacing = [
                refImage.rowPixelSpacing,
                refImage.columnPixelSpacing,
            ];
            imageInfo.push({
                scalarData: refPixelData,
                dimensions: refVoxelManager
                    ? refVoxelManager.dimensions
                    : [refImage.columns, refImage.rows, 1],
                spacing: refSpacing,
            });
        }
    }
    return { segmentationInfo, imageInfo };
};
const getImageReferenceInfo = (segVolumeId, segImageIds) => {
    let refImageId;
    if (segVolumeId) {
        const segmentationVolume = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getVolume(segVolumeId);
        const imageIds = segmentationVolume.imageIds;
        const cachedImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(imageIds[0]);
        if (cachedImage) {
            refImageId = cachedImage.referencedImageId;
        }
    }
    else if (segImageIds?.length) {
        const segImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(segImageIds[0]);
        refImageId = segImage.referencedImageId;
    }
    const refImage = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.cache.getImage(refImageId);
    const scalingModule = _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__.metaData.get('scalingModule', refImageId);
    const modalityUnitOptions = {
        isPreScaled: Boolean(refImage?.preScale?.scaled),
        isSuvScaled: typeof scalingModule?.suvbw === 'number',
    };
    return { refImageId, modalityUnitOptions };
};


/***/ }),

/***/ 21345:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports validatePublic, validate */
/* harmony import */ var _cornerstonejs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15327);

function validateRepresentationData(segmentationRepresentationData) {
    if ('volumeId' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        const cachedVolume = cache.getVolume(segmentationRepresentationData.volumeId);
        if (!cachedVolume) {
            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);
        }
    }
    else if ('imageIds' in segmentationRepresentationData) {
        segmentationRepresentationData =
            segmentationRepresentationData;
        if (!segmentationRepresentationData.imageIds) {
            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');
        }
    }
    else {
        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');
    }
}
function validatePublic(segmentationInput) {
    if (!segmentationInput.representation.data) {
        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');
    }
    const representationData = segmentationInput.representation
        .data;
    validateRepresentationData(representationData);
}
function validate(segmentationRepresentationData) {
    validateRepresentationData(segmentationRepresentationData);
}


/***/ }),

/***/ 56069:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39011);

function triggerAnnotationRender(element) {
    _stateManagement_annotation_AnnotationRenderingEngine__WEBPACK_IMPORTED_MODULE_0__/* .annotationRenderingEngine */ .o.renderViewport(element);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (triggerAnnotationRender);


/***/ }),

/***/ 3198:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ filterViewportsWithFrameOfReferenceUID)
/* harmony export */ });
function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {
    const numViewports = viewports.length;
    const viewportsWithFrameOfReferenceUID = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {
            viewportsWithFrameOfReferenceUID.push(viewport);
        }
    }
    return viewportsWithFrameOfReferenceUID;
}


/***/ }),

/***/ 67514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export filterViewportsWithParallelNormals */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);

function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {
    return viewports.filter((viewport) => {
        const vpCamera = viewport.getCamera();
        const isParallel = Math.abs(gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >
            EPS;
        return isParallel;
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (filterViewportsWithParallelNormals);


/***/ }),

/***/ 9356:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ filterViewportsWithToolEnabled)
/* harmony export */ });
/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99737);
/* harmony import */ var _store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77609);


const { Active, Passive, Enabled } = _enums__WEBPACK_IMPORTED_MODULE_0__.ToolModes;
function filterViewportsWithToolEnabled(viewports, toolName) {
    const numViewports = viewports.length;
    const viewportsWithToolEnabled = [];
    for (let vp = 0; vp < numViewports; vp++) {
        const viewport = viewports[vp];
        const toolGroup = (0,_store_ToolGroupManager__WEBPACK_IMPORTED_MODULE_1__.getToolGroupForViewport)(viewport.id, viewport.renderingEngineId);
        if (!toolGroup) {
            continue;
        }
        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);
        if (hasTool) {
            viewportsWithToolEnabled.push(viewport);
        }
    }
    return viewportsWithToolEnabled;
}
function _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {
    const { toolOptions } = toolGroup;
    const tool = toolOptions[toolName];
    if (!tool) {
        return false;
    }
    const toolMode = tool.mode;
    return toolMode === Active || toolMode === Passive || toolMode === Enabled;
}


/***/ }),

/***/ 35056:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCellArray$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28914);




// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  extractCellSizes,
  getNumberOfCells
};

// ----------------------------------------------------------------------------
// vtkCellArray methods
// ----------------------------------------------------------------------------

function vtkCellArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellArray');
  const superClass = {
    ...publicAPI
  };
  publicAPI.getNumberOfCells = recompute => {
    if (model.numberOfCells !== undefined && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = recompute => {
    if (model.cellSizes !== undefined && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };

  /**
   * When `resize()` is being used, you then MUST use `insertNextCell()`.
   */
  publicAPI.resize = requestedNumTuples => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        // We do not know how many cells are left.
        // Set to undefined to ensure insertNextCell works correctly.
        model.numberOfCells = undefined;
        model.cellSizes = undefined;
      }
    }
  };
  publicAPI.setData = typedArray => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = undefined;
    model.cellSizes = undefined;
  };
  publicAPI.getCell = loc => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = cellPointIds => {
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    // By computing the number of cells earlier, we made sure that numberOfCells is defined
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

function defaultValues(initialValues) {
  return {
    empty: true,
    numberOfComponents: 1,
    dataType: _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VtkDataTypes */ .JA.UNSIGNED_INT,
    ...initialValues
  };
}

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkCellArray');

// ----------------------------------------------------------------------------

var vtkCellArray$1 = {
  newInstance,
  extend,
  ...STATIC
};




/***/ }),

/***/ 44302:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ClassHierarchy)
/* harmony export */ });
/* eslint-disable prefer-rest-params */
class ClassHierarchy extends Array {
  push() {
    for (let i = 0; i < arguments.length; i++) {
      if (!this.includes(arguments[i])) {
        super.push(arguments[i]);
      }
    }
    return this.length;
  }
}




/***/ }),

/***/ 42008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkDataArray$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28914);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16632);




const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;
const {
  DefaultDataType
} = _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
const EPSILON = 1e-6;

// Original source from https://www.npmjs.com/package/compute-range
// Modified to accept type arrays
function fastComputeRange(arr, offset, numberOfComponents) {
  const len = arr.length;
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let x;
  let i;

  // find first non-NaN value
  for (i = offset; i < len; i += numberOfComponents) {
    if (!Number.isNaN(arr[i])) {
      min = arr[i];
      max = min;
      break;
    }
  }
  for (; i < len; i += numberOfComponents) {
    x = arr[i];
    if (x < min) {
      min = x;
    } else if (x > max) {
      max = x;
    }
  }
  return {
    min,
    max
  };
}

/**
 * @deprecated please use fastComputeRange instead
 */
function createRangeHelper() {
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;
  return {
    add(value) {
      if (min > value) {
        min = value;
      }
      if (max < value) {
        max = value;
      }
      count++;
      sum += value;
    },
    get() {
      return {
        min,
        max,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange() {
      return {
        min,
        max
      };
    }
  };
}
function computeRange(values) {
  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    // Compute magnitude
    const size = values.length;
    const numberOfValues = size / numberOfComponents;
    const data = new Float64Array(numberOfValues);
    for (let i = 0, j = 0; i < numberOfValues; ++i) {
      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      data[i] **= 0.5;
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  const ranges = rangeArray || [];
  // Pad ranges with null value to get the
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  // Expects toString() to return "[object ...Array]"
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0.0;
  const tuple = new Array(numComps);
  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
    normArray.getTuple(i, tuple);
    const norm$1 = (0,_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.n)(tuple, numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  computeRange,
  createRangeHelper,
  fastComputeRange,
  getDataType,
  getMaxNorm
};

// ----------------------------------------------------------------------------
// vtkDataArray methods
// ----------------------------------------------------------------------------

function vtkDataArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkDataArray');

  /**
   * Resize model.values and copy the old values to the new array.
   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0
   * @returns {Boolean} True if a resize occured, false otherwise
   */
  function resize(requestedNumTuples) {
    if (requestedNumTuples < 0) {
      return false;
    }
    const numComps = publicAPI.getNumberOfComponents();
    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
    if (requestedNumTuples === curNumTuples) {
      return true;
    }
    if (requestedNumTuples > curNumTuples) {
      // Requested size is bigger than current size.  Allocate enough
      // memory to fit the requested size and be more than double the
      // currently allocated memory.
      const oldValues = model.values;
      model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.a)(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
      model.values.set(oldValues);
      return true;
    }

    // Requested size is smaller than currently allocated size
    if (model.size > requestedNumTuples * numComps) {
      model.size = requestedNumTuples * numComps;
      publicAPI.dataChange();
    }
    return true;
  }
  publicAPI.dataChange = () => {
    model.ranges = null;
    publicAPI.modified();
  };
  publicAPI.resize = requestedNumTuples => {
    resize(requestedNumTuples);
    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
    if (model.size !== newSize) {
      model.size = newSize;
      publicAPI.dataChange();
      return true;
    }
    return false;
  };

  // FIXME, to rename into "clear()" or "reset()"
  publicAPI.initialize = () => {
    publicAPI.resize(0);
  };
  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;

  // Description:
  // Return the data component at the location specified by tupleIdx and
  // compIdx.
  publicAPI.getComponent = function (tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };

  // Description:
  // Set the data component at the location specified by tupleIdx and compIdx
  // to value.
  // Note that i is less than NumberOfTuples and j is less than
  //  NumberOfComponents. Make sure enough memory has been allocated
  // (use SetNumberOfTuples() and SetNumberOfComponents()).
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.dataChange();
    }
  };
  publicAPI.getValue = valueIdx => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    return publicAPI.getComponent(idx, comp);
  };
  publicAPI.setValue = (valueIdx, value) => {
    const idx = valueIdx / model.numberOfComponents;
    const comp = valueIdx % model.numberOfComponents;
    publicAPI.setComponent(idx, comp, value);
  };
  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
  publicAPI.getRange = function () {
    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    let rangeIdx = componentIndex;
    if (rangeIdx < 0) {
      // If scalar data, then store in slot 0 (same as componentIndex = 0).
      // If vector data, then store in last slot.
      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
    }
    let range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }

    // Need to compute ranges...
    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.getRanges = function () {
    let computeRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (!computeRanges) {
      return structuredClone(model.ranges);
    }
    /** @type {import('../../../interfaces').vtkRange[]} */
    const ranges = [];
    for (let i = 0; i < model.numberOfComponents; i++) {
      const [min, max] = publicAPI.getRange(i);
      /** @type {import('../../../interfaces').vtkRange} */
      const range = {
        min,
        max
      };
      ranges.push(range);
    }
    // where the number of components is greater than 1, the last element in
    // the range array is the min,max magnitude of the entire dataset.
    if (model.numberOfComponents > 1) {
      const [min, max] = publicAPI.getRange(-1);
      /** @type {import('../../../interfaces').vtkRange} */
      const range = {
        min,
        max
      };
      ranges.push(range);
    }
    return ranges;
  };
  publicAPI.setTuple = (idx, tuple) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.setTuples = (idx, tuples) => {
    let i = idx * model.numberOfComponents;
    const last = Math.min(tuples.length, model.size - i);
    for (let j = 0; j < last;) {
      model.values[i++] = tuples[j++];
    }
  };
  publicAPI.insertTuple = (idx, tuple) => {
    if (model.size <= idx * model.numberOfComponents) {
      model.size = (idx + 1) * model.numberOfComponents;
      resize(idx + 1);
    }
    publicAPI.setTuple(idx, tuple);
    return idx;
  };
  publicAPI.insertTuples = (idx, tuples) => {
    const end = idx + tuples.length / model.numberOfComponents;
    if (model.size < end * model.numberOfComponents) {
      model.size = end * model.numberOfComponents;
      resize(end);
    }
    publicAPI.setTuples(idx, tuples);
    return end;
  };
  publicAPI.insertNextTuple = tuple => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuple(idx, tuple);
  };
  publicAPI.insertNextTuples = tuples => {
    const idx = model.size / model.numberOfComponents;
    return publicAPI.insertTuples(idx, tuples);
  };
  publicAPI.findTuple = function (tuple) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;
    for (let i = 0; i < model.size; i += model.numberOfComponents) {
      if (Math.abs(tuple[0] - model.values[i]) <= precision) {
        let match = true;
        for (let j = 1; j < model.numberOfComponents; ++j) {
          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
            match = false;
            break;
          }
        }
        if (match) {
          return i / model.numberOfComponents;
        }
      }
    }
    return -1;
  };
  publicAPI.getTuple = function (idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    const offset = idx * numberOfComponents;
    // Check most common component sizes first
    // to avoid doing a for loop if possible
    switch (numberOfComponents) {
      case 4:
        tupleToFill[3] = model.values[offset + 3];
      // eslint-disable-next-line no-fallthrough
      case 3:
        tupleToFill[2] = model.values[offset + 2];
      // eslint-disable-next-line no-fallthrough
      case 2:
        tupleToFill[1] = model.values[offset + 1];
      // eslint-disable-next-line no-fallthrough
      case 1:
        tupleToFill[0] = model.values[offset];
        break;
      default:
        for (let i = numberOfComponents - 1; i >= 0; --i) {
          tupleToFill[i] = model.values[offset + i];
        }
    }
    return tupleToFill;
  };
  publicAPI.getTuples = (fromId, toId) => {
    const from = (fromId ?? 0) * model.numberOfComponents;
    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
    const arr = publicAPI.getData().subarray(from, to);
    return arr.length > 0 ? arr : null;
  };
  publicAPI.getTupleLocation = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.size;
  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  /* eslint-disable no-use-before-define */
  publicAPI.newClone = () => newInstance({
    empty: true,
    name: model.name,
    dataType: model.dataType,
    numberOfComponents: model.numberOfComponents
  });
  /* eslint-enable no-use-before-define */

  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };
  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.dataChange();
  };

  // Override serialization support
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };

    // Convert typed array to regular array
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;

    // Clean any empty data
    Object.keys(jsonArchive).forEach(keyName => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(name => {
      sortedObj[name] = jsonArchive[name];
    });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };

  /**
   * @param {import("./index").vtkDataArray} other
   */
  publicAPI.deepCopy = other => {
    // Retain current dataType and array reference before shallowCopy call.
    const currentType = publicAPI.getDataType();
    const currentArray = model.values;
    publicAPI.shallowCopy(other);

    // set the ranges
    model.ranges = structuredClone(other.getRanges());

    // Avoid array reallocation if size already sufficient
    // and dataTypes match.
    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {
      currentArray.set(other.getData());
      model.values = currentArray;
      publicAPI.dataChange();
    } else {
      publicAPI.setData(other.getData().slice());
    }
  };
  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
      vtkErrorMacro('numberOfComponents must match');
    }
    const tuple1 = source1.getTuple(source1Idx);
    const tuple2 = source2.getTuple(source2Idx);
    const out = [];
    out.length = numberOfComponents;

    // Check most common component sizes first
    // to avoid doing a for loop if possible
    switch (numberOfComponents) {
      case 4:
        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
      // eslint-disable-next-line no-fallthrough
      case 3:
        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
      // eslint-disable-next-line no-fallthrough
      case 2:
        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
      // eslint-disable-next-line no-fallthrough
      case 1:
        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
        break;
      default:
        for (let i = 0; i < numberOfComponents; i++) {
          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
        }
    }
    return publicAPI.insertTuple(idx, out);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

// size: The current size of the dataArray.
// NOTE: The underlying typed array may be larger than 'size'.
const DEFAULT_VALUES = {
  name: '',
  numberOfComponents: 1,
  dataType: DefaultDataType,
  rangeTuple: [0, 0]
  // size: undefined,
  // values: null,
  // ranges: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  if (Array.isArray(initialValues.values) && initialValues.dataType === undefined) {
    console.warn('vtkDataArray.newInstance: no dataType provided, converting to Float32Array');
  }
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');
  }
  if (!model.values) {
    model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.a)(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.b)(model.dataType, model.values);
  }
  if (model.values) {
    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.
    model.size = model.size ?? model.values.length;
    model.dataType = getDataType(model.values);
  }

  // Object methods
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(publicAPI, model);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.s)(publicAPI, model, ['name', 'numberOfComponents']);
  if (model.size % model.numberOfComponents !== 0) {
    throw new RangeError('model.size is not a multiple of model.numberOfComponents');
  }

  // Object specific methods
  vtkDataArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkDataArray');

// ----------------------------------------------------------------------------

var vtkDataArray$1 = {
  newInstance,
  extend,
  ...STATIC,
  ..._DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay
};




/***/ }),

/***/ 28914:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   JA: () => (/* binding */ VtkDataTypes),
/* harmony export */   uP: () => (/* binding */ DataTypeByteSize)
/* harmony export */ });
/* unused harmony export DefaultDataType */
const DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
const VtkDataTypes = {
  VOID: '',
  // not sure to know what that should be
  CHAR: 'Int8Array',
  SIGNED_CHAR: 'Int8Array',
  UNSIGNED_CHAR: 'Uint8Array',
  UNSIGNED_CHAR_CLAMPED: 'Uint8ClampedArray',
  // should be used for VTK.js internal purpose only
  SHORT: 'Int16Array',
  UNSIGNED_SHORT: 'Uint16Array',
  INT: 'Int32Array',
  UNSIGNED_INT: 'Uint32Array',
  FLOAT: 'Float32Array',
  DOUBLE: 'Float64Array'
};
const DefaultDataType = VtkDataTypes.FLOAT;
var Constants = {
  DefaultDataType,
  DataTypeByteSize,
  VtkDataTypes
};




/***/ }),

/***/ 97888:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ HalfFloat)
/* harmony export */ });
/* eslint-disable no-bitwise */

const floatView = new Float32Array(1);
const int32View = new Int32Array(floatView.buffer);

/* eslint-disable no-bitwise */
/* This method is faster than the OpenEXR implementation (very often
 * used, eg. in Ogre), with the additional benefit of rounding, inspired
 * by James Tursa?s half-precision code. */
function toHalf(val) {
  floatView[0] = val;
  const x = int32View[0];
  let bits = x >> 16 & 0x8000; /* Get the sign */
  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
  const e = x >> 23 & 0xff; /* Using int is faster here */

  /* If zero, or denormal, or exponent underflows too much for a denormal
   * half, return signed zero. */
  if (e < 103) {
    return bits;
  }

  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
  if (e > 142) {
    bits |= 0x7c00;
    /* If exponent was 0xff and one mantissa bit was set, it means NaN,
     * not Inf, so make sure we set one mantissa bit too. */
    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
    return bits;
  }

  /* If exponent underflows but not too much, return a denormal */
  if (e < 113) {
    m |= 0x0800;
    /* Extra rounding may overflow and set mantissa to 0 and exponent
     * to 1, which is OK. */
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  /* Extra rounding. An overflow will set mantissa to 0 and increment
   * the exponent, which is OK. */
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  const s = (h & 0x8000) >> 15;
  const e = (h & 0x7c00) >> 10;
  const f = h & 0x03ff;
  if (e === 0) {
    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
  }
  if (e === 0x1f) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
}
var HalfFloat = {
  fromHalf,
  toHalf
};




/***/ }),

/***/ 72879:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkLookupTable$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80993);
/* harmony import */ var _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62955);
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28914);






const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;

// ----------------------------------------------------------------------------
// vtkMyClass methods
// ----------------------------------------------------------------------------

function vtkLookupTable(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLookupTable');

  //----------------------------------------------------------------------------
  // Description:
  // Return true if all of the values defining the mapping have an opacity
  // equal to 1. Default implementation return true.
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {
        opaque = 0;
      }
      for (let i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;

  //----------------------------------------------------------------------------
  // Don't count special colors (min, max, NaN) as available colors
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;

  //----------------------------------------------------------------------------
  // Apply shift/scale to the scalar value v and return the index.
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;
    const nv = Number(v);
    if (nv < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p.shift) * p.scale;

      // This conditional is needed because when v is very close to
      // p.Range[1], it may map above p.MaxIndex in the linear mapping
      // above.
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v, table, p) => {
    let index = 0;
    if ((0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.i)(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index;
    return table.slice(offset, offset + 4);
  };
  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };

  //----------------------------------------------------------------------------
  publicAPI.lookupShiftAndScale = (range, p) => {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };

  // Public API methods
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0.0,
      scale: 0.0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    const alpha = publicAPI.getAlpha();
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1.0) {
      if (outFormat === _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ScalarMappingTarget */ .y0.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      /* eslint-disable no-lonely-if */
      if (outFormat === _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ScalarMappingTarget */ .y0.RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    } // alpha blending
  };

  publicAPI.forceBuild = () => {
    let hinc = 0.0;
    let sinc = 0.0;
    let vinc = 0.0;
    let ainc = 0.0;
    const maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    model.table.length = 4 * maxIndex + 16;
    const hsv = [];
    const rgba = [];
    for (let i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      (0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.h)(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;

      //  case VTK_RAMP_LINEAR:
      model.table[i * 4] = rgba[0] * 255.0 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = table => {
    // Handle JS array (assume 2D array)
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset = 0;
      // fill table
      for (let i = 0; i < model.numberOfColors; i++) {
        model.table[i * 4] = 255;
        model.table[i * 4 + 1] = 255;
        model.table[i * 4 + 2] = 255;
        model.table[i * 4 + 3] = 255;
      }
      // extract colors
      for (let i = 0; i < table.length; i++) {
        const color = table[i];
        for (let j = 0; j < nbComponents; j++) {
          model.table[offset++] = color[j];
        }
        offset += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro('Expected 4 components for RGBA colors');
      return false;
    }
    if (table.getDataType() !== _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR) {
      vtkErrorMacro('Expected unsigned char values for RGBA colors');
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    // Add "special" colors (NaN, below range, above range) to table here.
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;

    // Below range color
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the first color in the table.
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }

    // Above range color
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the last color in the table.
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }

    // Always use NanColor
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255.0 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    // Ensure that special colors are properly included in the table
    publicAPI.buildSpecialColors();

    // ensure insertTime is more recently modified than buildTime if
    // a table is provided via the constructor
    model.insertTime.modified();
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfColors: 256,
  // table: null,

  hueRange: [0.0, 0.66667],
  saturationRange: [1.0, 1.0],
  valueRange: [1.0, 1.0],
  alphaRange: [1.0, 1.0],
  nanColor: [0.5, 0.0, 0.0, 1.0],
  belowRangeColor: [0.0, 0.0, 0.0, 1.0],
  aboveRangeColor: [1.0, 1.0, 1.0, 1.0],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1.0
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _ScalarsToColors_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Internal objects initialization
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.insertTime, {
    mtime: 0
  });

  // Create get-only macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['buildTime']);

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['numberOfColors', 'useAboveRangeColor', 'useBelowRangeColor']);

  // Create set macros for array (needs to know size)
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'], 2);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['hueRange', 'saturationRange', 'valueRange', 'alphaRange', 'nanColor', 'belowRangeColor', 'aboveRangeColor']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkLookupTable(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkLookupTable');

// ----------------------------------------------------------------------------

var vtkLookupTable$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 84607:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_3__.f)
/* harmony export */ });
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56037);
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);






/***/ }),

/***/ 35341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GY: () => (/* binding */ IDENTITY_3X3),
/* harmony export */   kP: () => (/* binding */ VTK_SMALL_NUMBER),
/* harmony export */   p8: () => (/* binding */ EPSILON),
/* harmony export */   zK: () => (/* binding */ IDENTITY)
/* harmony export */ });
/* unused harmony export default */
const IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
const EPSILON = 1e-6;
const VTK_SMALL_NUMBER = 1.0e-12;
var Constants = {
  IDENTITY,
  IDENTITY_3X3,
  EPSILON,
  VTK_SMALL_NUMBER
};




/***/ }),

/***/ 16632:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ degreesFromRadians),
/* harmony export */   E: () => (/* binding */ clampValue),
/* harmony export */   H: () => (/* binding */ createUninitializedBounds),
/* harmony export */   K: () => (/* binding */ floor),
/* harmony export */   L: () => (/* binding */ isInf),
/* harmony export */   M: () => (/* binding */ rgb2hsv),
/* harmony export */   N: () => (/* binding */ rgb2lab),
/* harmony export */   O: () => (/* binding */ lab2rgb),
/* harmony export */   P: () => (/* binding */ round),
/* harmony export */   Q: () => (/* binding */ normalize2D),
/* harmony export */   R: () => (/* binding */ nearestPowerOfTwo),
/* harmony export */   S: () => (/* binding */ multiply3x3_vect3),
/* harmony export */   T: () => (/* binding */ getSparseOrthogonalMatrix),
/* harmony export */   U: () => (/* binding */ areBoundsInitialized),
/* harmony export */   V: () => (/* binding */ isPowerOfTwo),
/* harmony export */   a: () => (/* binding */ areMatricesEqual),
/* harmony export */   b: () => (/* binding */ roundVector),
/* harmony export */   c: () => (/* binding */ clampVector),
/* harmony export */   d: () => (/* binding */ dot),
/* harmony export */   e: () => (/* binding */ distance2BetweenPoints),
/* harmony export */   f: () => (/* binding */ vtkMath),
/* harmony export */   g: () => (/* binding */ solveLinearSystem),
/* harmony export */   h: () => (/* binding */ hsv2rgb),
/* harmony export */   i: () => (/* binding */ isNan),
/* harmony export */   j: () => (/* binding */ cross),
/* harmony export */   k: () => (/* binding */ add),
/* harmony export */   l: () => (/* binding */ normalize),
/* harmony export */   m: () => (/* binding */ multiplyAccumulate),
/* harmony export */   n: () => (/* binding */ norm),
/* harmony export */   o: () => (/* binding */ determinant2x2),
/* harmony export */   r: () => (/* binding */ radiansFromDegrees),
/* harmony export */   s: () => (/* binding */ subtract),
/* harmony export */   u: () => (/* binding */ uninitializeBounds)
/* harmony export */ });
/* unused harmony exports $, B, C, D, F, G, I, J, W, X, Y, Z, _, a$, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF, aG, aH, aI, aJ, aK, aL, aM, aN, aO, aP, aQ, aR, aS, aT, aU, aV, aW, aX, aY, aZ, a_, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, b0, p, q, t, v, w, x, y, z */
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56037);
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);




const {
  vtkErrorMacro,
  vtkWarningMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

// ----------------------------------------------------------------------------
/* eslint-disable camelcase                                                  */
/* eslint-disable no-cond-assign                                             */
/* eslint-disable no-bitwise                                                 */
/* eslint-disable no-multi-assign                                            */
// ----------------------------------------------------------------------------
let randomSeedValue = 0;
const VTK_MAX_ROTATIONS = 20;
function notImplemented(method) {
  return () => vtkErrorMacro(`vtkMath::${method} - NOT IMPLEMENTED`);
}

// Swap rows for n by n matrix
function swapRowsMatrix_nxn(matrix, n, row1, row2) {
  let tmp;
  for (let i = 0; i < n; i++) {
    tmp = matrix[row1 * n + i];
    matrix[row1 * n + i] = matrix[row2 * n + i];
    matrix[row2 * n + i] = tmp;
  }
}

// Swap columns for n by n matrix
function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
  let tmp;
  for (let i = 0; i < n; i++) {
    tmp = matrix[i * n + column1];
    matrix[i * n + column1] = matrix[i * n + column2];
    matrix[i * n + column2] = tmp;
  }
}

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function createArray() {
  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
  // faster than Array.from and/or while loop
  const res = Array(size);
  for (let i = 0; i < size; ++i) {
    res[i] = 0;
  }
  return res;
}
const Pi = () => Math.PI;
function ldexp(x, exponent) {
  if (exponent > 1023) {
    return x * 2 ** 1023 * 2 ** (exponent - 1023);
  }
  if (exponent < -1074) {
    return x * 2 ** -1074 * 2 ** (exponent + 1074);
  }
  return x * 2 ** exponent;
}
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
const {
  round,
  floor,
  ceil,
  min,
  max
} = Math;
function arrayMin(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return [minValue, maxValue];
}
const ceilLog2 = notImplemented('ceilLog2');
const factorial = notImplemented('factorial');
function nearestPowerOfTwo(xi) {
  let v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  let r = 1;
  for (let i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }
  const r = createArray(n);
  for (let i = 0; i < n; ++i) {
    r[i] = i;
  }
  return r;
}
function nextCombination(m, n, r) {
  let status = 0;
  for (let i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      let j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  seedrandom__WEBPACK_IMPORTED_MODULE_0___default()(`${seed}`, {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  let minValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let maxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  const delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
const gaussian = notImplemented('gaussian');

// Vect3 operations
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  out_3x3[0] = x[0] * y[0];
  out_3x3[1] = x[0] * y[1];
  out_3x3[2] = x[0] * y[2];
  out_3x3[3] = x[1] * y[0];
  out_3x3[4] = x[1] * y[1];
  out_3x3[5] = x[1] * y[2];
  out_3x3[6] = x[2] * y[0];
  out_3x3[7] = x[2] * y[1];
  out_3x3[8] = x[2] * y[2];
}
function cross(x, y, out) {
  const Zx = x[1] * y[2] - x[2] * y[1];
  const Zy = x[2] * y[0] - x[0] * y[2];
  const Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default:
      {
        let sum = 0;
        for (let i = 0; i < n; i++) {
          sum += x[i] * x[i];
        }
        return Math.sqrt(sum);
      }
  }
}
function normalize(x) {
  const den = norm(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}
function perpendiculars(x, y, z, theta) {
  const x2 = x[0] * x[0];
  const y2 = x[1] * x[1];
  const z2 = x[2] * x[2];
  const r = Math.sqrt(x2 + y2 + z2);
  let dx;
  let dy;
  let dz;

  // transpose the vector to avoid divide-by-zero error
  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }
  const a = x[dx] / r;
  const b = x[dy] / r;
  const c = x[dz] / r;
  const tmp = Math.sqrt(a * a + c * c);
  if (theta !== 0) {
    const sintheta = Math.sin(theta);
    const costheta = Math.cos(theta);
    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }
    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }
    if (z) {
      z[dx] = -a * b / tmp;
      z[dy] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector(a, b, projection) {
  const bSquared = dot(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }
  const scale = dot(a, b) / bSquared;
  for (let i = 0; i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  const bSquared = dot2D(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }
  const scale = dot2D(a, b) / bSquared;
  for (let i = 0; i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function signedAngleBetweenVectors(v1, v2, vN) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  const angle = Math.atan2(norm(crossVect), dot(v1, v2));
  return dot(crossVect, vN) >= 0 ? angle : -angle;
}
function gaussianAmplitude(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  out_2x2[0] = x[0] * y[0];
  out_2x2[1] = x[0] * y[1];
  out_2x2[2] = x[1] * y[0];
  out_2x2[3] = x[1] * y[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  const den = norm2D(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}
function rowsToMat4(row0, row1, row2, row3, mat) {
  for (let i = 0; i < 4; i++) {
    mat[i] = row0[i];
    mat[4 + i] = row1[i];
    mat[8 + i] = row2[i];
    mat[12 + i] = row3[i];
  }
  return mat;
}
function columnsToMat4(column0, column1, column2, column3, mat) {
  for (let i = 0; i < 4; i++) {
    mat[4 * i] = column0[i];
    mat[4 * i + 1] = column1[i];
    mat[4 * i + 2] = column2[i];
    mat[4 * i + 3] = column3[i];
  }
  return mat;
}
function rowsToMat3(row0, row1, row2, mat) {
  for (let i = 0; i < 3; i++) {
    mat[i] = row0[i];
    mat[3 + i] = row1[i];
    mat[6 + i] = row2[i];
  }
  return mat;
}
function columnsToMat3(column0, column1, column2, mat) {
  for (let i = 0; i < 3; i++) {
    mat[3 * i] = column0[i];
    mat[3 * i + 1] = column1[i];
    mat[3 * i + 2] = column2[i];
  }
  return mat;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  let maxI;
  let tmp;
  let largest;
  const scale = [0, 0, 0];

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i * 3]);
    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
      largest = tmp;
    }
    scale[i] = 1 / largest;
  }

  // Loop over all columns using Crout's method

  // first column
  largest = scale[0] * Math.abs(mat_3x3[0]);
  maxI = 0;
  if ((tmp = scale[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale[maxI] = scale[0];
  }
  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0];

  // second column
  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale[1] * Math.abs(mat_3x3[4]);
  maxI = 1;
  if ((tmp = scale[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale[2] = scale[1];
  }
  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4];

  // third column
  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  // forward substitution
  let sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1];

  // back substitution
  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  const a1 = mat_3x3[0];
  const b1 = mat_3x3[1];
  const c1 = mat_3x3[2];
  const a2 = mat_3x3[3];
  const b2 = mat_3x3[4];
  const c2 = mat_3x3[5];
  const a3 = mat_3x3[6];
  const b3 = mat_3x3[7];
  const c3 = mat_3x3[8];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Compute the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;

  // Multiply by the adjoint
  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  const v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  const v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];

  // Divide by the determinant
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  const x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  const y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  const z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  const copyA = [...a_3x3];
  const copyB = [...b_3x3];
  for (let i = 0; i < 3; i++) {
    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, outRowAColB) {
  // we need colA == rowB
  if (colA !== rowB) {
    vtkErrorMacro('Number of columns of A must match number of rows of B.');
  }

  // If a or b is used to store the result, copying them is required
  const copyA = [...a];
  const copyB = [...b];
  // output matrix is rowA*colB
  // output row
  for (let i = 0; i < rowA; i++) {
    // output col
    for (let j = 0; j < colB; j++) {
      outRowAColB[i * colB + j] = 0;
      // sum for this point
      for (let k = 0; k < colA; k++) {
        outRowAColB[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  let tmp;

  // off-diagonal elements
  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp;

  // on-diagonal elements
  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  const a1 = in_3x3[0];
  const b1 = in_3x3[1];
  const c1 = in_3x3[2];
  const a2 = in_3x3[3];
  const b2 = in_3x3[4];
  const c2 = in_3x3[5];
  const a3 = in_3x3[6];
  const b3 = in_3x3[7];
  const c3 = in_3x3[8];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);
  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);
  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Divide by the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;
  if (det === 0) {
    vtkWarningMacro('Matrix has 0 determinant');
  }
  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d2 / det;
  outI_3x3[6] = d3 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e2 / det;
  outI_3x3[7] = e3 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f2 / det;
  outI_3x3[8] = f3 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}

/**
 * Returns true if elements of both arrays are equals.
 * @param {Array} a an array of numbers (vector, point, matrix...)
 * @param {Array} b an array of numbers (vector, point, matrix...)
 * @param {Number} eps tolerance
 */
function areEquals(a, b) {
  let eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  if (a.length !== b.length) {
    return false;
  }
  function isEqual(element, index) {
    return Math.abs(element - b[index]) <= eps;
  }
  return a.every(isEqual);
}
const areMatricesEqual = areEquals;
function identity3x3(mat_3x3) {
  for (let i = 0; i < 3; i++) {
    /* eslint-disable-next-line no-multi-assign */
    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
    mat_3x3[i * 3 + i] = 1;
  }
}
function identity(n, mat) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      mat[i * n + j] = 0;
    }
    mat[i * n + i] = 1;
  }
  return mat;
}
function isIdentity(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY */ .zK, eps);
}
function isIdentity3x3(mat) {
  let eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EPSILON */ .p8;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY_3X3 */ .GY, eps);
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  const ww = quat_4[0] * quat_4[0];
  const wx = quat_4[0] * quat_4[1];
  const wy = quat_4[0] * quat_4[2];
  const wz = quat_4[0] * quat_4[3];
  const xx = quat_4[1] * quat_4[1];
  const yy = quat_4[2] * quat_4[2];
  const zz = quat_4[3] * quat_4[3];
  const xy = quat_4[1] * quat_4[2];
  const xz = quat_4[1] * quat_4[3];
  const yz = quat_4[2] * quat_4[3];
  const rr = xx + yy + zz;
  // normalization factor, just in case quaternion was not normalized
  let f = 1 / (ww + rr);
  const s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0] = xx * f + s;
  mat_3x3[3] = (xy + wz) * f;
  mat_3x3[6] = (xz - wy) * f;
  mat_3x3[1] = (xy - wz) * f;
  mat_3x3[4] = yy * f + s;
  mat_3x3[7] = (yz + wx) * f;
  mat_3x3[2] = (xz + wy) * f;
  mat_3x3[5] = (yz - wx) * f;
  mat_3x3[8] = zz * f + s;
}
function roundNumber(num) {
  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!`${num}`.includes('e')) {
    return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
  }
  const arr = `${num}`.split('e');
  let sig = '';
  if (+arr[1] + digits > 0) {
    sig = '+';
  }
  return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
}
function roundVector(vector) {
  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  let digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  let i;
  let j;
  let k;
  let iq;
  let ip;
  let numPos;
  let tresh;
  let theta;
  let t;
  let tau;
  let sm;
  let s;
  let h;
  let g;
  let c;
  let tmp;
  const b = createArray(n);
  const z = createArray(n);
  const vtkROTATE = (aa, ii, jj) => {
    g = aa[ii];
    h = aa[jj];
    aa[ii] = g - s * (h + g * tau);
    aa[jj] = h + s * (g - h * tau);
  };

  // initialize
  identity(n, v);
  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip + ip * n];
    z[ip] = 0.0;
  }

  // begin rotation sequence
  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0.0;
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip * n + iq]);
      }
    }
    if (sm === 0.0) {
      break;
    }

    // first 3 sweeps
    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0.0;
    }
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g = 100.0 * Math.abs(a[ip * n + iq]);

        // after 4 sweeps
        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
          a[ip * n + iq] = 0.0;
        } else if (Math.abs(a[ip * n + iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip * n + iq] / h;
          } else {
            theta = 0.5 * h / a[ip * n + iq];
            t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));
            if (theta < 0.0) {
              t = -t;
            }
          }
          c = 1.0 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1.0 + c);
          h = t * a[ip * n + iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip * n + iq] = 0.0;

          // ip already shifted left by 1 unit
          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j * n + ip, j * n + iq);
          }
          // ip and iq already shifted left by 1 unit
          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip * n + j, j * n + iq);
          }
          // iq already shifted left by 1 unit
          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip * n + j, iq * n + j);
          }
          for (j = 0; j < n; j++) {
            vtkROTATE(v, j * n + ip, j * n + iq);
          }
        }
      }
    }
    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0.0;
    }
  }

  // this is NEVER called
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro('vtkMath::Jacobi: Error extracting eigenfunctions');
    return 0;
  }

  // sort eigenfunctions: these changes do not affect accuracy
  for (j = 0; j < n - 1; j++) {
    // boundary incorrect
    k = j;
    tmp = w[k];
    for (i = j + 1; i < n; i++) {
      // boundary incorrect, shifted already
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
        // why exchange if same?
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      swapColumnsMatrix_nxn(v, n, j, k);
    }
  }
  // ensure eigenvector consistency (i.e., Jacobi can compute vectors that
  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can
  // reek havoc in hyperstreamline/other stuff. We will select the most
  // positive eigenvector.
  const ceil_half_n = (n >> 1) + (n & 1);
  for (numPos = 0, i = 0; i < n * n; i++) {
    if (v[i] >= 0.0) {
      numPos++;
    }
  }
  //    if ( numPos < ceil(double(n)/double(2.0)) )
  if (numPos < ceil_half_n) {
    for (i = 0; i < n; i++) {
      v[i * n + j] *= -1.0;
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  const tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

  // on-diagonal elements
  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8];

  // off-diagonal elements
  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  const eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  const eigenvalues = [0, 0, 0, 0];

  // convert into format that JacobiN can use,
  // then use Jacobi to find eigenvalues and eigenvectors
  // tmp is copied because jacobiN may modify it
  const NTemp = [...tmp];
  jacobiN(NTemp, 4, eigenvalues, eigenvectors);

  // the first eigenvector is the one we want
  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  const ww = quat_1[0] * quat_2[0];
  const wx = quat_1[0] * quat_2[1];
  const wy = quat_1[0] * quat_2[2];
  const wz = quat_1[0] * quat_2[3];
  const xw = quat_1[1] * quat_2[0];
  const xx = quat_1[1] * quat_2[1];
  const xy = quat_1[1] * quat_2[2];
  const xz = quat_1[1] * quat_2[3];
  const yw = quat_1[2] * quat_2[0];
  const yx = quat_1[2] * quat_2[1];
  const yy = quat_1[2] * quat_2[2];
  const yz = quat_1[2] * quat_2[3];
  const zw = quat_1[3] * quat_2[0];
  const zx = quat_1[3] * quat_2[1];
  const zy = quat_1[3] * quat_2[2];
  const zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  // copy the matrix
  for (let i = 0; i < 9; i++) {
    out_3x3[i] = a_3x3[i];
  }

  // Pivot the matrix to improve accuracy
  const scale = createArray(3);
  const index = createArray(3);
  let largest;

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    const x1 = Math.abs(out_3x3[i * 3]);
    const x2 = Math.abs(out_3x3[i * 3 + 1]);
    const x3 = Math.abs(out_3x3[i * 3 + 2]);
    largest = x2 > x1 ? x2 : x1;
    largest = x3 > largest ? x3 : largest;
    scale[i] = 1;
    if (largest !== 0) {
      scale[i] /= largest;
    }
  }

  // first column
  const x1 = Math.abs(out_3x3[0]) * scale[0];
  const x2 = Math.abs(out_3x3[3]) * scale[1];
  const x3 = Math.abs(out_3x3[6]) * scale[2];
  index[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }
  if (x3 >= largest) {
    index[0] = 2;
  }
  if (index[0] !== 0) {
    // swap vectors
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
    scale[index[0]] = scale[0];
  }

  // second column
  const y2 = Math.abs(out_3x3[4]) * scale[1];
  const y3 = Math.abs(out_3x3[7]) * scale[2];
  index[1] = 1;
  largest = y2;
  if (y3 >= largest) {
    index[1] = 2;
    // swap vectors
    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  }

  // third column
  index[2] = 2;

  // A quaternion can only describe a pure rotation, not
  // a rotation with a flip, therefore the flip must be
  // removed before the matrix is converted to a quaternion.
  let flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (let i = 0; i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }

  // Do orthogonalization using a quaternion intermediate
  // (this, essentially, does the orthogonalization via
  // diagonalization of an appropriately constructed symmetric
  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)
  const quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);

  // Put the flip back into the orthogonalized matrix.
  if (flip) {
    for (let i = 0; i < 9; i++) {
      out_3x3[i] = -out_3x3[i];
    }
  }

  // Undo the pivoting
  if (index[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);
  }
  if (index[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  let i;
  let j;
  let k;
  let maxI;
  let tmp;
  let maxVal;

  // a is copied because jacobiN may modify it
  const copyA = [...a_3x3];

  // diagonalize using Jacobi
  jacobiN(copyA, 3, w_3, v_3x3);

  // if all the eigenvalues are the same, return identity matrix
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }

  // transpose temporarily, it makes it easier to sort the eigenvectors
  transpose3x3(v_3x3, v_3x3);

  // if two eigenvalues are the same, re-orthogonalize to optimally line
  // up the eigenvectors with the x, y, and z axes
  for (i = 0; i < 3; i++) {
    // two eigenvalues are the same
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      // find maximum element of the independent eigenvector
      maxVal = Math.abs(v_3x3[i * 3]);
      maxI = 0;
      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      // swap the eigenvector into its proper position
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
      }
      // maximum element of eigenvector should be positive
      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      }

      // re-orthogonalize the other two eigenvectors
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j * 3] = 0.0;
      v_3x3[j * 3 + 1] = 0.0;
      v_3x3[j * 3 + 2] = 0.0;
      v_3x3[j * 3 + j] = 1.0;
      const vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
      normalize(vectTmp1);
      const vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);
      for (let t = 0; t < 3; t++) {
        v_3x3[k * 3 + t] = vectTmp1[t];
        v_3x3[j * 3 + t] = vectTmp2[t];
      }

      // transpose vectors back to columns
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }

  // the three eigenvalues are different, just sort the eigenvectors
  // to align them with the x, y, and z axes

  // find the vector with the largest x element, make that vector
  // the first vector
  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;
  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  // swap eigenvalue and eigenvector
  if (maxI !== 0) {
    const eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  }
  // do the same for the y element
  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    const eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  }

  // ensure that the sign of the eigenvectors is correct
  for (i = 0; i < 2; i++) {
    if (v_3x3[i * 3 + i] < 0) {
      v_3x3[i * 3] = -v_3x3[i * 3];
      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
    }
  }
  // set sign of final eigenvector to ensure that determinant is positive
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  }

  // transpose the eigenvectors back again
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  let i;
  // copy so that A can be used for U or VT without risk
  const B = [...a_3x3];

  // temporarily flip if determinant is negative
  const d = determinant3x3(B);
  if (d < 0) {
    for (i = 0; i < 9; i++) {
      B[i] = -B[i];
    }
  }

  // orthogonalize, diagonalize, etc.
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);

  // re-create the flip
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}

/**
 * Factor linear equations Ax = b using LU decomposition A = LU. Output factorization LU is in matrix A.
 * @param {Matrix} A square matrix
 * @param {Number} index integer array of pivot indices index[0->n-1]
 * @param {Number} size matrix size
 */
function luFactorLinearSystem(A, index, size) {
  let i;
  let j;
  let k;
  let largest;
  let maxI = 0;
  let sum;
  let temp1;
  let temp2;
  const scale = createArray(size);

  //
  // Loop over rows to get implicit scaling information
  //
  for (i = 0; i < size; i++) {
    for (largest = 0.0, j = 0; j < size; j++) {
      if ((temp2 = Math.abs(A[i * size + j])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0.0) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }
    scale[i] = 1.0 / largest;
  }
  //
  // Loop over all columns using Crout's method
  //
  for (j = 0; j < size; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i * size + j];
      for (k = 0; k < i; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
    }
    //
    // Begin search for largest pivot element
    //
    for (largest = 0.0, i = j; i < size; i++) {
      sum = A[i * size + j];
      for (k = 0; k < j; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }
      A[i * size + j] = sum;
      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    //
    // Check for row interchange
    //
    if (j !== maxI) {
      for (k = 0; k < size; k++) {
        temp1 = A[maxI * size + k];
        A[maxI * size + k] = A[j * size + k];
        A[j * size + k] = temp1;
      }
      scale[maxI] = scale[j];
    }
    //
    // Divide by pivot element and perform elimination
    //
    index[j] = maxI;
    if (Math.abs(A[j * size + j]) <= _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }
    if (j !== size - 1) {
      temp1 = 1.0 / A[j * size + j];
      for (i = j + 1; i < size; i++) {
        A[i * size + j] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A, index, x, size) {
  let i;
  let j;
  let ii;
  let idx;
  let sum;
  //
  // Proceed with forward and backsubstitution for L and U
  // matrices.  First, forward substitution.
  //
  for (ii = -1, i = 0; i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];
    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i * size + j] * x[j];
      }
    } else if (sum !== 0.0) {
      ii = i;
    }
    x[i] = sum;
  }
  //
  // Now, back substitution
  //
  for (i = size - 1; i >= 0; i--) {
    sum = x[i];
    for (j = i + 1; j < size; j++) {
      sum -= A[i * size + j] * x[j];
    }
    x[i] = sum / A[i * size + i];
  }
}
function solveLinearSystem(A, x, size) {
  // if we solving something simple, just solve it
  if (size === 2) {
    const y = createArray(2);
    const det = determinant2x2(A[0], A[1], A[2], A[3]);
    if (det === 0.0) {
      // Unable to solve linear system
      return 0;
    }
    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }
  if (size === 1) {
    if (A[0] === 0.0) {
      // Unable to solve linear system
      return 0;
    }
    x[0] /= A[0];
    return 1;
  }

  //
  // System of equations is not trivial, use Crout's method
  //

  // Check on allocation of working vectors
  const index = createArray(size);

  // Factor and solve matrix
  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index, x, size);
  return 1;
}

// Note that A is modified during the inversion !
function invertMatrix(A, AI, size) {
  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  let column = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  const tmp1Size = index || createArray(size);
  const tmp2Size = column || createArray(size);

  // Factor matrix; then begin solving for inverse one column at a time.
  // Note: tmp1Size returned value is used later, tmp2Size is just working
  // memory whose values are not used in LUSolveLinearSystem
  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
    return null;
  }
  for (let j = 0; j < size; j++) {
    for (let i = 0; i < size; i++) {
      tmp2Size[i] = 0.0;
    }
    tmp2Size[j] = 1.0;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);
    for (let i = 0; i < size; i++) {
      AI[i * size + j] = tmp2Size[i];
    }
  }
  return AI;
}
function estimateMatrixCondition(A, size) {
  let minValue = +Number.MAX_VALUE;
  let maxValue = -Number.MAX_VALUE;

  // find the maximum value
  for (let i = 0; i < size; i++) {
    for (let j = i; j < size; j++) {
      if (Math.abs(A[i * size + j]) > maxValue) {
        maxValue = Math.abs(A[i * size + j]);
      }
    }
  }

  // find the minimum diagonal value
  for (let i = 0; i < size; i++) {
    if (Math.abs(A[i * size + i]) < minValue) {
      minValue = Math.abs(A[i * size + i]);
    }
  }
  if (minValue === 0.0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  // check dimensional consistency
  if (numberOfSamples < xOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }
  let i;
  let j;
  let k;

  // set up intermediate variables
  // Allocate matrix to hold X times transpose of X
  const XXt = createArray(xOrder * xOrder); // size x by x
  // Allocate the array of eigenvalues and eigenvectors
  const eigenvals = createArray(xOrder);
  const eigenvecs = createArray(xOrder * xOrder);

  // Calculate XXt upper half only, due to symmetry
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }

  // Compute the eigenvectors and eigenvalues
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);

  // Smallest eigenval is at the end of the list (xOrder-1), and solution is
  // corresponding eigenvec.
  for (i = 0; i < xOrder; i++) {
    mt[i] = eigenvecs[i * xOrder + xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  let checkHomogeneous = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  // check dimensional consistency
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }
  const homogenFlags = createArray(yOrder);
  let allHomogeneous = 1;
  let hmt;
  let homogRC = 0;
  let i;
  let j;
  let k;
  let someHomogeneous = 0;

  // Ok, first init some flags check and see if all the systems are homogeneous
  if (checkHomogeneous) {
    // If Y' is zero, it's a homogeneous system and can't be solved via
    // the pseudoinverse method. Detect this case, warn the user, and
    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn't
    // really make much sense for yOrder to be greater than one in this case,
    // since that's just yOrder occurrences of a 0 vector on the RHS, but
    // we allow it anyway. N

    // Initialize homogeneous flags on a per-right-hand-side basis
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i * yOrder + j]) > _Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VTK_SMALL_NUMBER */ .kP) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }

    // If we've got one system, and it's homogeneous, do it and bail out quickly.
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro('Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()');
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }

    // Ok, we've got more than one system of equations.
    // Figure out if we need to calculate the homogeneous equation solution for
    // any of them.
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }

  // If necessary, solve the homogeneous problem
  if (someHomogeneous) {
    // hmt is the homogeneous equation version of mt, the general solution.
    // hmt should be xOrder x yOrder, but since we are solving only the homogeneous part, here it is xOrder x 1
    hmt = createArray(xOrder);

    // Ok, solve the homogeneous problem
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }

  // set up intermediate variables
  const XXt = createArray(xOrder * xOrder); // size x by x
  const XXtI = createArray(xOrder * xOrder); // size x by x
  const XYt = createArray(xOrder * yOrder); // size x by y

  // first find the pseudoinverse matrix
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      // first calculate the XXt matrix, only do the upper half (symmetrical)
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }

      // now calculate the XYt matrix
      for (j = 0; j < yOrder; j++) {
        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }
  const successFlag = invertMatrix(XXt, XXtI, xOrder);

  // next get the inverse of XXt
  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i * yOrder + j] = 0.0;
        for (k = 0; k < xOrder; k++) {
          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
        }
      }
    }
  }

  // Fix up any of the solutions that correspond to the homogeneous equation
  // problem.
  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        // Fix this one
        for (i = 0; i < xOrder; i++) {
          mt[i * yOrder + j] = hmt[i * yOrder];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  let outFloatArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      // abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      // #abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      // ab01df => #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      // #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      // #ab01df00
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  let h;
  let s;
  const [r, g, b] = rgb;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;
  let cmax = r;
  let cmin = r;
  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  const v = cmax;
  if (v > 0.0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0.0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g - b) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g) / (cmax - cmin);
    }
    if (h < 0.0) {
      h += 1.0;
    }
  } else {
    h = 0.0;
  }

  // Set the values back to the array
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  const [h, s, v] = hsv;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;
  const fivesixth = 5.0 / 6.0;
  let r;
  let g;
  let b;

  // compute RGB from HSV
  if (h > onesixth && h <= onethird) {
    // green/red
    g = 1.0;
    r = (onethird - h) / onesixth;
    b = 0.0;
  } else if (h > onethird && h <= 0.5) {
    // green/blue
    g = 1.0;
    b = (h - onethird) / onesixth;
    r = 0.0;
  } else if (h > 0.5 && h <= twothird) {
    // blue/green
    b = 1.0;
    g = (twothird - h) / onesixth;
    r = 0.0;
  } else if (h > twothird && h <= fivesixth) {
    // blue/red
    b = 1.0;
    r = (h - twothird) / onesixth;
    g = 0.0;
  } else if (h > fivesixth && h <= 1.0) {
    // red/blue
    r = 1.0;
    b = (1.0 - h) / onesixth;
    g = 0.0;
  } else {
    // red/green
    r = 1.0;
    g = h / onesixth;
    b = 0.0;
  }

  // add Saturation to the equation.
  r = s * r + (1.0 - s);
  g = s * g + (1.0 - s);
  b = s * b + (1.0 - s);
  r *= v;
  g *= v;
  b *= v;

  // Assign back to the array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  // LAB to XYZ
  const [L, a, b] = lab;
  let var_Y = (L + 16) / 116;
  let var_X = a / 500 + var_Y;
  let var_Z = var_Y - b / 200;
  if (var_Y ** 3 > 0.008856) {
    var_Y **= 3;
  } else {
    var_Y = (var_Y - 16.0 / 116.0) / 7.787;
  }
  if (var_X ** 3 > 0.008856) {
    var_X **= 3;
  } else {
    var_X = (var_X - 16.0 / 116.0) / 7.787;
  }
  if (var_Z ** 3 > 0.008856) {
    var_Z **= 3;
  } else {
    var_Z = (var_Z - 16.0 / 116.0) / 7.787;
  }
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  xyz[0] = ref_X * var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65
  xyz[1] = ref_Y * var_Y; // ref_Y = 1.000
  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089
}

function xyz2lab(xyz, lab) {
  const [x, y, z] = xyz;
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  let var_X = x / ref_X; // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65
  let var_Y = y / ref_Y; // ref_Y = 1.000
  let var_Z = z / ref_Z; // ref_Z = 1.089

  if (var_X > 0.008856) var_X **= 1.0 / 3.0;else var_X = 7.787 * var_X + 16.0 / 116.0;
  if (var_Y > 0.008856) var_Y **= 1.0 / 3.0;else var_Y = 7.787 * var_Y + 16.0 / 116.0;
  if (var_Z > 0.008856) var_Z **= 1.0 / 3.0;else var_Z = 7.787 * var_Z + 16.0 / 116.0;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  const [x, y, z] = xyz;
  let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  let b = x * 0.0557 + y * -0.204 + z * 1.057;

  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.0031308) r = 1.055 * r ** (1 / 2.4) - 0.055;else r *= 12.92;
  if (g > 0.0031308) g = 1.055 * g ** (1 / 2.4) - 0.055;else g *= 12.92;
  if (b > 0.0031308) b = 1.055 * b ** (1 / 2.4) - 0.055;else b *= 12.92;

  // Clip colors. ideally we would do something that is perceptually closest
  // (since we can see colors outside of the display gamut), but this seems to
  // work well enough.
  let maxVal = r;
  if (maxVal < g) maxVal = g;
  if (maxVal < b) maxVal = b;
  if (maxVal > 1.0) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;

  // Push values back to array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  let [r, g, b] = rgb;
  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.04045) r = ((r + 0.055) / 1.055) ** 2.4;else r /= 12.92;
  if (g > 0.04045) g = ((g + 0.055) / 1.055) ** 2.4;else g /= 12.92;
  if (b > 0.04045) b = ((b + 0.055) / 1.055) ** 2.4;else b /= 12.92;

  // Observer. = 2 deg, Illuminant = D65
  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  const xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  const xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1.0;
  bounds[1] = -1.0;
  bounds[2] = 1.0;
  bounds[3] = -1.0;
  bounds[4] = 1.0;
  bounds[5] = -1.0;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0.0);
}

/**
 * @deprecated please use vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), points)
 */
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  let out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  let result = 0;
  if (range[0] !== range[1]) {
    // clamp
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    // normalize
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
const getScalarTypeFittingRange = notImplemented('GetScalarTypeFittingRange');
const getAdjustedScalarRange = notImplemented('GetAdjustedScalarRange');
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (let i = 0; i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (let i = 0; i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (let i = 0; i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p2, p3, center) {
  const v21 = createArray(3);
  const v32 = createArray(3);
  const v13 = createArray(3);
  const v12 = createArray(3);
  const v23 = createArray(3);
  const v31 = createArray(3);
  for (let i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }
  const norm12 = norm(v12);
  const norm23 = norm(v23);
  const norm13 = norm(v13);
  const crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  const normCross = norm(crossv21v32);
  const radius = norm12 * norm23 * norm13 / (2 * normCross);
  const normCross22 = 2 * normCross * normCross;
  const alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  const beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  const gamma = norm12 * norm12 * dot(v13, v23) / normCross22;
  for (let i = 0; i < 3; ++i) {
    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p3[i];
  }
  return radius;
}
const inf = Infinity;
const negInf = -Infinity;
const isInf = value => !Number.isFinite(value);
const {
  isFinite,
  isNaN
} = Number;
const isNan = isNaN;

// JavaScript - add-on ----------------------

function createUninitializedBounds() {
  return [].concat([Number.MAX_VALUE, -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE, -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE, -Number.MAX_VALUE // Z
  ]);
}

function getMajorAxisIndex(vector) {
  let maxValue = -1;
  let axisIndex = -1;
  for (let i = 0; i < vector.length; i++) {
    const value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }
  return axisIndex;
}

// Return the closest orthogonal matrix of 1, -1 and 0
// It works for both column major and row major matrices
// This function iteratively associate a column with a row by choosing
// the greatest absolute value from the remaining row and columns
// For each association, a -1 or a 1 is set in the output, depending on
// the sign of the value in the original matrix
function getSparseOrthogonalMatrix(matrix) {
  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  // Initialize rows and columns to available indices
  const rows = new Array(n);
  const cols = new Array(n);
  for (let i = 0; i < n; ++i) {
    rows[i] = i;
    cols[i] = i;
  }
  // No need for the last iteration: i = 0
  for (let i = n - 1; i > 0; i--) {
    // Loop invariant:
    // rows[0:i] and cols[0:i] contain the remaining rows and columns
    // rows]i:n[ and cols]i:n[ contain the associations found (rows[k] is associated with cols[k])
    let bestValue = -Infinity;
    let bestRowI = 0;
    let bestColI = 0;
    for (let rowI = 0; rowI <= i; ++rowI) {
      const row = rows[rowI];
      for (let colI = 0; colI <= i; ++colI) {
        const col = cols[colI];
        const absVal = Math.abs(matrix[row + n * col]);
        if (absVal > bestValue) {
          bestValue = absVal;
          bestRowI = rowI;
          bestColI = colI;
        }
      }
    }
    // Found an association between rows[bestRowI] and cols[bestColI]
    // Put both at the end of their array by swapping with i
    [rows[i], rows[bestRowI]] = [rows[bestRowI], rows[i]];
    [cols[i], cols[bestColI]] = [cols[bestColI], cols[i]];
  }

  // Convert row/column association to a matrix
  const output = new Array(n * n).fill(0);
  for (let i = 0; i < n; ++i) {
    const matIdx = rows[i] + n * cols[i];
    output[matIdx] = matrix[matIdx] < 0 ? -1 : 1;
  }
  return output;
}
function floatToHex2(value) {
  const integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return `0${integer.toString(16)}`;
}
function floatRGB2HexCode(rgbArray) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
  return `${prefix}${rgbArray.map(floatToHex2).join('')}`;
}
function floatToChar(f) {
  return Math.round(f * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return `rgb(${rgbArray.map(floatToChar).join(', ')})`;
  }
  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(rgbArray[1] || 0)}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
}

// ----------------------------------------------------------------------------
// Only Static API
// ----------------------------------------------------------------------------

var vtkMath = {
  Pi,
  ldexp,
  radiansFromDegrees,
  degreesFromRadians,
  round,
  floor,
  ceil,
  ceilLog2,
  min,
  max,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random,
  gaussian,
  add,
  subtract,
  multiplyScalar,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot,
  outer,
  cross,
  norm,
  normalize,
  perpendiculars,
  projectVector,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  identity,
  isIdentity,
  isIdentity3x3,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  roundNumber,
  roundVector,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN,
  isNaN,
  isFinite,
  // JS add-on
  createUninitializedBounds,
  getMajorAxisIndex,
  getSparseOrthogonalMatrix,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA
};

var vtkMath$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createArray: createArray,
  Pi: Pi,
  ldexp: ldexp,
  radiansFromDegrees: radiansFromDegrees,
  degreesFromRadians: degreesFromRadians,
  round: round,
  floor: floor,
  ceil: ceil,
  min: min,
  max: max,
  arrayMin: arrayMin,
  arrayMax: arrayMax,
  arrayRange: arrayRange,
  ceilLog2: ceilLog2,
  factorial: factorial,
  nearestPowerOfTwo: nearestPowerOfTwo,
  isPowerOfTwo: isPowerOfTwo,
  binomial: binomial,
  beginCombination: beginCombination,
  nextCombination: nextCombination,
  randomSeed: randomSeed,
  getSeed: getSeed,
  random: random,
  gaussian: gaussian,
  add: add,
  subtract: subtract,
  multiplyScalar: multiplyScalar,
  multiplyScalar2D: multiplyScalar2D,
  multiplyAccumulate: multiplyAccumulate,
  multiplyAccumulate2D: multiplyAccumulate2D,
  dot: dot,
  outer: outer,
  cross: cross,
  norm: norm,
  normalize: normalize,
  perpendiculars: perpendiculars,
  projectVector: projectVector,
  dot2D: dot2D,
  projectVector2D: projectVector2D,
  distance2BetweenPoints: distance2BetweenPoints,
  angleBetweenVectors: angleBetweenVectors,
  signedAngleBetweenVectors: signedAngleBetweenVectors,
  gaussianAmplitude: gaussianAmplitude,
  gaussianWeight: gaussianWeight,
  outer2D: outer2D,
  norm2D: norm2D,
  normalize2D: normalize2D,
  rowsToMat4: rowsToMat4,
  columnsToMat4: columnsToMat4,
  rowsToMat3: rowsToMat3,
  columnsToMat3: columnsToMat3,
  determinant2x2: determinant2x2,
  LUFactor3x3: LUFactor3x3,
  LUSolve3x3: LUSolve3x3,
  linearSolve3x3: linearSolve3x3,
  multiply3x3_vect3: multiply3x3_vect3,
  multiply3x3_mat3: multiply3x3_mat3,
  multiplyMatrix: multiplyMatrix,
  transpose3x3: transpose3x3,
  invert3x3: invert3x3,
  determinant3x3: determinant3x3,
  areEquals: areEquals,
  areMatricesEqual: areMatricesEqual,
  identity3x3: identity3x3,
  identity: identity,
  isIdentity: isIdentity,
  isIdentity3x3: isIdentity3x3,
  quaternionToMatrix3x3: quaternionToMatrix3x3,
  roundNumber: roundNumber,
  roundVector: roundVector,
  jacobiN: jacobiN,
  matrix3x3ToQuaternion: matrix3x3ToQuaternion,
  multiplyQuaternion: multiplyQuaternion,
  orthogonalize3x3: orthogonalize3x3,
  diagonalize3x3: diagonalize3x3,
  singularValueDecomposition3x3: singularValueDecomposition3x3,
  luFactorLinearSystem: luFactorLinearSystem,
  luSolveLinearSystem: luSolveLinearSystem,
  solveLinearSystem: solveLinearSystem,
  invertMatrix: invertMatrix,
  estimateMatrixCondition: estimateMatrixCondition,
  jacobi: jacobi,
  solveHomogeneousLeastSquares: solveHomogeneousLeastSquares,
  solveLeastSquares: solveLeastSquares,
  hex2float: hex2float,
  rgb2hsv: rgb2hsv,
  hsv2rgb: hsv2rgb,
  lab2xyz: lab2xyz,
  xyz2lab: xyz2lab,
  xyz2rgb: xyz2rgb,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  lab2rgb: lab2rgb,
  uninitializeBounds: uninitializeBounds,
  areBoundsInitialized: areBoundsInitialized,
  computeBoundsFromPoints: computeBoundsFromPoints,
  clampValue: clampValue,
  clampVector: clampVector,
  clampAndNormalizeValue: clampAndNormalizeValue,
  getScalarTypeFittingRange: getScalarTypeFittingRange,
  getAdjustedScalarRange: getAdjustedScalarRange,
  extentIsWithinOtherExtent: extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds: boundsIsWithinOtherBounds,
  pointIsWithinBounds: pointIsWithinBounds,
  solve3PointCircle: solve3PointCircle,
  inf: inf,
  negInf: negInf,
  isInf: isInf,
  isFinite: isFinite,
  isNaN: isNaN,
  isNan: isNan,
  createUninitializedBounds: createUninitializedBounds,
  getMajorAxisIndex: getMajorAxisIndex,
  getSparseOrthogonalMatrix: getSparseOrthogonalMatrix,
  floatToHex2: floatToHex2,
  floatRGB2HexCode: floatRGB2HexCode,
  float2CssRGBA: float2CssRGBA,
  'default': vtkMath
});




/***/ }),

/***/ 89265:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkMatrixBuilder)
/* harmony export */ });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35341);




const NoOp = v => v;
const EPSILON = 1e-6;
class Transform {
  constructor() {
    let useDegree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .glMatrix.toRadian */ .Fd.toRadian : NoOp;
  }
  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(src, originDirection[0], originDirection[1], originDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(src, src);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(dst, dst);
    const cosAlpha = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.dot */ .eR.dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, src, dst);
    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(this.tmp) < EPSILON) {
      // cross product is 0, so pick arbitrary axis perpendicular
      // to originDirection.
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, [1, 0, 0], originDirection);
      if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.length */ .eR.length(this.tmp) < EPSILON) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.cross */ .eR.cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromRotation */ .pB.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, transf);
    return this;
  }
  rotate(angle, axis) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, ...axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(this.tmp, this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
    return this;
  }
  rotateX(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateX */ .pB.rotateX(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateY(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateY */ .pB.rotateY(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  rotateZ(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateZ */ .pB.rotateZ(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }
  translate(x, y, z) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(this.matrix, this.matrix, this.tmp);
    return this;
  }
  scale(sx, sy, sz) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, sx, sy, sz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(this.matrix, this.matrix, this.tmp);
    return this;
  }
  multiply(mat4x4) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, mat4x4);
    return this;
  }
  multiply3x3(mat3x3) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
    return this;
  }
  invert() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(this.matrix, this.matrix);
    return this;
  }
  identity() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(this.matrix);
    return this;
  }

  //-----------

  apply(typedArray) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let nbIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    if ((0,_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.a)(_Math_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .IDENTITY */ .zK, this.matrix)) {
      // Make sure we can chain apply...
      return this;
    }
    const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
    for (let i = offset; i < size; i += 3) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i] = this.tmp[0];
      typedArray[i + 1] = this.tmp[1];
      typedArray[i + 2] = this.tmp[2];
    }

    // Make sure we can chain apply...
    return this;
  }
  getMatrix() {
    return this.matrix;
  }
  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(this.matrix, mat4x4);
    }
    return this;
  }
}
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};




/***/ }),

/***/ 74966:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPoints$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28914);




const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
const INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];

// ----------------------------------------------------------------------------
// vtkPoints methods
// ----------------------------------------------------------------------------

function vtkPoints(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPoints');

  // Forwarding methods
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function (nbPoints) {
    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function (idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
  publicAPI.getBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
      return INVALID_BOUNDS;
    }
    const xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    const yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };

  // Trigger the computation of bounds
  publicAPI.computeBounds = publicAPI.getBounds;

  // Initialize
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 3,
  dataType: _DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VtkDataTypes */ .JA.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkPoints');

// ----------------------------------------------------------------------------

var vtkPoints$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 80993:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkScalarsToColors$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _DataArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42008);
/* harmony import */ var _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62955);
/* harmony import */ var _Rendering_Core_Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33395);





const {
  ScalarMappingTarget,
  VectorMode
} = _ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
const {
  VtkDataTypes
} = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
const {
  ColorMode
} = _Rendering_Core_Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255.0 + 0.5);
}

// ----------------------------------------------------------------------------
// vtkScalarsToColors methods
// ----------------------------------------------------------------------------

function vtkScalarsToColors(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarsToColors');
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode.RGBCOLORS);
  publicAPI.build = () => {};
  publicAPI.isOpaque = () => true;

  //----------------------------------------------------------------------------
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValue = idx => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotation = idx => {
    if (model.annotationArray[idx] === undefined) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;

  //----------------------------------------------------------------------------
  publicAPI.removeAnnotation = value => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };

  //----------------------------------------------------------------------------
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1.0;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);

  //----------------------------------------------------------------------------
  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for
  // internal use (no pointer checks performed)
  publicAPI.getAnnotatedValueIndexInternal = value => {
    if (model.annotatedValueMap[value] !== undefined) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    // Treat as a NaN
    return -1;
  };

  //----------------------------------------------------------------------------
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0.0;
    rgba[1] = 0.0;
    rgba[2] = 0.0;
    rgba[3] = 0.0;
  };

  //----------------------------------------------------------------------------
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };

  // Description:
  // Internal methods that map a data array into a 4-component,
  // unsigned char RGBA array. The color mode determines the behavior
  // of mapping. If ColorMode.DEFAULT is set, then unsigned char
  // data arrays are treated as colors (and converted to RGBA if
  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays
  // are treated as colors (integer types are clamped in the range 0-255,
  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does
  // not have enough values to represent a color so mapping this type is
  // considered an error);
  // otherwise, the data is mapped through this instance
  // of ScalarsToColors. The component argument is used for data
  // arrays with more than one component; it indicates which component
  // to use to do the blending.  When the component argument is -1,
  // then the this object uses its own selected technique to change a
  // vector into a scalar to map.
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;

    // map scalars through lookup table only if needed
    if (colorMode === ColorMode.DEFAULT && (scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: 'vtkDataArray',
        name: 'temp',
        numberOfComponents: 4,
        dataType: VtkDataTypes.UNSIGNED_CHAR
      };
      const s = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance(newscalars);
      let component = componentIn;

      // If mapper did not specify a component, use the VectorMode
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }

        // Map the scalars to colors
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i = 0; i < length; i++) {
      let sum = 0.0;
      for (let j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };

  //----------------------------------------------------------------------------
  // Map a set of vector values through the table
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode.COMPONENT) {
      // make sure vectorComponent is within allowed range
      if (vectorComponent === -1) {
        // if set to -1, use default value provided by table
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      // make sure vectorSize is within allowed range
      if (vectorSize === -1) {
        // if set to -1, use default value provided by table
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode.COMPONENT;
      }
    }

    // increment input pointer to the first component to map
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }

    // map according to the current vector mode
    switch (vectorMode) {
      case VectorMode.COMPONENT:
        {
          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
          break;
        }
      case VectorMode.RGBCOLORS:
        {
          // publicAPI.mapColorsToColors(
          //   input, output, inComponents, vectorSize,
          //   outputFormat);
          break;
        }

      // MAGNITUDE is considered default
      case VectorMode.MAGNITUDE:
      default:
        {
          const magValues = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
            numberOfComponents: 1,
            values: new Float32Array(input.getNumberOfTuples())
          });
          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
          break;
        }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;
    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = _DataArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro('Cannot convert colors');
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();

    // map scalars through lookup table only if needed
    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {
      // we will be using the scalars directly, so look at the number of
      // components and the range
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1.0;
      }
      // otherwise look at the range of the alpha channel
      const range = scalars.getRange(numberOfComponents - 1);
      return range[0] === 255;
    }
    return true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  alpha: 1.0,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);

  // Create set macros for array (needs to know size)
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['mappingRange'], 2);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['mappingRange']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkScalarsToColors(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkScalarsToColors');

// ----------------------------------------------------------------------------

var vtkScalarsToColors$1 = {
  newInstance,
  extend,
  ..._ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay
};




/***/ }),

/***/ 62955:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkScalarsToColors),
/* harmony export */   y0: () => (/* binding */ ScalarMappingTarget)
/* harmony export */ });
/* unused harmony export VectorMode */
const VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
const ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget
};




/***/ }),

/***/ 88903:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCell$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _Core_Points_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74966);




// ----------------------------------------------------------------------------
// vtkCell methods
// ----------------------------------------------------------------------------

function vtkCell(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCell');
  publicAPI.initialize = function (points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index) => {
        // const start = 3 * pointId;
        // pointsData.set(p.subarray(start, start + 3), 3 * index);
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => {
    const nbPoints = model.points.getNumberOfPoints();
    const x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];
      for (let i = 1; i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.u)(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = () => {
    publicAPI.getBounds();
    let length = 0.0;
    let diff = 0;
    for (let i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length += diff * diff;
    }
    return length;
  };
  publicAPI.getParametricDistance = pcoords => {
    let pDist;
    let pDistMax = 0.0;
    for (let i = 0; i < 3; i++) {
      if (pcoords[i] < 0.0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1.0) {
        pDist = pcoords[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = cell => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {}; // virtual
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual
  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {
    _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');
  }; // virtual
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  if (!model.points) {
    model.points = _Core_Points_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
  }
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['points', 'pointsIds']);
  vtkCell(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkCell');

// ----------------------------------------------------------------------------

var vtkCell$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 25737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkLine$1)
});

// UNUSED EXPORTS: STATIC, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
const IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants = {
  IntersectionState
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
var Cell = __webpack_require__(88903);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Line.js






const {
  IntersectionState: Line_IntersectionState
} = Constants;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
function distanceToLine(x, p1, p2) {
  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  // Determine appropriate vector
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];

  // Get parametric location
  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = (0,Core_Math.d)(p21, p21);

  // trying to avoid an expensive fabs
  let tolerance = 1e-5 * num;
  if (denom !== 0.0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0.0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0.0 || outObj.t < 0.0) {
    // If parametric coordinate is within 0<=p<=1, then the point is closest to
    // the line.  Otherwise, it's closest to a point at the end of the line.
    closest = p1;
  } else if (outObj.t > 1.0) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = (0,Core_Math.e)(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b2, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u[0] = 0.0;
  v[0] = 0.0;

  // Determine line vectors.
  (0,Core_Math.s)(a2, a1, a21);
  (0,Core_Math.s)(b2, b1, b21);
  (0,Core_Math.s)(b1, a1, b1a1);

  // Compute the system (least squares) matrix.
  const A = [(0,Core_Math.d)(a21, a21), -(0,Core_Math.d)(a21, b21), -(0,Core_Math.d)(a21, b21), (0,Core_Math.d)(b21, b21)];

  // Compute the least squares system constant term.
  const c = [];
  c[0] = (0,Core_Math.d)(a21, b1a1);
  c[1] = -(0,Core_Math.d)(b21, b1a1);
  // Solve the system of equations
  if ((0,Core_Math.g)(A, c, 2) === 0) {
    // The lines are colinear. Therefore, one of the four endpoints is the
    // point of closest approach
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b2];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b2, b2, a2, a2];
    [v[0], v[0], u[0], u[0]];
    [u[0], u[0], v[0], v[0]];
    let obj;
    for (let i = 0; i < 4; i++) {
      obj = distanceToLine(p[i], l1[i], l2[i]);
      if (obj.distance < minDist) {
        minDist = obj.distance;
        obj.t;
      }
    }
    return Line_IntersectionState.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];

  // Check parametric coordinates for intersection.
  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {
    return Line_IntersectionState.YES_INTERSECTION;
  }
  return Line_IntersectionState.NO_INTERSECTION;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  distanceToLine,
  intersection
};

// ----------------------------------------------------------------------------
// vtkLine methods
// ----------------------------------------------------------------------------

function vtkLine(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLine');
  function isBetweenPoints(t) {
    return t >= 0.0 && t <= 1.0;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0.0;
    pcoords[2] = 0.0;
    const projXYZ = [];
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    const u = [];
    const v = [];
    const intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect === Line_IntersectionState.YES_INTERSECTION) {
      // make sure we are within tolerance
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if ((0,Core_Math.e)(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      // check to see if it lies within tolerance
      // one of the parametric coords must be outside 0-1
      if (outObj.t < 0.0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0.0;
          outObj.intersect = 1;
          outObj.betweenPoints = true; // Intersection is near p1
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1.0) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1.0;
          outObj.intersect = 1;
          outObj.betweenPoints = true; // Intersection is near p2
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0.0) {
        pcoords[0] = 0.0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1.0) {
        pcoords[0] = 1.0;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (let i = 0; i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1.0 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      esm/* quat.slerp */.Yu.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1.0 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  orientations: null // an array of two quat or null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  Cell/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['orientations']);
  vtkLine(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkLine');

// ----------------------------------------------------------------------------

var vtkLine$1 = {
  newInstance,
  extend,
  ...STATIC,
  ...Constants
};




/***/ }),

/***/ 99341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPiecewiseFunction$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkPiecewiseFunction methods
// ----------------------------------------------------------------------------

function vtkPiecewiseFunction(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPiecewiseFunction');

  // Return the number of points which specify this function
  publicAPI.getSize = () => model.nodes.length;

  // Return the type of function stored in object:
  // Function Types:
  //    0 : Constant        (No change in slope between end points)
  //    1 : NonDecreasing   (Always increasing or zero slope)
  //    2 : NonIncreasing   (Always decreasing or zero slope)
  //    3 : Varied          (Contains both decreasing and increasing slopes)
  //    4 : Unknown         (Error condition)
  //
  publicAPI.getType = () => {
    let value;
    let prevValue = 0.0;
    let functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (let i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;

      // Do not change the function type if equal
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              // NonDecreasing
              functionType = 1;
              break;
            case 2:
            default:
              // Varied
              functionType = 3;
              break;
          }
        } else {
          // value < prev_value
          switch (functionType) {
            case 0:
            case 2:
              // NonIncreasing
              functionType = 2;
              break;
            case 1:
            default:
              // Varied
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;

      // Exit loop if we find a Varied function
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return 'Constant';
      case 1:
        return 'NonDecreasing';
      case 2:
        return 'NonIncreasing';
      case 3:
      default:
        return 'Varied';
    }
  };

  // Since we no longer store the data in an array, we must
  // copy out of the vector into an array. No modified check -
  // could be added if performance is a problem
  publicAPI.getDataPointer = () => {
    const size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (let i = 0; i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };

  // Returns the first point location which starts a non-zero segment of the
  // function. Note that the value at this point may be zero.
  publicAPI.getFirstNonZeroValue = () => {
    // Check if no points specified
    if (model.nodes.length === 0) {
      return 0;
    }
    let allZero = 1;
    let x = 0.0;
    let i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0.0) {
        allZero = 0;
        break;
      }
    }

    // If every specified point has a zero value then return
    // a large value
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      // A point was found with a non-zero value
      // Return the value of the point that precedes this one
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      // If this is the first point in the function, return its
      // value is clamping is off, otherwise VTK_DOUBLE_MIN if
      // clamping is on.
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };

  // For a specified index value, get the node parameters
  publicAPI.getNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].y;
    val[2] = model.nodes[index].midpoint;
    val[3] = model.nodes[index].sharpness;
    return 1;
  };

  // For a specified index value, get the node parameters
  publicAPI.setNodeValue = (index, val) => {
    const size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro('Index out of range!');
      return -1;
    }
    const oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].y = val[1];
    model.nodes[index].midpoint = val[2];
    model.nodes[index].sharpness = val[3];
    if (oldX !== val[0]) {
      // The point has been moved, the order of points or the range might have
      // been modified.
      publicAPI.sortAndUpdateRange();
      // No need to call Modified() here because SortAndUpdateRange() has done it
      // already.
    } else {
      publicAPI.modified();
    }
    return 1;
  };

  // Adds a point to the function. If a duplicate point is inserted
  // then the function value at that location is set to the new value.
  // This is the legacy version that assumes midpoint = 0.5 and
  // sharpness = 0.0
  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);

  // Adds a point to the function and returns the array index of the point.
  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {
    // Error check
    if (midpoint < 0.0 || midpoint > 1.0) {
      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');
      return -1;
    }
    if (sharpness < 0.0 || sharpness > 1.0) {
      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');
      return -1;
    }

    // remove any node already at this X location
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }

    // Create the new node
    const node = {
      x,
      y,
      midpoint,
      sharpness
    };

    // Add it, then sort to get everything in order
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();

    // Now find this node so we can return the index
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If we didn't find it, something went horribly wrong so
    // return -1
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = nodes => {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };

  // Sort the vector in increasing order, then fill in
  // the Range
  publicAPI.sortAndUpdateRange = () => {
    model.nodes.sort((a, b) => a.x - b.x);
    const modifiedInvoked = publicAPI.updateRange();
    // If range is updated, Modified() has been called, don't call it again.
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.updateRange = () => {
    const oldRange = model.range.slice();
    const size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    // If the rage is the same, then no need to call Modified()
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };

  // Removes a point from the function. If no point is found then function
  // remains the same.
  publicAPI.removePoint = x => {
    // First find the node since we need to know its
    // index as our return value
    let i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }

    // If the node doesn't exist, we return -1
    if (i >= model.nodes.length) {
      return -1;
    }
    const retVal = i;

    // If the first or last point has been removed, then we update the range
    // No need to sort here as the order of points hasn't changed.
    let modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };

  // Removes all points from the function.
  publicAPI.removeAllPoints = () => {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };

  // Add in end points of line and remove any points between them
  // Legacy method with no way to specify midpoint and sharpness
  publicAPI.addSegment = (x1, y1, x2, y2) => {
    // First, find all points in this range and remove them
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }

    // Now add the points
    publicAPI.addPoint(x1, y1, 0.5, 0.0);
    publicAPI.addPoint(x2, y2, 0.5, 0.0);
  };

  // Return the value of the function at a position
  publicAPI.getValue = x => {
    const table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };

  // Remove all points outside the range, and make sure a point
  // exists at each end of the range. Used as a convenience method
  // for transfer function editors
  publicAPI.adjustRange = range => {
    if (range.length < 2) {
      return 0;
    }
    const functionRange = publicAPI.getRange();

    // Make sure we have points at each end of the range
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }

    // Remove all points out-of-range
    publicAPI.sortAndUpdateRange();
    for (let i = 0; i < model.nodes.length;) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };

  //--------------------------------------------------------------------------
  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {
    const d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };

  //----------------------------------------------------------------------------
  publicAPI.findMinimumXDistance = () => {
    const size = model.nodes.length;
    if (size < 2) {
      return -1.0;
    }
    let distance = model.nodes[1].x - model.nodes[0].x;
    for (let i = 0; i < size - 1; i++) {
      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };

  // Returns a table of function values evaluated at regular intervals
  /* eslint-disable prefer-destructuring */
  /* eslint-disable no-continue */
  publicAPI.getTable = function (xStart, xEnd, size, table) {
    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    let i;
    let idx = 0;
    const numNodes = model.nodes.length;

    // Need to keep track of the last value so that
    // we can fill in table locations past this with
    // this value if Clamping is On.
    let lastValue = 0.0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    let x = 0.0;
    let x1 = 0.0;
    let x2 = 0.0;
    let y1 = 0.0;
    let y2 = 0.0;
    let midpoint = 0.0;
    let sharpness = 0.0;

    // For each table entry
    for (i = 0; i < size; i++) {
      // Find our location in the table
      const tidx = stride * i;

      // Find our X location. If we are taking only 1 sample, make
      // it halfway between start and end (usually start and end will
      // be the same in this case)
      if (size > 1) {
        x = xStart + i / (size - 1.0) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }

      // Do we need to move to the next node?
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        // If we are at a valid point index, fill in
        // the value at this node, and the one before (the
        // two that surround our current sample location)
        // idx cannot be 0 since we just incremented it.
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;

          // We only need the previous midpoint and sharpness
          // since these control this region
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;

          // Move midpoint away from extreme ends of range to avoid
          // degenerate math
          if (midpoint < 0.00001) {
            midpoint = 0.00001;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }

      // Are we at the end? If so, just use the last value
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0.0;
      } else if (idx === 0) {
        // Are we before the first node? If so, duplicate this nodes values
        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;
      } else {
        // Otherwise, we are between two nodes - interpolate
        // Our first attempt at a normalized location [0,1] -
        // we will be modifying this based on midpoint and
        // sharpness to get the curve shape we want and to have
        // it pass through (y1+y2)/2 at the midpoint.
        let s = (x - x1) / (x2 - x1);

        // Readjust based on the midpoint - linear adjustment
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);
        }

        // override for sharpness > 0.99
        // In this case we just want piecewise constant
        if (sharpness > 0.99) {
          // Use the first value since we are below the midpoint
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            // Use the second value at or above the midpoint
            table[tidx] = y2;
            continue;
          }
        }

        // Override for sharpness < 0.01
        // In this case we want piecewise linear
        if (sharpness < 0.01) {
          // Simple linear interpolation
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }

        // We have a sharpness between [0.01, 0.99] - we will
        // used a modified hermite curve interpolation where we
        // derive the slope based on the sharpness, and we compress
        // the curve non-linearly based on the sharpness

        // First, we will adjust our position based on sharpness in
        // order to make the curve sharper (closer to piecewise constant)
        if (s < 0.5) {
          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);
        }

        // Compute some coefficients we will need for the hermite curve
        const ss = s * s;
        const sss = ss * s;
        const h1 = 2 * sss - 3 * ss + 1;
        const h2 = -2 * sss + 3 * ss;
        const h3 = sss - 2 * ss + s;
        const h4 = sss - ss;

        // Use one slope for both end points
        const slope = y2 - y1;
        const t = (1.0 - sharpness) * slope;

        // Compute the value
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;

        // Final error check to make sure we don't go outside
        // the Y range
        const min = y1 < y2 ? y1 : y2;
        const max = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min ? min : table[tidx];
        table[tidx] = table[tidx] > max ? max : table[tidx];
      }
    }
  };
}
/* eslint-enable prefer-destructuring */
/* eslint-enable no-continue */

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // model.function = NULL;
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Internal objects initialization
  model.nodes = [];

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setArray(publicAPI, model, ['range'], 2);

  // Create get macros for array
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['range']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkPiecewiseFunction(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkPiecewiseFunction');

// ----------------------------------------------------------------------------

var vtkPiecewiseFunction$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 87275:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkPolyData$1)
});

// UNUSED EXPORTS: CELL_FACTORY, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/vtk.js
var vtk = __webpack_require__(42852);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var CellArray = __webpack_require__(35056);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
var Cell = __webpack_require__(88903);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
const InitLink = {
  ncells: 0,
  cells: null
};
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) model.array.push({
    ncells: 0,
    cells: null
  });
  model.array.length = newSize;
}

// ----------------------------------------------------------------------------
// vtkCellLinks methods
// ----------------------------------------------------------------------------

function vtkCellLinks(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellLinks');

  /**
   * Build the link list array. All subclasses of vtkAbstractCellLinks
   * must support this method.
   */
  publicAPI.buildLinks = data => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();

    // fill out lists with number of references to cells
    const linkLoc = new Uint32Array(numPts);

    // Use fast path if polydata
    if (data.isA('vtkPolyData')) {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach(cellPointId => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach(cellPointId => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } // any other type of dataset
    else {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; cellId++) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = Cell/* default.newInstance */.Ay.newInstance();
        cell.getPointsIds().forEach(cellPointId => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = Cell/* default.newInstance */.Ay.newInstance();
        cell.getPointsIds().forEach(cellPointId => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } // end else
  };

  /**
   * Build the link list array with a provided connectivity array.
   */
  // publicAPI.buildLinks = (data, connectivity) => {};

  /**
   * Allocate the specified number of links (i.e., number of points) that
   * will be built.
   */
  publicAPI.allocate = function (numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };

  /**
   * Get a link structure given a point id.
   */
  publicAPI.getLink = ptId => model.array[ptId];

  /**
   * Get the number of cells using the point specified by ptId.
   */
  publicAPI.getNcells = ptId => model.array[ptId].ncells;

  /**
   * Return a list of cell ids using the point.
   */
  publicAPI.getCells = ptId => model.array[ptId].cells;

  /**
   * Insert a new point into the cell-links data structure. The size parameter
   * is the initial size of the list.
   */
  publicAPI.insertNextPoint = numLinks => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };

  /**
   * Insert a cell id into the list of cells (at the end) using the cell id
   * provided. (Make sure to extend the link list (if necessary) using the
   * method resizeCellList().)
   */
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Delete point (and storage) by destroying links to using cells.
   */
  publicAPI.deletePoint = ptId => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };

  /**
   * Delete the reference to the cell (cellId) from the point (ptId). This
   * removes the reference to the cellId from the cell list, but does not
   * resize the list (recover memory with resizeCellList(), if necessary).
   */
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };

  /**
   * Add the reference to the cell (cellId) from the point (ptId). This
   * adds a reference to the cellId from the cell list, but does not resize
   * the list (extend memory with resizeCellList(), if necessary).
   */
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Change the length of a point's link list (i.e., list of cells using a
   * point) by the size specified.
   */
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };

  /**
   * Reclaim any unused memory.
   */
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };

  /**
   * Reset to a state of no entries without freeing the memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = src => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };

  /**
   * Increment the count of the number of cells using the point.
   */
  publicAPI.incrementLinkCount = ptId => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = n => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };

  /**
   * Insert a cell id into the list of cells using the point.
   */
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0 // grow array by this point
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkCellLinks');

// ----------------------------------------------------------------------------

var vtkCellLinks$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
const CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,
  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,
  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,
  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};

// This list should contain the cell class names in
// the same order as in CellType.
const CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];
var Constants = {
  CellType,
  CellTypesStrings
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

/**
 * Given an int (as defined in vtkCellType.h) identifier for a class
 * return it's classname.
 */
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';
}

/**
 * Given a data object classname, return it's int identified (as
 * defined in vtkCellType.h)
 */
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}

/**
 * This convenience method is a fast check to determine if a cell type
 * represents a linear or nonlinear cell.  This is generally much more
 * efficient than getting the appropriate vtkCell and checking its IsLinear
 * method.
 */
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};

// ----------------------------------------------------------------------------
// vtkCellTypes methods
// ----------------------------------------------------------------------------

function vtkCellTypes(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellTypes');

  /**
   * Allocate memory for this array. Delete old storage only if necessary.
   */
  publicAPI.allocate = function () {
    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };

  /**
   * Add a cell at specified id.
   */
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };

  /**
   * Add a cell to the object in the next available slot.
   */
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };

  /**
   * Specify a group of cell types. This version is provided to maintain
   * backwards compatibility and does a copy of the cellLocations
   */
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };

  /**
   * Return the location of the cell in the associated vtkCellArray.
   */
  publicAPI.getCellLocation = cellId => model.locationArray[cellId];

  /**
   * Delete cell by setting to nullptr cell type.
   */
  publicAPI.deleteCell = cellId => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };

  /**
   * Return the number of types in the list.
   */
  publicAPI.getNumberOfTypes = () => model.maxId + 1;

  /**
   * Return true if type specified is contained in list; false otherwise.
   */
  publicAPI.isType = type => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Add the type specified to the end of the list. Range checking is performed.
   */
  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);

  /**
   * Return the type of cell.
   */
  publicAPI.getCellType = cellId => model.typeArray[cellId];

  /**
   * Reclaim any extra memory.
   */
  // TODO: publicAPI.squeeze = () =>  {};

  /**
   * Initialize object without releasing memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = src => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const CellTypes_DEFAULT_VALUES = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0,
  // allocated size of data
  maxId: -1,
  // maximum index inserted thus far
  extend: 1000 // grow array by this point
};

// ----------------------------------------------------------------------------

function CellTypes_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, CellTypes_DEFAULT_VALUES, initialValues);
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['size', 'maxId', 'extend']);
  macros2.m.getArray(publicAPI, model, ['typeArray', 'locationArray']);
  vtkCellTypes(publicAPI, model);
}

// ----------------------------------------------------------------------------

const CellTypes_newInstance = macros2.m.newInstance(CellTypes_extend, 'vtkCellTypes');

// ----------------------------------------------------------------------------

var vtkCellTypes$1 = {
  newInstance: CellTypes_newInstance,
  extend: CellTypes_extend,
  ...STATIC
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Line.js + 1 modules
var Line = __webpack_require__(25737);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js + 3 modules
var DataSet = __webpack_require__(69147);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points = __webpack_require__(74966);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js





// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkPointSet methods
// ----------------------------------------------------------------------------

function vtkPointSet(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPointSet');

  // Create empty points
  if (!model.points) {
    model.points = Points/* default.newInstance */.Ay.newInstance();
  } else {
    model.points = (0,vtk/* default */.A)(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = Points/* default.newInstance */.Ay.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PointSet_DEFAULT_VALUES = {
  // points: null,
};

// ----------------------------------------------------------------------------

function PointSet_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PointSet_DEFAULT_VALUES, initialValues);

  // Inheritance
  DataSet/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['points']);

  // Object specific methods
  vtkPointSet(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PointSet_newInstance = macros2.m.newInstance(PointSet_extend, 'vtkPointSet');

// ----------------------------------------------------------------------------

var vtkPointSet$1 = {
  newInstance: PointSet_newInstance,
  extend: PointSet_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
var Triangle = __webpack_require__(96703);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];
var Constants_Constants = {
  POLYDATA_FIELDS
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js











const {
  vtkWarningMacro
} = macros2.m;
const CELL_FACTORY = {
  [CellType.VTK_LINE]: Line/* default */.Ay,
  [CellType.VTK_POLY_LINE]: Line/* default */.Ay,
  [CellType.VTK_TRIANGLE]: Triangle/* default */.Ay
};

// ----------------------------------------------------------------------------
// vtkPolyData methods
// ----------------------------------------------------------------------------

function vtkPolyData(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyData');
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, letter => letter.toUpperCase()).replace(/\s+/g, '');
  }

  // build empty cell arrays and set methods
  POLYDATA_FIELDS.forEach(type => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = CellArray/* default.newInstance */.Ay.newInstance();
    } else {
      model[type] = (0,vtk/* default */.A)(model[type]);
    }
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach(type => {
      model[type] = CellArray/* default.newInstance */.Ay.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = () => {
    // here are the number of cells we have
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();

    // pre-allocate the space we need
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;

    // record locations and type of each cell.
    // verts
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }

    // lines
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }

    // polys
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }

    // strips
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }

    // set up the cell types data structure
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };

  /**
   * Create upward links from points to cells that use each point. Enables
   * topologically complex queries.
   */
  publicAPI.buildLinks = function () {
    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.cells === undefined) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = cellId => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = ptId => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };

  /**
   * If you know the type of cell, you may provide it to improve performances.
   */
  publicAPI.getCell = function (cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const PolyData_DEFAULT_VALUES = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};

// ----------------------------------------------------------------------------

function PolyData_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, PolyData_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macros2.m.get(publicAPI, model, ['cells', 'links']);
  macros2.m.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);

  // Object specific methods
  vtkPolyData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const PolyData_newInstance = macros2.m.newInstance(PolyData_extend, 'vtkPolyData');

// ----------------------------------------------------------------------------

var vtkPolyData$1 = {
  newInstance: PolyData_newInstance,
  extend: PolyData_extend
};




/***/ }),

/***/ 96703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkTriangle$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Cell_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88903);
/* harmony import */ var _Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16632);
/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25737);
/* harmony import */ var _Plane_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75127);






// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function computeNormalDirection(v1, v2, v3, n) {
  // order is important!!! maintain consistency with triangle vertex order
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0.0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n2 = [];

  // Compute supporting plane normals.
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  const s1 = -(0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n1, p1);
  const s2 = -(0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n2, p2);

  // Compute signed distances of points p1, q1, r1 from supporting
  // plane of second triangle.
  const dist1 = [(0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n2, p1) + s2, (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n2, q1) + s2, (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n2, r1) + s2];

  // If signs of all points are the same, all the points lie on the
  // same side of the supporting plane, and we can exit early.
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    // vtkDebugMacro(<<"Same side supporting plane 1!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  // Do the same for p2, q2, r2 and supporting plane of first
  // triangle.
  const dist2 = [(0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n1, p2) + s1, (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n1, q2) + s1, (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n1, r2) + s1];

  // If signs of all points are the same, all the points lie on the
  // same side of the supporting plane, and we can exit early.
  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
    // vtkDebugMacro(<<"Same side supporting plane 2!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  // Check for coplanarity of the supporting planes.
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    // vtkDebugMacro(<<"Coplanar!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }

  // There are more efficient ways to find the intersection line (if
  // it exists), but this is clear enough.
  const pts1 = [p1, q1, r1];
  const pts2 = [p2, q2, r2];

  // Find line of intersection (L = p + t*v) between two planes.
  const n1n2 = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(n1, n2);
  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);
  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);
  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  const v = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.j)(n1, n2, []);
  (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.l)(v);
  let index1 = 0;
  let index2 = 0;
  const t1 = [];
  const t2 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i = 0; i < 3; i++) {
    const id1 = i;
    const id2 = (i + 1) % 3;

    // Find t coordinate on line of intersection between two planes.
    const val1 = _Plane_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(val1.x, v) - (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(p, v);
    }
    const val2 = _Plane_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t2[index2++] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(val2.x, v) - (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(p, v);
    }
  }

  // If the value of the index is greater than 2, the intersecting point
  // actually is intersected by all three edges. In this case, set the two
  // edges to the two edges where the intersecting point is not the end point
  if (index1 > 2) {
    index1--;
    // swap
    const t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    const t22 = t2[2];
    t2[2] = t2[ts2];
    t2[ts2] = t22;
  }
  // Check if only one edge or all edges intersect the supporting
  // planes intersection.
  if (index1 !== 2 || index2 !== 2) {
    // vtkDebugMacro(<<"Only one edge intersecting!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }

  // Check for NaNs
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
    // vtkWarningMacro(<<"NaNs!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    // swap
    const t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t2[0] > t2[1]) {
    // swap
    const t21 = t2[1];
    t2[1] = t2[0];
    t2[0] = t21;
  }
  // Handle the different interval configuration cases.
  let tt1;
  let tt2;
  if (t1[1] < t2[0] || t2[1] < t1[0]) {
    // vtkDebugMacro(<<"No Overlap!");
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    }; // No overlap
  }

  if (t1[0] < t2[0]) {
    if (t1[1] < t2[1]) {
      // First point on surface 2, second point on surface 1
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t2[0];
      tt2 = t1[1];
    } else {
      // Both points belong to lines on surface 2
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t2[0];
      tt2 = t2[1];
    }
  } // t1[0] >= t2[0]
  else if (t1[1] < t2[1]) {
    // Both points belong to lines on surface 1
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    // First point on surface 1, second point on surface 2
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t2[1];
  }

  // Create actual intersection points.
  (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.m)(p, v, tt1, pt1);
  (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.m)(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  computeNormalDirection,
  computeNormal,
  intersectWithTriangle
};

// ----------------------------------------------------------------------------
// vtkTriangle methods
// ----------------------------------------------------------------------------

function vtkTriangle(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkTriangle');
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0.0;
    const closestPoint = [];
    const tol2 = tol * tol;

    // Get normal for triangle
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      // Intersect plane of triangle with line
      const plane = _Plane_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0.0;
        pcoords[1] = 0.0;
        outObj.intersect = 0;
        return outObj;
      }

      // Evaluate position
      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }

    // Normals are null, so the triangle is degenerated and
    // we still need to check intersection between line and
    // the longest edge.
    const dist2Pt1Pt2 = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(pt1, pt2);
    const dist2Pt2Pt3 = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(pt2, pt3);
    const dist2Pt3Pt1 = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(pt3, pt1);
    if (!model.line) {
      model.line = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      // Compute r and s manually, using dot and norm.
      for (let i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.d)(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0.0;
    pcoords[1] = 0.0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    // will return obj
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0.0;

    // Get normal for triangle, only the normal direction is needed, i.e. the
    // normal need not be normalized (unit length)
    //
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);

    // Project point to plane
    _Plane_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.generalizedProjectPoint(x, pt1, n, cp);

    // Construct matrices.  Since we have over determined system, need to find
    // which 2 out of 3 equations to use to develop equations. (Any 2 should
    // work since we've projected point to plane.)
    let maxComponent = 0.0;
    for (i = 0; i < 3; i++) {
      // trying to avoid an expensive call to fabs()
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.o)(c1, c2);
    if (det === 0.0) {
      pcoords[0] = 0.0;
      pcoords[1] = 0.0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.o)(rhs, c2) / det;
    pcoords[1] = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.o)(c1, rhs) / det;

    // Okay, now find closest point to element
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {
      // projection distance
      if (closestPoint) {
        outObj.dist2 = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0.0 && weights[2] < 0.0) {
          dist2Point = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(x, pt3);
          dist2Line1 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0.0 && weights[0] < 0.0) {
          dist2Point = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(x, pt1);
          dist2Line1 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0.0 && weights[0] < 0.0) {
          dist2Point = (0,_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.e)(x, pt2);
          dist2Line1 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0.0) {
          const lineDistance = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0.0) {
          const lineDistance = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0.0) {
          const lineDistance = _Line_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1.0 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = pcoords => {
    let pDist;
    let pDistMax = 0.0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1.0 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      if (pc[i] < 0.0) {
        pDist = -pc[i];
      } else if (pc[i] > 1.0) {
        pDist = pc[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  _Cell_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkTriangle');

// ----------------------------------------------------------------------------

var vtkTriangle$1 = {
  newInstance,
  extend,
  ...STATIC
};




/***/ }),

/***/ 61088:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCutter$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87275);



const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;
function initPolyIterator(pd) {
  const polys = pd.getPolys().getData();
  const strips = pd.getStrips().getData();
  const it = {
    cellSize: 0,
    cell: [],
    done: false,
    polyIdx: 0,
    stripIdx: 0,
    remainingStripLength: 0,
    // returns a single poly cell
    next() {
      if (it.polyIdx < polys.length) {
        it.cellSize = polys[it.polyIdx];
        const start = it.polyIdx + 1;
        const end = start + it.cellSize;
        it.polyIdx = end;
        let p = 0;
        for (let i = start; i < end; ++i) {
          it.cell[p++] = polys[i];
        }
      } else if (it.stripIdx < strips.length) {
        it.cellSize = 3;
        if (it.remainingStripLength === 0) {
          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points
          // stripIdx points to the last point in a triangle 3-tuple
          it.stripIdx += 3;
        }
        const start = it.stripIdx - 2;
        const end = it.stripIdx + 1;
        it.stripIdx++;
        it.remainingStripLength--;
        let p = 0;
        for (let i = start; i < end; ++i) {
          it.cell[p++] = strips[i];
        }
      } else if (!it.done) {
        it.done = true;
      } else {
        throw new Error('Iterator is done');
      }
    }
  };
  it.next();
  return it;
}

// ----------------------------------------------------------------------------
// vtkCutter methods
// ----------------------------------------------------------------------------

function vtkCutter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCutter');

  // Capture "parentClass" api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getMTime = () => {
    let mTime = superClass.getMTime();
    if (!model.cutFunction) {
      return mTime;
    }
    mTime = Math.max(mTime, model.cutFunction.getMTime());
    return mTime;
  };
  function dataSetCutter(input, output) {
    const points = input.getPoints();
    const pointsData = points.getData();
    const numPts = points.getNumberOfPoints();
    const newPointsData = [];
    const newLinesData = [];
    const newPolysData = [];
    if (!model.cutScalars || model.cutScalars.length < numPts) {
      model.cutScalars = new Float32Array(numPts);
    }

    // Loop over all points evaluating scalar function at each point
    let inOffset = 0;
    let outOffset = 0;
    while (inOffset < pointsData.length) {
      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);
    }
    const crossedEdges = [];
    const x1 = new Array(3);
    const x2 = new Array(3);
    const cellPointsScalars = [];

    // Loop over all cells; get scalar values for all cell points
    // and process each cell.
    /* eslint-disable no-continue */
    for (const it = initPolyIterator(input); !it.done; it.next()) {
      // cell contains the point IDs/indices

      // Check that cells have at least 3 points
      if (it.cellSize <= 2) {
        continue;
      }

      // Get associated scalar of points that constitute the current cell
      for (let i = 0; i < it.cellSize;) {
        cellPointsScalars[i] = model.cutScalars[it.cell[i++]];
      }

      // Check if all cell points are on same side (same side == cell not crossed by cut function)
      // TODO: won't work if one point scalar is = 0 ?
      const sideFirstPoint = cellPointsScalars[0] > 0;
      let allPointsSameSide = true;
      for (let i = 1; i < it.cell.length; i++) {
        const sideCurrentPoint = cellPointsScalars[i] > 0;
        if (sideCurrentPoint !== sideFirstPoint) {
          allPointsSameSide = false;
          break;
        }
      }

      // Go to next cell if cell is not crossed by cut function
      if (allPointsSameSide) {
        continue;
      }

      // Find and compute edges which intersect cells
      const intersectedEdgesList = [];
      for (let i = 0; i < it.cellSize; i++) {
        const idNext = i + 1 === it.cellSize ? 0 : i + 1;

        // Go to next edge if edge is not crossed
        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell
        // will be crossed, but if it crosses right at a point, it could be intersecting
        // with (numberOfPoints) or 1 edge(s). Do we account for that?
        const signPoint0 = cellPointsScalars[i] > 0;
        const signPoint1 = cellPointsScalars[idNext] > 0;
        if (signPoint1 === signPoint0) {
          continue;
        }

        // Compute preferred interpolation direction
        let e1 = i;
        let e2 = idNext;
        let deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];
        if (deltaScalar <= 0) {
          e1 = idNext;
          e2 = i;
          deltaScalar *= -1;
        }

        // linear interpolation
        let t = 0.0;
        if (deltaScalar !== 0.0) {
          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;
        }

        // points position
        const pointID1 = it.cell[e1];
        const pointID2 = it.cell[e2];
        x1[0] = pointsData[pointID1 * 3];
        x1[1] = pointsData[pointID1 * 3 + 1];
        x1[2] = pointsData[pointID1 * 3 + 2];
        x2[0] = pointsData[pointID2 * 3];
        x2[1] = pointsData[pointID2 * 3 + 1];
        x2[2] = pointsData[pointID2 * 3 + 2];

        // Compute the intersected point on edge
        const computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])];

        // Keep track of it
        intersectedEdgesList.push({
          pointEdge1: pointID1,
          // id of one point of the edge
          pointEdge2: pointID2,
          // id of one point of the edge
          intersectedPoint: computedIntersectedPoint,
          // 3D coordinate of points that intersected edge
          newPointID: -1 // id of the intersected point when it will be added into vtkPoints
        });
      }

      // Add points into newPointList
      for (let i = 0; i < intersectedEdgesList.length; i++) {
        const intersectedEdge = intersectedEdgesList[i];
        let alreadyAdded = false;
        // Check if point/edge already added
        for (let j = 0; j < crossedEdges.length; j++) {
          const crossedEdge = crossedEdges[j];
          const sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;
          const samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];
          if (sameEdge || samePoint) {
            alreadyAdded = true;
            intersectedEdgesList[i].newPointID = crossedEdges[j].newPointID;
            break;
          }
        }
        if (!alreadyAdded) {
          newPointsData.push(intersectedEdge.intersectedPoint[0]);
          newPointsData.push(intersectedEdge.intersectedPoint[1]);
          newPointsData.push(intersectedEdge.intersectedPoint[2]);
          intersectedEdgesList[i].newPointID = newPointsData.length / 3 - 1;
          crossedEdges.push(intersectedEdgesList[i]);
        }
      }

      // Store cells
      const cellSize = intersectedEdgesList.length;
      if (cellSize === 2) {
        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);
      } else if (cellSize > 2) {
        newPolysData.push(cellSize);
        intersectedEdgesList.forEach(edge => {
          newPolysData.push(edge.newPointID);
        });
      }
    }

    // Set points
    const outputPoints = output.getPoints();
    outputPoints.setData((0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.b)(points.getDataType(), newPointsData), 3);

    // Set lines
    if (newLinesData.length !== 0) {
      output.getLines().setData(Uint16Array.from(newLinesData));
    }

    // Set polys
    if (newPolysData.length !== 0) {
      output.getPolys().setData(Uint16Array.from(newPolysData));
    }
  }

  // expose requestData
  publicAPI.requestData = (inData, outData) => {
    // implement requestData
    const input = inData[0];
    if (!input) {
      vtkErrorMacro('Invalid or missing input');
      return;
    }
    if (!model.cutFunction) {
      vtkErrorMacro('Missing cut function');
      return;
    }
    const output = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    dataSetCutter(input, output);
    outData[0] = output;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  cutFunction: null,
  // support method with evaluateFunction method
  cutScalars: null,
  cutValue: 0.0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Make this a VTK object
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.o)(publicAPI, model);

  // Also make it an algorithm with one input and one output
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.d)(publicAPI, model, 1, 1);

  // Set implicit function use to cut the input data (is vtkPlane)
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['cutFunction', 'cutValue']);

  // Object specific methods
  vtkCutter(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkCutter');

// ----------------------------------------------------------------------------

var vtkCutter$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 56748:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCubeSource$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35056);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87275);
/* harmony import */ var _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89265);






// prettier-ignore
const LINE_ARRAY = [2, 0, 1, 2, 2, 3, 2, 4, 5, 2, 6, 7, 2, 0, 2, 2, 1, 3, 2, 4, 6, 2, 5, 7, 2, 0, 4, 2, 1, 5, 2, 2, 6, 2, 3, 7];

// prettier-ignore
const POLY_ARRAY = [4, 0, 1, 3, 2, 4, 4, 6, 7, 5, 4, 8, 10, 11, 9, 4, 12, 13, 15, 14, 4, 16, 18, 19, 17, 4, 20, 21, 23, 22];

// ----------------------------------------------------------------------------
// vtkCubeSource methods
// ----------------------------------------------------------------------------

function vtkCubeSource(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCubeSource');
  function requestData(inData, outData) {
    if (model.deleted) {
      return;
    }
    const polyData = _Common_DataModel_PolyData_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
    outData[0] = polyData;
    const numberOfPoints = 24;

    // Define points
    const points = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);
    polyData.getPoints().setData(points, 3);
    const normals = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * 3);
    const normalArray = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
      name: 'Normals',
      values: normals,
      numberOfComponents: 3
    });
    polyData.getPointData().setNormals(normalArray);
    let tcdim = 2;
    if (model.generate3DTextureCoordinates === true) {
      tcdim = 3;
    }
    const textureCoords = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(model.pointType, numberOfPoints * tcdim);
    const tcoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
      name: 'TextureCoordinates',
      values: textureCoords,
      numberOfComponents: tcdim
    });
    polyData.getPointData().setTCoords(tcoords);
    const x = [0.0, 0.0, 0.0];
    const n = [0.0, 0.0, 0.0];
    const tc = [0.0, 0.0];
    let pointIndex = 0;
    x[0] = -model.xLength / 2.0;
    n[0] = -1.0;
    n[1] = 0.0;
    n[2] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[2] = -model.zLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[2] + 0.5) * (1 - 2 * i);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[1] += model.yLength;
      }
      x[0] += model.xLength;
      n[0] += 2.0;
    }
    x[1] = -model.yLength / 2.0;
    n[1] = -1.0;
    n[0] = 0.0;
    n[2] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[0] = -model.xLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[0] = (x[0] + 0.5) * (2 * i - 1);
        x[2] = -model.zLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[1] = (x[2] + 0.5) * -1;
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * i - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * k - 1;
          }
          pointIndex++;
          x[2] += model.zLength;
        }
        x[0] += model.xLength;
      }
      x[1] += model.yLength;
      n[1] += 2.0;
    }
    x[2] = -model.zLength / 2.0;
    n[2] = -1.0;
    n[0] = 0.0;
    n[1] = 0.0;
    for (let i = 0; i < 2; i++) {
      x[1] = -model.yLength / 2.0;
      for (let j = 0; j < 2; j++) {
        tc[1] = x[1] + 0.5;
        x[0] = -model.xLength / 2.0;
        for (let k = 0; k < 2; k++) {
          tc[0] = (x[0] + 0.5) * (2 * i - 1);
          points[pointIndex * 3] = x[0];
          points[pointIndex * 3 + 1] = x[1];
          points[pointIndex * 3 + 2] = x[2];
          normals[pointIndex * 3] = n[0];
          normals[pointIndex * 3 + 1] = n[1];
          normals[pointIndex * 3 + 2] = n[2];
          if (tcdim === 2) {
            textureCoords[pointIndex * tcdim] = tc[0];
            textureCoords[pointIndex * tcdim + 1] = tc[1];
          } else {
            textureCoords[pointIndex * tcdim] = 2 * k - 1;
            textureCoords[pointIndex * tcdim + 1] = 2 * j - 1;
            textureCoords[pointIndex * tcdim + 2] = 2 * i - 1;
          }
          pointIndex++;
          x[0] += model.xLength;
        }
        x[1] += model.yLength;
      }
      x[2] += model.zLength;
      n[2] += 2.0;
    }

    // Apply rotation to the points coordinates and normals
    if (model.rotations) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromDegree().rotateX(model.rotations[0]).rotateY(model.rotations[1]).rotateZ(model.rotations[2]).apply(points).apply(normals);
    }

    // Apply transformation to the points coordinates
    if (model.center) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().translate(...model.center).apply(points);
    }

    // Apply optional additionally specified matrix transformation
    if (model.matrix) {
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().setMatrix(model.matrix).apply(points);

      // prettier-ignore
      const rotMatrix = [model.matrix[0], model.matrix[1], model.matrix[2], 0, model.matrix[4], model.matrix[5], model.matrix[6], 0, model.matrix[8], model.matrix[9], model.matrix[10], 0, 0, 0, 0, 1];
      _Common_Core_MatrixBuilder_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.buildFromRadian().setMatrix(rotMatrix).apply(normals);
    }

    // Lastly, generate the necessary cell arrays.
    if (model.generateFaces) {
      polyData.getPolys().deepCopy(model._polys);
    } else {
      polyData.getPolys().initialize();
    }
    if (model.generateLines) {
      polyData.getLines().deepCopy(model._lineCells);
      // only set normals for faces, not for lines.
      polyData.getPointData().setNormals(null);
    } else {
      polyData.getLines().initialize();
    }
    polyData.modified();
  }
  publicAPI.setBounds = function () {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
      boundsArray = arguments.length <= 0 ? undefined : arguments[0];
    } else {
      for (let i = 0; i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    publicAPI.setXLength(boundsArray[1] - boundsArray[0]);
    publicAPI.setYLength(boundsArray[3] - boundsArray[2]);
    publicAPI.setZLength(boundsArray[5] - boundsArray[4]);
    publicAPI.setCenter([(boundsArray[0] + boundsArray[1]) / 2.0, (boundsArray[2] + boundsArray[3]) / 2.0, (boundsArray[4] + boundsArray[5]) / 2.0]);
  };

  // Expose methods
  publicAPI.requestData = requestData;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  xLength: 1.0,
  yLength: 1.0,
  zLength: 1.0,
  pointType: 'Float64Array',
  generate3DTextureCoordinates: false,
  generateFaces: true,
  generateLines: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['xLength', 'yLength', 'zLength', 'generate3DTextureCoordinates', 'generateFaces', 'generateLines']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['center', 'rotations'], 3);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['matrix'], 16);

  // Internal persistent/static objects
  model._polys = _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
    values: Uint16Array.from(POLY_ARRAY)
  });
  model._lineCells = _Common_Core_CellArray_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance({
    values: Uint16Array.from(LINE_ARRAY)
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['polys', 'lineCells']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 0, 1);
  vtkCubeSource(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkCubeSource');

// ----------------------------------------------------------------------------

var vtkCubeSource$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 56413:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ BinaryHelper)
/* harmony export */ });
/**
 * Converts a binary buffer in an ArrayBuffer to a string.
 *
 * Note this does not take encoding into consideration, so don't
 * expect proper Unicode or any other encoding.
 */
function arrayBufferToString(arrayBuffer) {
  const decoder = new TextDecoder('latin1');
  return decoder.decode(arrayBuffer);
}

/**
 * Extracts binary data out of a file ArrayBuffer given a prefix/suffix.
 */
function extractBinary(arrayBuffer, prefixRegex) {
  let suffixRegex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  const str = arrayBufferToString(arrayBuffer);
  const prefixMatch = prefixRegex.exec(str);
  if (!prefixMatch) {
    return {
      text: str
    };
  }
  const dataStartIndex = prefixMatch.index + prefixMatch[0].length;
  const strFirstHalf = str.substring(0, dataStartIndex);
  let retVal = null;
  const suffixMatch = suffixRegex ? suffixRegex.exec(str) : null;
  if (suffixMatch) {
    const strSecondHalf = str.substr(suffixMatch.index);
    retVal = {
      text: strFirstHalf + strSecondHalf,
      binaryBuffer: arrayBuffer.slice(dataStartIndex, suffixMatch.index)
    };
  } else {
    // no suffix, so just take all the data starting from dataStartIndex
    retVal = {
      text: strFirstHalf,
      binaryBuffer: arrayBuffer.slice(dataStartIndex)
    };
  }
  return retVal;
}
var BinaryHelper = {
  arrayBufferToString,
  extractBinary
};




/***/ }),

/***/ 8906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ DataAccessHelper),
/* harmony export */   uE: () => (/* binding */ registerType),
/* harmony export */   zy: () => (/* binding */ has)
/* harmony export */ });
/* unused harmony export get */
const TYPE_MAPPING = {};
function has(type) {
  return !!TYPE_MAPPING[type];
}
function get() {
  let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return TYPE_MAPPING[type](options);
}
function registerType(type, fn) {
  TYPE_MAPPING[type] = fn;
}
var DataAccessHelper = {
  get,
  has,
  registerType
};




/***/ }),

/***/ 67313:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Endian.js
function getEndianness() {
  const a = new ArrayBuffer(4);
  const b = new Uint8Array(a);
  const c = new Uint32Array(a);
  b[0] = 0xa1;
  b[1] = 0xb2;
  b[2] = 0xc3;
  b[3] = 0xd4;
  if (c[0] === 0xd4c3b2a1) return 'LittleEndian';
  if (c[0] === 0xa1b2c3d4) return 'BigEndian';
  return null;
}
const ENDIANNESS = getEndianness();
function swapBytes(buffer, wordSize) {
  if (wordSize < 2) {
    return;
  }
  const bytes = new Int8Array(buffer);
  const size = bytes.length;
  const tempBuffer = [];
  for (let i = 0; i < size; i += wordSize) {
    for (let j = 0; j < wordSize; j++) {
      tempBuffer.push(bytes[i + j]);
    }
    for (let j = 0; j < wordSize; j++) {
      bytes[i + j] = tempBuffer.pop();
    }
  }
}
var Endian = {
  ENDIANNESS,
  getEndianness,
  swapBytes
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var DataAccessHelper = __webpack_require__(8906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js





const {
  vtkErrorMacro,
  vtkDebugMacro
} = macros2.m;
const REJECT_COMPRESSION = () => {
  vtkErrorMacro('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.');
  return Promise.reject(new Error('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.'));
};

/* eslint-disable prefer-promise-reject-errors */
let requestCount = 0;
function openAsyncXHR(method, url) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  if (options.headers) {
    Object.entries(options.headers).forEach(_ref => {
      let [key, value] = _ref;
      return xhr.setRequestHeader(key, value);
    });
  }
  if (options.progressCallback) {
    xhr.addEventListener('progress', options.progressCallback);
  }
  return xhr;
}
function fetchBinary(url) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR('GET', url, options);
    xhr.onreadystatechange = e => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.response);
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };

    // Make request
    xhr.responseType = 'arraybuffer';
    xhr.send();
  });
}
function fetchArray(instance, baseURL, array) {
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  if (array.ref && !array.ref.pending) {
    return new Promise((resolve, reject) => {
      const url = [baseURL, array.ref.basepath, array.ref.id].join('/');
      const xhr = openAsyncXHR('GET', url, options);
      xhr.onreadystatechange = e => {
        if (xhr.readyState === 1) {
          array.ref.pending = true;
          if (++requestCount === 1 && instance?.invokeBusy) {
            instance.invokeBusy(true);
          }
        }
        if (xhr.readyState === 4) {
          array.ref.pending = false;
          if (xhr.status === 200 || xhr.status === 0) {
            array.buffer = xhr.response;
            if (array.ref.encode === 'JSON') {
              array.values = JSON.parse(array.buffer);
            } else {
              if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
                // Need to swap bytes
                vtkDebugMacro(`Swap bytes of ${array.name}`);
                Endian.swapBytes(array.buffer, Constants/* DataTypeByteSize */.uP[array.dataType]);
              }
              array.values = macros2.m.newTypedArray(array.dataType, array.buffer);
            }
            if (array.values.length !== array.size) {
              vtkErrorMacro(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
            }

            // Done with the ref and work
            delete array.ref;
            if (--requestCount === 0 && instance?.invokeBusy) {
              instance.invokeBusy(false);
            }
            if (instance?.modified) {
              instance.modified();
            }
            resolve(array);
          } else {
            reject({
              xhr,
              e
            });
          }
        }
      };

      // Make request
      xhr.responseType = array.dataType !== 'string' ? 'arraybuffer' : 'text';
      xhr.send();
    });
  }
  return Promise.resolve(array);
}

// ----------------------------------------------------------------------------

function fetchJSON(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR('GET', url, options);
    xhr.onreadystatechange = e => {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && instance?.invokeBusy) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount === 0 && instance?.invokeBusy) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };

    // Make request
    xhr.responseType = 'text';
    xhr.send();
  });
}

// ----------------------------------------------------------------------------

function fetchText(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (options && options.compression) {
    return REJECT_COMPRESSION();
  }
  return new Promise((resolve, reject) => {
    const xhr = openAsyncXHR('GET', url, options);
    xhr.onreadystatechange = e => {
      if (xhr.readyState === 1) {
        if (++requestCount === 1 && instance?.invokeBusy) {
          instance.invokeBusy(true);
        }
      }
      if (xhr.readyState === 4) {
        if (--requestCount === 0 && instance?.invokeBusy) {
          instance.invokeBusy(false);
        }
        if (xhr.status === 200 || xhr.status === 0) {
          resolve(xhr.responseText);
        } else {
          reject({
            xhr,
            e
          });
        }
      }
    };

    // Make request
    xhr.responseType = 'text';
    xhr.send();
  });
}

// ----------------------------------------------------------------------------

function fetchImage(instance, url) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return new Promise((resolve, reject) => {
    const img = new Image();
    if (options.crossOrigin) {
      img.crossOrigin = options.crossOrigin;
    }
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}
/* eslint-enable prefer-promise-reject-errors */

// ----------------------------------------------------------------------------

const LiteHttpDataAccessHelper = {
  fetchArray,
  fetchJSON,
  fetchText,
  fetchBinary,
  // Only for HTTP
  fetchImage
};

// The lite version should never override a full feature one...
if (!(0,DataAccessHelper/* has */.zy)('http')) {
  (0,DataAccessHelper/* registerType */.uE)('http', options => LiteHttpDataAccessHelper);
}




/***/ }),

/***/ 94199:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkXMLPolyDataReader$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js + 5 modules
var PolyData = __webpack_require__(87275);
// EXTERNAL MODULE: ../../../node_modules/xmlbuilder2/lib/xmlbuilder2.min.js
var xmlbuilder2_min = __webpack_require__(14235);
;// CONCATENATED MODULE: ../../../node_modules/fflate/esm/browser.js
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var ch2 = {};
var wk = (function (c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], { type: 'text/javascript' }))));
    w.onmessage = function (e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
            var err = new Error(ed[0]);
            err['code'] = ed[1];
            err.stack = ed[2];
            cb(err, null);
        }
        else
            cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
});

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
// see fleb note
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return [b, r];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) {
        if (cd[i])
            ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 0; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >>> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ (/* unused pure expression or super */ null && (hMap(flt, 9, 0))), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdm = /*#__PURE__*/ (/* unused pure expression or super */ null && (hMap(fdt, 5, 0))), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p + 7) / 8) | 0; };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (s == null || s < 0)
        s = 0;
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
};
/**
 * Codes for errors generated within this library
 */
var FlateErrorCode = {
    UnexpectedEOF: 0,
    InvalidBlockType: 1,
    InvalidLengthLiteral: 2,
    InvalidDistance: 3,
    StreamFinished: 4,
    NoStreamHandler: 5,
    InvalidHeader: 6,
    NoCallback: 7,
    InvalidUTF8: 8,
    ExtraFieldTooLong: 9,
    InvalidDate: 10,
    FilenameTooLong: 11,
    StreamFinishing: 12,
    InvalidZipData: 13,
    UnknownCompressionMethod: 14
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
    // determined by unknown compression method
];
;
var err = function (ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
    if (!nt)
        throw e;
    return e;
};
// expands raw DEFLATE data
var inflt = function (dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || (st && st.f && !st.l))
        return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st)
        st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        err(0);
                    break;
                }
                // ensure size
                if (noBuf)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8, st.f = final;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >>> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                err(1);
            if (pos > tbts) {
                if (noSt)
                    err(0);
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    err(0);
                break;
            }
            if (!c)
                err(2);
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d)
                    err(3);
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        err(0);
                    break;
                }
                if (noBuf)
                    cbuf(bt + 131072);
                var end = bt + add;
                for (; bt < end; bt += 4) {
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >>> 8;
    d[o + 2] |= v >>> 16;
};
// creates code lengths from a frequency table
var hTree = function (d, mb) {
    // Need extra info to make a tree
    var t = [];
    for (var i = 0; i < d.length; ++i) {
        if (d[i])
            t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
        return [et, 0];
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return [v, 1];
    }
    t.sort(function (a, b) { return a.f - b.f; });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
            maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
        for (; i < s; ++i) {
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << (mbt - tr[i2_1]));
                tr[i2_1] = mb;
            }
            else
                break;
        }
        dt >>>= lft;
        while (dt > 0) {
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb)
                dt -= 1 << (mb - tr[i2_2]++ - 1);
            else
                ++i;
        }
        for (; i >= 0 && dt; --i) {
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return [new u8(tr), mbt];
};
// get the max length and assign length codes
var ln = function (n, l, d) {
    return n.s == -1
        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
        : (l[n.s] = d);
};
// length codes generation
var lc = function (c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while (s && !c[--s])
        ;
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function (v) { cl[cli++] = v; };
    for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
            ++cls;
        else {
            if (!cln && cls > 2) {
                for (; cls > 138; cls -= 138)
                    w(32754);
                if (cls > 2) {
                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                    cls = 0;
                }
            }
            else if (cls > 3) {
                w(cln), --cls;
                for (; cls > 6; cls -= 6)
                    w(8304);
                if (cls > 2)
                    w(((cls - 3) << 5) | 8208), cls = 0;
            }
            while (cls--)
                w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return [cl.subarray(0, cli), s];
};
// calculate the length of output from tree, code lengths
var clen = function (cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function (out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >>> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
        lcfreq[lclt[i] & 31]++;
    for (var i = 0; i < lcdt.length; ++i)
        lcfreq[lcdt[i] & 31]++;
    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
    var flen = (bl + 5) << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
    if (flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i = 0; i < nlcc; ++i)
            wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
            var clct = lcts[it];
            for (var i = 0; i < clct.length; ++i) {
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15)
                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
            }
        }
    }
    else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
        if (syms[i] > 255) {
            var len = (syms[i] >>> 18) & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7)
                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
            var dst = syms[i] & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3)
                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
        }
        else {
            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function (dat, lvl, plvl, pre, post, lst) {
    var s = dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var pos = 0;
    if (!lvl || s < 8) {
        for (var i = 0; i <= s; i += 65535) {
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[pos >> 3] = lst;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
    }
    else {
        var opt = deo[lvl - 1];
        var n = opt >>> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = new u16(32768), head = new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new u32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
        for (; i < s; ++i) {
            // hash value
            // deopt when i > s - 3 - at end, deopt acceptable
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for (var j = 0; j < 286; ++j)
                        lf[j] = 0;
                    for (var j = 0; j < 30; ++j)
                        df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while (dif <= maxd && --ch_1 && imod != pimod) {
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                ;
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn)
                                    break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for (var j = 0; j < mmd; ++j) {
                                    var ti = (i - dif + j + 32768) & 32767;
                                    var pti = prev[ti];
                                    var cd = (ti - pti + 32768) & 32767;
                                    if (cd > md)
                                        md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += (imod - pimod + 32768) & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one Uint32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                }
                else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        // this is the easiest way to avoid needing to maintain state
        if (!lst && pos & 7)
            pos = wfblk(w, pos + 1, et);
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ (/* unused pure expression or super */ null && ((function () {
    var t = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
        var c = i, k = 9;
        while (--k)
            c = ((c & 1) && -306674912) ^ (c >>> 1);
        t[i] = c;
    }
    return t;
})()));
// CRC32
var crc = function () {
    var c = -1;
    return {
        p: function (d) {
            // closures have awful performance
            var cr = c;
            for (var i = 0; i < d.length; ++i)
                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);
            c = cr;
        },
        d: function () { return ~c; }
    };
};
// Alder32
var adler = function () {
    var a = 1, b = 0;
    return {
        p: function (d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length | 0;
            for (var i = 0; i != l;) {
                var e = Math.min(i + 2655, l);
                for (; i < e; ++i)
                    m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function () {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);
        }
    };
};
;
// deflate with opts
var dopt = function (dat, opt, pre, post, st) {
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
};
// Walmart object spread
var mrg = function (a, b) {
    var o = {};
    for (var k in a)
        o[k] = a[k];
    for (var k in b)
        o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function (fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\s+/g, '').split(',');
    for (var i = 0; i < dt.length; ++i) {
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                }
                else {
                    fnStr += st_1;
                    for (var t in v.prototype)
                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            }
            else
                fnStr += st_1;
        }
        else
            td[k] = v;
    }
    return [fnStr, td];
};
var ch = (/* unused pure expression or super */ null && ([]));
// clone bufs
var cbfs = function (v) {
    var tl = [];
    for (var k in v) {
        if (v[k].buffer) {
            tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
    }
    return tl;
};
// use a worker to execute code
var wrkr = function (fns, init, id, cb) {
    var _a;
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for (var i = 0; i < m; ++i)
            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];
        ch[id] = wcln(fns[m], fnStr, td_1);
    }
    var td = mrg({}, ch[id][1]);
    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
// base async inflate fn
var bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8]; };
var bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };
// gzip extra
var gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };
// gunzip extra
var guze = function () { return [gzs, gzl]; };
// zlib extra
var zle = function () { return [zlh, wbytes, adler]; };
// unzlib extra
var zule = function () { return [zlv]; };
// post buf
var pbf = function (msg) { return postMessage(msg, [msg.buffer]); };
// get u8
var gu8 = function (o) { return o && o.size && new u8(o.size); };
// async helper
var cbify = function (dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function (err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function () { w.terminate(); };
};
// auto stream
var astrm = function (strm) {
    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };
    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };
};
// async stream attach
var astrmify = function (fns, strm, opts, init, id) {
    var t;
    var w = wrkr(fns, init, id, function (err, dat) {
        if (err)
            w.terminate(), strm.ondata.call(strm, err);
        else {
            if (dat[1])
                w.terminate();
            strm.ondata.call(strm, err, dat[0], dat[1]);
        }
    });
    w.postMessage(opts);
    strm.push = function (d, f) {
        if (!strm.ondata)
            err(5);
        if (t)
            strm.ondata(err(4, 0, 1), null, !!f);
        w.postMessage([d, t = f], [d.buffer]);
    };
    strm.terminate = function () { w.terminate(); };
};
// read 2 bytes
var b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };
// read 4 bytes
var b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };
var b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };
// write bytes
var wbytes = function (d, b, v) {
    for (; v; ++b)
        d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function (c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for (var i = 0; i <= fn.length; ++i)
            c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start
var gzs = function (d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        err(6, 'invalid gzip data');
    var flg = d[3];
    var st = 10;
    if (flg & 4)
        st += d[10] | (d[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
    return st + (flg & 2);
};
// gzip length
var gzl = function (d) {
    var l = d.length;
    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;
};
// gzip header length
var gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };
// zlib header
var zlh = function (c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);
};
// zlib valid
var zlv = function (d) {
    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        err(6, 'invalid zlib data');
    if (d[1] & 32)
        err(6, 'invalid zlib data: preset dictionaries not supported');
};
function AsyncCmpStrm(opts, cb) {
    if (!cb && typeof opts == 'function')
        cb = opts, opts = {};
    this.ondata = cb;
    return opts;
}
// zlib footer: -4 to -0 is Adler32
/**
 * Streaming DEFLATE compression
 */
var Deflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function Deflate(opts, cb) {
        if (!cb && typeof opts == 'function')
            cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
    }
    Deflate.prototype.p = function (c, f) {
        this.ondata(dopt(c, this.o, 0, 0, !f), f);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Deflate.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (this.d)
            err(4);
        this.d = final;
        this.p(chunk, final || false);
    };
    return Deflate;
}())));

/**
 * Asynchronous streaming DEFLATE compression
 */
var AsyncDeflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function AsyncDeflate(opts, cb) {
        astrmify([
            bDflt,
            function () { return [astrm, Deflate]; }
        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
            var strm = new Deflate(ev.data);
            onmessage = astrm(strm);
        }, 6);
    }
    return AsyncDeflate;
}())));

function deflate(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);
}
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */
var Inflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates an inflation stream
     * @param cb The callback to call whenever data is inflated
     */
    function Inflate(cb) {
        this.s = {};
        this.p = new u8(0);
        this.ondata = cb;
    }
    Inflate.prototype.e = function (c) {
        if (!this.ondata)
            err(5);
        if (this.d)
            err(4);
        var l = this.p.length;
        var n = new u8(l + c.length);
        n.set(this.p), n.set(c, l), this.p = n;
    };
    Inflate.prototype.c = function (final) {
        this.d = this.s.i = final || false;
        var bts = this.s.b;
        var dt = inflt(this.p, this.o, this.s);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;
    };
    /**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */
    Inflate.prototype.push = function (chunk, final) {
        this.e(chunk), this.c(final);
    };
    return Inflate;
}())));

/**
 * Asynchronous streaming DEFLATE decompression
 */
var AsyncInflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates an asynchronous inflation stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncInflate(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            function () { return [astrm, Inflate]; }
        ], this, 0, function () {
            var strm = new Inflate();
            onmessage = astrm(strm);
        }, 7);
    }
    return AsyncInflate;
}())));

function inflate(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt
    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);
}
/**
 * Expands DEFLATE data with no wrapper
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function inflateSync(data, out) {
    return inflt(data, out);
}
// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */
var Gzip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function Gzip(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gzip.prototype.push = function (chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
    };
    Gzip.prototype.p = function (c, f) {
        this.c.p(c);
        this.l += c.length;
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
        if (this.v)
            gzh(raw, this.o), this.v = 0;
        if (f)
            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
    };
    return Gzip;
}())));

/**
 * Asynchronous streaming GZIP compression
 */
var AsyncGzip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function AsyncGzip(opts, cb) {
        astrmify([
            bDflt,
            gze,
            function () { return [astrm, Deflate, Gzip]; }
        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
            var strm = new Gzip(ev.data);
            onmessage = astrm(strm);
        }, 8);
    }
    return AsyncGzip;
}())));

function gzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
        gze,
        function () { return [gzipSync]; }
    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);
}
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */
function gzipSync(data, opts) {
    if (!opts)
        opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming GZIP decompression
 */
var Gunzip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a GUNZIP stream
     * @param cb The callback to call whenever data is inflated
     */
    function Gunzip(cb) {
        this.v = 1;
        Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Gunzip.prototype.push = function (chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            var s = this.p.length > 3 ? gzs(this.p) : 4;
            if (s >= this.p.length && !final)
                return;
            this.p = this.p.subarray(s), this.v = 0;
        }
        if (final) {
            if (this.p.length < 8)
                err(6, 'invalid gzip data');
            this.p = this.p.subarray(0, -8);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
    };
    return Gunzip;
}())));

/**
 * Asynchronous streaming GZIP decompression
 */
var AsyncGunzip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates an asynchronous GUNZIP stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncGunzip(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            guze,
            function () { return [astrm, Inflate, Gunzip]; }
        ], this, 0, function () {
            var strm = new Gunzip();
            onmessage = astrm(strm);
        }, 9);
    }
    return AsyncGunzip;
}())));

function gunzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt,
        guze,
        function () { return [gunzipSync]; }
    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);
}
/**
 * Expands GZIP data
 * @param data The data to decompress
 * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
 * @returns The decompressed version of the data
 */
function gunzipSync(data, out) {
    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
/**
 * Streaming Zlib compression
 */
var Zlib = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function Zlib(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
    }
    /**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Zlib.prototype.push = function (chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
    };
    Zlib.prototype.p = function (c, f) {
        this.c.p(c);
        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
        if (this.v)
            zlh(raw, this.o), this.v = 0;
        if (f)
            wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
    };
    return Zlib;
}())));

/**
 * Asynchronous streaming Zlib compression
 */
var AsyncZlib = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function AsyncZlib(opts, cb) {
        astrmify([
            bDflt,
            zle,
            function () { return [astrm, Deflate, Zlib]; }
        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
            var strm = new Zlib(ev.data);
            onmessage = astrm(strm);
        }, 10);
    }
    return AsyncZlib;
}())));

function zlib(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
        zle,
        function () { return [zlibSync]; }
    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);
}
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */
function zlibSync(data, opts) {
    if (!opts)
        opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */
var Unzlib = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a Zlib decompression stream
     * @param cb The callback to call whenever data is inflated
     */
    function Unzlib(cb) {
        this.v = 1;
        Inflate.call(this, cb);
    }
    /**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzlib.prototype.push = function (chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
            if (this.p.length < 2 && !final)
                return;
            this.p = this.p.subarray(2), this.v = 0;
        }
        if (final) {
            if (this.p.length < 4)
                err(6, 'invalid zlib data');
            this.p = this.p.subarray(0, -4);
        }
        // necessary to prevent TS from using the closure value
        // This allows for workerization to function correctly
        Inflate.prototype.c.call(this, final);
    };
    return Unzlib;
}())));

/**
 * Asynchronous streaming Zlib decompression
 */
var AsyncUnzlib = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates an asynchronous Zlib decompression stream
     * @param cb The callback to call whenever data is deflated
     */
    function AsyncUnzlib(cb) {
        this.ondata = cb;
        astrmify([
            bInflt,
            zule,
            function () { return [astrm, Inflate, Unzlib]; }
        ], this, 0, function () {
            var strm = new Unzlib();
            onmessage = astrm(strm);
        }, 11);
    }
    return AsyncUnzlib;
}())));

function unzlib(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bInflt,
        zule,
        function () { return [unzlibSync]; }
    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);
}
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}
// Default algorithm for compression (used because having a known output size allows faster decompression)

// Default algorithm for compression (used because having a known output size allows faster decompression)

/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */
var Decompress = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a decompression stream
     * @param cb The callback to call whenever data is decompressed
     */
    function Decompress(cb) {
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Decompress.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (!this.s) {
            if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
            }
            else
                this.p = chunk;
            if (this.p.length > 2) {
                var _this_1 = this;
                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };
                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)
                    ? new this.G(cb)
                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))
                        ? new this.I(cb)
                        : new this.Z(cb);
                this.s.push(this.p, final);
                this.p = null;
            }
        }
        else
            this.s.push(chunk, final);
    };
    return Decompress;
}())));

/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */
var AsyncDecompress = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
   * Creates an asynchronous decompression stream
   * @param cb The callback to call whenever data is decompressed
   */
    function AsyncDecompress(cb) {
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncDecompress.prototype.push = function (chunk, final) {
        Decompress.prototype.push.call(this, chunk, final);
    };
    return AsyncDecompress;
}())));

function decompress(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return (data[0] == 31 && data[1] == 139 && data[2] == 8)
        ? gunzip(data, opts, cb)
        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
            ? inflate(data, opts, cb)
            : unzlib(data, opts, cb);
}
/**
 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function decompressSync(data, out) {
    return (data[0] == 31 && data[1] == 139 && data[2] == 8)
        ? gunzipSync(data, out)
        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))
            ? inflateSync(data, out)
            : unzlibSync(data, out);
}
// flatten a directory structure
var fltn = function (d, p, t, o) {
    for (var k in d) {
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val))
            op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8)
            t[n] = [val, op];
        else {
            t[n += '/'] = [new u8(0), op];
            fltn(val, n, t, o);
        }
    }
};
// text encoder
var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }
// decode UTF8
var dutf8 = function (d) {
    for (var r = '', i = 0;;) {
        var c = d[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d.length)
            return [r, slc(d, i - 1)];
        if (!eb)
            r += String.fromCharCode(c);
        else if (eb == 3) {
            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,
                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));
        }
        else if (eb & 1)
            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));
        else
            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));
    }
};
/**
 * Streaming UTF-8 decoding
 */
var DecodeUTF8 = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is decoded
     */
    function DecodeUTF8(cb) {
        this.ondata = cb;
        if (tds)
            this.t = new TextDecoder();
        else
            this.p = et;
    }
    /**
     * Pushes a chunk to be decoded from UTF-8 binary
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    DecodeUTF8.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        final = !!final;
        if (this.t) {
            this.ondata(this.t.decode(chunk, { stream: true }), final);
            if (final) {
                if (this.t.decode().length)
                    err(8);
                this.t = null;
            }
            return;
        }
        if (!this.p)
            err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a = dutf8(dat), ch = _a[0], np = _a[1];
        if (final) {
            if (np.length)
                err(8);
            this.p = null;
        }
        else
            this.p = np;
        this.ondata(ch, final);
    };
    return DecodeUTF8;
}())));

/**
 * Streaming UTF-8 encoding
 */
var EncodeUTF8 = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a UTF-8 decoding stream
     * @param cb The callback to call whenever data is encoded
     */
    function EncodeUTF8(cb) {
        this.ondata = cb;
    }
    /**
     * Pushes a chunk to be encoded to UTF-8
     * @param chunk The string data to push
     * @param final Whether this is the last chunk
     */
    EncodeUTF8.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        if (this.d)
            err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
    };
    return EncodeUTF8;
}())));

/**
 * Converts a string into a Uint8Array for use with compression/decompression methods
 * @param str The string to encode
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless decoding a binary string.
 * @returns The string encoded in UTF-8/Latin-1 binary
 */
function strToU8(str, latin1) {
    if (latin1) {
        var ar_1 = new u8(str.length);
        for (var i = 0; i < str.length; ++i)
            ar_1[i] = str.charCodeAt(i);
        return ar_1;
    }
    if (te)
        return te.encode(str);
    var l = str.length;
    var ar = new u8(str.length + (str.length >> 1));
    var ai = 0;
    var w = function (v) { ar[ai++] = v; };
    for (var i = 0; i < l; ++i) {
        if (ai + 5 > ar.length) {
            var n = new u8(ai + 8 + ((l - i) << 1));
            n.set(ar);
            ar = n;
        }
        var c = str.charCodeAt(i);
        if (c < 128 || latin1)
            w(c);
        else if (c < 2048)
            w(192 | (c >> 6)), w(128 | (c & 63));
        else if (c > 55295 && c < 57344)
            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),
                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
        else
            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));
    }
    return slc(ar, 0, ai);
}
/**
 * Converts a Uint8Array to a string
 * @param dat The data to decode to string
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless encoding to binary string.
 * @returns The original UTF-8/Latin-1 string
 */
function strFromU8(dat, latin1) {
    if (latin1) {
        var r = '';
        for (var i = 0; i < dat.length; i += 16384)
            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
        return r;
    }
    else if (td)
        return td.decode(dat);
    else {
        var _a = dutf8(dat), out = _a[0], ext = _a[1];
        if (ext.length)
            err(8);
        return out;
    }
}
;
// deflate bit flag
var dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };
// skip local zip header
var slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };
// read zip header
var zh = function (d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
};
// read zip64 extra field
var z64e = function (d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
// extra field length
var exfl = function (ex) {
    var le = 0;
    if (ex) {
        for (var k in ex) {
            var l = ex[k].length;
            if (l > 65535)
                err(9);
            le += l + 4;
        }
    }
    return le;
};
// write zip header
var wzh = function (d, b, f, fn, u, c, ce, co) {
    var fl = fn.length, ex = f.extra, col = co && co.length;
    var exl = exfl(ex);
    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
    if (ce != null)
        d[b++] = 20, d[b++] = f.os;
    d[b] = 20, b += 2; // spec compliance? what's that?
    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;
    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
    if (y < 0 || y > 119)
        err(10);
    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;
    if (c != null) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c);
        wbytes(d, b + 8, f.size);
    }
    wbytes(d, b + 12, fl);
    wbytes(d, b + 14, exl), b += 16;
    if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
    }
    d.set(fn, b);
    b += fl;
    if (exl) {
        for (var k in ex) {
            var exf = ex[k], l = exf.length;
            wbytes(d, b, +k);
            wbytes(d, b + 2, l);
            d.set(exf, b + 4), b += 4 + l;
        }
    }
    if (col)
        d.set(co, b), b += col;
    return b;
};
// write zip footer (end of central directory)
var wzf = function (o, b, c, d, e) {
    wbytes(o, b, 0x6054B50); // skip disk
    wbytes(o, b + 8, c);
    wbytes(o, b + 10, c);
    wbytes(o, b + 12, d);
    wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */
var ZipPassThrough = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */
    function ZipPassThrough(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
    }
    /**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.process = function (chunk, final) {
        this.ondata(null, chunk, final);
    };
    /**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipPassThrough.prototype.push = function (chunk, final) {
        if (!this.ondata)
            err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
            this.crc = this.c.d();
        this.process(chunk, final || false);
    };
    return ZipPassThrough;
}())));

// I don't extend because TypeScript extension adds 1kB of runtime bloat
/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */
var ZipDeflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function ZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts)
            opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function (dat, final) {
            _this_1.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
    }
    ZipDeflate.prototype.process = function (chunk, final) {
        try {
            this.d.push(chunk, final);
        }
        catch (e) {
            this.ondata(e, null, final);
        }
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    ZipDeflate.prototype.push = function (chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return ZipDeflate;
}())));

/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */
var AsyncZipDeflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a DEFLATE stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     * @param opts The compression options
     */
    function AsyncZipDeflate(filename, opts) {
        var _this_1 = this;
        if (!opts)
            opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function (err, dat, final) {
            _this_1.ondata(err, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
    }
    AsyncZipDeflate.prototype.process = function (chunk, final) {
        this.d.push(chunk, final);
    };
    /**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    AsyncZipDeflate.prototype.push = function (chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
    };
    return AsyncZipDeflate;
}())));

// TODO: Better tree shaking
/**
 * A zippable archive to which files can incrementally be added
 */
var Zip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates an empty ZIP archive to which files can be added
     * @param cb The callback to call whenever data for the generated ZIP archive
     *           is available
     */
    function Zip(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
    }
    /**
     * Adds a file to the ZIP archive
     * @param file The file stream to add
     */
    Zip.prototype.add = function (file) {
        var _this_1 = this;
        if (!this.ondata)
            err(5);
        // finishing or finished
        if (this.d & 2)
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
            var f = strToU8(file.filename), fl_1 = f.length;
            var com = file.comment, o = com && strToU8(com);
            var u = fl_1 != file.filename.length || (o && (com.length != o.length));
            var hl_1 = fl_1 + exfl(file.extra) + 30;
            if (fl_1 > 65535)
                this.ondata(err(11, 0, 1), null, false);
            var header = new u8(hl_1);
            wzh(header, 0, file, f, u);
            var chks_1 = [header];
            var pAll_1 = function () {
                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
                    var chk = chks_2[_i];
                    _this_1.ondata(null, chk, false);
                }
                chks_1 = [];
            };
            var tr_1 = this.d;
            this.d = 0;
            var ind_1 = this.u.length;
            var uf_1 = mrg(file, {
                f: f,
                u: u,
                o: o,
                t: function () {
                    if (file.terminate)
                        file.terminate();
                },
                r: function () {
                    pAll_1();
                    if (tr_1) {
                        var nxt = _this_1.u[ind_1 + 1];
                        if (nxt)
                            nxt.r();
                        else
                            _this_1.d = 1;
                    }
                    tr_1 = 1;
                }
            });
            var cl_1 = 0;
            file.ondata = function (err, dat, final) {
                if (err) {
                    _this_1.ondata(err, dat, final);
                    _this_1.terminate();
                }
                else {
                    cl_1 += dat.length;
                    chks_1.push(dat);
                    if (final) {
                        var dd = new u8(16);
                        wbytes(dd, 0, 0x8074B50);
                        wbytes(dd, 4, file.crc);
                        wbytes(dd, 8, cl_1);
                        wbytes(dd, 12, file.size);
                        chks_1.push(dd);
                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                        if (tr_1)
                            uf_1.r();
                        tr_1 = 1;
                    }
                    else if (tr_1)
                        pAll_1();
                }
            };
            this.u.push(uf_1);
        }
    };
    /**
     * Ends the process of adding files and prepares to emit the final chunks.
     * This *must* be called after adding all desired files for the resulting
     * ZIP file to work properly.
     */
    Zip.prototype.end = function () {
        var _this_1 = this;
        if (this.d & 2) {
            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
            return;
        }
        if (this.d)
            this.e();
        else
            this.u.push({
                r: function () {
                    if (!(_this_1.d & 1))
                        return;
                    _this_1.u.splice(-1, 1);
                    _this_1.e();
                },
                t: function () { }
            });
        this.d = 3;
    };
    Zip.prototype.e = function () {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
            var f = _a[_i];
            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
            var f = _c[_b];
            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
    };
    /**
     * A method to terminate any internal workers used by the stream. Subsequent
     * calls to add() will fail.
     */
    Zip.prototype.terminate = function () {
        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
            var f = _a[_i];
            f.t();
        }
        this.d = 2;
    };
    return Zip;
}())));

function zip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    var r = {};
    fltn(data, '', r, opts);
    var k = Object.keys(r);
    var lft = k.length, o = 0, tot = 0;
    var slft = lft, files = new Array(lft);
    var term = [];
    var tAll = function () {
        for (var i = 0; i < term.length; ++i)
            term[i]();
    };
    var cbd = function (a, b) {
        mt(function () { cb(a, b); });
    };
    mt(function () { cbd = cb; });
    var cbf = function () {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for (var i = 0; i < slft; ++i) {
            var f = files[i];
            try {
                var l = f.c.length;
                wzh(out, tot, f, f.f, f.u, l);
                var badd = 30 + f.f.length + exfl(f.extra);
                var loc = tot + badd;
                out.set(f.c, loc);
                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
            }
            catch (e) {
                return cbd(e, null);
            }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
    };
    if (!lft)
        cbf();
    var _loop_1 = function (i) {
        var fn = k[i];
        var _a = r[fn], file = _a[0], p = _a[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function (e, d) {
            if (e) {
                tAll();
                cbd(e, null);
            }
            else {
                var l = d.length;
                files[i] = mrg(p, {
                    size: size,
                    crc: c.d(),
                    c: d,
                    f: f,
                    m: m,
                    u: s != fn.length || (m && (com.length != ms)),
                    compression: compression
                });
                o += 30 + s + exl + l;
                tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                if (!--lft)
                    cbf();
            }
        };
        if (s > 65535)
            cbl(err(11, 0, 1), null);
        if (!compression)
            cbl(null, file);
        else if (size < 160000) {
            try {
                cbl(null, deflateSync(file, p));
            }
            catch (e) {
                cbl(e, null);
            }
        }
        else
            term.push(deflate(file, p, cbl));
    };
    // Cannot use lft because it can decrease
    for (var i = 0; i < slft; ++i) {
        _loop_1(i);
    }
    return tAll;
}
/**
 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
 * with more than one file.
 * @param data The directory structure for the ZIP archive
 * @param opts The main options, merged with per-file options
 * @returns The generated ZIP archive
 */
function zipSync(data, opts) {
    if (!opts)
        opts = {};
    var r = {};
    var files = [];
    fltn(data, '', r, opts);
    var o = 0;
    var tot = 0;
    for (var fn in r) {
        var _a = r[fn], file = _a[0], p = _a[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535)
            err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
            size: file.length,
            crc: c.d(),
            c: d,
            f: f,
            m: m,
            u: s != fn.length || (m && (com.length != ms)),
            o: o,
            compression: compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
    }
    var out = new u8(tot + 22), oe = o, cdl = tot - o;
    for (var i = 0; i < files.length; ++i) {
        var f = files[i];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
    }
    wzf(out, o, files.length, cdl, oe);
    return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */
var UnzipPassThrough = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    function UnzipPassThrough() {
    }
    UnzipPassThrough.prototype.push = function (data, final) {
        this.ondata(null, data, final);
    };
    UnzipPassThrough.compression = 0;
    return UnzipPassThrough;
}())));

/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */
var UnzipInflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function UnzipInflate() {
        var _this_1 = this;
        this.i = new Inflate(function (dat, final) {
            _this_1.ondata(null, dat, final);
        });
    }
    UnzipInflate.prototype.push = function (data, final) {
        try {
            this.i.push(data, final);
        }
        catch (e) {
            this.ondata(e, null, final);
        }
    };
    UnzipInflate.compression = 8;
    return UnzipInflate;
}())));

/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */
var AsyncUnzipInflate = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a DEFLATE decompression that can be used in ZIP archives
     */
    function AsyncUnzipInflate(_, sz) {
        var _this_1 = this;
        if (sz < 320000) {
            this.i = new Inflate(function (dat, final) {
                _this_1.ondata(null, dat, final);
            });
        }
        else {
            this.i = new AsyncInflate(function (err, dat, final) {
                _this_1.ondata(err, dat, final);
            });
            this.terminate = this.i.terminate;
        }
    }
    AsyncUnzipInflate.prototype.push = function (data, final) {
        if (this.i.terminate)
            data = slc(data, 0);
        this.i.push(data, final);
    };
    AsyncUnzipInflate.compression = 8;
    return AsyncUnzipInflate;
}())));

/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */
var Unzip = /*#__PURE__*/ ((/* unused pure expression or super */ null && (function () {
    /**
     * Creates a ZIP decompression stream
     * @param cb The callback to call whenever a file in the ZIP archive is found
     */
    function Unzip(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
            0: UnzipPassThrough
        };
        this.p = et;
    }
    /**
     * Pushes a chunk to be unzipped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */
    Unzip.prototype.push = function (chunk, final) {
        var _this_1 = this;
        if (!this.onfile)
            err(5);
        if (!this.p)
            err(4);
        if (this.c > 0) {
            var len = Math.min(this.c, chunk.length);
            var toAdd = chunk.subarray(0, len);
            this.c -= len;
            if (this.d)
                this.d.push(toAdd, !this.c);
            else
                this.k[0].push(toAdd);
            chunk = chunk.subarray(len);
            if (chunk.length)
                return this.push(chunk, final);
        }
        else {
            var f = 0, i = 0, is = void 0, buf = void 0;
            if (!this.p.length)
                buf = chunk;
            else if (!chunk.length)
                buf = this.p;
            else {
                buf = new u8(this.p.length + chunk.length);
                buf.set(this.p), buf.set(chunk, this.p.length);
            }
            var l = buf.length, oc = this.c, add = oc && this.d;
            var _loop_2 = function () {
                var _a;
                var sig = b4(buf, i);
                if (sig == 0x4034B50) {
                    f = 1, is = i;
                    this_1.d = null;
                    this_1.c = 0;
                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                    if (l > i + 30 + fnl + es) {
                        var chks_3 = [];
                        this_1.k.unshift(chks_3);
                        f = 2;
                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                        if (sc_1 == 4294967295) {
                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                        }
                        else if (dd)
                            sc_1 = -1;
                        i += es;
                        this_1.c = sc_1;
                        var d_1;
                        var file_1 = {
                            name: fn_1,
                            compression: cmp_1,
                            start: function () {
                                if (!file_1.ondata)
                                    err(5);
                                if (!sc_1)
                                    file_1.ondata(null, et, true);
                                else {
                                    var ctr = _this_1.o[cmp_1];
                                    if (!ctr)
                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);
                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };
                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                                        var dat = chks_4[_i];
                                        d_1.push(dat, false);
                                    }
                                    if (_this_1.k[0] == chks_3 && _this_1.c)
                                        _this_1.d = d_1;
                                    else
                                        d_1.push(et, true);
                                }
                            },
                            terminate: function () {
                                if (d_1 && d_1.terminate)
                                    d_1.terminate();
                            }
                        };
                        if (sc_1 >= 0)
                            file_1.size = sc_1, file_1.originalSize = su_1;
                        this_1.onfile(file_1);
                    }
                    return "break";
                }
                else if (oc) {
                    if (sig == 0x8074B50) {
                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                        return "break";
                    }
                    else if (sig == 0x2014B50) {
                        is = i -= 4, f = 3, this_1.c = 0;
                        return "break";
                    }
                }
            };
            var this_1 = this;
            for (; i < l - 4; ++i) {
                var state_1 = _loop_2();
                if (state_1 === "break")
                    break;
            }
            this.p = et;
            if (oc < 0) {
                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
                if (add)
                    add.push(dat, !!f);
                else
                    this.k[+(f == 2)].push(dat);
            }
            if (f & 2)
                return this.push(buf.subarray(i), final);
            this.p = buf.subarray(i);
        }
        if (final) {
            if (this.c)
                err(13);
            this.p = null;
        }
    };
    /**
     * Registers a decoder with the stream, allowing for files compressed with
     * the compression type provided to be expanded correctly
     * @param decoder The decoder constructor
     */
    Unzip.prototype.register = function (decoder) {
        this.o[decoder.compression] = decoder;
    };
    return Unzip;
}())));

var mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };
function unzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    var term = [];
    var tAll = function () {
        for (var i = 0; i < term.length; ++i)
            term[i]();
    };
    var files = {};
    var cbd = function (a, b) {
        mt(function () { cb(a, b); });
    };
    mt(function () { cbd = cb; });
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
        if (!e || data.length - e > 65558) {
            cbd(err(13, 0, 1), null);
            return tAll;
        }
    }
    ;
    var lft = b2(data, e + 8);
    if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295;
        if (z) {
            e = b4(data, e - 12);
            if (b4(data, e) != 0x6064B50) {
                cbd(err(13, 0, 1), null);
                return tAll;
            }
            c = lft = b4(data, e + 32);
            o = b4(data, e + 48);
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function (i) {
            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
            o = no;
            var cbl = function (e, d) {
                if (e) {
                    tAll();
                    cbd(e, null);
                }
                else {
                    if (d)
                        files[fn] = d;
                    if (!--lft)
                        cbd(null, files);
                }
            };
            if (!fltr || fltr({
                name: fn,
                size: sc,
                originalSize: su,
                compression: c_1
            })) {
                if (!c_1)
                    cbl(null, slc(data, b, b + sc));
                else if (c_1 == 8) {
                    var infl = data.subarray(b, b + sc);
                    if (sc < 320000) {
                        try {
                            cbl(null, inflateSync(infl, new u8(su)));
                        }
                        catch (e) {
                            cbl(e, null);
                        }
                    }
                    else
                        term.push(inflate(infl, { size: su }, cbl));
                }
                else
                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);
            }
            else
                cbl(null, null);
        };
        for (var i = 0; i < c; ++i) {
            _loop_3(i);
        }
    }
    else
        cbd(null, {});
    return tAll;
}
/**
 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
 * performance with more than one file.
 * @param data The raw compressed ZIP file
 * @param opts The ZIP extraction options
 * @returns The decompressed files
 */
function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 0x6054B50; --e) {
        if (!e || data.length - e > 65558)
            err(13);
    }
    ;
    var c = b2(data, e + 8);
    if (!c)
        return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295;
    if (z) {
        e = b4(data, e - 12);
        if (b4(data, e) != 0x6064B50)
            err(13);
        c = b4(data, e + 32);
        o = b4(data, e + 48);
    }
    var fltr = opts && opts.filter;
    for (var i = 0; i < c; ++i) {
        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_2
        })) {
            if (!c_2)
                files[fn] = slc(data, b, b + sc);
            else if (c_2 == 8)
                files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
            else
                err(14, 'unknown compression type ' + c_2);
        }
    }
    return files;
}

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var DataAccessHelper = __webpack_require__(8906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Base64.js
/* eslint-disable no-bitwise */

// ----------------------------------------------------------------------------
// Decoding infrastructure
// ----------------------------------------------------------------------------

const REVERSE_LOOKUP = [];
REVERSE_LOOKUP['-'.charCodeAt(0)] = 62;
REVERSE_LOOKUP['_'.charCodeAt(0)] = 63;
const BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (let i = 0; i < BASE64_CODE.length; i++) {
  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;
}

// ----------------------------------------------------------------------------
// Base64 analysis
// ----------------------------------------------------------------------------

function isValidChar(c) {
  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;
}
function extractChunks(b64Str) {
  const strSize = b64Str.length;
  const chunks = [];
  let currentChunk = null;
  for (let i = 0; i < strSize; i++) {
    if (isValidChar(b64Str[i])) {
      if (!currentChunk) {
        currentChunk = {
          start: i,
          count: 0
        };
      }
      currentChunk.count++;
      currentChunk.end = i;
    } else if (b64Str[i] === '=' && currentChunk) {
      // End of chunk (found padding char)
      chunks.push(currentChunk);
      currentChunk = null;
    }
  }
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  return chunks;
}
function writeChunk(b64Str, chunk, dstOffset, uint8) {
  const {
    start,
    count
  } = chunk;
  const remain = count % 4;
  const fourCharProcessCount = Math.floor(count / 4);
  let charIdx = start;
  let tmp = null;
  let offset = dstOffset;

  // Handle 4=>3
  for (let i = 0; i < fourCharProcessCount; i++) {
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;
    while (!isValidChar(b64Str[charIdx])) {
      charIdx++;
    }
    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];
    uint8[offset++] = tmp >> 16 & 0xff;
    uint8[offset++] = tmp >> 8 & 0xff;
    uint8[offset++] = tmp & 0xff;
  }

  // Handle remain
  switch (remain) {
    case 3:
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;
      uint8[offset++] = tmp >> 8 & 0xff;
      uint8[offset++] = tmp & 0xff;
      break;
    case 2:
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;
      while (!isValidChar(b64Str[charIdx])) {
        charIdx++;
      }
      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;
      uint8[offset++] = tmp & 0xff;
      break;
    case 1:
      throw new Error('BASE64: remain 1 should not happen');
  }
  return offset;
}
function toArrayBuffer(b64Str) {
  const chunks = extractChunks(b64Str);
  const totalEncodedLength = chunks[chunks.length - 1].end + 1;
  const padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4
  // Any padding chars in the middle of b64Str is to be interpreted as \x00,
  // whereas the terminating padding chars are to be interpreted as literal padding.
  const totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;
  const arrayBuffer = new ArrayBuffer(totalSize);
  const view = new Uint8Array(arrayBuffer);
  let dstOffset = 0;
  for (let i = 0; i < chunks.length; i++) {
    dstOffset += writeChunk(b64Str, chunks[i], dstOffset, view);
    dstOffset += (4 - chunks[i].count % 4) % 4;
  }
  return arrayBuffer;
}
function encodeTriplet(v1, v2, v3) {
  const triplet = (v1 << 16) + (v2 << 8) + v3;
  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];
}
function fromArrayBuffer(ab) {
  const uint8 = new Uint8Array(ab);
  const leftoverLength = ab.byteLength % 3;
  const maxTripletIndex = ab.byteLength - leftoverLength;
  const segments = Array(maxTripletIndex / 3);
  for (let i = 0; i < segments.length; i++) {
    const bufOffset = i * 3;
    segments[i] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);
  }
  if (leftoverLength > 0) {
    const segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);
    if (leftoverLength === 1) {
      segments.push(`${segment.substr(0, 2)}==`);
    } else if (leftoverLength === 2) {
      segments.push(`${segment.substr(0, 3)}=`);
    }
  }
  return segments.join('');
}
var Base64 = {
  toArrayBuffer,
  fromArrayBuffer
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/StringArray.js


// ----------------------------------------------------------------------------
// vtkStringArray methods
// ----------------------------------------------------------------------------

function vtkStringArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkStringArray');

  // Description:
  // Return the data component at the location specified by tupleIdx and
  // compIdx.
  publicAPI.getComponent = function (tupleIdx) {
    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };

  // Description:
  // Set the data component at the location specified by tupleIdx and compIdx
  // to value.
  // Note that i is less than NumberOfTuples and j is less than
  //  NumberOfComponents. Make sure enough memory has been allocated
  // (use SetNumberOfTuples() and SetNumberOfComponents()).
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      publicAPI.modified();
    }
  };
  publicAPI.getData = () => model.values;
  publicAPI.getTuple = function (idx) {
    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const numberOfComponents = model.numberOfComponents || 1;
    if (tupleToFill.length) {
      tupleToFill.length = numberOfComponents;
    }
    const offset = idx * numberOfComponents;
    for (let i = 0; i < numberOfComponents; i++) {
      tupleToFill[i] = model.values[offset + i];
    }
    return tupleToFill;
  };
  publicAPI.getTupleLocation = function () {
    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.values.length;
  publicAPI.getNumberOfTuples = () => model.values.length / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  /* eslint-disable no-use-before-define */
  publicAPI.newClone = () => newInstance({
    name: model.name,
    numberOfComponents: model.numberOfComponents,
    empty: true
  });
  /* eslint-enable no-use-before-define */

  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.setName(`vtkStringArray${publicAPI.getMTime()}`);
    }
    return model.name;
  };
  publicAPI.setData = (array, numberOfComponents) => {
    model.values = array;
    model.size = array.length;
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    publicAPI.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  name: '',
  numberOfComponents: 1,
  size: 0,
  // values: null,
  dataType: 'string'
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError('Cannot create vtkStringArray object without: size > 0, values');
  }
  if (!model.values) {
    model.values = [];
  } else if (Array.isArray(model.values)) {
    model.values = [...model.values];
  }
  if (model.values) {
    model.size = model.values.length;
  }

  // Object methods
  macros2.m.obj(publicAPI, model);
  macros2.m.set(publicAPI, model, ['name']);

  // Object specific methods
  vtkStringArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkStringArray');

// ----------------------------------------------------------------------------

var vtkStringArray$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/BinaryHelper.js
var BinaryHelper = __webpack_require__(56413);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/LiteHttpDataAccessHelper.js + 1 modules
var LiteHttpDataAccessHelper = __webpack_require__(67313);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/XML/XMLReader.js










// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function findAllTags(node, tagName) {
  return [...node.getElementsByTagName(tagName)];
}
function findFirstTag(node, tagName) {
  return findAllTags(node, tagName)[0];
}
function parseXML(xmlStr) {
  // see xmlbuilder2 docs on the object format
  return (0,xmlbuilder2_min.create)(xmlStr);
}
function extractAppendedData(buffer) {
  // search for appended data tag
  const prefixRegex = /^\s*<AppendedData\s+encoding="raw">\s*_/m;
  const suffixRegex = /\n\s*<\/AppendedData>/m;
  return BinaryHelper/* default */.A.extractBinary(buffer, prefixRegex, suffixRegex);
}

// ----------------------------------------------------------------------------

const TYPED_ARRAY = {
  Int8: Int8Array,
  UInt8: Uint8Array,
  Int16: Int16Array,
  UInt16: Uint16Array,
  Int32: Int32Array,
  UInt32: Uint32Array,
  Int64: Int32Array,
  // Not supported with JavaScript will cause error in binary
  UInt64: Uint32Array,
  // Not supported with JavaScript will cause error in binary
  Float32: Float32Array,
  Float64: Float64Array
};

// ----------------------------------------------------------------------------

const TYPED_ARRAY_BYTES = {
  Int8: 1,
  UInt8: 1,
  Int16: 2,
  UInt16: 2,
  Int32: 4,
  UInt32: 4,
  Int64: 8,
  // Not supported with JavaScript will cause error in binary
  UInt64: 8,
  // Not supported with JavaScript will cause error in binary
  Float32: 4,
  Float64: 8
};

// ----------------------------------------------------------------------------

function integer64to32(array) {
  const maxIdx = array.length - 1; // Skip last
  return array.filter((v, i) => i < maxIdx && i % 2 === 0);
}

// ----------------------------------------------------------------------------

/**
 * Reads the data of a length-prefixed blob.
 *
 * Int64 headers and values are not supported.
 *
 * @param {Uint8Array} uint8 a uint8 view of the length-prefixed blob.
 * @param {string} dataType
 * @param {string} headerType either UInt64 or UInt32
 */
function readLengthPrefixedData(uint8, dataType, headerType) {
  if (!['UInt64', 'UInt32'].includes(headerType)) {
    throw new Error(`Cannot handle a header type of ${headerType}`);
  }
  let HeaderTypedArray = TYPED_ARRAY[headerType];
  let DataTypedArray = TYPED_ARRAY[dataType];
  let dataFallbackTo32 = false;
  if (headerType === 'UInt64') {
    HeaderTypedArray = TYPED_ARRAY.UInt32;
  }
  if (/^U?Int64$/.test(dataType)) {
    dataFallbackTo32 = true;
    DataTypedArray = TYPED_ARRAY[dataType.replace('64', '32')];
  }
  const {
    byteOffset
  } = uint8;
  const dataWordSize = TYPED_ARRAY_BYTES[dataType];
  const headerWordSize = TYPED_ARRAY_BYTES[headerType];

  // slice if offset is not word aligned
  let header;
  if (byteOffset % headerWordSize === 0) {
    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);
  } else {
    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));
  }
  const dataByteLength = Number(header[0]);

  // read values
  let values;
  let arraySize = dataByteLength / dataWordSize;
  if (dataFallbackTo32) {
    // We are reading int64 data with an int32 typed array.
    arraySize *= 2;
  }

  // slice if offset is not word aligned
  const dataOffset = byteOffset + headerWordSize;
  if (dataOffset % dataWordSize === 0) {
    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);
  } else {
    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));
  }
  if (dataFallbackTo32) {
    // remove higher order 32 bits
    values = integer64to32(values);
  }
  return values;
}

// ----------------------------------------------------------------------------

function readerHeader(uint8, headerType) {
  // We do not handle endianness or if more than 32 bits are needed to encode the data
  if (headerType === 'UInt64') {
    const offset = 8;
    let uint32 = new Uint32Array(uint8.buffer, 0, 6);
    const nbBlocks = uint32[0];
    const s1 = uint32[2];
    const s2 = uint32[4];
    const resultArray = [offset, nbBlocks, s1, s2];
    uint32 = new Uint32Array(uint8.buffer, 3 * 8, nbBlocks * 2);
    for (let i = 0; i < nbBlocks; i++) {
      resultArray.push(uint32[i * 2]);
    }
    return resultArray;
  }
  // UInt32
  let uint32 = new Uint32Array(uint8.buffer, 0, 3);
  const offset = 4;
  const nbBlocks = uint32[0];
  const s1 = uint32[1];
  const s2 = uint32[2];
  const resultArray = [offset, nbBlocks, s1, s2];
  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);
  for (let i = 0; i < nbBlocks; i++) {
    resultArray.push(uint32[i]);
  }
  return resultArray;
}

// ----------------------------------------------------------------------------

/**
 * Given the return value of readerHeader, return header byte length.
 */
function getHeaderByteLength(header, headerType) {
  // ignore the first number, which isn't actually part of the header.
  const [headerWordSize] = header;
  return (header.length - 1) * headerWordSize;
}

// ----------------------------------------------------------------------------

function uncompressBlock(compressedUint8, output) {
  const uncompressedBlock = decompressSync(compressedUint8);
  output.uint8.set(uncompressedBlock, output.offset);
  output.offset += uncompressedBlock.length;
}

// ----------------------------------------------------------------------------

function decompressZLib(bytes, headerType) {
  // ----------------------------------------------------------------------
  // Layout of the data
  // header[N, s1, s2, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]
  // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type="UInt64" attribute on the root node)
  // [header] s1: uncompress size of each block except the last one
  // [header] s2: uncompress size of the last blocks
  // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)
  // ----------------------------------------------------------------------

  // Header reading: [offset, numBlocks, s1, s2]
  const header = readerHeader(bytes, headerType);
  const nbBlocks = header[1];
  const s1 = header[2];
  const s2 = header[3];
  let dataByteLength = 0;
  if (nbBlocks > 0) {
    // If the last block's size is labeled as 0, that means the last block
    // really has size header[2].
    if (s2 === 0) {
      dataByteLength = nbBlocks * s1;
    } else {
      dataByteLength = (nbBlocks - 1) * s1 + s2;
    }
  }
  const buffer = new ArrayBuffer(dataByteLength);
  const output = {
    offset: 0,
    uint8: new Uint8Array(buffer)
  };
  let offset = getHeaderByteLength(header);
  // Starting from end of the data header, find the zlib header, which starts with 0x78.
  // This accounts for any padding between the header and the compressed data.
  while (offset < bytes.length && bytes[offset] !== 0x78) {
    offset++;
  }
  for (let i = 0; i < nbBlocks; i++) {
    const blockSize = header[4 + i];
    const compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);
    uncompressBlock(compressedBlock, output);
    offset += blockSize;
  }
  return output.uint8;
}

// ----------------------------------------------------------------------------

function processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {
  const dataType = dataArrayElem.getAttribute('type');
  const name = dataArrayElem.getAttribute('Name');
  const format = dataArrayElem.getAttribute('format'); // binary, ascii, appended
  const numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');
  let values = null;
  if (format === 'ascii') {
    values = new TYPED_ARRAY[dataType](size * numberOfComponents);
    let offset = 0;
    dataArrayElem.firstChild.nodeValue.split(/[\\t \\n]+/).forEach(token => {
      if (token.trim().length) {
        values[offset++] = Number(token);
      }
    });
  } else if (format === 'binary') {
    const uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));
    if (compressor === 'vtkZLibDataCompressor') {
      const data = decompressZLib(uint8, headerType);
      values = new TYPED_ARRAY[dataType](data.buffer);

      // Handle (u)int64 hoping for no overflow...
      if (/^U?Int64$/.test(dataType)) {
        values = integer64to32(values);
      }
    } else {
      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]);

      // Handle (u)int64 hoping no overflow...
      if (dataType.indexOf('Int64') !== -1) {
        values = integer64to32(values);
      }
    }
  } else if (format === 'appended') {
    const offset = Number(dataArrayElem.getAttribute('offset'));
    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), dataType, headerType);
  } else {
    console.error('Format not supported', format);
  }
  return {
    name,
    values,
    numberOfComponents
  };
}

// ----------------------------------------------------------------------------

function decodeStringArrayFromBytes(bytes) {
  const decoder = new TextDecoder();
  const decoded = decoder.decode(bytes);

  // strings are null-terminated
  return decoded.split('\x00').slice(0, -1);
}

// ----------------------------------------------------------------------------

function processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {
  const name = stringArrayElem.getAttribute('Name');
  const format = stringArrayElem.getAttribute('format'); // binary, ascii, appended
  const numberOfComponents = Number(stringArrayElem.getAttribute('NumberOfComponents') || '1');
  const numberOfTuples = Number(stringArrayElem.getAttribute('NumberOfTuples') || '1');
  const nbStrings = numberOfTuples * numberOfComponents;
  const strings = [];
  if (format === 'ascii') {
    const tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\s+/);
    let tokIdx = 0;
    const strChars = [];
    while (strings.length < nbStrings) {
      const token = Number(tokens[tokIdx++]);
      if (token === 0) {
        strings.push(strChars.join(''));
        strChars.length = 0;
      } else {
        strChars.push(String.fromCharCode(token));
      }
    }
  } else if (format === 'binary') {
    const uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));
    if (compressor === 'vtkZLibDataCompressor') {
      const decompressed = decompressZLib(uint8, headerType);
      strings.push(...decodeStringArrayFromBytes(decompressed));
    } else {
      const strData = readLengthPrefixedData(uint8, 'UInt8', headerType);
      strings.push(...decodeStringArrayFromBytes(strData));
    }
  } else if (format === 'appended') {
    const offset = Number(stringArrayElem.getAttribute('offset'));
    const values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), 'UInt8', headerType);
    strings.push(...decodeStringArrayFromBytes(values));
  } else {
    macros2.m.vtkErrorMacro(`Format not supported: ${format}`);
  }
  return {
    name,
    values: strings,
    numberOfComponents
  };
}

// ----------------------------------------------------------------------------

function processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {
  const arrayElems = {};
  const dataArrayElems = containerElem.getElementsByTagName('DataArray');
  for (let elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {
    const el = dataArrayElems[elIdx];
    arrayElems[el.getAttribute('Name')] = el;
  }
  const offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;
  const connectivitySize = offsets[offsets.length - 1];
  const connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;
  const values = new Uint32Array(size + connectivitySize);
  let writeOffset = 0;
  let previousOffset = 0;
  offsets.forEach(v => {
    const cellSize = v - previousOffset;
    values[writeOffset++] = cellSize;
    for (let i = 0; i < cellSize; i++) {
      values[writeOffset++] = connectivity[previousOffset + i];
    }

    // save previous offset
    previousOffset = v;
  });
  return values;
}

// ----------------------------------------------------------------------------

function processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {
  if (fieldElem) {
    const attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];
    const nameBinding = {};
    attributes.forEach(attrName => {
      const arrayName = fieldElem.getAttribute(attrName);
      if (arrayName) {
        nameBinding[arrayName] = fieldContainer[`set${attrName}`];
      }
    });
    const dataArrayElems = fieldElem.getElementsByTagName('DataArray');
    const nbArrays = dataArrayElems.length;
    for (let idx = 0; idx < nbArrays; idx++) {
      const array = dataArrayElems[idx];
      const dataArray = DataArray/* default.newInstance */.Ay.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));
      const name = dataArray.getName();
      (nameBinding[name] || fieldContainer.addArray)(dataArray);
    }
  }
}

// ----------------------------------------------------------------------------
function handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {
  const dataArrays = [...fieldDataElem.getElementsByTagName('DataArray')].map(daElem => DataArray/* default.newInstance */.Ay.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer)));
  const stringArrays = [...fieldDataElem.getElementsByTagName('Array')].filter(elem => elem.getAttribute('type') === 'String').map(arrElem => {
    const sa = vtkStringArray$1.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));
    return sa;
  });
  return [...dataArrays, ...stringArrays];
}

// ----------------------------------------------------------------------------
// vtkXMLReader methods
// ----------------------------------------------------------------------------

function vtkXMLReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkXMLReader');

  // Create default dataAccessHelper if not available
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper/* default.get */.Ay.get('http');
  }

  // Internal method to fetch Array
  function fetchData(url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return model.dataAccessHelper.fetchBinary(url, option);
  }

  // Set DataSet url
  publicAPI.setUrl = function (url) {
    let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    model.url = url;

    // Remove the file in the URL
    const path = url.split('/');
    path.pop();
    model.baseURL = path.join('/');

    // Fetch metadata
    return publicAPI.loadData(option);
  };

  // Fetch the actual data arrays
  publicAPI.loadData = function () {
    let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);
  };
  publicAPI.parseAsArrayBuffer = arrayBuffer => {
    if (!arrayBuffer) {
      return false;
    }
    if (arrayBuffer !== model.rawDataBuffer) {
      publicAPI.modified();
    } else {
      return true;
    }
    const {
      text: content,
      binaryBuffer
    } = extractAppendedData(arrayBuffer);
    model.rawDataBuffer = arrayBuffer;
    model.binaryBuffer = binaryBuffer;

    // Parse data here...
    const doc = parseXML(content);
    const root = doc.root();
    const rootElem = root.node;
    const type = rootElem.getAttribute('type');
    const compressor = rootElem.getAttribute('compressor');
    const byteOrder = rootElem.getAttribute('byte_order');
    // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.
    const headerType = rootElem.getAttribute('header_type') || 'UInt32';
    if (compressor && compressor !== 'vtkZLibDataCompressor') {
      console.error('Invalid compressor', compressor);
      return false;
    }
    if (byteOrder && byteOrder !== 'LittleEndian') {
      console.error('Only LittleEndian encoding is supported');
      return false;
    }
    if (type !== model.dataType) {
      console.error('Invalid data type', type, 'expecting', model.dataType);
      return false;
    }

    // appended format
    if (findFirstTag(rootElem, 'AppendedData')) {
      const appendedDataElem = findFirstTag(rootElem, 'AppendedData');
      const encoding = appendedDataElem.getAttribute('encoding');
      const arrays = root.filter(xmlNode => {
        const {
          node
        } = xmlNode;
        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute('format') === 'appended' && node.hasAttribute('offset');
      }, false, true).map(xmlNode => ({
        node: xmlNode.node,
        offset: Number(xmlNode.node.getAttribute('offset'))
      }));

      // sort dataElems by increasing offset
      arrays.sort((a, b) => a.offset - b.offset);
      let appendedBuffer = model.binaryBuffer;
      if (encoding === 'base64') {
        // substr(1) is to remove the '_' prefix
        appendedBuffer = appendedDataElem.textContent.trim().substr(1);
      }

      // get data array chunks
      const dataArrays = [];
      for (let i = 0; i < arrays.length; ++i) {
        const offset = arrays[i].offset;
        let nextOffset = 0;
        if (i === arrays.length - 1) {
          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;
        } else {
          nextOffset = arrays[i + 1].offset;
        }
        if (encoding === 'base64') {
          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));
        } else {
          // encoding === 'raw'
          // Need to slice the ArrayBuffer so readerHeader() works properly
          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));
        }
      }
      if (compressor === 'vtkZLibDataCompressor') {
        for (let arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {
          const dataArray = dataArrays[arrayidx];
          const uncompressed = decompressZLib(dataArray, headerType);
          const data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]);
          // set length header
          // TODO this does not work for lengths that are greater than the max Uint32 value.
          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;
          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);
          dataArrays[arrayidx] = data;
        }
      }
      const bufferLength = dataArrays.reduce((acc, arr) => acc + arr.length, 0);
      const buffer = new ArrayBuffer(bufferLength);
      const view = new Uint8Array(buffer);
      for (let i = 0, offset = 0; i < dataArrays.length; ++i) {
        // set correct offsets
        arrays[i].node.setAttribute('offset', offset);
        // set final buffer data
        view.set(dataArrays[i], offset);
        offset += dataArrays[i].length;
      }
      model.binaryBuffer = buffer;
      if (!model.binaryBuffer) {
        console.error('Processing appended data format: requires binaryBuffer to parse');
        return false;
      }
    }
    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);
    const datasetElem = rootElem.getElementsByTagName(type)[0];
    const fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];
    if (fieldDataElem) {
      const fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);
      for (let i = 0; i < model.output.length; i++) {
        const fieldData = model.output[i].getFieldData();
        for (let j = 0; j < fieldDataArrays.length; j++) {
          fieldData.addArray(fieldDataArrays[j]);
        }
      }
    }
    return true;
  };
  publicAPI.requestData = (inData, outData) => {
    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const XMLReader_DEFAULT_VALUES = {
  // baseURL: null,
  // dataAccessHelper: null,
  // url: null,
};

// ----------------------------------------------------------------------------

function XMLReader_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, XMLReader_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['url', 'baseURL']);
  macros2.m.setGet(publicAPI, model, ['dataAccessHelper']);
  macros2.m.algo(publicAPI, model, 0, 1);

  // vtkXMLReader methods
  vtkXMLReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

var vtkXMLReader$1 = {
  extend: XMLReader_extend,
  processDataArray,
  processFieldData,
  processCells
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/IO/XML/XMLPolyDataReader.js




// ----------------------------------------------------------------------------
// Global method
// ----------------------------------------------------------------------------

function handleArray(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {
  const size = Number(piece.getAttribute(`NumberOf${cellType}`));
  if (size > 0) {
    const dataArrayElem = piece.getElementsByTagName(cellType)[0].getElementsByTagName('DataArray')[0];
    const {
      values,
      numberOfComponents
    } = vtkXMLReader$1.processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer);
    polydata[`get${cellType}`]().setData(values, numberOfComponents);
  }
  return size;
}

// ----------------------------------------------------------------------------

function handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, binaryBuffer) {
  const size = Number(piece.getAttribute(`NumberOf${cellType}`));
  if (size > 0) {
    const values = vtkXMLReader$1.processCells(size, piece.getElementsByTagName(cellType)[0], compressor, byteOrder, headerType, binaryBuffer);
    polydata[`get${cellType}`]().setData(values);
  }
  return size;
}

// ----------------------------------------------------------------------------
// vtkXMLPolyDataReader methods
// ----------------------------------------------------------------------------

function vtkXMLPolyDataReader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkXMLPolyDataReader');
  publicAPI.parseXML = (rootElem, type, compressor, byteOrder, headerType) => {
    const datasetElem = rootElem.getElementsByTagName(model.dataType)[0];
    const pieces = datasetElem.getElementsByTagName('Piece');
    const nbPieces = pieces.length;
    for (let outputIndex = 0; outputIndex < nbPieces; outputIndex++) {
      // Create dataset
      const polydata = PolyData/* default.newInstance */.Ay.newInstance();
      const piece = pieces[outputIndex];

      // Points
      const nbPoints = handleArray(polydata, 'Points', piece, compressor, byteOrder, headerType, model.binaryBuffer);

      // Cells
      let nbCells = 0;
      ['Verts', 'Lines', 'Strips', 'Polys'].forEach(cellType => {
        nbCells += handleCells(polydata, cellType, piece, compressor, byteOrder, headerType, model.binaryBuffer);
      });

      // Fill data
      vtkXMLReader$1.processFieldData(nbPoints, piece.getElementsByTagName('PointData')[0], polydata.getPointData(), compressor, byteOrder, headerType, model.binaryBuffer);
      vtkXMLReader$1.processFieldData(nbCells, piece.getElementsByTagName('CellData')[0], polydata.getCellData(), compressor, byteOrder, headerType, model.binaryBuffer);

      // Add new output
      model.output[outputIndex] = polydata;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const XMLPolyDataReader_DEFAULT_VALUES = {
  dataType: 'PolyData'
};

// ----------------------------------------------------------------------------

function XMLPolyDataReader_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, XMLPolyDataReader_DEFAULT_VALUES, initialValues);
  vtkXMLReader$1.extend(publicAPI, model, initialValues);
  vtkXMLPolyDataReader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const XMLPolyDataReader_newInstance = macros2.m.newInstance(XMLPolyDataReader_extend, 'vtkXMLPolyDataReader');

// ----------------------------------------------------------------------------

var vtkXMLPolyDataReader$1 = {
  newInstance: XMLPolyDataReader_newInstance,
  extend: XMLPolyDataReader_extend
};




/***/ }),

/***/ 85311:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkAbstractMapper$1)
/* harmony export */ });
/* unused harmony export extend */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push('vtkAbstractMapper');
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = plane => {
    if (!plane.isA('vtkPlane')) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = clippingPlane => {
    const i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = planes => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        // Get the plane
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();

        // Compute the plane equation
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);

        // Transform normal from world to data coords
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  clippingPlanes: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------
var vtkAbstractMapper$1 = {
  extend
};




/***/ }),

/***/ 68076:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkAbstractMapper3D$1)
/* harmony export */ });
/* unused harmony export extend */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _AbstractMapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85311);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);





// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.H)();
  };
  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBounds();
    model.center = _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].isValid */ .Ay.isValid(bounds) ? _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCenter */ .Ay.getCenter(bounds) : null;
    return model.center?.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getDiagonalLength */ .Ay.getDiagonalLength(bounds);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const defaultValues = initialValues => ({
  bounds: [..._Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {},
  ...initialValues
});

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  // Inheritance
  _AbstractMapper_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .A.extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['viewSpecificProperties']);
  vtkAbstractMapper3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

var vtkAbstractMapper3D$1 = {
  extend
};




/***/ }),

/***/ 7019:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Prop3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62502);
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89585);






const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

// ----------------------------------------------------------------------------
// vtkActor methods
// ----------------------------------------------------------------------------

function vtkActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkActor');

  // Capture 'parentClass' api for internal use
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    // make sure we have a property
    if (!model.property) {
      // force creation of a property
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1.0;

    // are we using an opaque texture, if any?
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());

    // are we using an opaque scalar array, if any?
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    // make sure we have a property
    if (model.property === null) {
      // force creation of a property
      publicAPI.setProperty(publicAPI.makeProperty());
    }

    // is this actor opaque ?
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = _Property_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      const bbox = [];
      _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCorners */ .Ay.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmp4, model.matrix);
      bbox.forEach(pt => gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(pt, pt, tmp4));

      /* eslint-disable no-multi-assign */
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      /* eslint-enable no-multi-assign */

      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  mapper: null,
  property: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [1, -1, 1, -1, 1, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Prop3D_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.boundsMTime);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.set(publicAPI, model, ['property']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['backfaceProperty', 'forceOpaque', 'forceTranslucent', 'mapper']);

  // Object methods
  vtkActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkActor');

// ----------------------------------------------------------------------------

var vtkActor$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 26719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCamera$1)
/* harmony export */ });
/* unused harmony exports DEFAULT_VALUES, extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16632);




const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m;

/* eslint-disable new-cap */

/*
 * Convenience function to access elements of a gl-matrix.  If it turns
 * out I have rows and columns swapped everywhere, then I'll just change
 * the order of 'row' and 'col' parameters in this function
 */
// function getMatrixElement(matrix, row, col) {
//   const idx = (row * 4) + col;
//   return matrix[idx];
// }

// ----------------------------------------------------------------------------
// vtkCamera methods
// ----------------------------------------------------------------------------

function vtkCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCamera');

  // Set up private variables and methods
  const origin = new Float64Array(3);
  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);
  const upbasis = new Float64Array([0.0, 1.0, 0.0]);
  const tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const tmpMatrix2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const tmpvec1 = new Float64Array(3);
  const tmpvec2 = new Float64Array(3);
  const tmpvec3 = new Float64Array(3);
  const rotateMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const trans = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  const newPosition = new Float64Array(3);
  const newFocalPoint = new Float64Array(3);

  // Internal Functions that don't need to be public
  function computeViewPlaneNormal() {
    // VPN is -DOP
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = (x, y, z) => {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = (x, y, z) => {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = d => {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');
    }

    // we want to keep the camera pointing in the same direction
    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // This method must be called when the focal point or camera position changes
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');
      const vec = model.directionOfProjection;

      // recalculate FocalPoint
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };

  //----------------------------------------------------------------------------
  // Move the position of the camera along the view plane normal. Moving
  // towards the focal point (e.g., > 1) is a dolly-in, moving away
  // from the focal point (e.g., < 1) is a dolly-out.
  publicAPI.dolly = amount => {
    if (amount <= 0.0) {
      return;
    }

    // dolly moves the camera towards the focus
    const d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = angle => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(rotateMatrix);
    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotateMatrix, rotateMatrix, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), viewDir);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = angle => {
    const fp = model.focalPoint;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, fp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), model.viewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = angle => {
    const position = model.position;
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), model.viewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-position[0], -position[1], -position[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = angle => {
    const fp = model.focalPoint;

    // get the eye / camera position from the viewMatrix
    const vt = publicAPI.getViewMatrix();
    const axis = [-vt[0], -vt[1], -vt[2]];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, fp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = angle => {
    const position = model.position;
    const vt = publicAPI.getViewMatrix();
    const axis = [vt[0], vt[1], vt[2]];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, position);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(trans, trans, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(angle), axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(trans, trans, [-position[0], -position[1], -position[2]]);

    // apply the transform to the focal point
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(...newFocalPoint);
  };
  publicAPI.zoom = factor => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = (x, y, z) => {
    const offset = [x, y, z];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.k)(model.position, offset, model.position);
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.k)(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = transformMat4 => {
    const vuOld = [...model.viewUp, 1.0];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(posNew, [...model.position, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec4.transformMat4 */ .ln.transformMat4(vuNew, vuOld, transformMat4);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };
  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
  publicAPI.setThickness = thickness => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = thickness => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };

  // Unimplemented functions
  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html
  publicAPI.getRoll = () => {};
  publicAPI.setObliqueAngles = (alpha, beta) => {};
  publicAPI.getOrientation = () => {};
  publicAPI.getOrientationWXYZ = () => {};
  publicAPI.getFrustumPlanes = aspect => {
    // Return array of 24 params (4 params for each of 6 plane equations)
  };
  publicAPI.getCameraLightTransformMatrix = matrix => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = () => {
    // not sure if this is the correct transformation, based on the same funciton in VTK
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(tmpMatrix, publicAPI.getViewMatrix());
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(tmpMatrix, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromScaling */ .pB.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.cameraLightTransform);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);
  };
  publicAPI.deepCopy = sourceCamera => {};
  publicAPI.physicalOrientationToWorldDirection = ori => {
    // push the x axis through the orientation quat
    const oriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.fromValues */ .Yu.fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    const qdir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.fromValues */ .Yu.fromValues(0.0, 0.0, 1.0, 0.0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.conjugate */ .Yu.conjugate(coriq, oriq);

    // rotate the z axis by the quat
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.multiply */ .Yu.multiply(qdir, oriq, qdir);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.multiply */ .Yu.multiply(qdir, qdir, coriq);

    // return the z axis in world coords
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = result => {
    publicAPI.getWorldToPhysicalMatrix(result);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = result => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(result);

    // now the physical to vtk world rotation tform
    const physVRight = [3];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.j)(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(result, result);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = vmat => {
    // invert to get view to world
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(tmpMatrix, vmat);

    // note with glmatrix operations happen in
    // the reverse order
    // mat.scale
    // mat.translate
    // will result in the translation then the scale
    // mat.mult(a,b)
    // results in perform the B transformation then A

    // then extract the params position, orientation
    // push 0,0,0 through to get a translation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);

    // push basis vectors to get orientation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(tmpvec2, tmpvec2, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(tmpvec3, upbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.subtract */ .eR.subtract(tmpvec3, tmpvec3, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.normalize */ .eR.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };

  // the provided matrix should include
  // translation and orientation only
  // mat is physical to view
  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {
    // get the WorldToPhysicalMatrix
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);

    // first convert the physical -> view matrix to be
    // world -> view
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = mat => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.lookAt */ .pB.lookAt(tmpMatrix, model.position,
    // eye
    model.focalPoint,
    // at
    model.viewUp // up
    );

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
    const result = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = mat => {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(result);
    if (model.projectionMatrix) {
      const scale = 1 / model.physicalScale;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.set */ .eR.set(tmpvec1, scale, scale, scale);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, model.projectionMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(result, result, tmpvec1);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(result, result);
      return result;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(tmpMatrix);

    // FIXME: Not sure what to do about adjust z buffer here
    // adjust Z-buffer range
    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];
    if (model.parallelProjection) {
      // set up a rectangular parallelipiped
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;
      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.ortho */ .pB.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error('Off-Axis projection is not supported at this time');
    } else {
      const tmp = Math.tan((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(model.viewAngle) / 2.0);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = model.clippingRange[0] * tmp / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }
      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;
      const znear = cRange[0];
      const zfar = cRange[1];
      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);
      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1.0;
      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0.0;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    // mats are transposed so the order is A then B
    // we reuse pMat as it is a copy so we can do what we want with it
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = (x, y, z) => {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };

  // used to handle convert js device orientation angles
  // when you use this method the camera will adjust to the
  // device orientation such that the physicalViewUp you set
  // in world coordinates looks up, and the physicalViewNorth
  // you set in world coorindates will (maybe) point north
  //
  // NOTE WARNING - much of the documentation out there on how
  // orientation works is seriously wrong. Even worse the Chrome
  // device orientation simulator is completely wrong and should
  // never be used. OMG it is so messed up.
  //
  // how it seems to work on iOS is that the device orientation
  // is specified in extrinsic angles with a alpha, beta, gamma
  // convention with axes of Z, X, Y (the code below substitutes
  // the physical coordinate system for these axes to get the right
  // modified coordinate system.
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.j)(model.physicalViewNorth, model.physicalViewUp, physVRight);

    // phone to physical coordinates
    const rotmat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(alpha), model.physicalViewUp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(beta), physVRight);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(gamma), model.physicalViewNorth);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotate */ .pB.rotate(rotmat, rotmat, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(-screen), model.physicalViewUp);
    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    const vup = new Float64Array(model.physicalViewNorth);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(dop, dop, rotmat);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
    const quatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {
      // convert to radians
      const angle = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_2__.r)(degrees);
      const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(q, [x, y, z], angle);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(quatMat, q);
    }
    const newdop = new Float64Array(3);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);
    const newvup = new Float64Array(3);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);
    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = bounds => {
    let vn = null;
    let position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    const a = -vn[0];
    const b = -vn[1];
    const c = -vn[2];
    const d = -(a * position[0] + b * position[1] + c * position[2]);

    // Set the max near clipping plane and the min far clipping plane
    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];

    // Find the closest / farthest bounding box vertex
    for (let k = 0; k < 2; k++) {
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < 2; i++) {
          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }
    return range;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.create */ .pB.create(),
  // used for world to physical transformations
  physicalTranslation: [0, 0, 0],
  physicalScale: 1.0,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.get(publicAPI, model, ['distance']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);

  // Object methods
  vtkCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkCamera');

// ----------------------------------------------------------------------------

var vtkCamera$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 660:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ColorMaps_vtkColorMaps)
});

;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.json.js
var vtkColorMaps = [
	{
		Name: "KAAMS",
		IndexedColors: [
			1,
			1,
			1,
			1,
			0,
			0,
			0,
			1,
			0,
			0,
			0,
			1,
			1,
			1,
			0,
			1,
			0,
			1,
			0,
			1,
			1,
			0.63,
			0.63,
			1,
			0.67,
			0.5,
			0.33,
			1,
			0.5,
			0.75,
			0.53,
			0.35,
			0.7,
			1,
			0.75,
			0.5
		],
		Annotations: [
			0,
			0,
			1,
			1,
			2,
			2,
			3,
			3,
			4,
			4,
			5,
			5,
			6,
			6,
			7,
			7,
			8,
			8,
			9,
			9,
			10,
			10,
			11,
			11
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Cool to Warm",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.23137254902,
			0.298039215686,
			0.752941176471,
			0.5,
			0.865,
			0.865,
			0.865,
			1,
			0.705882352941,
			0.0156862745098,
			0.149019607843
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Cool to Warm (Extended)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0.34902,
			0.03125,
			0.039216,
			0.062745,
			0.380392,
			0.0625,
			0.062745,
			0.117647,
			0.411765,
			0.09375,
			0.090196,
			0.184314,
			0.45098,
			0.125,
			0.12549,
			0.262745,
			0.501961,
			0.15625,
			0.160784,
			0.337255,
			0.541176,
			0.1875,
			0.2,
			0.396078,
			0.568627,
			0.21875,
			0.239216,
			0.454902,
			0.6,
			0.25,
			0.286275,
			0.521569,
			0.65098,
			0.28125,
			0.337255,
			0.592157,
			0.701961,
			0.3125,
			0.388235,
			0.654902,
			0.74902,
			0.34375,
			0.466667,
			0.737255,
			0.819608,
			0.375,
			0.572549,
			0.819608,
			0.878431,
			0.40625,
			0.654902,
			0.866667,
			0.909804,
			0.4375,
			0.752941,
			0.917647,
			0.941176,
			0.46875,
			0.823529,
			0.956863,
			0.968627,
			0.5,
			0.988235,
			0.960784,
			0.901961,
			0.5,
			0.941176,
			0.984314,
			0.988235,
			0.52,
			0.988235,
			0.945098,
			0.85098,
			0.54,
			0.980392,
			0.898039,
			0.784314,
			0.5625,
			0.968627,
			0.835294,
			0.698039,
			0.59375,
			0.94902,
			0.733333,
			0.588235,
			0.625,
			0.929412,
			0.65098,
			0.509804,
			0.65625,
			0.909804,
			0.564706,
			0.435294,
			0.6875,
			0.878431,
			0.458824,
			0.352941,
			0.71875,
			0.839216,
			0.388235,
			0.286275,
			0.75,
			0.760784,
			0.294118,
			0.211765,
			0.78125,
			0.701961,
			0.211765,
			0.168627,
			0.8125,
			0.65098,
			0.156863,
			0.129412,
			0.84375,
			0.6,
			0.094118,
			0.094118,
			0.875,
			0.54902,
			0.066667,
			0.098039,
			0.90625,
			0.501961,
			0.05098,
			0.12549,
			0.9375,
			0.45098,
			0.054902,
			0.172549,
			0.96875,
			0.4,
			0.054902,
			0.192157,
			1,
			0.34902,
			0.070588,
			0.211765
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Warm to Cool",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.705882352941,
			0.0156862745098,
			0.149019607843,
			0.5,
			0.865,
			0.865,
			0.865,
			1,
			0.23137254902,
			0.298039215686,
			0.752941176471
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Warm to Cool (Extended)",
		NanColor: [
			0.250004,
			0,
			0
		],
		RGBPoints: [
			0,
			0.34902,
			0,
			0.129412,
			0.025,
			0.4,
			0.00392157,
			0.101961,
			0.05,
			0.470588,
			0.0156863,
			0.0901961,
			0.075,
			0.54902,
			0.027451,
			0.0705882,
			0.1,
			0.619608,
			0.0627451,
			0.0431373,
			0.125,
			0.690196,
			0.12549,
			0.0627451,
			0.15,
			0.741176,
			0.184314,
			0.0745098,
			0.175,
			0.788235,
			0.266667,
			0.0941176,
			0.2,
			0.811765,
			0.345098,
			0.113725,
			0.225,
			0.831373,
			0.411765,
			0.133333,
			0.25,
			0.85098,
			0.47451,
			0.145098,
			0.275,
			0.870588,
			0.54902,
			0.156863,
			0.3,
			0.878431,
			0.619608,
			0.168627,
			0.325,
			0.890196,
			0.658824,
			0.196078,
			0.35,
			0.909804,
			0.717647,
			0.235294,
			0.375,
			0.929412,
			0.776471,
			0.278431,
			0.395522,
			0.94902,
			0.823529,
			0.321569,
			0.418905,
			0.968627,
			0.87451,
			0.407843,
			0.444278,
			0.980392,
			0.917647,
			0.509804,
			0.470149,
			0.988235,
			0.956863,
			0.643137,
			0.483582,
			0.992157,
			0.964706,
			0.713725,
			0.499,
			0.988235,
			0.980392,
			0.870588,
			0.5,
			1,
			1,
			1,
			0.501,
			0.913725,
			0.988235,
			0.937255,
			0.516418,
			0.827451,
			0.980392,
			0.886275,
			0.531343,
			0.764706,
			0.980392,
			0.866667,
			0.546766,
			0.658824,
			0.980392,
			0.843137,
			0.564179,
			0.572549,
			0.964706,
			0.835294,
			0.587562,
			0.423529,
			0.941176,
			0.87451,
			0.60597,
			0.262745,
			0.901961,
			0.862745,
			0.629851,
			0.0705882,
			0.854902,
			0.870588,
			0.651741,
			0.0509804,
			0.8,
			0.85098,
			0.681592,
			0.0235294,
			0.709804,
			0.831373,
			0.712935,
			0.0313725,
			0.615686,
			0.811765,
			0.75,
			0.0313725,
			0.537255,
			0.788235,
			0.775,
			0.0392157,
			0.466667,
			0.768627,
			0.8,
			0.0509804,
			0.396078,
			0.741176,
			0.825,
			0.054902,
			0.317647,
			0.709804,
			0.85,
			0.054902,
			0.243137,
			0.678431,
			0.875,
			0.0431373,
			0.164706,
			0.639216,
			0.9,
			0.0313725,
			0.0980392,
			0.6,
			0.925,
			0.0392157,
			0.0392157,
			0.560784,
			0.95,
			0.105882,
			0.0509804,
			0.509804,
			0.975,
			0.113725,
			0.0235294,
			0.45098,
			1,
			0.12549,
			0,
			0.380392
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Desaturated",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.278431372549,
			0.278431372549,
			0.858823529412,
			0.143,
			0,
			0,
			0.360784313725,
			0.285,
			0,
			1,
			1,
			0.429,
			0,
			0.501960784314,
			0,
			0.571,
			1,
			1,
			0,
			0.714,
			1,
			0.380392156863,
			0,
			0.857,
			0.419607843137,
			0,
			0,
			1,
			0.878431372549,
			0.301960784314,
			0.301960784314
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Cold and Hot",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			1,
			1,
			0.45,
			0,
			0,
			1,
			0.5,
			0,
			0,
			0.501960784314,
			0.55,
			1,
			0,
			0,
			1,
			1,
			1,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black-Body Radiation",
		NanColor: [
			0,
			0.498039215686,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.4,
			0.901960784314,
			0,
			0,
			0.8,
			0.901960784314,
			0.901960784314,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "X Ray",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			1,
			1,
			0,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Grayscale",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkRd",
		NanColor: [
			0,
			1,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkGn",
		NanColor: [
			1,
			0,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			1,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkBu",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkMa",
		NanColor: [
			0,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			1,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "BkCy",
		NanColor: [
			0,
			1,
			1
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			1,
			0,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black, Blue and White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.333,
			0,
			0,
			0.501960784314,
			0.666,
			0,
			0.501960784314,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Black, Orange and White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.333,
			0.501960784314,
			0,
			0,
			0.666,
			1,
			0.501960784314,
			0,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Linear YGB 1211g",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			0.988235,
			0.968627,
			0.02,
			1,
			0.952941,
			0.878431,
			0.05,
			0.968627,
			0.905882,
			0.776471,
			0.1,
			0.94902,
			0.898039,
			0.647059,
			0.15,
			0.901961,
			0.878431,
			0.556863,
			0.2,
			0.847059,
			0.858824,
			0.482353,
			0.25,
			0.690196,
			0.819608,
			0.435294,
			0.3,
			0.513725,
			0.768627,
			0.384314,
			0.35,
			0.337255,
			0.721569,
			0.337255,
			0.4,
			0.278431,
			0.658824,
			0.392157,
			0.45,
			0.231373,
			0.639216,
			0.435294,
			0.5,
			0.203922,
			0.6,
			0.486275,
			0.55,
			0.172549,
			0.568627,
			0.537255,
			0.6,
			0.141176,
			0.517647,
			0.54902,
			0.65,
			0.133333,
			0.458824,
			0.541176,
			0.7,
			0.12549,
			0.396078,
			0.529412,
			0.75,
			0.117647,
			0.321569,
			0.521569,
			0.8,
			0.121569,
			0.258824,
			0.509804,
			0.85,
			0.133333,
			0.227451,
			0.501961,
			0.9,
			0.145098,
			0.192157,
			0.490196,
			0.95,
			0.188235,
			0.164706,
			0.470588,
			1,
			0.258824,
			0.196078,
			0.439216
		]
	},
	{
		ColorSpace: "CIELAB",
		Creator: "Francesca Samsel",
		Name: "Linear Green (Gr4L)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.054902,
			0.109804,
			0.121569,
			0.05,
			0.07451,
			0.172549,
			0.180392,
			0.1,
			0.086275,
			0.231373,
			0.219608,
			0.15,
			0.094118,
			0.278431,
			0.25098,
			0.2,
			0.109804,
			0.34902,
			0.278431,
			0.25,
			0.113725,
			0.4,
			0.278431,
			0.3,
			0.117647,
			0.45098,
			0.270588,
			0.35,
			0.117647,
			0.490196,
			0.243137,
			0.4,
			0.113725,
			0.521569,
			0.203922,
			0.45,
			0.109804,
			0.54902,
			0.152941,
			0.5,
			0.082353,
			0.588235,
			0.082353,
			0.55,
			0.109804,
			0.631373,
			0.05098,
			0.6,
			0.211765,
			0.678431,
			0.082353,
			0.65,
			0.317647,
			0.721569,
			0.113725,
			0.7,
			0.431373,
			0.760784,
			0.160784,
			0.75,
			0.556863,
			0.8,
			0.239216,
			0.8,
			0.666667,
			0.839216,
			0.294118,
			0.85,
			0.784314,
			0.878431,
			0.396078,
			0.9,
			0.886275,
			0.921569,
			0.533333,
			0.95,
			0.960784,
			0.94902,
			0.670588,
			1,
			1,
			0.984314,
			0.901961
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Linear Blue (8_31f)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.960784,
			1,
			0.980392,
			0.05,
			0.815686,
			0.960784,
			0.913725,
			0.1,
			0.670588,
			0.929412,
			0.870588,
			0.15,
			0.556863,
			0.901961,
			0.843137,
			0.2,
			0.478431,
			0.870588,
			0.823529,
			0.25,
			0.439216,
			0.831373,
			0.803922,
			0.3,
			0.4,
			0.8,
			0.788235,
			0.35,
			0.376471,
			0.768627,
			0.768627,
			0.4,
			0.34902,
			0.709804,
			0.729412,
			0.45,
			0.32549,
			0.654902,
			0.690196,
			0.5,
			0.301961,
			0.607843,
			0.658824,
			0.55,
			0.247059,
			0.545098,
			0.619608,
			0.6,
			0.239216,
			0.494118,
			0.580392,
			0.65,
			0.227451,
			0.439216,
			0.541176,
			0.7,
			0.227451,
			0.403922,
			0.521569,
			0.75,
			0.231373,
			0.368627,
			0.501961,
			0.8,
			0.227451,
			0.321569,
			0.470588,
			0.85,
			0.219608,
			0.282353,
			0.439216,
			0.9,
			0.192157,
			0.235294,
			0.4,
			0.95,
			0.160784,
			0.184314,
			0.34902,
			1,
			0.133333,
			0.12549,
			0.301961
		]
	},
	{
		ColorSpace: "HSV",
		Name: "Blue to Red Rainbow",
		NanColor: [
			0.498039215686,
			0.498039215686,
			0.498039215686
		],
		RGBPoints: [
			0,
			0,
			0,
			1,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "HSV",
		Name: "Red to Blue Rainbow",
		NanColor: [
			0.498039215686,
			0.498039215686,
			0.498039215686
		],
		RGBPoints: [
			0,
			1,
			0,
			0,
			1,
			0,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended White",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			1,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended Grey",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0.317647058824,
			0.341176470588,
			0.43137254902,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Rainbow Blended Black",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0,
			0,
			0.17,
			0,
			0,
			1,
			0.34,
			0,
			1,
			1,
			0.5,
			0,
			1,
			0,
			0.67,
			1,
			1,
			0,
			0.84,
			1,
			0,
			0,
			1,
			0.878431372549,
			0,
			1
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Blue to Yellow",
		NanColor: [
			1,
			0,
			0
		],
		RGBPoints: [
			0,
			0.0392156862745,
			0.0392156862745,
			0.949019607843,
			1,
			0.949019607843,
			0.949019607843,
			0.0392156862745
		]
	},
	{
		ColorSpace: "HSV",
		Name: "blot",
		RGBPoints: [
			0,
			0,
			0,
			1,
			0.166,
			0,
			0,
			1,
			0.167,
			1,
			0,
			1,
			0.332,
			1,
			0,
			1,
			0.333,
			0,
			1,
			1,
			0.5,
			0,
			1,
			1,
			0.501,
			0,
			1,
			0,
			0.666,
			0,
			1,
			0,
			0.667,
			1,
			1,
			0,
			0.832,
			1,
			1,
			0,
			0.833,
			1,
			0,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "CIELab Blue to Red",
		NanColor: [
			1,
			1,
			0
		],
		RGBPoints: [
			0,
			0,
			0.6,
			0.749019607843,
			1,
			0.76862745098,
			0.466666666667,
			0.341176470588
		]
	},
	{
		ColorSpace: "RGB",
		Name: "jet",
		RGBPoints: [
			-1,
			0,
			0,
			0.5625,
			-0.777778,
			0,
			0,
			1,
			-0.269841,
			0,
			1,
			1,
			-0.015873,
			0.5,
			1,
			0.5,
			0.238095,
			1,
			1,
			0,
			0.746032,
			1,
			0,
			0,
			1,
			0.5,
			0,
			0
		]
	},
	{
		ColorSpace: "RGB",
		Name: "rainbow",
		RGBPoints: [
			-1,
			0,
			0,
			1,
			-0.5,
			0,
			1,
			1,
			0,
			0,
			1,
			0,
			0.5,
			1,
			1,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_rainbow_bright",
		RGBPoints: [
			-1,
			0.32549,
			0.14902,
			0.960784,
			-0.866221,
			0.297047,
			0.375586,
			0.963836,
			-0.732441,
			0.180302,
			0.536818,
			0.964627,
			-0.598662,
			0.1302,
			0.649207,
			0.929647,
			-0.464883,
			0.0445143,
			0.749654,
			0.855998,
			-0.331104,
			0.0271325,
			0.830713,
			0.721527,
			-0.197324,
			0.259504,
			0.866145,
			0.543555,
			-0.0635452,
			0.428364,
			0.890725,
			0.329819,
			0.0702341,
			0.568503,
			0.898508,
			0.187623,
			0.204013,
			0.738259,
			0.890317,
			0.0825461,
			0.337793,
			0.84546,
			0.86136,
			0.0147555,
			0.471572,
			0.912191,
			0.808018,
			0,
			0.605351,
			0.962848,
			0.710445,
			0,
			0.73913,
			0.999469,
			0.600258,
			0.0176284,
			0.87291,
			0.994156,
			0.445975,
			0.193912,
			1,
			0.980407,
			0.247105,
			0.262699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_rainbow_dark",
		RGBPoints: [
			-1,
			0,
			0,
			0.423499,
			-0.866221,
			0,
			0.119346,
			0.529237,
			-0.732441,
			0,
			0.238691,
			0.634976,
			-0.598662,
			0,
			0.346852,
			0.68788,
			-0.464883,
			0,
			0.45022,
			0.718141,
			-0.331104,
			0,
			0.553554,
			0.664839,
			-0.197324,
			0,
			0.651082,
			0.519303,
			-0.0635452,
			0.115841,
			0.72479,
			0.352857,
			0.0702341,
			0.326771,
			0.781195,
			0.140187,
			0.204013,
			0.522765,
			0.798524,
			0.0284624,
			0.337793,
			0.703162,
			0.788685,
			0.00885756,
			0.471572,
			0.845118,
			0.751133,
			0,
			0.605351,
			0.955734,
			0.690825,
			0,
			0.73913,
			0.995402,
			0.567916,
			0.0618524,
			0.87291,
			0.987712,
			0.403398,
			0.164851,
			1,
			0.980407,
			0.247105,
			0.262699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_CubicL",
		RGBPoints: [
			-1,
			0.479965,
			0.0118108,
			0.5307,
			-0.87451,
			0.522213,
			0.0551282,
			0.706919,
			-0.74902,
			0.50839,
			0.237278,
			0.867764,
			-0.623529,
			0.451617,
			0.373834,
			0.987255,
			-0.498039,
			0.39365,
			0.497255,
			0.97506,
			-0.372549,
			0.328631,
			0.599639,
			0.891843,
			-0.247059,
			0.250043,
			0.690286,
			0.778553,
			-0.121569,
			0.249656,
			0.764905,
			0.645857,
			0.00392157,
			0.297954,
			0.821466,
			0.50449,
			0.129412,
			0.337509,
			0.872595,
			0.358447,
			0.254902,
			0.430011,
			0.913789,
			0.297079,
			0.380392,
			0.587191,
			0.931381,
			0.333353,
			0.505882,
			0.727937,
			0.93591,
			0.353742,
			0.631373,
			0.826403,
			0.921081,
			0.365066,
			0.756863,
			0.893201,
			0.846317,
			0.372662,
			0.882353,
			0.965347,
			0.73884,
			0.378506,
			1,
			0.983235,
			0.597451,
			0.366856
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_CubicYF",
		RGBPoints: [
			-1,
			0.5151,
			0.0482,
			0.6697,
			-0.87451,
			0.520711,
			0.168955,
			0.800574,
			-0.74902,
			0.493694,
			0.278596,
			0.911824,
			-0.623529,
			0.440026,
			0.369475,
			0.984978,
			-0.498039,
			0.398932,
			0.457593,
			0.987053,
			-0.372549,
			0.350651,
			0.540644,
			0.929608,
			-0.247059,
			0.298827,
			0.615625,
			0.857729,
			-0.121569,
			0.239928,
			0.685061,
			0.769531,
			0.00392157,
			0.228832,
			0.739349,
			0.673287,
			0.129412,
			0.263297,
			0.78608,
			0.569988,
			0.254902,
			0.298107,
			0.828337,
			0.460214,
			0.380392,
			0.33092,
			0.864071,
			0.352674,
			0.505882,
			0.38306,
			0.898169,
			0.287309,
			0.631373,
			0.49023,
			0.917481,
			0.307961,
			0.756863,
			0.62372,
			0.926026,
			0.332309,
			0.882353,
			0.717458,
			0.92527,
			0.342476,
			1,
			0.8,
			0.9255,
			0.3529
		]
	},
	{
		ColorSpace: "Lab",
		Name: "gist_earth",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.239216,
			0.027451,
			0.415686,
			-0.74902,
			0.0901961,
			0.254902,
			0.556863,
			-0.623529,
			0.0941176,
			0.352941,
			0.54902,
			-0.498039,
			0.105882,
			0.435294,
			0.533333,
			-0.372549,
			0.12549,
			0.52549,
			0.501961,
			-0.247059,
			0.156863,
			0.596078,
			0.443137,
			-0.121569,
			0.196078,
			0.65098,
			0.380392,
			0.00392157,
			0.282353,
			0.717647,
			0.301961,
			0.129412,
			0.466667,
			0.772549,
			0.27451,
			0.254902,
			0.678431,
			0.784314,
			0.309804,
			0.380392,
			0.901961,
			0.756863,
			0.376471,
			0.505882,
			0.992157,
			0.705882,
			0.521569,
			0.631373,
			1,
			0.721569,
			0.701961,
			0.756863,
			1,
			0.784314,
			0.784314,
			0.882353,
			1,
			0.866667,
			0.866667,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "2hot",
		RGBPoints: [
			-1,
			0.0416667,
			0,
			0,
			-0.873016,
			0.208333,
			0,
			0,
			-0.746032,
			0.375,
			0,
			0,
			-0.619048,
			0.541667,
			0,
			0,
			-0.492063,
			0.708333,
			0,
			0,
			-0.365079,
			0.854137,
			0,
			0,
			-0.238095,
			0.937488,
			0.039062,
			0,
			-0.111111,
			1,
			0.208333,
			0,
			0.015873,
			1,
			0.375,
			0,
			0.142857,
			1,
			0.541667,
			0,
			0.269841,
			1,
			0.708333,
			0,
			0.396825,
			1,
			0.858805,
			0.03125,
			0.52381,
			1,
			0.947392,
			0.15625,
			0.650794,
			1,
			1,
			0.3125,
			0.777778,
			1,
			1,
			0.5625,
			0.904762,
			1,
			1,
			0.8125,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red2yellow_BW",
		RGBPoints: [
			-1,
			7.54296e-7,
			0,
			0.0000109827,
			-0.87451,
			0.18285,
			0.0264094,
			0,
			-0.74902,
			0.3066,
			0,
			0,
			-0.623529,
			0.422841,
			0,
			0,
			-0.498039,
			0.522945,
			0,
			0,
			-0.372549,
			0.605721,
			0,
			0,
			-0.247059,
			0.672502,
			0.14168,
			0,
			-0.121569,
			0.728167,
			0.244025,
			0,
			0.00392157,
			0.781215,
			0.333454,
			0,
			0.129412,
			0.825,
			0.423586,
			0,
			0.254902,
			0.855893,
			0.516793,
			0,
			0.380392,
			0.880491,
			0.608846,
			0,
			0.505882,
			0.910305,
			0.695505,
			0,
			0.631373,
			0.94109,
			0.779067,
			0.223528,
			0.756863,
			0.967873,
			0.858572,
			0.473521,
			0.882353,
			0.986815,
			0.933211,
			0.751583,
			1,
			1,
			1,
			0.999997
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_marine2gold_BW",
		RGBPoints: [
			-1,
			1.11641e-7,
			0,
			0.00000162551,
			-0.87451,
			0.0413146,
			0.0619808,
			0.209857,
			-0.74902,
			0.0185557,
			0.101341,
			0.350684,
			-0.623529,
			0.00486405,
			0.149847,
			0.461054,
			-0.498039,
			0.0836345,
			0.210845,
			0.517906,
			-0.372549,
			0.173222,
			0.276134,
			0.541793,
			-0.247059,
			0.259857,
			0.343877,
			0.535869,
			-0.121569,
			0.362299,
			0.408124,
			0.504293,
			0.00392157,
			0.468266,
			0.468276,
			0.468257,
			0.129412,
			0.582781,
			0.527545,
			0.374914,
			0.254902,
			0.691591,
			0.585251,
			0.274266,
			0.380392,
			0.784454,
			0.645091,
			0.247332,
			0.505882,
			0.862299,
			0.710383,
			0.27518,
			0.631373,
			0.920863,
			0.782923,
			0.351563,
			0.756863,
			0.955792,
			0.859699,
			0.533541,
			0.882353,
			0.976162,
			0.93433,
			0.780671,
			1,
			1,
			1,
			0.999983
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2gold_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0742735,
			0.0440331,
			0.230013,
			-0.74902,
			0.125276,
			0.0258685,
			0.415826,
			-0.623529,
			0.143879,
			0.0163031,
			0.591346,
			-0.498039,
			0.212261,
			0.0627855,
			0.705239,
			-0.372549,
			0.306048,
			0.141178,
			0.763636,
			-0.247059,
			0.391537,
			0.232286,
			0.773263,
			-0.121569,
			0.461734,
			0.336633,
			0.708321,
			0.00392157,
			0.54209,
			0.427581,
			0.590007,
			0.129412,
			0.61704,
			0.508623,
			0.460978,
			0.254902,
			0.702703,
			0.579586,
			0.309117,
			0.380392,
			0.790336,
			0.644811,
			0.170397,
			0.505882,
			0.870173,
			0.710733,
			0.117134,
			0.631373,
			0.93656,
			0.781991,
			0.157144,
			0.756863,
			0.965672,
			0.862068,
			0.409836,
			0.882353,
			0.985751,
			0.936296,
			0.714162,
			1,
			1,
			1,
			0.999999
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_sapphire2gold_BW",
		RGBPoints: [
			-1,
			0.107704,
			0.107708,
			0.107694,
			-0.87451,
			0.1851,
			0.112354,
			0.308554,
			-0.74902,
			0.236782,
			0.114233,
			0.48788,
			-0.623529,
			0.28296,
			0.126187,
			0.639464,
			-0.498039,
			0.344787,
			0.171643,
			0.739713,
			-0.372549,
			0.413325,
			0.242371,
			0.76913,
			-0.247059,
			0.481863,
			0.3131,
			0.719841,
			-0.121569,
			0.550402,
			0.383829,
			0.612222,
			0.00392157,
			0.61894,
			0.454558,
			0.51126,
			0.129412,
			0.687478,
			0.525287,
			0.39993,
			0.254902,
			0.756017,
			0.596016,
			0.289923,
			0.380392,
			0.824555,
			0.666745,
			0.255498,
			0.505882,
			0.892979,
			0.736822,
			0.27696,
			0.631373,
			0.938851,
			0.804966,
			0.351734,
			0.756863,
			0.966491,
			0.874853,
			0.53572,
			0.882353,
			0.982105,
			0.94153,
			0.782579,
			1,
			1,
			1,
			0.999986
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red2purple_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.167793,
			0.0166271,
			0.0431278,
			-0.74902,
			0.262608,
			0.0107595,
			0.0791181,
			-0.623529,
			0.351902,
			0.0101858,
			0.100926,
			-0.498039,
			0.441257,
			0.0160835,
			0.131919,
			-0.372549,
			0.5221,
			0.0555972,
			0.195625,
			-0.247059,
			0.593852,
			0.104294,
			0.310234,
			-0.121569,
			0.654628,
			0.158115,
			0.448486,
			0.00392157,
			0.707443,
			0.220914,
			0.570253,
			0.129412,
			0.749504,
			0.293268,
			0.67897,
			0.254902,
			0.781587,
			0.370517,
			0.779269,
			0.380392,
			0.809951,
			0.451099,
			0.855831,
			0.505882,
			0.84424,
			0.531462,
			0.900451,
			0.631373,
			0.865174,
			0.620901,
			0.91606,
			0.756863,
			0.875041,
			0.714054,
			0.910284,
			0.882353,
			0.880764,
			0.80554,
			0.896276,
			1,
			0.887572,
			0.887591,
			0.887556
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2pink_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.117562,
			0.0291202,
			0.175876,
			-0.74902,
			0.178368,
			0.0458476,
			0.285454,
			-0.623529,
			0.237731,
			0.0680173,
			0.387717,
			-0.498039,
			0.300877,
			0.0956291,
			0.484802,
			-0.372549,
			0.370929,
			0.136858,
			0.554985,
			-0.247059,
			0.449033,
			0.189273,
			0.58863,
			-0.121569,
			0.529971,
			0.245796,
			0.598587,
			0.00392157,
			0.609914,
			0.300643,
			0.610244,
			0.129412,
			0.697079,
			0.351286,
			0.616371,
			0.254902,
			0.785858,
			0.401991,
			0.617376,
			0.380392,
			0.862517,
			0.45745,
			0.64463,
			0.505882,
			0.91359,
			0.525462,
			0.705336,
			0.631373,
			0.932583,
			0.61064,
			0.767412,
			0.756863,
			0.922478,
			0.706966,
			0.817522,
			0.882353,
			0.901302,
			0.803071,
			0.856311,
			1,
			0.887571,
			0.887591,
			0.887549
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_pbj_lin",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.091821,
			0.0611476,
			0.10617,
			-0.74902,
			0.160311,
			0.0900022,
			0.192713,
			-0.623529,
			0.22484,
			0.12126,
			0.272128,
			-0.498039,
			0.291263,
			0.157469,
			0.340828,
			-0.372549,
			0.360015,
			0.200388,
			0.388903,
			-0.247059,
			0.437497,
			0.250058,
			0.387201,
			-0.121569,
			0.512636,
			0.304969,
			0.355955,
			0.00392157,
			0.582603,
			0.360874,
			0.33488,
			0.129412,
			0.655126,
			0.416374,
			0.306351,
			0.254902,
			0.725889,
			0.473329,
			0.279051,
			0.380392,
			0.778125,
			0.537928,
			0.302697,
			0.505882,
			0.815894,
			0.606931,
			0.382431,
			0.631373,
			0.839159,
			0.679308,
			0.497608,
			0.756863,
			0.854748,
			0.751666,
			0.631792,
			0.882353,
			0.869483,
			0.822508,
			0.768592,
			1,
			0.887572,
			0.887589,
			0.887565
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2green_muted",
		RGBPoints: [
			-1,
			0.107704,
			0.107708,
			0.107695,
			-0.87451,
			0.141522,
			0.13066,
			0.270741,
			-0.74902,
			0.180123,
			0.146119,
			0.42308,
			-0.623529,
			0.210161,
			0.169674,
			0.551795,
			-0.498039,
			0.239701,
			0.212939,
			0.634969,
			-0.372549,
			0.253916,
			0.282947,
			0.653641,
			-0.247059,
			0.242791,
			0.366933,
			0.608521,
			-0.121569,
			0.226302,
			0.446776,
			0.52693,
			0.00392157,
			0.236237,
			0.514689,
			0.458798,
			0.129412,
			0.274641,
			0.577589,
			0.376069,
			0.254902,
			0.349625,
			0.633993,
			0.288131,
			0.380392,
			0.4437,
			0.683677,
			0.260497,
			0.505882,
			0.536247,
			0.731214,
			0.285424,
			0.631373,
			0.628472,
			0.777128,
			0.349151,
			0.756863,
			0.718259,
			0.819287,
			0.496825,
			0.882353,
			0.804768,
			0.856164,
			0.703299,
			1,
			0.887571,
			0.887591,
			0.887548
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2green_BW",
		RGBPoints: [
			-1,
			3.63578e-7,
			0,
			0.00000529374,
			-0.87451,
			0.0539915,
			0.0577948,
			0.212806,
			-0.74902,
			0.0620393,
			0.0758942,
			0.388959,
			-0.623529,
			0.0697499,
			0.102032,
			0.54177,
			-0.498039,
			0.113295,
			0.156156,
			0.64334,
			-0.372549,
			0.152047,
			0.243196,
			0.670283,
			-0.247059,
			0.158096,
			0.344084,
			0.622864,
			-0.121569,
			0.151142,
			0.43922,
			0.532767,
			0.00392157,
			0.17155,
			0.521588,
			0.457719,
			0.129412,
			0.225861,
			0.599141,
			0.363997,
			0.254902,
			0.32328,
			0.67007,
			0.259083,
			0.380392,
			0.442344,
			0.733697,
			0.223754,
			0.505882,
			0.558409,
			0.794941,
			0.257411,
			0.631373,
			0.673875,
			0.854344,
			0.340822,
			0.756863,
			0.787244,
			0.909326,
			0.524717,
			0.882353,
			0.896483,
			0.958063,
			0.775914,
			1,
			1,
			1,
			0.999982
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GREEN-WHITE_LINEAR",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.062745,
			0,
			-0.74902,
			0,
			0.12549,
			0,
			-0.623529,
			0,
			0.188235,
			0,
			-0.498039,
			0,
			0.25098,
			0,
			-0.372549,
			0,
			0.313725,
			0,
			-0.247059,
			0,
			0.376471,
			0,
			-0.121569,
			0.094118,
			0.439216,
			0,
			0.00392157,
			0.196078,
			0.501961,
			0,
			0.129412,
			0.294118,
			0.564706,
			0,
			0.254902,
			0.396078,
			0.627451,
			0,
			0.380392,
			0.498039,
			0.690196,
			0,
			0.505882,
			0.6,
			0.752941,
			0.145098,
			0.631373,
			0.701961,
			0.815686,
			0.364706,
			0.756863,
			0.8,
			0.878431,
			0.580392,
			0.882353,
			0.901961,
			0.941176,
			0.796078,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_green2yellow_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.105542,
			0.0603919,
			-0.74902,
			0,
			0.159454,
			0.104148,
			-0.623529,
			0,
			0.219502,
			0.15542,
			-0.498039,
			0,
			0.282276,
			0.203811,
			-0.372549,
			0,
			0.346331,
			0.235652,
			-0.247059,
			0,
			0.411765,
			0.235428,
			-0.121569,
			0,
			0.477177,
			0.217977,
			0.00392157,
			0.0593644,
			0.541635,
			0.21361,
			0.129412,
			0.233081,
			0.604722,
			0.210591,
			0.254902,
			0.369803,
			0.664942,
			0.226536,
			0.380392,
			0.498446,
			0.722367,
			0.288237,
			0.505882,
			0.601929,
			0.782244,
			0.380815,
			0.631373,
			0.703207,
			0.840497,
			0.512134,
			0.756863,
			0.803186,
			0.896433,
			0.674462,
			0.882353,
			0.903834,
			0.950266,
			0.846715,
			1,
			1,
			1,
			0.999981
		]
	},
	{
		ColorSpace: "Lab",
		Name: "blue2cyan",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0.152941,
			0.364706,
			-0.74902,
			0,
			0.254902,
			0.470588,
			-0.623529,
			0,
			0.34902,
			0.572549,
			-0.498039,
			0,
			0.443137,
			0.670588,
			-0.372549,
			0,
			0.537255,
			0.772549,
			-0.247059,
			0,
			0.627451,
			0.870588,
			-0.121569,
			0,
			0.717647,
			0.964706,
			0.00392157,
			0.0784314,
			0.772549,
			1,
			0.129412,
			0.207843,
			0.858824,
			1,
			0.254902,
			0.32549,
			0.941176,
			1,
			0.380392,
			0.45098,
			1,
			1,
			0.505882,
			0.560784,
			1,
			1,
			0.631373,
			0.662745,
			1,
			1,
			0.756863,
			0.760784,
			1,
			1,
			0.882353,
			0.870588,
			1,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2cyan_BW",
		RGBPoints: [
			-1,
			4.05298e-7,
			0,
			0.0000059012,
			-0.87451,
			0.0207526,
			0.0740933,
			0.18093,
			-0.74902,
			0,
			0.121033,
			0.30343,
			-0.623529,
			0,
			0.166892,
			0.416095,
			-0.498039,
			0,
			0.216768,
			0.524796,
			-0.372549,
			0.0164769,
			0.275471,
			0.608585,
			-0.247059,
			0.0544527,
			0.344824,
			0.659267,
			-0.121569,
			0.0880643,
			0.419118,
			0.688675,
			0.00392157,
			0.127938,
			0.492556,
			0.720256,
			0.129412,
			0.149476,
			0.566946,
			0.756918,
			0.254902,
			0.188961,
			0.641333,
			0.792122,
			0.380392,
			0.245482,
			0.715336,
			0.827609,
			0.505882,
			0.329216,
			0.786235,
			0.874761,
			0.631373,
			0.453558,
			0.852803,
			0.918466,
			0.756863,
			0.626281,
			0.910493,
			0.954,
			0.882353,
			0.82257,
			0.958709,
			0.980146,
			1,
			1,
			1,
			0.999989
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0425591,
			0.0763529,
			0.150682,
			-0.74902,
			0.0569472,
			0.119154,
			0.275403,
			-0.623529,
			0.0635978,
			0.164772,
			0.395427,
			-0.498039,
			0.0774342,
			0.213851,
			0.510014,
			-0.372549,
			0.106815,
			0.267034,
			0.615102,
			-0.247059,
			0.122093,
			0.324649,
			0.720068,
			-0.121569,
			0.160851,
			0.387068,
			0.806956,
			0.00392157,
			0.213754,
			0.453516,
			0.878012,
			0.129412,
			0.26722,
			0.524656,
			0.932436,
			0.254902,
			0.326844,
			0.599279,
			0.968038,
			0.380392,
			0.403403,
			0.674712,
			0.984784,
			0.505882,
			0.499703,
			0.745519,
			1,
			0.631373,
			0.615055,
			0.813983,
			1,
			0.756863,
			0.74405,
			0.879228,
			1,
			0.882353,
			0.877909,
			0.941913,
			1,
			1,
			1,
			1,
			0.999996
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BLUE-WHITE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0,
			0,
			0.082353,
			-0.74902,
			0,
			0,
			0.168627,
			-0.623529,
			0,
			0,
			0.254902,
			-0.498039,
			0,
			0,
			0.337255,
			-0.372549,
			0,
			0,
			0.423529,
			-0.247059,
			0,
			0,
			0.509804,
			-0.121569,
			0,
			0.101961,
			0.592157,
			0.00392157,
			0,
			0.203922,
			0.678431,
			0.129412,
			0,
			0.301961,
			0.764706,
			0.254902,
			0,
			0.403922,
			0.85098,
			0.380392,
			0,
			0.505882,
			0.933333,
			0.505882,
			0,
			0.603922,
			1,
			0.631373,
			0.254902,
			0.705882,
			1,
			0.756863,
			0.509804,
			0.807843,
			1,
			0.882353,
			0.764706,
			0.905882,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple_BW",
		RGBPoints: [
			-1,
			4.264e-8,
			0,
			6.20844e-7,
			-0.87451,
			0.100579,
			0.0593111,
			0.145666,
			-0.74902,
			0.167794,
			0.0889224,
			0.254953,
			-0.623529,
			0.231446,
			0.123339,
			0.360511,
			-0.498039,
			0.296699,
			0.163027,
			0.461278,
			-0.372549,
			0.363211,
			0.209286,
			0.55306,
			-0.247059,
			0.431136,
			0.260776,
			0.637195,
			-0.121569,
			0.498202,
			0.320012,
			0.705799,
			0.00392157,
			0.567456,
			0.380459,
			0.778091,
			0.129412,
			0.629381,
			0.445284,
			0.8448,
			0.254902,
			0.688373,
			0.517374,
			0.895694,
			0.380392,
			0.74891,
			0.590906,
			0.93976,
			0.505882,
			0.805017,
			0.667956,
			0.977626,
			0.631373,
			0.850914,
			0.752618,
			0.992396,
			0.756863,
			0.89724,
			0.838454,
			0.994093,
			0.882353,
			0.948461,
			0.922603,
			0.994449,
			1,
			1,
			1,
			0.999967
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_magenta_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000254023,
			-0.87451,
			0.128696,
			0.0456782,
			0.11635,
			-0.74902,
			0.228133,
			0.0476299,
			0.201452,
			-0.623529,
			0.327273,
			0.0374065,
			0.282107,
			-0.498039,
			0.420953,
			0.0408166,
			0.35709,
			-0.372549,
			0.511562,
			0.0642203,
			0.430511,
			-0.247059,
			0.599552,
			0.102686,
			0.504257,
			-0.121569,
			0.684646,
			0.150536,
			0.579429,
			0.00392157,
			0.765817,
			0.205978,
			0.656062,
			0.129412,
			0.839176,
			0.27229,
			0.731807,
			0.254902,
			0.89536,
			0.357594,
			0.797309,
			0.380392,
			0.930238,
			0.457825,
			0.846984,
			0.505882,
			0.945921,
			0.564536,
			0.880571,
			0.631373,
			0.948995,
			0.670753,
			0.902279,
			0.756863,
			0.947124,
			0.772819,
			0.918171,
			0.882353,
			0.947265,
			0.869424,
			0.934352,
			1,
			0.954719,
			0.95475,
			0.954726
		]
	},
	{
		ColorSpace: "Lab",
		Name: "magenta",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.364706,
			0,
			0.152941,
			-0.74902,
			0.470588,
			0,
			0.254902,
			-0.623529,
			0.572549,
			0,
			0.34902,
			-0.498039,
			0.670588,
			0,
			0.443137,
			-0.372549,
			0.772549,
			0,
			0.537255,
			-0.247059,
			0.870588,
			0,
			0.627451,
			-0.121569,
			0.964706,
			0,
			0.717647,
			0.00392157,
			1,
			0.0784314,
			0.772549,
			0.129412,
			1,
			0.207843,
			0.858824,
			0.254902,
			1,
			0.32549,
			0.941176,
			0.380392,
			1,
			0.45098,
			1,
			0.505882,
			1,
			0.560784,
			1,
			0.631373,
			1,
			0.662745,
			1,
			0.756863,
			1,
			0.760784,
			1,
			0.882353,
			1,
			0.870588,
			1,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RED-PURPLE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.188235,
			0,
			0.007843,
			-0.74902,
			0.345098,
			0,
			0.035294,
			-0.623529,
			0.439216,
			0,
			0.098039,
			-0.498039,
			0.533333,
			0,
			0.152941,
			-0.372549,
			0.627451,
			0.015686,
			0.211765,
			-0.247059,
			0.721569,
			0.031373,
			0.266667,
			-0.121569,
			0.8,
			0.047059,
			0.329412,
			0.00392157,
			0.862745,
			0.047059,
			0.403922,
			0.129412,
			0.941176,
			0.062745,
			0.466667,
			0.254902,
			0.988235,
			0.078431,
			0.54902,
			0.380392,
			0.988235,
			0.141176,
			0.643137,
			0.505882,
			0.988235,
			0.25098,
			0.729412,
			0.631373,
			0.988235,
			0.376471,
			0.811765,
			0.756863,
			0.988235,
			0.54902,
			0.886275,
			0.882353,
			0.988235,
			0.752941,
			0.952941,
			1,
			0.996078,
			0.996078,
			0.996078
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_red_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.147204,
			0.0480135,
			0.0401815,
			-0.74902,
			0.253411,
			0.0617478,
			0.0301333,
			-0.623529,
			0.356059,
			0.0746331,
			0.0446897,
			-0.498039,
			0.457731,
			0.0934935,
			0.0636931,
			-0.372549,
			0.557199,
			0.122714,
			0.0860013,
			-0.247059,
			0.665179,
			0.144238,
			0.105585,
			-0.121569,
			0.763833,
			0.187056,
			0.138326,
			0.00392157,
			0.847035,
			0.254558,
			0.189407,
			0.129412,
			0.905663,
			0.345937,
			0.258215,
			0.254902,
			0.941431,
			0.447111,
			0.346277,
			0.380392,
			0.962608,
			0.546927,
			0.457571,
			0.505882,
			0.987833,
			0.637276,
			0.569944,
			0.631373,
			0.994202,
			0.732176,
			0.687958,
			0.756863,
			0.993304,
			0.826268,
			0.800567,
			0.882353,
			0.994413,
			0.917205,
			0.906393,
			1,
			1,
			1,
			0.999979
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RED_TEMPERATURE",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.090196,
			0,
			0,
			-0.74902,
			0.180392,
			0,
			0,
			-0.623529,
			0.270588,
			0,
			0,
			-0.498039,
			0.360784,
			0,
			0,
			-0.372549,
			0.45098,
			0,
			0,
			-0.247059,
			0.545098,
			0,
			0,
			-0.121569,
			0.635294,
			0,
			0,
			0.00392157,
			0.72549,
			0.058824,
			0,
			0.129412,
			0.815686,
			0.176471,
			0,
			0.254902,
			0.905882,
			0.294118,
			0,
			0.380392,
			1,
			0.411765,
			0,
			0.505882,
			1,
			0.533333,
			0.027451,
			0.631373,
			1,
			0.65098,
			0.27451,
			0.756863,
			1,
			0.768627,
			0.521569,
			0.882353,
			1,
			0.886275,
			0.768627,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_orange_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000253806,
			-0.87451,
			0.135871,
			0.0593824,
			0,
			-0.74902,
			0.224328,
			0.0907216,
			0,
			-0.623529,
			0.318083,
			0.119647,
			0,
			-0.498039,
			0.414443,
			0.150246,
			0,
			-0.372549,
			0.511077,
			0.184884,
			0,
			-0.247059,
			0.605501,
			0.226033,
			0,
			-0.121569,
			0.695274,
			0.275491,
			0,
			0.00392157,
			0.777826,
			0.334445,
			0,
			0.129412,
			0.851498,
			0.402441,
			0,
			0.254902,
			0.915899,
			0.47759,
			0.000602975,
			0.380392,
			0.971984,
			0.557882,
			0.0361443,
			0.505882,
			1,
			0.641287,
			0.135967,
			0.631373,
			1,
			0.725198,
			0.27997,
			0.756863,
			1,
			0.808205,
			0.438135,
			0.882353,
			1,
			0.89306,
			0.587036,
			1,
			1,
			0.977928,
			0.721599
		]
	},
	{
		ColorSpace: "Lab",
		Name: "heated_object",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.34902,
			0.0862745,
			0,
			-0.74902,
			0.45098,
			0.172549,
			0,
			-0.623529,
			0.52549,
			0.231373,
			0,
			-0.498039,
			0.580392,
			0.278431,
			0,
			-0.372549,
			0.623529,
			0.313725,
			0,
			-0.247059,
			0.670588,
			0.352941,
			0,
			-0.121569,
			0.717647,
			0.392157,
			0,
			0.00392157,
			0.772549,
			0.439216,
			0,
			0.129412,
			0.839216,
			0.494118,
			0,
			0.254902,
			0.901961,
			0.541176,
			0,
			0.380392,
			0.968627,
			0.6,
			0,
			0.505882,
			1,
			0.658824,
			0,
			0.631373,
			1,
			0.721569,
			0,
			0.756863,
			1,
			0.827451,
			0.298039,
			0.882353,
			1,
			0.976471,
			0.72549,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_gold_BW",
		RGBPoints: [
			-1,
			0,
			0,
			0.0000190933,
			-0.87451,
			0.128363,
			0.0636265,
			0,
			-0.74902,
			0.193795,
			0.111057,
			0,
			-0.623529,
			0.25976,
			0.15987,
			0,
			-0.498039,
			0.328546,
			0.210589,
			0,
			-0.372549,
			0.399726,
			0.26332,
			0,
			-0.247059,
			0.472969,
			0.318261,
			0,
			-0.121569,
			0.546245,
			0.375827,
			0,
			0.00392157,
			0.61745,
			0.436719,
			0,
			0.129412,
			0.685545,
			0.501113,
			0,
			0.254902,
			0.749578,
			0.568799,
			0,
			0.380392,
			0.80962,
			0.6394,
			0,
			0.505882,
			0.865572,
			0.712699,
			0.10257,
			0.631373,
			0.917709,
			0.787569,
			0.233665,
			0.756863,
			0.966914,
			0.863138,
			0.369608,
			0.882353,
			1,
			0.939405,
			0.496104,
			1,
			0.999225,
			1,
			0.612275
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_brown_BW",
		RGBPoints: [
			-1,
			3.3216e-7,
			0,
			0.00000483629,
			-0.87451,
			0.14693,
			0.0518172,
			0,
			-0.74902,
			0.225806,
			0.0814996,
			0,
			-0.623529,
			0.301681,
			0.111452,
			0,
			-0.498039,
			0.370487,
			0.150664,
			0,
			-0.372549,
			0.43108,
			0.199477,
			0,
			-0.247059,
			0.4849,
			0.255107,
			0,
			-0.121569,
			0.536798,
			0.313486,
			0,
			0.00392157,
			0.59286,
			0.371167,
			0,
			0.129412,
			0.653119,
			0.428135,
			0,
			0.254902,
			0.714589,
			0.485917,
			0.0379541,
			0.380392,
			0.774667,
			0.54565,
			0.116634,
			0.505882,
			0.831222,
			0.608047,
			0.183895,
			0.631373,
			0.880305,
			0.674199,
			0.260298,
			0.756863,
			0.922314,
			0.742472,
			0.367086,
			0.882353,
			0.959408,
			0.811222,
			0.497258,
			1,
			0.993548,
			0.875183,
			0.622093
		]
	},
	{
		ColorSpace: "Lab",
		Name: "copper_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0784314,
			0.0501961,
			0.0313725,
			-0.74902,
			0.156863,
			0.100392,
			0.0627451,
			-0.623529,
			0.235294,
			0.150588,
			0.0941176,
			-0.498039,
			0.313725,
			0.200784,
			0.12549,
			-0.372549,
			0.392157,
			0.25098,
			0.156863,
			-0.247059,
			0.470588,
			0.301176,
			0.188235,
			-0.121569,
			0.54902,
			0.351373,
			0.219608,
			0.00392157,
			0.627451,
			0.401569,
			0.25098,
			0.129412,
			0.705882,
			0.451765,
			0.282353,
			0.254902,
			0.784314,
			0.501961,
			0.313725,
			0.380392,
			0.862745,
			0.552157,
			0.345098,
			0.505882,
			0.941176,
			0.602353,
			0.376471,
			0.631373,
			1,
			0.652549,
			0.407843,
			0.756863,
			1,
			0.702745,
			0.439216,
			0.882353,
			1,
			0.752941,
			0.470588,
			1,
			1,
			0.8,
			0.5
		]
	},
	{
		ColorSpace: "Lab",
		Name: "pink_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.312416,
			0.204524,
			0.204524,
			-0.74902,
			0.441822,
			0.289241,
			0.289241,
			-0.623529,
			0.54112,
			0.354246,
			0.354246,
			-0.498039,
			0.624831,
			0.409048,
			0.409048,
			-0.372549,
			0.698582,
			0.45733,
			0.45733,
			-0.247059,
			0.764404,
			0.502282,
			0.500979,
			-0.121569,
			0.791292,
			0.591516,
			0.54112,
			0.00392157,
			0.817297,
			0.66895,
			0.578481,
			0.129412,
			0.842499,
			0.738308,
			0.613572,
			0.254902,
			0.866968,
			0.801687,
			0.646762,
			0.380392,
			0.890766,
			0.86041,
			0.678329,
			0.505882,
			0.913944,
			0.913944,
			0.711254,
			0.631373,
			0.936549,
			0.936549,
			0.79459,
			0.756863,
			0.958621,
			0.958621,
			0.869979,
			0.882353,
			0.980196,
			0.980196,
			0.939336,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "bone_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.054902,
			0.054902,
			0.075817,
			-0.74902,
			0.109804,
			0.109804,
			0.151634,
			-0.623529,
			0.164706,
			0.164706,
			0.227451,
			-0.498039,
			0.219608,
			0.219608,
			0.303268,
			-0.372549,
			0.27451,
			0.27451,
			0.379085,
			-0.247059,
			0.329412,
			0.329902,
			0.454412,
			-0.121569,
			0.384314,
			0.405719,
			0.509314,
			0.00392157,
			0.439216,
			0.481536,
			0.564216,
			0.129412,
			0.494118,
			0.557353,
			0.619118,
			0.254902,
			0.54902,
			0.63317,
			0.67402,
			0.380392,
			0.603922,
			0.708987,
			0.728922,
			0.505882,
			0.660294,
			0.783824,
			0.783824,
			0.631373,
			0.746569,
			0.838725,
			0.838725,
			0.756863,
			0.832843,
			0.893627,
			0.893627,
			0.882353,
			0.919118,
			0.948529,
			0.948529,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "gray_Matlab",
		RGBPoints: [
			-1,
			0,
			0,
			0,
			-0.87451,
			0.0627451,
			0.0627451,
			0.0627451,
			-0.74902,
			0.12549,
			0.12549,
			0.12549,
			-0.623529,
			0.188235,
			0.188235,
			0.188235,
			-0.498039,
			0.25098,
			0.25098,
			0.25098,
			-0.372549,
			0.313725,
			0.313725,
			0.313725,
			-0.247059,
			0.376471,
			0.376471,
			0.376471,
			-0.121569,
			0.439216,
			0.439216,
			0.439216,
			0.00392157,
			0.501961,
			0.501961,
			0.501961,
			0.129412,
			0.564706,
			0.564706,
			0.564706,
			0.254902,
			0.627451,
			0.627451,
			0.627451,
			0.380392,
			0.690196,
			0.690196,
			0.690196,
			0.505882,
			0.752941,
			0.752941,
			0.752941,
			0.631373,
			0.815686,
			0.815686,
			0.815686,
			0.756863,
			0.878431,
			0.878431,
			0.878431,
			0.882353,
			0.941176,
			0.941176,
			0.941176,
			1,
			1,
			1,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Purples",
		RGBPoints: [
			-1,
			0.247059,
			0,
			0.490196,
			-0.87451,
			0.288397,
			0.07677,
			0.525629,
			-0.74902,
			0.32975,
			0.153587,
			0.561092,
			-0.623529,
			0.373057,
			0.236263,
			0.600461,
			-0.498039,
			0.416363,
			0.319,
			0.639923,
			-0.372549,
			0.459669,
			0.405613,
			0.685198,
			-0.247059,
			0.503345,
			0.491534,
			0.730058,
			-0.121569,
			0.562399,
			0.54862,
			0.757616,
			0.00392157,
			0.621453,
			0.606075,
			0.785544,
			0.129412,
			0.680508,
			0.674971,
			0.824914,
			0.254902,
			0.739562,
			0.743406,
			0.863899,
			0.380392,
			0.798616,
			0.800492,
			0.893426,
			0.505882,
			0.85684,
			0.856655,
			0.922491,
			0.631373,
			0.898178,
			0.894056,
			0.942176,
			0.756863,
			0.938654,
			0.930919,
			0.961646,
			0.882353,
			0.964245,
			0.958478,
			0.977393,
			1,
			0.988235,
			0.984314,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Blues",
		RGBPoints: [
			-1,
			0.031373,
			0.188235,
			0.419608,
			-0.87451,
			0.031373,
			0.253195,
			0.516063,
			-0.74902,
			0.031757,
			0.318139,
			0.612149,
			-0.623529,
			0.080969,
			0.38113,
			0.661361,
			-0.498039,
			0.130427,
			0.444152,
			0.710327,
			-0.372549,
			0.195386,
			0.509112,
			0.743791,
			-0.247059,
			0.260715,
			0.573841,
			0.777209,
			-0.121569,
			0.341423,
			0.628958,
			0.808704,
			0.00392157,
			0.422745,
			0.684075,
			0.839892,
			0.129412,
			0.523137,
			0.739193,
			0.861546,
			0.254902,
			0.622684,
			0.793464,
			0.883429,
			0.380392,
			0.701423,
			0.826928,
			0.910988,
			0.505882,
			0.778685,
			0.8603,
			0.937993,
			0.631373,
			0.825928,
			0.891795,
			0.953741,
			0.756863,
			0.87328,
			0.923291,
			0.969489,
			0.882353,
			0.922491,
			0.954787,
			0.985236,
			1,
			0.968627,
			0.984314,
			1
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Greens",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0,
			0.347374,
			0.139346,
			-0.74902,
			0.000538,
			0.427912,
			0.172933,
			-0.623529,
			0.069435,
			0.486967,
			0.222145,
			-0.498039,
			0.138178,
			0.546082,
			0.271326,
			-0.372549,
			0.197232,
			0.609073,
			0.31857,
			-0.247059,
			0.257255,
			0.671742,
			0.365859,
			-0.121569,
			0.357647,
			0.720953,
			0.415071,
			0.00392157,
			0.45767,
			0.769919,
			0.465021,
			0.129412,
			0.546251,
			0.811257,
			0.537855,
			0.254902,
			0.634295,
			0.852211,
			0.610688,
			0.380392,
			0.709097,
			0.883706,
			0.683522,
			0.505882,
			0.78316,
			0.914833,
			0.755894,
			0.631373,
			0.842215,
			0.938454,
			0.818885,
			0.756863,
			0.899977,
			0.961538,
			0.880692,
			0.882353,
			0.935409,
			0.975317,
			0.92203,
			1,
			0.968627,
			0.988235,
			0.960784
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuBu",
		RGBPoints: [
			-1,
			0.301961,
			0,
			0.294118,
			-0.87451,
			0.404321,
			0.029527,
			0.390573,
			-0.74902,
			0.50599,
			0.059592,
			0.486782,
			-0.623529,
			0.519769,
			0.158016,
			0.551742,
			-0.498039,
			0.533456,
			0.256194,
			0.616301,
			-0.372549,
			0.54133,
			0.33887,
			0.655671,
			-0.247059,
			0.54902,
			0.421592,
			0.695087,
			-0.121569,
			0.54902,
			0.506236,
			0.736424,
			0.00392157,
			0.550127,
			0.590573,
			0.777701,
			0.129412,
			0.585559,
			0.665375,
			0.81707,
			0.254902,
			0.622145,
			0.739023,
			0.855825,
			0.380392,
			0.687105,
			0.784298,
			0.879446,
			0.505882,
			0.752065,
			0.829758,
			0.903253,
			0.631373,
			0.817024,
			0.87897,
			0.930811,
			0.756863,
			0.880907,
			0.927213,
			0.957832,
			0.882353,
			0.926182,
			0.958708,
			0.975548,
			1,
			0.968627,
			0.988235,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuPu",
		RGBPoints: [
			-1,
			0.007843,
			0.219608,
			0.345098,
			-0.87451,
			0.01178,
			0.286536,
			0.449427,
			-0.74902,
			0.015702,
			0.35328,
			0.553479,
			-0.623529,
			0.01767,
			0.396586,
			0.622376,
			-0.498039,
			0.021115,
			0.4402,
			0.690688,
			-0.372549,
			0.11757,
			0.503191,
			0.722184,
			-0.247059,
			0.214625,
			0.565859,
			0.753633,
			-0.121569,
			0.336671,
			0.615071,
			0.78316,
			0.00392157,
			0.457978,
			0.663975,
			0.812503,
			0.129412,
			0.556401,
			0.703345,
			0.836125,
			0.254902,
			0.65421,
			0.742714,
			0.859669,
			0.380392,
			0.736886,
			0.782084,
			0.881323,
			0.505882,
			0.81827,
			0.821638,
			0.903068,
			0.631373,
			0.873387,
			0.864944,
			0.92669,
			0.756863,
			0.927536,
			0.907605,
			0.949988,
			0.882353,
			0.964937,
			0.9391,
			0.967705,
			1,
			1,
			0.968627,
			0.984314
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuGn",
		RGBPoints: [
			-1,
			0.031373,
			0.25098,
			0.505882,
			-0.87451,
			0.031373,
			0.329719,
			0.590527,
			-0.74902,
			0.031911,
			0.408397,
			0.674787,
			-0.623529,
			0.100807,
			0.479262,
			0.710219,
			-0.498039,
			0.169704,
			0.550219,
			0.745744,
			-0.372549,
			0.238601,
			0.62699,
			0.787082,
			-0.247059,
			0.307958,
			0.703114,
			0.826759,
			-0.121569,
			0.39654,
			0.752326,
			0.797232,
			0.00392157,
			0.485121,
			0.801046,
			0.767705,
			0.129412,
			0.573702,
			0.83451,
			0.738178,
			0.254902,
			0.661592,
			0.867743,
			0.711034,
			0.380392,
			0.732457,
			0.895302,
			0.74253,
			0.505882,
			0.801845,
			0.922307,
			0.774579,
			0.631373,
			0.841215,
			0.938055,
			0.817885,
			0.756863,
			0.880907,
			0.95391,
			0.861084,
			0.882353,
			0.926182,
			0.971626,
			0.902422,
			1,
			0.968627,
			0.988235,
			0.941176
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnBu",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0,
			0.347374,
			0.139346,
			-0.74902,
			0.000538,
			0.427912,
			0.172933,
			-0.623529,
			0.069435,
			0.486967,
			0.222145,
			-0.498039,
			0.138178,
			0.546175,
			0.272095,
			-0.372549,
			0.197232,
			0.615071,
			0.368551,
			-0.247059,
			0.256609,
			0.683276,
			0.464867,
			-0.121569,
			0.329443,
			0.722645,
			0.555417,
			0.00392157,
			0.403137,
			0.762138,
			0.645413,
			0.129412,
			0.503529,
			0.805444,
			0.718247,
			0.254902,
			0.603922,
			0.848597,
			0.790465,
			0.380392,
			0.704314,
			0.887966,
			0.847551,
			0.505882,
			0.802307,
			0.926321,
			0.903714,
			0.631373,
			0.851519,
			0.944037,
			0.941115,
			0.756863,
			0.899977,
			0.961538,
			0.976901,
			0.882353,
			0.935409,
			0.975317,
			0.984775,
			1,
			0.968627,
			0.988235,
			0.992157
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnBuPu",
		RGBPoints: [
			-1,
			0.003922,
			0.27451,
			0.211765,
			-0.87451,
			0.003922,
			0.349312,
			0.280661,
			-0.74902,
			0.003937,
			0.423852,
			0.349773,
			-0.623529,
			0.005905,
			0.46519,
			0.446228,
			-0.498039,
			0.009443,
			0.506344,
			0.542837,
			-0.372549,
			0.111803,
			0.535871,
			0.649135,
			-0.247059,
			0.214025,
			0.565859,
			0.753633,
			-0.121569,
			0.310481,
			0.615071,
			0.78316,
			0.00392157,
			0.407797,
			0.663975,
			0.812503,
			0.129412,
			0.531811,
			0.703345,
			0.836125,
			0.254902,
			0.65421,
			0.742714,
			0.859669,
			0.380392,
			0.736886,
			0.782084,
			0.881323,
			0.505882,
			0.81827,
			0.821176,
			0.902884,
			0.631373,
			0.873387,
			0.854641,
			0.922568,
			0.756863,
			0.927536,
			0.888535,
			0.942361,
			0.882353,
			0.964937,
			0.929873,
			0.964014,
			1,
			1,
			0.968627,
			0.984314
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuGnYl",
		RGBPoints: [
			-1,
			0.031373,
			0.113725,
			0.345098,
			-0.87451,
			0.088458,
			0.159,
			0.463206,
			-0.74902,
			0.145052,
			0.204567,
			0.5807,
			-0.623529,
			0.139146,
			0.287243,
			0.620069,
			-0.498039,
			0.13318,
			0.370196,
			0.659562,
			-0.372549,
			0.123337,
			0.470588,
			0.706805,
			-0.247059,
			0.115386,
			0.570335,
			0.753126,
			-0.121569,
			0.186251,
			0.643168,
			0.761,
			0.00392157,
			0.258716,
			0.71514,
			0.768074,
			0.129412,
			0.380761,
			0.760415,
			0.750358,
			0.254902,
			0.503576,
			0.806075,
			0.732795,
			0.380392,
			0.645306,
			0.861192,
			0.719016,
			0.505882,
			0.783899,
			0.91511,
			0.705606,
			0.631373,
			0.858701,
			0.944637,
			0.6997,
			0.756863,
			0.931349,
			0.973303,
			0.698424,
			0.882353,
			0.966782,
			0.987082,
			0.777163,
			1,
			1,
			1,
			0.85098
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuRd",
		RGBPoints: [
			-1,
			0.286275,
			0,
			0.415686,
			-0.87451,
			0.38273,
			0.001968,
			0.441276,
			-0.74902,
			0.479231,
			0.003922,
			0.466774,
			-0.623529,
			0.581592,
			0.003922,
			0.480554,
			-0.498039,
			0.683799,
			0.00549,
			0.494887,
			-0.372549,
			0.776317,
			0.105882,
			0.544098,
			-0.247059,
			0.867866,
			0.206321,
			0.592618,
			-0.121569,
			0.919047,
			0.308681,
			0.612303,
			0.00392157,
			0.968812,
			0.411226,
			0.632603,
			0.129412,
			0.974717,
			0.519493,
			0.671972,
			0.254902,
			0.980546,
			0.626451,
			0.71065,
			0.380392,
			0.984483,
			0.701253,
			0.732303,
			0.505882,
			0.988328,
			0.77504,
			0.755617,
			0.631373,
			0.990296,
			0.828189,
			0.812703,
			0.756863,
			0.992372,
			0.880907,
			0.869035,
			0.882353,
			0.996309,
			0.926182,
			0.912341,
			1,
			1,
			0.968627,
			0.952941
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdPu",
		RGBPoints: [
			-1,
			0.403922,
			0,
			0.121569,
			-0.87451,
			0.500377,
			0,
			0.192434,
			-0.74902,
			0.596909,
			0.000277,
			0.263037,
			-0.623529,
			0.703206,
			0.035709,
			0.300438,
			-0.498039,
			0.808612,
			0.071296,
			0.338854,
			-0.372549,
			0.857824,
			0.116571,
			0.441215,
			-0.247059,
			0.905513,
			0.163552,
			0.54293,
			-0.121569,
			0.889765,
			0.281661,
			0.617732,
			0.00392157,
			0.873156,
			0.39897,
			0.691611,
			0.129412,
			0.82985,
			0.491488,
			0.736886,
			0.254902,
			0.789081,
			0.583237,
			0.781853,
			0.380392,
			0.810734,
			0.656071,
			0.819254,
			0.505882,
			0.833126,
			0.729181,
			0.85684,
			0.631373,
			0.870527,
			0.80792,
			0.898178,
			0.756863,
			0.907605,
			0.884398,
			0.938331,
			0.882353,
			0.9391,
			0.921799,
			0.958016,
			1,
			0.968627,
			0.956863,
			0.976471
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Oranges",
		RGBPoints: [
			-1,
			0.498039,
			0.152941,
			0.015686,
			-0.87451,
			0.57481,
			0.182468,
			0.013718,
			-0.74902,
			0.651765,
			0.212042,
			0.011734,
			-0.623529,
			0.752157,
			0.247474,
			0.007797,
			-0.498039,
			0.851719,
			0.283368,
			0.004475,
			-0.372549,
			0.898962,
			0.348328,
			0.039908,
			-0.247059,
			0.945652,
			0.413426,
			0.076401,
			-0.121569,
			0.969273,
			0.484291,
			0.157109,
			0.00392157,
			0.992157,
			0.554971,
			0.238185,
			0.129412,
			0.992157,
			0.619931,
			0.330704,
			0.254902,
			0.992157,
			0.684967,
			0.423837,
			0.380392,
			0.992157,
			0.751895,
			0.532103,
			0.505882,
			0.992249,
			0.817716,
			0.639354,
			0.631373,
			0.994218,
			0.861023,
			0.725967,
			0.756863,
			0.996186,
			0.903576,
			0.810965,
			0.882353,
			0.998155,
			0.933103,
			0.868051,
			1,
			1,
			0.960784,
			0.921569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Reds",
		RGBPoints: [
			-1,
			0.403922,
			0,
			0.05098,
			-0.87451,
			0.525967,
			0.029527,
			0.066728,
			-0.74902,
			0.647643,
			0.058962,
			0.082476,
			-0.623529,
			0.722445,
			0.076678,
			0.098224,
			-0.498039,
			0.797186,
			0.095194,
			0.114187,
			-0.372549,
			0.868051,
			0.164091,
			0.143714,
			-0.247059,
			0.937809,
			0.233541,
			0.173933,
			-0.121569,
			0.96143,
			0.326059,
			0.232987,
			0.00392157,
			0.984375,
			0.418147,
			0.292657,
			0.129412,
			0.986344,
			0.496886,
			0.371396,
			0.254902,
			0.988235,
			0.575702,
			0.450673,
			0.380392,
			0.988235,
			0.656409,
			0.543191,
			0.505882,
			0.98842,
			0.736747,
			0.635894,
			0.631373,
			0.992357,
			0.809581,
			0.732349,
			0.756863,
			0.996186,
			0.880692,
			0.826759,
			0.882353,
			0.998155,
			0.92203,
			0.885813,
			1,
			1,
			0.960784,
			0.941176
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdOr",
		RGBPoints: [
			-1,
			0.498039,
			0,
			0,
			-0.87451,
			0.6004,
			0,
			0,
			-0.74902,
			0.702514,
			0.000738,
			0.000477,
			-0.623529,
			0.773379,
			0.095225,
			0.061499,
			-0.498039,
			0.843875,
			0.189865,
			0.12283,
			-0.372549,
			0.891119,
			0.294195,
			0.203537,
			-0.247059,
			0.937855,
			0.397924,
			0.283137,
			-0.121569,
			0.963445,
			0.476663,
			0.316601,
			0.00392157,
			0.988297,
			0.555771,
			0.351665,
			0.129412,
			0.990265,
			0.646321,
			0.436309,
			0.254902,
			0.992157,
			0.735256,
			0.519646,
			0.380392,
			0.992157,
			0.784468,
			0.570827,
			0.505882,
			0.992249,
			0.833218,
			0.623483,
			0.631373,
			0.994218,
			0.872587,
			0.706159,
			0.756863,
			0.996186,
			0.911419,
			0.788189,
			0.882353,
			0.998155,
			0.940946,
			0.859054,
			1,
			1,
			0.968627,
			0.92549
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BrOrYl",
		RGBPoints: [
			-1,
			0.4,
			0.145098,
			0.023529,
			-0.87451,
			0.500392,
			0.174625,
			0.019592,
			-0.74902,
			0.600784,
			0.204291,
			0.015656,
			-0.623529,
			0.701176,
			0.251534,
			0.011719,
			-0.498039,
			0.800984,
			0.299146,
			0.008397,
			-0.372549,
			0.863975,
			0.370012,
			0.043829,
			-0.247059,
			0.926321,
			0.441107,
			0.0794,
			-0.121569,
			0.961753,
			0.521815,
			0.120738,
			0.00392157,
			0.996078,
			0.602645,
			0.163122,
			0.129412,
			0.996078,
			0.68729,
			0.237924,
			0.254902,
			0.996078,
			0.771011,
			0.314879,
			0.380392,
			0.996078,
			0.832034,
			0.444798,
			0.505882,
			0.996171,
			0.892042,
			0.572595,
			0.631373,
			0.998139,
			0.931411,
			0.65724,
			0.756863,
			1,
			0.969489,
			0.741669,
			0.882353,
			1,
			0.985236,
			0.822376,
			1,
			1,
			1,
			0.898039
		]
	},
	{
		ColorSpace: "Lab",
		Name: "RdOrYl",
		RGBPoints: [
			-1,
			0.501961,
			0,
			0.14902,
			-0.87451,
			0.622038,
			0,
			0.14902,
			-0.74902,
			0.741761,
			0.0004,
			0.148866,
			-0.623529,
			0.816563,
			0.05158,
			0.129181,
			-0.498039,
			0.890965,
			0.10356,
			0.110235,
			-0.372549,
			0.940177,
			0.205921,
			0.137793,
			-0.247059,
			0.988281,
			0.308789,
			0.165536,
			-0.121569,
			0.99025,
			0.432803,
			0.200969,
			0.00392157,
			0.992218,
			0.555217,
			0.236278,
			0.129412,
			0.994187,
			0.628051,
			0.267774,
			0.254902,
			0.996078,
			0.701038,
			0.301269,
			0.380392,
			0.996078,
			0.777809,
			0.383945,
			0.505882,
			0.996171,
			0.852826,
			0.466621,
			0.631373,
			0.998139,
			0.892195,
			0.549296,
			0.756863,
			1,
			0.931349,
			0.632188,
			0.882353,
			1,
			0.966782,
			0.7188,
			1,
			1,
			1,
			0.8
		]
	},
	{
		ColorSpace: "Lab",
		Name: "CIELab_blue2red",
		RGBPoints: [
			-1,
			0,
			0.6,
			0.74902,
			1,
			0.76863,
			0.46667,
			0.34118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "blue2yellow",
		RGBPoints: [
			-1,
			0,
			0,
			1,
			0,
			0.5,
			0.5,
			0.5,
			1,
			1,
			1,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2gold",
		RGBPoints: [
			-1,
			0.175119,
			0.0438468,
			1,
			-0.874016,
			0.22383,
			0.159771,
			0.94557,
			-0.748031,
			0.27254,
			0.233611,
			0.891216,
			-0.622047,
			0.321251,
			0.296526,
			0.836857,
			-0.496063,
			0.369962,
			0.354296,
			0.782359,
			-0.370079,
			0.418672,
			0.409139,
			0.72754,
			-0.244094,
			0.467383,
			0.462152,
			0.672148,
			-0.11811,
			0.51609,
			0.51396,
			0.615825,
			0.00787402,
			0.572863,
			0.55452,
			0.559172,
			0.133858,
			0.630269,
			0.593822,
			0.517729,
			0.259843,
			0.689588,
			0.624668,
			0.47446,
			0.385827,
			0.745394,
			0.656113,
			0.428638,
			0.511811,
			0.798624,
			0.688104,
			0.379105,
			0.637795,
			0.849926,
			0.720593,
			0.323834,
			0.76378,
			0.899765,
			0.753543,
			0.258657,
			0.889764,
			0.948487,
			0.78692,
			0.171778,
			1,
			0.990413,
			0.816451,
			0.00729848
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_blue2yellow",
		RGBPoints: [
			-1,
			0.0830122,
			0,
			0.495617,
			-0.87451,
			0.141973,
			0.0551288,
			0.57363,
			-0.74902,
			0.193048,
			0.110258,
			0.604561,
			-0.623529,
			0.234231,
			0.165386,
			0.57643,
			-0.498039,
			0.275413,
			0.220515,
			0.548299,
			-0.372549,
			0.316596,
			0.275644,
			0.520169,
			-0.247059,
			0.357778,
			0.330773,
			0.492038,
			-0.121569,
			0.398961,
			0.385901,
			0.463908,
			0.00392157,
			0.449929,
			0.438487,
			0.426815,
			0.129412,
			0.511572,
			0.488299,
			0.379944,
			0.254902,
			0.581222,
			0.53603,
			0.325741,
			0.380392,
			0.650871,
			0.583761,
			0.271538,
			0.505882,
			0.720521,
			0.631493,
			0.217335,
			0.631373,
			0.79017,
			0.679224,
			0.163132,
			0.756863,
			0.85982,
			0.726955,
			0.108929,
			0.882353,
			0.910254,
			0.774159,
			0.14112,
			1,
			0.927513,
			0.81759,
			0.306289
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_cyan2orange",
		RGBPoints: [
			-1,
			0.0471513,
			0.213874,
			0.414329,
			-0.87451,
			0.0674702,
			0.256648,
			0.439027,
			-0.74902,
			0.0959957,
			0.299331,
			0.462089,
			-0.623529,
			0.132428,
			0.341872,
			0.483212,
			-0.498039,
			0.188743,
			0.38277,
			0.500597,
			-0.372549,
			0.268511,
			0.420229,
			0.512179,
			-0.247059,
			0.352945,
			0.455602,
			0.519101,
			-0.121569,
			0.43893,
			0.489368,
			0.521538,
			0.00392157,
			0.522445,
			0.522495,
			0.522436,
			0.129412,
			0.600089,
			0.555682,
			0.53205,
			0.254902,
			0.67988,
			0.587981,
			0.539163,
			0.380392,
			0.761011,
			0.619586,
			0.544439,
			0.505882,
			0.84278,
			0.650741,
			0.548567,
			0.631373,
			0.910713,
			0.687347,
			0.557822,
			0.756863,
			0.952232,
			0.734972,
			0.577775,
			0.882353,
			0.975642,
			0.789858,
			0.604868,
			1,
			0.990752,
			0.843643,
			0.632857
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2green",
		RGBPoints: [
			-1,
			0.235006,
			0.0483128,
			0.530899,
			-0.87451,
			0.302968,
			0.108419,
			0.552391,
			-0.74902,
			0.360241,
			0.166059,
			0.569502,
			-0.623529,
			0.406746,
			0.226782,
			0.579373,
			-0.498039,
			0.444073,
			0.28964,
			0.582094,
			-0.372549,
			0.473648,
			0.353774,
			0.577947,
			-0.247059,
			0.497636,
			0.418154,
			0.567911,
			-0.121569,
			0.519086,
			0.481741,
			0.553968,
			0.00392157,
			0.542884,
			0.542914,
			0.542875,
			0.129412,
			0.566303,
			0.603989,
			0.527499,
			0.254902,
			0.595218,
			0.662965,
			0.516857,
			0.380392,
			0.628641,
			0.720701,
			0.510673,
			0.505882,
			0.665373,
			0.777849,
			0.508165,
			0.631373,
			0.704182,
			0.834921,
			0.508303,
			0.756863,
			0.743846,
			0.892328,
			0.50999,
			0.882353,
			0.783158,
			0.950422,
			0.512181,
			1,
			0.818617,
			1,
			0.513888
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_purple2green_dark",
		RGBPoints: [
			-1,
			0.107656,
			0,
			0.428682,
			-0.87451,
			0.1924,
			0,
			0.449799,
			-0.74902,
			0.255118,
			0.0648939,
			0.466726,
			-0.623529,
			0.304256,
			0.133066,
			0.476703,
			-0.498039,
			0.343202,
			0.19716,
			0.479793,
			-0.372549,
			0.373876,
			0.260353,
			0.476241,
			-0.247059,
			0.398497,
			0.322872,
			0.466953,
			-0.121569,
			0.420016,
			0.384252,
			0.453785,
			0.00392157,
			0.44319,
			0.443216,
			0.443186,
			0.129412,
			0.465553,
			0.502139,
			0.428233,
			0.254902,
			0.492959,
			0.559151,
			0.417591,
			0.380392,
			0.524654,
			0.615092,
			0.411016,
			0.505882,
			0.55959,
			0.670583,
			0.40779,
			0.631373,
			0.596614,
			0.726102,
			0.406948,
			0.756863,
			0.634544,
			0.782032,
			0.407439,
			0.882353,
			0.672183,
			0.838703,
			0.408237,
			1,
			0.706131,
			0.892759,
			0.408452
		]
	},
	{
		ColorSpace: "Lab",
		Name: "coolwarm",
		RGBPoints: [
			-1,
			0.229806,
			0.298718,
			0.753683,
			-0.875,
			0.303869,
			0.406535,
			0.844959,
			-0.75,
			0.383013,
			0.509419,
			0.917388,
			-0.625,
			0.466667,
			0.604563,
			0.968155,
			-0.5,
			0.552953,
			0.688929,
			0.995376,
			-0.375,
			0.639176,
			0.7596,
			0.998151,
			-0.25,
			0.722193,
			0.813953,
			0.976575,
			-0.125,
			0.798692,
			0.849786,
			0.931689,
			0,
			0.865395,
			0.86541,
			0.865396,
			0.125,
			0.924128,
			0.827385,
			0.774508,
			0.25,
			0.958853,
			0.769768,
			0.678008,
			0.375,
			0.969954,
			0.694267,
			0.579375,
			0.5,
			0.958003,
			0.602842,
			0.481776,
			0.625,
			0.923945,
			0.497309,
			0.38797,
			0.75,
			0.869187,
			0.378313,
			0.300267,
			0.875,
			0.795632,
			0.241284,
			0.220526,
			1,
			0.705673,
			0.0155562,
			0.150233
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BuRd",
		RGBPoints: [
			-1,
			0.019608,
			0.188235,
			0.380392,
			-0.87451,
			0.088504,
			0.321107,
			0.564937,
			-0.74902,
			0.163399,
			0.444983,
			0.697501,
			-0.623529,
			0.247059,
			0.555709,
			0.754095,
			-0.498039,
			0.420684,
			0.676432,
			0.818685,
			-0.372549,
			0.606459,
			0.789773,
			0.880277,
			-0.247059,
			0.761476,
			0.868512,
			0.924567,
			-0.121569,
			0.878047,
			0.925721,
			0.951942,
			0.00392157,
			0.969089,
			0.966474,
			0.964937,
			0.129412,
			0.983852,
			0.897578,
			0.846828,
			0.254902,
			0.982468,
			0.800692,
			0.706113,
			0.380392,
			0.960323,
			0.66782,
			0.536332,
			0.505882,
			0.894579,
			0.503806,
			0.399769,
			0.631373,
			0.81707,
			0.33218,
			0.281046,
			0.756863,
			0.728489,
			0.155017,
			0.197386,
			0.882353,
			0.576932,
			0.055363,
			0.14925,
			1,
			0.403922,
			0,
			0.121569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Spectral_lowBlue",
		RGBPoints: [
			-1,
			0.368627,
			0.309804,
			0.635294,
			-0.87451,
			0.260361,
			0.450058,
			0.70173,
			-0.74902,
			0.248058,
			0.591311,
			0.717186,
			-0.623529,
			0.376009,
			0.734025,
			0.658132,
			-0.498039,
			0.537947,
			0.814764,
			0.64506,
			-0.372549,
			0.702345,
			0.879585,
			0.636678,
			-0.247059,
			0.84752,
			0.938639,
			0.607151,
			-0.121569,
			0.940408,
			0.976163,
			0.656055,
			0.00392157,
			0.999923,
			0.997616,
			0.745021,
			0.129412,
			0.997463,
			0.921338,
			0.61707,
			0.254902,
			0.995002,
			0.824606,
			0.499885,
			0.380392,
			0.992541,
			0.701576,
			0.39654,
			0.505882,
			0.973472,
			0.547405,
			0.318108,
			0.631373,
			0.937793,
			0.398539,
			0.270127,
			0.756863,
			0.861515,
			0.282891,
			0.299654,
			0.882353,
			0.746482,
			0.144637,
			0.288812,
			1,
			0.619608,
			0.003922,
			0.258824
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnRP",
		RGBPoints: [
			-1,
			0,
			0.266667,
			0.105882,
			-0.87451,
			0.066436,
			0.394617,
			0.174779,
			-0.74902,
			0.168858,
			0.524567,
			0.25767,
			-0.623529,
			0.323875,
			0.657439,
			0.361015,
			-0.498039,
			0.504883,
			0.772318,
			0.506344,
			-0.372549,
			0.678431,
			0.870127,
			0.654902,
			-0.247059,
			0.803922,
			0.921799,
			0.780392,
			-0.121569,
			0.897116,
			0.951942,
			0.882814,
			0.00392157,
			0.967397,
			0.965936,
			0.967474,
			0.129412,
			0.928028,
			0.879815,
			0.930565,
			0.254902,
			0.866052,
			0.780777,
			0.882891,
			0.380392,
			0.77501,
			0.665129,
			0.821376,
			0.505882,
			0.675663,
			0.537024,
			0.737024,
			0.631373,
			0.57847,
			0.396155,
			0.645982,
			0.756863,
			0.492349,
			0.223914,
			0.547559,
			0.882353,
			0.375548,
			0.096886,
			0.423299,
			1,
			0.25098,
			0,
			0.294118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GYPi",
		RGBPoints: [
			-1,
			0.152941,
			0.392157,
			0.098039,
			-0.87451,
			0.246444,
			0.505344,
			0.117724,
			-0.74902,
			0.351942,
			0.614533,
			0.161399,
			-0.623529,
			0.474971,
			0.717878,
			0.240138,
			-0.498039,
			0.611995,
			0.811226,
			0.392849,
			-0.372549,
			0.746328,
			0.893118,
			0.565321,
			-0.247059,
			0.859516,
			0.94233,
			0.747405,
			-0.121569,
			0.928105,
			0.96386,
			0.875663,
			0.00392157,
			0.969089,
			0.966859,
			0.968012,
			0.129412,
			0.983852,
			0.910265,
			0.948328,
			0.254902,
			0.979239,
			0.833218,
			0.914648,
			0.380392,
			0.949712,
			0.729873,
			0.862976,
			0.505882,
			0.905652,
			0.58293,
			0.763552,
			0.631373,
			0.85521,
			0.410073,
			0.652211,
			0.756863,
			0.793695,
			0.183699,
			0.531642,
			0.882353,
			0.683737,
			0.063899,
			0.420761,
			1,
			0.556863,
			0.003922,
			0.321569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GnYlRd",
		RGBPoints: [
			-1,
			0,
			0.407843,
			0.215686,
			-0.87451,
			0.063975,
			0.525952,
			0.277201,
			-0.74902,
			0.177932,
			0.633064,
			0.332718,
			-0.623529,
			0.364937,
			0.724106,
			0.379469,
			-0.498039,
			0.527951,
			0.797155,
			0.40223,
			-0.372549,
			0.678431,
			0.862822,
			0.433449,
			-0.247059,
			0.803922,
			0.916955,
			0.514648,
			-0.121569,
			0.909419,
			0.961861,
			0.625067,
			0.00392157,
			0.999923,
			0.997616,
			0.745021,
			0.129412,
			0.997463,
			0.921338,
			0.61707,
			0.254902,
			0.995002,
			0.824606,
			0.499885,
			0.380392,
			0.992541,
			0.701576,
			0.39654,
			0.505882,
			0.973472,
			0.547405,
			0.318108,
			0.631373,
			0.939023,
			0.389927,
			0.245521,
			0.756863,
			0.867666,
			0.239831,
			0.176624,
			0.882353,
			0.762399,
			0.110727,
			0.151326,
			1,
			0.647059,
			0,
			0.14902
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GBBr",
		RGBPoints: [
			-1,
			0,
			0.235294,
			0.188235,
			-0.87451,
			0.002461,
			0.338639,
			0.301423,
			-0.74902,
			0.055902,
			0.448981,
			0.417609,
			-0.623529,
			0.183852,
			0.56955,
			0.538178,
			-0.498039,
			0.357785,
			0.700115,
			0.660746,
			-0.372549,
			0.540177,
			0.819531,
			0.77624,
			-0.247059,
			0.714879,
			0.890888,
			0.864821,
			-0.121569,
			0.851134,
			0.934564,
			0.922645,
			0.00392157,
			0.960861,
			0.959785,
			0.95694,
			0.129412,
			0.963322,
			0.927797,
			0.83391,
			0.254902,
			0.939946,
			0.868897,
			0.68935,
			0.380392,
			0.883353,
			0.775394,
			0.517109,
			0.505882,
			0.808074,
			0.625836,
			0.324106,
			0.631373,
			0.717647,
			0.476355,
			0.15494,
			0.756863,
			0.592157,
			0.358247,
			0.06882,
			0.882353,
			0.458593,
			0.26436,
			0.031142,
			1,
			0.329412,
			0.188235,
			0.019608
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PuOr",
		RGBPoints: [
			-1,
			0.498039,
			0.231373,
			0.031373,
			-0.87451,
			0.62599,
			0.30273,
			0.026451,
			-0.74902,
			0.746943,
			0.387082,
			0.037524,
			-0.623529,
			0.85767,
			0.490427,
			0.071972,
			-0.498039,
			0.936409,
			0.617762,
			0.236371,
			-0.372549,
			0.992695,
			0.743099,
			0.43291,
			-0.247059,
			0.995156,
			0.841523,
			0.63714,
			-0.121569,
			0.985313,
			0.913802,
			0.813687,
			0.00392157,
			0.966244,
			0.966398,
			0.967705,
			0.129412,
			0.889965,
			0.89504,
			0.938178,
			0.254902,
			0.806151,
			0.804306,
			0.894656,
			0.380392,
			0.712649,
			0.688658,
			0.833141,
			0.505882,
			0.594233,
			0.554325,
			0.744637,
			0.631373,
			0.474894,
			0.404229,
			0.652364,
			0.756863,
			0.366628,
			0.217224,
			0.563783,
			0.882353,
			0.266436,
			0.089965,
			0.434833,
			1,
			0.176471,
			0,
			0.294118
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PRGn",
		RGBPoints: [
			-1,
			0.25098,
			0,
			0.294118,
			-0.87451,
			0.383852,
			0.103345,
			0.431911,
			-0.74902,
			0.497732,
			0.234679,
			0.55371,
			-0.623529,
			0.583852,
			0.40692,
			0.652134,
			-0.498039,
			0.681968,
			0.545175,
			0.742561,
			-0.372549,
			0.7807,
			0.672357,
			0.825221,
			-0.247059,
			0.871742,
			0.788005,
			0.886736,
			-0.121569,
			0.930488,
			0.885198,
			0.932872,
			0.00392157,
			0.966321,
			0.968089,
			0.965859,
			0.129412,
			0.892503,
			0.950865,
			0.877278,
			0.254902,
			0.796078,
			0.91857,
			0.772549,
			0.380392,
			0.670588,
			0.866897,
			0.647059,
			0.505882,
			0.493195,
			0.765398,
			0.496655,
			0.631373,
			0.314187,
			0.649135,
			0.354556,
			0.756863,
			0.15917,
			0.516263,
			0.251211,
			0.882353,
			0.062284,
			0.386621,
			0.170473,
			1,
			0,
			0.266667,
			0.105882
		]
	},
	{
		ColorSpace: "Lab",
		Name: "PiYG",
		RGBPoints: [
			-1,
			0.556863,
			0.003922,
			0.321569,
			-0.87451,
			0.692195,
			0.067897,
			0.427374,
			-0.74902,
			0.797539,
			0.197847,
			0.539177,
			-0.623529,
			0.859054,
			0.424221,
			0.659746,
			-0.498039,
			0.908574,
			0.592618,
			0.770319,
			-0.372549,
			0.951557,
			0.736332,
			0.866205,
			-0.247059,
			0.981084,
			0.839677,
			0.917878,
			-0.121569,
			0.98293,
			0.913802,
			0.949558,
			0.00392157,
			0.96732,
			0.968474,
			0.965629,
			0.129412,
			0.92549,
			0.963552,
			0.869666,
			0.254902,
			0.852441,
			0.939254,
			0.736025,
			0.380392,
			0.739254,
			0.890042,
			0.553941,
			0.505882,
			0.60323,
			0.805536,
			0.382238,
			0.631373,
			0.467282,
			0.711419,
			0.235217,
			0.756863,
			0.344252,
			0.608074,
			0.156478,
			0.882353,
			0.2406,
			0.49827,
			0.116494,
			1,
			0.152941,
			0.392157,
			0.098039
		]
	},
	{
		ColorSpace: "Lab",
		Name: "OrPu",
		RGBPoints: [
			-1,
			0.176471,
			0,
			0.294118,
			-0.87451,
			0.272434,
			0.095963,
			0.444214,
			-0.74902,
			0.373395,
			0.228912,
			0.56932,
			-0.623529,
			0.481661,
			0.415917,
			0.657901,
			-0.498039,
			0.601922,
			0.562937,
			0.750481,
			-0.372549,
			0.718493,
			0.695886,
			0.836986,
			-0.247059,
			0.811995,
			0.811534,
			0.898501,
			-0.121569,
			0.894733,
			0.8995,
			0.940023,
			0.00392157,
			0.969166,
			0.966859,
			0.963629,
			0.129412,
			0.98639,
			0.910265,
			0.803691,
			0.254902,
			0.995002,
			0.835371,
			0.624375,
			0.380392,
			0.992541,
			0.736947,
			0.420146,
			0.505882,
			0.931949,
			0.609458,
			0.224221,
			0.631373,
			0.85075,
			0.483968,
			0.069819,
			0.756863,
			0.740023,
			0.380623,
			0.035371,
			0.882353,
			0.617993,
			0.29827,
			0.026759,
			1,
			0.498039,
			0.231373,
			0.031373
		]
	},
	{
		ColorSpace: "Lab",
		Name: "BrBG",
		RGBPoints: [
			-1,
			0.329412,
			0.188235,
			0.019608,
			-0.87451,
			0.467205,
			0.269435,
			0.031911,
			-0.74902,
			0.6,
			0.365629,
			0.074202,
			-0.623529,
			0.72549,
			0.483737,
			0.160323,
			-0.498039,
			0.812995,
			0.635832,
			0.336409,
			-0.372549,
			0.88689,
			0.781238,
			0.527874,
			-0.247059,
			0.943483,
			0.87474,
			0.700115,
			-0.121569,
			0.963168,
			0.929796,
			0.841599,
			0.00392157,
			0.957247,
			0.959938,
			0.959554,
			0.129412,
			0.84406,
			0.932872,
			0.920185,
			0.254902,
			0.70396,
			0.886428,
			0.859285,
			0.380392,
			0.529258,
			0.815071,
			0.770704,
			0.505882,
			0.346251,
			0.691811,
			0.653057,
			0.631373,
			0.175855,
			0.562015,
			0.530642,
			0.756863,
			0.047905,
			0.441446,
			0.410073,
			0.882353,
			0.002307,
			0.33218,
			0.294348,
			1,
			0,
			0.235294,
			0.188235
		]
	},
	{
		ColorSpace: "Lab",
		Name: "GyRd",
		RGBPoints: [
			-1,
			0.101961,
			0.101961,
			0.101961,
			-0.87451,
			0.227451,
			0.227451,
			0.227451,
			-0.74902,
			0.359939,
			0.359939,
			0.359939,
			-0.623529,
			0.502653,
			0.502653,
			0.502653,
			-0.498039,
			0.631373,
			0.631373,
			0.631373,
			-0.372549,
			0.749865,
			0.749865,
			0.749865,
			-0.247059,
			0.843368,
			0.843368,
			0.843368,
			-0.121569,
			0.926105,
			0.926105,
			0.926105,
			0.00392157,
			0.999846,
			0.997232,
			0.995694,
			0.129412,
			0.994925,
			0.908651,
			0.857901,
			0.254902,
			0.982468,
			0.800692,
			0.706113,
			0.380392,
			0.960323,
			0.66782,
			0.536332,
			0.505882,
			0.894579,
			0.503806,
			0.399769,
			0.631373,
			0.81707,
			0.33218,
			0.281046,
			0.756863,
			0.728489,
			0.155017,
			0.197386,
			0.882353,
			0.576932,
			0.055363,
			0.14925,
			1,
			0.403922,
			0,
			0.121569
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divHi_purpleGreen",
		RGBPoints: [
			-1,
			0.297553,
			0,
			0.489074,
			-0.87451,
			0.40259,
			0.151146,
			0.567754,
			-0.74902,
			0.516038,
			0.284843,
			0.658231,
			-0.623529,
			0.629783,
			0.423646,
			0.750938,
			-0.498039,
			0.735198,
			0.563697,
			0.835956,
			-0.372549,
			0.82408,
			0.695541,
			0.903582,
			-0.247059,
			0.889091,
			0.807454,
			0.944862,
			-0.121569,
			0.92334,
			0.886917,
			0.951839,
			0.00392157,
			0.921045,
			0.921084,
			0.921003,
			0.129412,
			0.877324,
			0.907455,
			0.845381,
			0.254902,
			0.797649,
			0.849713,
			0.734695,
			0.380392,
			0.691646,
			0.75964,
			0.600532,
			0.505882,
			0.568981,
			0.649159,
			0.453807,
			0.631373,
			0.438945,
			0.529756,
			0.304259,
			0.756863,
			0.30973,
			0.412001,
			0.158303,
			0.882353,
			0.187078,
			0.305111,
			0.00251458,
			1,
			0.101655,
			0.220836,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divHi_purpleGreen_dim",
		RGBPoints: [
			-1,
			0.404088,
			0.131038,
			0.592767,
			-0.87451,
			0.486469,
			0.230957,
			0.651243,
			-0.74902,
			0.575165,
			0.339335,
			0.717723,
			-0.623529,
			0.662741,
			0.454332,
			0.784263,
			-0.498039,
			0.742071,
			0.570213,
			0.842918,
			-0.372549,
			0.806935,
			0.678992,
			0.886227,
			-0.247059,
			0.852219,
			0.771315,
			0.90763,
			-0.121569,
			0.873345,
			0.837327,
			0.901572,
			0.00392157,
			0.866783,
			0.86682,
			0.866745,
			0.129412,
			0.82839,
			0.858225,
			0.796812,
			0.254902,
			0.762578,
			0.814287,
			0.700202,
			0.380392,
			0.676429,
			0.744229,
			0.585735,
			0.505882,
			0.577033,
			0.65732,
			0.461526,
			0.631373,
			0.47128,
			0.562476,
			0.33476,
			0.756863,
			0.365461,
			0.467957,
			0.21076,
			0.882353,
			0.264758,
			0.381138,
			0.0878313,
			1,
			0.182591,
			0.312249,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divLow_icePeach",
		RGBPoints: [
			-1,
			0.480048,
			0.817441,
			0.998056,
			-0.87451,
			0.425898,
			0.726921,
			0.883187,
			-0.74902,
			0.366682,
			0.629445,
			0.761936,
			-0.623529,
			0.308756,
			0.531002,
			0.640217,
			-0.498039,
			0.258021,
			0.43705,
			0.523433,
			-0.372549,
			0.219244,
			0.352381,
			0.416348,
			-0.247059,
			0.195127,
			0.281032,
			0.322979,
			-0.121569,
			0.186286,
			0.22627,
			0.246525,
			0.00392157,
			0.192352,
			0.19236,
			0.192364,
			0.129412,
			0.255927,
			0.214469,
			0.191756,
			0.254902,
			0.340459,
			0.254426,
			0.206666,
			0.380392,
			0.444655,
			0.309315,
			0.234029,
			0.505882,
			0.565353,
			0.376004,
			0.270969,
			0.631373,
			0.697917,
			0.450748,
			0.314293,
			0.756863,
			0.836657,
			0.529064,
			0.360227,
			0.882353,
			0.972695,
			0.614884,
			0.413123,
			1,
			1,
			0.705904,
			0.472699
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_divLow_purpleGreen",
		RGBPoints: [
			-1,
			0.956034,
			0.666487,
			0.952663,
			-0.87451,
			0.874457,
			0.572698,
			0.936352,
			-0.74902,
			0.753465,
			0.488253,
			0.909063,
			-0.623529,
			0.63309,
			0.413507,
			0.763833,
			-0.498039,
			0.514491,
			0.345878,
			0.620015,
			-0.372549,
			0.405008,
			0.288141,
			0.484376,
			-0.247059,
			0.311388,
			0.241986,
			0.363556,
			-0.121569,
			0.238722,
			0.209044,
			0.263449,
			0.00392157,
			0.192352,
			0.192366,
			0.192362,
			0.129412,
			0.200379,
			0.233201,
			0.168618,
			0.254902,
			0.230151,
			0.291737,
			0.165227,
			0.380392,
			0.279481,
			0.366076,
			0.178607,
			0.505882,
			0.344927,
			0.453267,
			0.205703,
			0.631373,
			0.421554,
			0.549449,
			0.242643,
			0.756863,
			0.503334,
			0.649999,
			0.284377,
			0.882353,
			0.583497,
			0.749672,
			0.324969,
			1,
			0.650705,
			0.837228,
			0.356264
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_green",
		RGBPoints: [
			-1,
			1,
			0.835294,
			0.886275,
			-0.87451,
			0.937255,
			0.756863,
			0.870443,
			-0.74902,
			0.875817,
			0.666376,
			0.857807,
			-0.623529,
			0.778359,
			0.583007,
			0.808134,
			-0.498039,
			0.676253,
			0.494118,
			0.745098,
			-0.372549,
			0.561365,
			0.390123,
			0.682353,
			-0.247059,
			0.438344,
			0.262745,
			0.621496,
			-0.121569,
			0.321133,
			0.141031,
			0.558751,
			0.00392157,
			0.203922,
			0.0217865,
			0.495861,
			0.129412,
			0.265505,
			0.129412,
			0.433261,
			0.254902,
			0.311692,
			0.255338,
			0.37008,
			0.380392,
			0.356282,
			0.377342,
			0.310821,
			0.505882,
			0.39971,
			0.488889,
			0.258243,
			0.631373,
			0.442556,
			0.604357,
			0.205519,
			0.756863,
			0.48671,
			0.71968,
			0.152941,
			0.882353,
			0.529847,
			0.830356,
			0.100944,
			1,
			0.572549,
			0.933333,
			0.054902
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_lime",
		RGBPoints: [
			-1,
			0.704034,
			0.784196,
			1,
			-0.87451,
			0.633111,
			0.691418,
			0.956078,
			-0.74902,
			0.564021,
			0.600606,
			0.912157,
			-0.623529,
			0.496827,
			0.51189,
			0.868235,
			-0.498039,
			0.43157,
			0.425416,
			0.824314,
			-0.372549,
			0.368248,
			0.341347,
			0.780392,
			-0.247059,
			0.306767,
			0.259855,
			0.736471,
			-0.121569,
			0.246862,
			0.181069,
			0.692549,
			0.00392157,
			0.191619,
			0.109542,
			0.648627,
			0.129412,
			0.257404,
			0.194031,
			0.604706,
			0.254902,
			0.321794,
			0.278775,
			0.560784,
			0.380392,
			0.387909,
			0.364617,
			0.516863,
			0.505882,
			0.456569,
			0.451881,
			0.472941,
			0.631373,
			0.527424,
			0.540773,
			0.42902,
			0.756863,
			0.599759,
			0.631427,
			0.385098,
			0.882353,
			0.673065,
			0.723898,
			0.341176,
			1,
			0.742751,
			0.812252,
			0.3
		]
	},
	{
		ColorSpace: "RGB",
		Name: "Haze",
		RGBPoints: [
			-1,
			1,
			0.835294,
			0.996078,
			-0.00392157,
			0.023529,
			0.141176,
			0.498039,
			0.00392157,
			0.015686,
			0.137255,
			0.494118,
			1,
			0.984314,
			0.764706,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "Haze_cyan",
		RGBPoints: [
			-1,
			0.956863,
			1,
			0.835294,
			-0.87451,
			0.933188,
			0.921714,
			0.760784,
			-0.74902,
			0.870588,
			0.803486,
			0.671605,
			-0.623529,
			0.807843,
			0.684096,
			0.583297,
			-0.498039,
			0.745098,
			0.569208,
			0.494118,
			-0.372549,
			0.682353,
			0.437763,
			0.390123,
			-0.247059,
			0.621496,
			0.288163,
			0.262745,
			-0.121569,
			0.558751,
			0.144517,
			0.141031,
			0.00392157,
			0.495861,
			0.0217865,
			0.0413943,
			0.129412,
			0.433261,
			0.137255,
			0.129412,
			0.254902,
			0.37008,
			0.263181,
			0.255338,
			0.380392,
			0.306318,
			0.381845,
			0.372694,
			0.505882,
			0.243137,
			0.503994,
			0.494263,
			0.631373,
			0.180392,
			0.629484,
			0.619753,
			0.756863,
			0.117647,
			0.754975,
			0.747131,
			0.882353,
			0.054902,
			0.876398,
			0.866812,
			1,
			0,
			0.988235,
			0.976471
		]
	},
	{
		ColorSpace: "Lab",
		Name: "nic_Edge",
		RGBPoints: [
			-1,
			0.191208,
			0.191208,
			0.191208,
			-0.87451,
			0.239484,
			0.00545035,
			0.614821,
			-0.74902,
			0.220593,
			0.0617459,
			0.863547,
			-0.623529,
			0.17509,
			0.278988,
			0.97794,
			-0.498039,
			0.143526,
			0.576069,
			0.998553,
			-0.372549,
			0.166456,
			0.871883,
			0.96594,
			-0.247059,
			0.376202,
			0.993555,
			0.981833,
			-0.121569,
			0.681996,
			0.991297,
			0.999239,
			0.00392157,
			0.954172,
			0.952734,
			0.94374,
			0.129412,
			0.999735,
			0.99301,
			0.662896,
			0.254902,
			0.979399,
			0.991466,
			0.357973,
			0.380392,
			0.968771,
			0.854967,
			0.162659,
			0.505882,
			0.999245,
			0.556697,
			0.144323,
			0.631373,
			0.973959,
			0.26223,
			0.177946,
			0.756863,
			0.852358,
			0.0526707,
			0.222974,
			0.882353,
			0.593889,
			0.00912724,
			0.238855,
			1,
			0.191208,
			0.191208,
			0.191208
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_iceFire_H",
		RGBPoints: [
			-1,
			4.05432e-7,
			0,
			0.00000590122,
			-0.87451,
			0,
			0.120401,
			0.302675,
			-0.74902,
			0,
			0.216583,
			0.524574,
			-0.623529,
			0.0552475,
			0.345025,
			0.6595,
			-0.498039,
			0.128047,
			0.492588,
			0.720288,
			-0.372549,
			0.188955,
			0.641309,
			0.792092,
			-0.247059,
			0.327673,
			0.784935,
			0.873434,
			-0.121569,
			0.60824,
			0.892164,
			0.935547,
			0.00392157,
			0.881371,
			0.912178,
			0.818099,
			0.129412,
			0.951407,
			0.835621,
			0.449279,
			0.254902,
			0.904481,
			0.690489,
			0,
			0.380392,
			0.85407,
			0.510864,
			0,
			0.505882,
			0.777093,
			0.33018,
			0.00088199,
			0.631373,
			0.672862,
			0.139087,
			0.00269398,
			0.756863,
			0.508815,
			0,
			0,
			0.882353,
			0.299417,
			0.000366289,
			0.000547829,
			1,
			0.0157519,
			0.00332021,
			4.55569e-8
		]
	},
	{
		ColorSpace: "Lab",
		Name: "erdc_iceFire_L",
		RGBPoints: [
			-1,
			0.870485,
			0.913768,
			0.832905,
			-0.87451,
			0.586919,
			0.887865,
			0.934003,
			-0.74902,
			0.31583,
			0.776442,
			0.867858,
			-0.623529,
			0.18302,
			0.632034,
			0.787722,
			-0.498039,
			0.117909,
			0.484134,
			0.713825,
			-0.372549,
			0.0507239,
			0.335979,
			0.654741,
			-0.247059,
			0,
			0.209874,
			0.511832,
			-0.121569,
			0,
			0.114689,
			0.28935,
			0.00392157,
			0.0157519,
			0.00332021,
			4.55569e-8,
			0.129412,
			0.312914,
			0,
			0,
			0.254902,
			0.520865,
			0,
			0,
			0.380392,
			0.680105,
			0.15255,
			0.0025996,
			0.505882,
			0.785109,
			0.339479,
			0.000797922,
			0.631373,
			0.857354,
			0.522494,
			0,
			0.756863,
			0.910974,
			0.699774,
			0,
			0.882353,
			0.951921,
			0.842817,
			0.478545,
			1,
			0.881371,
			0.912178,
			0.818099
		]
	},
	{
		ColorSpace: "RGB",
		Name: "hsv",
		RGBPoints: [
			-1,
			1,
			0,
			0,
			-0.666666,
			1,
			0,
			1,
			-0.333333,
			0,
			0,
			1,
			0,
			0,
			1,
			1,
			0.33333,
			0,
			1,
			0,
			0.66666,
			1,
			1,
			0,
			1,
			1,
			0,
			0
		]
	},
	{
		ColorSpace: "Lab",
		Name: "hue_L60",
		RGBPoints: [
			-1,
			0.964784,
			0.400592,
			0.349549,
			-0.87451,
			0.964915,
			0.372498,
			0.53785,
			-0.74902,
			0.892353,
			0.401039,
			0.759569,
			-0.623529,
			0.79263,
			0.446956,
			0.903017,
			-0.498039,
			0.682208,
			0.49954,
			0.966673,
			-0.372549,
			0.56392,
			0.553082,
			0.968836,
			-0.247059,
			0.442031,
			0.606396,
			0.901601,
			-0.121569,
			0.305499,
			0.65701,
			0.765784,
			0.00392157,
			0.197251,
			0.687914,
			0.620914,
			0.129412,
			0.193882,
			0.701887,
			0.472654,
			0.254902,
			0.249866,
			0.706123,
			0.320005,
			0.380392,
			0.35132,
			0.697417,
			0.202919,
			0.505882,
			0.498097,
			0.669467,
			0.125232,
			0.631373,
			0.637477,
			0.626239,
			0.107431,
			0.756863,
			0.762115,
			0.56872,
			0.155812,
			0.882353,
			0.889434,
			0.481116,
			0.240445,
			1,
			0.964784,
			0.400592,
			0.349549
		]
	},
	{
		IndexedColors: [
			0,
			0,
			0,
			0.8941176470588236,
			0.1019607843137255,
			0.1098039215686274,
			0.2156862745098039,
			0.4941176470588236,
			0.7215686274509804,
			0.3019607843137255,
			0.6862745098039216,
			0.2901960784313726,
			0.596078431372549,
			0.3058823529411765,
			0.6392156862745098,
			1,
			0.4980392156862745,
			0,
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392
		],
		Name: "Spectrum",
		NanColor: [
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392
		]
	},
	{
		IndexedColors: [
			0.4745098039215686,
			0.09019607843137255,
			0.09019607843137255,
			0.7098039215686275,
			0.00392156862745098,
			0.00392156862745098,
			0.9372549019607843,
			0.2784313725490196,
			0.09803921568627451,
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353,
			1,
			0.7058823529411765,
			0,
			1,
			0.8980392156862745,
			0.02352941176470588
		],
		Name: "Warm",
		NanColor: [
			1,
			0.8980392156862745,
			0.02352941176470588
		]
	},
	{
		IndexedColors: [
			0.4588235294117647,
			0.6941176470588235,
			0.00392156862745098,
			0.3450980392156863,
			0.5019607843137255,
			0.1607843137254902,
			0.3137254901960784,
			0.8431372549019608,
			0.7490196078431373,
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.6039215686274509,
			0.407843137254902,
			1,
			0.3725490196078431,
			0.2,
			0.5019607843137255
		],
		Name: "Cool",
		NanColor: [
			0.3725490196078431,
			0.2,
			0.5019607843137255
		]
	},
	{
		IndexedColors: [
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.3058823529411765,
			0.8509803921568627,
			0.9176470588235294,
			0.4509803921568628,
			0.6039215686274509,
			0.8352941176470589,
			0.2588235294117647,
			0.2392156862745098,
			0.6627450980392157,
			0.3137254901960784,
			0.3294117647058823,
			0.5294117647058824,
			0.06274509803921569,
			0.1647058823529412,
			0.3215686274509804
		],
		Name: "Blues",
		NanColor: [
			0.06274509803921569,
			0.1647058823529412,
			0.3215686274509804
		]
	},
	{
		IndexedColors: [
			0.1098039215686274,
			0.5843137254901961,
			0.803921568627451,
			0.2313725490196079,
			0.407843137254902,
			0.6705882352941176,
			0.4,
			0.2431372549019608,
			0.7176470588235294,
			0.6352941176470588,
			0.3294117647058823,
			0.8117647058823529,
			0.8705882352941177,
			0.3803921568627451,
			0.807843137254902,
			0.8627450980392157,
			0.3803921568627451,
			0.5843137254901961,
			0.2392156862745098,
			0.06274509803921569,
			0.3215686274509804
		],
		Name: "Wild Flower",
		NanColor: [
			0.2392156862745098,
			0.06274509803921569,
			0.3215686274509804
		]
	},
	{
		IndexedColors: [
			0.396078431372549,
			0.4862745098039216,
			0.2156862745098039,
			0.4588235294117647,
			0.6941176470588235,
			0.00392156862745098,
			0.6980392156862745,
			0.7294117647058823,
			0.1882352941176471,
			1,
			0.8980392156862745,
			0.02352941176470588,
			1,
			0.7058823529411765,
			0,
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353
		],
		Name: "Citrus",
		NanColor: [
			0.9764705882352941,
			0.5137254901960784,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.2313725490196079,
			0.03137254901960784,
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333,
			0.1764705882352941,
			0,
			0.2941176470588235
		],
		Name: "Brewer Diverging Purple-Orange (11)",
		NanColor: [
			0.1764705882352941,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.2313725490196079,
			0.03137254901960784,
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333,
			0.1764705882352941,
			0,
			0.2941176470588235
		],
		Name: "Brewer Diverging Purple-Orange (10)",
		NanColor: [
			0.1764705882352941,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (9)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.8784313725490196,
			0.5098039215686274,
			0.0784313725490196,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.5019607843137255,
			0.4509803921568628,
			0.6745098039215687,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (8)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6,
			0.5568627450980392,
			0.7647058823529411,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (7)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.3450980392156863,
			0.02352941176470588,
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.996078431372549,
			0.8784313725490196,
			0.7137254901960784,
			0.8470588235294118,
			0.8549019607843137,
			0.9215686274509803,
			0.6,
			0.5568627450980392,
			0.7647058823529411,
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		],
		Name: "Brewer Diverging Purple-Orange (6)",
		NanColor: [
			0.3294117647058823,
			0.1529411764705882,
			0.5333333333333333
		]
	},
	{
		IndexedColors: [
			0.9019607843137255,
			0.3803921568627451,
			0.00392156862745098,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.3686274509803922,
			0.2352941176470588,
			0.6
		],
		Name: "Brewer Diverging Purple-Orange (5)",
		NanColor: [
			0.3686274509803922,
			0.2352941176470588,
			0.6
		]
	},
	{
		IndexedColors: [
			0.9019607843137255,
			0.3803921568627451,
			0.00392156862745098,
			0.9921568627450981,
			0.7215686274509804,
			0.3882352941176471,
			0.6980392156862745,
			0.6705882352941176,
			0.8235294117647058,
			0.3686274509803922,
			0.2352941176470588,
			0.6
		],
		Name: "Brewer Diverging Purple-Orange (4)",
		NanColor: [
			0.3686274509803922,
			0.2352941176470588,
			0.6
		]
	},
	{
		IndexedColors: [
			0.9450980392156862,
			0.6392156862745098,
			0.2509803921568627,
			0.9686274509803922,
			0.9686274509803922,
			0.9686274509803922,
			0.6,
			0.5568627450980392,
			0.7647058823529411
		],
		Name: "Brewer Diverging Purple-Orange (3)",
		NanColor: [
			0.6,
			0.5568627450980392,
			0.7647058823529411
		]
	},
	{
		IndexedColors: [
			0.6196078431372549,
			0.00392156862745098,
			0.2588235294117647,
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353,
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		],
		Name: "Brewer Diverging Spectral (11)",
		NanColor: [
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		]
	},
	{
		IndexedColors: [
			0.6196078431372549,
			0.00392156862745098,
			0.2588235294117647,
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353,
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		],
		Name: "Brewer Diverging Spectral (10)",
		NanColor: [
			0.3686274509803922,
			0.3098039215686275,
			0.6352941176470588
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (9)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9568627450980393,
			0.4274509803921568,
			0.2627450980392157,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (8)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			1,
			1,
			0.7490196078431373,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6,
			0.8352941176470589,
			0.5803921568627451,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (7)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8352941176470589,
			0.2431372549019608,
			0.3098039215686275,
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			0.996078431372549,
			0.8784313725490196,
			0.5450980392156862,
			0.9019607843137255,
			0.9607843137254902,
			0.596078431372549,
			0.6,
			0.8352941176470589,
			0.5803921568627451,
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		],
		Name: "Brewer Diverging Spectral (6)",
		NanColor: [
			0.196078431372549,
			0.5333333333333333,
			0.7411764705882353
		]
	},
	{
		IndexedColors: [
			0.8431372549019608,
			0.09803921568627451,
			0.1098039215686274,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			1,
			1,
			0.7490196078431373,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		],
		Name: "Brewer Diverging Spectral (5)",
		NanColor: [
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		]
	},
	{
		IndexedColors: [
			0.8431372549019608,
			0.09803921568627451,
			0.1098039215686274,
			0.9921568627450981,
			0.6823529411764706,
			0.3803921568627451,
			0.6705882352941176,
			0.8666666666666667,
			0.6431372549019608,
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		],
		Name: "Brewer Diverging Spectral (4)",
		NanColor: [
			0.1686274509803922,
			0.5137254901960784,
			0.7294117647058823
		]
	},
	{
		IndexedColors: [
			0.9882352941176471,
			0.5529411764705883,
			0.3490196078431372,
			1,
			1,
			0.7490196078431373,
			0.6,
			0.8352941176470589,
			0.5803921568627451
		],
		Name: "Brewer Diverging Spectral (3)",
		NanColor: [
			0.6,
			0.8352941176470589,
			0.5803921568627451
		]
	},
	{
		IndexedColors: [
			0.3294117647058823,
			0.1882352941176471,
			0.0196078431372549,
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922,
			0,
			0.2352941176470588,
			0.1882352941176471
		],
		Name: "Brewer Diverging Brown-Blue-Green (11)",
		NanColor: [
			0,
			0.2352941176470588,
			0.1882352941176471
		]
	},
	{
		IndexedColors: [
			0.3294117647058823,
			0.1882352941176471,
			0.0196078431372549,
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922,
			0,
			0.2352941176470588,
			0.1882352941176471
		],
		Name: "Brewer Diverging Brown-Blue-Green (10)",
		NanColor: [
			0,
			0.2352941176470588,
			0.1882352941176471
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (9)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.7490196078431373,
			0.5058823529411764,
			0.1764705882352941,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.207843137254902,
			0.592156862745098,
			0.5607843137254902,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (8)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (7)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.5490196078431373,
			0.3176470588235294,
			0.0392156862745098,
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9647058823529412,
			0.9098039215686274,
			0.7647058823529411,
			0.7803921568627451,
			0.9176470588235294,
			0.8980392156862745,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687,
			0.00392156862745098,
			0.4,
			0.3686274509803922
		],
		Name: "Brewer Diverging Brown-Blue-Green (6)",
		NanColor: [
			0.00392156862745098,
			0.4,
			0.3686274509803922
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.3803921568627451,
			0.1019607843137255,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		],
		Name: "Brewer Diverging Brown-Blue-Green (5)",
		NanColor: [
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.3803921568627451,
			0.1019607843137255,
			0.8745098039215686,
			0.7607843137254902,
			0.4901960784313725,
			0.5019607843137255,
			0.803921568627451,
			0.7568627450980392,
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		],
		Name: "Brewer Diverging Brown-Blue-Green (4)",
		NanColor: [
			0.00392156862745098,
			0.5215686274509804,
			0.4431372549019608
		]
	},
	{
		IndexedColors: [
			0.8470588235294118,
			0.7019607843137254,
			0.396078431372549,
			0.9607843137254902,
			0.9607843137254902,
			0.9607843137254902,
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687
		],
		Name: "Brewer Diverging Brown-Blue-Green (3)",
		NanColor: [
			0.3529411764705883,
			0.7058823529411765,
			0.6745098039215687
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.4274509803921568,
			0.1725490196078431,
			0,
			0.2666666666666667,
			0.1058823529411765
		],
		Name: "Brewer Sequential Blue-Green (9)",
		NanColor: [
			0,
			0.2666666666666667,
			0.1058823529411765
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.3450980392156863,
			0.1411764705882353
		],
		Name: "Brewer Sequential Blue-Green (8)",
		NanColor: [
			0,
			0.3450980392156863,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.2549019607843137,
			0.6823529411764706,
			0.4627450980392157,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176,
			0,
			0.3450980392156863,
			0.1411764705882353
		],
		Name: "Brewer Sequential Blue-Green (7)",
		NanColor: [
			0,
			0.3450980392156863,
			0.1411764705882353
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.8,
			0.9254901960784314,
			0.9019607843137255,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431,
			0,
			0.4274509803921568,
			0.1725490196078431
		],
		Name: "Brewer Sequential Blue-Green (6)",
		NanColor: [
			0,
			0.4274509803921568,
			0.1725490196078431
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.6980392156862745,
			0.8862745098039215,
			0.8862745098039215,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431,
			0,
			0.4274509803921568,
			0.1725490196078431
		],
		Name: "Brewer Sequential Blue-Green (5)",
		NanColor: [
			0,
			0.4274509803921568,
			0.1725490196078431
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.6980392156862745,
			0.8862745098039215,
			0.8862745098039215,
			0.4,
			0.7607843137254902,
			0.6431372549019608,
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176
		],
		Name: "Brewer Sequential Blue-Green (4)",
		NanColor: [
			0.1372549019607843,
			0.5450980392156862,
			0.2705882352941176
		]
	},
	{
		IndexedColors: [
			0.8980392156862745,
			0.9607843137254902,
			0.9764705882352941,
			0.6,
			0.8470588235294118,
			0.788235294117647,
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431
		],
		Name: "Brewer Sequential Blue-Green (3)",
		NanColor: [
			0.1725490196078431,
			0.6352941176470588,
			0.3725490196078431
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8980392156862745,
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.6,
			0.203921568627451,
			0.01568627450980392,
			0.4,
			0.1450980392156863,
			0.02352941176470588
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (9)",
		NanColor: [
			0.4,
			0.1450980392156863,
			0.02352941176470588
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8980392156862745,
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (8)",
		NanColor: [
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.9254901960784314,
			0.4392156862745098,
			0.0784313725490196,
			0.8,
			0.2980392156862745,
			0.00784313725490196,
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (7)",
		NanColor: [
			0.5490196078431373,
			0.1764705882352941,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8901960784313725,
			0.5686274509803921,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372,
			0.6,
			0.203921568627451,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (6)",
		NanColor: [
			0.6,
			0.203921568627451,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8509803921568627,
			0.5568627450980392,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372,
			0.6,
			0.203921568627451,
			0.01568627450980392
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (5)",
		NanColor: [
			0.6,
			0.203921568627451,
			0.01568627450980392
		]
	},
	{
		IndexedColors: [
			1,
			1,
			0.8313725490196079,
			0.996078431372549,
			0.8509803921568627,
			0.5568627450980392,
			0.996078431372549,
			0.6,
			0.1607843137254902,
			0.8,
			0.2980392156862745,
			0.00784313725490196
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (4)",
		NanColor: [
			0.8,
			0.2980392156862745,
			0.00784313725490196
		]
	},
	{
		IndexedColors: [
			1,
			0.9686274509803922,
			0.7372549019607844,
			0.996078431372549,
			0.7686274509803922,
			0.3098039215686275,
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372
		],
		Name: "Brewer Sequential Yellow-Orange-Brown (3)",
		NanColor: [
			0.8509803921568627,
			0.3725490196078431,
			0.05490196078431372
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216,
			0.3019607843137255,
			0,
			0.2941176470588235
		],
		Name: "Brewer Sequential Blue-Purple (9)",
		NanColor: [
			0.3019607843137255,
			0,
			0.2941176470588235
		]
	},
	{
		IndexedColors: [
			0.9686274509803922,
			0.9882352941176471,
			0.9921568627450981,
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		],
		Name: "Brewer Sequential Blue-Purple (8)",
		NanColor: [
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5490196078431373,
			0.4196078431372549,
			0.6941176470588235,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804,
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		],
		Name: "Brewer Sequential Blue-Purple (7)",
		NanColor: [
			0.4313725490196079,
			0.00392156862745098,
			0.4196078431372549
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7490196078431373,
			0.8274509803921568,
			0.9019607843137255,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		],
		Name: "Brewer Sequential Blue-Purple (6)",
		NanColor: [
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137,
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		],
		Name: "Brewer Sequential Blue-Purple (5)",
		NanColor: [
			0.5058823529411764,
			0.05882352941176471,
			0.4862745098039216
		]
	},
	{
		IndexedColors: [
			0.9294117647058824,
			0.9725490196078431,
			0.984313725490196,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.5490196078431373,
			0.5882352941176471,
			0.7764705882352941,
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804
		],
		Name: "Brewer Sequential Blue-Purple (4)",
		NanColor: [
			0.5333333333333333,
			0.2549019607843137,
			0.615686274509804
		]
	},
	{
		IndexedColors: [
			0.8784313725490196,
			0.9254901960784314,
			0.9568627450980393,
			0.6196078431372549,
			0.7372549019607844,
			0.8549019607843137,
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137
		],
		Name: "Brewer Sequential Blue-Purple (3)",
		NanColor: [
			0.5333333333333333,
			0.3372549019607843,
			0.6549019607843137
		]
	},
	{
		IndexedColors: [
			0.4980392156862745,
			0.788235294117647,
			0.4980392156862745,
			0.7450980392156863,
			0.6823529411764706,
			0.8313725490196079,
			0.9921568627450981,
			0.7529411764705882,
			0.5254901960784314,
			1,
			1,
			0.6,
			0.2196078431372549,
			0.4235294117647059,
			0.6901960784313725,
			0.9411764705882353,
			0.00784313725490196,
			0.4980392156862745,
			0.7490196078431373,
			0.3568627450980392,
			0.09019607843137255,
			0.4,
			0.4,
			0.4
		],
		Name: "Brewer Qualitative Accent",
		NanColor: [
			0.4,
			0.4,
			0.4
		]
	},
	{
		IndexedColors: [
			0.1058823529411765,
			0.6196078431372549,
			0.4666666666666667,
			0.8509803921568627,
			0.3725490196078431,
			0.00784313725490196,
			0.4588235294117647,
			0.4392156862745098,
			0.7019607843137254,
			0.9058823529411765,
			0.1607843137254902,
			0.5411764705882353,
			0.4,
			0.6509803921568628,
			0.1176470588235294,
			0.9019607843137255,
			0.6705882352941176,
			0.00784313725490196,
			0.6509803921568628,
			0.4627450980392157,
			0.1137254901960784,
			0.4,
			0.4,
			0.4
		],
		Name: "Brewer Qualitative Dark2",
		NanColor: [
			0.4,
			0.4,
			0.4
		]
	},
	{
		IndexedColors: [
			0.4,
			0.7607843137254902,
			0.6470588235294118,
			0.9882352941176471,
			0.5529411764705883,
			0.3843137254901961,
			0.5529411764705883,
			0.6274509803921569,
			0.796078431372549,
			0.9058823529411765,
			0.5411764705882353,
			0.7647058823529411,
			0.6509803921568628,
			0.8470588235294118,
			0.3294117647058823,
			1,
			0.8509803921568627,
			0.1843137254901961,
			0.8980392156862745,
			0.7686274509803922,
			0.5803921568627451,
			0.7019607843137254,
			0.7019607843137254,
			0.7019607843137254
		],
		Name: "Brewer Qualitative Set2",
		NanColor: [
			0.7019607843137254,
			0.7019607843137254,
			0.7019607843137254
		]
	},
	{
		IndexedColors: [
			0.7019607843137254,
			0.8862745098039215,
			0.803921568627451,
			0.9921568627450981,
			0.803921568627451,
			0.6745098039215687,
			0.796078431372549,
			0.8352941176470589,
			0.9098039215686274,
			0.9568627450980393,
			0.792156862745098,
			0.8941176470588236,
			0.9019607843137255,
			0.9607843137254902,
			0.788235294117647,
			1,
			0.9490196078431372,
			0.6823529411764706,
			0.9450980392156862,
			0.8862745098039215,
			0.8,
			0.8,
			0.8,
			0.8
		],
		Name: "Brewer Qualitative Pastel2",
		NanColor: [
			0.8,
			0.8,
			0.8
		]
	},
	{
		IndexedColors: [
			0.984313725490196,
			0.7058823529411765,
			0.6823529411764706,
			0.7019607843137254,
			0.803921568627451,
			0.8901960784313725,
			0.8,
			0.9215686274509803,
			0.7725490196078432,
			0.8705882352941177,
			0.796078431372549,
			0.8941176470588236,
			0.996078431372549,
			0.8509803921568627,
			0.6509803921568628,
			1,
			1,
			0.8,
			0.8980392156862745,
			0.8470588235294118,
			0.7411764705882353,
			0.9921568627450981,
			0.8549019607843137,
			0.9254901960784314,
			0.9490196078431372,
			0.9490196078431372,
			0.9490196078431372
		],
		Name: "Brewer Qualitative Pastel1",
		NanColor: [
			0.9490196078431372,
			0.9490196078431372,
			0.9490196078431372
		]
	},
	{
		IndexedColors: [
			0.8941176470588236,
			0.1019607843137255,
			0.1098039215686274,
			0.2156862745098039,
			0.4941176470588236,
			0.7215686274509804,
			0.3019607843137255,
			0.6862745098039216,
			0.2901960784313726,
			0.596078431372549,
			0.3058823529411765,
			0.6392156862745098,
			1,
			0.4980392156862745,
			0,
			1,
			1,
			0.2,
			0.6509803921568628,
			0.3372549019607843,
			0.1568627450980392,
			0.9686274509803922,
			0.5058823529411764,
			0.7490196078431373,
			0.6,
			0.6,
			0.6
		],
		Name: "Brewer Qualitative Set1",
		NanColor: [
			0.6,
			0.6,
			0.6
		]
	},
	{
		IndexedColors: [
			0.6509803921568628,
			0.807843137254902,
			0.8901960784313725,
			0.1215686274509804,
			0.4705882352941176,
			0.7058823529411765,
			0.6980392156862745,
			0.8745098039215686,
			0.5411764705882353,
			0.2,
			0.6274509803921569,
			0.1725490196078431,
			0.984313725490196,
			0.6039215686274509,
			0.6,
			0.8901960784313725,
			0.1019607843137255,
			0.1098039215686274,
			0.9921568627450981,
			0.7490196078431373,
			0.4352941176470588,
			1,
			0.4980392156862745,
			0,
			0.792156862745098,
			0.6980392156862745,
			0.8392156862745098,
			0.4156862745098039,
			0.2392156862745098,
			0.6039215686274509,
			1,
			1,
			0.6
		],
		Name: "Brewer Qualitative Paired",
		NanColor: [
			1,
			1,
			0.6
		]
	},
	{
		IndexedColors: [
			0.5529411764705883,
			0.8274509803921568,
			0.7803921568627451,
			1,
			1,
			0.7019607843137254,
			0.7450980392156863,
			0.7294117647058823,
			0.8549019607843137,
			0.984313725490196,
			0.5019607843137255,
			0.4470588235294118,
			0.5019607843137255,
			0.6941176470588235,
			0.8274509803921568,
			0.9921568627450981,
			0.7058823529411765,
			0.3843137254901961,
			0.7019607843137254,
			0.8705882352941177,
			0.4117647058823529,
			0.9882352941176471,
			0.803921568627451,
			0.8980392156862745,
			0.8509803921568627,
			0.8509803921568627,
			0.8509803921568627,
			0.7372549019607844,
			0.5019607843137255,
			0.7411764705882353,
			0.8,
			0.9215686274509803,
			0.7725490196078432,
			1,
			0.9294117647058824,
			0.4352941176470588
		],
		Name: "Brewer Qualitative Set3",
		NanColor: [
			1,
			0.9294117647058824,
			0.4352941176470588
		]
	},
	{
		IndexedColors: [
			1,
			0,
			0,
			1,
			0.862745,
			0,
			0,
			0.695201,
			0
		],
		Name: "Traffic Lights",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		IndexedColors: [
			0.908659,
			0.604013,
			0.581857,
			1,
			0.862745,
			0,
			0,
			0.695201,
			0
		],
		Name: "Traffic Lights For Deuteranopes",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		IndexedColors: [
			0.4196078431372549,
			0,
			0.07058823529411765,
			0.9019607843137255,
			0.9411764705882353,
			0.0196078431372549,
			0.01568627450980392,
			0.6196078431372549,
			0.00784313725490196
		],
		Name: "Traffic Lights For Deuteranopes 2",
		NanColor: [
			0.803922,
			0,
			0.803922
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Muted Blue-Green",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.109804,
			0.27451,
			0.301961,
			0.02,
			0.129412,
			0.309804,
			0.341176,
			0.05,
			0.14902,
			0.341176,
			0.380392,
			0.1,
			0.188235,
			0.403922,
			0.458824,
			0.15,
			0.227451,
			0.447059,
			0.521569,
			0.2,
			0.290196,
			0.494118,
			0.588235,
			0.25,
			0.368627,
			0.552941,
			0.670588,
			0.3,
			0.458824,
			0.619608,
			0.74902,
			0.35,
			0.588235,
			0.713725,
			0.85098,
			0.4,
			0.72549,
			0.815686,
			0.941176,
			0.45,
			0.831373,
			0.882353,
			0.980392,
			0.475,
			0.909804,
			0.933333,
			1,
			0.5,
			0.980392,
			0.984314,
			1,
			0.5,
			0.996078,
			1,
			0.94902,
			0.5,
			1,
			1,
			0.980392,
			0.5,
			0.980392,
			0.984314,
			1,
			0.525,
			0.972549,
			0.988235,
			0.890196,
			0.55,
			0.917647,
			0.960784,
			0.835294,
			0.6,
			0.835294,
			0.921569,
			0.772549,
			0.65,
			0.768627,
			0.901961,
			0.737255,
			0.7,
			0.670588,
			0.831373,
			0.654902,
			0.75,
			0.576471,
			0.760784,
			0.584314,
			0.8,
			0.498039,
			0.678431,
			0.521569,
			0.85,
			0.392157,
			0.560784,
			0.427451,
			0.9,
			0.294118,
			0.45098,
			0.333333,
			0.95,
			0.211765,
			0.34902,
			0.254902,
			1,
			0.152941,
			0.278431,
			0.196078
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Green-Blue Asymmetric Divergent (62Blbc)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.121569,
			0.2,
			0.145098,
			0.05,
			0.196078,
			0.301961,
			0.223529,
			0.1,
			0.258824,
			0.4,
			0.278431,
			0.2,
			0.341176,
			0.54902,
			0.341176,
			0.25,
			0.419608,
			0.619608,
			0.376471,
			0.3,
			0.545098,
			0.701961,
			0.392157,
			0.35,
			0.643137,
			0.780392,
			0.403922,
			0.4,
			0.729412,
			0.819608,
			0.45098,
			0.45,
			0.811765,
			0.870588,
			0.521569,
			0.5,
			0.898039,
			0.909804,
			0.564706,
			0.55,
			0.941176,
			0.92549,
			0.686275,
			0.6,
			0.960784,
			0.94902,
			0.776471,
			0.64,
			1,
			1,
			1,
			0.65,
			0.890196,
			0.988235,
			0.972549,
			0.7,
			0.721569,
			0.894118,
			0.901961,
			0.75,
			0.631373,
			0.823529,
			0.839216,
			0.8,
			0.517647,
			0.662745,
			0.701961,
			0.85,
			0.384314,
			0.494118,
			0.54902,
			0.9,
			0.298039,
			0.360784,
			0.45098,
			0.95,
			0.223529,
			0.25098,
			0.34902,
			0.99,
			0.156863,
			0.172549,
			0.25098,
			1,
			0.137255,
			0.137255,
			0.188235
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Asymmtrical Earth Tones (6_21b)",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			0.141176,
			0.14902,
			0.2,
			0.05,
			0.215686,
			0.258824,
			0.321569,
			0.1,
			0.243137,
			0.368627,
			0.380392,
			0.15,
			0.27451,
			0.439216,
			0.4,
			0.2,
			0.32549,
			0.501961,
			0.384314,
			0.25,
			0.403922,
			0.6,
			0.419608,
			0.3,
			0.486275,
			0.701961,
			0.454902,
			0.35,
			0.556863,
			0.74902,
			0.494118,
			0.4,
			0.670588,
			0.8,
			0.545098,
			0.5,
			0.854902,
			0.901961,
			0.631373,
			0.55,
			0.92549,
			0.941176,
			0.694118,
			0.6,
			0.960784,
			0.94902,
			0.776471,
			0.65,
			0.988235,
			0.968627,
			0.909804,
			0.7,
			0.839216,
			0.815686,
			0.772549,
			0.75,
			0.701961,
			0.662745,
			0.615686,
			0.8,
			0.6,
			0.529412,
			0.478431,
			0.85,
			0.501961,
			0.403922,
			0.360784,
			0.9,
			0.439216,
			0.313725,
			0.290196,
			1,
			0.301961,
			0.164706,
			0.176471
		]
	},
	{
		ColorSpace: "Lab",
		Creator: "Francesca Samsel",
		Name: "Yellow 15",
		NanColor: [
			0.25,
			0,
			0
		],
		RGBPoints: [
			0,
			1,
			1,
			0.988235,
			0.002,
			1,
			1,
			0.988235,
			0.05,
			0.984314,
			0.988235,
			0.843137,
			0.1,
			0.988235,
			0.988235,
			0.741176,
			0.15,
			0.980392,
			0.968627,
			0.654902,
			0.2,
			0.980392,
			0.945098,
			0.576471,
			0.25,
			0.968627,
			0.905882,
			0.486275,
			0.3,
			0.968627,
			0.862745,
			0.388235,
			0.35,
			0.960784,
			0.803922,
			0.286275,
			0.4,
			0.94902,
			0.741176,
			0.219608,
			0.45,
			0.941176,
			0.678431,
			0.14902,
			0.5,
			0.929412,
			0.607843,
			0.094118,
			0.55,
			0.921569,
			0.545098,
			0.054902,
			0.6,
			0.909804,
			0.486275,
			0.035294,
			0.65,
			0.890196,
			0.411765,
			0.019608,
			0.7,
			0.8,
			0.305882,
			0,
			0.75,
			0.760784,
			0.239216,
			0,
			0.8,
			0.678431,
			0.180392,
			0.011765,
			0.85,
			0.6,
			0.121569,
			0.023529,
			0.9,
			0.501961,
			0.054902,
			0.031373,
			0.95,
			0.4,
			0.039216,
			0.058824,
			1,
			0.301961,
			0.047059,
			0.090196
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Magma (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.001462,
			0.000466,
			0.013866,
			0.003922,
			0.002258,
			0.001295,
			0.018331,
			0.007843,
			0.003279,
			0.002305,
			0.023708,
			0.011765,
			0.004512,
			0.00349,
			0.029965,
			0.015686,
			0.00595,
			0.004843,
			0.03713,
			0.019608,
			0.007588,
			0.006356,
			0.044973,
			0.023529,
			0.009426,
			0.008022,
			0.052844,
			0.027451,
			0.011465,
			0.009828,
			0.06075,
			0.031373,
			0.013708,
			0.011771,
			0.068667,
			0.035294,
			0.016156,
			0.01384,
			0.076603,
			0.039216,
			0.018815,
			0.016026,
			0.084584,
			0.043137,
			0.021692,
			0.01832,
			0.09261,
			0.047059,
			0.024792,
			0.020715,
			0.100676,
			0.05098,
			0.028123,
			0.023201,
			0.108787,
			0.054902,
			0.031696,
			0.025765,
			0.116965,
			0.058824,
			0.03552,
			0.028397,
			0.125209,
			0.062745,
			0.039608,
			0.03109,
			0.133515,
			0.066667,
			0.04383,
			0.03383,
			0.141886,
			0.070588,
			0.048062,
			0.036607,
			0.150327,
			0.07451,
			0.05232,
			0.039407,
			0.158841,
			0.078431,
			0.056615,
			0.04216,
			0.167446,
			0.082353,
			0.060949,
			0.044794,
			0.176129,
			0.086275,
			0.06533,
			0.047318,
			0.184892,
			0.090196,
			0.069764,
			0.049726,
			0.193735,
			0.094118,
			0.074257,
			0.052017,
			0.20266,
			0.098039,
			0.078815,
			0.054184,
			0.211667,
			0.101961,
			0.083446,
			0.056225,
			0.220755,
			0.105882,
			0.088155,
			0.058133,
			0.229922,
			0.109804,
			0.092949,
			0.059904,
			0.239164,
			0.113725,
			0.097833,
			0.061531,
			0.248477,
			0.117647,
			0.102815,
			0.06301,
			0.257854,
			0.121569,
			0.107899,
			0.064335,
			0.267289,
			0.12549,
			0.113094,
			0.065492,
			0.276784,
			0.129412,
			0.118405,
			0.066479,
			0.286321,
			0.133333,
			0.123833,
			0.067295,
			0.295879,
			0.137255,
			0.12938,
			0.067935,
			0.305443,
			0.141176,
			0.135053,
			0.068391,
			0.315,
			0.145098,
			0.140858,
			0.068654,
			0.324538,
			0.14902,
			0.146785,
			0.068738,
			0.334011,
			0.152941,
			0.152839,
			0.068637,
			0.343404,
			0.156863,
			0.159018,
			0.068354,
			0.352688,
			0.160784,
			0.165308,
			0.067911,
			0.361816,
			0.164706,
			0.171713,
			0.067305,
			0.370771,
			0.168627,
			0.178212,
			0.066576,
			0.379497,
			0.172549,
			0.184801,
			0.065732,
			0.387973,
			0.176471,
			0.19146,
			0.064818,
			0.396152,
			0.180392,
			0.198177,
			0.063862,
			0.404009,
			0.184314,
			0.204935,
			0.062907,
			0.411514,
			0.188235,
			0.211718,
			0.061992,
			0.418647,
			0.192157,
			0.218512,
			0.061158,
			0.425392,
			0.196078,
			0.225302,
			0.060445,
			0.431742,
			0.2,
			0.232077,
			0.059889,
			0.437695,
			0.203922,
			0.238826,
			0.059517,
			0.443256,
			0.207843,
			0.245543,
			0.059352,
			0.448436,
			0.211765,
			0.25222,
			0.059415,
			0.453248,
			0.215686,
			0.258857,
			0.059706,
			0.45771,
			0.219608,
			0.265447,
			0.060237,
			0.46184,
			0.223529,
			0.271994,
			0.060994,
			0.46566,
			0.227451,
			0.278493,
			0.061978,
			0.46919,
			0.231373,
			0.284951,
			0.063168,
			0.472451,
			0.235294,
			0.291366,
			0.064553,
			0.475462,
			0.239216,
			0.29774,
			0.066117,
			0.478243,
			0.243137,
			0.304081,
			0.067835,
			0.480812,
			0.247059,
			0.310382,
			0.069702,
			0.483186,
			0.25098,
			0.316654,
			0.07169,
			0.48538,
			0.254902,
			0.322899,
			0.073782,
			0.487408,
			0.258824,
			0.329114,
			0.075972,
			0.489287,
			0.262745,
			0.335308,
			0.078236,
			0.491024,
			0.266667,
			0.341482,
			0.080564,
			0.492631,
			0.270588,
			0.347636,
			0.082946,
			0.494121,
			0.27451,
			0.353773,
			0.085373,
			0.495501,
			0.278431,
			0.359898,
			0.087831,
			0.496778,
			0.282353,
			0.366012,
			0.090314,
			0.49796,
			0.286275,
			0.372116,
			0.092816,
			0.499053,
			0.290196,
			0.378211,
			0.095332,
			0.500067,
			0.294118,
			0.384299,
			0.097855,
			0.501002,
			0.298039,
			0.390384,
			0.100379,
			0.501864,
			0.301961,
			0.396467,
			0.102902,
			0.502658,
			0.305882,
			0.402548,
			0.10542,
			0.503386,
			0.309804,
			0.408629,
			0.10793,
			0.504052,
			0.313725,
			0.414709,
			0.110431,
			0.504662,
			0.317647,
			0.420791,
			0.11292,
			0.505215,
			0.321569,
			0.426877,
			0.115395,
			0.505714,
			0.32549,
			0.432967,
			0.117855,
			0.50616,
			0.329412,
			0.439062,
			0.120298,
			0.506555,
			0.333333,
			0.445163,
			0.122724,
			0.506901,
			0.337255,
			0.451271,
			0.125132,
			0.507198,
			0.341176,
			0.457386,
			0.127522,
			0.507448,
			0.345098,
			0.463508,
			0.129893,
			0.507652,
			0.34902,
			0.46964,
			0.132245,
			0.507809,
			0.352941,
			0.47578,
			0.134577,
			0.507921,
			0.356863,
			0.481929,
			0.136891,
			0.507989,
			0.360784,
			0.488088,
			0.139186,
			0.508011,
			0.364706,
			0.494258,
			0.141462,
			0.507988,
			0.368627,
			0.500438,
			0.143719,
			0.50792,
			0.372549,
			0.506629,
			0.145958,
			0.507806,
			0.376471,
			0.512831,
			0.148179,
			0.507648,
			0.380392,
			0.519045,
			0.150383,
			0.507443,
			0.384314,
			0.52527,
			0.152569,
			0.507192,
			0.388235,
			0.531507,
			0.154739,
			0.506895,
			0.392157,
			0.537755,
			0.156894,
			0.506551,
			0.396078,
			0.544015,
			0.159033,
			0.506159,
			0.4,
			0.550287,
			0.161158,
			0.505719,
			0.403922,
			0.556571,
			0.163269,
			0.50523,
			0.407843,
			0.562866,
			0.165368,
			0.504692,
			0.411765,
			0.569172,
			0.167454,
			0.504105,
			0.415686,
			0.57549,
			0.16953,
			0.503466,
			0.419608,
			0.581819,
			0.171596,
			0.502777,
			0.423529,
			0.588158,
			0.173652,
			0.502035,
			0.427451,
			0.594508,
			0.175701,
			0.501241,
			0.431373,
			0.600868,
			0.177743,
			0.500394,
			0.435294,
			0.607238,
			0.179779,
			0.499492,
			0.439216,
			0.613617,
			0.181811,
			0.498536,
			0.443137,
			0.620005,
			0.18384,
			0.497524,
			0.447059,
			0.626401,
			0.185867,
			0.496456,
			0.45098,
			0.632805,
			0.187893,
			0.495332,
			0.454902,
			0.639216,
			0.189921,
			0.49415,
			0.458824,
			0.645633,
			0.191952,
			0.49291,
			0.462745,
			0.652056,
			0.193986,
			0.491611,
			0.466667,
			0.658483,
			0.196027,
			0.490253,
			0.470588,
			0.664915,
			0.198075,
			0.488836,
			0.47451,
			0.671349,
			0.200133,
			0.487358,
			0.478431,
			0.677786,
			0.202203,
			0.485819,
			0.482353,
			0.684224,
			0.204286,
			0.484219,
			0.486275,
			0.690661,
			0.206384,
			0.482558,
			0.490196,
			0.697098,
			0.208501,
			0.480835,
			0.494118,
			0.703532,
			0.210638,
			0.479049,
			0.498039,
			0.709962,
			0.212797,
			0.477201,
			0.501961,
			0.716387,
			0.214982,
			0.47529,
			0.505882,
			0.722805,
			0.217194,
			0.473316,
			0.509804,
			0.729216,
			0.219437,
			0.471279,
			0.513725,
			0.735616,
			0.221713,
			0.46918,
			0.517647,
			0.742004,
			0.224025,
			0.467018,
			0.521569,
			0.748378,
			0.226377,
			0.464794,
			0.52549,
			0.754737,
			0.228772,
			0.462509,
			0.529412,
			0.761077,
			0.231214,
			0.460162,
			0.533333,
			0.767398,
			0.233705,
			0.457755,
			0.537255,
			0.773695,
			0.236249,
			0.455289,
			0.541176,
			0.779968,
			0.238851,
			0.452765,
			0.545098,
			0.786212,
			0.241514,
			0.450184,
			0.54902,
			0.792427,
			0.244242,
			0.447543,
			0.552941,
			0.798608,
			0.24704,
			0.444848,
			0.556863,
			0.804752,
			0.249911,
			0.442102,
			0.560784,
			0.810855,
			0.252861,
			0.439305,
			0.564706,
			0.816914,
			0.255895,
			0.436461,
			0.568627,
			0.822926,
			0.259016,
			0.433573,
			0.572549,
			0.828886,
			0.262229,
			0.430644,
			0.576471,
			0.834791,
			0.26554,
			0.427671,
			0.580392,
			0.840636,
			0.268953,
			0.424666,
			0.584314,
			0.846416,
			0.272473,
			0.421631,
			0.588235,
			0.852126,
			0.276106,
			0.418573,
			0.592157,
			0.857763,
			0.279857,
			0.415496,
			0.596078,
			0.86332,
			0.283729,
			0.412403,
			0.6,
			0.868793,
			0.287728,
			0.409303,
			0.603922,
			0.874176,
			0.291859,
			0.406205,
			0.607843,
			0.879464,
			0.296125,
			0.403118,
			0.611765,
			0.884651,
			0.30053,
			0.400047,
			0.615686,
			0.889731,
			0.305079,
			0.397002,
			0.619608,
			0.8947,
			0.309773,
			0.393995,
			0.623529,
			0.899552,
			0.314616,
			0.391037,
			0.627451,
			0.904281,
			0.31961,
			0.388137,
			0.631373,
			0.908884,
			0.324755,
			0.385308,
			0.635294,
			0.913354,
			0.330052,
			0.382563,
			0.639216,
			0.917689,
			0.3355,
			0.379915,
			0.643137,
			0.921884,
			0.341098,
			0.377376,
			0.647059,
			0.925937,
			0.346844,
			0.374959,
			0.65098,
			0.929845,
			0.352734,
			0.372677,
			0.654902,
			0.933606,
			0.358764,
			0.370541,
			0.658824,
			0.937221,
			0.364929,
			0.368567,
			0.662745,
			0.940687,
			0.371224,
			0.366762,
			0.666667,
			0.944006,
			0.377643,
			0.365136,
			0.670588,
			0.94718,
			0.384178,
			0.363701,
			0.67451,
			0.95021,
			0.39082,
			0.362468,
			0.678431,
			0.953099,
			0.397563,
			0.361438,
			0.682353,
			0.955849,
			0.4044,
			0.360619,
			0.686275,
			0.958464,
			0.411324,
			0.360014,
			0.690196,
			0.960949,
			0.418323,
			0.35963,
			0.694118,
			0.96331,
			0.42539,
			0.359469,
			0.698039,
			0.965549,
			0.432519,
			0.359529,
			0.701961,
			0.967671,
			0.439703,
			0.35981,
			0.705882,
			0.96968,
			0.446936,
			0.360311,
			0.709804,
			0.971582,
			0.45421,
			0.36103,
			0.713725,
			0.973381,
			0.46152,
			0.361965,
			0.717647,
			0.975082,
			0.468861,
			0.363111,
			0.721569,
			0.97669,
			0.476226,
			0.364466,
			0.72549,
			0.97821,
			0.483612,
			0.366025,
			0.729412,
			0.979645,
			0.491014,
			0.367783,
			0.733333,
			0.981,
			0.498428,
			0.369734,
			0.737255,
			0.982279,
			0.505851,
			0.371874,
			0.741176,
			0.983485,
			0.51328,
			0.374198,
			0.745098,
			0.984622,
			0.520713,
			0.376698,
			0.74902,
			0.985693,
			0.528148,
			0.379371,
			0.752941,
			0.9867,
			0.535582,
			0.38221,
			0.756863,
			0.987646,
			0.543015,
			0.38521,
			0.760784,
			0.988533,
			0.550446,
			0.388365,
			0.764706,
			0.989363,
			0.557873,
			0.391671,
			0.768627,
			0.990138,
			0.565296,
			0.395122,
			0.772549,
			0.990871,
			0.572706,
			0.398714,
			0.776471,
			0.991558,
			0.580107,
			0.402441,
			0.780392,
			0.992196,
			0.587502,
			0.406299,
			0.784314,
			0.992785,
			0.594891,
			0.410283,
			0.788235,
			0.993326,
			0.602275,
			0.41439,
			0.792157,
			0.993834,
			0.609644,
			0.418613,
			0.796078,
			0.994309,
			0.616999,
			0.42295,
			0.8,
			0.994738,
			0.62435,
			0.427397,
			0.803922,
			0.995122,
			0.631696,
			0.431951,
			0.807843,
			0.99548,
			0.639027,
			0.436607,
			0.811765,
			0.99581,
			0.646344,
			0.441361,
			0.815686,
			0.996096,
			0.653659,
			0.446213,
			0.819608,
			0.996341,
			0.660969,
			0.45116,
			0.823529,
			0.99658,
			0.668256,
			0.456192,
			0.827451,
			0.996775,
			0.675541,
			0.461314,
			0.831373,
			0.996925,
			0.682828,
			0.466526,
			0.835294,
			0.997077,
			0.690088,
			0.471811,
			0.839216,
			0.997186,
			0.697349,
			0.477182,
			0.843137,
			0.997254,
			0.704611,
			0.482635,
			0.847059,
			0.997325,
			0.711848,
			0.488154,
			0.85098,
			0.997351,
			0.719089,
			0.493755,
			0.854902,
			0.997351,
			0.726324,
			0.499428,
			0.858824,
			0.997341,
			0.733545,
			0.505167,
			0.862745,
			0.997285,
			0.740772,
			0.510983,
			0.866667,
			0.997228,
			0.747981,
			0.516859,
			0.870588,
			0.997138,
			0.75519,
			0.522806,
			0.87451,
			0.997019,
			0.762398,
			0.528821,
			0.878431,
			0.996898,
			0.769591,
			0.534892,
			0.882353,
			0.996727,
			0.776795,
			0.541039,
			0.886275,
			0.996571,
			0.783977,
			0.547233,
			0.890196,
			0.996369,
			0.791167,
			0.553499,
			0.894118,
			0.996162,
			0.798348,
			0.55982,
			0.898039,
			0.995932,
			0.805527,
			0.566202,
			0.901961,
			0.99568,
			0.812706,
			0.572645,
			0.905882,
			0.995424,
			0.819875,
			0.57914,
			0.909804,
			0.995131,
			0.827052,
			0.585701,
			0.913725,
			0.994851,
			0.834213,
			0.592307,
			0.917647,
			0.994524,
			0.841387,
			0.598983,
			0.921569,
			0.994222,
			0.84854,
			0.605696,
			0.92549,
			0.993866,
			0.855711,
			0.612482,
			0.929412,
			0.993545,
			0.862859,
			0.619299,
			0.933333,
			0.99317,
			0.870024,
			0.626189,
			0.937255,
			0.992831,
			0.877168,
			0.633109,
			0.941176,
			0.99244,
			0.88433,
			0.640099,
			0.945098,
			0.992089,
			0.89147,
			0.647116,
			0.94902,
			0.991688,
			0.898627,
			0.654202,
			0.952941,
			0.991332,
			0.905763,
			0.661309,
			0.956863,
			0.99093,
			0.912915,
			0.668481,
			0.960784,
			0.99057,
			0.920049,
			0.675675,
			0.964706,
			0.990175,
			0.927196,
			0.682926,
			0.968627,
			0.989815,
			0.934329,
			0.690198,
			0.972549,
			0.989434,
			0.94147,
			0.697519,
			0.976471,
			0.989077,
			0.948604,
			0.704863,
			0.980392,
			0.988717,
			0.955742,
			0.712242,
			0.984314,
			0.988367,
			0.962878,
			0.719649,
			0.988235,
			0.988033,
			0.970012,
			0.727077,
			0.992157,
			0.987691,
			0.977154,
			0.734536,
			0.996078,
			0.987387,
			0.984288,
			0.742002,
			1,
			0.987053,
			0.991438,
			0.749504
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Inferno (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.001462,
			0.000466,
			0.013866,
			0.003922,
			0.002267,
			0.00127,
			0.01857,
			0.007843,
			0.003299,
			0.002249,
			0.024239,
			0.011765,
			0.004547,
			0.003392,
			0.030909,
			0.015686,
			0.006006,
			0.004692,
			0.038558,
			0.019608,
			0.007676,
			0.006136,
			0.046836,
			0.023529,
			0.009561,
			0.007713,
			0.055143,
			0.027451,
			0.011663,
			0.009417,
			0.06346,
			0.031373,
			0.013995,
			0.011225,
			0.071862,
			0.035294,
			0.016561,
			0.013136,
			0.080282,
			0.039216,
			0.019373,
			0.015133,
			0.088767,
			0.043137,
			0.022447,
			0.017199,
			0.097327,
			0.047059,
			0.025793,
			0.019331,
			0.10593,
			0.05098,
			0.029432,
			0.021503,
			0.114621,
			0.054902,
			0.033385,
			0.023702,
			0.123397,
			0.058824,
			0.037668,
			0.025921,
			0.132232,
			0.062745,
			0.042253,
			0.028139,
			0.141141,
			0.066667,
			0.046915,
			0.030324,
			0.150164,
			0.070588,
			0.051644,
			0.032474,
			0.159254,
			0.07451,
			0.056449,
			0.034569,
			0.168414,
			0.078431,
			0.06134,
			0.03659,
			0.177642,
			0.082353,
			0.066331,
			0.038504,
			0.186962,
			0.086275,
			0.071429,
			0.040294,
			0.196354,
			0.090196,
			0.076637,
			0.041905,
			0.205799,
			0.094118,
			0.081962,
			0.043328,
			0.215289,
			0.098039,
			0.087411,
			0.044556,
			0.224813,
			0.101961,
			0.09299,
			0.045583,
			0.234358,
			0.105882,
			0.098702,
			0.046402,
			0.243904,
			0.109804,
			0.104551,
			0.047008,
			0.25343,
			0.113725,
			0.110536,
			0.047399,
			0.262912,
			0.117647,
			0.116656,
			0.047574,
			0.272321,
			0.121569,
			0.122908,
			0.047536,
			0.281624,
			0.12549,
			0.129285,
			0.047293,
			0.290788,
			0.129412,
			0.135778,
			0.046856,
			0.299776,
			0.133333,
			0.142378,
			0.046242,
			0.308553,
			0.137255,
			0.149073,
			0.045468,
			0.317085,
			0.141176,
			0.15585,
			0.044559,
			0.325338,
			0.145098,
			0.162689,
			0.043554,
			0.333277,
			0.14902,
			0.169575,
			0.042489,
			0.340874,
			0.152941,
			0.176493,
			0.041402,
			0.348111,
			0.156863,
			0.183429,
			0.040329,
			0.354971,
			0.160784,
			0.190367,
			0.039309,
			0.361447,
			0.164706,
			0.197297,
			0.0384,
			0.367535,
			0.168627,
			0.204209,
			0.037632,
			0.373238,
			0.172549,
			0.211095,
			0.03703,
			0.378563,
			0.176471,
			0.217949,
			0.036615,
			0.383522,
			0.180392,
			0.224763,
			0.036405,
			0.388129,
			0.184314,
			0.231538,
			0.036405,
			0.3924,
			0.188235,
			0.238273,
			0.036621,
			0.396353,
			0.192157,
			0.244967,
			0.037055,
			0.400007,
			0.196078,
			0.25162,
			0.037705,
			0.403378,
			0.2,
			0.258234,
			0.038571,
			0.406485,
			0.203922,
			0.26481,
			0.039647,
			0.409345,
			0.207843,
			0.271347,
			0.040922,
			0.411976,
			0.211765,
			0.27785,
			0.042353,
			0.414392,
			0.215686,
			0.284321,
			0.043933,
			0.416608,
			0.219608,
			0.290763,
			0.045644,
			0.418637,
			0.223529,
			0.297178,
			0.04747,
			0.420491,
			0.227451,
			0.303568,
			0.049396,
			0.422182,
			0.231373,
			0.309935,
			0.051407,
			0.423721,
			0.235294,
			0.316282,
			0.05349,
			0.425116,
			0.239216,
			0.32261,
			0.055634,
			0.426377,
			0.243137,
			0.328921,
			0.057827,
			0.427511,
			0.247059,
			0.335217,
			0.06006,
			0.428524,
			0.25098,
			0.3415,
			0.062325,
			0.429425,
			0.254902,
			0.347771,
			0.064616,
			0.430217,
			0.258824,
			0.354032,
			0.066925,
			0.430906,
			0.262745,
			0.360284,
			0.069247,
			0.431497,
			0.266667,
			0.366529,
			0.071579,
			0.431994,
			0.270588,
			0.372768,
			0.073915,
			0.4324,
			0.27451,
			0.379001,
			0.076253,
			0.432719,
			0.278431,
			0.385228,
			0.078591,
			0.432955,
			0.282353,
			0.391453,
			0.080927,
			0.433109,
			0.286275,
			0.397674,
			0.083257,
			0.433183,
			0.290196,
			0.403894,
			0.08558,
			0.433179,
			0.294118,
			0.410113,
			0.087896,
			0.433098,
			0.298039,
			0.416331,
			0.090203,
			0.432943,
			0.301961,
			0.422549,
			0.092501,
			0.432714,
			0.305882,
			0.428768,
			0.09479,
			0.432412,
			0.309804,
			0.434987,
			0.097069,
			0.432039,
			0.313725,
			0.441207,
			0.099338,
			0.431594,
			0.317647,
			0.447428,
			0.101597,
			0.43108,
			0.321569,
			0.453651,
			0.103848,
			0.430498,
			0.32549,
			0.459875,
			0.106089,
			0.429846,
			0.329412,
			0.4661,
			0.108322,
			0.429125,
			0.333333,
			0.472328,
			0.110547,
			0.428334,
			0.337255,
			0.478558,
			0.112764,
			0.427475,
			0.341176,
			0.484789,
			0.114974,
			0.426548,
			0.345098,
			0.491022,
			0.117179,
			0.425552,
			0.34902,
			0.497257,
			0.119379,
			0.424488,
			0.352941,
			0.503493,
			0.121575,
			0.423356,
			0.356863,
			0.50973,
			0.123769,
			0.422156,
			0.360784,
			0.515967,
			0.12596,
			0.420887,
			0.364706,
			0.522206,
			0.12815,
			0.419549,
			0.368627,
			0.528444,
			0.130341,
			0.418142,
			0.372549,
			0.534683,
			0.132534,
			0.416667,
			0.376471,
			0.54092,
			0.134729,
			0.415123,
			0.380392,
			0.547157,
			0.136929,
			0.413511,
			0.384314,
			0.553392,
			0.139134,
			0.411829,
			0.388235,
			0.559624,
			0.141346,
			0.410078,
			0.392157,
			0.565854,
			0.143567,
			0.408258,
			0.396078,
			0.572081,
			0.145797,
			0.406369,
			0.4,
			0.578304,
			0.148039,
			0.404411,
			0.403922,
			0.584521,
			0.150294,
			0.402385,
			0.407843,
			0.590734,
			0.152563,
			0.40029,
			0.411765,
			0.59694,
			0.154848,
			0.398125,
			0.415686,
			0.603139,
			0.157151,
			0.395891,
			0.419608,
			0.60933,
			0.159474,
			0.393589,
			0.423529,
			0.615513,
			0.161817,
			0.391219,
			0.427451,
			0.621685,
			0.164184,
			0.388781,
			0.431373,
			0.627847,
			0.166575,
			0.386276,
			0.435294,
			0.633998,
			0.168992,
			0.383704,
			0.439216,
			0.640135,
			0.171438,
			0.381065,
			0.443137,
			0.64626,
			0.173914,
			0.378359,
			0.447059,
			0.652369,
			0.176421,
			0.375586,
			0.45098,
			0.658463,
			0.178962,
			0.372748,
			0.454902,
			0.66454,
			0.181539,
			0.369846,
			0.458824,
			0.670599,
			0.184153,
			0.366879,
			0.462745,
			0.676638,
			0.186807,
			0.363849,
			0.466667,
			0.682656,
			0.189501,
			0.360757,
			0.470588,
			0.688653,
			0.192239,
			0.357603,
			0.47451,
			0.694627,
			0.195021,
			0.354388,
			0.478431,
			0.700576,
			0.197851,
			0.351113,
			0.482353,
			0.7065,
			0.200728,
			0.347777,
			0.486275,
			0.712396,
			0.203656,
			0.344383,
			0.490196,
			0.718264,
			0.206636,
			0.340931,
			0.494118,
			0.724103,
			0.20967,
			0.337424,
			0.498039,
			0.729909,
			0.212759,
			0.333861,
			0.501961,
			0.735683,
			0.215906,
			0.330245,
			0.505882,
			0.741423,
			0.219112,
			0.326576,
			0.509804,
			0.747127,
			0.222378,
			0.322856,
			0.513725,
			0.752794,
			0.225706,
			0.319085,
			0.517647,
			0.758422,
			0.229097,
			0.315266,
			0.521569,
			0.76401,
			0.232554,
			0.311399,
			0.52549,
			0.769556,
			0.236077,
			0.307485,
			0.529412,
			0.775059,
			0.239667,
			0.303526,
			0.533333,
			0.780517,
			0.243327,
			0.299523,
			0.537255,
			0.785929,
			0.247056,
			0.295477,
			0.541176,
			0.791293,
			0.250856,
			0.29139,
			0.545098,
			0.796607,
			0.254728,
			0.287264,
			0.54902,
			0.801871,
			0.258674,
			0.283099,
			0.552941,
			0.807082,
			0.262692,
			0.278898,
			0.556863,
			0.812239,
			0.266786,
			0.274661,
			0.560784,
			0.817341,
			0.270954,
			0.27039,
			0.564706,
			0.822386,
			0.275197,
			0.266085,
			0.568627,
			0.827372,
			0.279517,
			0.26175,
			0.572549,
			0.832299,
			0.283913,
			0.257383,
			0.576471,
			0.837165,
			0.288385,
			0.252988,
			0.580392,
			0.841969,
			0.292933,
			0.248564,
			0.584314,
			0.846709,
			0.297559,
			0.244113,
			0.588235,
			0.851384,
			0.30226,
			0.239636,
			0.592157,
			0.855992,
			0.307038,
			0.235133,
			0.596078,
			0.860533,
			0.311892,
			0.230606,
			0.6,
			0.865006,
			0.316822,
			0.226055,
			0.603922,
			0.869409,
			0.321827,
			0.221482,
			0.607843,
			0.873741,
			0.326906,
			0.216886,
			0.611765,
			0.878001,
			0.33206,
			0.212268,
			0.615686,
			0.882188,
			0.337287,
			0.207628,
			0.619608,
			0.886302,
			0.342586,
			0.202968,
			0.623529,
			0.890341,
			0.347957,
			0.198286,
			0.627451,
			0.894305,
			0.353399,
			0.193584,
			0.631373,
			0.898192,
			0.358911,
			0.18886,
			0.635294,
			0.902003,
			0.364492,
			0.184116,
			0.639216,
			0.905735,
			0.37014,
			0.17935,
			0.643137,
			0.90939,
			0.375856,
			0.174563,
			0.647059,
			0.912966,
			0.381636,
			0.169755,
			0.65098,
			0.916462,
			0.387481,
			0.164924,
			0.654902,
			0.919879,
			0.393389,
			0.16007,
			0.658824,
			0.923215,
			0.399359,
			0.155193,
			0.662745,
			0.92647,
			0.405389,
			0.150292,
			0.666667,
			0.929644,
			0.411479,
			0.145367,
			0.670588,
			0.932737,
			0.417627,
			0.140417,
			0.67451,
			0.935747,
			0.423831,
			0.13544,
			0.678431,
			0.938675,
			0.430091,
			0.130438,
			0.682353,
			0.941521,
			0.436405,
			0.125409,
			0.686275,
			0.944285,
			0.442772,
			0.120354,
			0.690196,
			0.946965,
			0.449191,
			0.115272,
			0.694118,
			0.949562,
			0.45566,
			0.110164,
			0.698039,
			0.952075,
			0.462178,
			0.105031,
			0.701961,
			0.954506,
			0.468744,
			0.099874,
			0.705882,
			0.956852,
			0.475356,
			0.094695,
			0.709804,
			0.959114,
			0.482014,
			0.089499,
			0.713725,
			0.961293,
			0.488716,
			0.084289,
			0.717647,
			0.963387,
			0.495462,
			0.079073,
			0.721569,
			0.965397,
			0.502249,
			0.073859,
			0.72549,
			0.967322,
			0.509078,
			0.068659,
			0.729412,
			0.969163,
			0.515946,
			0.063488,
			0.733333,
			0.970919,
			0.522853,
			0.058367,
			0.737255,
			0.97259,
			0.529798,
			0.053324,
			0.741176,
			0.974176,
			0.53678,
			0.048392,
			0.745098,
			0.975677,
			0.543798,
			0.043618,
			0.74902,
			0.977092,
			0.55085,
			0.03905,
			0.752941,
			0.978422,
			0.557937,
			0.034931,
			0.756863,
			0.979666,
			0.565057,
			0.031409,
			0.760784,
			0.980824,
			0.572209,
			0.028508,
			0.764706,
			0.981895,
			0.579392,
			0.02625,
			0.768627,
			0.982881,
			0.586606,
			0.024661,
			0.772549,
			0.983779,
			0.593849,
			0.02377,
			0.776471,
			0.984591,
			0.601122,
			0.023606,
			0.780392,
			0.985315,
			0.608422,
			0.024202,
			0.784314,
			0.985952,
			0.61575,
			0.025592,
			0.788235,
			0.986502,
			0.623105,
			0.027814,
			0.792157,
			0.986964,
			0.630485,
			0.030908,
			0.796078,
			0.987337,
			0.63789,
			0.034916,
			0.8,
			0.987622,
			0.64532,
			0.039886,
			0.803922,
			0.987819,
			0.652773,
			0.045581,
			0.807843,
			0.987926,
			0.66025,
			0.05175,
			0.811765,
			0.987945,
			0.667748,
			0.058329,
			0.815686,
			0.987874,
			0.675267,
			0.065257,
			0.819608,
			0.987714,
			0.682807,
			0.072489,
			0.823529,
			0.987464,
			0.690366,
			0.07999,
			0.827451,
			0.987124,
			0.697944,
			0.087731,
			0.831373,
			0.986694,
			0.70554,
			0.095694,
			0.835294,
			0.986175,
			0.713153,
			0.103863,
			0.839216,
			0.985566,
			0.720782,
			0.112229,
			0.843137,
			0.984865,
			0.728427,
			0.120785,
			0.847059,
			0.984075,
			0.736087,
			0.129527,
			0.85098,
			0.983196,
			0.743758,
			0.138453,
			0.854902,
			0.982228,
			0.751442,
			0.147565,
			0.858824,
			0.981173,
			0.759135,
			0.156863,
			0.862745,
			0.980032,
			0.766837,
			0.166353,
			0.866667,
			0.978806,
			0.774545,
			0.176037,
			0.870588,
			0.977497,
			0.782258,
			0.185923,
			0.87451,
			0.976108,
			0.789974,
			0.196018,
			0.878431,
			0.974638,
			0.797692,
			0.206332,
			0.882353,
			0.973088,
			0.805409,
			0.216877,
			0.886275,
			0.971468,
			0.813122,
			0.227658,
			0.890196,
			0.969783,
			0.820825,
			0.238686,
			0.894118,
			0.968041,
			0.828515,
			0.249972,
			0.898039,
			0.966243,
			0.836191,
			0.261534,
			0.901961,
			0.964394,
			0.843848,
			0.273391,
			0.905882,
			0.962517,
			0.851476,
			0.285546,
			0.909804,
			0.960626,
			0.859069,
			0.29801,
			0.913725,
			0.95872,
			0.866624,
			0.31082,
			0.917647,
			0.956834,
			0.874129,
			0.323974,
			0.921569,
			0.954997,
			0.881569,
			0.337475,
			0.92549,
			0.953215,
			0.888942,
			0.351369,
			0.929412,
			0.951546,
			0.896226,
			0.365627,
			0.933333,
			0.950018,
			0.903409,
			0.380271,
			0.937255,
			0.948683,
			0.910473,
			0.395289,
			0.941176,
			0.947594,
			0.917399,
			0.410665,
			0.945098,
			0.946809,
			0.924168,
			0.426373,
			0.94902,
			0.946392,
			0.930761,
			0.442367,
			0.952941,
			0.946403,
			0.937159,
			0.458592,
			0.956863,
			0.946903,
			0.943348,
			0.47497,
			0.960784,
			0.947937,
			0.949318,
			0.491426,
			0.964706,
			0.949545,
			0.955063,
			0.50786,
			0.968627,
			0.95174,
			0.960587,
			0.524203,
			0.972549,
			0.954529,
			0.965896,
			0.540361,
			0.976471,
			0.957896,
			0.971003,
			0.556275,
			0.980392,
			0.961812,
			0.975924,
			0.571925,
			0.984314,
			0.966249,
			0.980678,
			0.587206,
			0.988235,
			0.971162,
			0.985282,
			0.602154,
			0.992157,
			0.976511,
			0.989753,
			0.61676,
			0.996078,
			0.982257,
			0.994109,
			0.631017,
			1,
			0.988362,
			0.998364,
			0.644924
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Plasma (matplotlib)",
		NanColor: [
			0,
			1,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Nathaniel J. Smith & Stefan van der Walt",
		RGBPoints: [
			0,
			0.050383,
			0.029803,
			0.527975,
			0.003922,
			0.063536,
			0.028426,
			0.533124,
			0.007843,
			0.075353,
			0.027206,
			0.538007,
			0.011765,
			0.086222,
			0.026125,
			0.542658,
			0.015686,
			0.096379,
			0.025165,
			0.547103,
			0.019608,
			0.10598,
			0.024309,
			0.551368,
			0.023529,
			0.115124,
			0.023556,
			0.555468,
			0.027451,
			0.123903,
			0.022878,
			0.559423,
			0.031373,
			0.132381,
			0.022258,
			0.56325,
			0.035294,
			0.140603,
			0.021687,
			0.566959,
			0.039216,
			0.148607,
			0.021154,
			0.570562,
			0.043137,
			0.156421,
			0.020651,
			0.574065,
			0.047059,
			0.16407,
			0.020171,
			0.577478,
			0.05098,
			0.171574,
			0.019706,
			0.580806,
			0.054902,
			0.17895,
			0.019252,
			0.584054,
			0.058824,
			0.186213,
			0.018803,
			0.587228,
			0.062745,
			0.193374,
			0.018354,
			0.59033,
			0.066667,
			0.200445,
			0.017902,
			0.593364,
			0.070588,
			0.207435,
			0.017442,
			0.596333,
			0.07451,
			0.21435,
			0.016973,
			0.599239,
			0.078431,
			0.221197,
			0.016497,
			0.602083,
			0.082353,
			0.227983,
			0.016007,
			0.604867,
			0.086275,
			0.234715,
			0.015502,
			0.607592,
			0.090196,
			0.241396,
			0.014979,
			0.610259,
			0.094118,
			0.248032,
			0.014439,
			0.612868,
			0.098039,
			0.254627,
			0.013882,
			0.615419,
			0.101961,
			0.261183,
			0.013308,
			0.617911,
			0.105882,
			0.267703,
			0.012716,
			0.620346,
			0.109804,
			0.274191,
			0.012109,
			0.622722,
			0.113725,
			0.280648,
			0.011488,
			0.625038,
			0.117647,
			0.287076,
			0.010855,
			0.627295,
			0.121569,
			0.293478,
			0.010213,
			0.62949,
			0.12549,
			0.299855,
			0.009561,
			0.631624,
			0.129412,
			0.30621,
			0.008902,
			0.633694,
			0.133333,
			0.312543,
			0.008239,
			0.6357,
			0.137255,
			0.318856,
			0.007576,
			0.63764,
			0.141176,
			0.32515,
			0.006915,
			0.639512,
			0.145098,
			0.331426,
			0.006261,
			0.641316,
			0.14902,
			0.337683,
			0.005618,
			0.643049,
			0.152941,
			0.343925,
			0.004991,
			0.64471,
			0.156863,
			0.35015,
			0.004382,
			0.646298,
			0.160784,
			0.356359,
			0.003798,
			0.64781,
			0.164706,
			0.362553,
			0.003243,
			0.649245,
			0.168627,
			0.368733,
			0.002724,
			0.650601,
			0.172549,
			0.374897,
			0.002245,
			0.651876,
			0.176471,
			0.381047,
			0.001814,
			0.653068,
			0.180392,
			0.387183,
			0.001434,
			0.654177,
			0.184314,
			0.393304,
			0.001114,
			0.655199,
			0.188235,
			0.399411,
			0.000859,
			0.656133,
			0.192157,
			0.405503,
			0.000678,
			0.656977,
			0.196078,
			0.41158,
			0.000577,
			0.65773,
			0.2,
			0.417642,
			0.000564,
			0.65839,
			0.203922,
			0.423689,
			0.000646,
			0.658956,
			0.207843,
			0.429719,
			0.000831,
			0.659425,
			0.211765,
			0.435734,
			0.001127,
			0.659797,
			0.215686,
			0.441732,
			0.00154,
			0.660069,
			0.219608,
			0.447714,
			0.00208,
			0.66024,
			0.223529,
			0.453677,
			0.002755,
			0.66031,
			0.227451,
			0.459623,
			0.003574,
			0.660277,
			0.231373,
			0.46555,
			0.004545,
			0.660139,
			0.235294,
			0.471457,
			0.005678,
			0.659897,
			0.239216,
			0.477344,
			0.00698,
			0.659549,
			0.243137,
			0.48321,
			0.00846,
			0.659095,
			0.247059,
			0.489055,
			0.010127,
			0.658534,
			0.25098,
			0.494877,
			0.01199,
			0.657865,
			0.254902,
			0.500678,
			0.014055,
			0.657088,
			0.258824,
			0.506454,
			0.016333,
			0.656202,
			0.262745,
			0.512206,
			0.018833,
			0.655209,
			0.266667,
			0.517933,
			0.021563,
			0.654109,
			0.270588,
			0.523633,
			0.024532,
			0.652901,
			0.27451,
			0.529306,
			0.027747,
			0.651586,
			0.278431,
			0.534952,
			0.031217,
			0.650165,
			0.282353,
			0.54057,
			0.03495,
			0.64864,
			0.286275,
			0.546157,
			0.038954,
			0.64701,
			0.290196,
			0.551715,
			0.043136,
			0.645277,
			0.294118,
			0.557243,
			0.047331,
			0.643443,
			0.298039,
			0.562738,
			0.051545,
			0.641509,
			0.301961,
			0.568201,
			0.055778,
			0.639477,
			0.305882,
			0.573632,
			0.060028,
			0.637349,
			0.309804,
			0.579029,
			0.064296,
			0.635126,
			0.313725,
			0.584391,
			0.068579,
			0.632812,
			0.317647,
			0.589719,
			0.072878,
			0.630408,
			0.321569,
			0.595011,
			0.07719,
			0.627917,
			0.32549,
			0.600266,
			0.081516,
			0.625342,
			0.329412,
			0.605485,
			0.085854,
			0.622686,
			0.333333,
			0.610667,
			0.090204,
			0.619951,
			0.337255,
			0.615812,
			0.094564,
			0.61714,
			0.341176,
			0.620919,
			0.098934,
			0.614257,
			0.345098,
			0.625987,
			0.103312,
			0.611305,
			0.34902,
			0.631017,
			0.107699,
			0.608287,
			0.352941,
			0.636008,
			0.112092,
			0.605205,
			0.356863,
			0.640959,
			0.116492,
			0.602065,
			0.360784,
			0.645872,
			0.120898,
			0.598867,
			0.364706,
			0.650746,
			0.125309,
			0.595617,
			0.368627,
			0.65558,
			0.129725,
			0.592317,
			0.372549,
			0.660374,
			0.134144,
			0.588971,
			0.376471,
			0.665129,
			0.138566,
			0.585582,
			0.380392,
			0.669845,
			0.142992,
			0.582154,
			0.384314,
			0.674522,
			0.147419,
			0.578688,
			0.388235,
			0.67916,
			0.151848,
			0.575189,
			0.392157,
			0.683758,
			0.156278,
			0.57166,
			0.396078,
			0.688318,
			0.160709,
			0.568103,
			0.4,
			0.69284,
			0.165141,
			0.564522,
			0.403922,
			0.697324,
			0.169573,
			0.560919,
			0.407843,
			0.701769,
			0.174005,
			0.557296,
			0.411765,
			0.706178,
			0.178437,
			0.553657,
			0.415686,
			0.710549,
			0.182868,
			0.550004,
			0.419608,
			0.714883,
			0.187299,
			0.546338,
			0.423529,
			0.719181,
			0.191729,
			0.542663,
			0.427451,
			0.723444,
			0.196158,
			0.538981,
			0.431373,
			0.72767,
			0.200586,
			0.535293,
			0.435294,
			0.731862,
			0.205013,
			0.531601,
			0.439216,
			0.736019,
			0.209439,
			0.527908,
			0.443137,
			0.740143,
			0.213864,
			0.524216,
			0.447059,
			0.744232,
			0.218288,
			0.520524,
			0.45098,
			0.748289,
			0.222711,
			0.516834,
			0.454902,
			0.752312,
			0.227133,
			0.513149,
			0.458824,
			0.756304,
			0.231555,
			0.509468,
			0.462745,
			0.760264,
			0.235976,
			0.505794,
			0.466667,
			0.764193,
			0.240396,
			0.502126,
			0.470588,
			0.76809,
			0.244817,
			0.498465,
			0.47451,
			0.771958,
			0.249237,
			0.494813,
			0.478431,
			0.775796,
			0.253658,
			0.491171,
			0.482353,
			0.779604,
			0.258078,
			0.487539,
			0.486275,
			0.783383,
			0.2625,
			0.483918,
			0.490196,
			0.787133,
			0.266922,
			0.480307,
			0.494118,
			0.790855,
			0.271345,
			0.476706,
			0.498039,
			0.794549,
			0.27577,
			0.473117,
			0.501961,
			0.798216,
			0.280197,
			0.469538,
			0.505882,
			0.801855,
			0.284626,
			0.465971,
			0.509804,
			0.805467,
			0.289057,
			0.462415,
			0.513725,
			0.809052,
			0.293491,
			0.45887,
			0.517647,
			0.812612,
			0.297928,
			0.455338,
			0.521569,
			0.816144,
			0.302368,
			0.451816,
			0.52549,
			0.819651,
			0.306812,
			0.448306,
			0.529412,
			0.823132,
			0.311261,
			0.444806,
			0.533333,
			0.826588,
			0.315714,
			0.441316,
			0.537255,
			0.830018,
			0.320172,
			0.437836,
			0.541176,
			0.833422,
			0.324635,
			0.434366,
			0.545098,
			0.836801,
			0.329105,
			0.430905,
			0.54902,
			0.840155,
			0.33358,
			0.427455,
			0.552941,
			0.843484,
			0.338062,
			0.424013,
			0.556863,
			0.846788,
			0.342551,
			0.420579,
			0.560784,
			0.850066,
			0.347048,
			0.417153,
			0.564706,
			0.853319,
			0.351553,
			0.413734,
			0.568627,
			0.856547,
			0.356066,
			0.410322,
			0.572549,
			0.85975,
			0.360588,
			0.406917,
			0.576471,
			0.862927,
			0.365119,
			0.403519,
			0.580392,
			0.866078,
			0.36966,
			0.400126,
			0.584314,
			0.869203,
			0.374212,
			0.396738,
			0.588235,
			0.872303,
			0.378774,
			0.393355,
			0.592157,
			0.875376,
			0.383347,
			0.389976,
			0.596078,
			0.878423,
			0.387932,
			0.3866,
			0.6,
			0.881443,
			0.392529,
			0.383229,
			0.603922,
			0.884436,
			0.397139,
			0.37986,
			0.607843,
			0.887402,
			0.401762,
			0.376494,
			0.611765,
			0.89034,
			0.406398,
			0.37313,
			0.615686,
			0.89325,
			0.411048,
			0.369768,
			0.619608,
			0.896131,
			0.415712,
			0.366407,
			0.623529,
			0.898984,
			0.420392,
			0.363047,
			0.627451,
			0.901807,
			0.425087,
			0.359688,
			0.631373,
			0.904601,
			0.429797,
			0.356329,
			0.635294,
			0.907365,
			0.434524,
			0.35297,
			0.639216,
			0.910098,
			0.439268,
			0.34961,
			0.643137,
			0.9128,
			0.444029,
			0.346251,
			0.647059,
			0.915471,
			0.448807,
			0.34289,
			0.65098,
			0.918109,
			0.453603,
			0.339529,
			0.654902,
			0.920714,
			0.458417,
			0.336166,
			0.658824,
			0.923287,
			0.463251,
			0.332801,
			0.662745,
			0.925825,
			0.468103,
			0.329435,
			0.666667,
			0.928329,
			0.472975,
			0.326067,
			0.670588,
			0.930798,
			0.477867,
			0.322697,
			0.67451,
			0.933232,
			0.48278,
			0.319325,
			0.678431,
			0.93563,
			0.487712,
			0.315952,
			0.682353,
			0.93799,
			0.492667,
			0.312575,
			0.686275,
			0.940313,
			0.497642,
			0.309197,
			0.690196,
			0.942598,
			0.502639,
			0.305816,
			0.694118,
			0.944844,
			0.507658,
			0.302433,
			0.698039,
			0.947051,
			0.512699,
			0.299049,
			0.701961,
			0.949217,
			0.517763,
			0.295662,
			0.705882,
			0.951344,
			0.52285,
			0.292275,
			0.709804,
			0.953428,
			0.52796,
			0.288883,
			0.713725,
			0.95547,
			0.533093,
			0.28549,
			0.717647,
			0.957469,
			0.53825,
			0.282096,
			0.721569,
			0.959424,
			0.543431,
			0.278701,
			0.72549,
			0.961336,
			0.548636,
			0.275305,
			0.729412,
			0.963203,
			0.553865,
			0.271909,
			0.733333,
			0.965024,
			0.559118,
			0.268513,
			0.737255,
			0.966798,
			0.564396,
			0.265118,
			0.741176,
			0.968526,
			0.5697,
			0.261721,
			0.745098,
			0.970205,
			0.575028,
			0.258325,
			0.74902,
			0.971835,
			0.580382,
			0.254931,
			0.752941,
			0.973416,
			0.585761,
			0.25154,
			0.756863,
			0.974947,
			0.591165,
			0.248151,
			0.760784,
			0.976428,
			0.596595,
			0.244767,
			0.764706,
			0.977856,
			0.602051,
			0.241387,
			0.768627,
			0.979233,
			0.607532,
			0.238013,
			0.772549,
			0.980556,
			0.613039,
			0.234646,
			0.776471,
			0.981826,
			0.618572,
			0.231287,
			0.780392,
			0.983041,
			0.624131,
			0.227937,
			0.784314,
			0.984199,
			0.629718,
			0.224595,
			0.788235,
			0.985301,
			0.63533,
			0.221265,
			0.792157,
			0.986345,
			0.640969,
			0.217948,
			0.796078,
			0.987332,
			0.646633,
			0.214648,
			0.8,
			0.98826,
			0.652325,
			0.211364,
			0.803922,
			0.989128,
			0.658043,
			0.2081,
			0.807843,
			0.989935,
			0.663787,
			0.204859,
			0.811765,
			0.990681,
			0.669558,
			0.201642,
			0.815686,
			0.991365,
			0.675355,
			0.198453,
			0.819608,
			0.991985,
			0.681179,
			0.195295,
			0.823529,
			0.992541,
			0.68703,
			0.19217,
			0.827451,
			0.993032,
			0.692907,
			0.189084,
			0.831373,
			0.993456,
			0.69881,
			0.186041,
			0.835294,
			0.993814,
			0.704741,
			0.183043,
			0.839216,
			0.994103,
			0.710698,
			0.180097,
			0.843137,
			0.994324,
			0.716681,
			0.177208,
			0.847059,
			0.994474,
			0.722691,
			0.174381,
			0.85098,
			0.994553,
			0.728728,
			0.171622,
			0.854902,
			0.994561,
			0.734791,
			0.168938,
			0.858824,
			0.994495,
			0.74088,
			0.166335,
			0.862745,
			0.994355,
			0.746995,
			0.163821,
			0.866667,
			0.994141,
			0.753137,
			0.161404,
			0.870588,
			0.993851,
			0.759304,
			0.159092,
			0.87451,
			0.993482,
			0.765499,
			0.156891,
			0.878431,
			0.993033,
			0.77172,
			0.154808,
			0.882353,
			0.992505,
			0.777967,
			0.152855,
			0.886275,
			0.991897,
			0.784239,
			0.151042,
			0.890196,
			0.991209,
			0.790537,
			0.149377,
			0.894118,
			0.990439,
			0.796859,
			0.14787,
			0.898039,
			0.989587,
			0.803205,
			0.146529,
			0.901961,
			0.988648,
			0.809579,
			0.145357,
			0.905882,
			0.987621,
			0.815978,
			0.144363,
			0.909804,
			0.986509,
			0.822401,
			0.143557,
			0.913725,
			0.985314,
			0.828846,
			0.142945,
			0.917647,
			0.984031,
			0.835315,
			0.142528,
			0.921569,
			0.982653,
			0.841812,
			0.142303,
			0.92549,
			0.98119,
			0.848329,
			0.142279,
			0.929412,
			0.979644,
			0.854866,
			0.142453,
			0.933333,
			0.977995,
			0.861432,
			0.142808,
			0.937255,
			0.976265,
			0.868016,
			0.143351,
			0.941176,
			0.974443,
			0.874622,
			0.144061,
			0.945098,
			0.97253,
			0.88125,
			0.144923,
			0.94902,
			0.970533,
			0.887896,
			0.145919,
			0.952941,
			0.968443,
			0.894564,
			0.147014,
			0.956863,
			0.966271,
			0.901249,
			0.14818,
			0.960784,
			0.964021,
			0.90795,
			0.14937,
			0.964706,
			0.961681,
			0.914672,
			0.15052,
			0.968627,
			0.959276,
			0.921407,
			0.151566,
			0.972549,
			0.956808,
			0.928152,
			0.152409,
			0.976471,
			0.954287,
			0.934908,
			0.152921,
			0.980392,
			0.951726,
			0.941671,
			0.152925,
			0.984314,
			0.949151,
			0.948435,
			0.152178,
			0.988235,
			0.946602,
			0.95519,
			0.150328,
			0.992157,
			0.944152,
			0.961916,
			0.146861,
			0.996078,
			0.941896,
			0.96859,
			0.140956,
			1,
			0.940015,
			0.975158,
			0.131326
		]
	},
	{
		ColorSpace: "Diverging",
		Name: "Viridis (matplotlib)",
		NanColor: [
			1,
			0,
			0
		],
		Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
		License: "CC0",
		Creator: "Eric Firing",
		RGBPoints: [
			0,
			0.267004,
			0.004874,
			0.329415,
			0.003922,
			0.26851,
			0.009605,
			0.335427,
			0.007843,
			0.269944,
			0.014625,
			0.341379,
			0.011765,
			0.271305,
			0.019942,
			0.347269,
			0.015686,
			0.272594,
			0.025563,
			0.353093,
			0.019608,
			0.273809,
			0.031497,
			0.358853,
			0.023529,
			0.274952,
			0.037752,
			0.364543,
			0.027451,
			0.276022,
			0.044167,
			0.370164,
			0.031373,
			0.277018,
			0.050344,
			0.375715,
			0.035294,
			0.277941,
			0.056324,
			0.381191,
			0.039216,
			0.278791,
			0.062145,
			0.386592,
			0.043137,
			0.279566,
			0.067836,
			0.391917,
			0.047059,
			0.280267,
			0.073417,
			0.397163,
			0.05098,
			0.280894,
			0.078907,
			0.402329,
			0.054902,
			0.281446,
			0.08432,
			0.407414,
			0.058824,
			0.281924,
			0.089666,
			0.412415,
			0.062745,
			0.282327,
			0.094955,
			0.417331,
			0.066667,
			0.282656,
			0.100196,
			0.42216,
			0.070588,
			0.28291,
			0.105393,
			0.426902,
			0.07451,
			0.283091,
			0.110553,
			0.431554,
			0.078431,
			0.283197,
			0.11568,
			0.436115,
			0.082353,
			0.283229,
			0.120777,
			0.440584,
			0.086275,
			0.283187,
			0.125848,
			0.44496,
			0.090196,
			0.283072,
			0.130895,
			0.449241,
			0.094118,
			0.282884,
			0.13592,
			0.453427,
			0.098039,
			0.282623,
			0.140926,
			0.457517,
			0.101961,
			0.28229,
			0.145912,
			0.46151,
			0.105882,
			0.281887,
			0.150881,
			0.465405,
			0.109804,
			0.281412,
			0.155834,
			0.469201,
			0.113725,
			0.280868,
			0.160771,
			0.472899,
			0.117647,
			0.280255,
			0.165693,
			0.476498,
			0.121569,
			0.279574,
			0.170599,
			0.479997,
			0.12549,
			0.278826,
			0.17549,
			0.483397,
			0.129412,
			0.278012,
			0.180367,
			0.486697,
			0.133333,
			0.277134,
			0.185228,
			0.489898,
			0.137255,
			0.276194,
			0.190074,
			0.493001,
			0.141176,
			0.275191,
			0.194905,
			0.496005,
			0.145098,
			0.274128,
			0.199721,
			0.498911,
			0.14902,
			0.273006,
			0.20452,
			0.501721,
			0.152941,
			0.271828,
			0.209303,
			0.504434,
			0.156863,
			0.270595,
			0.214069,
			0.507052,
			0.160784,
			0.269308,
			0.218818,
			0.509577,
			0.164706,
			0.267968,
			0.223549,
			0.512008,
			0.168627,
			0.26658,
			0.228262,
			0.514349,
			0.172549,
			0.265145,
			0.232956,
			0.516599,
			0.176471,
			0.263663,
			0.237631,
			0.518762,
			0.180392,
			0.262138,
			0.242286,
			0.520837,
			0.184314,
			0.260571,
			0.246922,
			0.522828,
			0.188235,
			0.258965,
			0.251537,
			0.524736,
			0.192157,
			0.257322,
			0.25613,
			0.526563,
			0.196078,
			0.255645,
			0.260703,
			0.528312,
			0.2,
			0.253935,
			0.265254,
			0.529983,
			0.203922,
			0.252194,
			0.269783,
			0.531579,
			0.207843,
			0.250425,
			0.27429,
			0.533103,
			0.211765,
			0.248629,
			0.278775,
			0.534556,
			0.215686,
			0.246811,
			0.283237,
			0.535941,
			0.219608,
			0.244972,
			0.287675,
			0.53726,
			0.223529,
			0.243113,
			0.292092,
			0.538516,
			0.227451,
			0.241237,
			0.296485,
			0.539709,
			0.231373,
			0.239346,
			0.300855,
			0.540844,
			0.235294,
			0.237441,
			0.305202,
			0.541921,
			0.239216,
			0.235526,
			0.309527,
			0.542944,
			0.243137,
			0.233603,
			0.313828,
			0.543914,
			0.247059,
			0.231674,
			0.318106,
			0.544834,
			0.25098,
			0.229739,
			0.322361,
			0.545706,
			0.254902,
			0.227802,
			0.326594,
			0.546532,
			0.258824,
			0.225863,
			0.330805,
			0.547314,
			0.262745,
			0.223925,
			0.334994,
			0.548053,
			0.266667,
			0.221989,
			0.339161,
			0.548752,
			0.270588,
			0.220057,
			0.343307,
			0.549413,
			0.27451,
			0.21813,
			0.347432,
			0.550038,
			0.278431,
			0.21621,
			0.351535,
			0.550627,
			0.282353,
			0.214298,
			0.355619,
			0.551184,
			0.286275,
			0.212395,
			0.359683,
			0.55171,
			0.290196,
			0.210503,
			0.363727,
			0.552206,
			0.294118,
			0.208623,
			0.367752,
			0.552675,
			0.298039,
			0.206756,
			0.371758,
			0.553117,
			0.301961,
			0.204903,
			0.375746,
			0.553533,
			0.305882,
			0.203063,
			0.379716,
			0.553925,
			0.309804,
			0.201239,
			0.38367,
			0.554294,
			0.313725,
			0.19943,
			0.387607,
			0.554642,
			0.317647,
			0.197636,
			0.391528,
			0.554969,
			0.321569,
			0.19586,
			0.395433,
			0.555276,
			0.32549,
			0.1941,
			0.399323,
			0.555565,
			0.329412,
			0.192357,
			0.403199,
			0.555836,
			0.333333,
			0.190631,
			0.407061,
			0.556089,
			0.337255,
			0.188923,
			0.41091,
			0.556326,
			0.341176,
			0.187231,
			0.414746,
			0.556547,
			0.345098,
			0.185556,
			0.41857,
			0.556753,
			0.34902,
			0.183898,
			0.422383,
			0.556944,
			0.352941,
			0.182256,
			0.426184,
			0.55712,
			0.356863,
			0.180629,
			0.429975,
			0.557282,
			0.360784,
			0.179019,
			0.433756,
			0.55743,
			0.364706,
			0.177423,
			0.437527,
			0.557565,
			0.368627,
			0.175841,
			0.44129,
			0.557685,
			0.372549,
			0.174274,
			0.445044,
			0.557792,
			0.376471,
			0.172719,
			0.448791,
			0.557885,
			0.380392,
			0.171176,
			0.45253,
			0.557965,
			0.384314,
			0.169646,
			0.456262,
			0.55803,
			0.388235,
			0.168126,
			0.459988,
			0.558082,
			0.392157,
			0.166617,
			0.463708,
			0.558119,
			0.396078,
			0.165117,
			0.467423,
			0.558141,
			0.4,
			0.163625,
			0.471133,
			0.558148,
			0.403922,
			0.162142,
			0.474838,
			0.55814,
			0.407843,
			0.160665,
			0.47854,
			0.558115,
			0.411765,
			0.159194,
			0.482237,
			0.558073,
			0.415686,
			0.157729,
			0.485932,
			0.558013,
			0.419608,
			0.15627,
			0.489624,
			0.557936,
			0.423529,
			0.154815,
			0.493313,
			0.55784,
			0.427451,
			0.153364,
			0.497,
			0.557724,
			0.431373,
			0.151918,
			0.500685,
			0.557587,
			0.435294,
			0.150476,
			0.504369,
			0.55743,
			0.439216,
			0.149039,
			0.508051,
			0.55725,
			0.443137,
			0.147607,
			0.511733,
			0.557049,
			0.447059,
			0.14618,
			0.515413,
			0.556823,
			0.45098,
			0.144759,
			0.519093,
			0.556572,
			0.454902,
			0.143343,
			0.522773,
			0.556295,
			0.458824,
			0.141935,
			0.526453,
			0.555991,
			0.462745,
			0.140536,
			0.530132,
			0.555659,
			0.466667,
			0.139147,
			0.533812,
			0.555298,
			0.470588,
			0.13777,
			0.537492,
			0.554906,
			0.47451,
			0.136408,
			0.541173,
			0.554483,
			0.478431,
			0.135066,
			0.544853,
			0.554029,
			0.482353,
			0.133743,
			0.548535,
			0.553541,
			0.486275,
			0.132444,
			0.552216,
			0.553018,
			0.490196,
			0.131172,
			0.555899,
			0.552459,
			0.494118,
			0.129933,
			0.559582,
			0.551864,
			0.498039,
			0.128729,
			0.563265,
			0.551229,
			0.501961,
			0.127568,
			0.566949,
			0.550556,
			0.505882,
			0.126453,
			0.570633,
			0.549841,
			0.509804,
			0.125394,
			0.574318,
			0.549086,
			0.513725,
			0.124395,
			0.578002,
			0.548287,
			0.517647,
			0.123463,
			0.581687,
			0.547445,
			0.521569,
			0.122606,
			0.585371,
			0.546557,
			0.52549,
			0.121831,
			0.589055,
			0.545623,
			0.529412,
			0.121148,
			0.592739,
			0.544641,
			0.533333,
			0.120565,
			0.596422,
			0.543611,
			0.537255,
			0.120092,
			0.600104,
			0.54253,
			0.541176,
			0.119738,
			0.603785,
			0.5414,
			0.545098,
			0.119512,
			0.607464,
			0.540218,
			0.54902,
			0.119423,
			0.611141,
			0.538982,
			0.552941,
			0.119483,
			0.614817,
			0.537692,
			0.556863,
			0.119699,
			0.61849,
			0.536347,
			0.560784,
			0.120081,
			0.622161,
			0.534946,
			0.564706,
			0.120638,
			0.625828,
			0.533488,
			0.568627,
			0.12138,
			0.629492,
			0.531973,
			0.572549,
			0.122312,
			0.633153,
			0.530398,
			0.576471,
			0.123444,
			0.636809,
			0.528763,
			0.580392,
			0.12478,
			0.640461,
			0.527068,
			0.584314,
			0.126326,
			0.644107,
			0.525311,
			0.588235,
			0.128087,
			0.647749,
			0.523491,
			0.592157,
			0.130067,
			0.651384,
			0.521608,
			0.596078,
			0.132268,
			0.655014,
			0.519661,
			0.6,
			0.134692,
			0.658636,
			0.517649,
			0.603922,
			0.137339,
			0.662252,
			0.515571,
			0.607843,
			0.14021,
			0.665859,
			0.513427,
			0.611765,
			0.143303,
			0.669459,
			0.511215,
			0.615686,
			0.146616,
			0.67305,
			0.508936,
			0.619608,
			0.150148,
			0.676631,
			0.506589,
			0.623529,
			0.153894,
			0.680203,
			0.504172,
			0.627451,
			0.157851,
			0.683765,
			0.501686,
			0.631373,
			0.162016,
			0.687316,
			0.499129,
			0.635294,
			0.166383,
			0.690856,
			0.496502,
			0.639216,
			0.170948,
			0.694384,
			0.493803,
			0.643137,
			0.175707,
			0.6979,
			0.491033,
			0.647059,
			0.180653,
			0.701402,
			0.488189,
			0.65098,
			0.185783,
			0.704891,
			0.485273,
			0.654902,
			0.19109,
			0.708366,
			0.482284,
			0.658824,
			0.196571,
			0.711827,
			0.479221,
			0.662745,
			0.202219,
			0.715272,
			0.476084,
			0.666667,
			0.20803,
			0.718701,
			0.472873,
			0.670588,
			0.214,
			0.722114,
			0.469588,
			0.67451,
			0.220124,
			0.725509,
			0.466226,
			0.678431,
			0.226397,
			0.728888,
			0.462789,
			0.682353,
			0.232815,
			0.732247,
			0.459277,
			0.686275,
			0.239374,
			0.735588,
			0.455688,
			0.690196,
			0.24607,
			0.73891,
			0.452024,
			0.694118,
			0.252899,
			0.742211,
			0.448284,
			0.698039,
			0.259857,
			0.745492,
			0.444467,
			0.701961,
			0.266941,
			0.748751,
			0.440573,
			0.705882,
			0.274149,
			0.751988,
			0.436601,
			0.709804,
			0.281477,
			0.755203,
			0.432552,
			0.713725,
			0.288921,
			0.758394,
			0.428426,
			0.717647,
			0.296479,
			0.761561,
			0.424223,
			0.721569,
			0.304148,
			0.764704,
			0.419943,
			0.72549,
			0.311925,
			0.767822,
			0.415586,
			0.729412,
			0.319809,
			0.770914,
			0.411152,
			0.733333,
			0.327796,
			0.77398,
			0.40664,
			0.737255,
			0.335885,
			0.777018,
			0.402049,
			0.741176,
			0.344074,
			0.780029,
			0.397381,
			0.745098,
			0.35236,
			0.783011,
			0.392636,
			0.74902,
			0.360741,
			0.785964,
			0.387814,
			0.752941,
			0.369214,
			0.788888,
			0.382914,
			0.756863,
			0.377779,
			0.791781,
			0.377939,
			0.760784,
			0.386433,
			0.794644,
			0.372886,
			0.764706,
			0.395174,
			0.797475,
			0.367757,
			0.768627,
			0.404001,
			0.800275,
			0.362552,
			0.772549,
			0.412913,
			0.803041,
			0.357269,
			0.776471,
			0.421908,
			0.805774,
			0.35191,
			0.780392,
			0.430983,
			0.808473,
			0.346476,
			0.784314,
			0.440137,
			0.811138,
			0.340967,
			0.788235,
			0.449368,
			0.813768,
			0.335384,
			0.792157,
			0.458674,
			0.816363,
			0.329727,
			0.796078,
			0.468053,
			0.818921,
			0.323998,
			0.8,
			0.477504,
			0.821444,
			0.318195,
			0.803922,
			0.487026,
			0.823929,
			0.312321,
			0.807843,
			0.496615,
			0.826376,
			0.306377,
			0.811765,
			0.506271,
			0.828786,
			0.300362,
			0.815686,
			0.515992,
			0.831158,
			0.294279,
			0.819608,
			0.525776,
			0.833491,
			0.288127,
			0.823529,
			0.535621,
			0.835785,
			0.281908,
			0.827451,
			0.545524,
			0.838039,
			0.275626,
			0.831373,
			0.555484,
			0.840254,
			0.269281,
			0.835294,
			0.565498,
			0.84243,
			0.262877,
			0.839216,
			0.575563,
			0.844566,
			0.256415,
			0.843137,
			0.585678,
			0.846661,
			0.249897,
			0.847059,
			0.595839,
			0.848717,
			0.243329,
			0.85098,
			0.606045,
			0.850733,
			0.236712,
			0.854902,
			0.616293,
			0.852709,
			0.230052,
			0.858824,
			0.626579,
			0.854645,
			0.223353,
			0.862745,
			0.636902,
			0.856542,
			0.21662,
			0.866667,
			0.647257,
			0.8584,
			0.209861,
			0.870588,
			0.657642,
			0.860219,
			0.203082,
			0.87451,
			0.668054,
			0.861999,
			0.196293,
			0.878431,
			0.678489,
			0.863742,
			0.189503,
			0.882353,
			0.688944,
			0.865448,
			0.182725,
			0.886275,
			0.699415,
			0.867117,
			0.175971,
			0.890196,
			0.709898,
			0.868751,
			0.169257,
			0.894118,
			0.720391,
			0.87035,
			0.162603,
			0.898039,
			0.730889,
			0.871916,
			0.156029,
			0.901961,
			0.741388,
			0.873449,
			0.149561,
			0.905882,
			0.751884,
			0.874951,
			0.143228,
			0.909804,
			0.762373,
			0.876424,
			0.137064,
			0.913725,
			0.772852,
			0.877868,
			0.131109,
			0.917647,
			0.783315,
			0.879285,
			0.125405,
			0.921569,
			0.79376,
			0.880678,
			0.120005,
			0.92549,
			0.804182,
			0.882046,
			0.114965,
			0.929412,
			0.814576,
			0.883393,
			0.110347,
			0.933333,
			0.82494,
			0.88472,
			0.106217,
			0.937255,
			0.83527,
			0.886029,
			0.102646,
			0.941176,
			0.845561,
			0.887322,
			0.099702,
			0.945098,
			0.85581,
			0.888601,
			0.097452,
			0.94902,
			0.866013,
			0.889868,
			0.095953,
			0.952941,
			0.876168,
			0.891125,
			0.09525,
			0.956863,
			0.886271,
			0.892374,
			0.095374,
			0.960784,
			0.89632,
			0.893616,
			0.096335,
			0.964706,
			0.906311,
			0.894855,
			0.098125,
			0.968627,
			0.916242,
			0.896091,
			0.100717,
			0.972549,
			0.926106,
			0.89733,
			0.104071,
			0.976471,
			0.935904,
			0.89857,
			0.108131,
			0.980392,
			0.945636,
			0.899815,
			0.112838,
			0.984314,
			0.9553,
			0.901065,
			0.118128,
			0.988235,
			0.964894,
			0.902323,
			0.123941,
			0.992157,
			0.974417,
			0.90359,
			0.130215,
			0.996078,
			0.983868,
			0.904867,
			0.136897,
			1,
			0.993248,
			0.906157,
			0.143936
		]
	},
	{
		ShowIndexedColorActiveValues: 1,
		IndexedColors: [
			0.07,
			0.5,
			0.7,
			1,
			1,
			1,
			0.85,
			1,
			1,
			0.8,
			0.5,
			1,
			0.76,
			1,
			0,
			1,
			0.71,
			0.71,
			0.5,
			0.5,
			0.5,
			0.05,
			0.05,
			1,
			1,
			0.05,
			0.05,
			0.7,
			1,
			1,
			0.7,
			0.89,
			0.96,
			0.67,
			0.36,
			0.95,
			0.54,
			1,
			0,
			0.75,
			0.65,
			0.65,
			0.5,
			0.6,
			0.6,
			1,
			0.5,
			0,
			1,
			1,
			0.19,
			0.12,
			0.94,
			0.12,
			0.5,
			0.82,
			0.89,
			0.56,
			0.25,
			0.83,
			0.24,
			1,
			0,
			0.9,
			0.9,
			0.9,
			0.75,
			0.76,
			0.78,
			0.65,
			0.65,
			0.67,
			0.54,
			0.6,
			0.78,
			0.61,
			0.48,
			0.78,
			0.5,
			0.48,
			0.78,
			0.44,
			0.48,
			0.78,
			0.36,
			0.48,
			0.76,
			1,
			0.48,
			0.38,
			0.49,
			0.5,
			0.69,
			0.76,
			0.56,
			0.56,
			0.4,
			0.56,
			0.56,
			0.74,
			0.5,
			0.89,
			1,
			0.63,
			0,
			0.65,
			0.16,
			0.16,
			0.36,
			0.72,
			0.82,
			0.44,
			0.18,
			0.69,
			0,
			1,
			0,
			0.58,
			1,
			1,
			0.58,
			0.88,
			0.88,
			0.45,
			0.76,
			0.79,
			0.33,
			0.71,
			0.71,
			0.23,
			0.62,
			0.62,
			0.14,
			0.56,
			0.56,
			0.04,
			0.49,
			0.55,
			0,
			0.41,
			0.52,
			0.88,
			0.88,
			1,
			1,
			0.85,
			0.56,
			0.65,
			0.46,
			0.45,
			0.4,
			0.5,
			0.5,
			0.62,
			0.39,
			0.71,
			0.83,
			0.48,
			0,
			0.58,
			0,
			0.58,
			0.26,
			0.62,
			0.69,
			0.34,
			0.09,
			0.56,
			0,
			0.79,
			0,
			0.44,
			0.83,
			1,
			1,
			1,
			0.78,
			0.85,
			1,
			0.78,
			0.78,
			1,
			0.78,
			0.64,
			1,
			0.78,
			0.56,
			1,
			0.78,
			0.38,
			1,
			0.78,
			0.27,
			1,
			0.78,
			0.19,
			1,
			0.78,
			0.12,
			1,
			0.78,
			0,
			1,
			0.61,
			0,
			0.9,
			0.46,
			0,
			0.83,
			0.32,
			0,
			0.75,
			0.22,
			0,
			0.67,
			0.14,
			0.3,
			0.76,
			1,
			0.3,
			0.65,
			1,
			0.13,
			0.58,
			0.84,
			0.15,
			0.49,
			0.67,
			0.15,
			0.4,
			0.59,
			0.09,
			0.33,
			0.53,
			0.96,
			0.93,
			0.82,
			0.8,
			0.82,
			0.12,
			0.71,
			0.71,
			0.76,
			0.65,
			0.33,
			0.3,
			0.34,
			0.35,
			0.38,
			0.62,
			0.31,
			0.71,
			0.67,
			0.36,
			0,
			0.46,
			0.31,
			0.27,
			0.26,
			0.51,
			0.59,
			0.26,
			0,
			0.4,
			0,
			0.49,
			0,
			0.44,
			0.67,
			0.98,
			0,
			0.73,
			1,
			0,
			0.63,
			1,
			0,
			0.56,
			1,
			0,
			0.5,
			1,
			0,
			0.42,
			1,
			0.33,
			0.36,
			0.95,
			0.47,
			0.36,
			0.89,
			0.54,
			0.31,
			0.89,
			0.63,
			0.21,
			0.83,
			0.7,
			0.12,
			0.83,
			0.7,
			0.12,
			0.73,
			0.7,
			0.05,
			0.65,
			0.74,
			0.05,
			0.53,
			0.78,
			0,
			0.4,
			0.8,
			0,
			0.35,
			0.82,
			0,
			0.31,
			0.85,
			0,
			0.27,
			0.88,
			0,
			0.22,
			0.9,
			0,
			0.18,
			0.91,
			0,
			0.15,
			0.92,
			0,
			0.14,
			0.93,
			0,
			0.13,
			0.94,
			0,
			0.12,
			0.95,
			0,
			0.11,
			0.96,
			0,
			0.1,
			0.97,
			0,
			0.09,
			0.98,
			0,
			0.08,
			0.99,
			0,
			0.07,
			1,
			0,
			0.06
		],
		Annotations: [
			0,
			"Xx",
			1,
			"H",
			2,
			"He",
			3,
			"Li",
			4,
			"Be",
			5,
			"B",
			6,
			"C",
			7,
			"N",
			8,
			"O",
			9,
			"F",
			10,
			"Ne",
			11,
			"Na",
			12,
			"Mg",
			13,
			"Al",
			14,
			"Si",
			15,
			"P",
			16,
			"S",
			17,
			"Cl",
			18,
			"Ar",
			19,
			"K",
			20,
			"Ca",
			21,
			"Sc",
			22,
			"Ti",
			23,
			"V",
			24,
			"Cr",
			25,
			"Mn",
			26,
			"Fe",
			27,
			"Co",
			28,
			"Ni",
			29,
			"Cu",
			30,
			"Zn",
			31,
			"Ga",
			32,
			"Ge",
			33,
			"As",
			34,
			"Se",
			35,
			"Br",
			36,
			"Kr",
			37,
			"Rb",
			38,
			"Sr",
			39,
			"Y",
			40,
			"Zr",
			41,
			"Nb",
			42,
			"Mo",
			43,
			"Tc",
			44,
			"Ru",
			45,
			"Rh",
			46,
			"Pd",
			47,
			"Ag",
			48,
			"Cd",
			49,
			"In",
			50,
			"Sn",
			51,
			"Sb",
			52,
			"Te",
			53,
			"I",
			54,
			"Xe",
			55,
			"Cs",
			56,
			"Ba",
			57,
			"La",
			58,
			"Ce",
			59,
			"Pr",
			60,
			"Nd",
			61,
			"Pm",
			62,
			"Sm",
			63,
			"Eu",
			64,
			"Gd",
			65,
			"Tb",
			66,
			"Dy",
			67,
			"Ho",
			68,
			"Er",
			69,
			"Tm",
			70,
			"Yb",
			71,
			"Lu",
			72,
			"Hf",
			73,
			"Ta",
			74,
			"W",
			75,
			"Re",
			76,
			"Os",
			77,
			"Ir",
			78,
			"Pt",
			79,
			"Au",
			80,
			"Hg",
			81,
			"Tl",
			82,
			"Pb",
			83,
			"Bi",
			84,
			"Po",
			85,
			"At",
			86,
			"Rn",
			87,
			"Fr",
			88,
			"Ra",
			89,
			"Ac",
			90,
			"Th",
			91,
			"Pa",
			92,
			"U",
			93,
			"Np",
			94,
			"Pu",
			95,
			"Am",
			96,
			"Cm",
			97,
			"Bk",
			98,
			"Cf",
			99,
			"Es",
			100,
			"Fm",
			101,
			"Md",
			102,
			"No",
			103,
			"Lr",
			104,
			"Rf",
			105,
			"Db",
			106,
			"Sg",
			107,
			"Bh",
			108,
			"Hs",
			109,
			"Mt",
			110,
			"Ds",
			111,
			"Rg",
			112,
			"Cn",
			113,
			"Uut",
			114,
			"Uuq",
			115,
			"Uup",
			116,
			"Uuh",
			117,
			"Uus",
			118,
			"Uuo"
		],
		Name: "BlueObeliskElements"
	}
];



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js


const presetMap = Object.create(null);
vtkColorMaps.filter(p => p.RGBPoints).filter(p => p.ColorSpace !== 'CIELAB').forEach(p => {
  presetMap[p.Name] = p;
});

// ----------------------------------------------------------------------------

const rgbPresetNames = Object.keys(presetMap);
rgbPresetNames.sort();

// ----------------------------------------------------------------------------

function getPresetByName(name) {
  return presetMap[name];
}

// ----------------------------------------------------------------------------

function addPreset(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === 'CIELAB') {
    return;
  }
  if (!presetMap[preset.Name]) {
    rgbPresetNames.push(preset.Name);
    rgbPresetNames.sort();
  }
  presetMap[preset.Name] = preset;
}

// ----------------------------------------------------------------------------

function removePresetByName(name) {
  const index = rgbPresetNames.indexOf(name);
  if (index > -1) {
    rgbPresetNames.splice(index, 1);
  }
  delete presetMap[name];
}

// ----------------------------------------------------------------------------

var ColorMaps_vtkColorMaps = {
  addPreset,
  removePresetByName,
  getPresetByName,
  rgbPresetNames
};




/***/ }),

/***/ 25128:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants)
/* harmony export */ });
/* unused harmony exports ColorSpace, Scale */
const ColorSpace = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
const Scale = {
  LINEAR: 0,
  LOG10: 1
};
var Constants = {
  ColorSpace,
  Scale
};




/***/ }),

/***/ 94520:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants)
/* harmony export */ });
/* unused harmony export SlicingMode */
const SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants = {
  SlicingMode
};




/***/ }),

/***/ 91732:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   V: () => (/* binding */ InterpolationType)
/* harmony export */ });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1
};
var Constants = {
  InterpolationType
};




/***/ }),

/***/ 82409:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkMapper$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68076);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Common_DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58498);
/* harmony import */ var _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72879);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16632);
/* harmony import */ var _Common_Core_ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62955);
/* harmony import */ var _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57285);
/* harmony import */ var _Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33395);
/* harmony import */ var _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69147);
/* harmony import */ var _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(57703);












const {
  FieldAssociations
} = _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Ay;
const {
  staticOffsetAPI,
  otherStaticMethods
} = _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay;
const {
  ColorMode,
  ScalarMode,
  GetArray
} = _Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Ay;
const {
  VectorMode
} = _Common_Core_ScalarsToColors_Constants_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay;
const {
  VtkDataTypes
} = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------

function notImplemented(method) {
  return () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}

/**
 * Increase by one the 3D coordinates
 * It will follow a zigzag pattern so that each coordinate is the neighbor of the next coordinate
 * This enables interpolation between two texels without issues
 * Note: texture coordinates can't be interpolated using this pattern
 * @param {vec3} coordinates The 3D coordinates using integers for each coorinate
 * @param {vec3} dimensions The 3D dimensions of the volume
 */
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}

/**
 * Returns the index in the array representing the volume from a 3D coordinate
 * @param {vec3} coordinates The 3D integer coordinates
 * @param {vec3} dimensions The 3D dimensions of the volume
 * @returns The index in a flat array representing the volume
 */
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}

/**
 * Write texture coordinates for the given `texelIndexPosition` in `textureCoordinate`.
 * The `texelIndexPosition` is a floating point number that represents the distance in index space
 * from the center of the first texel to the final output position.
 * The output is given in texture coordinates and not in index coordinates (this is done at the very end of the function)
 * @param {vec3} textureCoordinate The output texture coordinates (to avoid allocating a new Array)
 * @param {Number} texelIndexPosition The floating point distance from the center of the first texel, following a zigzag pattern
 * @param {vec3} dimensions The 3D dimensions of the volume
 */
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  // First compute the integer textureCoordinate
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);

  // Now add the remainder either in x, y or z
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }

  // textureCoordinates are in index space, convert to texture space
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}

// Associate an input vtkDataArray to an object { stringHash, textureCoordinates }
// A single dataArray only caches one array of texture coordinates, so this cache is useless when
// the input data array is used with two different lookup tables (which is very unlikely)
const colorTextureCoordinatesCache = new WeakMap();
/**
 * The minimum of the range is mapped to the center of the first texel excluding min texel (texel at index distance 1)
 * The maximum of the range is mapped to the center of the last texel excluding max and NaN texels (texel at index distance numberOfColorsInRange)
 * The result is cached, and is reused if the arguments are the same and the input doesn't change
 * @param {vtkDataArray} input The input data array used for coloring
 * @param {Number} component The component of the input data array that is used for coloring (-1 for magnitude of the vectors)
 * @param {Range} range The range of the scalars
 * @param {Number} numberOfColorsInRange The number of colors that are used in the range
 * @param {vec3} dimensions The dimensions of the texture
 * @param {boolean} useLogScale If log scale should be used to transform input scalars
 * @param {boolean} useZigzagPattern If a zigzag pattern should be used. Otherwise 1 row for colors (including min and max) and 1 row for NaN are used.
 * @returns A vtkDataArray containing the texture coordinates (2D or 3D)
 */
function getOrCreateColorTextureCoordinates(input, component, range, numberOfColorsInRange, dimensions, useLogScale, useZigzagPattern) {
  // Caching using the "arguments" special object (because it is a pure function)
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
    // eslint-disable-next-line prefer-rest-params
    const arg = arguments[argIndex];
    argStrings[argIndex] = arg.getMTime?.() ?? arg;
  }
  const stringHash = argStrings.join('/');
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }

  // The range used for computing coordinates have to change
  // slightly to accommodate the special above- and below-range
  // colors that are the first and last texels, respectively.
  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];

  // Use the center of the voxel
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1.0 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);

  // Compute in index space first
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  // Distance of NaN from the beginning:
  // min: 0, ...colorsInRange, max: numberOfColorsInRange + 1, NaN = numberOfColorsInRange + 2
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);

  // Set a texture coordinate in the output for each tuple in the input
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
    // Get scalar value from magnitude or a single component
    let scalarValue;
    if (useMagnitude) {
      let sum = 0;
      for (let compIdx = 0; compIdx < numComps; ++compIdx) {
        const compValue = inputV[inputIdx + compIdx];
        sum += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum);
    } else {
      scalarValue = inputV[inputIdx + component];
    }
    inputIdx += numComps;

    // Apply log scale if necessary
    if (useLogScale) {
      scalarValue = _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.applyLogScale(scalarValue, range, range);
    }

    // Convert to texture coordinates and update output
    if ((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__.i)(scalarValue)) {
      // Last texels are NaN colors (there is at least one NaN color)
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      // Texel position is in [0, numberOfColorsInRange + 1]
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        // Use min color when smaller than range
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        // Use max color when greater than range
        texelIndexPosition = numberOfColorsInRange + 1;
      }

      // Convert the texel position into texture coordinate following a zigzag pattern
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?
      // Because when you are mapping scalars and you have a NaN adjacent to
      // anything else, the interpolation everywhere should be NaN.  Thus, I
      // want the NaN color everywhere except right on the non-NaN neighbors.
      // To simulate this, I set the t coord for the real numbers close to
      // the threshold so that the interpolation almost immediately looks up
      // the NaN value.
      textureCoordinate[1] = 0.49;

      // Some implementations apparently don't handle relatively large
      // numbers (compared to the range [0.0, 1.0]) very well. In fact,
      // values above 1122.0f appear to cause texture wrap-around on
      // some systems even when edge clamping is enabled. Why 1122.0f? I
      // don't know. For safety, we'll clamp at +/- 1000. This will
      // result in incorrect images when the texture value should be
      // above or below 1000, but I don't have a better solution.
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1000.0) {
        textureCoordinate[0] = 1000.0;
      } else if (textureS < -1000.0) {
        textureCoordinate[0] = -1000.0;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0; i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}

// ----------------------------------------------------------------------------
// vtkMapper methods
// ----------------------------------------------------------------------------

function vtkMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkMapper');
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_5__.H)();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = v => {
    model.forceCompileOnly = v;
    // make sure we do NOT call modified()
  };

  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
    // make sure we do NOT call modified()
    // this attribute is only used when processing a selection made with the hardware selector
    // the mtime of the mapper doesn't need to be changed
  };

  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance();
  };
  publicAPI.getColorModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(ColorMode, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(ScalarMode, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    // make sure we have an input
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;

    // get and scalar data according to scalar mode
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }

    // we want to only recompute when something has changed
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString) return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }

    // Decide between texture color or vertex color.
    // Cell data always uses vertex color.
    // Only point data can use both texture and vertex coloring.
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        // Ensure that the lookup table is built
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };

  // Protected method
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      // convert range to log.
      _Common_Core_LookupTable_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Ay.getLogRange(range, range);
    }
    const origAlpha = model.lookupTable.getAlpha();

    // Get rid of vertex color array.  Only texture or vertex coloring
    // can be active at one time.  The existence of the array is the
    // signal to use that technique.
    model.colorMapColors = null;

    // If the lookup table has changed, then recreate the color texture map.
    // Set a new lookup table changes this->MTime.
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;

      // Get the texture map from the lookup table.
      // Create a dummy ramp of scalars.
      // In the future, we could extend vtkScalarsToColors.
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();

      // Maximum dimensions and number of colors in range
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3; // 3D but keep a color for min, max and NaN
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2; // 1D but keep a color for min and max (NaN is in a different row)
      // Minimum number of colors in range (excluding special colors like minColor, maxColor and NaNColor)
      const minColorsInRange = 2;
      // Maximum number of colors, limited by the maximum possible texture size
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3; // Add min, max and NaN
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2; // Add min and max ; the lower row will be used for NaN color
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);

      // Colors for NaN by default
      scalarsArray.fill(NaN);

      // Colors in range
      // Add 2 to also get color for min and max
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = range[0];
      const rangeDifference = range[1] - range[0];
      for (let i = 0; i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);

        // Minus 1 start at min color
        const scalarValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        scalarsArray[scalarsArrayIndex] = useLogScale ? 10.0 ** scalarValue : scalarValue;

        // Colors are zigzagging to allow interpolation between two neighbor colors when coloring cells
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = _Common_DataModel_ImageData_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }

    // Although I like the feature of applying magnitude to single component
    // scalars, it is not how the old MapScalars for vertex coloring works.
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();

    // Create new coordinates if necessary, this function uses cache if possible.
    // A zigzag pattern can't be used with point data, as interpolation of texture coordinates will be wrong
    // A zigzag pattern can be used with cell data, as there will be no texture coordinates interpolation
    // The texture generated using a zigzag pattern in one dimension is the same as without zigzag
    // Therefore, the same code can be used for texture generation of point/cell data but not for texture coordinates
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, range, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), useLogScale, cellFlag);
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      // No scalar colors.
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {
      return true; // cell data always use textures.
    }

    if (!model.interpolateScalarsBeforeMapping) {
      return false; // user doesn't want us to use texture maps at all.
    }

    // index color does not use textures
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      // no scalars on this dataset, we don't care if texture is used at all.
      return false;
    }
    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {
      // Don't use texture is direct coloring using RGB unsigned chars is
      // requested.
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');
  publicAPI.valueToColor = notImplemented('ValueToColor');
  publicAPI.colorToValue = notImplemented('ColorToValue');
  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');
  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    /* eslint-disable no-bitwise */
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach(pos => {
      if (currentPass === _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_LOW24);
        lowData[pos] = outValue & 0xff;
        lowData[pos + 1] = (outValue & 0xff00) >> 8;
        lowData[pos + 2] = (outValue & 0xff0000) >> 16;
      } else if (currentPass === _OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(_OpenGL_HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .PassTypes */ .T.ID_HIGH24);
        highData[pos] = (outValue & 0xff000000) >> 24;
      }
    });
    /* eslint-enable no-bitwise */
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  colorMapColors: null,
  // Same as this->Colors
  areScalarsMappedFromCells: false,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME

  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  numberOfColorsInRange: 0,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .A.extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['areScalarsMappedFromCells', 'colorCoordinates', 'colorMapColors', 'colorTextureMap', 'numberOfColorsInRange', 'selectionWebGLIdsToVTKIds']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO
  ]);

  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['scalarRange'], 2);
  _Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay.implementCoincidentTopologyMethods(publicAPI, model);

  // Object methods
  vtkMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkMapper');

// ----------------------------------------------------------------------------

var vtkMapper$1 = {
  newInstance,
  extend,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ..._Mapper_Constants_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Ay
};




/***/ }),

/***/ 57285:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ CoincidentTopologyHelper)
/* harmony export */ });
/* unused harmony export CATEGORIES */
/* harmony import */ var _Static_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7698);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);




/* eslint-disable arrow-body-style */
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach(item => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.objectSetterMap.object(publicAPI, model, {
      name: item.key,
      params: ['factor', 'offset']
    });
  });
}
const CATEGORIES = ['Polygon', 'Line', 'Point'];

// CoincidentTopology static methods ------------------------------------------

const staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
const noOp = () => undefined;
const staticOffsetAPI = {
  modified: noOp
};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(key => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === undefined) {
    model.resolveCoincidentTopology = false;
  }
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['resolveCoincidentTopology']);

  // Relative methods
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };

  // Add Static methods to our instance
  Object.keys(_Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay).forEach(methodName => {
    publicAPI[methodName] = _Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay[methodName];
  });
  Object.keys(staticOffsetAPI).filter(methodName => methodName !== 'modified') // don't override instance's modified
  .forEach(methodName => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(key => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods: _Static_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Ay,
  CATEGORIES,
  Resolve: _Static_js__WEBPACK_IMPORTED_MODULE_0__/* .Resolve */ .XK
};




/***/ }),

/***/ 33395:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants)
/* harmony export */ });
/* unused harmony exports ColorMode, GetArray, ScalarMode */
const ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
const ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
const GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants = {
  ColorMode,
  GetArray,
  ScalarMode
};




/***/ }),

/***/ 7698:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ otherStaticMethods),
/* harmony export */   XK: () => (/* binding */ Resolve)
/* harmony export */ });
/* unused harmony exports RESOLVE_COINCIDENT_TOPOLOGY_MODE, getResolveCoincidentTopology, getResolveCoincidentTopologyAsString, getResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopology, setResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopologyToDefault, setResolveCoincidentTopologyToOff, setResolveCoincidentTopologyToPolygonOffset */
const Resolve = {
  Off: 0,
  PolygonOffset: 1
};
let resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
let resolveCoincidentTopology = Resolve.Off;
const RESOLVE_COINCIDENT_TOPOLOGY_MODE = ['VTK_RESOLVE_OFF', 'VTK_RESOLVE_POLYGON_OFFSET'];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
  resolveCoincidentTopologyPolygonOffsetFaces = value;
  return changed;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  const changed = resolveCoincidentTopology === mode;
  resolveCoincidentTopology = mode;
  return changed;
}
function setResolveCoincidentTopologyToDefault() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToOff() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  return setResolveCoincidentTopology(Resolve.PolygonOffset);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  Resolve,
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};




/***/ }),

/***/ 46985:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkProp$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
const CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants = {
  CoordinateSystem
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Prop.js



const {
  CoordinateSystem: Prop_CoordinateSystem
} = Constants;
function notImplemented(method) {
  return () => macros2.m.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProp methods
// ----------------------------------------------------------------------------

function vtkProp(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp');
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0; index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {};
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented('pick');
  publicAPI.hasKey = notImplemented('hasKey');
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = t => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = t => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = t => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = texture => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = texture => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = texture => {
    const newTextureList = model.textures.filter(item => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };

  // not all mappers support all coordinate systems
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(Prop_CoordinateSystem.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(Prop_CoordinateSystem.DISPLAY);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: Prop_CoordinateSystem.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['estimatedRenderTime', 'allocatedRenderTime']);
  macros2.m.setGet(publicAPI, model, ['_parentProp', 'coordinateSystem', 'dragable', 'pickable', 'renderTimeMultiplier', 'useBounds', 'visibility']);
  macros2.m.moveToProtected(publicAPI, model, ['parentProp']);

  // Object methods
  vtkProp(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkProp');

// ----------------------------------------------------------------------------

var vtkProp$1 = {
  newInstance,
  extend,
  ...Constants
};




/***/ }),

/***/ 62502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkProp3D$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21734);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16632);
/* harmony import */ var _Prop_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46985);






const VTK_EPSILON = 1e-6;

// ----------------------------------------------------------------------------
// vtkProp3D methods
// ----------------------------------------------------------------------------

function vtkProp3D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp3D');
  publicAPI.addPosition = deltaXYZ => {
    model.position = model.position.map((value, index) => value + deltaXYZ[index]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.getRotation */ .pB.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.getAxisAngle */ .Yu.getAxisAngle(oaxis, q);
    return [(0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.A)(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function () {
    let out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.getRotation */ .pB.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateX */ .pB.rotateX(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateY */ .pB.rotateY(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = val => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.rotateZ */ .pB.rotateZ(model.rotation, model.rotation, (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0.0 || x === 0.0 && y === 0.0 && z === 0.0) {
      return;
    }

    // convert to radians
    const angle = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.r)(degrees);
    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.create */ .Yu.create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .quat.setAxisAngle */ .Yu.setAxisAngle(q, [x, y, z], angle);
    const quatMat = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(quatMat, q);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = orientationQuaternion => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.fromQuat */ .pB.fromQuat(new Float64Array(16), orientationQuaternion);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = matrix => {
    if ((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_3__.a)(model.userMatrix, matrix)) {
      return false;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    // check whether or not need to rebuild the matrix
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.matrix);
      if (model.userMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, model.origin);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, model.position);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.matrix, model.matrix, model.rotation);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.scale */ .pB.scale(model.matrix, model.matrix, model.scale);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.matrix, model.matrix);

      // check for identity
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1.0 : 0.0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCenter */ .Ay.getCenter(model.bounds);
  publicAPI.getLength = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getLength */ .Ay.getLength(model.bounds);
  publicAPI.getXRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getXRange */ .Ay.getXRange(model.bounds);
  publicAPI.getYRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getYRange */ .Ay.getYRange(model.bounds);
  publicAPI.getZRange = () => _Common_DataModel_BoundingBox_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getZRange */ .Ay.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _Prop_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.matrixMTime);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.get(publicAPI, model, ['bounds', 'isIdentity']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.getArray(publicAPI, model, ['orientation']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGetArray(publicAPI, model, ['origin', 'position', 'scale'], 3);

  // Object internal instance
  model.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.userMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.transform = null; // FIXME

  // Object methods
  vtkProp3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend, 'vtkProp3D');

// ----------------------------------------------------------------------------

var vtkProp3D$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 89585:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkProperty$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71995);



const {
  Representation,
  Interpolation
} = _Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
function notImplemented(method) {
  return () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProperty methods
// ----------------------------------------------------------------------------

function vtkProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProperty');
  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented('ComputeCompositeColor');
  publicAPI.getColor = () => {
    // Inline computeCompositeColor
    let norm = 0.0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm = 1.0 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i = 0; i < 3; i++) {
      model.color[i] = norm * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = specularPower => {
    const roughness = 1 / Math.max(1.0, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower; // Specular power still needs to be set as long as webgl is using it (otherwise testShaderReplacementsClear fails)
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented('AddShaderVariable');
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation.PHONG);
  publicAPI.getInterpolationAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(Interpolation, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(Representation, model.representation);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation.GOURAUD,
  representation: Representation.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['lighting', 'interpolation', 'ambient', 'diffuse', 'metallic', 'roughness', 'normalStrength', 'emission', 'baseIOR', 'specular', 'specularPower', 'opacity', 'edgeVisibility', 'lineWidth', 'pointSize', 'backfaceCulling', 'frontfaceCulling', 'representation', 'diffuseTexture', 'metallicTexture', 'roughnessTexture', 'normalTexture', 'ambientOcclusionTexture', 'emissionTexture']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['ambientColor', 'specularColor', 'diffuseColor', 'edgeColor'], 3);

  // Object methods
  vtkProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkProperty');

// ----------------------------------------------------------------------------

var vtkProperty$1 = {
  newInstance,
  extend,
  ..._Property_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay
};




/***/ }),

/***/ 71995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ PropertyConst),
/* harmony export */   YL: () => (/* binding */ Representation)
/* harmony export */ });
/* unused harmony exports Interpolation, Shading */
const Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
const Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
const Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};




/***/ }),

/***/ 50036:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkRenderer$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var Camera = __webpack_require__(26719);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Light.js




// ----------------------------------------------------------------------------

const LIGHT_TYPES = ['HeadLight', 'CameraLight', 'SceneLight'];

// ----------------------------------------------------------------------------
// vtkLight methods
// ----------------------------------------------------------------------------

function vtkLight(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLight');
  const tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      esm/* vec3.set */.eR.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      esm/* vec3.transformMat4 */.eR.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      esm/* vec3.set */.eR.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      esm/* vec3.sub */.eR.sub(model.direction, model.focalPoint, model.position);
      (0,Core_Math.l)(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };

  // Sets the direction from a vec3 instead of a focal point
  publicAPI.setDirection = directionVector => {
    const newFocalPoint = new Float64Array(3);
    esm/* vec3.sub */.eR.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = (0,Core_Math.r)(elevation);
    const azimuthRadians = (0,Core_Math.r)(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType('HeadLight');
  };
  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType('CameraLight');
  };
  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType('SceneLight');
  };
  publicAPI.lightTypeIsHeadLight = () => model.lightType === 'HeadLight';
  publicAPI.lightTypeIsSceneLight = () => model.lightType === 'SceneLight';
  publicAPI.lightTypeIsCameraLight = () => model.lightType === 'CameraLight';
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: 'SceneLight',
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['intensity', 'switch', 'positional', 'exponent', 'coneAngle', 'coneFalloff', 'transformMatrix', 'lightType', 'shadowAttenuation', 'attenuationValues']);
  macros2.m.setGetArray(publicAPI, model, ['color', 'position', 'focalPoint', 'attenuationValues'], 3);

  // Object methods
  vtkLight(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkLight');

// ----------------------------------------------------------------------------

var vtkLight$1 = {
  newInstance,
  extend,
  LIGHT_TYPES
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js


const {
  vtkErrorMacro
} = macros2.m;
function notImplemented(method) {
  return () => vtkErrorMacro(`vtkViewport::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkViewport methods
// ----------------------------------------------------------------------------

function vtkViewport(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewport');

  // Public API methods
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = prop => model.props.includes(prop);
  publicAPI.addViewProp = prop => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props.push(prop);
    }
  };
  publicAPI.removeViewProp = prop => {
    const newPropList = model.props.filter(item => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };

  // this method get all the props including any nested props
  function gatherProps(prop) {
    let allProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = () => {
    const allPropsArray = [];
    for (let i = 0; i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = prop => {
    // VTK way: model.actors2D.RemoveItem(prop);
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach(prop => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = () => vtkErrorMacro('call displayToView on your view instead');
  publicAPI.viewToDisplay = () => vtkErrorMacro('callviewtodisplay on your view instead');
  publicAPI.getSize = () => vtkErrorMacro('call getSize on your View instead');
  publicAPI.normalizedDisplayToProjection = (x, y, z) => {
    // first to normalized viewport
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);

    // then to view
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
  };
  publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2.0 - 1.0, y * 2.0 - 1.0, z * 2.0 - 1.0];
  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
    // first to nvp
    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);

    // then to ndp
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1.0) * 0.5, (y + 1.0) * 0.5, (z + 1.0) * 0.5];
  publicAPI.PickPropFrom = notImplemented('PickPropFrom');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Viewport_DEFAULT_VALUES = {
  // _vtkWindow: null,
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};

// ----------------------------------------------------------------------------

function Viewport_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Viewport_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.event(publicAPI, model, 'event');
  macros2.m.setGetArray(publicAPI, model, ['viewport'], 4);
  macros2.m.setGetArray(publicAPI, model, ['background', 'background2'], 3);
  vtkViewport(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Viewport_newInstance = macros2.m.newInstance(Viewport_extend, 'vtkViewport');

// ----------------------------------------------------------------------------

var vtkViewport$1 = {
  newInstance: Viewport_newInstance,
  extend: Viewport_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var BoundingBox = __webpack_require__(21734);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js








const {
  vtkDebugMacro,
  vtkErrorMacro: Renderer_vtkErrorMacro,
  vtkWarningMacro
} = macros2.c;
function Renderer_notImplemented(method) {
  return () => Renderer_vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkRenderer methods
// ----------------------------------------------------------------------------

function vtkRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderer');

  // Events
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: 'ComputeVisiblePropBoundsEvent',
    renderer: publicAPI
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: 'ResetCameraClippingRangeEvent',
    renderer: publicAPI
  };
  const RESET_CAMERA_EVENT = {
    type: 'ResetCameraEvent',
    renderer: publicAPI
  };
  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro('No cameras are on, creating one.');
      // the get method will automagically create a camera
      // and reset it since one hasn't been specified yet.
      publicAPI.getActiveCameraAndResetIfCreated();
    }

    // update the viewing transformation
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = () => {
    // only update the light's geometry if this Renderer is tracking
    // this lights.  That allows one renderer to view the lights that
    // another renderer is setting up.
    const camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach(light => {
      if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {
        // update position and orientation of light to match camera.
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(esm/* mat4.create */.pB.create()));
      } else {
        Renderer_vtkErrorMacro('light has unknown light type', light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      // only update the light's geometry if this Renderer is tracking
      // this lights.  That allows one renderer to view the lights that
      // another renderer is setting up.
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = Renderer_notImplemented('allocateTime');
  publicAPI.updateGeometry = Renderer_notImplemented('updateGeometry');
  publicAPI.getVTKWindow = () => model._renderWindow;
  publicAPI.setLayer = layer => {
    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = camera => {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: 'ActiveCameraEvent',
      camera
    });
    return true;
  };
  publicAPI.makeCamera = () => {
    const camera = Camera/* default.newInstance */.Ay.newInstance();
    publicAPI.invokeEvent({
      type: 'CreateCameraEvent',
      camera
    });
    return camera;
  };

  // Replace the set/get macro method
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach(prop => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = actor => {
    model.actors = model.actors.filter(a => a !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    const actors = publicAPI.getActors();
    actors.forEach(actor => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach(prop => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = volume => {
    model.volumes = model.volumes.filter(v => v !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    const volumes = publicAPI.getVolumes();
    volumes.forEach(volume => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.hasLight = light => model.lights.includes(light);
  publicAPI.addLight = light => {
    if (light && !publicAPI.hasLight(light)) {
      model.lights.push(light);
      publicAPI.modified();
    }
  };
  publicAPI.removeLight = light => {
    model.lights = model.lights.filter(l => l !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = lights => {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();

    // set these values just to have a good default should LightFollowCamera
    // be turned off.
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
    let vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToWorld = (x, y, z) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the view matrix from the active camera
    const matrix = model.activeCamera.getViewMatrix();
    esm/* mat4.invert */.pB.invert(matrix, matrix);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the projection transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
    esm/* mat4.invert */.pB.invert(matrix, matrix);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };

  // Convert world point coordinates to view coordinates.
  publicAPI.worldToView = (x, y, z) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the view transformation from the active camera
    const matrix = model.activeCamera.getViewMatrix();
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };

  // Convert world point coordinates to view coordinates.
  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToProjection = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      Renderer_vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');
      return [0, 0, 0];
    }

    // get the projeciton transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
    esm/* mat4.transpose */.pB.transpose(matrix, matrix);
    const result = new Float64Array([x, y, z]);
    esm/* vec3.transformMat4 */.eR.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = BoundingBox/* default */.Ay.INIT_BOUNDS[0];
    model.allBounds[1] = BoundingBox/* default */.Ay.INIT_BOUNDS[1];
    model.allBounds[2] = BoundingBox/* default */.Ay.INIT_BOUNDS[2];
    model.allBounds[3] = BoundingBox/* default */.Ay.INIT_BOUNDS[3];
    model.allBounds[4] = BoundingBox/* default */.Ay.INIT_BOUNDS[4];
    model.allBounds[5] = BoundingBox/* default */.Ay.INIT_BOUNDS[5];
    let nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);

    // loop through all props
    for (let index = 0; index < model.props.length; ++index) {
      const prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && (0,Core_Math.U)(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      (0,Core_Math.u)(model.allBounds);
      vtkDebugMacro("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function () {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];
    if (!(0,Core_Math.U)(boundsToUse)) {
      vtkDebugMacro('Cannot reset camera!');
      return false;
    }
    let vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      Renderer_vtkErrorMacro('Trying to reset non-existent camera');
      return false;
    }

    // Reset the perspective zoom factors, otherwise subsequent zooms will cause
    // the view angle to become very small and cause bad depth sorting.
    model.activeCamera.setViewAngle(30.0);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;
    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;

    // If we have just a single point, pick a radius of 1.0
    radius = radius === 0 ? 1.0 : radius;

    // compute the radius of the enclosing sphere
    radius = Math.sqrt(radius) * 0.5;

    // default so that the bounding sphere fits within the view fustrum

    // compute the distance from the intersection of the view frustum with the
    // bounding sphere. Basically in 2D draw a circle representing the bounding
    // sphere in 2D then draw a horizontal line going out from the center of
    // the circle. That is the camera view. Then draw a line from the camera
    // position to the point where it intersects the circle. (it will be tangent
    // to the circle at this point, this is important, only go to the tangent
    // point, do not draw all the way to the view plane). Then draw the radius
    // from the tangent point to the center of the circle. You will note that
    // this forms a right triangle with one side being the radius, another being
    // the target distance for the camera, then just find the target dist using
    // a sin.
    const angle = (0,Core_Math.r)(model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance = radius / Math.sin(angle * 0.5);

    // check view-up vector against view plane normal
    const vup = model.activeCamera.getViewUp();
    if (Math.abs((0,Core_Math.d)(vup, vn)) > 0.999) {
      vtkWarningMacro('Resetting view-up since view plane normal is parallel');
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }

    // update the camera
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);

    // setup default parallel scale
    model.activeCamera.setParallelScale(parallelScale);

    // update reasonable world to physical values
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function () {
    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!(0,Core_Math.U)(boundsToUse)) {
      vtkDebugMacro('Cannot reset camera clipping range!');
      return false;
    }

    // Make sure we have an active camera
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      Renderer_vtkErrorMacro('Trying to reset clipping range of non-existent camera');
      return false;
    }

    // Get the exact range for the bounds
    const range = model.activeCamera.computeClippingRange(boundsToUse);

    // do not let far - near be less than 0.1 of the window height
    // this is for cases such as 2D images which may have zero range
    let minGap = 0.0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      const angle = (0,Core_Math.r)(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2.0;
      range[0] -= minGap / 2.0;
    }

    // Do not let the range behind the camera throw off the calculation.
    if (range[0] < 0.0) {
      range[0] = 0.0;
    }

    // Give ourselves a little breathing room
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;

    // Make sure near is not bigger than far
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];

    // Make sure near is at least some fraction of far - this prevents near
    // from being behind the camera or too close in front. How close is too
    // close depends on the resolution of the depth buffer
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }

    // make sure the front clipping range is not too far from the far clippnig
    // range, this is to make sure that the zbuffer resolution is effectively
    // used
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = renderWindow => {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = () => !!model.preserveColorBuffer;
  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Renderer_DEFAULT_VALUES = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: (0,Core_Math.H)(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};

// ----------------------------------------------------------------------------

function Renderer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Renderer_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkViewport$1.extend(publicAPI, model, initialValues);

  // make sure background has 4 entries. Default to opaque black
  if (!model.background) model.background = [0, 0, 0, 1];
  while (model.background.length < 3) model.background.push(0);
  if (model.background.length === 3) model.background.push(1);

  // Build VTK API
  (0,macros2.g)(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);
  (0,macros2.e)(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);
  (0,macros2.k)(publicAPI, model, ['actors', 'volumes', 'lights']);
  (0,macros2.l)(publicAPI, model, ['background'], 4, 1.0);
  (0,macros2.i)(publicAPI, model, ['renderWindow']);

  // Object methods
  vtkRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Renderer_newInstance = (0,macros2.n)(Renderer_extend, 'vtkRenderer');

// ----------------------------------------------------------------------------

var vtkRenderer$1 = {
  newInstance: Renderer_newInstance,
  extend: Renderer_extend
};




/***/ }),

/***/ 61433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkTexture$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkTexture methods
// ----------------------------------------------------------------------------

function vtkTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkTexture');
  publicAPI.imageLoaded = () => {
    model.image.removeEventListener('load', publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = imageData => {
    if (model.jsImageData === imageData) {
      return;
    }

    // clear other entries
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = canvas => {
    if (model.canvas === canvas) {
      return;
    }

    // clear other entries
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = image => {
    if (model.image === image) {
      return;
    }

    // clear other entries
    if (image !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
    }
    model.image = image;
    model.imageLoaded = false;
    if (image.complete) {
      publicAPI.imageLoaded();
    } else {
      image.addEventListener('load', publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = () => {
    let width = 0;
    let height = 0;
    let depth = 1;
    if (publicAPI.getInputData()) {
      const data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    const dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = () => {
    if (!model.imageLoaded || publicAPI.getInputData()) return null;
    if (model.jsImageData) {
      return model.jsImageData();
    }
    if (model.canvas) {
      const context = model.canvas.getContext('2d');
      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      const canvas = document.createElement('canvas');
      canvas.width = model.image.width;
      canvas.height = model.image.height;
      const context = canvas.getContext('2d');
      context.translate(0, canvas.height);
      context.scale(1, -1);
      context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      return imageData;
    }
    return null;
  };
}

// Use nativeArray instead of self
const generateMipmaps = (nativeArray, width, height, level) => {
  // TODO: FIX UNEVEN TEXTURE MIP GENERATION:
  // When textures don't have standard ratios, higher mip levels
  // result in their color chanels getting messed up and shifting
  // 3x3 gaussian kernel
  const g3m = [1, 2, 1]; // eslint-disable-line
  const g3w = 4; // eslint-disable-line

  const kernel = g3m;
  const kernelWeight = g3w;
  const hs = nativeArray.length / (width * height); // TODO: support for textures with depth more than 1
  let currentWidth = width;
  let currentHeight = height;
  let imageData = nativeArray;
  const maps = [imageData];
  for (let i = 0; i < level; i++) {
    const oldData = [...imageData];
    currentWidth /= 2;
    currentHeight /= 2;
    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
    const vs = hs * currentWidth;

    // Scale down
    let shift = 0;
    for (let p = 0; p < imageData.length; p += hs) {
      if (p % vs === 0) {
        shift += 2 * hs * currentWidth;
      }
      for (let c = 0; c < hs; c++) {
        let sample = oldData[shift + c];
        sample += oldData[shift + hs + c];
        sample += oldData[shift - 2 * vs + c];
        sample += oldData[shift - 2 * vs + hs + c];
        sample /= 4;
        imageData[p + c] = sample;
      }
      shift += 2 * hs;
    }

    // Horizontal Pass
    let dataCopy = [...imageData];
    for (let p = 0; p < imageData.length; p += hs) {
      for (let c = 0; c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0.0;
        for (let k = 0; k < kernel.length; k++) {
          let index = p + c + x * hs;
          const lineShift = index % vs - (p + c) % vs;
          if (lineShift > hs) index += vs;
          if (lineShift < -hs) index -= vs;
          if (dataCopy[index]) {
            value += dataCopy[index] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    // Vertical Pass
    dataCopy = [...imageData];
    for (let p = 0; p < imageData.length; p += hs) {
      for (let c = 0; c < hs; c++) {
        let x = -(kernel.length - 1) / 2;
        let kw = kernelWeight;
        let value = 0.0;
        for (let k = 0; k < kernel.length; k++) {
          const index = p + c + x * vs;
          if (dataCopy[index]) {
            value += dataCopy[index] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[p + c] = value / kw;
      }
    }
    maps.push(imageData);
  }
  return maps;
};

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0,
  resizable: false // must be set at construction time if the texture can be resizable
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.algo(publicAPI, model, 6, 0);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageLoaded', 'resizable']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);
  vtkTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkTexture');
const STATIC = {
  generateMipmaps
};

// ----------------------------------------------------------------------------

var vtkTexture$1 = {
  newInstance,
  extend,
  ...STATIC
};




/***/ }),

/***/ 53387:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkVolumeMapper$1)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16632);
/* harmony import */ var _VolumeMapper_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67737);
/* harmony import */ var _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68076);
/* harmony import */ var _Common_DataModel_PiecewiseFunction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99341);






const {
  BlendMode,
  FilterMode
} = _VolumeMapper_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
function createRadonTransferFunction(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption, maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption, outputTransferFunction) {
  let ofun = null;
  if (outputTransferFunction) {
    ofun = outputTransferFunction;
    ofun.removeAllPoints();
  } else {
    ofun = _Common_DataModel_PiecewiseFunction_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].newInstance */ .Ay.newInstance();
  }
  ofun.addPointLong(-1024, 0, 1, 1); // air (i.e. material with no absorption)
  ofun.addPoint(firstAbsorbentMaterialHounsfieldValue, firstAbsorbentMaterialAbsorption);
  ofun.addPoint(maxAbsorbentMaterialHounsfieldValue, maxAbsorbentMaterialAbsorption);
  return ofun;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  createRadonTransferFunction
};

// ----------------------------------------------------------------------------
// vtkVolumeMapper methods
// ----------------------------------------------------------------------------

function vtkVolumeMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkVolumeMapper');
  const superClass = {
    ...publicAPI
  };
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.H)();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = () => {
    publicAPI.setBlendMode(BlendMode.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = () => {
    publicAPI.setBlendMode(BlendMode.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = () => {
    publicAPI.setBlendMode(BlendMode.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = () => {
    publicAPI.setBlendMode(BlendMode.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = () => {
    publicAPI.setBlendMode(BlendMode.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToRadonTransform = () => {
    publicAPI.setBlendMode(BlendMode.RADON_TRANSFORM_BLEND);
  };
  publicAPI.getBlendModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(BlendMode, model.blendMode);
  publicAPI.setAverageIPScalarRange = (min, max) => {
    console.warn('setAverageIPScalarRange is deprecated use setIpScalarRange');
    publicAPI.setIpScalarRange(min, max);
  };
  publicAPI.getFilterModeAsString = () => _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.enumToString(FilterMode, model.filterMode);
  publicAPI.setFilterModeToOff = () => {
    publicAPI.setFilterMode(FilterMode.OFF);
  };
  publicAPI.setFilterModeToNormalized = () => {
    publicAPI.setFilterMode(FilterMode.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = () => {
    publicAPI.setFilterMode(FilterMode.RAW);
  };
  publicAPI.setGlobalIlluminationReach = gl => superClass.setGlobalIlluminationReach((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.E)(gl, 0.0, 1.0));
  publicAPI.setVolumetricScatteringBlending = vsb => superClass.setVolumetricScatteringBlending((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.E)(vsb, 0.0, 1.0));
  publicAPI.setVolumeShadowSamplingDistFactor = vsdf => superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1.0 ? vsdf : 1.0);
  publicAPI.setAnisotropy = at => superClass.setAnisotropy((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.E)(at, -0.99, 0.99));
  publicAPI.setLAOKernelSize = ks => superClass.setLAOKernelSize((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.K)((0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_1__.E)(ks, 1, 32)));
  publicAPI.setLAOKernelRadius = kr => superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

// TODO: what values to use for averageIPScalarRange to get GLSL to use max / min values like [-Math.inf, Math.inf]?
const defaultValues = initialValues => ({
  bounds: [1, -1, 1, -1, 1, -1],
  sampleDistance: 1.0,
  imageSampleDistance: 1.0,
  maximumSamplesPerRay: 1000,
  autoAdjustSampleDistances: true,
  initialInteractionScale: 1.0,
  interactionSampleDistanceFactor: 1.0,
  blendMode: BlendMode.COMPOSITE_BLEND,
  ipScalarRange: [-1000000.0, 1000000.0],
  filterMode: FilterMode.OFF,
  // ignored by WebGL so no behavior change
  preferSizeOverAccuracy: false,
  // Whether to use halfFloat representation of float, when it is inaccurate
  computeNormalFromOpacity: false,
  // volume shadow parameters
  volumetricScatteringBlending: 0.0,
  globalIlluminationReach: 0.0,
  volumeShadowSamplingDistFactor: 5.0,
  anisotropy: 0.0,
  // local ambient occlusion
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7,
  updatedExtents: [],
  ...initialValues
});

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  _AbstractMapper3D_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].extend */ .A.extend(publicAPI, model, initialValues);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['sampleDistance', 'imageSampleDistance', 'maximumSamplesPerRay', 'autoAdjustSampleDistances', 'initialInteractionScale', 'interactionSampleDistanceFactor', 'blendMode', 'filterMode', 'preferSizeOverAccuracy', 'computeNormalFromOpacity', 'volumetricScatteringBlending', 'globalIlluminationReach', 'volumeShadowSamplingDistFactor', 'anisotropy', 'localAmbientOcclusion', 'LAOKernelSize', 'LAOKernelRadius', 'updatedExtents']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGetArray(publicAPI, model, ['ipScalarRange'], 2);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.event(publicAPI, model, 'lightingActivated');

  // Object methods
  vtkVolumeMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkVolumeMapper');

// ----------------------------------------------------------------------------

var vtkVolumeMapper$1 = {
  newInstance,
  extend,
  ...STATIC
};




/***/ }),

/***/ 67737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   Nx: () => (/* binding */ BlendMode)
/* harmony export */ });
/* unused harmony export FilterMode */
const BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
  ADDITIVE_INTENSITY_BLEND: 4,
  RADON_TRANSFORM_BLEND: 5,
  LABELMAP_EDGE_PROJECTION_BLEND: 6
};
const FilterMode = {
  OFF: 0,
  NORMALIZED: 1,
  RAW: 2
};
var Constants = {
  BlendMode,
  FilterMode
};




/***/ }),

/***/ 20433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   VO: () => (/* binding */ InterpolationType),
/* harmony export */   dM: () => (/* binding */ ColorMixPreset),
/* harmony export */   tE: () => (/* binding */ OpacityMode)
/* harmony export */ });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2
};
const OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1
};
const ColorMixPreset = {
  CUSTOM: 0,
  ADDITIVE: 1,
  COLORIZE: 2
};
var Constants = {
  InterpolationType,
  OpacityMode,
  ColorMixPreset
};




/***/ }),

/***/ 80639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();

      // we store textures and mapper
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA('vtkOpenGLTexture')) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };

  // render both opaque and translucent actors
  publicAPI.traverseZBufferPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // only render opaque actors
  publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(model.keyMatrices.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.transpose */ .w0.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9)),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkActor = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkActor', newInstance);




/***/ }),

/***/ 58601:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkActor2D)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor2D');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();

      // we store textures and mapper
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA('vtkOpenGLTexture')) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = renderPass => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      // deactivate textures
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.overlayPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      // deactivate textures
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  activeTextures: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend);

// ----------------------------------------------------------------------------

var vtkActor2D = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkActor2D', newInstance);




/***/ }),

/***/ 21081:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkBufferObject)
/* harmony export */ });
/* unused harmony exports STATIC, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60003);



const {
  ObjectType
} = _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A;

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {};

// ----------------------------------------------------------------------------
// vtkOpenGLBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLBufferObject');

  // Class-specific private functions
  function convertType(type) {
    switch (type) {
      case ObjectType.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType.TEXTURE_BUFFER:
        if ('TEXTURE_BUFFER' in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      /* eslint-disable no-fallthrough */
      // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL
      case ObjectType.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
      /* eslint-enable no-fallthrough */
    }
  }

  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = '';

  // Public API methods
  publicAPI.getType = () => internalType;
  publicAPI.setType = value => {
    internalType = value;
  };
  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;
  publicAPI.generateBuffer = type => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = (data, type) => {
    // buffer, size, type
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = 'Trying to upload array buffer to incompatible buffer.';
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
    dirty = false;
    return true;
  };
  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
      model.allocatedGPUMemoryInBytes = 0;
    }
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = () => error;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  objectType: ObjectType.ARRAY_BUFFER,
  // _openGLRenderWindow: null,
  context: null,
  allocatedGPUMemoryInBytes: 0
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['_openGLRenderWindow', 'allocatedGPUMemoryInBytes']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['openGLRenderWindow']);
  vtkOpenGLBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkBufferObject = {
  newInstance,
  extend,
  ...STATIC,
  ..._BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A
};




/***/ }),

/***/ 60003:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   a: () => (/* binding */ ObjectType)
/* harmony export */ });
const ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants = {
  ObjectType
};




/***/ }),

/***/ 38475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkCamera)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLCamera methods
// ----------------------------------------------------------------------------

function vtkOpenGLCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCamera');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };

  // Renders myself
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = ren => {
    // has the camera changed?
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime);

  // values always get set by the get method
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context', 'keyMatrixTime']);

  // Object methods
  vtkOpenGLCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkCamera = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkCamera', newInstance);




/***/ }),

/***/ 32821:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkOpenGLFramebuffer)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79525);
/* harmony import */ var _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28914);
/* harmony import */ var _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52271);





// ----------------------------------------------------------------------------
// vtkFramebuffer methods
// ----------------------------------------------------------------------------
function vtkFramebuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkFramebuffer');
  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  // publicAPI.getDrawMode = () => model.context.DRAW_FRAMEBUFFER;
  // publicAPI.getReadMode = () => model.context.READ_FRAMEBUFFER;

  publicAPI.saveCurrentBindingsAndBuffers = modeIn => {
    const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = modeIn => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling saveCurrentBindings');
      return;
    }
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = modeIn => {
    // noop on webgl 1
  };
  publicAPI.restorePreviousBindingsAndBuffers = modeIn => {
    const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = modeIn => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling restorePreviousBindings');
      return;
    }
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = modeIn => {
    // currently a noop on webgl1
  };
  publicAPI.bind = function () {
    let modeArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (let i = 0; i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = (width, height) => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling create');
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function (texture) {
    let attachment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const gl = model.context;
    if (!gl) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling setColorBuffer');
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Using multiple framebuffer attachments requires WebGL 2');
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function () {
    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const gl = model.context;
    if (!gl) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling removeColorBuffer');
      return;
    }
    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Using multiple framebuffer attachments requires WebGL 2');
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = texture => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling setDepthBuffer');
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Attaching depth buffer textures to fbo requires WebGL 2');
    }
  };
  publicAPI.removeDepthBuffer = () => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling removeDepthBuffer');
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('Attaching depth buffer textures to framebuffers requires WebGL 2');
    }
  };
  publicAPI.getGLFramebuffer = () => model.glFramebuffer;
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = () => {
    if (model.glFramebuffer == null) return null;
    return [model.glFramebuffer.width, model.glFramebuffer.height];
  };
  publicAPI.populateFramebuffer = () => {
    if (!model.context) {
      (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you must set the OpenGLRenderWindow before calling populateFrameBuffer');
      return;
    }
    publicAPI.bind();
    const gl = model.context;
    const texture = _Texture_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].newInstance */ .Ay.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .Filter */ .dJ.LINEAR);
    texture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_3__/* .Filter */ .dJ.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_2__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);

    // for now do not count on having a depth buffer texture
    // as they are not standard webgl 1
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };

  // For backwards compatibility. Use getColorBuffers()[0] going forward.
  publicAPI.getColorTexture = () => model.colorBuffers[0];
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const DEFAULT_VALUES = {
  // _openGLRenderWindow: null,
  glFramebuffer: null,
  colorBuffers: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null
};

// ----------------------------------------------------------------------------
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.o)(publicAPI, model);
  if (model.colorBuffers) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)('you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.');
  }
  model.colorBuffers = [];
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.k)(publicAPI, model, ['colorBuffers']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkFramebuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------
const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkFramebuffer');

// ----------------------------------------------------------------------------
var vtkOpenGLFramebuffer = {
  newInstance,
  extend
};




/***/ }),

/***/ 57703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Constants),
/* harmony export */   T: () => (/* binding */ PassTypes)
/* harmony export */ });
const PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants = {
  PassTypes
};




/***/ }),

/***/ 71650:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkHelper)
});

// UNUSED EXPORTS: extend, newInstance, primTypes

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var BufferObject = __webpack_require__(21081);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var Constants = __webpack_require__(60003);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js






const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// Static functions
// ----------------------------------------------------------------------------

function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = new Float64Array(3);
  esm/* vec3.inverse */.eR.inverse(inverseScale, coordScale);
  const matrix = new Float64Array(16);
  esm/* mat4.fromRotationTranslationScale */.pB.fromRotationTranslationScale(matrix, esm/* quat.create */.Yu.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(esm/* vec3.exactEquals */.eR.exactEquals(coordShift, [0, 0, 0]) && esm/* vec3.exactEquals */.eR.exactEquals(coordScale, [1, 1, 1]));
}

// ----------------------------------------------------------------------------
// vtkOpenGLCellArrayBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');
  publicAPI.setType(Constants/* ObjectType */.a.ARRAY_BUFFER);
  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {
    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }

    // Figure out how big each block will be, currently 6 or 7 floats.
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;
    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;

    // the values of 4 below are because floats are 4 bytes

    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach(a => {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = BufferObject/* default.newInstance */.Ay.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;
    const cellBuilders = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts, offset, cellId) {
        for (let i = 0; i < numPoints; ++i) {
          addAPoint(cellPts[offset + i], cellId);
        }
      },
      linesToWireframe(numPoints, cellPts, offset, cellIdx) {
        // for lines we add a bunch of segments
        for (let i = 0; i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
        }
      },
      polysToWireframe(numPoints, cellPts, offset, cellIdx) {
        // for polys we add a bunch of segments and close it
        if (numPoints > 2) {
          for (let i = 0; i < numPoints; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);
          }
        }
      },
      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          // for strips we add a bunch of segments and close it
          for (let i = 0; i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
          }
          for (let i = 0; i < numPoints - 2; i++) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 2], cellIdx);
          }
        }
      },
      polysToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + 0], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
          addAPoint(cellPts[offset + i + 2], cellIdx);
        }
      },
      stripsToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);
          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);
        }
      }
    };
    const cellCounters = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    let func = null;
    let countFunc = null;
    if (outRep === Property_Constants/* Representation */.YL.POINTS || inRep === 'verts') {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Property_Constants/* Representation */.YL.WIREFRAME || inRep === 'lines') {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }
    const array = cellArray.getData();
    const size = array.length;
    let caboCount = 0;
    for (let index = 0; index < size;) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }
    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;

    // Find out if shift scale should be used
    // Compute squares of diagonal size and distance from the origin
    let diagSq = 0.0;
    let distSq = 0.0;
    for (let i = 0; i < 3; ++i) {
      const range = options.points.getRange(i);
      const delta = range[1] - range[0];
      diagSq += delta * delta;
      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||
    // If data is far from the origin relative to its size
    Math.abs(Math.log10(diagSq)) > 3.0 ||
    // If the size is huge when not far from the origin
    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin

    if (useShiftAndScale) {
      // Compute shift and scale vectors
      const coordShift = new Float64Array(3);
      const coordScale = new Float64Array(3);
      for (let i = 0; i < 3; ++i) {
        const range = options.points.getRange(i);
        const delta = range[1] - range[0];
        coordShift[i] = 0.5 * (range[1] + range[0]);
        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      // Make sure to reset
      publicAPI.setCoordShiftAndScale(null, null);
    }

    // Initialize the structures used to keep track of point ids and cell ids for selectors
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    let pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(pointId, cellId) {
      // Keep track of original point and cell ids, for selection
      if (selectionMaps) {
        selectionMaps.points[pointCount] = pointId;
        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
      }
      ++pointCount;

      // Vertices
      pointIdx = pointId * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        // Apply shift and scale
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = pointId * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach(attr => {
        custIdx = pointId * attr.components;
        for (let j = 0; j < attr.components; ++j) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        if (options.useTCoordsPerCell) {
          tcoordIdx = cellId * textureComponents;
        } else {
          tcoordIdx = pointId * textureComponents;
        }
        for (let j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = pointId * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };

    // Browse the cell array: the index is at the beginning of a cell
    // The value of 'array' at the position 'index' is the number of points in the cell
    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {
      func(array[index], array, index + 1, cellCount + options.cellOffset);
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, Constants/* ObjectType */.a.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, Constants/* ObjectType */.a.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');
      return;
    }
    if (model.coordShift === null || coordShift === null || !esm/* vec3.equals */.eR.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !esm/* vec3.equals */.eR.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  BufferObject/* default.extend */.Ay.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);
  macros2.m.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);

  // Object specific methods
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkCellArrayBufferObject = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js






const primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};

// ----------------------------------------------------------------------------
// vtkOpenGLHelper methods
// ----------------------------------------------------------------------------

function vtkOpenGLHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHelper');
  publicAPI.setOpenGLRenderWindow = win => {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = oglwin => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
    // Are there any entries
    if (model.CABO.getElementCount()) {
      // are we drawing edges
      const mode = publicAPI.getOpenGLMode(rep);
      const wideLines = publicAPI.haveWideLines(ren, actor);
      const gl = model.context;
      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      const drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        // reset the line width
        gl.lineWidth(1);
      }
      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = rep => {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    const type = model.primitiveType;
    if (rep === Property_Constants/* Representation */.YL.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Property_Constants/* Representation */.YL.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = (ren, actor) => {
    if (actor.getProperty().getLineWidth() > 1.0) {
      // we have wide lines, but the OpenGL implementation may
      // actually support them, check the range to see if we
      // really need have to implement our own wide lines
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // mapper modified (lighting complexity)
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (ren, actor, oglMapper) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        // reset the VAO as the shader has changed
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (ren, actor, size) => {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);
      const lineWidth = parseFloat(actor.getProperty().getLineWidth());
      const halfLineWidth = lineWidth / 2.0;
      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Property_Constants/* Representation */.YL.POINTS) {
      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;

    // Always set point size in case we need picking
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;

    // for lines, make sure we add the width code
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = () => {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Helper_DEFAULT_VALUES = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};

// ----------------------------------------------------------------------------

function Helper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Helper_DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macros2.m.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macros2.m.obj(model.attributeUpdateTime);
  macros2.m.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);
  model.program = ShaderProgram/* default */.A.newInstance();
  model.VAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();

  // Object methods
  vtkOpenGLHelper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Helper_newInstance = macros2.m.newInstance(Helper_extend);

// ----------------------------------------------------------------------------

var vtkHelper = {
  newInstance: Helper_newInstance,
  extend: Helper_extend,
  primTypes
};




/***/ }),

/***/ 82967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ index)
});

// UNUSED EXPORTS: STATIC, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var ImageProperty_Constants = __webpack_require__(91732);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageCPRMapper/Constants.js
const ProjectionMode = {
  MAX: 0,
  MIN: 1,
  AVERAGE: 2
};
var Constants_Constants = {
  ProjectionMode
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var DataArray_Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js + 1 modules
var Texture = __webpack_require__(79525);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS_glsl = __webpack_require__(84839);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS_glsl = __webpack_require__(23159);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
var CoincidentTopologyHelper = __webpack_require__(57285);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Static = __webpack_require__(7698);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageCPRMapper.js




















const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkOpenGLImageCPRMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageCPRMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageCPRMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._colorTransferFunc, model._pwFunc].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology() === Static/* Resolve */.XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = () => {
    const prop = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, prop);
  };
  publicAPI.renderPiece = (ren, prop) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });

    // Check if the ImageCPRMapper has everything it needs to render
    if (!model.renderable.preRenderCheck()) {
      return;
    }
    model.currentImageDataInput = model.renderable.getInputData(0);
    model.currentCenterlineInput = model.renderable.getOrientedCenterline();
    publicAPI.renderPieceStart(ren, prop);
    publicAPI.renderPieceDraw(ren, prop);
    publicAPI.renderPieceFinish(ren, prop);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // activate the texture
    model.volumeTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();

    // draw polygons
    if (model.tris.getCABO().getElementCount()) {
      // First we do the triangles, update the shader, set uniforms, etc.
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.volumeTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    // Set interpolation on the texture based on property setting
    const actorProperty = actor.getProperty();
    if (actorProperty.getInterpolationType() === ImageProperty_Constants/* InterpolationType */.V.NEAREST) {
      model.volumeTexture.setMinificationFilter(Constants/* Filter */.dJ.NEAREST);
      model.volumeTexture.setMagnificationFilter(Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMinificationFilter(Constants/* Filter */.dJ.NEAREST);
      model.colorTexture.setMagnificationFilter(Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMinificationFilter(Constants/* Filter */.dJ.NEAREST);
      model.pwfTexture.setMagnificationFilter(Constants/* Filter */.dJ.NEAREST);
    } else {
      model.volumeTexture.setMinificationFilter(Constants/* Filter */.dJ.LINEAR);
      model.volumeTexture.setMagnificationFilter(Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMinificationFilter(Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMinificationFilter(Constants/* Filter */.dJ.LINEAR);
      model.pwfTexture.setMagnificationFilter(Constants/* Filter */.dJ.LINEAR);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    return vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentImageDataInput.getMTime() || vmtime < model.currentCenterlineInput.getMTime() || !model.volumeTexture?.getHandle();
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentImageDataInput;
    const centerline = model.currentCenterlineInput;

    // Rebuild the volumeTexture if the data has changed
    const scalars = image?.getPointData()?.getScalars();
    if (!scalars) {
      return;
    }
    const cachedScalarsEntry = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    const volumeTextureHash = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const reBuildTex = !cachedScalarsEntry?.oglObject?.getHandle() || cachedScalarsEntry?.hash !== volumeTextureHash;
    const updatedExtents = model.renderable.getUpdatedExtents();
    const hasUpdatedExtents = !!updatedExtents.length;
    if (reBuildTex) {
      model.volumeTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.volumeTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the textures
      const dims = image.getDimensions();
      // Use norm16 for scalar texture if the extension is available
      model.volumeTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.volumeTexture.resetFormatAndType();
      model.volumeTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, model.renderable.getPreferSizeOverAccuracy());
      model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.volumeTexture, volumeTextureHash);
      if (scalars !== model._scalars) {
        model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
        model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
      }
      model._scalars = scalars;
    } else {
      model.volumeTexture = cachedScalarsEntry.oglObject;
    }
    if (hasUpdatedExtents) {
      // If hasUpdatedExtents, then the texture is partially updated.
      // clear the array to acknowledge the update.
      model.renderable.setUpdatedExtents([]);
      const dims = image.getDimensions();
      model.volumeTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, false, updatedExtents);
    }

    // Rebuild the color texture if needed
    const numComp = scalars.getNumberOfComponents();
    const ppty = actor.getProperty();
    const iComps = ppty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = ppty.getRGBTransferFunction();
    const colorTextureHash = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, iComps, numIComps);
    const cachedColorEntry = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildColorTexture = !cachedColorEntry?.oglObject?.getHandle() || cachedColorEntry?.hash !== colorTextureHash;
    if (reBuildColorTexture) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = ppty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, colorTextureHash);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cachedColorEntry.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = ppty.getPiecewiseFunction();
    const pwfTextureHash = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(pwFunc, iComps, numIComps);
    const cachedPwfEntry = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    const reBuildPwf = !cachedPwfEntry?.oglObject?.getHandle() || cachedPwfEntry?.hash !== pwfTextureHash;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = ppty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, DataArray_Constants/* VtkDataTypes */.JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, DataArray_Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfTextureHash);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = cachedPwfEntry.oglObject;
    }

    // Rebuild the image vertices if needed
    if (model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < centerline.getMTime()) {
      const nPoints = centerline.getNumberOfPoints();
      const nLines = nPoints <= 1 ? 0 : nPoints - 1;
      const distances = centerline.getDistancesToFirstPoint();
      const totalHeight = model.renderable.getHeight();
      const nPts = 4 * nLines;

      // Create the array of point: 4 points per segment
      const ptsArray = new Float32Array(3 * nPts);
      const widthMC = model.renderable.getWidth();
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        // Use model coordinates
        // See "setCameraShaderParameters" to see how MCPCMatrix is built

        // Top left
        ptsArray.set([0, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        // Top right
        ptsArray.set([widthMC, totalHeight - distances[lineIdx], 0], offset);
        offset += 3;
        // Bottom right
        ptsArray.set([widthMC, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
        // Bottom left
        ptsArray.set([0, totalHeight - distances[lineIdx + 1], 0], offset);
        offset += 3;
      }
      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');

      // Create the array of cells: a quad per segment
      const cellArray = new Uint16Array(5 * nLines);
      for (let lineIdx = 0, offset = 0, ptIdx = 0; lineIdx < nLines; ++lineIdx) {
        cellArray.set([4, ptIdx + 3, ptIdx + 2, ptIdx + 1, ptIdx], offset);
        offset += 5;
        ptIdx += 4;
      }
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });

      // Create the array of centerline positions (VBO custom attribute)
      const pointsDataArray = centerline.getPoints();
      const centerlinePositionArray = new Float32Array(3 * nPts);
      const pa = new Array(3);
      const pb = new Array(3);
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        pointsDataArray.getPoint(lineIdx, pa);
        pointsDataArray.getPoint(lineIdx + 1, pb);

        // Top left
        centerlinePositionArray.set(pa, offset);
        offset += 3;
        // Top right
        centerlinePositionArray.set(pa, offset);
        offset += 3;
        // Bottom right
        centerlinePositionArray.set(pb, offset);
        offset += 3;
        // Bottom left
        centerlinePositionArray.set(pb, offset);
        offset += 3;
      }
      const centerlinePosition = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: centerlinePositionArray,
        name: 'centerlinePosition'
      });

      // Create the array of quad index:
      //   0 ____ 1
      //    |    |
      //    |____|
      //   2      3
      const quadIndexArray = new Float32Array(nPts);
      for (let lineIdx = 0, offset = 0; lineIdx < nLines; ++lineIdx) {
        quadIndexArray.set([0,
        // Top left
        1,
        // Top right
        3,
        // Bottom right
        2 // Bottom left
        ], offset);
        offset += 4;
      }
      const quadIndex = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: quadIndexArray,
        name: 'quadIndex'
      });
      const customAttributes = [centerlinePosition, quadIndex];
      if (!model.renderable.getUseUniformOrientation()) {
        // For each quad (i.e. centerline segment), a top and bottom quaternion give the orientation
        // Send both quaternions to each vertex and use flat interpolation to get them "as is" in the fragment shader
        // The interpolation of the quaternions will occur in the fragment shader (slerp)
        const orientationQuats = model.renderable.getOrientedCenterline().getOrientations() ?? [];
        const centerlineTopOrientationArray = new Float32Array(4 * nPts);
        const centerlineBotOrientationArray = new Float32Array(4 * nPts);
        for (let quadIdx = 0; quadIdx < nLines; ++quadIdx) {
          // All vertices of a given quad have the same topDir and botDir
          // Polyline goes from top to bottom
          const topQuat = orientationQuats[quadIdx];
          const botQuat = orientationQuats[quadIdx + 1];
          for (let pointInQuadIdx = 0; pointInQuadIdx < 4; ++pointInQuadIdx) {
            const pointIdx = pointInQuadIdx + 4 * quadIdx;
            const quaternionArrayOffset = 4 * pointIdx;
            centerlineTopOrientationArray.set(topQuat, quaternionArrayOffset);
            centerlineBotOrientationArray.set(botQuat, quaternionArrayOffset);
          }
        }
        const centerlineTopOrientation = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 4,
          values: centerlineTopOrientationArray,
          name: 'centerlineTopOrientation'
        });
        const centerlineBotOrientation = DataArray/* default.newInstance */.Ay.newInstance({
          numberOfComponents: 4,
          values: centerlineBotOrientationArray,
          name: 'centerlineBotOrientation'
        });
        customAttributes.push(centerlineTopOrientation, centerlineBotOrientation);
      }
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
        points,
        customAttributes
      });
      model.VBOBuildTime.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // presence of centerPoint
    // value of useUniformOrientation
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed

    const tNumComp = model.volumeTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();
    const useCenterPoint = !!model.renderable.getCenterPoint();
    const useUniformOrientation = model.renderable.getUseUniformOrientation();
    const projectionMode = model.renderable.isProjectionEnabled() && model.renderable.getProjectionMode();
    if (cellBO.getProgram() === 0 || model.lastUseCenterPoint !== useCenterPoint || model.lastUseUniformOrientation !== useUniformOrientation || model.lastProjectionMode !== projectionMode || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastUseCenterPoint = useCenterPoint;
      model.lastUseUniformOrientation = useUniformOrientation;
      model.lastProjectionMode = projectionMode;
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    // https://glmatrix.net/docs/vec3.js.html#line522
    const applyQuaternionToVecShaderFunction = ['vec3 applyQuaternionToVec(vec4 q, vec3 v) {', '  float uvx = q.y * v.z - q.z * v.y;', '  float uvy = q.z * v.x - q.x * v.z;', '  float uvz = q.x * v.y - q.y * v.x;', '  float uuvx = q.y * uvz - q.z * uvy;', '  float uuvy = q.z * uvx - q.x * uvz;', '  float uuvz = q.x * uvy - q.y * uvx;', '  float w2 = q.w * 2.0;', '  uvx *= w2;', '  uvy *= w2;', '  uvz *= w2;', '  uuvx *= 2.0;', '  uuvy *= 2.0;', '  uuvz *= 2.0;', '  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);', '}'];

    // Vertex shader main replacements
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    const vsColorDec = ['attribute vec3 centerlinePosition;', 'attribute float quadIndex;', 'uniform float width;', 'out vec2 quadOffsetVSOutput;', 'out vec3 centerlinePosVSOutput;'];
    const useProjection = model.renderable.isProjectionEnabled();
    const isDirectionUniform = model.renderable.getUseUniformOrientation();
    if (isDirectionUniform) {
      vsColorDec.push('out vec3 samplingDirVSOutput;', 'uniform vec4 centerlineOrientation;', 'uniform vec3 tangentDirection;', ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        vsColorDec.push('out vec3 projectionDirVSOutput;', 'uniform vec3 bitangentDirection;');
      }
    } else {
      vsColorDec.push('out vec4 centerlineTopOrientationVSOutput;', 'out vec4 centerlineBotOrientationVSOutput;', 'attribute vec4 centerlineTopOrientation;', 'attribute vec4 centerlineBotOrientation;');
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Dec', vsColorDec).result;
    const vsColorImpl = [
    // quadOffsetVSOutput.x: left = -0.5* width; right = 0.5 * width
    // quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;
    'quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);', 'centerlinePosVSOutput = centerlinePosition;'];
    if (isDirectionUniform) {
      vsColorImpl.push('samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);');
      if (useProjection) {
        vsColorImpl.push('projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);');
      }
    } else {
      vsColorImpl.push('centerlineTopOrientationVSOutput = centerlineTopOrientation;', 'centerlineBotOrientationVSOutput = centerlineBotOrientation;');
    }
    VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Color::Impl', vsColorImpl).result;

    // Fragment shader main replacements
    const tNumComp = model.volumeTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordFSDec = [
    // used to compute texture coordinates of the sample
    'uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates', 'in vec2 quadOffsetVSOutput;', 'in vec3 centerlinePosVSOutput;',
    // volume texture
    'uniform highp sampler3D volumeTexture;',
    // color and pwf textures
    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',
    // opacity
    'uniform float opacity;',
    // background color (out of volume samples)
    'uniform vec4 backgroundColor;',
    // color shift and scale
    `uniform float cshift0;`, `uniform float cscale0;`,
    // weighting shift and scale
    `uniform float pwfshift0;`, `uniform float pwfscale0;`];
    if (useProjection) {
      tcoordFSDec.push('uniform vec3 volumeSizeMC;', 'uniform int projectionSlabNumberOfSamples;', 'uniform float projectionConstantOffset;', 'uniform float projectionStepLength;');
    }
    if (isDirectionUniform) {
      tcoordFSDec.push('in vec3 samplingDirVSOutput;');
      if (useProjection) {
        tcoordFSDec.push('in vec3 projectionDirVSOutput;');
      }
    } else {
      tcoordFSDec.push('uniform vec3 tangentDirection;', 'in vec4 centerlineTopOrientationVSOutput;', 'in vec4 centerlineBotOrientationVSOutput;', ...applyQuaternionToVecShaderFunction);
      if (useProjection) {
        tcoordFSDec.push('uniform vec3 bitangentDirection;');
      }
    }
    const centerPoint = model.renderable.getCenterPoint();
    if (centerPoint) {
      tcoordFSDec.push('uniform vec3 globalCenterPoint;');
    }
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordFSDec = tcoordFSDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;
    let tcoordFSImpl = [];
    if (isDirectionUniform) {
      tcoordFSImpl.push('vec3 samplingDirection = samplingDirVSOutput;');
      if (useProjection) {
        tcoordFSImpl.push('vec3 projectionDirection = projectionDirVSOutput;');
      }
    } else {
      // Slerp or lerp between centerlineTopDirVSOutput and centerlineBotDirVSOutput
      // We use quadOffsetVSOutput.y: bottom = 0.0; top = 1.0;
      tcoordFSImpl.push(
      // Slerp / Lerp
      'vec4 q0 = centerlineBotOrientationVSOutput;', 'vec4 q1 = centerlineTopOrientationVSOutput;', 'float qCosAngle = dot(q0, q1);', 'vec4 interpolatedOrientation;', 'if (qCosAngle > 0.999 || qCosAngle < -0.999) {', '  // Use LERP instead of SLERP when the two quaternions are close or opposite', '  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));', '} else {', '  float omega = acos(qCosAngle);', '  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);', '}', 'vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);');
      if (useProjection) {
        tcoordFSImpl.push('vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);');
      }
    }
    if (centerPoint) {
      tcoordFSImpl.push('float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);', 'float horizontalOffset = quadOffsetVSOutput.x + baseOffset;');
    } else {
      tcoordFSImpl.push('float horizontalOffset = quadOffsetVSOutput.x;');
    }
    tcoordFSImpl.push('vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;', 'vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;', 'if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}');
    if (useProjection) {
      const projectionMode = model.renderable.getProjectionMode();
      switch (projectionMode) {
        case ProjectionMode.MIN:
          tcoordFSImpl.push('const vec4 initialProjectionTextureValue = vec4(1.0);');
          break;
        case ProjectionMode.MAX:
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push('const vec4 initialProjectionTextureValue = vec4(0.0);');
          break;
      }

      // Loop on all the samples of the projection
      tcoordFSImpl.push('vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;', 'vec3 projectionStep = projectionStepLength * projectionScaledDirection;', 'vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;', 'vec4 tvalue = initialProjectionTextureValue;', 'for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {', '  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;', '  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);');
      switch (projectionMode) {
        case ProjectionMode.MAX:
          tcoordFSImpl.push('  tvalue = max(tvalue, sampledTextureValue);');
          break;
        case ProjectionMode.MIN:
          tcoordFSImpl.push('  tvalue = min(tvalue, sampledTextureValue);');
          break;
        case ProjectionMode.AVERAGE:
        default:
          tcoordFSImpl.push('  tvalue = tvalue + sampledTextureValue;');
          break;
      }
      tcoordFSImpl.push('}');

      // Process the total if needed
      if (projectionMode === ProjectionMode.AVERAGE) {
        tcoordFSImpl.push('tvalue = tvalue / float(projectionSlabNumberOfSamples);');
      }
    } else {
      tcoordFSImpl.push('vec4 tvalue = texture(volumeTexture, volumePosTC);');
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      for (let comp = 0; comp < tNumComp; ++comp) {
        tcoordFSImpl = tcoordFSImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);
          break;
        case 2:
          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);
          break;
        case 3:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);
          break;
        default:
          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;

    // Picking shader replacements
    if (model.haveSeenDepthRequest) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macros2.m.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;
      VSSource = ShaderProgram/* default.substitute */.A.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS_glsl.v;
    shaders.Fragment = vtkPolyDataFS_glsl.v;
    shaders.Geometry = '';
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const cellArrayBufferObject = cellBO.getCABO();
    if (cellArrayBufferObject.getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, 'vertexMC', cellArrayBufferObject.getVertexOffset(), cellArrayBufferObject.getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      // Custom data of the CABO (centerlinePosition, centerlineTopDirection,
      // centerlineBotDirection, quadIndex and user defined custom data)
      cellBO.getCABO().getCustomData().forEach(data => {
        if (data && program.isAttributeUsed(data.name) && !cellBO.getVAO().addAttributeArray(program, cellArrayBufferObject, data.name, data.offset, cellArrayBufferObject.getStride(), model.context.FLOAT, data.components, model.context.FALSE)) {
          vtkErrorMacro(`Error setting ${data.name} in shader VAO.`);
        }
      });
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.volumeTexture.getTextureUnit();
    program.setUniformi('volumeTexture', texUnit);
    program.setUniformf('width', model.renderable.getWidth());
    cellBO.getProgram().setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());
    if (program.isUniformUsed('tangentDirection')) {
      const tangentDirection = model.renderable.getTangentDirection();
      cellBO.getProgram().setUniform3fArray('tangentDirection', tangentDirection);
    }
    if (program.isUniformUsed('bitangentDirection')) {
      const bitangentDirection = model.renderable.getBitangentDirection();
      cellBO.getProgram().setUniform3fArray('bitangentDirection', bitangentDirection);
    }
    if (program.isUniformUsed('centerlineOrientation')) {
      const uniformOrientation = model.renderable.getUniformOrientation();
      cellBO.getProgram().setUniform4fv('centerlineOrientation', uniformOrientation);
    }
    if (program.isUniformUsed('globalCenterPoint')) {
      const centerPoint = model.renderable.getCenterPoint();
      program.setUniform3fArray('globalCenterPoint', centerPoint);
    }
    // Projection uniforms
    if (model.renderable.isProjectionEnabled()) {
      const image = model.currentImageDataInput;
      const spacing = image.getSpacing();
      const dimensions = image.getDimensions();
      const projectionSlabThickness = model.renderable.getProjectionSlabThickness();
      const projectionSlabNumberOfSamples = model.renderable.getProjectionSlabNumberOfSamples();
      const volumeSize = esm/* vec3.mul */.eR.mul([], spacing, dimensions);
      program.setUniform3fArray('volumeSizeMC', volumeSize);
      program.setUniformi('projectionSlabNumberOfSamples', projectionSlabNumberOfSamples);
      const constantOffset = -0.5 * projectionSlabThickness;
      program.setUniformf('projectionConstantOffset', constantOffset);
      const stepLength = projectionSlabThickness / (projectionSlabNumberOfSamples - 1);
      program.setUniformf('projectionStepLength', stepLength);
    }

    // Model coordinates to image space
    // getWorldToIndex is badly named and is in fact modelToIndex
    // MCIC -> Model coordinates to index coordinates
    // MCTC -> Model coordinates to texture coordinates
    const image = model.currentImageDataInput;
    const MCICMatrix = image.getWorldToIndex();
    const ICTCMatrix = esm/* mat4.fromScaling */.pB.fromScaling(new Float32Array(16), esm/* vec3.inverse */.eR.inverse([], image.getDimensions()));
    const MCTCMatrix = esm/* mat4.mul */.pB.mul(ICTCMatrix, ICTCMatrix, MCICMatrix);
    program.setUniformMatrix('MCTCMatrix', MCTCMatrix);
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        macros2.m.vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellArrayBufferObject.getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellArrayBufferObject.getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? esm/* mat4.copy */.pB.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        esm/* mat4.transpose */.pB.transpose(mat, mat);
        esm/* mat4.multiply */.pB.multiply(mat, mat, inverseShiftScaleMatrix);
        esm/* mat4.transpose */.pB.transpose(mat, mat);
      }

      // transform crop plane normal with transpose(inverse(worldToIndex))
      esm/* mat4.transpose */.pB.transpose(model.imagemat, model.currentImageDataInput.getIndexToWorld());
      esm/* mat4.multiply */.pB.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      program.setUniformi('numClipPlanes', numClipPlanes);
      program.setUniform4fv('clipPlanes', planeEquations);
    }

    // handle coincident
    if (program.isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      program.setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (program.isUniformUsed('cfactor')) {
        program.setUniformf('cfactor', cp.factor);
      }
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const MCWCMatrix = model.openGLImageSlice.getKeyMatrices().mcwc;
    const WCPCMatrix = model.openGLCamera.getKeyMatrices(ren).wcpc;
    esm/* mat4.multiply */.pB.multiply(model.imagemat, WCPCMatrix, MCWCMatrix);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      esm/* mat4.multiply */.pB.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    cellBO.getProgram().setUniformMatrix('MCPCMatrix', model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);

    // Component mix
    // Independent components: Mixed according to component weights
    // Dependent components: Mixed using the following logic:
    //    - 2 comps => LA
    //    - 3 comps => RGB + opacity from pwf
    //    - 4 comps => RGBA
    const numComp = model.volumeTexture.getComponents();
    const iComps = ppty.getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; ++i) {
        program.setUniformf(`mix${i}`, ppty.getComponentWeight(i));
      }
    }

    // Color opacity map
    const volInfo = model.volumeTexture.getVolumeInfo();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = ppty.getColorWindow();
      let cl = ppty.getColorLevel();
      const target = iComps ? i : 0;
      const cfun = ppty.getRGBTransferFunction(target);
      if (cfun && ppty.getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = volInfo.scale[i] / cw;
      const shift = (volInfo.offset[i] - cl) / cw + 0.5;
      program.setUniformf(`cshift${i}`, shift);
      program.setUniformf(`cscale${i}`, scale);
    }
    const texColorUnit = model.colorTexture.getTextureUnit(); // TODO
    program.setUniformi('colorTexture1', texColorUnit);

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = ppty.getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = volInfo.scale[i] / length;
        pwfShift = (volInfo.offset[i] - mid) / length + 0.5;
      }
      program.setUniformf(`pwfshift${i}`, pwfShift);
      program.setUniformf(`pwfscale${i}`, pwfScale);
    }
    const texOpacityUnit = model.pwfTexture.getTextureUnit(); // TODO
    program.setUniformi('pwfTexture1', texOpacityUnit);
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.delete = macros2.m.chain(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  currentRenderPass: null,
  volumeTexture: null,
  colorTexture: null,
  pwfTexture: null,
  tris: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
  lastIndependentComponents: 0,
  imagemat: null,
  imagematinv: null
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);

  // Two inputs: one for the ImageData/Texture and one for the PolyData (centerline)
  macros2.m.algo(publicAPI, model, 2, 0);
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.volumeTexture = null;
  model.colorTexture = null;
  model.pwfTexture = null;
  model.imagemat = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.imagematinv = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  macros2.m.obj(model.VBOBuildTime, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLImageCPRMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkOpenGLImageCPRMapper');
const STATIC = {};

// ----------------------------------------------------------------------------

var index = {
  newInstance,
  extend,
  ...STATIC
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkImageCPRMapper', newInstance);




/***/ }),

/***/ 6814:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkImageMapper)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _Core_ImageMapper_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94520);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42008);
/* harmony import */ var _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28914);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71650);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16632);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(79525);
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18713);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25196);
/* harmony import */ var _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(71995);
/* harmony import */ var _Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(52271);
/* harmony import */ var _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(91732);
/* harmony import */ var _RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(90919);
/* harmony import */ var _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(84839);
/* harmony import */ var _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(23159);
/* harmony import */ var _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(83534);
/* harmony import */ var _Core_Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(57285);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(88691);
/* harmony import */ var _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(7698);





















const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_2__.c;
const {
  SlicingMode
} = _Core_ImageMapper_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function splitStringOnEnter(inputString) {
  // Split the input string into an array of lines based on "Enter" (newline) characters
  // Remove any leading or trailing whitespace from each line and filter out empty lines
  const lines = inputString.split('\n');
  const trimmedLines = [];
  for (let i = 0; i < lines.length; ++i) {
    const trimmedLine = lines[i].trim();
    if (trimmedLine.length > 0) {
      trimmedLines.push(trimmedLine);
    }
  }
  return trimmedLines;
}

// ----------------------------------------------------------------------------
// vtkOpenGLImageMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageMapper');
  function unregisterGraphicsResources(renderWindow) {
    // The openGLTexture is not shared
    model.openGLTexture.releaseGraphicsResources(renderWindow);
    // All these other resources are shared
    [model._colorTransferFunc, model._pwFunc, model._labelOutlineThicknessArray].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      // is slice set by the camera
      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_19__/* .Resolve */ .XK.PolygonOffset) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };

  // Renders myself
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_14__.v;
    shaders.Fragment = _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_15__.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;
    VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;
    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    let tcoordDec = ['varying vec2 tcoordVCVSOutput;',
    // color shift and scale
    'uniform float cshift0;', 'uniform float cscale0;',
    // pwf shift and scale
    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform sampler2D labelOutlineTexture1;', 'uniform float opacity;', 'uniform float outlineOpacity;'];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
        // color shift and scale
        `uniform float cshift${comp};`, `uniform float cscale${comp};`,
        // weighting shift and scale
        `uniform float pwfshift${comp};`, `uniform float pwfscale${comp};`]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;

    // check for the outline thickness and opacity
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::LabelOutline::Dec', ['uniform int outlineThickness;', 'uniform float vpWidth;', 'uniform float vpHeight;', 'uniform float vpOffsetX;', 'uniform float vpOffsetY;', 'uniform mat4 PCWCMatrix;', 'uniform mat4 vWCtoIDX;', 'uniform ivec3 imageDimensions;', 'uniform int sliceAxis;']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::LabelOutlineHelperFunction', ['#ifdef vtkImageLabelOutlineOn', 'vec3 fragCoordToIndexSpace(vec4 fragCoord) {', '  vec4 pcPos = vec4(', '    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,', '    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,', '    (fragCoord.z - 0.5) * 2.0,', '    1.0);', '', '  vec4 worldCoord = PCWCMatrix * pcPos;', '  vec4 vertex = (worldCoord/worldCoord.w);', '', '  vec3 index = (vWCtoIDX * vertex).xyz;', '', '  // half voxel fix for labelmapOutline', '  return (index + vec3(0.5)) / vec3(imageDimensions);', '}', 'vec2 getSliceCoords(vec3 coord, int axis) {', '  if (axis == 0) return coord.yz;', '  if (axis == 1) return coord.xz;', '  if (axis == 2) return coord.xy;', '}', '#endif']).result;
    }
    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];
      for (let comp = 0; comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([`vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`, `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', [...splitStringOnEnter(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)]).result;
          break;
        case 2:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;
          break;
        case 3:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;
          break;
        default:
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.r)('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed

    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();

    // has the render pass shader replacement changed? Two options
    let needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram()?.getHandle() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.

    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('texture1', texUnit);
    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }
    const oglShiftScale = model.openGLTexture.getShiftAndScale();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = actor.getProperty().getColorWindow();
      let cl = actor.getProperty().getColorLevel();
      const target = iComps ? i : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      const scale = oglShiftScale.scale / cw;
      const shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i}`, shift);
      cellBO.getProgram().setUniformf(`cscale${i}`, scale);
    }

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }
    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);
    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);
    const outlineThicknessUnit = model.labelOutlineThicknessTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('labelOutlineTexture1', outlineThicknessUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.r)('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(mat, mat, inverseShiftScaleMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
      }

      // transform crop plane normal with transpose(inverse(worldToIndex))
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagematinv, mat, model.imagemat);
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);
    }

    // outline thickness and opacity
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const outlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      cellBO.getProgram().setUniformf('outlineOpacity', outlineOpacity);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image = model.currentInput;
    const i2wmat4 = image.getIndexToWorld();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix('MCPCMatrix', model.imagemat);
    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const worldToIndex = image.getWorldToIndex();
      const imageDimensions = image.getDimensions();
      let sliceAxis = model.renderable.getClosestIJKAxis().ijkMode;

      // SlicingMode.NONE equates to SlicingMode.K
      if (sliceAxis === SlicingMode.NONE) {
        sliceAxis = SlicingMode.K;
      }
      program.setUniform3i('imageDimensions', imageDimensions[0], imageDimensions[1], imageDimensions[2]);
      program.setUniformi('sliceAxis', sliceAxis);
      program.setUniformMatrix('vWCtoIDX', worldToIndex);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);

      // Get the projection coordinate to world coordinate transformation matrix.
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf('vpWidth', size[0]);
      program.setUniformf('vpHeight', size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf('vpOffsetX', offset[0] / size[0]);
      program.setUniformf('vpOffsetY', offset[1] / size[1]);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const ppty = actor.getProperty();
    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // activate the texture
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.pwfTexture.activate();

    // draw polygons
    if (model.tris.getCABO().getElementCount()) {
      // First we do the triangles, update the shader, set uniforms, etc.
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {};
  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getCurrentImage();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_6__.u)(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.openGLTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle() || !model.pwfTexture?.getHandle();
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    const dataType = imgScalars.getDataType();
    const numComp = imgScalars.getNumberOfComponents();
    const actorProperty = actor.getProperty();
    const iType = actorProperty.getInterpolationType();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;
    const colorTransferFunc = actorProperty.getRGBTransferFunction();
    const cfunToString = (0,_RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__/* .getTransferFunctionHash */ .gP)(colorTransferFunc, iComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== cfunToString;
    if (reBuildC) {
      model.colorTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: true
      });
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8ClampedArray(cSize);
      // set interpolation on the texture based on property setting
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        model.colorTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        model.colorTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        model.colorTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        model.colorTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      if (colorTransferFunc) {
        const tmpTable = new Float32Array(cWidth * 3);
        for (let c = 0; c < numIComps; c++) {
          const cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.resetFormatAndType();
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, cTable);
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 1] = 255.0 * i / ((cWidth - 1) * 3);
          cTable[i + 2] = 255.0 * i / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, cTable);
      }
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, cfunToString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwFunc = actorProperty.getPiecewiseFunction();
    const pwfunToString = (0,_RenderWindow_resourceSharingHelper_js__WEBPACK_IMPORTED_MODULE_13__/* .getTransferFunctionHash */ .gP)(pwFunc, iComps, numIComps);
    const pwfTex = model._openGLRenderWindow.getGraphicsResourceForObject(pwFunc);
    // rebuild opacity tfun?
    const reBuildPwf = !pwfTex?.oglObject?.getHandle() || pwfTex?.hash !== pwfunToString;
    if (reBuildPwf) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8ClampedArray(pwfSize);
      model.pwfTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: true
      });
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // set interpolation on the texture based on property setting
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        model.pwfTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        model.pwfTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        model.pwfTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        model.pwfTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      if (pwFunc) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);
        for (let c = 0; c < numIComps; ++c) {
          const pwfun = actorProperty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.resetFormatAndType();
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.FLOAT, pwfFloatTable);
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, pwfTable);
      }
      if (pwFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(pwFunc, model.pwfTexture, pwfunToString);
        if (pwFunc !== model._pwFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(pwFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._pwFunc, publicAPI);
        }
        model._pwFunc = pwFunc;
      }
    } else {
      model.pwfTexture = pwfTex.oglObject;
    }

    // Build outline thickness buffer
    publicAPI.updatelabelOutlineThicknessTexture(actor);

    // Find what IJK axis and what direction to slice along
    const {
      ijkMode
    } = model.renderable.getClosestIJKAxis();

    // Find the IJK slice
    let slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      slice = model.renderable.getSliceAtPosition(slice);
    }

    // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,
    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).
    const nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image
    : Math.round(slice);

    // Find sliceOffset
    const ext = image.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
      sliceOffset = nSlice - ext[4];
    }

    // rebuild the VBO if the data has changed
    const toString = `${slice}A${image.getMTime()}A${imgScalars.getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor.getProperty().getInterpolationType()}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const dims = image.getDimensions();
      if (!model.openGLTexture) {
        model.openGLTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
          resizable: true
        });
      }
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Use norm16 for scalar texture if the extension is available
      model.openGLTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      if (iType === _Core_ImageProperty_Constants_js__WEBPACK_IMPORTED_MODULE_12__/* .InterpolationType */ .V.NEAREST) {
        if (new Set([1, 3, 4]).has(numComp) && dataType === _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      } else {
        if (numComp === 4 && dataType === _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR && !iComps) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.LINEAR);
      }
      model.openGLTexture.setWrapS(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Wrap */ .B_.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Wrap */ .B_.CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;
      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i = 0; i < 4; i++) {
        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;
        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;
      }

      // Determine depth position of the slicing plane in the scene.
      // Slicing modes X, Y, and Z use a continuous axis position, whereas
      // slicing modes I, J, and K should use discrete positions.
      const sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      const spatialExt = image.getSpatialExtent();
      const basicScalars = imgScalars.getData();
      let scalars = null;
      // Get right scalars according to slicing mode
      if (ijkMode === SlicingMode.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let j = 0; j < dims[1]; j++) {
            let bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let i = 0; i < dims[0]; i++) {
            let bsIdx = (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[0] + i) * numComp;
            const end = bsIdx + numComp;
            while (bsIdx < end) {
              scalars[id++] = basicScalars[bsIdx++];
            }
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro('Reformat slicing not yet supported.');
      }

      /**
       *
       * Fetch the ranges of the source volume, `imgScalars`, and use them when
       * creating the texture. Whilst the pre-calculated ranges may not be
       * strictly correct for the slice, it is guaranteed to be within the
       * source volume's range.
       *
       * There is a significant performance improvement by pre-setting the range
       * of the scalars array particularly when scrolling through the source
       * volume as there is no need to calculate the range of the slice scalar.
       *
       * @type{ import("../../../interfaces").vtkRange[] }
       */
      const ranges = imgScalars.getRanges();

      // Don't share this resource as `scalars` is created in this function
      // so it is impossible to share
      model.openGLTexture.resetFormatAndType();
      model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, model.renderable.getPreferSizeOverAccuracy?.(), ranges);
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      const points = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const tcoords = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName('tcoords');
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_10__/* .Representation */ .YL.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.updatelabelOutlineThicknessTexture = image => {
    const labelOutlineThicknessArray = image.getProperty().getLabelOutlineThicknessByReference();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);

    // compute the join of the labelOutlineThicknessArray so that
    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture
    // or not
    const toString = `${labelOutlineThicknessArray.join('-')}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);

      // Assuming labelOutlineThicknessArray contains the thickness for each segment
      for (let i = 0; i < lWidth; ++i) {
        // Retrieve the thickness value for the current segment index.
        // If the value is undefined, use the first element's value as a default, otherwise use the value (even if 0)
        const thickness = typeof labelOutlineThicknessArray[i] !== 'undefined' ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].newInstance */ .Ay.newInstance({
        resizable: false
      });
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(_Texture_Constants_js__WEBPACK_IMPORTED_MODULE_11__/* .Filter */ .dJ.NEAREST);

      // Create a 2D texture (acting as 1D) from the raw data
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, _Common_Core_DataArray_Constants_js__WEBPACK_IMPORTED_MODULE_4__/* .VtkDataTypes */ .JA.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.delete = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.h)(() => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
  // _scalars: null,
  // _colorTransferFunc: null,
  // _pwFunc: null,
  // _labelOutlineThicknessArray: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.tris = _Helper_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance();
  model.imagemat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.imagematinv = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.projectionToWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.idxToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.idxNormalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9));
  model.modelToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  model.projectionToView = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.e)(publicAPI, model, []);
  model.VBOBuildTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.o)(model.VBOBuildTime);

  // Object methods
  vtkOpenGLImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_2__.n)(extend, 'vtkOpenGLImageMapper');

// ----------------------------------------------------------------------------

var vtkImageMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_18__/* .registerOverride */ .c9)('vtkAbstractImageMapper', newInstance);




/***/ }),

/***/ 64501:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkImageSlice)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLImageSlice methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageSlice');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseZBufferPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(child => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLImageSlice');

// ----------------------------------------------------------------------------

var vtkImageSlice = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkImageSlice', newInstance);




/***/ }),

/***/ 68464:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkPixelSpaceCallbackMapper)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




// import { mat4, vec3 }     from 'gl-matrix';
const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLPixelSpaceCallbackMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();

      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro('No framebuffer to save/restore');
      } else {
        // save framebuffer settings
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }

      // Now we need to restore framebuffer bindings/buffers
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkOpenGLPixelSpaceCallbackMapper');

// ----------------------------------------------------------------------------

var vtkPixelSpaceCallbackMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkPixelSpaceCallbackMapper', newInstance);




/***/ }),

/***/ 62939:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkOpenGLPolyDataMapper$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71650);
/* harmony import */ var _Core_Mapper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82409);
/* harmony import */ var _Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16632);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79525);
/* harmony import */ var _Core_Prop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(46985);
/* harmony import */ var _Core_Property_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89585);
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18713);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(25196);
/* harmony import */ var _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(84839);
/* harmony import */ var _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23159);
/* harmony import */ var _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(83534);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(88691);
/* harmony import */ var _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(57703);
/* harmony import */ var _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(69147);
/* harmony import */ var _Core_Mapper_CoincidentTopologyHelper_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(57285);
/* harmony import */ var _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(7698);



















const {
  FieldAssociations
} = _Common_DataModel_DataSet_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Ay;

/* eslint-disable no-lonely-if */

const {
  primTypes
} = _Helper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Ay;
const {
  Representation,
  Shading
} = _Core_Property_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Ay;
const {
  ScalarMode
} = _Core_Mapper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Ay;
const {
  Filter,
  Wrap
} = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;
const StartEvent = {
  type: 'StartEvent'
};
const EndEvent = {
  type: 'EndEvent'
};
const {
  CoordinateSystem
} = _Core_Prop_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Ay;

// ----------------------------------------------------------------------------
// vtkOpenGLPolyDataMapper methods
// ----------------------------------------------------------------------------

function getPickState(renderer) {
  const selector = renderer.getSelector();
  if (selector) {
    return selector.getCurrentPass();
  }
  return _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.MIN_KNOWN_PASS - 1;
}
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLPolyDataMapper');
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');
      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = _glsl_vtkPolyDataVS_glsl_js__WEBPACK_IMPORTED_MODULE_10__.v;
    shaders.Fragment = _glsl_vtkPolyDataFS_glsl_js__WEBPACK_IMPORTED_MODULE_11__.v;
    shaders.Geometry = '';
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');

    // create the material/color property declarations, and VS implementation
    // these are always defined
    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];
    // add more for specular
    if (lastLightComplexity) {
      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);
    }

    // now handle the more complex fragment shader implementation
    // the following are always defined variables.  We start
    // by assigning a default value from the uniform
    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);
    }
    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);
    }

    // add scalar vertex coloring
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;
    } else {
      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);
            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);
          } else {
            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;
      }
    }
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;

    // check for shadow maps
    const shadowFactor = '';
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
    let sstring = [];
    switch (lastLightComplexity) {
      case 0:
        // no lighting or RENDER_VALUES
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;
        break;
      case 1:
        // headlight
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;
        break;
      case 2:
        // light kit
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);
        }
        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
        break;
      case 3:
        // positional
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
        }
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);
        }
        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
        break;
      default:
        vtkErrorMacro('bad light complexity');
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',
        //  if (!gl_FrontFacing) does not work in intel hd4000 mac
        //  if (int(gl_FrontFacing) == 0) does not work on mesa
        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
        } else {
          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
            // generate a normal for lines, it will be perpendicular to the line
            // and maximally aligned with the camera view direction
            // no clue if this is the best way to do this.
            // the code below has been optimized a bit so what follows is
            // an explanation of the basic approach. Compute the gradient of the line
            // with respect to x and y, the the larger of the two
            // cross that with the camera view direction. That gives a vector
            // orthogonal to the camera view and the line. Note that the line and the camera
            // view are probably not orthogonal. Which is why when we cross result that with
            // the line gradient again we get a reasonable normal. It will be othogonal to
            // the line (which is a plane but maximally aligned with the camera view.
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
            ).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;
          } else {
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', [
            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
            ).result;
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',
            // the code below is faster, but does not work on some devices
            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    // replace common shader code
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;

    // do we need the vertex in the shader in View Coordinates
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity > 0) {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;
      GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;
    } else {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;

      // we only handle the first texture by default
      // additional textures are activated and we set the uniform
      // for the texture unit they are assigned to, but you have to
      // add in the shader code to do something with them
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
              break;
            case 2:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
              break;
            default:
              FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
          }
        }
      } else {
        VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;
        GSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;
        switch (tNumComp) {
          case 1:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
            break;
          case 2:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
            break;
          default:
            FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    // 1. ResolveCoincidentTopology is On and non zero for this primitive
    // type
    let cp = {
      factor: 0.0,
      offset: 0.0
    };
    const prop = actor.getProperty();
    if (
    // backwards compat with code that (errorneously) set this to boolean
    // eslint-disable-next-line eqeqeq
    model.renderable.getResolveCoincidentTopology() == _Core_Mapper_Static_js__WEBPACK_IMPORTED_MODULE_17__/* .Resolve */ .XK.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2.0;
        cp.offset /= 2.0;
      }
    }

    // hardware picking always offset due to saved zbuffer
    // This gets you above the saved surface depth buffer.
    const selector = model._openGLRenderer.getSelector();
    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      cp.offset -= 2.0;
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    let VSSource = shaders.Vertex;
    FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;
    if (!model._openGLRenderer.getSelector()) {
      return;
    }
    if (model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24 || model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24) {
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\n', 'uniform int VertexIDOffset;\n']).result;
      VSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\n').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;
    }
    switch (model.lastSelectionState) {
      case _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;
        break;
      case _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);').result;
        break;
      default:
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;
        FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
    }
    shaders.Fragment = FSSource;
    shaders.Vertex = VSSource;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;
    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;

    // different algo from C++ as of 5/2019
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode = cellBO.getOpenGLMode(representation, primType);
    // 1) all surfaces need lighting
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
      // 2) all cell normals without point normals need lighting
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
      // 3) Phong + pointNormals need lighting
    } else if (!flat && pointNormals) {
      needLighting = true;
      // 4) Phong Lines need lighting
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    // 5) everything else is unlit

    // do we need lighting?
    if (actor.getProperty().getLighting() && needLighting) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }

    // has the render pass shader replacement changed? Two options
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }

    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    // render pass shader replacement changed
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach(object => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {
      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro('Error setting normalMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('normalMC');
      }
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('tcoordMC');
      }
      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro('Error setting scalarColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('scalarColor');
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      const planeEquations = [];
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(mat, mat, inverseShiftScaleMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(mat, mat);
      }
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index = 0; index < tus.length; ++index) {
        const tex = tus[index];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }

    // handle depth requests
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }

    // handle wide lines
    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
    const selector = model._openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    // for unlit and headlight there are no lighting parameters
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity < 2) {
      return;
    }
    const program = cellBO.getProgram();

    // bind some light settings
    let numberOfLights = 0;
    const lights = ren.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        // get required info from light
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();
        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.l)(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.l)(model.lightDirection);
        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
        numberOfLights++;
      }
    }

    // we are done unless we have positional lights
    if (lastLightComplexity < 3) {
      return;
    }

    // for lightkit case there are some parameters to set
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const lp = light.getTransformedPosition();
        const np = new Float64Array(3);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .vec3.transformMat4 */ .eR.transformMat4(np, lp, viewTF);
        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();
    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {
      const size = model._openGLRenderer.getTiledSizeAndOrigin();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(model.tmpMat4);
      model.tmpMat4[0] = 2.0 / size.usize;
      model.tmpMat4[12] = -1.0;
      model.tmpMat4[5] = 2.0 / size.vsize;
      model.tmpMat4[13] = -1.0;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
    } else {
      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4 */ .pB, model.tmpMat4));
    }
    if (program.isUniformUsed('MCVCMatrix')) {
      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4 */ .pB, model.tmpMat4));
    }
    if (program.isUniformUsed('normalMatrix')) {
      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3 */ .w0, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed('cameraParallel')) {
        program.setUniformi('cameraParallel', cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      // reset the cam mtime as actor modified the shader values
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    let ppty = actor.getProperty();
    let opacity = ppty.getOpacity();
    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();
    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();
    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();
    const specularPower = ppty.getSpecularPower();
    program.setUniformf('opacityUniform', opacity);
    program.setUniform3fArray('ambientColorUniform', aColor);
    program.setUniform3fArray('diffuseColorUniform', dColor);
    program.setUniformf('ambient', aIntensity);
    program.setUniformf('diffuse', dIntensity);

    // we are done unless we have lighting
    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
    if (lastLightComplexity < 1) {
      return;
    }
    let sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray('specularColorUniform', sColor);
    program.setUniformf('specularPowerUniform', specularPower);
    program.setUniformf('specular', sIntensity);

    // now set the backface properties if we have them
    if (program.isUniformUsed('ambientIntensityBF')) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf('ambientIntensityBF', aIntensity);
      program.setUniformf('diffuseIntensityBF', dIntensity);
      program.setUniformf('opacityUniformBF', opacity);
      program.setUniform3fArray('ambientColorUniformBF', aColor);
      program.setUniform3fArray('diffuseColorUniformBF', dColor);

      // we are done unless we have lighting
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf('specularIntensityBF', sIntensity);
      program.setUniform3fArray('specularColorUniformBF', sColor);
      program.setUniformf('specularPowerUniformBF', specularPower);
    }
  };
  publicAPI.updateMaximumPointCellIds = (ren, actor) => {
    const selector = model._openGLRenderer.getSelector();
    if (!selector) {
      return;
    }
    if (model.selectionWebGLIdsToVTKIds?.points?.length) {
      const length = model.selectionWebGLIdsToVTKIds.points.length;
      selector.setMaximumPointId(length - 1);
    }
    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {
      const length = model.selectionWebGLIdsToVTKIds.cells.length;
      selector.setMaximumCellId(length - 1);
    }
    const fieldAssociation = selector.getFieldAssociation();
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      model.pointPicking = true;
    }
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    model.vertexIDOffset = 0;
    const picking = getPickState(model._openGLRenderer);
    if (model.lastSelectionState !== picking) {
      model.selectionStateChanged.modified();
      model.lastSelectionState = picking;
    }
    if (model._openGLRenderer.getSelector()) {
      switch (picking) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // If we are coloring by texture, then load the texture map.
    // Use Map as indicator, because texture hangs around.
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;
    const selector = model._openGLRenderer.getSelector();
    // If we are picking points, we need to tell it to the helper
    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_LOW24 || model.lastSelectionState === _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.ID_HIGH24);

    // for every primitive type
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      model.primitives[i].setPointPicking(pointPicking);
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);
        // don't draw edges when rendering depth or rendering for picking
        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
        }
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,_Common_Core_Math_index_js__WEBPACK_IMPORTED_MODULE_4__.u)(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    // Always call this function as the selector can change
    publicAPI.updateMaximumPointCellIds();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      // We must figure out how the scalars should be mapped to the polydata.
      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }

    // Do we have normals?
    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }

    // rebuild the VBO if the data has changed we create a string for the VBO what
    // can change the VBO? points normals tcoords colors so what can change those?
    // the input data is clearly one as it can change all four items tcoords may
    // haveTextures or not colors may change based on quite a few mapping
    // parameters in the mapper

    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }

    // Flag to check if tcoords are per cell instead of per point
    let useTCoordsPerCell = false;
    // handle color mapping via texture
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      // the following 4 lines allow for NPOT textures
      tex.setMinificationFilter(Filter.NEAREST);
      tex.setMagnificationFilter(Filter.NEAREST);
      tex.setWrapS(Wrap.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        vertexOffset: 0,
        // Used to keep track of vertex ids across primitives for selection
        useTCoordsPerCell,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
      };
      if (model.renderable.getPopulateSelectionSettings()) {
        model.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        };
      }
      const primitives = [{
        inRep: 'verts',
        cells: poly.getVerts()
      }, {
        inRep: 'lines',
        cells: poly.getLines()
      }, {
        inRep: 'polys',
        cells: poly.getPolys()
      }, {
        inRep: 'strips',
        cells: poly.getStrips()
      }, {
        inRep: 'polys',
        cells: poly.getPolys()
      }, {
        inRep: 'strips',
        cells: poly.getStrips()
      }];
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {
          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
          options.vertexOffset += model.primitives[i].getCABO().getElementCount();
        } else {
          // if we have edge visibility build the edge VBOs
          if (drawSurfaceWithEdges) {
            // VBOs for edges in "surface with edges" are the last to be built,
            // they are not used when picking with a hardware selector so they
            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset
            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {
              ...options,
              tcoords: null,
              colors: null,
              haveCellScalars: false,
              haveCellNormals: false
            });
          } else {
            // otherwise free them
            model.primitives[i].releaseGraphicsResources();
          }
        }
      }
      if (model.renderable.getPopulateSelectionSettings()) {
        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
      }
      model.VBOBuildString = toString;
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach(prim => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    // Return in MB
    return memUsed;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [],
  // used internally
  diffuseColor: [],
  // used internally
  specularColor: [],
  // used internally
  lightColor: [],
  // used internally
  lightDirection: [],
  // used internally
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastSelectionState: _HardwareSelector_Constants_js__WEBPACK_IMPORTED_MODULE_14__/* .PassTypes */ .T.MIN_KNOWN_PASS - 1,
  selectionStateChanged: null,
  selectionWebGLIdsToVTKIds: null,
  pointPicking: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  _ReplacementShaderMapper_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9));
  model.tmpMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16));
  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = _Helper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  model.VBOBuildTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.VBOBuildTime, {
    mtime: 0
  });
  model.selectionStateChanged = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.selectionStateChanged, {
    mtime: 0
  });

  // Object methods
  vtkOpenGLPolyDataMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLPolyDataMapper');

// ----------------------------------------------------------------------------

var vtkOpenGLPolyDataMapper$1 = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_13__/* .registerOverride */ .c9)('vtkMapper', newInstance);




/***/ }),

/***/ 90919:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   eS: () => (/* binding */ getImageDataHash),
/* harmony export */   gP: () => (/* binding */ getTransferFunctionHash)
/* harmony export */ });
/* unused harmony export default */
// See typescript header for documentation

function getTransferFunctionHash(transferFunction, useIndependentComponents, numberOfComponents) {
  return transferFunction ? `${transferFunction.getMTime()}-${useIndependentComponents}-${numberOfComponents}` : '0';
}
function getImageDataHash(image, scalars) {
  return `${image.getMTime()}A${scalars.getMTime()}`;
}
var resourceSharingHelper = {
  getTransferFunctionHash,
  getImageDataHash
};




/***/ }),

/***/ 63819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkRenderer)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88691);




const {
  vtkDebugMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLRenderer methods
// ----------------------------------------------------------------------------
/* eslint-disable no-bitwise */

function vtkOpenGLRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderer');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0.0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro('No lights are on, creating one.');
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.zBufferPass = prepass => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1.0, 0.0, 0.0, 1.0);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1.0);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);

  // Renders myself
  publicAPI.cameraPass = prepass => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();

    // if there is no window assume 0 1
    const tileViewPort = [0.0, 0.0, 1.0, 1.0];

    // find the lower left corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];

    // store the result as a pixel value
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);

    // find the upper right corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

    // now compute the size of the intersection of the viewport with the
    // current tile
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      // renderable ensures that background has 4 entries.
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1.0);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
    /* eslint-enable no-bitwise */
  };

  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    // Releasing resources means that the next render should re-create resources
    if (model.renderable) {
      model.renderable.getViewProps().forEach(prop => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.g)(publicAPI, model, ['shaderCache']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.e)(publicAPI, model, ['selector']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.i)(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkOpenGLRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.n)(extend, 'vtkOpenGLRenderer');

// ----------------------------------------------------------------------------

var vtkRenderer = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkRenderer', newInstance);




/***/ }),

/***/ 83534:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkReplacementShaderMapper)
/* harmony export */ });
/* harmony import */ var _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18713);


function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);

    // if we need an offset handle it here
    // The value of .000016 is suitable for depth buffers
    // of at least 16 bit depth. We do not query the depth
    // right now because we would need some mechanism to
    // cache the result taking into account FBO changes etc.
    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {
      let FSSource = shaders.Fragment;
      FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;
      if (model.context.getExtension('EXT_frag_depth')) {
        if (cp.factor !== 0.0) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
        } else {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0.0) {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
        } else {
          FSSource = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = _ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].substitute */ .A.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;

    // apply any renderPassReplacements
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;

    // user specified pre replacements
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);

    // user specified post replacements
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== undefined) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};




/***/ }),

/***/ 18713:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ vtkShaderProgram$1)
});

// UNUSED EXPORTS: substitute

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js


const {
  vtkErrorMacro
} = macros2.m;

// export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];

// ----------------------------------------------------------------------------
// vtkShader methods
// ----------------------------------------------------------------------------

function vtkShader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShader');
  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === 'Unknown') {
      return false;
    }

    // Ensure we delete the previous shader if necessary.
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      // case vtkShader::Geometry:
      //   type = GL_GEOMETRY_SHADER;
      //   break;
      case 'Fragment':
        stype = model.context.FRAGMENT_SHADER;
        break;
      case 'Vertex':
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }

    // The shader compiled, store its handle and return success.
    return true;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  shaderType: 'Unknown',
  source: '',
  error: '',
  handle: 0,
  dirty: false,
  context: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['shaderType', 'source', 'error', 'handle', 'context']);

  // Object methods
  vtkShader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkShader');

// ----------------------------------------------------------------------------

var vtkShader$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js



const {
  vtkErrorMacro: ShaderProgram_vtkErrorMacro
} = macros2.m;

// perform in place string substitutions, indicate if a substitution was done
// this is useful for building up shader strings which typically involve
// lots of string substitutions. Return true if a substitution was done.
function substitute(source, search, replace, all) {
  // We only accept strings or array of strings, typeof is faster than Array.isArray
  const replaceStr = typeof replace === 'string' ? replace : replace.join('\n');

  // We don't need to instantiate a RegExp if we don't want a global substitution.
  // In all other cases, we need to take the provided string or RegExp and
  // instantiate a new one to add the `g` flag.
  // Argument defaults are transpiled to slow `arguments`-based operations
  // better assume undefined as flag to know if the value is set or not
  const replaceSearch = all === false ? search : new RegExp(search, 'g');
  const resultstr = source.replace(replaceSearch, replaceStr);
  return {
    // If the result is different than the input, we did perform a replacement
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}

// ----------------------------------------------------------------------------
// vtkShaderProgram methods
// ----------------------------------------------------------------------------

function vtkShaderProgram(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderProgram');
  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      ShaderProgram_vtkErrorMacro(model.vertexShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
      ShaderProgram_vtkErrorMacro(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      ShaderProgram_vtkErrorMacro(model.fragmentShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
      ShaderProgram_vtkErrorMacro(model.fragmentShader.getError());
      return 0;
    }
    // skip geometry for now
    if (!publicAPI.attachShader(model.vertexShader)) {
      ShaderProgram_vtkErrorMacro(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      ShaderProgram_vtkErrorMacro(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      ShaderProgram_vtkErrorMacro(`Links failed: ${model.error}`);
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }
    publicAPI.release();
    if (model.vertexShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.vertexShaderHandle);
      model.vertexShaderHandle = 0;
    }
    if (model.fragmentShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.fragmentShaderHandle);
      model.fragmentShaderHandle = 0;
    }
    model.context.deleteProgram(model.handle);
    model.handle = 0;
    publicAPI.setCompiled(false);
  };
  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = () => !!model.bound;
  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = ctx => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = () => {
    if (model.linked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = 'Program has not been initialized, and/or does not have shaders.';
      return false;
    }

    // clear out the list of uniforms used
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      ShaderProgram_vtkErrorMacro(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = (name, a1, a2, a3) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a3 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = (name, a) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function (name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = name => {
    if (!name || !model.linked) {
      return -1;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = name => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc !== null;
    }
    if (!model.linked) {
      ShaderProgram_vtkErrorMacro('attempt to find uniform when the shader program is not linked');
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = name => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      ShaderProgram_vtkErrorMacro('attempt to find uniform when the shader program is not linked');
      return false;
    }
    const loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = shader => {
    if (shader.getHandle() === 0) {
      model.error = 'Shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }
    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = 'Could not create shader program.';
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === 'Vertex') {
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === 'Fragment') {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = shader => {
    if (shader.getHandle() === 0) {
      model.error = 'shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }
    if (model.handle === 0) {
      model.error = 'This shader program has not been initialized yet.';
    }
    switch (shader.getShaderType()) {
      case 'Vertex':
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case 'Fragment':
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = ctx => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = mtime => {
    model.lastCameraMTime = mtime;
  };

  // publicAPI.enableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.enableVertexAttribArray(location);
  //   return true;
  // };

  // publicAPI.disableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.disableVertexAttribArray(location);
  //   return true;
  // };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderProgram_DEFAULT_VALUES = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: '',
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};

// ----------------------------------------------------------------------------

function ShaderProgram_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderProgram_DEFAULT_VALUES, initialValues);

  // Instantiate internal objects
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType('Vertex');
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType('Fragment');
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType('Geometry');

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['lastCameraMTime']);
  macros2.m.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);

  // Object methods
  vtkShaderProgram(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderProgram_newInstance = macros2.m.newInstance(ShaderProgram_extend, 'vtkShaderProgram');

// ----------------------------------------------------------------------------

var vtkShaderProgram$1 = {
  newInstance: ShaderProgram_newInstance,
  extend: ShaderProgram_extend,
  substitute
};




/***/ }),

/***/ 92530:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkSkybox)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42008);
/* harmony import */ var _Helper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71650);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25196);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79525);
/* harmony import */ var _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71995);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(88691);









const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.c;

// ----------------------------------------------------------------------------
// vtkOpenGLSkybox methods
// ----------------------------------------------------------------------------

function vtkOpenGLSkybox(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSkybox');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model._openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi('sbtexture', texUnit);
      const ren = model._openGLRenderer.getRenderable();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = new Float64Array(16);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);
      if (model.lastFormat === 'box') {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();

      // draw polygons
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = () => {
    // build the VBO if needed, only happens once
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = 1.0;
      }
      const points = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = _Common_Core_DataArray_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].newInstance */ .Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', _Core_Property_Constants_js__WEBPACK_IMPORTED_MODULE_6__/* .Representation */ .YL.SURFACE, {
        points,
        cellOffset: 0
      });
    }

    // update the program?
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === 'box') {
        // we invert Y below because opengl is messed up!
        // Cube Maps have been specified to follow the RenderMan
        // specification (for whatever reason), and RenderMan
        // assumes the images' origin being in the upper left,
        // contrary to the usual OpenGL behaviour of having the
        // image origin in the lower left. That's why things get
        // swapped in the Y direction. It totally breaks with the usual
        // OpenGL semantics and doesn't make sense at all.
        // But now we're stuck with it.  From
        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping
        //
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ''));
      }
      if (model.lastFormat === 'background') {
        // maps the texture to the window
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ''));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro('Error setting vertexMC in shader VAO.');
      }
    }

    // set/update the texture map if needed
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro('vtkSkybox requires a texture map');
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.openGLTexture = _Texture_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].newInstance */ .Ay.newInstance();
  model.tris = _Helper_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].newInstance */ .Ay.newInstance();
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(new Float64Array(9)),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(new Float64Array(16))
  };

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.g)(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLSkybox(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend);

// ----------------------------------------------------------------------------

var vtkSkybox = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_7__/* .registerOverride */ .c9)('vtkSkybox', newInstance);




/***/ }),

/***/ 79525:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkOpenGLTexture$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(45043);
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var HalfFloat = __webpack_require__(97888);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js
/**
 * Even when the EXT_texture_norm16 extension is present, linear filtering
 * might not be supported for normalized fixed point textures.
 *
 * This is a driver bug. See https://github.com/KhronosGroup/WebGL/issues/3706
 * @return {boolean}
 */
function supportsNorm16Linear() {
  try {
    const canvasSize = 4;
    const texWidth = 2;
    const texHeight = 1;
    const texData = new Int16Array([0, 2 ** 15 - 1]);
    const pixelToCheck = [1, 1];
    const canvas = document.createElement('canvas');
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const gl = canvas.getContext('webgl2');
    if (!gl) {
      return false;
    }
    const ext = gl.getExtension('EXT_texture_norm16');
    if (!ext) {
      return false;
    }
    const vs = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
    const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vs);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      return false;
    }
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.useProgram(program);
    gl.drawArrays(gl.POINTS, 0, 1);
    const pixel = new Uint8Array(4);
    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    const [r, g, b] = pixel;
    const webglLoseContext = gl.getExtension('WEBGL_lose_context');
    if (webglLoseContext) {
      webglLoseContext.loseContext();
    }
    return r === g && g === b && r !== 0;
  } catch (e) {
    return false;
  }
}

/**
 * @type {boolean | undefined}
 */
let supportsNorm16LinearCache;
function supportsNorm16LinearCached() {
  // Only create a canvas+texture+shaders the first time
  if (supportsNorm16LinearCache === undefined) {
    supportsNorm16LinearCache = supportsNorm16Linear();
  }
  return supportsNorm16LinearCache;
}



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js










const {
  Wrap,
  Filter
} = Constants/* default */.Ay;
const {
  VtkDataTypes
} = DataArray/* default */.Ay;
const {
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} = macros2.c;
const {
  toHalf
} = HalfFloat/* default */.A;

// ----------------------------------------------------------------------------
// vtkOpenGLTexture methods
// ----------------------------------------------------------------------------

function vtkOpenGLTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTexture');
  function getTexParams() {
    return {
      internalFormat: model.internalFormat,
      format: model.format,
      openGLDataType: model.openGLDataType,
      width: model.width,
      height: model.height
    };
  }

  // Renders myself
  publicAPI.render = function () {
    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      // sync renderable properties
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter.NEAREST);
      publicAPI.setMagnificationFilter(Filter.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap.REPEAT);
      publicAPI.setWrapS(Wrap.REPEAT);
      publicAPI.setWrapT(Wrap.REPEAT);
    }
    // clear image if input data is set
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    // create the texture if it is not done already
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      // if we have an Image
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        // Have an Image which may not be complete
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      // if we have a canvas
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        const canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      // if we have jsImageData
      if (model.renderable.getJsImageData() !== null) {
        const jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      // if we have InputData
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();

        // do we have a cube map? Six inputs
        const data = [];
        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          const indata = model.renderable.getInputData(i);
          const scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  const getNorm16Ext = () => {
    if ((model.minificationFilter === Filter.LINEAR || model.magnificationFilter === Filter.LINEAR) && !supportsNorm16LinearCached()) {
      return undefined;
    }
    return model.oglNorm16Ext;
  };

  //----------------------------------------------------------------------------
  publicAPI.destroyTexture = () => {
    // deactivate it first
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model._prevTexParams = null;
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };

  //----------------------------------------------------------------------------
  publicAPI.createTexture = () => {
    // reuse the existing handle if we have one
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);

        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture
        // turn off mip map filter or set the base and max level correctly. here
        // both are done.
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.getTextureUnit = () => {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };

  //---------------------------------------------------------------------------
  publicAPI.activate = () => {
    // activate a free texture unit for this texture
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };

  //---------------------------------------------------------------------------
  publicAPI.deactivate = () => {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.releaseGraphicsResources = rwin => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model._prevTexParams = null;
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      model.allocatedGPUMemoryInBytes = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro('impossible case');
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.sendParameters = () => {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }

    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);
    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);

    model.sendParametersTime.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model._forceInternalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {
      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');
    }
    return model.internalFormat;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;
    // try default next
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());
    if (result) {
      return result;
    }
    if (!result) {
      vtkDebugMacro('Unsupported internal texture type!');
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    return result;
  };
  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;

  //----------------------------------------------------------------------------
  publicAPI.setInternalFormat = iFormat => {
    model._forceInternalFormat = true;
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      // webgl1
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.resetFormatAndType = () => {
    model._prevTexParams = null;
    model.format = 0;
    model.internalFormat = 0;
    model._forceInternalFormat = false;
    model.openGLDataType = 0;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultDataType = vtkScalarType => {
    const useHalfFloat = publicAPI.useHalfFloat();
    // DON'T DEAL with VTK_CHAR as this is platform dependent.
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        // case VtkDataTypes.SIGNED_CHAR:
        //   return model.context.BYTE;
        case VtkDataTypes.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        // prefer norm16 since that is accurate compared to
        // half float which is not
        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.SHORT:
          return model.context.SHORT;
        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:
          return model.context.UNSIGNED_SHORT;
        // use half float type
        case useHalfFloat && VtkDataTypes.SHORT:
          return model.context.HALF_FLOAT;
        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:
          return model.context.HALF_FLOAT;
        // case VtkDataTypes.INT:
        //   return model.context.INT;
        // case VtkDataTypes.UNSIGNED_INT:
        //   return model.context.UNSIGNED_INT;
        case VtkDataTypes.FLOAT:
        case VtkDataTypes.VOID: // used for depth component textures.
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      // case VtkDataTypes.SIGNED_CHAR:
      //   return model.context.BYTE;
      case VtkDataTypes.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      // case VtkDataTypes.SHORT:
      //   return model.context.SHORT;
      // case VtkDataTypes.UNSIGNED_SHORT:
      //   return model.context.UNSIGNED_SHORT;
      // case VtkDataTypes.INT:
      //   return model.context.INT;
      // case VtkDataTypes.UNSIGNED_INT:
      //   return model.context.UNSIGNED_INT;
      case VtkDataTypes.FLOAT:
      case VtkDataTypes.VOID: // used for depth component textures.
      default:
        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
          return model.context.FLOAT;
        }
        {
          const halfFloat = model.context.getExtension('OES_texture_half_float');
          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLDataType = function (vtkScalarType) {
    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!model.openGLDataType || forceUpdate) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = () => {
    let shift = 0.0;
    let scale = 1.0;

    // for all float type internal formats
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128.0;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255.0;
        shift = 0.0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768.0;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536.0;
        shift = 0.0;
        break;
      case model.context.INT:
        scale = 2147483647.5;
        shift = scale - 2147483648.0;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295.0;
        shift = 0.0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale
    };
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLFilterMode = emode => {
    switch (emode) {
      case Filter.NEAREST:
        return model.context.NEAREST;
      case Filter.LINEAR:
        return model.context.LINEAR;
      case Filter.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLWrapMode = vtktype => {
    switch (vtktype) {
      case Wrap.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap.REPEAT:
        return model.context.REPEAT;
      case Wrap.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };

  //----------------------------------------------------------------------------

  /**
   * Gets the extent's size.
   * @param {Extent} extent
   */
  function getExtentSize(extent) {
    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;
    return [xmax - xmin + 1, ymax - ymin + 1, zmax - zmin + 1];
  }

  //----------------------------------------------------------------------------

  /**
   * Gets the number of pixels in the extent.
   * @param {Extent} extent
   */
  function getExtentPixelCount(extent) {
    const [sx, sy, sz] = getExtentSize(extent);
    return sx * sy * sz;
  }

  //----------------------------------------------------------------------------

  /**
   * Reads a flattened extent from the image data and writes to the given output array.
   *
   * Assumes X varies the fastest and Z varies the slowest.
   *
   * @param {*} data
   * @param {*} dataDims
   * @param {Extent} extent
   * @param {TypedArray} outArray
   * @param {number} outOffset
   * @returns
   */
  function readExtentIntoArray(data, dataDims, extent, outArray, outOffset) {
    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;
    const [dx, dy] = dataDims;
    const sxy = dx * dy;
    let writeOffset = outOffset;
    for (let zi = zmin; zi <= zmax; zi++) {
      const zOffset = zi * sxy;
      for (let yi = ymin; yi <= ymax; yi++) {
        const zyOffset = zOffset + yi * dx;
        // explicit alternative to data.subarray,
        // due to potential perf issues on v8
        for (let readOffset = zyOffset + xmin, end = zyOffset + xmax; readOffset <= end; readOffset++, writeOffset++) {
          outArray[writeOffset] = data[readOffset];
        }
      }
    }
  }

  //----------------------------------------------------------------------------

  /**
   * Reads several image extents into a contiguous pixel array.
   *
   * @param {*} data
   * @param {Extent[]} extent
   * @param {TypedArrayConstructor} typedArrayConstructor optional typed array constructor
   * @returns
   */
  function readExtents(data, extents) {
    let typedArrayConstructor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const constructor = typedArrayConstructor || data.constructor;
    const numPixels = extents.reduce((count, extent) => count + getExtentPixelCount(extent), 0);
    const extentPixels = new constructor(numPixels);
    const dataDims = [model.width, model.height, model.depth];
    let writeOffset = 0;
    extents.forEach(extent => {
      readExtentIntoArray(data, dataDims, extent, extentPixels, writeOffset);
      writeOffset += getExtentPixelCount(extent);
    });
    return extentPixels;
  }

  //----------------------------------------------------------------------------

  /**
   * Updates the data array to match the required data type for OpenGL.
   *
   * This function takes the input data and converts it to the appropriate
   * format required by the OpenGL texture, based on the specified data type.
   *
   * @param {string} dataType - The original data type of the input data.
   * @param {Array} data - The input data array that needs to be updated.
   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.
   * @param {Array<Extent>} imageExtents only consider these image extents (default: [])
   * @returns {Array} The updated data array that matches the OpenGL data type.
   */
  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {
    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let imageExtents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    const pixData = [];
    let pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    const onlyUpdateExtents = !!imageExtents.length;

    // if the opengl data type is float
    // then the data array must be float
    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          if (onlyUpdateExtents) {
            pixData.push(readExtents(data[idx], imageExtents, Float32Array));
          } else {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Float32Array(dataArrayToCopy));
          }
        } else {
          pixData.push(null);
        }
      }
    }

    // if the opengl data type is ubyte
    // then the data array must be u8, we currently simply truncate the data
    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          if (onlyUpdateExtents) {
            pixData.push(readExtents(data[idx], imageExtents, Uint8Array));
          } else {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Uint8Array(dataArrayToCopy));
          }
        } else {
          pixData.push(null);
        }
      }
    }

    // if the opengl data type is half float
    // then the data array must be u16
    let halfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension('OES_texture_half_float');
      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    if (halfFloat) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const src = onlyUpdateExtents ? readExtents(data[idx], imageExtents) : data[idx];
          const newArray = new Uint16Array(onlyUpdateExtents ? src.length : pixCount);
          const newArrayLen = newArray.length;
          for (let i = 0; i < newArrayLen; i++) {
            newArray[i] = toHalf(src[i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(onlyUpdateExtents && data[i] ? readExtents(data[i], imageExtents) : data[i]);
      }
    }
    return pixData;
  };

  //----------------------------------------------------------------------------
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      // No need if webGL2
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (data && (!(0,Core_Math.V)(width) || !(0,Core_Math.V)(height))) {
      // Scale up the texture to the next highest power of two dimensions.
      const halfFloat = model.context.getExtension('OES_texture_half_float');
      const newWidth = (0,Core_Math.R)(width);
      const newHeight = (0,Core_Math.R)(height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          let usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (let j = 0; j < newHeight; j++) {
            const joff = j * newWidth * numComps;
            const jidx = j * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1.0 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i = 0; i < newWidth; i++) {
              const ioff = i * numComps;
              const iidx = i * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat/* default */.A.toHalf(HalfFloat/* default */.A.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat/* default */.A.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat/* default */.A.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat/* default */.A.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  }

  //----------------------------------------------------------------------------
  function useTexStorage(dataType) {
    if (model._openGLRenderWindow) {
      if (model.resizable || model.renderable?.getResizable()) {
        // Cannot use texStorage if the texture is supposed to be resizable.
        return false;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const webGLInfo = model._openGLRenderWindow.getGLInformations();
        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {
          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.
          // No errors reported but the texture is unusable.
          return false;
        }
        // Use texStorage for WebGL2
        return true;
      }
      return false;
    }
    return false;
  }

  //----------------------------------------------------------------------------
  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {
    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType, true);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Create an array of texture with one texture
    const dataArray = [data];
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // Source texture data from the PBO.
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (scaledData[0] != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    // always reset the flip
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // invert the data because opengl is messed up with cube maps
    // and uses the old renderman standard with Y going down
    // even though it is completely at odds with OpenGL standards
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = (0,macros2.a)(dataType, heightLevel * widthLevel * model.components);
      for (let y = 0; y < heightLevel; ++y) {
        const row1 = y * widthLevel * model.components;
        const row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }

    // Source texture data from the PBO.
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
    }
    // We get the 6 images
    for (let i = 0; i < 6; i++) {
      // For each mipmap level
      let j = 0;
      let w = model.width;
      let h = model.height;
      while (w >= 1 && h >= 1) {
        // In webgl 1, all levels need to be defined. So if the latest level size is
        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)
        // In webgl 2, the attribute maxLevel will be use.
        let tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + i];
        }
        if (useTexStorage(dataType)) {
          if (tempData != null) {
            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
          }
        } else {
          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        }
        j++;
        w /= 2;
        h /= 2;
      }
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    // generateMipmap must not be called here because we manually upload all levels
    // if it is called, all levels will be overwritten

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (data != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.create2DFromImage = image => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.
    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!(0,Core_Math.V)(image.width) || !(0,Core_Math.V)(image.height));
    const canvas = document.createElement('canvas');
    canvas.width = needNearestPowerOfTwo ? (0,Core_Math.R)(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? (0,Core_Math.R)(image.height) : image.height;
    model.width = canvas.width;
    model.height = canvas.height;
    const ctx = canvas.getContext('2d');
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    const safeImage = canvas;
    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (safeImage != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  // Compute scale and offset per component from min and max per component
  function computeScaleOffsets(min, max, numComps) {
    const offset = new Array(numComps);
    const scale = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      offset[c] = min[c];
      scale[c] = max[c] - min[c] || 1.0;
    }
    return {
      scale,
      offset
    };
  }

  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,
  // for numbers outside of this range there is a precision limitation
  function hasExactHalfFloat(offset, scale) {
    // Per Component
    for (let c = 0; c < offset.length; c++) {
      const min = offset[c];
      const max = scale[c] + min;
      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {
        return false;
      }
    }
    return true;
  }
  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
    publicAPI.getOpenGLDataType(dataType);

    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat
    // AND it is not preferable to have a smaller texture than an exact texture.
    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;
    let useHalfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      // If OES_texture_float_linear is not available, and using a half float would still be exact, force half floats
      // This is because half floats are always texture filterable in webgl2, while full *32F floats are not (unless the extension is present)
      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension('OES_texture_float_linear') === null && isExactHalfFloat;
      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension('OES_texture_half_float');
      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;
  }
  function processDataArray(dataArray, preferSizeOverAccuracy) {
    const numComps = dataArray.getNumberOfComponents();
    const dataType = dataArray.getDataType();
    const data = dataArray.getData();

    // Compute min max from array
    // Using the vtkDataArray.getRange() enables caching
    const minArray = new Array(numComps);
    const maxArray = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      const [min, max] = dataArray.getRange(c);
      minArray[c] = min;
      maxArray[c] = max;
    }
    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);

    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247
    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);

    // since our default is to use half float, in case that we can't use it
    // we need to use another type
    if (!publicAPI.useHalfFloat()) {
      publicAPI.getOpenGLDataType(dataType, true);
    }
    return {
      numComps,
      dataType,
      data,
      scaleOffsets
    };
  }
  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    let ranges = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;
    return publicAPI.create2DFilterableFromDataArray(width, height, DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents,
      dataType,
      values,
      ranges
    }), preferSizeOverAccuracy);
  };
  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const {
      numComps,
      dataType,
      data
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);
  };
  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
    let isScalingApplied = false;
    const useHalfFloat = publicAPI.useHalfFloat();

    // Initialize volume info if it doesn't exist
    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {
      model.volumeInfo = {
        scale: new Array(numComps),
        offset: new Array(numComps)
      };
    }

    // Default scaling and offset
    for (let c = 0; c < numComps; ++c) {
      model.volumeInfo.scale[c] = 1.0;
      model.volumeInfo.offset[c] = 0.0;
    }

    // Handle SHORT data type with EXT_texture_norm16 extension
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range
      }

      isScalingApplied = true;
    }

    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range
      }

      isScalingApplied = true;
    }

    // Handle UNSIGNED_CHAR data type
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range
      }

      isScalingApplied = true;
    }

    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)
    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {
      isScalingApplied = true;
    }
    return isScalingApplied;
  };

  //----------------------------------------------------------------------------
  publicAPI.create3DFromRaw = function (width, height, depth, numComps, dataType, data) {
    let updatedExtents = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    let dataTypeToUse = dataType;
    let dataToUse = data;
    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {
      const numPixelsIn = width * height * depth;
      const scaleOffsetsCopy = structuredClone(model.volumeInfo);
      // otherwise convert to float
      const newArray = new Float32Array(numPixelsIn * numComps);
      // use computed scale and offset
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let count = 0;
      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);
      for (let i = 0; i < numPixelsIn; i++) {
        for (let nc = 0; nc < numComps; nc++) {
          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      dataTypeToUse = VtkDataTypes.FLOAT;
      dataToUse = newArray;
    }

    // Permit OpenGLDataType to be half float, if applicable, for 3D
    publicAPI.getOpenGLDataType(dataTypeToUse);

    // Now determine the texture parameters using the arguments.
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const hasUpdatedExtents = updatedExtents.length > 0;

    // It's possible for the texture parameters to change while
    // streaming, so check for such a change.
    const rebuildEntireTexture = !hasUpdatedExtents || !fast_deep_equal_default()(model._prevTexParams, getTexParams());

    // Create an array of texture with one texture
    const dataArray = [dataToUse];
    const is3DArray = true;
    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray, rebuildEntireTexture ? [] : updatedExtents);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (rebuildEntireTexture) {
      if (useTexStorage(dataTypeToUse)) {
        model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
        if (scaledData[0] != null) {
          model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
        }
      } else {
        model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
      }
      model._prevTexParams = getTexParams();
    } else if (hasUpdatedExtents) {
      const extentPixels = scaledData[0];
      let readOffset = 0;
      for (let i = 0; i < updatedExtents.length; i++) {
        const extent = updatedExtents[i];
        const extentSize = getExtentSize(extent);
        const extentPixelCount = getExtentPixelCount(extent);
        const textureData = new extentPixels.constructor(extentPixels.buffer, readOffset, extentPixelCount);
        readOffset += textureData.byteLength;
        model.context.texSubImage3D(model.target, 0, extent[0], extent[2], extent[4], extentSize[0], extentSize[1], extentSize[2], model.format, model.openGLDataType, textureData);
      }
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  // This method simulates a 3D texture using 2D
  // Prefer create3DFilterableFromDataArray to enable caching of min and max values
  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {
    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    let ranges = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;
    let updatedExtents = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
    return publicAPI.create3DFilterableFromDataArray(width, height, depth, DataArray/* default.newInstance */.Ay.newInstance({
      numberOfComponents,
      dataType,
      values,
      ranges
    }), preferSizeOverAccuracy, updatedExtents);
  };

  //----------------------------------------------------------------------------
  // This method create a 3D texture from dimensions and a DataArray
  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {
    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    let updatedExtents = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
    const {
      numComps,
      dataType,
      data,
      scaleOffsets
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    const offset = [];
    const scale = [];
    for (let c = 0; c < numComps; ++c) {
      offset[c] = 0.0;
      scale[c] = 1.0;
    }

    // store the information, we will need it later
    // offset and scale are the offset and scale required to get
    // the texture value back to data values ala
    // data = texture * scale + offset
    // and texture = (data - offset)/scale
    model.volumeInfo = {
      scale,
      offset,
      dataComputedScale: scaleOffsets.scale,
      dataComputedOffset: scaleOffsets.offset,
      width,
      height,
      depth
    };

    // Create a copy of scale and offset to avoid aliasing issues
    // Original is read only, copy is read/write
    // Use the copy as volumeInfo.scale and volumeInfo.offset

    // WebGL2 path, we have 3d textures etc
    if (model._openGLRenderWindow.getWebgl2()) {
      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data, updatedExtents);
    }
    const numPixelsIn = width * height * depth;
    const scaleOffsetsCopy = structuredClone(scaleOffsets);

    // not webgl2, deal with webgl1, no 3d textures
    // and maybe no float textures

    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {
      outArray[outIdx] = inValue;
    };
    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
    // unsigned char gets used as is
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        scaleOffsetsCopy.offset[c] = 0.0;
        scaleOffsetsCopy.scale[c] = 255.0;
      }
    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
      // use float textures scaled to 0.0 to 1.0
      dataTypeToUse = VtkDataTypes.FLOAT;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = (inValue - soffset) / sscale;
      };
    } else {
      // worst case, scale data to uchar
      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;
      };
    }

    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    // have to pack this 3D texture into pot 2D texture
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;

    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,
    // but it doesn't mean it will fit in memory. If we have to use a float data type
    // or 4 components, there are good chances that the texture size will blow up
    // and could not fit in the GPU memory. Use a smaller texture size in that case,
    // which will force a downsampling of the dataset.
    // That problem does not occur when using webGL2 since we can pack the data in
    // denser textures based on our data type.
    // TODO: try to fit in the biggest supported texture, catch the gl error if it
    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }

    // compute estimate for XY subsample
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = (0,Core_Math.R)(targetWidth);
    // determine X reps
    const xreps = Math.floor(targetWidth * xstride / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = (0,Core_Math.R)(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // store the information, we will need it later
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = scaleOffsetsCopy.offset;
    model.volumeInfo.scale = scaleOffsetsCopy.scale;

    // OK stuff the data into the 2d TEXTURE

    // first allocate the new texture
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }

    // then stuff the data into it, nothing fancy right now
    // for stride
    let outIdx = 0;
    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);
    for (let yRep = 0; yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0; tileY < tileHeight; tileY++) {
        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (let tileX = 0; tileX < tileWidth; tileX++) {
            // copy value
            for (let nc = 0; nc < numComps; nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (newArray != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getMaximumTextureSize = ctx => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };

  // set use half float
  publicAPI.enableUseHalfFloat = use => {
    model.enableUseHalfFloat = use;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  _openGLRenderWindow: null,
  _forceInternalFormat: false,
  _prevTexParams: null,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap.CLAMP_TO_EDGE,
  wrapT: Wrap.CLAMP_TO_EDGE,
  wrapR: Wrap.CLAMP_TO_EDGE,
  minificationFilter: Filter.NEAREST,
  magnificationFilter: Filter.NEAREST,
  minLOD: -1000.0,
  maxLOD: 1000.0,
  baseLevel: 0,
  maxLevel: 1000,
  generateMipmap: false,
  oglNorm16Ext: null,
  allocatedGPUMemoryInBytes: 0,
  // by default it is enabled
  enableUseHalfFloat: true,
  // but by default we don't know if we can use half float base on the data range
  canUseHalfFloat: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  (0,macros2.o)(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  (0,macros2.o)(model.textureBuildTime, {
    mtime: 0
  });

  // Build VTK API
  (0,macros2.s)(publicAPI, model, ['format', 'openGLDataType']);
  (0,macros2.e)(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);
  (0,macros2.g)(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);
  (0,macros2.i)(publicAPI, model, ['openGLRenderWindow']);

  // Object methods
  vtkOpenGLTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,macros2.n)(extend, 'vtkOpenGLTexture');

// ----------------------------------------------------------------------------

var vtkOpenGLTexture$1 = {
  newInstance,
  extend,
  ...Constants/* default */.Ay
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkTexture', newInstance);




/***/ }),

/***/ 52271:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ Constants),
/* harmony export */   B_: () => (/* binding */ Wrap),
/* harmony export */   dJ: () => (/* binding */ Filter)
/* harmony export */ });
const Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
const Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants = {
  Wrap,
  Filter
};




/***/ }),

/***/ 13926:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkVertexArrayObject)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60003);



// ----------------------------------------------------------------------------
// vtkOpenGLVertexArrayObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLVertexArrayObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVertexArrayObject');

  // Public API methods
  publicAPI.exposedMethod = () => {
    // This is a publicly exposed method of this object
  };
  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension('OES_vertex_array_object');
      // Start setting up VAO
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = () =>
  // We either probed and allocated a VAO, or are falling back as the current
  // hardware does not support VAOs.
  model.handleVAO !== 0 || model.supported === false;
  publicAPI.bind = () => {
    // Either simply bind the VAO, or emulate behavior by binding all attributes.
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = () => {
    // Either simply release the VAO, or emulate behavior by releasing all attributes.
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);
  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {
    if (!program) {
      return false;
    }

    // Check the program is bound, and the buffer is valid.
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== _BufferObject_Constants_js__WEBPACK_IMPORTED_MODULE_1__/* .ObjectType */ .a.ARRAY_BUFFER) {
      return false;
    }

    // Perform initialization if necessary, ensure program matches VAOs.
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    const gl = model.context;
    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }

    // Always make the call as even the first use wants the attrib pointer setting
    // up when we are emulating.
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();

    // If vertex array objects are not supported then build up our list.
    if (!model.supported) {
      // find the buffer
      let buffFound = false;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {
    // bind the first row of values
    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);
    if (!result) {
      return result;
    }
    const gl = model.context;
    const index = gl.getAttribLocation(model.handleProgram, name);
    for (let i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = name => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }

    // If we don't have real VAOs find the entry and remove it too.
    if (!model.supported) {
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = rw => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Internal objects initialization
  model.buffers = [];

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Create get-only macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['supported']);

  // Create get-set macros
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['forceEmulation']);

  // For more macro methods, see "Sources/macros.js"

  // Object specific methods
  vtkOpenGLVertexArrayObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkOpenGLVertexArrayObject');

// ----------------------------------------------------------------------------

var vtkVertexArrayObject = {
  newInstance,
  extend
};




/***/ }),

/***/ 88691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkViewNodeFactory),
/* harmony export */   c9: () => (/* binding */ registerOverride)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84784);



const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}

// ----------------------------------------------------------------------------
// vtkOpenGLViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkOpenGLViewNodeFactory(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLViewNodeFactory');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Static class mapping shared across instances
  model.overrides = CLASS_MAPPING;

  // Inheritance
  _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkOpenGLViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkViewNodeFactory = {
  newInstance,
  extend
};




/***/ }),

/***/ 8126:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkVolume)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88691);





// ----------------------------------------------------------------------------
// vtkOpenGLVolume methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolume');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = renderPass => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  // Renders myself
  publicAPI.volumePass = prepass => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.MCWCMatrix, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.identity */ .w0.identity(model.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.fromMat4 */ .w0.fromMat4(model.normalMatrix, model.MCWCMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.invert */ .w0.invert(model.normalMatrix, model.normalMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat3.transpose */ .w0.transpose(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
  // _openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.o)(model.keyMatrixTime, {
    mtime: 0
  });
  // always set by getter
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);

  // Build VTK API
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,_macros2_js__WEBPACK_IMPORTED_MODULE_1__.n)(extend, 'vtkOpenGLVolume');

// ----------------------------------------------------------------------------

var vtkVolume = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkVolume', newInstance);




/***/ }),

/***/ 95785:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkVolumeMapper)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/fast-deep-equal/index.js
var fast_deep_equal = __webpack_require__(45043);
var fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants = __webpack_require__(28914);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js + 1 modules
var Helper = __webpack_require__(71650);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
var Framebuffer = __webpack_require__(32821);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js + 1 modules
var Texture = __webpack_require__(79525);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
var ReplacementShaderMapper = __webpack_require__(83534);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js + 1 modules
var ShaderProgram = __webpack_require__(18713);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
var VertexArrayObject = __webpack_require__(13926);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Property_Constants = __webpack_require__(71995);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Texture_Constants = __webpack_require__(52271);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var VolumeProperty_Constants = __webpack_require__(20433);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var VolumeMapper_Constants = __webpack_require__(67737);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/resourceSharingHelper.js
var resourceSharingHelper = __webpack_require__(90919);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define UseIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define vtkCustomComponentsColorMix\n//VTK::CustomComponentsColorMixOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// possibly define any components that are forced to nearest interpolation\n//VTK::vtkForceNearestComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Possibly define vtkLabelEdgeProjectionOn\n//VTK::LabelEdgeProjectionOn\n\n\n#ifdef vtkImageLabelOutlineOn\n  uniform float outlineOpacity;\n  uniform float vpWidth;\n  uniform float vpHeight;\n  uniform float vpOffsetX;\n  uniform float vpOffsetY;\n  uniform mat4 PCWCMatrix;\n  uniform mat4 vWCtoIDX;\n\n  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];\n  #define MAX_SEGMENTS 256\n  #define UINT_SIZE 32\n  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\n\n  uint bitmask[BITMASK_SIZE];\n\n  // Set the corresponding bit in the bitmask\n  void setBit(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    bitmask[index] |= 1u << bitIndex;\n  }\n\n  // Check if a bit is set in the bitmask\n  bool isBitSet(int segmentIndex) {\n    int index = segmentIndex / UINT_SIZE;\n    int bitIndex = segmentIndex % UINT_SIZE;\n    return ((bitmask[index] & (1u << bitIndex)) != 0u);\n  }\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#ifdef UseIndependentComponents\n#if vtkNumComponents > 1\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents > 2\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#if vtkNumComponents > 3\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\nuniform vec3 volumeSpacings; // spacing in the world coorindates\n\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef UseIndependentComponents\n#if vtkNumComponents == 1\nuniform float mix0;\n#define height0 0.5\n#endif\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);\n    vec4 nearestValue = texture(texture1, nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  #ifndef UseIndependentComponents\n    #if vtkNumComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n  #ifdef vtkClippingPlanesOn\n    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n    {\n      vec3 g1VC[3];\n      for (int i = 0; i < 3; ++i)\n      {\n        g1VC[i] = IStoVC(texPos[i]);\n      }\n      vec3 posVC = IStoVC(pos);\n      for (int i = 0; i < clip_numPlanes; ++i)\n      {\n        for (int j = 0; j < 3; ++j)\n        {\n          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n          {\n            g1[j] = 0.0;\n          }\n        }\n      }\n    }\n  #endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {\n      vec3 opacityG1, opacityG2;\n      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;\n      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;\n      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;\n      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;\n      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;\n      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;\n      opacityG1.xyz *= gradientOpacity;\n      opacityG2.xyz *= gradientOpacity;\n\n      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n      // divide by spacing\n      opacityG.xyz /= vSpacing;\n      opacityG.w = length(opacityG.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(opacityG.xyz);\n      if (!all(equal(opacityG.xyz, vec3(0.0)))) {\n        return vec4(normalize(opacityG.xyz),opacityG.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n\n    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)\n    {\n      vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n      vec3 yvec = vec3(0.0, tstep.y, 0.0);\n      vec3 zvec = vec3(0.0, 0.0, tstep.z);\n      vec3 texPosPVec[3];\n      texPosPVec[0] = pos + xvec;\n      texPosPVec[1] = pos + yvec;\n      texPosPVec[2] = pos + zvec;\n      vec3 texPosNVec[3];\n      texPosNVec[0] = pos - xvec;\n      texPosNVec[1] = pos - yvec;\n      texPosNVec[2] = pos - zvec;\n      vec3 g1, g2;\n\n      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];\n      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];\n      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];\n      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];\n      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];\n      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];\n\n      #ifdef vtkClippingPlanesOn\n        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n      #endif\n      vec4 result;\n      result.x = scalarInterp[0].x - scalarInterp[1].x;\n      result.y = scalarInterp[0].y - scalarInterp[1].y;\n      result.z = scalarInterp[0].z - scalarInterp[1].z;\n      // divide by spacing\n      result.xyz /= vSpacing;\n      result.w = length(result.xyz);\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      if (length(result.xyz) > 0.0) {\n        return vec4(normalize(result.xyz),result.w);\n      } else {\n        return vec4(0.0);\n      }\n    }\n  #endif\n\n  // only works with dependent components\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n\n#ifdef vtkImageLabelOutlineOn\n  vec4 fragCoordToPCPos(vec4 fragCoord) {\n    return vec4(\n      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n      (fragCoord.z - 0.5) * 2.0,\n      1.0);\n  }\n\n  vec4 pcPosToWorldCoord(vec4 pcPos) {\n    return PCWCMatrix * pcPos;\n  }\n\n  vec3 fragCoordToIndexSpace(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    vec4 vertex = (worldCoord / worldCoord.w);\n\n    vec3 index = (vWCtoIDX * vertex).xyz;\n\n    // half voxel fix for labelmapOutline\n    return (index + vec3(0.5)) / vec3(volumeDimensions);\n  }\n\n  vec3 fragCoordToWorld(vec4 fragCoord) {\n    vec4 pcPos = fragCoordToPCPos(fragCoord);\n    vec4 worldCoord = pcPosToWorldCoord(pcPos);\n    return worldCoord.xyz;\n  }\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)\n      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {\n  #if vtkLightComplexity > 0\n    // surface shadows if needed\n    #ifdef SurfaceShadowOn\n      #if vtkLightComplexity < 3\n        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);\n      #else\n        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));\n      #endif\n    #endif\n\n    // volume shadows if needed\n    #ifdef VolumeShadowOn\n      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);\n    #endif\n\n    // merge\n    #ifdef VolumeShadowOn\n      #ifdef SurfaceShadowOn\n        // surface shadows + volumetric shadows\n        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n      #else\n        // volumetric shadows only\n        tColor = tColorVS;\n      #endif\n    #else\n      #ifdef SurfaceShadowOn\n        // surface shadows only\n        tColor = tColorS;\n      #else\n        // no shadows\n        applyLighting(tColor, normal3);\n      #endif\n    #endif\n  #endif\n  return tColor;\n}\n\n  \nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n\n// If labeloutline and not the edge labelmap, since in the edge labelmap blend\n// we need the underlying data to sample through\n#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n\n  // If it is the background (segment index 0), we should quickly bail out. \n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0){\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n        gl_FragCoord.y + float(j),\n        gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = outlineOpacity;\n  }\n\n  return tColor;\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n\n  #ifdef UseIndependentComponents\n\n    // sample textures\n    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n\n    #if vtkNumComponents > 1\n      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n\n      #if vtkNumComponents > 2\n        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n\n        #if vtkNumComponents > 3\n          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #endif\n      #endif\n    #endif\n\n    #if !defined(vtkCustomComponentsColorMix)\n      // default path for component color mix\n\n      // compute the normal vectors as needed\n      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #endif\n\n      // compute gradient opacity factors as needed\n      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);\n      #if defined(vtkGradientOpacityOn)\n        #if !defined(vtkComponent0Proportional)\n          goFactor.x =\n            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);\n        #endif\n        #if vtkNumComponents > 1\n          #if !defined(vtkComponent1Proportional)\n            goFactor.y =\n              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);\n          #endif\n          #if vtkNumComponents > 2\n            #if !defined(vtkComponent2Proportional)\n              goFactor.z =\n                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);\n            #endif\n            #if vtkNumComponents > 3\n              #if !defined(vtkComponent3Proportional)\n                goFactor.w =\n                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);\n              #endif\n            #endif\n          #endif\n        #endif\n      #endif\n\n      // process color and opacity for each component\n      #if !defined(vtkComponent0Proportional)\n        float alpha = goFactor.x*mix0*pwfValue0;\n        #if vtkLightComplexity > 0\n          applyLighting(tColor0, normalMat[0]);\n        #endif\n      #else\n        tColor0 *= pwfValue0;\n        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));\n      #endif\n\n      #if vtkNumComponents > 1\n        #if !defined(vtkComponent1Proportional)\n          alpha += goFactor.y*mix1*pwfValue1;\n          #if vtkLightComplexity > 0\n            applyLighting(tColor1, normalMat[1]);\n          #endif\n        #else\n          tColor1 *= pwfValue1;\n          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));\n        #endif\n\n        #if vtkNumComponents > 2\n          #if !defined(vtkComponent2Proportional)\n            alpha += goFactor.z*mix2*pwfValue2;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor2, normalMat[2]);\n            #endif\n          #else\n            tColor2 *= pwfValue2;\n            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));\n          #endif\n        #endif\n\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            alpha += goFactor.w*mix3*pwfValue3;\n            #if vtkLightComplexity > 0\n              applyLighting(tColor3, normalMat[3]);\n            #endif\n          #else\n            tColor3 *= pwfValue3;\n            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));\n          #endif\n        #endif\n      #endif\n\n      // perform final independent blend\n      vec3 tColor = mix0 * tColor0;\n      #if vtkNumComponents > 1\n        tColor += mix1 * tColor1;\n        #if vtkNumComponents > 2\n          tColor += mix2 * tColor2;\n          #if vtkNumComponents > 3\n            tColor += mix3 * tColor3;\n          #endif\n        #endif\n      #endif\n\n      return vec4(tColor, alpha);\n    #else\n      /*\n       * Mix the color information from all the independent components to get a single rgba output\n       * Gradient opactity factors and normals are not computed\n       *\n       * You can compute these using:\n       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix\n       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),\n       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper\n       * - computeGradientOpacityFactor: always available, used in a lot of places\n       *\n       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)\n       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight\n       */\n      //VTK::CustomComponentsColorMix::Impl\n    #endif\n  #else\n    // dependent components\n\n    // compute normal if needed\n    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n      #endif\n    #endif\n\n    // compute gradient opacity factor enabled\n    #if defined(vtkGradientOpacityOn)\n      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #else\n      const float gradientOpacity = 1.0;\n    #endif\n\n    // get color and opacity\n    #if vtkNumComponents == 1\n      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      if (alpha < EPSILON){\n        return vec4(0.0);\n      }\n    #endif\n    #if vtkNumComponents == 2\n      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 3\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n    #endif\n    #if vtkNumComponents == 4\n      vec3 tColor;\n      tColor.r = tValue.r * cscale0 + cshift0;\n      tColor.g = tValue.g * cscale1 + cshift1;\n      tColor.b = tValue.b * cscale2 + cshift2;\n      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n    #endif\n\n    // lighting\n    #if (vtkLightComplexity > 0)\n      #ifdef vtkComputeNormalFromOpacity\n        vec4 normalLight;\n        if (!all(equal(normal0, vec4(0.0)))) {\n          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;\n          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;\n          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);\n          if (all(equal(normalLight, vec4(0.0)))) {\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normalLight = normal0;\n      #endif\n      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);\n    #endif\n\n    return vec4(tColor, alpha);\n  #endif // dependent\n#endif\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #else\n    #ifdef UseIndependentComponents\n      #if vtkNumComponents == 2\n        if (val.r >= min.r && val.r <= max.r &&\n            val.g >= min.g && val.g <= max.g) {\n          withinRange = true;\n        }\n      #else\n        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n            all(lessThanEqual(val, ipScalarRangeMax))) {\n          withinRange = true;\n        }\n      #endif\n    #endif\n  #endif\n  return withinRange;\n}\n\n#if vtkBlendMode == 6 \nbool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    bool justSawIt = false;\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n\n    float stepsTraveled = 0.0;\n\n\n    // float neighborValue;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS += stepIS;\n    }\n\n    if (justSawIt){\n      return false;\n    }\n\n   \n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {\n        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));\n        vec4 texValue = texelFetch(texture1, texCoord, 0);\n\n        if (int(texValue.g) == s) {\n            justSawIt = true;\n            break;\n        }\n        neighborPosIS -= stepIS;\n    }\n\n\n    if (!justSawIt) {\n        // onedge\n        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;\n        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;\n        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n        return true;\n    }\n\n    // not on edge\n    return false;\n}\n\n#endif\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // Initialize arrays to false\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n  \n  #if vtkBlendMode == 6 \n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    uint bitmask = 0u;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading \n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the segment index\n      // and later check if the bit is set via bit operations\n      setBit(segmentIndex);\n    }\n    \n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value =  tValue; // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue; // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }  \n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);\n      return;\n    }\n\n    // probably we can make this configurable but for now we will use the same\n    // sample distance as the original sample distance\n    float neighborSampleDistanceIS = sampleDistanceIS;\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not \n      // been seen by the center segment\n      if (!isBitSet(s)) {\n       continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have \n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out \n      // faster if we find the edge\n      bool onEdge =\n          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||\n          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than \n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety \n      // of the all the fragments inside. i.e., this happens when we zoom out, \n      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n      \n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n            for (int j = -actualThickness; j <= actualThickness; j++) {\n                if (i == 0 && j == 0) continue; // Skip the center\n                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners\n                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {\n                    return;\n                }\n          }\n      }\n    }\n\n    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;\n    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n";



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(88691);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js






















const {
  vtkWarningMacro,
  vtkErrorMacro
} = macros2.c;

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function getColorCodeFromPreset(colorMixPreset) {
  switch (colorMixPreset) {
    case VolumeProperty_Constants/* ColorMixPreset */.dM.CUSTOM:
      return '//VTK::CustomColorMix';
    case VolumeProperty_Constants/* ColorMixPreset */.dM.ADDITIVE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
    case VolumeProperty_Constants/* ColorMixPreset */.dM.COLORIZE:
      return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
    default:
      return null;
  }
}

// ----------------------------------------------------------------------------
// vtkOpenGLVolumeMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolumeMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolumeMapper');
  function unregisterGraphicsResources(renderWindow) {
    [model._scalars, model._scalarOpacityFunc, model._colorTransferFunc, model._labelOutlineThicknessArray].forEach(coreObject => renderWindow.unregisterGraphicsResourceUser(coreObject, publicAPI));
  }
  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };

  // ohh someone is doing a zbuffer pass, use that for
  // intermixed volume rendering
  publicAPI.zBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.zBufferPass(prepass, renderPass);

  // Renders myself
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      const oldOglRenderWindow = model._openGLRenderWindow;
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');
      if (oldOglRenderWindow && !oldOglRenderWindow.isDeleted() && oldOglRenderWindow !== model._openGLRenderWindow) {
        // Unregister the mapper when the render window changes
        unregisterGraphicsResources(oldOglRenderWindow);
      }
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');
      const actor = model.openGLVolume.getRenderable();
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = '';
  };
  publicAPI.useIndependentComponents = actorProperty => {
    const iComps = actorProperty.getIndependentComponents();
    const image = model.currentInput;
    const numComp = image?.getPointData()?.getScalars()?.getNumberOfComponents();
    const colorMixPreset = actorProperty.getColorMixPreset();
    return iComps && numComp >= 2 || !!colorMixPreset;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    const actorProps = actor.getProperty();
    let FSSource = shaders.Fragment;

    // define some values in the shader
    const iType = actorProps.getInterpolationType();
    if (iType === VolumeProperty_Constants/* InterpolationType */.VO.LINEAR) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;
    }
    const LabelEdgeProjection = model.renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.LABELMAP_EDGE_PROJECTION_BLEND;
    if (LabelEdgeProjection) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LabelEdgeProjectionOn', '#define vtkLabelEdgeProjectionOn').result;
    }
    const numComp = model.scalarTexture.getComponents();
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::NumComponents', `#define vtkNumComponents ${numComp}`).result;
    const useIndependentComps = publicAPI.useIndependentComponents(actorProps);
    if (useIndependentComps) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define UseIndependentComponents').result;
    }

    // Define any proportional components
    const proportionalComponents = [];
    const forceNearestComponents = [];
    for (let nc = 0; nc < numComp; nc++) {
      if (actorProps.getOpacityMode(nc) === VolumeProperty_Constants/* OpacityMode */.tE.PROPORTIONAL) {
        proportionalComponents.push(`#define vtkComponent${nc}Proportional`);
      }
      if (actorProps.getForceNearestInterpolation(nc)) {
        forceNearestComponents.push(`#define vtkComponent${nc}ForceNearest`);
      }
    }
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\n')).result;
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkForceNearestComponents', forceNearestComponents.join('\n')).result;
    const colorMixPreset = actorProps.getColorMixPreset();
    const colorMixCode = getColorCodeFromPreset(colorMixPreset);
    if (colorMixCode) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::CustomComponentsColorMixOn', '#define vtkCustomComponentsColorMix').result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::CustomComponentsColorMix::Impl', colorMixCode).result;
    }

    // WebGL only supports loops over constants
    // and does not support while loops so we
    // have to hard code how many steps/samples to take
    // We do a break so most systems will gracefully
    // early terminate, but it is always possible
    // a system will execute every step regardless
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::MaximumSamplesValue', `${Math.ceil(maxSamples)}`).result;

    // set light complexity
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LightComplexity', `#define vtkLightComplexity ${model.lightComplexity}`).result;

    // set shadow blending flag
    if (model.lightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::VolumeShadowOn', `#define VolumeShadowOn`).result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::SurfaceShadowOn', `#define SurfaceShadowOn`).result;
      }
      if (model.renderable.getLocalAmbientOcclusion() && actorProps.getAmbient() > 0.0) {
        FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::localAmbientOcclusionOn', `#define localAmbientOcclusionOn`).result;
      }
    }

    // if using gradient opacity define that
    const numIComps = useIndependentComps ? numComp : 1;
    model.gopacity = false;
    for (let nc = 0; !model.gopacity && nc < numIComps; ++nc) {
      model.gopacity ||= actorProps.getUseGradientOpacity(nc);
    }
    if (model.gopacity) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;
    }

    // set normal from density
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', `#define vtkComputeNormalFromOpacity`).result;
    }

    // if we have a ztexture then declare it and use it
    if (model.zBufferTexture !== null) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpZWidth;', 'uniform float vpZHeight;']).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'if (cameraParallel == 0) {', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}', 'else {', 'zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;
    }

    // Set the BlendMode approach
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::BlendMode', `${model.renderable.getBlendMode()}`).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    if (model.lightComplexity === 0) {
      return;
    }
    let FSSource = shaders.Fragment;
    // check for shadow maps - not implemented yet, skip
    // const shadowFactor = '';

    // to-do: single out the case when complexity = 1

    // only account for lights that are switched on
    let lightNum = 0;
    ren.getLights().forEach(light => {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Light::Dec', [`uniform int lightNum;`, `uniform bool twoSidedLighting;`, `uniform vec3 lightColor[${lightNum}];`, `uniform vec3 lightDirectionVC[${lightNum}]; // normalized`, `uniform vec3 lightHalfAngleVC[${lightNum}];`, '//VTK::Light::Dec'], false).result;
    // support any number of lights
    if (model.lightComplexity === 3) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::Light::Dec', [`uniform vec3 lightPositionVC[${lightNum}];`, `uniform vec3 lightAttenuation[${lightNum}];`, `uniform float lightConeAngle[${lightNum}];`, `uniform float lightExponent[${lightNum}];`, `uniform int lightPositional[${lightNum}];`], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::VolumeShadow::Dec', [`uniform float volumetricScatteringBlending;`, `uniform float giReach;`, `uniform float volumeShadowSamplingDistFactor;`, `uniform float anisotropy;`, `uniform float anisotropy2;`], false).result;
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::LAO::Dec', [`uniform int kernelRadius;`, `uniform vec2 kernelSample[${model.renderable.getLAOKernelRadius()}];`, `uniform int kernelSize;`], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      const clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ClipPlane::Dec', [`uniform vec3 vClipPlaneNormals[6];`, `uniform float vClipPlaneDistances[6];`, `uniform vec3 vClipPlaneOrigins[6];`, `uniform int clip_numPlanes;`, '//VTK::ClipPlane::Dec', '#define vtkClippingPlanesOn'], false).result;
      FSSource = ShaderProgram/* default.substitute */.A.substitute(FSSource, '//VTK::ClipPlane::Impl', [`for(int i = 0; i < ${clipPlaneSize}; i++) {`, '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;
    }
    shaders.Fragment = FSSource;
  };
  const recomputeLightComplexity = (actor, lights) => {
    // do we need lighting?
    let lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.COMPOSITE_BLEND) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      model.numberOfLights = 0;
      lights.forEach(light => {
        const status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    if (lightComplexity !== model.lightComplexity) {
      model.lightComplexity = lightComplexity;
      publicAPI.modified();
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    const actorProps = actor.getProperty();
    recomputeLightComplexity(actor, ren.getLights());
    const numComp = model.scalarTexture.getComponents();
    const opacityModes = [];
    const forceNearestInterps = [];
    for (let nc = 0; nc < numComp; nc++) {
      opacityModes.push(actorProps.getOpacityMode(nc));
      forceNearestInterps.push(actorProps.getForceNearestInterpolation(nc));
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    const hasZBufferTexture = !!model.zBufferTexture;
    const state = {
      iComps: actorProps.getIndependentComponents(),
      colorMixPreset: actorProps.getColorMixPreset(),
      interpolationType: actorProps.getInterpolationType(),
      useLabelOutline: publicAPI.isLabelmapOutlineRequired(actor),
      numComp,
      maxSamples,
      useGradientOpacity: actorProps.getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      hasZBufferTexture,
      opacityModes,
      forceNearestInterps
    };

    // We need to rebuild the shader if one of these variables has changed,
    // since they are used in the shader template replacement step.
    // We also need to rebuild if the shader source time is outdated.
    if (cellBO.getProgram()?.getHandle() === 0 || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || !model.previousState || !fast_deep_equal_default()(model.previousState, state)) {
      model.previousState = state;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    const program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed('vertexDC')) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexDC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());
    program.setUniformf('sampleDistance', publicAPI.getCurrentSampleDistance(ren));
    const volInfo = model.scalarTexture.getVolumeInfo();
    const ipScalarRange = model.renderable.getIpScalarRange();

    // In some situations, we might not have computed the scale and offset
    // for the data range, or it might not be needed.
    if (volInfo?.dataComputedScale?.length) {
      const minVals = [];
      const maxVals = [];
      for (let i = 0; i < 4; i++) {
        // convert iprange from 0-1 into data range values
        minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
        // convert data ranges into texture values
        minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
        maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      }
      program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);
      program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    }

    // if we have a zbuffer texture then set it
    if (model.zBufferTexture !== null) {
      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());
      const size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf('vpZWidth', size[0]);
      program.setUniformf('vpZHeight', size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    // // [WMVP]C == {world, model, view, projection} coordinates
    // // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();
    esm/* mat4.multiply */.pB.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    const program = cellBO.getProgram();
    const cam = model.openGLCamera.getRenderable();
    const crange = cam.getClippingRange();
    program.setUniformf('camThick', crange[1] - crange[0]);
    program.setUniformf('camNear', crange[0]);
    program.setUniformf('camFar', crange[1]);
    const bounds = model.currentInput.getBounds();
    const dims = model.currentInput.getDimensions();

    // compute the viewport bounds of the volume
    // we will only render those fragments.
    const pos = new Float64Array(3);
    const dir = new Float64Array(3);
    let dcxmin = 1.0;
    let dcxmax = -1.0;
    let dcymin = 1.0;
    let dcymax = -1.0;
    for (let i = 0; i < 8; ++i) {
      esm/* vec3.set */.eR.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        esm/* vec3.normalize */.eR.normalize(dir, pos);

        // now find the projection of this point onto a
        // nearZ distance plane. Since the camera is at 0,0,0
        // in VC the ray is just t*pos and
        // t is -nearZ/dir.z
        // intersection becomes pos.x/pos.z
        const t = -crange[0] / pos[2];
        esm/* vec3.scale */.eR.scale(pos, dir, t);
      }
      // now convert to DC
      esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf('dcxmin', dcxmin);
    program.setUniformf('dcxmax', dcxmax);
    program.setUniformf('dcymin', dcymin);
    program.setUniformf('dcymax', dcymax);
    if (program.isUniformUsed('cameraParallel')) {
      program.setUniformi('cameraParallel', cam.getParallelProjection());
    }
    const ext = model.currentInput.getSpatialExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = new Float64Array(3);
    esm/* vec3.set */.eR.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);
    esm/* vec3.set */.eR.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    esm/* vec3.transformMat4 */.eR.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);

    // apply the image directions
    const i2wmat4 = model.currentInput.getIndexToWorld();
    esm/* mat4.multiply */.pB.multiply(model.idxToView, model.modelToView, i2wmat4);
    esm/* mat3.multiply */.w0.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    esm/* mat3.multiply */.w0.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirectionByReference());
    const maxSamples = esm/* vec3.length */.eR.length(vsize) / publicAPI.getCurrentSampleDistance(ren);
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro(`The number of steps required ${Math.ceil(maxSamples)} is larger than the
        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
    }
    const vctoijk = new Float64Array(3);
    esm/* vec3.set */.eR.set(vctoijk, 1.0, 1.0, 1.0);
    esm/* vec3.divide */.eR.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);
    program.setUniform3f('volumeSpacings', spc[0], spc[1], spc[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      const volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf('texWidth', model.scalarTexture.getWidth());
      program.setUniformf('texHeight', model.scalarTexture.getHeight());
      program.setUniformi('xreps', volInfo.xreps);
      program.setUniformi('xstride', volInfo.xstride);
      program.setUniformi('ystride', volInfo.ystride);
    }

    // map normals through normal matrix
    // then use a point on the plane to compute the distance
    const normal = new Float64Array(3);
    const pos2 = new Float64Array(3);
    for (let i = 0; i < 6; ++i) {
      switch (i) {
        case 1:
          esm/* vec3.set */.eR.set(normal, -1.0, 0.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          esm/* vec3.set */.eR.set(normal, 0.0, 1.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          esm/* vec3.set */.eR.set(normal, 0.0, -1.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          esm/* vec3.set */.eR.set(normal, 0.0, 0.0, 1.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          esm/* vec3.set */.eR.set(normal, 0.0, 0.0, -1.0);
          esm/* vec3.set */.eR.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          esm/* vec3.set */.eR.set(normal, 1.0, 0.0, 0.0);
          esm/* vec3.set */.eR.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      esm/* vec3.transformMat3 */.eR.transformMat3(normal, normal, model.idxNormalMatrix);
      esm/* vec3.transformMat4 */.eR.transformMat4(pos2, pos2, model.idxToView);
      const dist = -1.0 * esm/* vec3.dot */.eR.dot(pos2, normal);

      // we have the plane in view coordinates
      // specify the planes in view coordinates
      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);
      program.setUniformf(`vPlaneDistance${i}`, dist);
    }
    if (publicAPI.isLabelmapOutlineRequired(actor)) {
      const image = model.currentInput;
      const worldToIndex = image.getWorldToIndex();
      program.setUniformMatrix('vWCtoIDX', worldToIndex);
      const camera = ren.getActiveCamera();
      const [cRange0, cRange1] = camera.getClippingRange();
      const distance = camera.getDistance();

      // set the clipping range to be model.distance and model.distance + 0.1
      // since we use the in the keyMats.wcpc (world to projection) matrix
      // the projection matrix calculation relies on the clipping range to be
      // set correctly. This is done inside the interactorStyleMPRSlice which
      // limits use cases where the interactor style is not used.

      camera.setClippingRange(distance, distance + 0.1);
      const labelOutlineKeyMats = model.openGLCamera.getKeyMatrices(ren);

      // Get the projection coordinate to world coordinate transformation matrix.
      esm/* mat4.invert */.pB.invert(model.projectionToWorld, labelOutlineKeyMats.wcpc);

      // reset the clipping range since the keyMats are cached
      camera.setClippingRange(cRange0, cRange1);

      // to re compute the matrices for the current camera and cache them
      model.openGLCamera.getKeyMatrices(ren);
      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf('vpWidth', size[0]);
      program.setUniformf('vpHeight', size[1]);
      const offset = publicAPI.getRenderTargetOffset();
      program.setUniformf('vpOffsetX', offset[0] / size[0]);
      program.setUniformf('vpOffsetY', offset[1] / size[1]);
    }
    esm/* mat4.invert */.pB.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix('PCVCMatrix', model.projectionToView);

    // handle lighting values
    if (model.lightComplexity === 0) {
      return;
    }
    let lightNum = 0;
    const lightColor = [];
    const lightDir = [];
    const halfAngle = [];
    ren.getLights().forEach(light => {
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColor();
        const intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        const ldir = light.getDirection();
        esm/* vec3.set */.eR.set(normal, ldir[0], ldir[1], ldir[2]);
        esm/* vec3.transformMat3 */.eR.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat
        esm/* vec3.normalize */.eR.normalize(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        // camera DOP is 0,0,-1.0 in VC
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);
        lightNum++;
      }
    });
    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());
    program.setUniformi('lightNum', lightNum);
    program.setUniform3fv('lightColor', lightColor);
    program.setUniform3fv('lightDirectionVC', lightDir);
    program.setUniform3fv('lightHalfAngleVC', halfAngle);
    if (model.lightComplexity === 3) {
      lightNum = 0;
      const lightPositionVC = [];
      const lightAttenuation = [];
      const lightConeAngle = [];
      const lightExponent = [];
      const lightPositional = [];
      ren.getLights().forEach(light => {
        const status = light.getSwitch();
        if (status > 0) {
          const attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          const lp = light.getTransformedPosition();
          esm/* vec3.transformMat4 */.eR.transformMat4(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv('lightPositionVC', lightPositionVC);
      program.setUniform3fv('lightAttenuation', lightAttenuation);
      program.setUniformfv('lightConeAngle', lightConeAngle);
      program.setUniformfv('lightExponent', lightExponent);
      program.setUniformiv('lightPositional', lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {
      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());
      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());
      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf('anisotropy', model.renderable.getAnisotropy());
      program.setUniformf('anisotropy2', model.renderable.getAnisotropy() ** 2.0);
    }
    if (model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {
      const ks = model.renderable.getLAOKernelSize();
      program.setUniformi('kernelSize', ks);
      const kernelSample = [];
      for (let i = 0; i < ks; i++) {
        kernelSample[i * 2] = Math.random() * 0.5;
        kernelSample[i * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv('kernelSample', kernelSample);
      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());
    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());
    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());
    program.setUniformi('ttexture', model.labelOutlineThicknessTexture.getTextureUnit());
    const volInfo = model.scalarTexture.getVolumeInfo();
    const vprop = actor.getProperty();

    // set the component mix when independent
    const numComp = model.scalarTexture.getComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    if (useIndependentComps) {
      for (let i = 0; i < numComp; i++) {
        program.setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      const target = useIndependentComps ? i : 0;
      const sscale = volInfo.scale[i];
      const ofun = vprop.getScalarOpacity(target);
      const oRange = ofun.getRange();
      const oscale = sscale / (oRange[1] - oRange[0]);
      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf(`oshift${i}`, oshift);
      program.setUniformf(`oscale${i}`, oscale);
      const cfun = vprop.getRGBTransferFunction(target);
      const cRange = cfun.getRange();
      const cshift = (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0]);
      const cScale = sscale / (cRange[1] - cRange[0]);
      program.setUniformf(`cshift${i}`, cshift);
      program.setUniformf(`cscale${i}`, cScale);
    }
    if (model.gopacity) {
      if (useIndependentComps) {
        for (let nc = 0; nc < numComp; ++nc) {
          const sscale = volInfo.scale[nc];
          const useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf(`gomin${nc}`, gomin);
            program.setUniformf(`gomax${nc}`, gomax);
            const goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf(`goscale${nc}`, sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf(`goshift${nc}`, -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf(`gomin${nc}`, 1.0);
            program.setUniformf(`gomax${nc}`, 1.0);
            program.setUniformf(`goscale${nc}`, 0.0);
            program.setUniformf(`goshift${nc}`, 1.0);
          }
        }
      } else {
        const sscale = volInfo.scale[numComp - 1];
        const gomin = vprop.getGradientOpacityMinimumOpacity(0);
        const gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf('gomin0', gomin);
        program.setUniformf('gomax0', gomax);
        const goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf('goscale0', sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
        program.setUniformf('goshift0', -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
      }
    }
    const vtkImageLabelOutline = publicAPI.isLabelmapOutlineRequired(actor);
    if (vtkImageLabelOutline === true) {
      const labelOutlineOpacity = actor.getProperty().getLabelOutlineOpacity();
      program.setUniformf('outlineOpacity', labelOutlineOpacity);
    }
    if (model.lightComplexity > 0) {
      program.setUniformf('vAmbient', vprop.getAmbient());
      program.setUniformf('vDiffuse', vprop.getDiffuse());
      program.setUniformf('vSpecular', vprop.getSpecular());
      program.setUniformf('vSpecularPower', vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = (cellBO, ren, actor) => {
    if (model.renderable.getClippingPlanes().length > 0) {
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const clipPlaneNormals = [];
      const clipPlaneDistances = [];
      const clipPlaneOrigins = [];
      const clipPlanes = model.renderable.getClippingPlanes();
      const clipPlaneSize = clipPlanes.length;
      for (let i = 0; i < clipPlaneSize; ++i) {
        const clipPlaneNormal = clipPlanes[i].getNormal();
        const clipPlanePos = clipPlanes[i].getOrigin();
        esm/* vec3.transformMat3 */.eR.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        esm/* vec3.transformMat4 */.eR.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        const clipPlaneDist = -1.0 * esm/* vec3.dot */.eR.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
        clipPlaneOrigins.push(clipPlanePos[0]);
        clipPlaneOrigins.push(clipPlanePos[1]);
        clipPlaneOrigins.push(clipPlanePos[2]);
      }
      const program = cellBO.getProgram();
      program.setUniform3fv(`vClipPlaneNormals`, clipPlaneNormals);
      program.setUniformfv(`vClipPlaneDistances`, clipPlaneDistances);
      program.setUniform3fv(`vClipPlaneOrigins`, clipPlaneOrigins);
      program.setUniformi(`clip_numPlanes`, clipPlaneSize);
    }
  };

  // unsubscribe from our listeners
  publicAPI.delete = (0,macros2.h)(() => {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, () => {
    if (model._openGLRenderWindow) {
      unregisterGraphicsResources(model._openGLRenderWindow);
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = () => {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    const {
      usize,
      vsize
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = () => {
    const {
      lowerLeftU,
      lowerLeftV
    } = model._openGLRenderer.getTiledSizeAndOrigin();
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.getCurrentSampleDistance = ren => {
    const rwi = ren.getVTKWindow().getInteractor();
    const baseSampleDistance = model.renderable.getSampleDistance();
    if (rwi.isAnimating()) {
      const factor = model.renderable.getInteractionSampleDistanceFactor();
      return baseSampleDistance * factor;
    }
    return baseSampleDistance;
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    const rwi = ren.getVTKWindow().getInteractor();
    if (!model._lastScale) {
      model._lastScale = model.renderable.getInitialInteractionScale();
    }
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      // when the animation frame rate changes recompute the scale factor
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          const frate = rwi.getRecentAnimationFrameRate();
          const adjustment = rwi.getDesiredUpdateRate() / frate;

          // only change if we are off by 15%
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          // clamp scale to some reasonable values.
          // Below 1.5 we will just be using full resolution as that is close enough
          // Above 400 seems like a lot so we limit to that 1/20th per axis
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
      });
    }

    // use/create/resize framebuffer if needed
    if (model._useSmallViewport) {
      const size = model._openGLRenderWindow.getFramebufferSize();
      const scaleFactor = 1 / Math.sqrt(model._lastScale);
      model._smallViewportWidth = Math.ceil(scaleFactor * size[0]);
      model._smallViewportHeight = Math.ceil(scaleFactor * size[1]);

      // adjust viewportSize to always be at most the dest fo size
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (!fbSize || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // set interpolation on the texture based on property setting
    const iType = actor.getProperty().getInterpolationType();
    if (iType === VolumeProperty_Constants/* InterpolationType */.VO.NEAREST) {
      model.scalarTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.scalarTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.scalarTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
    }

    // if we have a zbuffer texture then activate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // render the texture
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.labelOutlineThicknessTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);

    // First we do the triangles, update the shader, set uniforms, etc.
    // for (let i = 0; i < 11; ++i) {
    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);
    // }
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.labelOutlineThicknessTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    // if we have a zbuffer texture then deactivate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      // now copy the framebuffer with the volume into the
      // regular buffer
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\n'), '');
        const program = model.copyShader;
        model.copyVAO = VertexArrayObject/* default.newInstance */.Ay.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      const size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);

      // activate texture
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi('texture', tex.getTextureUnit());
      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);
      const gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      // render quad
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({
      type: 'StartEvent'
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: 'EndEvent'
    });
    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      (0,Core_Math.u)(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || !model.scalarTexture?.getHandle() || !model.colorTexture?.getHandle() || !model.labelOutlineThicknessTexture?.getHandle()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;
    if (!image) {
      return;
    }
    const scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    const vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255.0 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.jitterTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
    }
    const numComp = scalars.getNumberOfComponents();
    const useIndependentComps = publicAPI.useIndependentComponents(vprop);
    const numIComps = useIndependentComps ? numComp : 1;
    const scalarOpacityFunc = vprop.getScalarOpacity();
    const opTex = model._openGLRenderWindow.getGraphicsResourceForObject(scalarOpacityFunc);
    let toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(scalarOpacityFunc, useIndependentComps, numIComps);
    const reBuildOp = !opTex?.oglObject || opTex.hash !== toString;
    if (reBuildOp) {
      model.opacityTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // rebuild opacity tfun?
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);
      for (let c = 0; c < numIComps; ++c) {
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor = publicAPI.getCurrentSampleDistance(ren) / vprop.getScalarOpacityUnitDistance(c);
        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        // adjust for sample distance etc
        for (let i = 0; i < oWidth; ++i) {
          ofTable[c * oWidth * 2 + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
        }
      }
      model.opacityTexture.resetFormatAndType();
      model.opacityTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.opacityTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);

      // use float texture where possible because we really need the resolution
      // for this table. Errors in low values of opacity accumulate to
      // visible artifacts. High values of opacity quickly terminate without
      // artifacts.
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.FLOAT, ofTable);
      } else {
        const oTable = new Uint8ClampedArray(oSize);
        for (let i = 0; i < oSize; ++i) {
          oTable[i] = 255.0 * ofTable[i];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, oTable);
      }
      if (scalarOpacityFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalarOpacityFunc, model.opacityTexture, toString);
        if (scalarOpacityFunc !== model._scalarOpacityFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalarOpacityFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalarOpacityFunc, publicAPI);
        }
        model._scalarOpacityFunc = scalarOpacityFunc;
      }
    } else {
      model.opacityTexture = opTex.oglObject;
    }

    // rebuild color tfun?
    const colorTransferFunc = vprop.getRGBTransferFunction();
    toString = (0,resourceSharingHelper/* getTransferFunctionHash */.gP)(colorTransferFunc, useIndependentComps, numIComps);
    const cTex = model._openGLRenderWindow.getGraphicsResourceForObject(colorTransferFunc);
    const reBuildC = !cTex?.oglObject?.getHandle() || cTex?.hash !== toString;
    if (reBuildC) {
      model.colorTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8ClampedArray(cSize);
      const tmpTable = new Float32Array(cWidth * 3);
      for (let c = 0; c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
        }
      }
      model.colorTexture.resetFormatAndType();
      model.colorTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, cTable);
      if (colorTransferFunc) {
        model._openGLRenderWindow.setGraphicsResourceForObject(colorTransferFunc, model.colorTexture, toString);
        if (colorTransferFunc !== model._colorTransferFunc) {
          model._openGLRenderWindow.registerGraphicsResourceUser(colorTransferFunc, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._colorTransferFunc, publicAPI);
        }
        model._colorTransferFunc = colorTransferFunc;
      }
    } else {
      model.colorTexture = cTex.oglObject;
    }
    publicAPI.updateLabelOutlineThicknessTexture(actor);
    const tex = model._openGLRenderWindow.getGraphicsResourceForObject(scalars);
    // rebuild the scalarTexture if the data has changed
    toString = (0,resourceSharingHelper/* getImageDataHash */.eS)(image, scalars);
    const reBuildTex = !tex?.oglObject?.getHandle() || tex?.hash !== toString;
    const updatedExtents = model.renderable.getUpdatedExtents();
    const hasUpdatedExtents = !!updatedExtents.length;
    if (reBuildTex && !hasUpdatedExtents) {
      model.scalarTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      // Build the textures
      const dims = image.getDimensions();
      // Use norm16 for scalar texture if the extension is available
      model.scalarTexture.setOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);
      if (scalars) {
        model._openGLRenderWindow.setGraphicsResourceForObject(scalars, model.scalarTexture, toString);
        if (scalars !== model._scalars) {
          model._openGLRenderWindow.registerGraphicsResourceUser(scalars, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._scalars, publicAPI);
        }
        model._scalars = scalars;
      }
    } else {
      model.scalarTexture = tex.oglObject;
    }
    if (hasUpdatedExtents) {
      // If hasUpdatedExtents, then the texture is partially updated.
      // clear the array to acknowledge the update.
      model.renderable.setUpdatedExtents([]);
      const dims = image.getDimensions();
      model.scalarTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars, false, updatedExtents);
    }
    if (!model.tris.getCABO().getElementCount()) {
      // build the CABO
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = -1.0;
      }
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;

      // const dim = 12.0;
      // const ptsArray = new Float32Array(3 * dim * dim);
      // for (let i = 0; i < dim; i++) {
      //   for (let j = 0; j < dim; j++) {
      //     const offset = ((i * dim) + j) * 3;
      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 2] = -1.0;
      //   }
      // }

      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));
      // for (let i = 0; i < dim - 1; i++) {
      //   for (let j = 0; j < dim - 1; j++) {
      //     const offset = 8 * ((i * (dim - 1)) + j);
      //     cellArray[offset] = 3;
      //     cellArray[offset + 1] = (i * dim) + j;
      //     cellArray[offset + 2] = (i * dim) + 1 + j;
      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 4] = 3;
      //     cellArray[offset + 5] = (i * dim) + j;
      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 7] = ((i + 1) * dim) + j;
      //   }
      // }

      const points = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const cells = DataArray/* default.newInstance */.Ay.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', Property_Constants/* Representation */.YL.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.updateLabelOutlineThicknessTexture = volume => {
    const labelOutlineThicknessArray = volume.getProperty().getLabelOutlineThickness();
    const lTex = model._openGLRenderWindow.getGraphicsResourceForObject(labelOutlineThicknessArray);

    // compute the join of the labelOutlineThicknessArray so that
    // we can use it to decide whether to rebuild the labelOutlineThicknessTexture
    // or not
    const toString = `${labelOutlineThicknessArray.join('-')}`;
    const reBuildL = !lTex?.oglObject?.getHandle() || lTex?.hash !== toString;
    if (reBuildL) {
      model.labelOutlineThicknessTexture = Texture/* default.newInstance */.Ay.newInstance();
      model.labelOutlineThicknessTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const lWidth = 1024;
      const lHeight = 1;
      const lSize = lWidth * lHeight;
      const lTable = new Uint8Array(lSize);

      // Assuming labelOutlineThicknessArray contains the thickness for each segment
      for (let i = 0; i < lWidth; ++i) {
        // Retrieve the thickness value for the current segment index.
        // If the value is undefined, use the first element's value as a default, otherwise use the value (even if 0)
        const thickness = typeof labelOutlineThicknessArray[i] !== 'undefined' ? labelOutlineThicknessArray[i] : labelOutlineThicknessArray[0];
        lTable[i] = thickness;
      }
      model.labelOutlineThicknessTexture.resetFormatAndType();
      model.labelOutlineThicknessTexture.setMinificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);
      model.labelOutlineThicknessTexture.setMagnificationFilter(Texture_Constants/* Filter */.dJ.NEAREST);

      // Create a 2D texture (acting as 1D) from the raw data
      model.labelOutlineThicknessTexture.create2DFromRaw(lWidth, lHeight, 1, Constants/* VtkDataTypes */.JA.UNSIGNED_CHAR, lTable);
      if (labelOutlineThicknessArray) {
        model._openGLRenderWindow.setGraphicsResourceForObject(labelOutlineThicknessArray, model.labelOutlineThicknessTexture, toString);
        if (labelOutlineThicknessArray !== model._labelOutlineThicknessArray) {
          model._openGLRenderWindow.registerGraphicsResourceUser(labelOutlineThicknessArray, publicAPI);
          model._openGLRenderWindow.unregisterGraphicsResourceUser(model._labelOutlineThicknessArray, publicAPI);
        }
        model._labelOutlineThicknessArray = labelOutlineThicknessArray;
      }
    } else {
      model.labelOutlineThicknessTexture = lTex.oglObject;
    }
  };
  publicAPI.isLabelmapOutlineRequired = actor => {
    const prop = actor.getProperty();
    const renderable = model.renderable;
    return prop.getUseLabelOutline() || renderable.getBlendMode() === VolumeMapper_Constants/* BlendMode */.Nx.LABELMAP_EDGE_PROJECTION_BLEND;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  labelOutlineThicknessTexture: null,
  labelOutlineThicknessTextureString: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1.0,
  targetXYF: 1.0,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lightComplexity: 0,
  fullViewportTime: 1.0,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0.0,
  avgFrameTime: 0.0
  // _scalars: null,
  // _scalarOpacityFunc: null,
  // _colorTransferFunc: null,
  // _labelOutlineThicknessArray: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  ReplacementShaderMapper/* default */.A.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  (0,macros2.o)(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = Helper/* default.newInstance */.Ay.newInstance();
  model.jitterTexture = Texture/* default.newInstance */.Ay.newInstance();
  model.jitterTexture.setWrapS(Texture_Constants/* Wrap */.B_.REPEAT);
  model.jitterTexture.setWrapT(Texture_Constants/* Wrap */.B_.REPEAT);
  model.framebuffer = Framebuffer/* default.newInstance */.Ay.newInstance();
  model.idxToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.idxNormalMatrix = esm/* mat3.identity */.w0.identity(new Float64Array(9));
  model.modelToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.projectionToView = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.projectionToWorld = esm/* mat4.identity */.pB.identity(new Float64Array(16));

  // Build VTK API
  (0,macros2.e)(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolumeMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = (0,macros2.n)(extend, 'vtkOpenGLVolumeMapper');

// ----------------------------------------------------------------------------

var vtkVolumeMapper = {
  newInstance,
  extend
};

// Register ourself to OpenGL backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkVolumeMapper', newInstance);




/***/ }),

/***/ 23159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ vtkPolyDataFS)
/* harmony export */ });
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";




/***/ }),

/***/ 84839:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ vtkPolyDataVS)
/* harmony export */ });
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";




/***/ }),

/***/ 25196:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkViewNode$1)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;
const PASS_TYPES = ['Build', 'Render'];

// ----------------------------------------------------------------------------
// vtkViewNode methods
// ----------------------------------------------------------------------------

function vtkViewNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewNode');

  // Builds myself.
  publicAPI.build = prepass => {};

  // Renders myself
  publicAPI.render = prepass => {};
  publicAPI.traverse = renderPass => {
    // we can choose to do special
    // traversal here based on pass
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }

    // default traversal
    publicAPI.apply(renderPass, true);
    for (let index = 0; index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = dataObject => {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return undefined;
  };
  publicAPI.getFirstAncestorOfType = type => {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.getLastAncestorOfType = type => {
    if (!model._parent) {
      return null;
    }
    const lastAncestor = model._parent.getLastAncestorOfType(type);
    if (lastAncestor) {
      return lastAncestor;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return null;
  };

  // add a missing node/child for the passed in renderables. This should
  // be called only in between prepareNodes and removeUnusedNodes
  publicAPI.addMissingNode = dobj => {
    if (!dobj) {
      return undefined;
    }

    // if found just mark as visited
    const result = model._renderableChildMap.get(dobj);
    if (result !== undefined) {
      result.setVisited(true);
      return result;
    }

    // otherwise create a node
    const newNode = publicAPI.createViewNode(dobj);
    if (newNode) {
      newNode.setParent(publicAPI);
      newNode.setVisited(true);
      model._renderableChildMap.set(dobj, newNode);
      model.children.push(newNode);
      return newNode;
    }
    return undefined;
  };

  // add missing nodes/children for the passed in renderables. This should
  // be called only in between prepareNodes and removeUnusedNodes
  publicAPI.addMissingNodes = dataObjs => {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (let index = 0; index < dataObjs.length; ++index) {
      const dobj = dataObjs[index];
      publicAPI.addMissingNode(dobj);
    }
  };

  // ability to add children that have no renderable use in the same manner
  // as addMissingNodes This case is when a normal viewnode wants to
  // delegate passes to a helper or child that doeasn't map to a clear
  // renderable or any renderable
  publicAPI.addMissingChildren = children => {
    if (!children || !children.length) {
      return;
    }
    for (let index = 0; index < children.length; ++index) {
      const child = children[index];
      const cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
        const childRenderable = child.getRenderable();
        if (childRenderable) {
          model._renderableChildMap.set(childRenderable, child);
        }
      }
      child.setVisited(true);
    }
  };
  publicAPI.removeNode = child => {
    const childIdx = model.children.findIndex(x => x === child);
    if (childIdx < 0) {
      return false;
    }
    const renderable = child.getRenderable();
    if (renderable) {
      model._renderableChildMap.delete(renderable);
    }
    child.delete();
    model.children.splice(childIdx, 1);
    return true;
  };
  publicAPI.prepareNodes = () => {
    for (let index = 0; index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };
  publicAPI.setVisited = val => {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = () => {
    let visitedCount = 0;
    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const visited = child.getVisited();
      if (visited) {
        model.children[visitedCount++] = child;
        child.setVisited(false);
      } else {
        const renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        child.delete();
      }
    }
    model.children.length = visitedCount;
  };
  publicAPI.createViewNode = dataObj => {
    if (!model.myFactory) {
      vtkErrorMacro('Cannot create view nodes without my own factory');
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
  const parentDelete = publicAPI.delete;
  publicAPI.delete = () => {
    for (let i = 0; i < model.children.length; i++) {
      model.children[i].delete();
    }
    parentDelete();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // _parent: null,
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.event(publicAPI, model, 'event');
  model._renderableChildMap = new Map();
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['visited']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.getArray(publicAPI, model, ['children']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.moveToProtected(publicAPI, model, ['parent']);

  // Object methods
  vtkViewNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkViewNode');

// ----------------------------------------------------------------------------

var vtkViewNode$1 = {
  newInstance,
  extend,
  PASS_TYPES
};




/***/ }),

/***/ 84784:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkViewNodeFactory$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkViewNodeFactory(publicAPI, model) {
  // Make sure our overrides is just for our instance not shared with everyone...
  if (!model.overrides) {
    model.overrides = {};
  }

  // Set our className
  model.classHierarchy.push('vtkViewNodeFactory');
  publicAPI.createNode = dataObject => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // overrides: {},
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Object methods
  vtkViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkViewNodeFactory$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 10299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUBindGroup$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkWebGPUBindGroup methods
// ----------------------------------------------------------------------------

function vtkWebGPUBindGroup(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBindGroup');
  publicAPI.setBindables = bindables => {
    // is there a difference between the old and new list?
    if (model.bindables.length === bindables.length) {
      let allMatch = true;
      for (let i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }

    // there is a difference
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = device => {
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = device => {
    // check mtime
    let mtime = publicAPI.getMTime();
    for (let i = 0; i < model.bindables.length; i++) {
      const tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupEntry();
      entry.binding = i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = pipeline => {
    const lines = [];
    const bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (let i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join('\n');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  label: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['bindGroupTime', 'handle', 'sizeInBytes', 'usage']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['label', 'device', 'arrayInformation']);
  vtkWebGPUBindGroup(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBindGroup$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 49767:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUBufferManager$1)
});

// UNUSED EXPORTS: STATIC, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray = __webpack_require__(42008);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
const BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
const PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants = {
  BufferUsage,
  PrimitiveTypes
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js



// methods we forward to the handle
const forwarded = ['getMappedRange', 'mapAsync', 'unmap'];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  const byteCount = srcArrayBuffer.byteLength;
  const srcBuffer = device.createBuffer({
    size: byteCount,
    /* eslint-disable no-undef */
    usage: GPUBufferUsage.COPY_SRC,
    /* eslint-enable no-undef */
    mappedAtCreation: true
  });
  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer)); // memcpy
  srcBuffer.unmap();
  const encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  const commandBuffer = encoder.finish();
  const queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
// ----------------------------------------------------------------------------
// vtkWebGPUBufferManager methods
// ----------------------------------------------------------------------------

function vtkWebGPUBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBuffer');
  publicAPI.create = (sizeInBytes, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = data => {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = (data, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer)); // memcpy
    model.handle.unmap();
  };

  // simple forwarders
  for (let i = 0; i < forwarded.length; i++) {
    publicAPI[forwarded[i]] = function () {
      return model.handle[forwarded[i]](...arguments);
    };
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['handle', 'sizeInBytes', 'usage']);
  macros2.m.setGet(publicAPI, model, ['strideInBytes', 'device', 'arrayInformation', 'label', 'sourceTime']);
  vtkWebGPUBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBuffer$1 = {
  newInstance,
  extend,
  ...Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var Property = __webpack_require__(89585);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js





const {
  Representation
} = Property/* default */.Ay;
const {
  PrimitiveTypes: IndexBuffer_PrimitiveTypes
} = Constants;

// Simulate a small map of pointId to flatId for a cell. The original code
// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed
// length arrays with a count is so much faster even with the required for
// loops and if statements. This only works as we know the usage is
// restricted to clear(), set() get() and has() so the count is always
// incrmenting except for clear where it goes back to 0. Performance
// improvement is probably due to this appoach not hitting the heap but wow
// it is so much faster. Code that adds to these vectors checks against 9 to
// make sure there is room. Switching to test against vec.length -1 results
// in a small performance hit, so if you change 10, search for 9 in this
// small class and change those as well.
class _LimitedMap {
  constructor() {
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  clear() {
    this.count = 0;
  }
  has(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return true;
      }
    }
    return undefined;
  }
  get(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return this.values[i];
      }
    }
    return undefined;
  }
  set(key, value) {
    if (this.count < 9) {
      this.keys[this.count] = key;
      this.values[this.count++] = value;
    }
  }
}
function getPrimitiveName(primType) {
  switch (primType) {
    case IndexBuffer_PrimitiveTypes.Points:
      return 'points';
    case IndexBuffer_PrimitiveTypes.Lines:
      return 'lines';
    case IndexBuffer_PrimitiveTypes.Triangles:
    case IndexBuffer_PrimitiveTypes.TriangleEdges:
      return 'polys';
    case IndexBuffer_PrimitiveTypes.TriangleStripEdges:
    case IndexBuffer_PrimitiveTypes.TriangleStrips:
      return 'strips';
    default:
      return '';
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  let flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  // are any points already marked for this cell? If so use that as the provoking point
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);

      // insert remaining ptIds (they do not need to provoke)
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId = ptIds[ptIdx2 % numPtIds];
        const flatId = _getOrAddFlatId(state, ptId, cellId);
        // add to ibo
        state.ibo[state.iboId++] = flatId;
      }
      // all done now
      return;
    }
  }

  // else have any of the points not been used yet? (not in provokedPointIds)
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      let flatId = _getOrAddFlatId(state, ptId, cellId);
      // mark provoking and add to ibo
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, flatId);
      // when provoking always set the cellId as an original non-provoking value
      // will have been stored and we need to overwrite that
      state.flatIdToCellId[flatId] = cellId;
      state.ibo[state.iboId++] = flatId;

      // insert remaining ptIds (they do not need to provoke)
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId = ptIds[ptIdx2 % numPtIds];
        flatId = _getOrAddFlatId(state, ptId, cellId);
        // add to ibo
        state.ibo[state.iboId++] = flatId;
      }
      // all done now
      return;
    }
  }

  // if we got here then none of the ptIds could be used to provoke
  // so just duplicate the first one
  let ptId = ptIds[0];
  let flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;

  // add to ibo
  state.ibo[state.iboId++] = flatId;

  // insert remaining ptIds (they do not need to provoke)
  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
    ptId = ptIds[ptIdx2];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    // add to ibo
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  state.iboSize += numPtIds;

  // are any points already marked for this cell? If so use that as the provoking point
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }

  // else have any of the points not been used yet? (not in provokedPointIds)
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, 1);
      return;
    }
  }
  // if we got here then none of the ptIds could be used to provoke
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
let processCell;
const _single = new Uint32Array(1);
const _double = new Uint32Array(2);
const _triple = new Uint32Array(3);
const _indexCellBuilders = {
  // easy, every input point becomes an output point
  anythingToPoints(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0; i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe(numPoints, cellPts, offset, cellId, state) {
    // for lines we add a bunch of segments
    for (let i = 0; i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe(numPoints, cellPts, offset, cellId, state) {
    // for polys we add a bunch of segments and close it
    if (numPoints > 2) {
      for (let i = 0; i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      // for strips we add a bunch of segments and close it
      for (let i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
      for (let i = 0; i < numPoints - 2; i++) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};

// ----------------------------------------------------------------------------
// vtkWebGPUIndexBufferManager methods
// ----------------------------------------------------------------------------

function vtkWebGPUIndexBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUIndexBuffer');
  publicAPI.buildIndexBuffer = req => {
    const cellArray = req.cells;
    const primitiveType = req.primitiveType;
    const representation = req.representation;
    const cellOffset = req.cellOffset;
    const array = cellArray.getData();
    const cellArraySize = array.length;
    const inRepName = getPrimitiveName(primitiveType);
    const numPts = req.numberOfPoints;
    const state = {
      provokedPointIds: new Uint8Array(numPts),
      // size is good
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    let func = null;
    if (representation === Representation.POINTS || primitiveType === IndexBuffer_PrimitiveTypes.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation.WIREFRAME || primitiveType === IndexBuffer_PrimitiveTypes.Lines) {
      func = _indexCellBuilders[`${inRepName}ToWireframe`];
    } else {
      func = _indexCellBuilders[`${inRepName}ToSurface`];
    }

    // first we count how many extra provoking points we need
    processCell = countCell;
    let cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }

    // then we allocate the remaining structures
    // (we pick the best size to save space and transfer costs)
    if (numPts <= 0xffff) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 0x8fff) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 0xffff) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = 'uint16';
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = 'uint32';
    }
    if (cellId <= 0xffff) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);

    // and fill them in
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;

    // store the results we need
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const IndexBuffer_DEFAULT_VALUES = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};

// ----------------------------------------------------------------------------

function IndexBuffer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, IndexBuffer_DEFAULT_VALUES, initialValues);

  // Inheritance
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macros2.m.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);
  vtkWebGPUIndexBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const IndexBuffer_newInstance = macros2.m.newInstance(IndexBuffer_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUIndexBuffer$1 = {
  newInstance: IndexBuffer_newInstance,
  extend: IndexBuffer_extend,
  ...Constants
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js








const {
  BufferUsage: BufferManager_BufferUsage
} = Constants;
const {
  vtkErrorMacro
} = macros2.c;
const {
  VtkDataTypes
} = DataArray/* default */.Ay;

// the webgpu constants all show up as undefined
/* eslint-disable no-undef */

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {};
function _getFormatForDataArray(dataArray) {
  let format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes.UNSIGNED_CHAR:
      format = 'uint8';
      break;
    case VtkDataTypes.FLOAT:
      format = 'float32';
      break;
    case VtkDataTypes.UNSIGNED_INT:
      format = 'uint32';
      break;
    case VtkDataTypes.INT:
      format = 'sint32';
      break;
    case VtkDataTypes.DOUBLE:
      format = 'float32';
      break;
    case VtkDataTypes.UNSIGNED_SHORT:
      format = 'uint16';
      break;
    case VtkDataTypes.SHORT:
      format = 'sin16';
      break;
    default:
      format = 'float32';
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += 'x2';
      break;
    case 3:
      // only 32bit types support x3
      if (!format.includes('32')) {
        vtkErrorMacro(`unsupported x3 type for ${format}`);
      }
      format += 'x3';
      break;
    case 4:
      format += 'x4';
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  const result = {};
  const flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }

  // setup shift and scale
  let shift = [0.0, 0.0, 0.0, 0.0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  let scale = [1.0, 1.0, 1.0, 1.0];
  if (options.scale) {
    if (options.scale.length) {
      scale = options.scale;
    } else {
      scale.fill(options.scale);
    }
  }
  const packExtra = Object.prototype.hasOwnProperty.call(options, 'packExtra') ? options.packExtra : false;
  let addAPoint;
  let vboidx = 0;
  const stride = numComp + (packExtra ? 1 : 0);
  const packedVBO = (0,macros2.a)(outputType, flatSize * stride);

  // pick the right function based on point versus cell data
  let flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }

  // add data based on number of components
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * 1.0 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * inArrayData[i + 3] + shift[3];
    };
  }

  // for each entry in the flat array process it
  for (let index = 0; index < flatSize; index++) {
    const inArrayId = numComp * flatIdMap[index];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i2) {
  const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  const result = [];
  (0,Core_Math.j)(v1, v2, result);
  (0,Core_Math.l)(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  const pointData = pointArray.getData();
  const cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }

  // return a cellArray of normals
  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  const size = cellArrayData.length;
  let vboidx = 0;
  for (let index = 0; index < size;) {
    const normal = getNormal(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index += cellArrayData[index] + 1;
  }
  return packedVBO;
}

// ----------------------------------------------------------------------------
// vtkWebGPUBufferManager methods
// ----------------------------------------------------------------------------
function vtkWebGPUBufferManager(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUBufferManager');
  function _createBuffer(req) {
    // if a dataArray is provided set the nativeArray
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    let buffer;
    let gpuUsage;

    // handle index buffers
    if (req.usage === BufferManager_BufferUsage.Index) {
      // todo change to FlattenedIndex to be more clear
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }

    // create one if not done already
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }

    // handle uniform buffers
    if (req.usage === BufferManager_BufferUsage.UniformArray) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // handle storage buffers
    if (req.usage === BufferManager_BufferUsage.Storage) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // handle textures
    if (req.usage === BufferManager_BufferUsage.Texture) {
      /* eslint-disable no-bitwise */
      gpuUsage = GPUBufferUsage.COPY_SRC;
      /* eslint-enable no-bitwise */
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }

    // all of the below types that have gpuUsage = VERTEX require format
    // to be provided.

    // handle point data
    if (req.usage === BufferManager_BufferUsage.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = Types/* default */.A.getNativeTypeFromBufferFormat(req.format);
      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? 'flat' : 'perspective'
      }]);
    }

    // handle normals from points, snorm8x4
    if (req.usage === BufferManager_BufferUsage.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = Types/* default */.A.getNativeTypeFromBufferFormat(req.format);
      const normals = generateNormals(req.cells, req.dataArray);
      const result = packArray(req.indexBuffer, normals, 4, arrayType, {
        cellData: true
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: 'flat'
      }]);
    }
    if (req.usage === BufferManager_BufferUsage.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(Types/* default */.A.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }

  // is the buffer already present?
  publicAPI.hasBuffer = hash => model.device.hasCachedObject(hash);
  publicAPI.getBuffer = req => {
    // if we have a source the get/create/cache the buffer
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
    const format = _getFormatForDataArray(dataArray);
    const buffRequest = {
      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,
      usage: BufferManager_BufferUsage.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = () => {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);

    // prettier-ignore
    const array = new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: 'float32x3'
    }]);
    return model.fullScreenQuadBuffer;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const BufferManager_DEFAULT_VALUES = {
  device: null,
  fullScreenQuadBuffer: null
};

// ----------------------------------------------------------------------------

function BufferManager_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, BufferManager_DEFAULT_VALUES, initialValues);

  // Object methods
  (0,macros2.o)(publicAPI, model);
  (0,macros2.e)(publicAPI, model, ['device']);
  vtkWebGPUBufferManager(publicAPI, model);
}

// ----------------------------------------------------------------------------

const BufferManager_newInstance = (0,macros2.n)(BufferManager_extend);

// ----------------------------------------------------------------------------

var vtkWebGPUBufferManager$1 = {
  newInstance: BufferManager_newInstance,
  extend: BufferManager_extend,
  ...STATIC,
  ...Constants
};




/***/ }),

/***/ 26910:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3823);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50440);





// ----------------------------------------------------------------------------
// vtkWebGPUCamera methods
// ----------------------------------------------------------------------------

function vtkWebGPUCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCamera');
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.identity */ .pB.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      // set up a rectangular parallelipiped
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1.0) * width;
      const xmax = (windowCenter[0] + 1.0) * width;
      const ymin = (windowCenter[1] - 1.0) * height;
      const ymax = (windowCenter[1] + 1.0) * height;
      const xr = 1.0 / (xmax - xmin);
      const yr = 1.0 / (ymax - ymin);
      outMat[0] = 2.0 * xr;
      outMat[5] = 2.0 * yr;
      outMat[10] = 1.0 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360.0);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1.0) * width;
      const xmax = (windowCenter[0] + 1.0) * width;
      const ymin = (windowCenter[1] - 1.0) * height;
      const ymax = (windowCenter[1] + 1.0) * height;
      outMat[0] = 2.0 * cRange[0] / (xmax - xmin);
      outMat[5] = 2.0 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0.0;
      outMat[14] = cRange[0];
      outMat[11] = -1.0;
      outMat[15] = 0.0;
    }
  };
  publicAPI.convertToOpenGLDepth = val => {
    if (model.renderable.getParallelProjection()) {
      return 1.0 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2.0 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = webGPURenderer => {
    // has the camera changed?
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.copy */ .pB.copy(model.keyMatrices.normalMatrix, wcvc);
      // zero out translation
      model.keyMatrices.normalMatrix[3] = 0.0;
      model.keyMatrices.normalMatrix[7] = 0.0;
      model.keyMatrices.normalMatrix[11] = 0.0;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.transpose */ .pB.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.translate */ .pB.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.multiply */ .pB.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .mat4.invert */ .pB.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  keyMatrixTime: null,
  keyMatrices: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.obj(model.keyMatrixTime);

  // values always get set by the get method
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.setGet(publicAPI, model, ['keyMatrixTime']);

  // Object methods
  vtkWebGPUCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_1__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var index = {
  newInstance,
  extend
};

// Register ourself to WebGPU backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_3__/* .registerOverride */ .c9)('vtkCamera', newInstance);




/***/ }),

/***/ 94363:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUFullScreenQuad$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _ShaderCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9806);
/* harmony import */ var _SimpleMapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32603);




// ----------------------------------------------------------------------------
// vtkWebGPUFullScreenQuad methods
// ----------------------------------------------------------------------------

function vtkWebGPUFullScreenQuad(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUFullScreenQuad');
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    vDesc.addOutput('vec4<f32>', 'vertexVC');
    let code = vDesc.getCode();
    code = _ShaderCache_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);', 'output.vertexVC = vec4<f32>(vertexBC, 1);']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = () => {
    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ['vertexBC']);
    model.numberOfVertices = 6;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SimpleMapper_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUFullScreenQuad(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUFullScreenQuad');

// ----------------------------------------------------------------------------

var vtkWebGPUFullScreenQuad$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 77489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25196);
/* harmony import */ var _ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50440);




// ----------------------------------------------------------------------------
// vtkWebGPUPixelSpaceCallbackMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push('vtkWebGPUPixelSpaceCallbackMapper');
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues()) ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUPixelSpaceCallbackMapper');

// ----------------------------------------------------------------------------

var index = {
  newInstance,
  extend
};

// Register ourself to WebGPU backend if imported
(0,_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_2__/* .registerOverride */ .c9)('vtkPixelSpaceCallbackMapper', newInstance);




/***/ }),

/***/ 24210:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: default, extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/index.js + 1 modules
var esm = __webpack_require__(3823);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js
var Core_Math = __webpack_require__(16632);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
var BindGroup = __webpack_require__(10299);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
var FullScreenQuad = __webpack_require__(94363);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js + 3 modules
var BufferManager = __webpack_require__(49767);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js




const {
  BufferUsage
} = BufferManager/* default */.Ay;
const {
  vtkErrorMacro
} = macros2.m;

// ----------------------------------------------------------------------------
// vtkWebGPUStorageBuffer - similar to the UniformBuffer class
// but YOU are responsible for layout issues and alignment.
// The order you add entries is the order they will be layed out
// in memory. But you must follow layout rules.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkWebGPUStorageBuffer methods
// ----------------------------------------------------------------------------

function vtkWebGPUStorageBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUStorageBuffer');
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro(`entry named ${name} already exists`);
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    const sizeInBytes = Types/* default */.A.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: Types/* default */.A.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = device => {
    if (!model._buffer) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = type => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macros2.m.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, instance, val) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = (name, instance, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (let i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255.0;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = 9;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let j = 0; j < 3; j++) {
        for (let i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = () => model._sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    const lines = [`struct ${model.label}StructEntry\n{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
    return lines.join('\n');
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = () => {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);

  // Internal objects
  model._bufferEntryNames = new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macros2.m.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macros2.m.obj(model.bindGroupTime, {
    mtime: 0
  });

  // default SSBO desc
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: 'read-only-storage'
    }
  };
  macros2.m.get(publicAPI, model, ['bindGroupTime']);
  macros2.m.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);

  // Object methods
  vtkWebGPUStorageBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkWebGPUStorageBuffer');

// ----------------------------------------------------------------------------

var vtkWebGPUStorageBuffer$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var UniformBuffer = __webpack_require__(83259);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var ViewNodeFactory = __webpack_require__(50440);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js










const {
  vtkDebugMacro
} = macros2.c;
const clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
const clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
const _fsqClearMat4 = new Float64Array(16);
const _tNormalMat4 = new Float64Array(16);

// Light type index gives either 0, 1, or 2 which indicates what type of light there is.
// While technically, there are only spot and directional lights, within the CellArrayMapper
// there is a third, positional light. It is technically just a variant of a spot light with
// a cone angle of 90 or above, however certain calculations can be skipped if it is treated
// separately.
// The mappings are shown below:
// 0 -> positional light
// 1 -> directional light
// 2 -> spot light
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}

// ----------------------------------------------------------------------------
// vtkWebGPURenderer methods
// ----------------------------------------------------------------------------
/* eslint-disable no-bitwise */

function vtkWebGPURenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPURenderer');

  // Builds myself.
  publicAPI.buildPass = prepass => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    // This method is designed to help with floating point
    // issues when rendering datasets that push the limits of
    // resolutions on float.
    //
    // One of the most common cases is when the dataset is located far
    // away from the origin relative to the clipping range we are looking
    // at. For that case we want to perform the floating point sensitive
    // multiplications on the CPU in double. To this end we want the
    // vertex rendering ops to look something like
    //
    // Compute shifted points and load those into the VBO
    // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;
    //
    // In the vertex shader do the following
    // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;
    //
    // We use two matrices because it is expensive to change the
    // WorldToStabilized matrix as we have to reupload all pointCoords
    // So that matrix (MCSCMatrix) is fairly static, the Stabilized to
    // Device matrix is the one that gets updated every time the camera
    // changes.
    //
    // The basic idea is that we should translate the data so that
    // when the center of the view frustum moves a lot
    // we recenter it. The center of the view frustum is roughly
    // camPos + dirOfProj*(far + near)*0.5
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset = [];
    esm/* vec3.scale */.eR.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    esm/* vec3.add */.eR.add(center, pos, offset);
    esm/* vec3.sub */.eR.sub(offset, center, model.stabilizedCenter);
    const length = esm/* vec3.len */.eR.len(offset);
    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0.0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro('No lights are on, creating one.');
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.updateUBO = () => {
    // make sure the data is up to date
    // has the camera changed?
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray('WCVCMatrix', keyMats.wcvc);
      model.UBO.setArray('SCPCMatrix', keyMats.scpc);
      model.UBO.setArray('PCSCMatrix', keyMats.pcsc);
      model.UBO.setArray('SCVCMatrix', keyMats.scvc);
      model.UBO.setArray('VCPCMatrix', keyMats.vcpc);
      model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);
      model.UBO.setValue('LightCount', model.renderable.getLights().length);
      model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());
      model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);
      model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i = 0; i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i = 0; i < lights.length; i++) {
        const offset = i * 4;

        // Position
        const viewCoordinatePosition = lights[i].getPosition();
        esm/* vec3.transformMat4 */.eR.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        // viewCoordinatePosition
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;

        // Rotation (All are negative to correct for -Z being forward)
        lightDirArray[offset] = -lights[i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[i].getDirection()[2];
        lightDirArray[offset + 3] = 0;

        // Color
        lightColorArray[offset] = lights[i].getColor()[0];
        lightColorArray[offset + 1] = lights[i].getColor()[1];
        lightColorArray[offset + 2] = lights[i].getColor()[2];
        lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights

        // Type
        lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type
        lightTypeArray[offset + 1] = Math.cos((0,Core_Math.r)(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits
        lightTypeArray[offset + 2] = Math.cos((0,Core_Math.r)(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi
        lightTypeArray[offset + 3] = 0;
      }

      // Im not sure how correct this is, but this is what the example does
      // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position
      model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction
      model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)
      model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)

      model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);
      model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);
      model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);
      model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = encoder => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);
    // set scissor
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = renderEncoder => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };

  // Renders myself
  publicAPI.opaquePass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    // Normal Solid Color
    if (!model.clearFSQ) {
      model.clearFSQ = FullScreenQuad/* default.newInstance */.Ay.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash('clearfsq');
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    // Textured Background
    if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';
        tview.addSampler(device, {
          addressModeU: 'repeat',
          addressModeV: 'clamp-to-edge',
          addressModeW: 'repeat',
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: 'linear'
        });
      }
      model.clearFSQ.setPipelineHash('clearfsqwithtexture');
    } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      // In case the mode is changed at runtime
      model.clearFSQ = FullScreenQuad/* default.newInstance */.Ay.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash('clearfsq');
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = UniformBuffer/* default.newInstance */.Ay.newInstance({
        label: 'mapperUBO'
      });
      ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
      ubo.addEntry('BackgroundColor', 'vec4<f32>');
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray('BackgroundColor', background);
    esm/* mat4.transpose */.pB.transpose(_tNormalMat4, keyMats.normalMatrix);
    esm/* mat4.mul */.pB.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    esm/* mat4.mul */.pB.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = prepass => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();

    // if there is no window assume 0 1
    const tileViewPort = [0.0, 0.0, 1.0, 1.0];

    // find the lower left corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];

    // store the result as a pixel value
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);

    // find the upper right corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

    // now compute the size of the intersection of the viewport with the
    // current tile
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = id => {
    for (let i = 0; i < model.children.length; i++) {
      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const Renderer_DEFAULT_VALUES = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20.0,
  suppressClear: false,
  stabilizedCenter: [0.0, 0.0, 0.0]
};

// ----------------------------------------------------------------------------

function Renderer_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, Renderer_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);

  // UBO
  model.UBO = UniformBuffer/* default.newInstance */.Ay.newInstance({
    label: 'rendererUBO'
  });
  model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');
  model.UBO.addEntry('viewportSize', 'vec2<f32>');
  model.UBO.addEntry('LightCount', 'i32');
  model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');
  model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');
  model.UBO.addEntry('BackgroundSpecularStrength', 'f32');
  model.UBO.addEntry('cameraParallel', 'u32');

  // SSBO (Light data)
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: 'rendererLightSSBO'
  });
  model.lightTimeString = '';
  model.bindGroup = BindGroup/* default.newInstance */.Ay.newInstance({
    label: 'rendererBG'
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = esm/* mat4.identity */.pB.identity(new Float64Array(16));
  model.stabilizedTime = {};
  (0,macros2.o)(model.stabilizedTime, {
    mtime: 0
  });

  // Build VTK API
  (0,macros2.g)(publicAPI, model, ['bindGroup', 'stabilizedTime']);
  (0,macros2.k)(publicAPI, model, ['stabilizedCenter']);
  (0,macros2.e)(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);

  // Object methods
  vtkWebGPURenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const Renderer_newInstance = (0,macros2.n)(Renderer_extend, 'vtkWebGPURenderer');

// ----------------------------------------------------------------------------

var index = {
  newInstance: Renderer_newInstance,
  extend: Renderer_extend
};

// Register ourself to WebGPU backend if imported
(0,ViewNodeFactory/* registerOverride */.c9)('vtkRenderer', Renderer_newInstance);




/***/ }),

/***/ 20461:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUSampler$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


/* eslint-disable no-bitwise */

// ----------------------------------------------------------------------------
// vtkWebGPUSampler methods
// ----------------------------------------------------------------------------

function vtkWebGPUSampler(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUSampler');
  publicAPI.create = function (device) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : 'clamp-to-edge';
    model.options.addressModeV = options.addressModeV ? options.addressModeV : 'clamp-to-edge';
    model.options.addressModeW = options.addressModeW ? options.addressModeW : 'clamp-to-edge';
    model.options.magFilter = options.magFilter ? options.magFilter : 'nearest';
    model.options.minFilter = options.minFilter ? options.minFilter : 'nearest';
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : 'nearest';
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = (binding, group) => {
    const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
    return result;
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: model.handle
    };
    return foo;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null,
  label: null,
  options: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    sampler: {
      // type: 'filtering',
    }
  };
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['bindGroupTime', 'handle', 'options']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label']);
  vtkWebGPUSampler(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend);

// ----------------------------------------------------------------------------

var vtkWebGPUSampler$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 9806:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUShaderCache$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js


// ----------------------------------------------------------------------------
// vtkWebGPUShaderModule methods
// ----------------------------------------------------------------------------

function vtkWebGPUShaderModule(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderModule');
  publicAPI.initialize = (device, shaderDesc) => {
    model.device = device;
    // console.log(shaderDesc.getCode());
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };

  // publicAPI.setLastCameraMTime = (mtime) => {
  //   model.lastCameraMTime = mtime;
  // };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  device: null,
  handle: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.get(publicAPI, model, ['lastCameraMTime']);
  macros2.m.setGet(publicAPI, model, ['device', 'handle']);

  // Object methods
  vtkWebGPUShaderModule(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = macros2.m.newInstance(extend, 'vtkWebGPUShaderModule');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderModule$1 = {
  newInstance,
  extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js



// perform in place string substitutions, indicate if a substitution was done
// this is useful for building up shader strings which typically involve
// lots of string substitutions. Return true if a substitution was done.
function substitute(source, search, replace) {
  let all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const replaceStr = Array.isArray(replace) ? replace.join('\n') : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = '';
  if (all) {
    gflag = 'g';
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}

// ----------------------------------------------------------------------------
// vtkWebGPUShaderCache methods
// ----------------------------------------------------------------------------

function vtkWebGPUShaderCache(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderCache');
  publicAPI.getShaderModule = shaderDesc => {
    // has it already been created?
    const sType = shaderDesc.getType();
    const sHash = shaderDesc.getHash();
    const keys = model._shaderModules.keys();
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }

    // console.log(JSON.stringify(shaderDesc));

    const sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderCache_DEFAULT_VALUES = {
  shaderModules: null,
  device: null,
  window: null
};

// ----------------------------------------------------------------------------

function ShaderCache_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderCache_DEFAULT_VALUES, initialValues);

  // Internal objects
  model._shaderModules = new Map();

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['device', 'window']);

  // Object methods
  vtkWebGPUShaderCache(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderCache_newInstance = macros2.m.newInstance(ShaderCache_extend, 'vtkWebGPUShaderCache');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderCache$1 = {
  newInstance: ShaderCache_newInstance,
  extend: ShaderCache_extend,
  substitute
};




/***/ }),

/***/ 32603:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ vtkWebGPUSimpleMapper$1)
});

// UNUSED EXPORTS: extend, newInstance

// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/macros2.js
var macros2 = __webpack_require__(28906);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var ViewNode = __webpack_require__(25196);
// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
var BindGroup = __webpack_require__(10299);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js


// ----------------------------------------------------------------------------
// vtkWebGPUPipeline methods
// ----------------------------------------------------------------------------
function vtkWebGPUPipeline(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUPipeline');
  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
  publicAPI.initialize = (device, hash) => {
    // start with the renderencoder settings
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;

    // add in bind group layouts
    const bindGroupLayouts = [];
    for (let i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      const sd = model.shaderDescriptions[i];
      const sm = device.getShaderModule(sd);
      if (sd.getType() === 'vertex') {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = 'main';
      }
      if (sd.getType() === 'fragment') {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = 'main';
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = stype => {
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype) return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = bindGroup => {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = idx => model.layouts[idx].layout;
  publicAPI.getBindGroupLayoutCount = llabel => {
    for (let i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = (renderEncoder, vInput) => {
    vInput.bindBuffers(renderEncoder);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const DEFAULT_VALUES = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};

// ----------------------------------------------------------------------------
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,macros2.o)(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  (0,macros2.g)(publicAPI, model, ['handle', 'pipelineDescription']);
  (0,macros2.e)(publicAPI, model, ['device', 'renderEncoder', 'topology', 'vertexState']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkWebGPUPipeline(publicAPI, model);
}

// ----------------------------------------------------------------------------
const newInstance = (0,macros2.n)(extend, 'vtkWebGPUPipeline');

// ----------------------------------------------------------------------------
var vtkWebGPUPipeline$1 = {
  newInstance,
  extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js + 1 modules
var ShaderCache = __webpack_require__(9806);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js



// ----------------------------------------------------------------------------
// vtkWebGPUShaderDescription methods
// ----------------------------------------------------------------------------

// shader description

function vtkWebGPUShaderDescription(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUShaderDescription');
  publicAPI.hasOutput = name => model.outputNames.includes(name);
  publicAPI.addOutput = function (type, name) {
    let interpolation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = (type, name) => {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = (type, name) => {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };

  // perform shader replacements for the input and outputs
  // of this shader. That includes vertex inputs if specified
  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
    const inputImpl = [];
    let iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      const inputStruct = [];
      inputStruct.push(`struct ${model.type}Input\n{`);
      if (priorStage) {
        const inputNames = priorStage.getOutputNamesByReference();
        const inputTypes = priorStage.getOutputTypesByReference();
        const inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (let i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== undefined) {
            inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
          } else {
            inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
          }
        }
      }
      for (let i = 0; i < model.builtinInputNames.length; i++) {
        inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
      }
      if (inputStruct.length > 1) {
        inputStruct.push('};');
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ',';
        inputImpl.push(`input: ${model.type}Input`);
      }
    }
    if (inputImpl.length) {
      model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Input', inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      const outputStruct = [`struct ${model.type}Output\n{`];
      for (let i = 0; i < model.outputNames.length; i++) {
        if (model.outputInterpolations[i] !== undefined) {
          outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        } else {
          outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        }
      }
      for (let i = 0; i < model.builtinOutputNames.length; i++) {
        outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
      }
      outputStruct.push('};');
      iodec = iodec.concat(outputStruct);
      model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Output', [`-> ${model.type}Output`]).result;
    }
    model.code = ShaderCache/* default */.Ay.substitute(model.code, '//VTK::IOStructs::Dec', iodec).result;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const ShaderDescription_DEFAULT_VALUES = {
  type: null,
  // 'vertex' or 'fragment'
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};

// ----------------------------------------------------------------------------

function ShaderDescription_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, ShaderDescription_DEFAULT_VALUES, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];

  // Build VTK API
  macros2.m.obj(publicAPI, model);
  macros2.m.setGet(publicAPI, model, ['type', 'hash', 'code']);
  macros2.m.getArray(publicAPI, model, ['outputTypes', 'outputNames', 'outputInterpolations']);

  // Object methods
  vtkWebGPUShaderDescription(publicAPI, model);
}

// ----------------------------------------------------------------------------

const ShaderDescription_newInstance = macros2.m.newInstance(ShaderDescription_extend, 'vtkWebGPUShaderDescription');

// ----------------------------------------------------------------------------

var vtkWebGPUShaderDescription$1 = {
  newInstance: ShaderDescription_newInstance,
  extend: ShaderDescription_extend
};



// EXTERNAL MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var Types = __webpack_require__(57372);
;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js



function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!b.includes(a[i])) return false;
  }
  return true;
}

// ----------------------------------------------------------------------------
// vtkWebGPUVertexInput methods
// ----------------------------------------------------------------------------
function vtkWebGPUVertexInput(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUVertexInput');
  publicAPI.addBuffer = function (buffer, inames) {
    let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';
    let names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    // only add if it is a new setting
    for (let i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }

    // when adding a new entry, make sure we sort the array
    // as the order is important to the shader and must always
    // be the same, so alphabetical is an easy option
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort((v1, v2) => {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = name => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = () => {
    let result = '';
    let nameCount = 0;
    for (let i = 0; i < model.inputs.length; i++) {
      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        const type = Types/* default */.A.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ',\n';
        }
        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = () => {
    const info = {};
    if (model.inputs.length) {
      const vertexBuffers = [];
      let nameCount = 0;
      for (let i = 0; i < model.inputs.length; i++) {
        const buf = model.inputs[i].buffer;
        const buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        const arrayInfo = buf.getArrayInformation();
        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = renderEncoder => {
    for (let i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = () => {};
  publicAPI.releaseGraphicsResources = () => {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const VertexInput_DEFAULT_VALUES = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};

// ----------------------------------------------------------------------------
function VertexInput_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, VertexInput_DEFAULT_VALUES, initialValues);

  // Build VTK API
  (0,macros2.o)(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  (0,macros2.e)(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);

  // For more macro methods, see "Sources/macros.js"
  // Object specific methods
  vtkWebGPUVertexInput(publicAPI, model);
}

// ----------------------------------------------------------------------------
const VertexInput_newInstance = (0,macros2.n)(VertexInput_extend, 'vtkWebGPUVertexInput');

// ----------------------------------------------------------------------------
var vtkWebGPUVertexInput$1 = {
  newInstance: VertexInput_newInstance,
  extend: VertexInput_extend
};



;// CONCATENATED MODULE: ../../../node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js








const vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
const vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;

// ----------------------------------------------------------------------------
// vtkWebGPUSimpleMapper methods
// ----------------------------------------------------------------------------

function vtkWebGPUSimpleMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUSimpleMapper');
  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
    // create the shader descriptions
    const vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: 'vertex',
      hash,
      code: model.vertexShaderTemplate
    });
    const fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: 'fragment',
      hash,
      code: model.fragmentShaderTemplate
    });

    // add them to the pipeline
    const sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);

    // look for replacements to invoke
    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    // eslint-disable-next-line prefer-regex-literals
    const re = new RegExp('//VTK::[^:]*::', 'g');
    const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);
    const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);

    // now invoke shader replacement functions
    for (let i = 0; i < fnames.length; i++) {
      const fname = fnames[i];
      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }

    // always replace the IOStructs last as other replacement funcs may
    // add inputs or outputs
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);

    // console.log(vDesc.getCode());
    // console.log(fDesc.getCode());
  };

  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.replaceShaderCode(null, vertexInput);
    const fDesc = pipeline.getShaderDescription('fragment');
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
    if (!model.WebGPURenderer) {
      return;
    }
    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription('vertex');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
    const ubocode = model.bindGroup.getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription('vertex');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription('fragment');
    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');
    code = fDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    let code = vDesc.getCode();
    code = ShaderCache/* default */.Ay.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec2<f32>', 'tcoordVS');
  };
  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = view => {
    // is it already there?
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };

  // do everything required for this mapper to be rerady to draw
  // but do not bind or do the actual draw commands as the pipeline
  // is not neccessarily bound yet
  publicAPI.prepareToDraw = renderEncoder => {
    model.renderEncoder = renderEncoder;

    // do anything needed to get our input data up to date
    publicAPI.updateInput();

    // make sure buffers are created and up to date
    publicAPI.updateBuffers();

    // update bindings and bind groups/layouts
    // does not acutally bind them, that is done in draw(...)
    publicAPI.updateBindings();

    // update the pipeline, includes computing the hash, and if needed
    // creating the pipeline, shader code etc
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = () => {};
  publicAPI.updateBuffers = () => {};
  publicAPI.updateBindings = () => {
    // bindings can change without a pipeline change
    // as long as their layout remains the same.
    // That is why this is done even when the pipeline
    // hash doesn't change.
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = () => {};
  publicAPI.registerDrawCallback = encoder => {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = encoder => {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };

  // do the rest of the calls required to draw this mapper
  // at this point the command encouder and pipeline are
  // created and bound
  publicAPI.draw = renderEncoder => {
    const pipeline = renderEncoder.getBoundPipeline();

    // bind the mapper bind group
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }

    // bind the vertex input
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    const indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = () => {
    const bindables = [...model.additionalBindables];
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }

    // add texture BindGroupLayouts
    for (let t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      const samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = () => {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);

    // build the pipeline if needed
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const SimpleMapper_DEFAULT_VALUES = {
  additionalBindables: undefined,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: 'triangle-list',
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};

// ----------------------------------------------------------------------------

function SimpleMapper_extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, SimpleMapper_DEFAULT_VALUES, initialValues);

  // Inheritance
  ViewNode/* default */.A.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = BindGroup/* default.newInstance */.Ay.newInstance({
    label: 'mapperBG'
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = new Map();

  // Build VTK API
  macros2.m.get(publicAPI, model, ['pipeline', 'vertexInput']);
  macros2.m.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);

  // Object methods
  vtkWebGPUSimpleMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const SimpleMapper_newInstance = macros2.m.newInstance(SimpleMapper_extend, 'vtkWebGPUSimpleMapper');

// ----------------------------------------------------------------------------

var vtkWebGPUSimpleMapper$1 = {
  newInstance: SimpleMapper_newInstance,
  extend: SimpleMapper_extend
};




/***/ }),

/***/ 57372:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtkWebGPUTypes)
/* harmony export */ });
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);


// ----------------------------------------------------------------------------
// vtkWebGPUDevice static functions
//
// WebGPU uses types in a many places and calls, and often those types
// need to be associated with byte sizes, alignments, native arrays etc.
// The folowing methods are designed to help vtk.js introspect those types.
// WebGPU currently tends to use multiple type formats:
//  - buffer types such as float32x4
//  - shader types suchs as vec4<f32>
//  - texture types such as rgba32float
// ----------------------------------------------------------------------------

// see https://gpuweb.github.io/gpuweb/#texture-formats
// for possible formats, there are a lot of them
const textureDetails = {
  // 8-bit formats
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'float'
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'float'
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'uint'
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'sint'
  },
  // 16-bit formats
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'uint'
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'sint'
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'float'
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'float'
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'float'
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'uint'
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: 'sint'
  },
  // 32-bit formats
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'uint'
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'sint'
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'uint'
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'sint'
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: 'float'
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  'rgba8unorm-srgb': {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'uint'
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'sint'
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  'bgra8unorm-srgb': {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: 'float'
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'float'
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'float'
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: 'float'
  },
  // 64-bit formats
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'uint'
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'sint'
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'uint'
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'sint'
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: 'float'
  },
  // 128-bit formats
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'uint'
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'sint'
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: 'unfilterable-float'
  },
  // Depth and stencil formats
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: 'uint'
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: 'depth'
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: 'depth'
  },
  'depth24plus-stencil8': {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: 'mixed'
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: 'depth'
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6) return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
  return null;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
  // plugged into the formula below gives 1, 2, 4 respectively
  const num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return 0;
  }
  const typeSize = 5 - num / 2;
  return numComp * typeSize;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}

// see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
// for possible formats
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5) return 0;

  // raw types are Uint Int or Float as follows
  let result;
  if (format[0] === 'f') {
    result = 'Float';
  } else if (format[0] === 's') {
    result = 'Int';
  } else if (format[0] === 'u') {
    result = 'Uint';
  } else {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }

  // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
  // plugged into the formula below gives 1, 2, 4 respectively
  const base = format.split('x')[0];
  const num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }
  result += 8 * (5 - num / 2);
  result += 'Array';
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  let dataType;
  if (format[0] === 'f' || format[1] === 'n') {
    dataType = 'f32';
  } else if (format[0] === 's' && format[1] === 'i') {
    dataType = 'i32';
  } else if (format[0] === 'u' && format[1] === 'i') {
    dataType = 'u32';
  } else {
    (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
    return undefined;
  }

  // options are x2, x3, x4 or nothing
  let numComp = 1;
  if (format[format.length - 2] === 'x') {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4) return `vec4<${dataType}>`;
  if (numComp === 3) return `vec3<${dataType}>`;
  if (numComp === 2) return `vec2<${dataType}>`;
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format) return 0;
  let numComp = 1;
  if (format.substring(0, 3) === 'vec') {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === 'mat') {
    numComp = format[3] * format[5];
  }
  const typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format) return undefined;
  if (format.includes('f32')) return 'Float32Array';
  if (format.includes('i32')) return 'Int32Array';
  if (format.includes('u32')) return 'Uint32Array';
  (0,_macros2_js__WEBPACK_IMPORTED_MODULE_0__.r)(`unknown format ${format}`);
  return undefined;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};




/***/ }),

/***/ 83259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ vtkWebGPUUniformBuffer$1)
/* harmony export */ });
/* unused harmony exports extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _BufferManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49767);
/* harmony import */ var _Types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57372);




const {
  BufferUsage
} = _BufferManager_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Ay;
const {
  vtkErrorMacro
} = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m;

// ----------------------------------------------------------------------------
// vtkWebGPUUniformBuffer methods
// ----------------------------------------------------------------------------

function vtkWebGPUUniformBuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUUniformBuffer');
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro(`entry named ${name} already exists`);
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: _Types_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: _Types_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };

  // UBOs have layout rules in terms of how memory is aligned so we
  // have to be careful how we order the entries. For example a vec4<f32>
  // must be aligned on a 16 byte offset, etc. See
  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts
  // for more details. Right now you can create a situation that would fail
  // in the future we could add dummy spacer entries where needed to
  // handle alignment issues
  publicAPI.sortBufferEntries = () => {
    if (!model.sortDirty) {
      return;
    }
    let currOffset = 0;
    const newEntries = [];

    // compute the max alignment, this is required as WebGPU defines a UBO to have
    // a size that is a multiple of the maxAlignment
    let maxAlignment = 4;
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }

    // pack anything whose size is a multiple of 16 bytes first
    // this includes a couple types that don't require 16 byte alignment
    // such as mat2x2<f32> but that is OK
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // now it gets tough, we have the following common types (f32, i32, u32)
    // - vec2<f32> 8 byte size, 8 byte alignment
    // - vec3<f32> 12 byte size, 16 byte alignment
    // - f32 4 byte size, 4 byte alignment

    // try adding 12 byte, 4 byte pairs
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes === 12) {
        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }

    // try adding 8 byte, 8 byte pairs
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }

    // try adding 8 byte, 4 byte 4 byte triplets
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        let found = false;
        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes === 4) {
            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {
              const entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                entry.packed = true;
                entry.offset = currOffset;
                newEntries.push(entry);
                currOffset += entry.sizeInBytes;
                entry2.packed = true;
                entry2.offset = currOffset;
                newEntries.push(entry2);
                currOffset += entry2.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }

    // Add anything remaining that is larger than 4 bytes and hope we get lucky.
    // Likely if there is more than one item added here it will result
    // in a failed UBO
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes > 4) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // finally add remaining 4 byte items
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }

    // update entries and entryNames
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (let i = 0; i < model.bufferEntries.length; i++) {
      model._bufferEntryNames.set(model.bufferEntries[i].name, i);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = device => {
    if (!model.UBO) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }

    // send data down if needed
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }

    // always updated as mappers depend on this time
    // it is more of a sentIfNeededTime
    model.sendTime.modified();
  };
  publicAPI.createView = type => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, val) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = (name, arr) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === undefined) {
      vtkErrorMacro(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    let changed = false;
    for (let i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = [...arr];
    }
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = () => model.sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group) => {
    // sort the entries
    publicAPI.sortBufferEntries();
    const lines = [`struct ${model.label}Struct\n{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`};\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
    return lines.join('\n');
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(publicAPI, model);

  // Internal objects
  model._bufferEntryNames = new Map();
  model.bufferEntries = [];

  // default UBO desc
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: 'uniform'
    }
  };
  model.sendTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.get(publicAPI, model, ['binding', 'bindGroupTime']);
  _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);

  // Object methods
  vtkWebGPUUniformBuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUUniformBuffer');

// ----------------------------------------------------------------------------

var vtkWebGPUUniformBuffer$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 50440:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c9: () => (/* binding */ registerOverride)
/* harmony export */ });
/* unused harmony exports default, extend, newInstance */
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28906);
/* harmony import */ var _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84784);



const CLASS_MAPPING = Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}

// ----------------------------------------------------------------------------
// vtkWebGPUViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkWebGPUViewNodeFactory(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUViewNodeFactory');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Static class mapping shared across instances
  model.overrides = CLASS_MAPPING;

  // Inheritance
  _SceneGraph_ViewNodeFactory_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].extend */ .Ay.extend(publicAPI, model, initialValues);

  // Object methods
  vtkWebGPUViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macros2_js__WEBPACK_IMPORTED_MODULE_0__.m.newInstance(extend, 'vtkWebGPUViewNodeFactory');

// ----------------------------------------------------------------------------

var vtkWebGPUViewNodeFactory$1 = {
  newInstance,
  extend
};




/***/ }),

/***/ 37290:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* reexport safe */ _macros2_js__WEBPACK_IMPORTED_MODULE_3__.m)
/* harmony export */ });
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45043);
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vtk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42852);
/* harmony import */ var _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44302);
/* harmony import */ var _macros2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28906);






/***/ }),

/***/ 28906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ newTypedArray),
/* harmony export */   b: () => (/* binding */ newTypedArrayFrom),
/* harmony export */   c: () => (/* binding */ macro$1),
/* harmony export */   d: () => (/* binding */ algo),
/* harmony export */   e: () => (/* binding */ setGet),
/* harmony export */   f: () => (/* binding */ event),
/* harmony export */   g: () => (/* binding */ get),
/* harmony export */   h: () => (/* binding */ chain),
/* harmony export */   i: () => (/* binding */ moveToProtected),
/* harmony export */   k: () => (/* binding */ getArray),
/* harmony export */   l: () => (/* binding */ setGetArray),
/* harmony export */   m: () => (/* binding */ macro),
/* harmony export */   n: () => (/* binding */ newInstance),
/* harmony export */   o: () => (/* binding */ obj),
/* harmony export */   r: () => (/* binding */ vtkErrorMacro),
/* harmony export */   s: () => (/* binding */ set)
/* harmony export */ });
/* unused harmony exports A, B, C, D, E, F, G, H, I, J, K, L, M, T, V, _, j, p, q, t, u, v, w, x, y, z */
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45043);
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vtk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42852);
/* harmony import */ var _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44302);




/**
 * macros.js is the old macro.js.
 * The name change is so we do not get eaten by babel-plugin-macros.
 */
let globalMTime = 0;
const VOID = Symbol('void');
function getCurrentGlobalMTime() {
  return globalMTime;
}

// ----------------------------------------------------------------------------
// Logging function calls
// ----------------------------------------------------------------------------
/* eslint-disable no-prototype-builtins                                      */

const fakeConsole = {};
function noOp() {}
const consoleMethods = ['log', 'debug', 'info', 'warn', 'error', 'time', 'timeEnd', 'group', 'groupEnd'];
consoleMethods.forEach(methodName => {
  fakeConsole[methodName] = noOp;
});
_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console = console.hasOwnProperty('log') ? console : fakeConsole;
const loggerFunctions = {
  debug: noOp,
  // Don't print debug by default
  error: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.error || noOp,
  info: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.info || noOp,
  log: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.log || noOp,
  warn: _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* .vtkGlobal */ .n.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log(...arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info(...arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug(...arguments);
}
function vtkErrorMacro() {
  loggerFunctions.error(...arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn(...arguments);
}
const ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
}

// ----------------------------------------------------------------------------
// TypedArray
// ----------------------------------------------------------------------------

const TYPED_ARRAYS = Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
try {
  TYPED_ARRAYS.BigInt64Array = BigInt64Array;
  TYPED_ARRAYS.BigUint64Array = BigUint64Array;
} catch {
  // ignore
}
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return new (TYPED_ARRAYS[type] || Float64Array)(...args);
}
function newTypedArrayFrom(type) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (TYPED_ARRAYS[type] || Float64Array).from(...args);
}

// ----------------------------------------------------------------------------
// capitilize provided string
// ----------------------------------------------------------------------------

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function _capitalize(str) {
  return capitalize(str[0] === '_' ? str.slice(1) : str);
}
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// ----------------------------------------------------------------------------
// Convert byte size into a well formatted string
// ----------------------------------------------------------------------------

function formatBytesToProperUnit(size) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  let chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  const units = ['TB', 'GB', 'MB', 'KB'];
  let value = Number(size);
  let currentUnit = 'B';
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return `${value.toFixed(precision)} ${currentUnit}`;
}

// ----------------------------------------------------------------------------
// Convert thousand number with proper separator
// ----------------------------------------------------------------------------

function formatNumbersWithThousandSeparator(n) {
  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
  const sections = [];
  let size = n;
  while (size > 1000) {
    sections.push(`000${size % 1000}`.slice(-3));
    size = Math.floor(size / 1000);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join(separator);
}

// ----------------------------------------------------------------------------
// Array helper
// ----------------------------------------------------------------------------

function safeArrays(model) {
  Object.keys(model).forEach(key => {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function isTypedArray(value) {
  return Object.values(TYPED_ARRAYS).some(ctor => value instanceof ctor);
}

// ----------------------------------------------------------------------------
// shallow equals
// ----------------------------------------------------------------------------

function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// ----------------------------------------------------------------------------

function enumToString(e, value) {
  return Object.keys(e).find(key => e[key] === value);
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}

// ----------------------------------------------------------------------------
// setImmediate
// ----------------------------------------------------------------------------

function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}

// ----------------------------------------------------------------------------
// measurePromiseExecution
//
// Measures the time it takes for a promise to finish from
//   the time this function is invoked.
// The callback receives the time it took for the promise to resolve or reject.
// ----------------------------------------------------------------------------

function measurePromiseExecution(promise, callback) {
  const start = performance.now();
  promise.finally(() => {
    const delta = performance.now() - start;
    callback(delta);
  });
}

// ----------------------------------------------------------------------------
// vtkObject: modified(), onModified(callback), delete()
// ----------------------------------------------------------------------------

function obj() {
  let publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Ensure each instance as a unique ref of array
  safeArrays(model);
  const callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!('classHierarchy' in model)) {
    model.classHierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A('vtkObject');
  } else if (!(model.classHierarchy instanceof _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)) {
    const hierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A();
    for (let i = 0; i < model.classHierarchy.length; i++) {
      hierarchy.push(model.classHierarchy[i]);
    }
    model.classHierarchy = hierarchy;
  }
  function off(index) {
    callbacks[index] = null;
  }
  function on(index) {
    function unsubscribe() {
      off(index);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = () => !!model.deleted;
  publicAPI.modified = otherMTime => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach(callback => callback && callback(publicAPI));
  };
  publicAPI.onModified = callback => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    const index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };
  publicAPI.getMTime = () => model.mtime;
  publicAPI.isA = className => {
    let count = model.classHierarchy.length;
    // we go backwards as that is more likely for
    // early termination
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function () {
    let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function () {
    let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let ret = false;
    Object.keys(map).forEach(name => {
      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn(...map[name]) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        // Set data on model directly
        if (['mtime'].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro(`Warning: Set value to model directly ${name}, ${map[name]}`);
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function () {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    const subset = {};
    list.forEach(name => {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = val => model[val];
  publicAPI.delete = () => {
    Object.keys(model).forEach(field => delete model[field]);
    callbacks.forEach((el, index) => off(index));

    // Flag the instance being deleted
    model.deleted = true;
  };

  // Add serialization support
  publicAPI.getState = () => {
    if (model.deleted) {
      return null;
    }
    const jsonArchive = {
      ...model,
      vtkClass: publicAPI.getClassName()
    };

    // Convert every vtkObject to its serializable form
    Object.keys(jsonArchive).forEach(keyName => {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === '_' // protected members start with _
      ) {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      } else if (isTypedArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(name => {
      sortedObj[name] = jsonArchive[name];
    });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };

  // Add shallowCopy(otherInstance) support
  publicAPI.shallowCopy = function (other) {
    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
    }
    const otherModel = other.get();
    const keyList = Object.keys(model).sort();
    const otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach(key => {
      const keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro(`add ${key} in shallowCopy`);
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro(`Untouched keys: ${keyList.join(', ')}`);
    }
    publicAPI.modified();
  };

  // This function will get called when one invoke JSON.stringify(vtkObject)
  // JSON.stringify will only stringify the return value of this function
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };

  // Allow usage as decorator
  return publicAPI;
}

// ----------------------------------------------------------------------------
// getXXX: add getters
// ----------------------------------------------------------------------------

const objectGetterMap = {
  object(publicAPI, model, field) {
    return function getter() {
      return {
        ...model[field.name]
      };
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach(field => {
    if (typeof field === 'object') {
      const getter = objectGetterMap[field.type];
      if (getter) {
        publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
      } else {
        publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
      }
    } else {
      publicAPI[`get${_capitalize(field)}`] = () => model[field];
    }
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setters
// ----------------------------------------------------------------------------

const objectSetterMap = {
  enum(publicAPI, model, field) {
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return value => {
      if (typeof value === 'string') {
        if (field.enum[value] !== undefined) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro(`Set Enum with invalid argument ${field}, ${value}`);
        throw new RangeError('Set Enum with invalid string argument');
      }
      if (typeof value === 'number') {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map(key => field.enum[key]).indexOf(value) !== -1) {
            const previousValue = model[field.name];
            model[field.name] = value;
            model[onChanged]?.(publicAPI, model, value, previousValue);
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro(`Set Enum outside numeric range ${field}, ${value}`);
          throw new RangeError('Set Enum outside numeric range');
        }
        return false;
      }
      vtkErrorMacro(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
      throw new TypeError('Set Enum with invalid argument (String/Number)');
    };
  },
  object(publicAPI, model, field) {
    if (field.params?.length === 1) {
      vtkWarningMacro('Setter of type "object" with a single "param" field is not supported');
    }
    const onChanged = `_on${_capitalize(field.name)}Changed`;
    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      let value;
      if (args.length > 1 && field.params?.length) {
        value = field.params.reduce((acc, prop, idx) => Object.assign(acc, {
          [prop]: args[idx]
        }), {});
      } else {
        value = args[0];
      }
      if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(model[field.name], value)) {
        const previousValue = model[field.name];
        model[field.name] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  }
};
function findSetter(field) {
  if (typeof field === 'object') {
    const fn = objectSetterMap[field.type];
    if (fn) {
      return (publicAPI, model) => fn(publicAPI, model, field);
    }
    vtkErrorMacro(`No setter for field ${field}`);
    throw new TypeError('No setter for field');
  }
  return function getSetter(publicAPI, model) {
    const onChanged = `_on${_capitalize(field)}Changed`;
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }
      if (model[field] !== value) {
        const previousValue = model[field.name];
        model[field] = value;
        model[onChanged]?.(publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set(publicAPI, model, fields) {
  fields.forEach(field => {
    if (typeof field === 'object') {
      publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
    }
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add both setters and getters
// ----------------------------------------------------------------------------

function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}

// ----------------------------------------------------------------------------
// getXXX: add getters for object of type array with copy to be safe
// getXXXByReference: add getters for object of type array without copy
// ----------------------------------------------------------------------------

function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach(field => {
    publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
    publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setter for object of type array
// if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'
// set...From: fast path to copy the content of an array to the current one without call to modified.
// ----------------------------------------------------------------------------

function setArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  fieldNames.forEach(field => {
    if (model[field] && size && model[field].length !== size) {
      throw new RangeError(`Invalid initial number of values for array (${field})`);
    }
    const onChanged = `_on${_capitalize(field)}Changed`;
    publicAPI[`set${_capitalize(field)}`] = function () {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      let array = args;
      let changeDetected;
      let needCopy = false;
      // allow null or an array to be passed as a single arg.
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        /* eslint-disable prefer-destructuring */
        array = array[0];
        /* eslint-enable prefer-destructuring */
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size && array.length !== size) {
          if (array.length < size && defaultVal !== undefined) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size) array.push(defaultVal);
          } else {
            throw new RangeError(`Invalid number of values for array setter (${field})`);
          }
        }
        changeDetected = model[field] == null || model[field].length !== array.length;
        for (let i = 0; !changeDetected && i < array.length; ++i) {
          changeDetected = model[field][i] !== array[i];
        }
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        const previousValue = model[field.name];
        model[field] = array;
        model[onChanged]?.(publicAPI, model, array, previousValue);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI[`set${_capitalize(field)}From`] = otherArray => {
      const target = model[field];
      otherArray.forEach((v, i) => {
        target[i] = v;
      });
    };
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add setter and getter for object of type array
// ----------------------------------------------------------------------------

function setGetArray(publicAPI, model, fieldNames, size) {
  let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (let i = 0; i < fieldNames.length; i++) {
    const fieldName = fieldNames[i];
    if (model[fieldName] !== undefined) {
      model[`_${fieldName}`] = model[fieldName];
      delete model[fieldName];
    }
  }
}
// ----------------------------------------------------------------------------
// vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()
// ----------------------------------------------------------------------------

function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(_vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A);
  } else {
    model.inputArrayToProcess = [];
  }

  // Cache the argument for later manipulation
  model.numberOfInputs = numberOfInputs;

  // Methods
  function setInputData(dataset) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      let msg = `algorithm ${publicAPI.getClassName()} only has `;
      msg += `${model.numberOfInputs}`;
      msg += ' input ports. To add more input ports, use addInputConnection()';
      vtkErrorMacro(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    let portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = () => {
    const localMTime = publicAPI.getMTime();
    let minOutputMTime = Infinity;
    let count = numberOfOutputs;
    while (count--) {
      if (!model.output[count] || model.output[count].isDeleted()) {
        return true;
      }
      const mt = model.output[count].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count = model.numberOfInputs;
    while (count--) {
      if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    const outputPortAccess = () => getOutputData(port);
    // Add reference to filter
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }

  // Handle input if needed
  if (model.numberOfInputs) {
    // Reserve inputs
    let count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }

    // Expose public methods
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = () => {
    const ins = [];
    if (model.numberOfInputs) {
      let count = 0;
      while (count < model.numberOfInputs) {
        ins[count] = publicAPI.getInputData(count);
        count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
  publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
  publicAPI.getInputArrayToProcess = inputPort => {
    const arrayDesc = model.inputArrayToProcess[inputPort];
    const ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function (inputPort, arrayName, fieldAssociation) {
    let attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Scalars';
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}

// ----------------------------------------------------------------------------
// Event handling: onXXX(callback), invokeXXX(args...)
// ----------------------------------------------------------------------------

const EVENT_ABORT = Symbol('Event abort');
function event(publicAPI, model, eventName) {
  const callbacks = [];
  const previousDelete = publicAPI.delete;
  let curCallbackID = 1;
  function off(callbackID) {
    for (let i = 0; i < callbacks.length; ++i) {
      const [cbID] = callbacks[i];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }
  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    /* eslint-disable prefer-rest-params */
    // Go through a copy of the callbacks array in case new callbacks
    // get prepended within previous callbacks
    const currentCallbacks = callbacks.slice();
    for (let index = 0; index < currentCallbacks.length; ++index) {
      const [, cb, priority] = currentCallbacks[index];
      if (!cb) {
        continue; // eslint-disable-line
      }

      if (priority < 0) {
        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
      } else {
        // Abort only if the callback explicitly returns false
        const continueNext = cb.apply(publicAPI, arguments);
        if (continueNext === EVENT_ABORT) {
          break;
        }
      }
    }
    /* eslint-enable prefer-rest-params */
  }

  publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
  publicAPI[`on${_capitalize(eventName)}`] = function (callback) {
    let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
    if (!callback.apply) {
      console.error(`Invalid callback for event ${eventName}`);
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    const callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
    return on(callbackID);
  };
  publicAPI.delete = () => {
    previousDelete();
    callbacks.forEach(_ref => {
      let [cbID] = _ref;
      return off(cbID);
    });
  };
}

// ----------------------------------------------------------------------------
// newInstance
// ----------------------------------------------------------------------------

function newInstance(extend, className) {
  const constructor = function () {
    let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const model = {};
    const publicAPI = {};
    extend(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };

  // Register constructor to factory
  if (className) {
    _vtk_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A.register(className, constructor);
  }
  return constructor;
}

// ----------------------------------------------------------------------------
// Chain function calls
// ----------------------------------------------------------------------------

function chain() {
  for (var _len6 = arguments.length, fn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    fn[_key6] = arguments[_key6];
  }
  return function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return fn.filter(i => !!i).map(i => i(...args));
  };
}

// ----------------------------------------------------------------------------
// Some utility methods for vtk objects
// ----------------------------------------------------------------------------

function isVtkObject(instance) {
  return instance && instance.isA && instance.isA('vtkObject');
}
function traverseInstanceTree(instance, extractFunction) {
  let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  let visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      // avoid cycles
      return accumulator;
    }
    visitedInstances.push(instance);
    const result = extractFunction(instance);
    if (result !== undefined) {
      accumulator.push(result);
    }

    // Now go through this instance's model
    const model = instance.get();
    Object.keys(model).forEach(key => {
      const modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach(subObj => {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}

// ----------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

function debounce(func, wait, immediate) {
  var _this = this;
  let timeout;
  const debounced = function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    const context = _this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = () => clearTimeout(timeout);
  return debounced;
}

// ----------------------------------------------------------------------------
// Creates a throttled function that only invokes `func` at most once per
// every `wait` milliseconds.

function throttle(callback, delay) {
  let isThrottled = false;
  let argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper(...argsToUse); // eslint-disable-line
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback(...args);
    setTimeout(next, delay);
  }
  return wrapper;
}

// ----------------------------------------------------------------------------
// keystore(publicAPI, model, initialKeystore)
//
//    - initialKeystore: Initial keystore. This can be either a Map or an
//      object.
//
// Generated API
//  setKey(key, value) : mixed (returns value)
//  getKey(key) : mixed
//  getAllKeys() : [mixed]
//  deleteKey(key) : Boolean
// ----------------------------------------------------------------------------

function keystore(publicAPI, model) {
  let initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = (key, value) => {
    model.keystore[key] = value;
  };
  publicAPI.getKey = key => model.keystore[key];
  publicAPI.getAllKeys = () => Object.keys(model.keystore);
  publicAPI.deleteKey = key => delete model.keystore[key];
  publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach(key => delete model.keystore[key]);
}

// ----------------------------------------------------------------------------
// proxy(publicAPI, model, sectionName, propertyUI)
//
//    - sectionName: Name of the section for UI
//    - propertyUI: List of props with their UI description
//
// Generated API
//  getProxyId() : String
//  listProxyProperties() : [string]
//  updateProxyProperty(name, prop)
//  getProxySection() => List of properties for UI generation
// ----------------------------------------------------------------------------
let nextProxyId = 1;
const ROOT_GROUP_NAME = '__root__';
function proxy(publicAPI, model) {
  // Proxies are keystores
  keystore(publicAPI, model);
  const parentDelete = publicAPI.delete;

  // getProxyId
  model.proxyId = `${nextProxyId++}`;

  // ui handling
  model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy
  get(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);
  setGet(publicAPI, model, ['proxyManager']);

  // group properties
  const propertyMap = {};
  const groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    const childrenNames = groupChildrenNames[currentGroupName];
    for (let i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = ui => {
    model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy
    Object.keys(propertyMap).forEach(k => delete propertyMap[k]);
    Object.keys(groupChildrenNames).forEach(k => delete groupChildrenNames[k]);
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    let gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = (propertyName, propUI) => {
    const prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = {
        ...propUI
      };
    }
  };
  publicAPI.activate = () => {
    if (model.proxyManager) {
      const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };

  // property link
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = type => {
    const subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function (id) {
    let persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    let value = null;
    const links = [];
    let count = 0;
    let updateInProgress = false;
    function update(source) {
      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      const needUpdate = [];
      let sourceLink = null;
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          const linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set({
            [linkToUpdate.propertyName]: value
          });
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      const indexToDelete = [];
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind(instance, propertyName) {
      let updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const subscription = instance.onModified(update);
      const other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {
          instance.set({
            [propertyName]: model.propertyLinkMap[id].value
          });
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: () => unbind(instance, propertyName)
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    const linkHandler = {
      bind,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };

  // extract values
  function getProperties() {
    let groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    const values = [];
    const id = model.proxyId;
    const propertyNames = listProxyProperties(groupName) || [];
    for (let i = 0; i < propertyNames.length; i++) {
      const name = propertyNames[i];
      const method = publicAPI[`get${_capitalize(name)}`];
      const value = method ? method() : undefined;
      const prop = {
        id,
        name,
        value
      };
      const children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = () => getProperties().map(p => p.name);
  publicAPI.getPropertyByName = name => getProperties().find(p => p.name === name);
  publicAPI.getPropertyDomainByName = name => (propertyMap[name] || {}).domain;

  // ui section
  publicAPI.getProxySection = () => ({
    id: model.proxyId,
    name: model.proxyGroup,
    ui: model.ui,
    properties: getProperties()
  });

  // free resources
  publicAPI.delete = () => {
    const list = Object.keys(model.propertyLinkMap);
    let count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };

  // @todo fix infinite recursion due to active source
  publicAPI.getState = () => null;
  function registerLinks() {
    // Allow dynamic registration of links at the application level
    if (model.links) {
      for (let i = 0; i < model.links.length; i++) {
        const {
          link,
          property,
          persistent,
          updateOnBind,
          type
        } = model.links[i];
        if (type === 'application') {
          const sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, 'application');
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}

// ----------------------------------------------------------------------------
// proxyPropertyMapping(publicAPI, model, map)
//
//   map = {
//      opacity: { modelKey: 'property', property: 'opacity' },
//   }
//
// Generated API:
//  Elevate set/get methods from internal object stored in the model to current one
// ----------------------------------------------------------------------------

function proxyPropertyMapping(publicAPI, model, map) {
  const parentDelete = publicAPI.delete;
  const subscriptions = [];
  const propertyNames = Object.keys(map);
  let count = propertyNames.length;
  while (count--) {
    const propertyName = propertyNames[count];
    const {
      modelKey,
      property,
      modified = true
    } = map[propertyName];
    const methodSrc = _capitalize(property);
    const methodDst = _capitalize(propertyName);
    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}

// ----------------------------------------------------------------------------
// proxyPropertyState(publicAPI, model, state, defaults)
//
//   state = {
//     representation: {
//       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },
//       Surface: { property: { edgeVisibility: false, representation: 2 } },
//       Wireframe: { property: { edgeVisibility: false, representation: 1 } },
//       Points: { property: { edgeVisibility: false, representation: 0 } },
//     },
//   }
//
//   defaults = {
//      representation: 'Surface',
//   }
//
// Generated API
//   get / set Representation ( string ) => push state to various internal objects
// ----------------------------------------------------------------------------

function proxyPropertyState(publicAPI, model) {
  let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    const modelKeys = Object.keys(map);
    let count = modelKeys.length;
    while (count--) {
      const modelKey = modelKeys[count];
      model[modelKey].set(map[modelKey]);
    }
  }
  const modelKeys = Object.keys(defaults);
  let count = modelKeys.length;
  while (count--) {
    // Add default
    const key = modelKeys[count];
    model[key] = defaults[key];

    // Add set method
    const mapping = state[key];
    publicAPI[`set${_capitalize(key)}`] = value => {
      if (value !== model[key]) {
        model[key] = value;
        const propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  }

  // Add getter
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}

// ----------------------------------------------------------------------------
// From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
//
//
// Copyright (c) 2015, Facebook, Inc.
// All rights reserved.
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree. An additional grant
// of patent rights can be found in the PATENTS file in the same directory.
//
//
// Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
// complicated, thus this doc is long and (hopefully) detailed enough to answer
// your questions.
//
// If you need to react to the mouse wheel in a predictable way, this code is
// like your bestest friend.// hugs//
//
// As of today, there are 4 DOM event types you can listen to:
//
//   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
//   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
//   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
//   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
//
// So what to do?  The is the best:
//
//   normalizeWheel.getEventType();
//
// In your event callback, use this code to get sane interpretation of the
// deltas.  This code will return an object with properties:
//
//   spinX   -- normalized spin speed (use for zoom) - x plane
//   spinY   -- " - y plane
//   pixelX  -- normalized distance (to pixels) - x plane
//   pixelY  -- " - y plane
//
// Wheel values are provided by the browser assuming you are using the wheel to
// scroll a web page by a number of lines or pixels (or pages).  Values can vary
// significantly on different platforms and browsers, forgetting that you can
// scroll at different speeds.  Some devices (like trackpads) emit more events
// at smaller increments with fine granularity, and some emit massive jumps with
// linear speed or acceleration.
//
// This code does its best to normalize the deltas for you:
//
//   - spin is trying to normalize how far the wheel was spun (or trackpad
//     dragged).  This is super useful for zoom support where you want to
//     throw away the chunky scroll steps on the PC and make those equal to
//     the slow and smooth tiny steps on the Mac. Key data: This code tries to
//     resolve a single slow step on a wheel to 1.
//
//   - pixel is normalizing the desired scroll delta in pixel units.  You'll
//     get the crazy differences between browsers, but at least it'll be in
//     pixels!
//
//   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
//     should translate to positive value zooming IN, negative zooming OUT.
//     This matches the newer 'wheel' event.
//
// Why are there spinX, spinY (or pixels)?
//
//   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
//     with a mouse.  It results in side-scrolling in the browser by default.
//
//   - spinY is what you expect -- it's the classic axis of a mouse wheel.
//
//   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
//     probably is by browsers in conjunction with fancy 3D controllers .. but
//     you know.
//
// Implementation info:
//
// Examples of 'wheel' event if you scroll slowly (down) by one step with an
// average mouse:
//
//   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
//   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
//   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
//   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
//   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
//
// On the trackpad:
//
//   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
//   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
//
// On other/older browsers.. it's more complicated as there can be multiple and
// also missing delta values.
//
// The 'wheel' event is more standard:
//
// http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
//
// The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
// deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
// backward compatibility with older events.  Those other values help us
// better normalize spin speed.  Example of what the browsers provide:
//
//                          | event.wheelDelta | event.detail
//        ------------------+------------------+--------------
//          Safari v5/OS X  |       -120       |       0
//          Safari v5/Win7  |       -120       |       0
//         Chrome v17/OS X  |       -120       |       0
//         Chrome v17/Win7  |       -120       |       0
//                IE9/Win7  |       -120       |   undefined
//         Firefox v4/OS X  |     undefined    |       1
//         Firefox v4/Win7  |     undefined    |       3
//
// ----------------------------------------------------------------------------

// Reasonable defaults
const PIXEL_STEP = 10;
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  let sX = 0; // spinX
  let sY = 0; // spinY
  let pX = 0; // pixelX
  let pY = 0; // pixelY

  // Legacy
  if ('detail' in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ('wheelDelta' in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ('wheelDeltaY' in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ('deltaY' in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ('deltaX' in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY || sX,
    pixelX: pX,
    pixelY: pY || pX
  };
}

// ----------------------------------------------------------------------------
// Default export
// ----------------------------------------------------------------------------

var macro = {
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  measurePromiseExecution,
  moveToProtected,
  newInstance,
  newTypedArray,
  newTypedArrayFrom,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  // deprecated todo remove on breaking API revision
  uncapitalize,
  VOID,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro,
  // vtk.js internal use
  objectSetterMap
};

var macro$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  VOID: VOID,
  setLoggerFunction: setLoggerFunction,
  vtkLogMacro: vtkLogMacro,
  vtkInfoMacro: vtkInfoMacro,
  vtkDebugMacro: vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro,
  vtkWarningMacro: vtkWarningMacro,
  vtkOnceErrorMacro: vtkOnceErrorMacro,
  TYPED_ARRAYS: TYPED_ARRAYS,
  newTypedArray: newTypedArray,
  newTypedArrayFrom: newTypedArrayFrom,
  capitalize: capitalize,
  _capitalize: _capitalize,
  uncapitalize: uncapitalize,
  formatBytesToProperUnit: formatBytesToProperUnit,
  formatNumbersWithThousandSeparator: formatNumbersWithThousandSeparator,
  setImmediateVTK: setImmediateVTK,
  measurePromiseExecution: measurePromiseExecution,
  obj: obj,
  get: get,
  set: set,
  setGet: setGet,
  getArray: getArray,
  setArray: setArray,
  setGetArray: setGetArray,
  moveToProtected: moveToProtected,
  algo: algo,
  EVENT_ABORT: EVENT_ABORT,
  event: event,
  newInstance: newInstance,
  chain: chain,
  isVtkObject: isVtkObject,
  traverseInstanceTree: traverseInstanceTree,
  debounce: debounce,
  throttle: throttle,
  keystore: keystore,
  proxy: proxy,
  proxyPropertyMapping: proxyPropertyMapping,
  proxyPropertyState: proxyPropertyState,
  normalizeWheel: normalizeWheel,
  'default': macro
});




/***/ }),

/***/ 42852:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ vtk),
/* harmony export */   n: () => (/* binding */ vtkGlobal)
/* harmony export */ });
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5744);
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(globalthis__WEBPACK_IMPORTED_MODULE_0__);


const vtkGlobal = globalthis__WEBPACK_IMPORTED_MODULE_0___default()(); // returns native globalThis if compliant

const factoryMapping = {
  vtkObject: () => null
};
function vtk(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (obj.isA) {
    return obj;
  }
  if (!obj.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error('Invalid VTK object');
    }
    return null;
  }
  const constructor = factoryMapping[obj.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error(`No vtk class found for Object of type ${obj.vtkClass}`);
    }
    return null;
  }

  // Shallow copy object
  const model = {
    ...obj
  };

  // Convert into vtkObject any nested key
  Object.keys(model).forEach(keyName => {
    if (model[keyName] && typeof model[keyName] === 'object' && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });

  // Return the root
  const newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}

// Nest register method under the vtk function
vtk.register = register;




/***/ }),

/***/ 45043:
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 24457:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_TYPE: () => (/* binding */ ARRAY_TYPE),
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   setMatrixArrayType: () => (/* binding */ setMatrixArrayType),
/* harmony export */   toRadian: () => (/* binding */ toRadian)
/* harmony export */ });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ 3823:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Fd: () => (/* reexport */ common),
  w0: () => (/* reexport */ mat3),
  pB: () => (/* reexport */ mat4),
  Yu: () => (/* reexport */ quat),
  Zc: () => (/* reexport */ vec2_namespaceObject),
  eR: () => (/* reexport */ vec3),
  ln: () => (/* reexport */ vec4)
});

// UNUSED EXPORTS: mat2, mat2d, quat2

// NAMESPACE OBJECT: ../../../node_modules/gl-matrix/esm/vec2.js
var vec2_namespaceObject = {};
__webpack_require__.r(vec2_namespaceObject);
__webpack_require__.d(vec2_namespaceObject, {
  add: () => (add),
  angle: () => (angle),
  ceil: () => (ceil),
  clone: () => (clone),
  copy: () => (copy),
  create: () => (create),
  cross: () => (cross),
  dist: () => (dist),
  distance: () => (distance),
  div: () => (div),
  divide: () => (divide),
  dot: () => (dot),
  equals: () => (equals),
  exactEquals: () => (exactEquals),
  floor: () => (floor),
  forEach: () => (forEach),
  fromValues: () => (fromValues),
  inverse: () => (inverse),
  len: () => (len),
  length: () => (vec2_length),
  lerp: () => (lerp),
  max: () => (max),
  min: () => (min),
  mul: () => (mul),
  multiply: () => (multiply),
  negate: () => (negate),
  normalize: () => (normalize),
  random: () => (random),
  rotate: () => (rotate),
  round: () => (round),
  scale: () => (scale),
  scaleAndAdd: () => (scaleAndAdd),
  set: () => (set),
  sqrDist: () => (sqrDist),
  sqrLen: () => (sqrLen),
  squaredDistance: () => (squaredDistance),
  squaredLength: () => (squaredLength),
  str: () => (str),
  sub: () => (sub),
  subtract: () => (subtract),
  transformMat2: () => (transformMat2),
  transformMat2d: () => (transformMat2d),
  transformMat3: () => (transformMat3),
  transformMat4: () => (transformMat4),
  zero: () => (zero)
});

// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/common.js
var common = __webpack_require__(24457);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat2.js
var mat2 = __webpack_require__(98232);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat2d.js
var mat2d = __webpack_require__(72918);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat3.js
var mat3 = __webpack_require__(32591);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/mat4.js
var mat4 = __webpack_require__(28910);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/quat.js
var quat = __webpack_require__(50095);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/quat2.js
var quat2 = __webpack_require__(16953);
;// CONCATENATED MODULE: ../../../node_modules/gl-matrix/esm/vec2.js

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new common.ARRAY_TYPE(2);

  if (common.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new common.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new common.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function vec2_length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = common.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= common.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= common.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = vec2_length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/vec3.js
var vec3 = __webpack_require__(9175);
// EXTERNAL MODULE: ../../../node_modules/gl-matrix/esm/vec4.js
var vec4 = __webpack_require__(15958);
;// CONCATENATED MODULE: ../../../node_modules/gl-matrix/esm/index.js












/***/ }),

/***/ 32591:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   adjoint: () => (/* binding */ adjoint),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   frob: () => (/* binding */ frob),
/* harmony export */   fromMat2d: () => (/* binding */ fromMat2d),
/* harmony export */   fromMat4: () => (/* binding */ fromMat4),
/* harmony export */   fromQuat: () => (/* binding */ fromQuat),
/* harmony export */   fromRotation: () => (/* binding */ fromRotation),
/* harmony export */   fromScaling: () => (/* binding */ fromScaling),
/* harmony export */   fromTranslation: () => (/* binding */ fromTranslation),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   multiplyScalar: () => (/* binding */ multiplyScalar),
/* harmony export */   multiplyScalarAndAdd: () => (/* binding */ multiplyScalarAndAdd),
/* harmony export */   normalFromMat4: () => (/* binding */ normalFromMat4),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   translate: () => (/* binding */ translate),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ 50095:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   calculateW: () => (/* binding */ calculateW),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   conjugate: () => (/* binding */ conjugate),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   fromEuler: () => (/* binding */ fromEuler),
/* harmony export */   fromMat3: () => (/* binding */ fromMat3),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   getAngle: () => (/* binding */ getAngle),
/* harmony export */   getAxisAngle: () => (/* binding */ getAxisAngle),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   ln: () => (/* binding */ ln),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   rotateX: () => (/* binding */ rotateX),
/* harmony export */   rotateY: () => (/* binding */ rotateY),
/* harmony export */   rotateZ: () => (/* binding */ rotateZ),
/* harmony export */   rotationTo: () => (/* binding */ rotationTo),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setAxes: () => (/* binding */ setAxes),
/* harmony export */   setAxisAngle: () => (/* binding */ setAxisAngle),
/* harmony export */   slerp: () => (/* binding */ slerp),
/* harmony export */   sqlerp: () => (/* binding */ sqlerp),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32591);
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9175);
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15958);




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.create();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__.dot(a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__.len(tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ 15958:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   cross: () => (/* binding */ cross),
/* harmony export */   dist: () => (/* binding */ dist),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   div: () => (/* binding */ div),
/* harmony export */   divide: () => (/* binding */ divide),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   exactEquals: () => (/* binding */ exactEquals),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   fromValues: () => (/* binding */ fromValues),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   len: () => (/* binding */ len),
/* harmony export */   length: () => (/* binding */ length),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   mul: () => (/* binding */ mul),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   negate: () => (/* binding */ negate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleAndAdd: () => (/* binding */ scaleAndAdd),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   sqrDist: () => (/* binding */ sqrDist),
/* harmony export */   sqrLen: () => (/* binding */ sqrLen),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredLength: () => (/* binding */ squaredLength),
/* harmony export */   str: () => (/* binding */ str),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   subtract: () => (/* binding */ subtract),
/* harmony export */   transformMat4: () => (/* binding */ transformMat4),
/* harmony export */   transformQuat: () => (/* binding */ transformQuat),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24457);

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ 93008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 4367:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    var _loggersByName = {};
    var defaultLogger = null;

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods() {
        /*jshint validthis:true */
        var level = this.getLevel();

        // Replace the actual methods.
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, this.name);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;

        // Return any important warnings.
        if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
        }
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, _level, _loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, factory) {
      // Private instance variables.
      var self = this;
      /**
       * The level inherited from a parent logger (or a global default). We
       * cache this here rather than delegating to the parent so that it stays
       * in sync with the actual logging methods that we have installed (the
       * parent could change levels but we might not have rebuilt the loggers
       * in this child yet).
       * @type {number}
       */
      var inheritedLevel;
      /**
       * The default level for this logger, if any. If set, this overrides
       * `inheritedLevel`.
       * @type {number|null}
       */
      var defaultLevel;
      /**
       * A user-specific level for this logger. If set, this overrides
       * `defaultLevel`.
       * @type {number|null}
       */
      var userLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var cookieName = encodeURIComponent(storageKey);
                  var location = cookie.indexOf(cookieName + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(
                          cookie.slice(location + cookieName.length + 1)
                      )[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              return level;
          } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
      };

      self.setLevel = function (level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {  // defaults to true
              persistLevelIfPossible(userLevel);
          }

          // NOTE: in v2, this should call rebuild(), which updates children.
          return replaceLoggingMethods.call(self);
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self);
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      self.rebuild = function () {
          if (defaultLogger !== self) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self);

          if (defaultLogger === self) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
          }
      };

      // Initialize all the internal levels.
      inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
      );
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self);
    }

    /*
     *
     * Top-level API
     *
     */

    defaultLogger = new Logger();

    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
            logger = _loggersByName[name] = new Logger(
                name,
                defaultLogger.methodFactory
            );
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ 56037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(89738);

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(81327);

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(21897);

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(49329);

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(95967);

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(68415);

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(17663);

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ 10989:
/***/ ((module) => {

(function (factory) {
    if (true) {
        // Node/CommonJS
        module.exports = factory();
    } else { var glob; }
}(function (undefined) {

    'use strict';

    /*
     * Fastest md5 implementation around (JKM md5).
     * Credits: Joseph Myers
     *
     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
     * @see http://jsperf.com/md5-shootout/7
     */

    /* this function is much faster,
      so if possible we use it. Some IEs
      are the only ones I know of that
      need the idiotic second function,
      generated by an if clause.  */
    var add32 = function (a, b) {
        return (a + b) & 0xFFFFFFFF;
    },
        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


    function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32((a << s) | (a >>> (32 - s)), b);
    }

    function md5cycle(x, k) {
        var a = x[0],
            b = x[1],
            c = x[2],
            d = x[3];

        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a  = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d  = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c  = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b  = (b << 22 | b >>> 10) + c | 0;

        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a  = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d  = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c  = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b  = (b << 20 | b >>> 12) + c | 0;

        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a  = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d  = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c  = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b  = (b << 23 | b >>> 9) + c | 0;

        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b  = (b << 21 |b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a  = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d  = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c  = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b  = (b << 21 | b >>> 11) + c | 0;

        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
    }

    function md5blk(s) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }

    function md5blk_array(a) {
        var md5blks = [],
            i; /* Andy King said do it this way. */

        for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
    }

    function md51(s) {
        var n = s.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);
        return state;
    }

    function md51_array(a) {
        var n = a.length,
            state = [1732584193, -271733879, -1732584194, 271733878],
            i,
            length,
            tail,
            tmp,
            lo,
            hi;

        for (i = 64; i <= n; i += 64) {
            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }

        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
        // containing the last element of the parent array if the sub array specified starts
        // beyond the length of the parent array - weird.
        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= a[i] << ((i % 4) << 3);
        }

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Beware that the final length might not fit in 32 bits so we take care of that
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;

        md5cycle(state, tail);

        return state;
    }

    function rhex(n) {
        var s = '',
            j;
        for (j = 0; j < 4; j += 1) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }

    function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
            x[i] = rhex(x[i]);
        }
        return x.join('');
    }

    // In some cases the fast add32 function cannot be used..
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
        add32 = function (x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };
    }

    // ---------------------------------------------------

    /**
     * ArrayBuffer slice polyfill.
     *
     * @see https://github.com/ttaubert/node-arraybuffer-slice
     */

    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
        (function () {
            function clamp(val, length) {
                val = (val | 0) || 0;

                if (val < 0) {
                    return Math.max(val + length, 0);
                }

                return Math.min(val, length);
            }

            ArrayBuffer.prototype.slice = function (from, to) {
                var length = this.byteLength,
                    begin = clamp(from, length),
                    end = length,
                    num,
                    target,
                    targetArray,
                    sourceArray;

                if (to !== undefined) {
                    end = clamp(to, length);
                }

                if (begin > end) {
                    return new ArrayBuffer(0);
                }

                num = end - begin;
                target = new ArrayBuffer(num);
                targetArray = new Uint8Array(target);

                sourceArray = new Uint8Array(this, begin, num);
                targetArray.set(sourceArray);

                return target;
            };
        })();
    }

    // ---------------------------------------------------

    /**
     * Helpers.
     */

    function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
            str = unescape(encodeURIComponent(str));
        }

        return str;
    }

    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length,
           buff = new ArrayBuffer(length),
           arr = new Uint8Array(buff),
           i;

        for (i = 0; i < length; i += 1) {
            arr[i] = str.charCodeAt(i);
        }

        return returnUInt8Array ? arr : buff;
    }

    function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
    }

    function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);

        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);

        return returnUInt8Array ? result : result.buffer;
    }

    function hexToBinaryString(hex) {
        var bytes = [],
            length = hex.length,
            x;

        for (x = 0; x < length - 1; x += 2) {
            bytes.push(parseInt(hex.substr(x, 2), 16));
        }

        return String.fromCharCode.apply(String, bytes);
    }

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation.
     *
     * Use this class to perform an incremental md5, otherwise use the
     * static methods instead.
     */

    function SparkMD5() {
        // call reset to init the instance
        this.reset();
    }

    /**
     * Appends a string.
     * A conversion will be applied if an utf8 string is detected.
     *
     * @param {String} str The string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.append = function (str) {
        // Converts the string to utf8 bytes if necessary
        // Then append as binary
        this.appendBinary(toUtf8(str));

        return this;
    };

    /**
     * Appends a binary string.
     *
     * @param {String} contents The binary string to be appended
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.appendBinary = function (contents) {
        this._buff += contents;
        this._length += contents.length;

        var length = this._buff.length,
            i;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }

        this._buff = this._buff.substring(i - 64);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            i,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.reset = function () {
        this._buff = '';
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.prototype.getState = function () {
        return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
        };
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5} The instance itself
     */
    SparkMD5.prototype.setState = function (state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;

        return this;
    };

    /**
     * Releases memory used by the incremental buffer and other additional
     * resources. If you plan to use the instance again, use reset instead.
     */
    SparkMD5.prototype.destroy = function () {
        delete this._hash;
        delete this._buff;
        delete this._length;
    };

    /**
     * Finish the final calculation based on the tail.
     *
     * @param {Array}  tail   The tail (will be modified)
     * @param {Number} length The length of the remaining buffer
     */
    SparkMD5.prototype._finish = function (tail, length) {
        var i = length,
            tmp,
            lo,
            hi;

        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
                tail[i] = 0;
            }
        }

        // Do the final computation based on the tail and length
        // Beware that the final length may not fit in 32 bits so we take care of that
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;

        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
    };

    /**
     * Performs the md5 hash on a string.
     * A conversion will be applied if utf8 string is detected.
     *
     * @param {String}  str The string
     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hash = function (str, raw) {
        // Converts the string to utf8 bytes if necessary
        // Then compute it using the binary function
        return SparkMD5.hashBinary(toUtf8(str), raw);
    };

    /**
     * Performs the md5 hash on a binary string.
     *
     * @param {String}  content The binary string
     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.hashBinary = function (content, raw) {
        var hash = md51(content),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    // ---------------------------------------------------

    /**
     * SparkMD5 OOP implementation for array buffers.
     *
     * Use this class to perform an incremental md5 ONLY for array buffers.
     */
    SparkMD5.ArrayBuffer = function () {
        // call reset to init the instance
        this.reset();
    };

    /**
     * Appends an array buffer.
     *
     * @param {ArrayBuffer} arr The array to be appended
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
            length = buff.length,
            i;

        this._length += arr.byteLength;

        for (i = 64; i <= length; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }

        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

        return this;
    };

    /**
     * Finishes the incremental computation, reseting the internal state and
     * returning the result.
     *
     * @param {Boolean} raw True to get the raw string, false to get the hex string
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
        var buff = this._buff,
            length = buff.length,
            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            i,
            ret;

        for (i = 0; i < length; i += 1) {
            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
        }

        this._finish(tail, length);
        ret = hex(this._hash);

        if (raw) {
            ret = hexToBinaryString(ret);
        }

        this.reset();

        return ret;
    };

    /**
     * Resets the internal state of the computation.
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.reset = function () {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];

        return this;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @return {Object} The state
     */
    SparkMD5.ArrayBuffer.prototype.getState = function () {
        var state = SparkMD5.prototype.getState.call(this);

        // Convert buffer to a string
        state.buff = arrayBuffer2Utf8Str(state.buff);

        return state;
    };

    /**
     * Gets the internal state of the computation.
     *
     * @param {Object} state The state
     *
     * @return {SparkMD5.ArrayBuffer} The instance itself
     */
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
        // Convert string to buffer
        state.buff = utf8Str2ArrayBuffer(state.buff, true);

        return SparkMD5.prototype.setState.call(this, state);
    };

    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

    /**
     * Performs the md5 hash on an array buffer.
     *
     * @param {ArrayBuffer} arr The array buffer
     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
     *
     * @return {String} The result
     */
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
        var hash = md51_array(new Uint8Array(arr)),
            ret = hex(hash);

        return raw ? hexToBinaryString(ret) : ret;
    };

    return SparkMD5;
}));


/***/ }),

/***/ 14235:
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=184)}([function(e,t,r){"use strict";function n(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0}),n(r(240)),n(r(251)),n(r(175)),n(r(107)),n(r(29)),n(r(73)),n(r(106)),n(r(30)),n(r(252)),n(r(52)),n(r(97)),n(r(253)),n(r(37)),n(r(51)),n(r(173)),n(r(176)),n(r(172)),n(r(108)),n(r(254)),n(r(255)),n(r(256)),n(r(72)),n(r(177)),n(r(105)),n(r(17)),n(r(257)),n(r(12)),n(r(174))},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(212);t.FixedSizeSet=i.FixedSizeSet;var o=r(213);t.ObjectCache=o.ObjectCache;var a=r(214);t.CompareCache=a.CompareCache;var s=r(215);t.Lazy=s.Lazy;var u=r(216);function l(e,t,r){if(m(e))e.forEach((function(e,n){return t.call(r,n,e)}));else for(var n in e)e.hasOwnProperty(n)&&t.call(r,n,e[n])}function c(e){var t,r;if(h(e))return e;if(f(e)){var i=[];try{for(var o=n(e),a=o.next();!a.done;a=o.next()){var s=a.value;i.push(c(s))}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return i}if(p(e)){i={};for(var u in e)if(e.hasOwnProperty(u)){var l=e[u];i[u]=c(l)}return i}return e}function h(e){return!!e&&"[object Function]"===Object.prototype.toString.call(e)}function p(e){var t=typeof e;return!!e&&("function"===t||"object"===t)}function f(e){return Array.isArray(e)}function d(e){return e instanceof Set}function m(e){return e instanceof Map}function y(e){if(p(e)){var t=Object.getPrototypeOf(e),r=t.constructor;return t&&r&&"function"==typeof r&&r instanceof r&&Function.prototype.toString.call(r)===Function.prototype.toString.call(Object)}return!1}t.StringWalker=u.StringWalker,t.applyMixin=function(e,t){for(var r=[],n=2;n<arguments.length;n++)r[n-2]=arguments[n];Object.getOwnPropertyNames(t.prototype).forEach((function(n){if("constructor"!==n){if(-1!==r.indexOf(n)){var i=Object.getOwnPropertyDescriptor(e.prototype,n);i&&Object.defineProperty(e.prototype,"_"+n,i)}var o=Object.getOwnPropertyDescriptor(t.prototype,n);o&&Object.defineProperty(e.prototype,n,o)}}))},t.applyDefaults=function e(t,r,n){void 0===n&&(n=!1);var i=c(t||{});return l(r,(function(t,r){y(r)?i[t]=e(i[t],r,n):(n||void 0===i[t])&&(i[t]=r)})),i},t.forEachArray=function(e,t,r){e.forEach(t,r)},t.forEachObject=l,t.arrayLength=function(e){return d(e)?e.size:e.length},t.objectLength=function(e){return m(e)?e.size:Object.keys(e).length},t.getObjectValue=function(e,t){return m(e)?e.get(t):e[t]},t.removeObjectValue=function(e,t){m(e)?e.delete(t):delete e[t]},t.clone=c,t.isBoolean=function(e){return"boolean"==typeof e},t.isNumber=function(e){return"number"==typeof e},t.isString=function(e){return"string"==typeof e},t.isFunction=h,t.isObject=p,t.isArray=f,t.isSet=d,t.isMap=m,t.isEmpty=function(e){if(f(e))return!e.length;if(d(e))return!e.size;if(m(e))return!e.size;if(p(e)){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}return!1},t.isPlainObject=y,t.isIterable=function(e){return e&&"function"==typeof e[Symbol.iterator]},t.getValue=function(e){return h(e.valueOf)?e.valueOf():e},t.utf8Encode=function(e){for(var t=new Uint8Array(4*e.length),r=0,n=0;n<e.length;n++){var i=e.charCodeAt(n);if(i<128)t[r++]=i;else{if(i<2048)t[r++]=i>>6|192;else{if(i>55295&&i<56320){if(++n>=e.length)throw new Error("Incomplete surrogate pair.");var o=e.charCodeAt(n);if(o<56320||o>57343)throw new Error("Invalid surrogate character.");i=65536+((1023&i)<<10)+(1023&o),t[r++]=i>>18|240,t[r++]=i>>12&63|128}else t[r++]=i>>12|224;t[r++]=i>>6&63|128}t[r++]=63&i|128}}return t.subarray(0,r)},t.utf8Decode=function(e){for(var t="",r=0;r<e.length;){var n=e[r++];if(n>127)if(n>191&&n<224){if(r>=e.length)throw new Error("Incomplete 2-byte sequence.");n=(31&n)<<6|63&e[r++]}else if(n>223&&n<240){if(r+1>=e.length)throw new Error("Incomplete 3-byte sequence.");n=(15&n)<<12|(63&e[r++])<<6|63&e[r++]}else{if(!(n>239&&n<248))throw new Error("Unknown multi-byte start.");if(r+2>=e.length)throw new Error("Incomplete 4-byte sequence.");n=(7&n)<<18|(63&e[r++])<<12|(63&e[r++])<<6|63&e[r++]}if(n<=65535)t+=String.fromCharCode(n);else{if(!(n<=1114111))throw new Error("Code point exceeds UTF-16 limit.");n-=65536,t+=String.fromCharCode(n>>10|55296),t+=String.fromCharCode(1023&n|56320)}}return t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.Before=0]="Before",e[e.Equal=1]="Equal",e[e.After=2]="After"}(t.BoundaryPosition||(t.BoundaryPosition={})),function(e){e[e.None=0]="None",e[e.Capturing=1]="Capturing",e[e.AtTarget=2]="AtTarget",e[e.Bubbling=3]="Bubbling"}(t.EventPhase||(t.EventPhase={})),function(e){e[e.Element=1]="Element",e[e.Attribute=2]="Attribute",e[e.Text=3]="Text",e[e.CData=4]="CData",e[e.EntityReference=5]="EntityReference",e[e.Entity=6]="Entity",e[e.ProcessingInstruction=7]="ProcessingInstruction",e[e.Comment=8]="Comment",e[e.Document=9]="Document",e[e.DocumentType=10]="DocumentType",e[e.DocumentFragment=11]="DocumentFragment",e[e.Notation=12]="Notation"}(t.NodeType||(t.NodeType={})),function(e){e[e.Disconnected=1]="Disconnected",e[e.Preceding=2]="Preceding",e[e.Following=4]="Following",e[e.Contains=8]="Contains",e[e.ContainedBy=16]="ContainedBy",e[e.ImplementationSpecific=32]="ImplementationSpecific"}(t.Position||(t.Position={})),function(e){e[e.Accept=1]="Accept",e[e.Reject=2]="Reject",e[e.Skip=3]="Skip"}(t.FilterResult||(t.FilterResult={})),function(e){e[e.All=4294967295]="All",e[e.Element=1]="Element",e[e.Attribute=2]="Attribute",e[e.Text=4]="Text",e[e.CDataSection=8]="CDataSection",e[e.EntityReference=16]="EntityReference",e[e.Entity=32]="Entity",e[e.ProcessingInstruction=64]="ProcessingInstruction",e[e.Comment=128]="Comment",e[e.Document=256]="Document",e[e.DocumentType=512]="DocumentType",e[e.DocumentFragment=1024]="DocumentFragment",e[e.Notation=2048]="Notation"}(t.WhatToShow||(t.WhatToShow={})),function(e){e[e.StartToStart=0]="StartToStart",e[e.StartToEnd=1]="StartToEnd",e[e.EndToEnd=2]="EndToEnd",e[e.EndToStart=3]="EndToStart"}(t.HowToCompare||(t.HowToCompare={}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(241);t.Cast=n.Cast;var i=r(150);t.Guard=i.Guard;var o=r(242);t.EmptySet=o.EmptySet},function(e,t,r){var n=r(11),i=r(55).f,o=r(21),a=r(25),s=r(80),u=r(119),l=r(123);e.exports=function(e,t){var r,c,h,p,f,d=e.target,m=e.global,y=e.stat;if(r=m?n:y?n[d]||s(d,{}):(n[d]||{}).prototype)for(c in t){if(p=t[c],h=e.noTargetGet?(f=i(r,c))&&f.value:r[c],!l(m?c:d+(y?".":"#")+c,e.forced)&&void 0!==h){if(typeof p==typeof h)continue;u(p,h)}(e.sham||h&&h.sham)&&o(p,"sham",!0),a(r,c,p,e)}}},function(e,t,r){var n=r(11),i=r(81),o=r(14),a=r(58),s=r(86),u=r(124),l=i("wks"),c=n.Symbol,h=u?c:c&&c.withoutSetter||a;e.exports=function(e){return o(l,e)||(s&&o(c,e)?l[e]=c[e]:l[e]=h("Symbol."+e)),l[e]}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(29),o=function(){function e(){this._features={mutationObservers:!0,customElements:!0,slots:!0,steps:!0},this._window=null,this._compareCache=new n.CompareCache,this._rangeList=new n.FixedSizeSet}return e.prototype.setFeatures=function(e){if(void 0===e&&(e=!0),n.isObject(e))for(var t in e)this._features[t]=e[t]||!1;else for(var t in this._features)this._features[t]=e},Object.defineProperty(e.prototype,"features",{get:function(){return this._features},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"window",{get:function(){return null===this._window&&(this._window=i.create_window()),this._window},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"compareCache",{get:function(){return this._compareCache},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"rangeList",{get:function(){return this._rangeList},enumerable:!0,configurable:!0}),Object.defineProperty(e,"instance",{get:function(){return e._instance||(e._instance=new e),e._instance},enumerable:!0,configurable:!0}),e}();t.dom=o.instance},function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});var i=n(r(228));t.base64=i;var o=n(r(146));t.byte=o;var a=n(r(147));t.byteSequence=a;var s=n(r(96));t.codePoint=s;var u=n(r(232));t.json=u;var l=n(r(233));t.list=l;var c=n(r(234));t.map=c;var h=n(r(235));t.namespace=h;var p=n(r(236));t.queue=p;var f=n(r(237));t.set=f;var d=n(r(238));t.stack=d;var m=n(r(239));t.string=m},function(e,t){e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(t,r){void 0===r&&(r="");var n=e.call(this,r)||this;return n.name=t,n}return i(t,e),t}(Error);t.DOMException=o;var a=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"DOMStringSizeError",t)||this}return i(t,e),t}(o);t.DOMStringSizeError=a;var s=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"WrongDocumentError","The object is in the wrong document. "+t)||this}return i(t,e),t}(o);t.WrongDocumentError=s;var u=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NoDataAllowedError",t)||this}return i(t,e),t}(o);t.NoDataAllowedError=u;var l=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NoModificationAllowedError","The object can not be modified. "+t)||this}return i(t,e),t}(o);t.NoModificationAllowedError=l;var c=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NotSupportedError","The operation is not supported. "+t)||this}return i(t,e),t}(o);t.NotSupportedError=c;var h=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InUseAttributeError",t)||this}return i(t,e),t}(o);t.InUseAttributeError=h;var p=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InvalidStateError","The object is in an invalid state. "+t)||this}return i(t,e),t}(o);t.InvalidStateError=p;var f=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InvalidModificationError","The object can not be modified in this way. "+t)||this}return i(t,e),t}(o);t.InvalidModificationError=f;var d=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NamespaceError","The operation is not allowed by Namespaces in XML. [XMLNS] "+t)||this}return i(t,e),t}(o);t.NamespaceError=d;var m=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InvalidAccessError","The object does not support the operation or argument. "+t)||this}return i(t,e),t}(o);t.InvalidAccessError=m;var y=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"ValidationError",t)||this}return i(t,e),t}(o);t.ValidationError=y;var v=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"TypeMismatchError",t)||this}return i(t,e),t}(o);t.TypeMismatchError=v;var _=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"SecurityError","The operation is insecure. "+t)||this}return i(t,e),t}(o);t.SecurityError=_;var g=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NetworkError","A network error occurred. "+t)||this}return i(t,e),t}(o);t.NetworkError=g;var b=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"AbortError","The operation was aborted. "+t)||this}return i(t,e),t}(o);t.AbortError=b;var x=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"URLMismatchError","The given URL does not match another URL. "+t)||this}return i(t,e),t}(o);t.URLMismatchError=x;var w=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"QuotaExceededError","The quota has been exceeded. "+t)||this}return i(t,e),t}(o);t.QuotaExceededError=w;var E=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"TimeoutError","The operation timed out. "+t)||this}return i(t,e),t}(o);t.TimeoutError=E;var D=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InvalidNodeTypeError","The supplied node is incorrect or has an incorrect ancestor for this operation. "+t)||this}return i(t,e),t}(o);t.InvalidNodeTypeError=D;var S=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"DataCloneError","The object can not be cloned. "+t)||this}return i(t,e),t}(o);t.DataCloneError=S;var C=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NotImplementedError","The DOM method is not implemented by this module. "+t)||this}return i(t,e),t}(o);t.NotImplementedError=C;var A=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"HierarchyRequestError","The operation would yield an incorrect node tree. "+t)||this}return i(t,e),t}(o);t.HierarchyRequestError=A;var N=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"NotFoundError","The object can not be found here. "+t)||this}return i(t,e),t}(o);t.NotFoundError=N;var T=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"IndexSizeError","The index is not in the allowed range. "+t)||this}return i(t,e),t}(o);t.IndexSizeError=T;var O=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"SyntaxError","The string did not match the expected pattern. "+t)||this}return i(t,e),t}(o);t.SyntaxError=O;var F=function(e){function t(t){return void 0===t&&(t=""),e.call(this,"InvalidCharacterError","The string contains invalid characters. "+t)||this}return i(t,e),t}(o);t.InvalidCharacterError=F},function(e,t,r){"use strict";var n=r(53),i=["kind","resolve","construct","instanceOf","predicate","represent","defaultStyle","styleAliases"],o=["scalar","sequence","mapping"];e.exports=function(e,t){var r,a;if(t=t||{},Object.keys(t).forEach((function(t){if(-1===i.indexOf(t))throw new n('Unknown option "'+t+'" is met in definition of "'+e+'" YAML type.')})),this.tag=e,this.kind=t.kind||null,this.resolve=t.resolve||function(){return!0},this.construct=t.construct||function(e){return e},this.instanceOf=t.instanceOf||null,this.predicate=t.predicate||null,this.represent=t.represent||null,this.defaultStyle=t.defaultStyle||null,this.styleAliases=(r=t.styleAliases||null,a={},null!==r&&Object.keys(r).forEach((function(e){r[e].forEach((function(t){a[String(t)]=e}))})),a),-1===o.indexOf(this.kind))throw new n('Unknown kind "'+this.kind+'" is specified for "'+e+'" YAML type.')}},function(e,t,r){(function(t){var r=function(e){return e&&e.Math==Math&&e};e.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof t&&t)||Function("return this")()}).call(this,r(78))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.idl_defineConst=function(e,t,r){Object.defineProperty(e,t,{writable:!1,enumerable:!0,configurable:!1,value:r})}},function(e,t){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},function(e,t){var r={}.hasOwnProperty;e.exports=function(e,t){return r.call(e,t)}},function(e,t,r){var n=r(16),i=r(115),o=r(18),a=r(56),s=Object.defineProperty;t.f=n?s:function(e,t,r){if(o(e),t=a(t,!0),o(r),i)try{return s(e,t,r)}catch(e){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(e[t]=r.value),e}},function(e,t,r){var n=r(8);e.exports=!n((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(3),o=r(2);function a(e,t,r){if(void 0===r&&(r=!1),r&&i.Guard.isElementNode(t)&&i.Guard.isShadowRoot(t.shadowRoot)&&t.shadowRoot._firstChild)return t.shadowRoot._firstChild;if(t._firstChild)return t._firstChild;if(t===e)return null;if(t._nextSibling)return t._nextSibling;for(var n=t._parent;n&&n!==e;){if(n._nextSibling)return n._nextSibling;n=n._parent}return null}function s(){var e;return(e={})[Symbol.iterator]=function(){return{next:function(){return{done:!0,value:null}}}},e}function u(e,t,r,n){void 0===t&&(t=!1),void 0===r&&(r=!1);for(var i=t?e:a(e,e,r);i&&n&&!n(i);)i=a(e,i,r);return i}function l(e,t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=a(e,t,n);o&&i&&!i(o);)o=a(e,o,n);return o}function c(e,t,r,n){var i;return void 0===t&&(t=!1),void 0===r&&(r=!1),t||0!==e._children.size?((i={})[Symbol.iterator]=function(){var i=t?e:a(e,e,r);return{next:function(){for(;i&&n&&!n(i);)i=a(e,i,r);if(null===i)return{done:!0,value:null};var t={done:!1,value:i};return i=a(e,i,r),t}}},i):s()}function h(e,t,r){void 0===t&&(t=!1);for(var n=t?e:e._parent;n&&r&&!r(n);)n=n._parent;return n}function p(e,t,r,n){void 0===r&&(r=!1);for(var i=t._parent;i&&n&&!n(i);)i=i._parent;return i}function f(e){return i.Guard.isDocumentTypeNode(e)?0:i.Guard.isCharacterDataNode(e)?e._data.length:e._children.size}function d(e,t){if(void 0===t&&(t=!1),t){var r=d(e,!1);return i.Guard.isShadowRoot(r)?d(r._host,!0):r}return e._parent?d(e._parent):e}function m(e,t,r,n){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=r?e:n&&i.Guard.isShadowRoot(e)?e._host:e._parent;null!==o;){if(o===t)return!0;o=n&&i.Guard.isShadowRoot(o)?o._host:o._parent}return!1}function y(e){for(var t=d(e),r=0,n=u(t);null!==n;){if(r++,n===e)return r;n=l(t,n)}return-1}t.tree_getFirstDescendantNode=u,t.tree_getNextDescendantNode=l,t.tree_getDescendantNodes=c,t.tree_getDescendantElements=function(e,t,r,n){var o;return void 0===t&&(t=!1),void 0===r&&(r=!1),t||0!==e._children.size?((o={})[Symbol.iterator]=function(){var o=c(e,t,r,(function(e){return i.Guard.isElementNode(e)}))[Symbol.iterator](),a=o.next().value;return{next:function(){for(;a&&n&&!n(a);)a=o.next().value;if(null===a)return{done:!0,value:null};var e={done:!1,value:a};return a=o.next().value,e}}},o):s()},t.tree_getSiblingNodes=function(e,t,r){var n;return void 0===t&&(t=!1),e._parent&&0!==e._parent._children.size?((n={})[Symbol.iterator]=function(){var n=e._parent?e._parent._firstChild:null;return{next:function(){for(;n&&(r&&!r(n)||!t&&n===e);)n=n._nextSibling;if(null===n)return{done:!0,value:null};var i={done:!1,value:n};return n=n._nextSibling,i}}},n):s()},t.tree_getFirstAncestorNode=h,t.tree_getNextAncestorNode=p,t.tree_getAncestorNodes=function(e,t,r){var n;return void 0===t&&(t=!1),t||e._parent?((n={})[Symbol.iterator]=function(){var n=h(e,t,r);return{next:function(){if(null===n)return{done:!0,value:null};var e={done:!1,value:n};return n=p(0,n,t,r),e}}},n):s()},t.tree_getCommonAncestor=function(e,t){if(e===t)return e._parent;for(var r=[],n=[],i=h(e,!0);null!==i;)r.push(i),i=p(0,i,!0);for(var o=h(t,!0);null!==o;)n.push(o),o=p(0,o,!0);for(var a=r.length,s=n.length,u=null,l=Math.min(a,s);l>0;l--){var c=r[--a];if(c!==n[--s])break;u=c}return u},t.tree_getFollowingNode=function(e,t){if(t._firstChild)return t._firstChild;if(t._nextSibling)return t._nextSibling;for(;;){var r=t._parent;if(null===r||r===e)return null;if(r._nextSibling)return r._nextSibling;t=r}},t.tree_getPrecedingNode=function(e,t){return t===e?null:t._previousSibling?(t=t._previousSibling)._lastChild?t._lastChild:t:t._parent},t.tree_isConstrained=function e(t){var r,i,a,s,u,l;switch(t._nodeType){case o.NodeType.Document:var c=!1,h=!1;try{for(var p=n(t._children),f=p.next();!f.done;f=p.next()){switch(f.value._nodeType){case o.NodeType.ProcessingInstruction:case o.NodeType.Comment:break;case o.NodeType.DocumentType:if(c||h)return!1;c=!0;break;case o.NodeType.Element:if(h)return!1;h=!0;break;default:return!1}}}catch(e){r={error:e}}finally{try{f&&!f.done&&(i=p.return)&&i.call(p)}finally{if(r)throw r.error}}break;case o.NodeType.DocumentFragment:case o.NodeType.Element:try{for(var d=n(t._children),m=d.next();!m.done;m=d.next()){switch(m.value._nodeType){case o.NodeType.Element:case o.NodeType.Text:case o.NodeType.ProcessingInstruction:case o.NodeType.CData:case o.NodeType.Comment:break;default:return!1}}}catch(e){a={error:e}}finally{try{m&&!m.done&&(s=d.return)&&s.call(d)}finally{if(a)throw a.error}}break;case o.NodeType.DocumentType:case o.NodeType.Text:case o.NodeType.ProcessingInstruction:case o.NodeType.CData:case o.NodeType.Comment:return!t.hasChildNodes()}try{for(var y=n(t._children),v=y.next();!v.done;v=y.next()){if(!e(v.value))return!1}}catch(e){u={error:e}}finally{try{v&&!v.done&&(l=y.return)&&l.call(y)}finally{if(u)throw u.error}}return!0},t.tree_nodeLength=f,t.tree_isEmpty=function(e){return 0===f(e)},t.tree_rootNode=d,t.tree_isDescendantOf=function(e,t,r,n){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var i=u(e,r,n);null!==i;){if(i===t)return!0;i=l(e,i,r,n)}return!1},t.tree_isAncestorOf=m,t.tree_isHostIncludingAncestorOf=function e(t,r,n){if(void 0===n&&(n=!1),m(t,r,n))return!0;var o=d(t);return!(!i.Guard.isDocumentFragmentNode(o)||null===o._host||!e(o._host,r,n))},t.tree_isSiblingOf=function(e,t,r){return void 0===r&&(r=!1),e!==t?null!==e._parent&&e._parent===t._parent:!!r},t.tree_isPreceding=function(e,t){var r=y(e),n=y(t);return-1!==r&&-1!==n&&(d(e)===d(t)&&n<r)},t.tree_isFollowing=function(e,t){var r=y(e),n=y(t);return-1!==r&&-1!==n&&(d(e)===d(t)&&n>r)},t.tree_isParentOf=function(e,t){return e._parent===t},t.tree_isChildOf=function(e,t){return t._parent===e},t.tree_previousSibling=function(e){return e._previousSibling},t.tree_nextSibling=function(e){return e._nextSibling},t.tree_firstChild=function(e){return e._firstChild},t.tree_lastChild=function(e){return e._lastChild},t.tree_treePosition=y,t.tree_index=function(e){for(var t=0;null!==e._previousSibling;)t++,e=e._previousSibling;return t},t.tree_retarget=function(e,t){for(;;){if(!e||!i.Guard.isNode(e))return e;var r=d(e);if(!i.Guard.isShadowRoot(r))return e;if(t&&i.Guard.isNode(t)&&m(r,t,!0,!0))return e;e=r.host}}},function(e,t,r){var n=r(13);e.exports=function(e){if(!n(e))throw TypeError(String(e)+" is not an object");return e}},function(e,t,r){"use strict";var n=r(24),i=r(130),o=r(49),a=r(43),s=r(88),u=a.set,l=a.getterFor("Array Iterator");e.exports=s(Array,"Array",(function(e,t){u(this,{type:"Array Iterator",target:n(e),index:0,kind:t})}),(function(){var e=l(this),t=e.target,r=e.kind,n=e.index++;return!t||n>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:t[n],done:!1}:{value:[n,t[n]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},function(e,t,r){var n=r(90),i=r(25),o=r(202);n||i(Object.prototype,"toString",o,{unsafe:!0})},function(e,t,r){var n=r(16),i=r(15),o=r(40);e.exports=n?function(e,t,r){return i.f(e,t,o(1,r))}:function(e,t,r){return e[t]=r,e}},function(e,t,r){"use strict";var n=r(137).charAt,i=r(43),o=r(88),a=i.set,s=i.getterFor("String Iterator");o(String,"String",(function(e){a(this,{type:"String Iterator",string:String(e),index:0})}),(function(){var e,t=s(this),r=t.string,i=t.index;return i>=r.length?{value:void 0,done:!0}:(e=n(r,i),t.index+=e.length,{value:e,done:!1})}))},function(e,t,r){var n=r(11),i=r(203),o=r(19),a=r(21),s=r(5),u=s("iterator"),l=s("toStringTag"),c=o.values;for(var h in i){var p=n[h],f=p&&p.prototype;if(f){if(f[u]!==c)try{a(f,u,c)}catch(e){f[u]=c}if(f[l]||a(f,l,h),i[h])for(var d in o)if(f[d]!==o[d])try{a(f,d,o[d])}catch(e){f[d]=o[d]}}}},function(e,t,r){var n=r(41),i=r(35);e.exports=function(e){return n(i(e))}},function(e,t,r){var n=r(11),i=r(21),o=r(14),a=r(80),s=r(117),u=r(43),l=u.get,c=u.enforce,h=String(String).split("String");(e.exports=function(e,t,r,s){var u=!!s&&!!s.unsafe,l=!!s&&!!s.enumerable,p=!!s&&!!s.noTargetGet;"function"==typeof r&&("string"!=typeof t||o(r,"name")||i(r,"name",t),c(r).source=h.join("string"==typeof t?t:"")),e!==n?(u?!p&&e[t]&&(l=!0):delete e[t],l?e[t]=r:i(e,t,r)):l?e[t]=r:a(t,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&l(this).source||s(this)}))},function(e,t,r){var n=r(47),i=Math.min;e.exports=function(e){return e>0?i(n(e),9007199254740991):0}},function(e,t,r){var n=r(35);e.exports=function(e){return Object(n(e))}},function(e,t,r){var n=r(16),i=r(8),o=r(14),a=Object.defineProperty,s={},u=function(e){throw e};e.exports=function(e,t){if(o(s,e))return s[e];t||(t={});var r=[][e],l=!!o(t,"ACCESSORS")&&t.ACCESSORS,c=o(t,0)?t[0]:u,h=o(t,1)?t[1]:void 0;return s[e]=!!r&&!i((function(){if(l&&!n)return!0;var e={length:-1};l?a(e,1,{enumerable:!0,get:u}):e[1]=1,r.call(e,c,h)}))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(148),i=r(149),o=r(151),a=r(98),s=r(153),u=r(154),l=r(155),c=r(99),h=r(100),p=r(156),f=r(157),d=r(101),m=r(158),y=r(159),v=r(160),_=r(161),g=r(162),b=r(163),x=r(164),w=r(165),E=r(166),D=r(167),S=r(168),C=r(169),A=r(170);t.create_domImplementation=function(e){return n.DOMImplementationImpl._create(e)},t.create_window=function(){return i.WindowImpl._create()},t.create_xmlDocument=function(){return new o.XMLDocumentImpl},t.create_document=function(){return new a.DocumentImpl},t.create_abortController=function(){return new s.AbortControllerImpl},t.create_abortSignal=function(){return u.AbortSignalImpl._create()},t.create_documentType=function(e,t,r,n){return l.DocumentTypeImpl._create(e,t,r,n)},t.create_element=function(e,t,r,n){return c.ElementImpl._create(e,t,r,n)},t.create_htmlElement=function(e,t,r,n){return c.ElementImpl._create(e,t,r,n)},t.create_htmlUnknownElement=function(e,t,r,n){return c.ElementImpl._create(e,t,r,n)},t.create_documentFragment=function(e){return h.DocumentFragmentImpl._create(e)},t.create_shadowRoot=function(e,t){return p.ShadowRootImpl._create(e,t)},t.create_attr=function(e,t){return f.AttrImpl._create(e,t)},t.create_text=function(e,t){return d.TextImpl._create(e,t)},t.create_cdataSection=function(e,t){return m.CDATASectionImpl._create(e,t)},t.create_comment=function(e,t){return y.CommentImpl._create(e,t)},t.create_processingInstruction=function(e,t,r){return v.ProcessingInstructionImpl._create(e,t,r)},t.create_htmlCollection=function(e,t){return void 0===t&&(t=function(){return!0}),_.HTMLCollectionImpl._create(e,t)},t.create_nodeList=function(e){return g.NodeListImpl._create(e)},t.create_nodeListStatic=function(e,t){return b.NodeListStaticImpl._create(e,t)},t.create_namedNodeMap=function(e){return x.NamedNodeMapImpl._create(e)},t.create_range=function(e,t){return w.RangeImpl._create(e,t)},t.create_nodeIterator=function(e,t,r){return E.NodeIteratorImpl._create(e,t,r)},t.create_treeWalker=function(e,t){return D.TreeWalkerImpl._create(e,t)},t.create_nodeFilter=function(){return S.NodeFilterImpl._create()},t.create_mutationRecord=function(e,t,r,n,i,o,a,s,u){return C.MutationRecordImpl._create(e,t,r,n,i,o,a,s,u)},t.create_domTokenList=function(e,t){return A.DOMTokenListImpl._create(e,t)}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(17),a=r(3),s=r(72),u=new Map;function l(e,t){if(t!==e._root&&o.tree_isAncestorOf(e._reference,t,!0)){if(e._pointerBeforeReference)for(;;){var r=o.tree_getFollowingNode(e._root,t);if(null!==r&&o.tree_isDescendantOf(e._root,r,!0)&&!o.tree_isDescendantOf(t,r,!0))return void(e._reference=r);if(null===r)return void(e._pointerBeforeReference=!1)}if(null===t._previousSibling)null!==t._parent&&(e._reference=t._parent);else{for(var n=t._previousSibling,i=o.tree_getFirstDescendantNode(t._previousSibling,!0,!1);null!==i;)null!==i&&(n=i),i=o.tree_getNextDescendantNode(t._previousSibling,i,!0,!1);e._reference=n}}}function c(e,t,r,n,i){if(a.Guard.isSlot(e)&&"name"===t&&null===i){if(n===r)return;if(null===n&&""===r)return;if(""===n&&null===r)return;e._name=null===n||""===n?"":n,s.shadowTree_assignSlotablesForATree(o.tree_rootNode(e))}}function h(e,t,r,n,i){if(a.Guard.isSlotable(e)&&"slot"===t&&null===i){if(n===r)return;if(null===n&&""===r)return;if(""===n&&null===r)return;e._name=null===n||""===n?"":n,s.shadowTree_isAssigned(e)&&s.shadowTree_assignSlotables(e._assignedSlot),s.shadowTree_assignASlot(e)}}function p(e,t,r,n){"id"===t&&null===n&&(e._uniqueIdentifier=r||void 0)}t.dom_runRemovingSteps=function(e,t){},t.dom_runCloningSteps=function(e,t,r,n){},t.dom_runAdoptingSteps=function(e,t){},t.dom_runAttributeChangeSteps=function(e,t,r,o,a){var s,u;i.dom.features.slots&&(h.call(e,e,t,r,o,a),c.call(e,e,t,r,o,a)),p.call(e,e,t,o,a);try{for(var l=n(e._attributeChangeSteps),f=l.next();!f.done;f=l.next()){f.value.call(e,e,t,r,o,a)}}catch(e){s={error:e}}finally{try{f&&!f.done&&(u=l.return)&&u.call(l)}finally{if(s)throw s.error}}},t.dom_runInsertionSteps=function(e){},t.dom_runNodeIteratorPreRemovingSteps=function(e,t){l.call(e,e,t)},t.dom_hasSupportedTokens=function(e){return u.has(e)},t.dom_getSupportedTokens=function(e){return u.get(e)||new Set},t.dom_runEventConstructingSteps=function(e){},t.dom_runChildTextContentChangeSteps=function(e){}},function(e,t,r){"use strict";var n=r(4),i=r(11),o=r(46),a=r(44),s=r(16),u=r(86),l=r(124),c=r(8),h=r(14),p=r(59),f=r(13),d=r(18),m=r(27),y=r(24),v=r(56),_=r(40),g=r(60),b=r(61),x=r(82),w=r(190),E=r(85),D=r(55),S=r(15),C=r(79),A=r(21),N=r(25),T=r(81),O=r(57),F=r(45),k=r(58),P=r(5),I=r(125),L=r(126),M=r(62),B=r(43),j=r(36).forEach,R=O("hidden"),z=P("toPrimitive"),U=B.set,G=B.getterFor("Symbol"),X=Object.prototype,q=i.Symbol,W=o("JSON","stringify"),H=D.f,J=S.f,Y=w.f,V=C.f,K=T("symbols"),$=T("op-symbols"),Q=T("string-to-symbol-registry"),Z=T("symbol-to-string-registry"),ee=T("wks"),te=i.QObject,re=!te||!te.prototype||!te.prototype.findChild,ne=s&&c((function(){return 7!=g(J({},"a",{get:function(){return J(this,"a",{value:7}).a}})).a}))?function(e,t,r){var n=H(X,t);n&&delete X[t],J(e,t,r),n&&e!==X&&J(X,t,n)}:J,ie=function(e,t){var r=K[e]=g(q.prototype);return U(r,{type:"Symbol",tag:e,description:t}),s||(r.description=t),r},oe=l?function(e){return"symbol"==typeof e}:function(e){return Object(e)instanceof q},ae=function(e,t,r){e===X&&ae($,t,r),d(e);var n=v(t,!0);return d(r),h(K,n)?(r.enumerable?(h(e,R)&&e[R][n]&&(e[R][n]=!1),r=g(r,{enumerable:_(0,!1)})):(h(e,R)||J(e,R,_(1,{})),e[R][n]=!0),ne(e,n,r)):J(e,n,r)},se=function(e,t){d(e);var r=y(t),n=b(r).concat(he(r));return j(n,(function(t){s&&!ue.call(r,t)||ae(e,t,r[t])})),e},ue=function(e){var t=v(e,!0),r=V.call(this,t);return!(this===X&&h(K,t)&&!h($,t))&&(!(r||!h(this,t)||!h(K,t)||h(this,R)&&this[R][t])||r)},le=function(e,t){var r=y(e),n=v(t,!0);if(r!==X||!h(K,n)||h($,n)){var i=H(r,n);return!i||!h(K,n)||h(r,R)&&r[R][n]||(i.enumerable=!0),i}},ce=function(e){var t=Y(y(e)),r=[];return j(t,(function(e){h(K,e)||h(F,e)||r.push(e)})),r},he=function(e){var t=e===X,r=Y(t?$:y(e)),n=[];return j(r,(function(e){!h(K,e)||t&&!h(X,e)||n.push(K[e])})),n};(u||(N((q=function(){if(this instanceof q)throw TypeError("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,t=k(e),r=function(e){this===X&&r.call($,e),h(this,R)&&h(this[R],t)&&(this[R][t]=!1),ne(this,t,_(1,e))};return s&&re&&ne(X,t,{configurable:!0,set:r}),ie(t,e)}).prototype,"toString",(function(){return G(this).tag})),N(q,"withoutSetter",(function(e){return ie(k(e),e)})),C.f=ue,S.f=ae,D.f=le,x.f=w.f=ce,E.f=he,I.f=function(e){return ie(P(e),e)},s&&(J(q.prototype,"description",{configurable:!0,get:function(){return G(this).description}}),a||N(X,"propertyIsEnumerable",ue,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!u,sham:!u},{Symbol:q}),j(b(ee),(function(e){L(e)})),n({target:"Symbol",stat:!0,forced:!u},{for:function(e){var t=String(e);if(h(Q,t))return Q[t];var r=q(t);return Q[t]=r,Z[r]=t,r},keyFor:function(e){if(!oe(e))throw TypeError(e+" is not a symbol");if(h(Z,e))return Z[e]},useSetter:function(){re=!0},useSimple:function(){re=!1}}),n({target:"Object",stat:!0,forced:!u,sham:!s},{create:function(e,t){return void 0===t?g(e):se(g(e),t)},defineProperty:ae,defineProperties:se,getOwnPropertyDescriptor:le}),n({target:"Object",stat:!0,forced:!u},{getOwnPropertyNames:ce,getOwnPropertySymbols:he}),n({target:"Object",stat:!0,forced:c((function(){E.f(1)}))},{getOwnPropertySymbols:function(e){return E.f(m(e))}}),W)&&n({target:"JSON",stat:!0,forced:!u||c((function(){var e=q();return"[null]"!=W([e])||"{}"!=W({a:e})||"{}"!=W(Object(e))}))},{stringify:function(e,t,r){for(var n,i=[e],o=1;arguments.length>o;)i.push(arguments[o++]);if(n=t,(f(t)||void 0!==e)&&!oe(e))return p(t)||(t=function(e,t){if("function"==typeof n&&(t=n.call(this,e,t)),!oe(t))return t}),i[1]=t,W.apply(null,i)}});q.prototype[z]||A(q.prototype,z,q.prototype.valueOf),M(q,"Symbol"),F[R]=!0},function(e,t,r){"use strict";var n=r(4),i=r(16),o=r(11),a=r(14),s=r(13),u=r(15).f,l=r(119),c=o.Symbol;if(i&&"function"==typeof c&&(!("description"in c.prototype)||void 0!==c().description)){var h={},p=function(){var e=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),t=this instanceof p?new c(e):void 0===e?c():c(e);return""===e&&(h[t]=!0),t};l(p,c);var f=p.prototype=c.prototype;f.constructor=p;var d=f.toString,m="Symbol(test)"==String(c("test")),y=/^Symbol\((.*)\)[^)]+$/;u(f,"description",{configurable:!0,get:function(){var e=s(this)?this.valueOf():this,t=d.call(e);if(a(h,e))return"";var r=m?t.slice(7,-1):t.replace(y,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:p})}},function(e,t,r){r(126)("iterator")},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),s=r(2),u=r(70),l=r(3),c=r(9),h=r(0),p=r(152),f=r(12),d=function(e){function t(){var t=e.call(this)||this;return t._parent=null,t._firstChild=null,t._lastChild=null,t._previousSibling=null,t._nextSibling=null,t}return i(t,e),Object.defineProperty(t.prototype,"_childNodes",{get:function(){return this.__childNodes||(this.__childNodes=h.create_nodeList(this))},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_nodeDocument",{get:function(){return this._nodeDocumentOverride||a.dom.window._associatedDocument},set:function(e){this._nodeDocumentOverride=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_registeredObserverList",{get:function(){return this.__registeredObserverList||(this.__registeredObserverList=[])},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nodeType",{get:function(){return this._nodeType},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nodeName",{get:function(){return l.Guard.isElementNode(this)?this._htmlUppercasedQualifiedName:l.Guard.isAttrNode(this)?this._qualifiedName:l.Guard.isExclusiveTextNode(this)?"#text":l.Guard.isCDATASectionNode(this)?"#cdata-section":l.Guard.isProcessingInstructionNode(this)?this._target:l.Guard.isCommentNode(this)?"#comment":l.Guard.isDocumentNode(this)?"#document":l.Guard.isDocumentTypeNode(this)?this._name:l.Guard.isDocumentFragmentNode(this)?"#document-fragment":""},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"baseURI",{get:function(){return p.urlSerializer(this._nodeDocument._URL)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isConnected",{get:function(){return l.Guard.isElementNode(this)&&h.shadowTree_isConnected(this)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"ownerDocument",{get:function(){return this._nodeType===s.NodeType.Document?null:this._nodeDocument},enumerable:!0,configurable:!0}),t.prototype.getRootNode=function(e){return h.tree_rootNode(this,!!e&&e.composed)},Object.defineProperty(t.prototype,"parentNode",{get:function(){return this._nodeType===s.NodeType.Attribute?null:this._parent},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"parentElement",{get:function(){return this._parent&&l.Guard.isElementNode(this._parent)?this._parent:null},enumerable:!0,configurable:!0}),t.prototype.hasChildNodes=function(){return null!==this._firstChild},Object.defineProperty(t.prototype,"childNodes",{get:function(){return this._childNodes},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"firstChild",{get:function(){return this._firstChild},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"lastChild",{get:function(){return this._lastChild},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"previousSibling",{get:function(){return this._previousSibling},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nextSibling",{get:function(){return this._nextSibling},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nodeValue",{get:function(){return l.Guard.isAttrNode(this)?this._value:l.Guard.isCharacterDataNode(this)?this._data:null},set:function(e){null===e&&(e=""),l.Guard.isAttrNode(this)?h.attr_setAnExistingAttributeValue(this,e):l.Guard.isCharacterDataNode(this)&&h.characterData_replaceData(this,0,this._data.length,e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"textContent",{get:function(){return l.Guard.isDocumentFragmentNode(this)||l.Guard.isElementNode(this)?h.text_descendantTextContent(this):l.Guard.isAttrNode(this)?this._value:l.Guard.isCharacterDataNode(this)?this._data:null},set:function(e){null===e&&(e=""),l.Guard.isDocumentFragmentNode(this)||l.Guard.isElementNode(this)?h.node_stringReplaceAll(e,this):l.Guard.isAttrNode(this)?h.attr_setAnExistingAttributeValue(this,e):l.Guard.isCharacterDataNode(this)&&h.characterData_replaceData(this,0,h.tree_nodeLength(this),e)},enumerable:!0,configurable:!0}),t.prototype.normalize=function(){for(var e,t,r,n,i=[],s=h.tree_getFirstDescendantNode(this,!1,!1,(function(e){return l.Guard.isExclusiveTextNode(e)}));null!==s;)i.push(s),s=h.tree_getNextDescendantNode(this,s,!1,!1,(function(e){return l.Guard.isExclusiveTextNode(e)}));for(var u=0;u<i.length;u++){var c=i[u];if(null!==c._parent){var p=h.tree_nodeLength(c);if(0!==p){var f=[],d="";try{for(var m=(e=void 0,o(h.text_contiguousExclusiveTextNodes(c))),y=m.next();!y.done;y=m.next()){var v=y.value;f.push(v),d+=v._data}}catch(t){e={error:t}}finally{try{y&&!y.done&&(t=m.return)&&t.call(m)}finally{if(e)throw e.error}}if(h.characterData_replaceData(c,p,0,d),0!==a.dom.rangeList.size)for(var _=c._nextSibling;null!==_&&l.Guard.isExclusiveTextNode(_);){var g=_,b=h.tree_index(g);try{for(var x=(r=void 0,o(a.dom.rangeList)),w=x.next();!w.done;w=x.next()){var E=w.value;E._start[0]===g&&(E._start[0]=c,E._start[1]+=p),E._end[0]===g&&(E._end[0]=c,E._end[1]+=p),E._start[0]===g._parent&&E._start[1]===b&&(E._start[0]=c,E._start[1]=p),E._end[0]===g._parent&&E._end[1]===b&&(E._end[0]=c,E._end[1]=p)}}catch(e){r={error:e}}finally{try{w&&!w.done&&(n=x.return)&&n.call(x)}finally{if(r)throw r.error}}p+=h.tree_nodeLength(_),_=_._nextSibling}for(var D=0;D<f.length;D++){null!==(v=f[D])._parent&&h.mutation_remove(v,v._parent)}}else h.mutation_remove(c,c._parent)}}},t.prototype.cloneNode=function(e){if(void 0===e&&(e=!1),l.Guard.isShadowRoot(this))throw new c.NotSupportedError;return h.node_clone(this,null,e)},t.prototype.isEqualNode=function(e){return void 0===e&&(e=null),null!==e&&h.node_equals(this,e)},t.prototype.isSameNode=function(e){return void 0===e&&(e=null),this===e},t.prototype.compareDocumentPosition=function(e){if(e===this)return 0;var t=e,r=this,n=null,i=null;if(l.Guard.isAttrNode(t)&&(t=(n=t)._element),l.Guard.isAttrNode(r)&&(r=(i=r)._element,n&&t&&t===r))for(var o=0;o<r._attributeList.length;o++){var u=r._attributeList[o];if(h.node_equals(u,n))return s.Position.ImplementationSpecific|s.Position.Preceding;if(h.node_equals(u,i))return s.Position.ImplementationSpecific|s.Position.Following}return null===t||null===r||h.tree_rootNode(t)!==h.tree_rootNode(r)?s.Position.Disconnected|s.Position.ImplementationSpecific|(a.dom.compareCache.check(this,e)?s.Position.Preceding:s.Position.Following):!n&&h.tree_isAncestorOf(r,t)||i&&t===r?s.Position.Contains|s.Position.Preceding:!i&&h.tree_isDescendantOf(r,t)||n&&t===r?s.Position.ContainedBy|s.Position.Following:h.tree_isPreceding(r,t)?s.Position.Preceding:s.Position.Following},t.prototype.contains=function(e){return null!==e&&h.tree_isDescendantOf(this,e,!0)},t.prototype.lookupPrefix=function(e){return e?l.Guard.isElementNode(this)?h.node_locateANamespacePrefix(this,e):l.Guard.isDocumentNode(this)?null===this.documentElement?null:h.node_locateANamespacePrefix(this.documentElement,e):l.Guard.isDocumentTypeNode(this)||l.Guard.isDocumentFragmentNode(this)?null:l.Guard.isAttrNode(this)?null===this._element?null:h.node_locateANamespacePrefix(this._element,e):null!==this._parent&&l.Guard.isElementNode(this._parent)?h.node_locateANamespacePrefix(this._parent,e):null:null},t.prototype.lookupNamespaceURI=function(e){return h.node_locateANamespace(this,e||null)},t.prototype.isDefaultNamespace=function(e){return e||(e=null),h.node_locateANamespace(this,null)===e},t.prototype.insertBefore=function(e,t){return h.mutation_preInsert(e,this,t)},t.prototype.appendChild=function(e){return h.mutation_append(e,this)},t.prototype.replaceChild=function(e,t){return h.mutation_replace(t,e,this)},t.prototype.removeChild=function(e){return h.mutation_preRemove(e,this)},t.prototype._getTheParent=function(e){return l.Guard.isSlotable(this)&&h.shadowTree_isAssigned(this)?this._assignedSlot:this._parent},t.ELEMENT_NODE=1,t.ATTRIBUTE_NODE=2,t.TEXT_NODE=3,t.CDATA_SECTION_NODE=4,t.ENTITY_REFERENCE_NODE=5,t.ENTITY_NODE=6,t.PROCESSING_INSTRUCTION_NODE=7,t.COMMENT_NODE=8,t.DOCUMENT_NODE=9,t.DOCUMENT_TYPE_NODE=10,t.DOCUMENT_FRAGMENT_NODE=11,t.NOTATION_NODE=12,t.DOCUMENT_POSITION_DISCONNECTED=1,t.DOCUMENT_POSITION_PRECEDING=2,t.DOCUMENT_POSITION_FOLLOWING=4,t.DOCUMENT_POSITION_CONTAINS=8,t.DOCUMENT_POSITION_CONTAINED_BY=16,t.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC=32,t}(u.EventTargetImpl);t.NodeImpl=d,d.prototype._children=new l.EmptySet,f.idl_defineConst(d.prototype,"ELEMENT_NODE",1),f.idl_defineConst(d.prototype,"ATTRIBUTE_NODE",2),f.idl_defineConst(d.prototype,"TEXT_NODE",3),f.idl_defineConst(d.prototype,"CDATA_SECTION_NODE",4),f.idl_defineConst(d.prototype,"ENTITY_REFERENCE_NODE",5),f.idl_defineConst(d.prototype,"ENTITY_NODE",6),f.idl_defineConst(d.prototype,"PROCESSING_INSTRUCTION_NODE",7),f.idl_defineConst(d.prototype,"COMMENT_NODE",8),f.idl_defineConst(d.prototype,"DOCUMENT_NODE",9),f.idl_defineConst(d.prototype,"DOCUMENT_TYPE_NODE",10),f.idl_defineConst(d.prototype,"DOCUMENT_FRAGMENT_NODE",11),f.idl_defineConst(d.prototype,"NOTATION_NODE",12),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_DISCONNECTED",1),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_PRECEDING",2),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_FOLLOWING",4),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_CONTAINS",8),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_CONTAINED_BY",16),f.idl_defineConst(d.prototype,"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",32)},function(e,t){e.exports=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e}},function(e,t,r){var n=r(87),i=r(41),o=r(27),a=r(26),s=r(128),u=[].push,l=function(e){var t=1==e,r=2==e,l=3==e,c=4==e,h=6==e,p=5==e||h;return function(f,d,m,y){for(var v,_,g=o(f),b=i(g),x=n(d,m,3),w=a(b.length),E=0,D=y||s,S=t?D(f,w):r?D(f,0):void 0;w>E;E++)if((p||E in b)&&(_=x(v=b[E],E,g),e))if(t)S[E]=_;else if(_)switch(e){case 3:return!0;case 5:return v;case 6:return E;case 2:u.call(S,v)}else if(c)return!1;return h?-1:l||c?c:S}};e.exports={forEach:l(0),map:l(1),filter:l(2),some:l(3),every:l(4),find:l(5),findIndex:l(6)}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),s=r(9),u=r(2),l=r(3),c=r(1),h=r(7),p=r(73),f=r(17),d=r(172),m=r(72),y=r(51),v=r(30),_=r(106);function g(e,t,r){var i,o,a,l,c,h,p,d,m=t._nodeType,y=e._nodeType,v=r?r._nodeType:null;if(m!==u.NodeType.Document&&m!==u.NodeType.DocumentFragment&&m!==u.NodeType.Element)throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is "+t.nodeName+".");if(f.tree_isHostIncludingAncestorOf(t,e,!0))throw new s.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is "+e.nodeName+", parent node is "+t.nodeName+".");if(null!==r&&r._parent!==t)throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is "+r.nodeName+", parent node is "+t.nodeName+".");if(y!==u.NodeType.DocumentFragment&&y!==u.NodeType.DocumentType&&y!==u.NodeType.Element&&y!==u.NodeType.Text&&y!==u.NodeType.ProcessingInstruction&&y!==u.NodeType.CData&&y!==u.NodeType.Comment)throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is "+e.nodeName+".");if(y===u.NodeType.Text&&m===u.NodeType.Document)throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is "+e.nodeName+".");if(y===u.NodeType.DocumentType&&m!==u.NodeType.Document)throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is "+t.nodeName+".");if(m===u.NodeType.Document)if(y===u.NodeType.DocumentFragment){var _=0;try{for(var g=n(e._children),b=g.next();!b.done;b=g.next()){var x=b.value;if(x._nodeType===u.NodeType.Element)_++;else if(x._nodeType===u.NodeType.Text)throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is "+x.nodeName+".")}}catch(e){i={error:e}}finally{try{b&&!b.done&&(o=g.return)&&o.call(g)}finally{if(i)throw i.error}}if(_>1)throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has "+_+" element nodes.");if(1===_){try{for(var w=n(t._children),E=w.next();!E.done;E=w.next()){if(E.value._nodeType===u.NodeType.Element)throw new s.HierarchyRequestError("The document node already has a document element node.")}}catch(e){a={error:e}}finally{try{E&&!E.done&&(l=w.return)&&l.call(w)}finally{if(a)throw a.error}}if(r){if(v===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");for(var D=r._nextSibling;D;){if(D._nodeType===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");D=D._nextSibling}}}}else if(y===u.NodeType.Element){try{for(var S=n(t._children),C=S.next();!C.done;C=S.next()){if(C.value._nodeType===u.NodeType.Element)throw new s.HierarchyRequestError("Document already has a document element node. Node is "+e.nodeName+".")}}catch(e){c={error:e}}finally{try{C&&!C.done&&(h=S.return)&&h.call(S)}finally{if(c)throw c.error}}if(r){if(v===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is "+e.nodeName+".");for(D=r._nextSibling;D;){if(D._nodeType===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is "+e.nodeName+".");D=D._nextSibling}}}else if(y===u.NodeType.DocumentType){try{for(var A=n(t._children),N=A.next();!N.done;N=A.next()){if(N.value._nodeType===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Document already has a document type node. Node is "+e.nodeName+".")}}catch(e){p={error:e}}finally{try{N&&!N.done&&(d=A.return)&&d.call(A)}finally{if(p)throw p.error}}if(r)for(var T=r._previousSibling;T;){if(T._nodeType===u.NodeType.Element)throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is "+e.nodeName+".");T=T._previousSibling}else for(T=t._firstChild;T;){if(T._nodeType===u.NodeType.Element)throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is "+e.nodeName+".");T=T._nextSibling}}}function b(e,t,r){g(e,t,r);var n=r;return n===e&&(n=e._nextSibling),_.document_adopt(e,t._nodeDocument),x(e,t,n),e}function x(e,t,r,i){var s,d;if(null!==r||e._nodeType===u.NodeType.DocumentFragment){var _=e._nodeType===u.NodeType.DocumentFragment?e._children.size:1;if(null!==r&&0!==a.dom.rangeList.size){var g=f.tree_index(r);try{for(var b=n(a.dom.rangeList),x=b.next();!x.done;x=b.next()){var E=x.value;E._start[0]===t&&E._start[1]>g&&(E._start[1]+=_),E._end[0]===t&&E._end[1]>g&&(E._end[1]+=_)}}catch(e){s={error:e}}finally{try{x&&!x.done&&(d=b.return)&&d.call(b)}finally{if(s)throw s.error}}}var D=e._nodeType===u.NodeType.DocumentFragment?new(Array.bind.apply(Array,o([void 0],e._children))):[e];if(e._nodeType===u.NodeType.DocumentFragment)for(;e._firstChild;)w(e._firstChild,e,!0);a.dom.features.mutationObservers&&e._nodeType===u.NodeType.DocumentFragment&&y.observer_queueTreeMutationRecord(e,[],D,null,null);for(var S=r?r._previousSibling:t._lastChild,C=null===r?-1:f.tree_index(r),A=0;A<D.length;A++){var N=D[A];if(l.Guard.isElementNode(N)&&(l.Guard.isDocumentNode(t)&&(t._documentElement=N),N._nodeDocument._hasNamespaces||null===N._namespace&&null===N._namespacePrefix||(N._nodeDocument._hasNamespaces=!0)),N._parent=t,null===r?h.set.append(t._children,N):(h.set.insert(t._children,N,C),C++),null===t._firstChild)N._previousSibling=null,N._nextSibling=null,t._firstChild=N,t._lastChild=N;else{var T=r?r._previousSibling:t._lastChild,O=r||null;N._previousSibling=T,N._nextSibling=O,T&&(T._nextSibling=N),O&&(O._previousSibling=N),T||(t._firstChild=N),O||(t._lastChild=N)}a.dom.features.slots&&null!==t._shadowRoot&&l.Guard.isSlotable(N)&&m.shadowTree_assignASlot(N),a.dom.features.steps&&l.Guard.isTextNode(N)&&v.dom_runChildTextContentChangeSteps(t),a.dom.features.slots&&l.Guard.isShadowRoot(f.tree_rootNode(t))&&l.Guard.isSlot(t)&&c.isEmpty(t._assignedNodes)&&m.shadowTree_signalASlotChange(t),a.dom.features.slots&&m.shadowTree_assignSlotablesForATree(f.tree_rootNode(N));for(var F=f.tree_getFirstDescendantNode(N,!0,!0);null!==F;)a.dom.features.steps&&v.dom_runInsertionSteps(F),a.dom.features.customElements&&l.Guard.isElementNode(F)&&m.shadowTree_isConnected(F)&&(l.Guard.isCustomElementNode(F)?p.customElement_enqueueACustomElementCallbackReaction(F,"connectedCallback",[]):p.customElement_tryToUpgrade(F)),F=f.tree_getNextDescendantNode(N,F,!0,!0)}a.dom.features.mutationObservers&&(i||y.observer_queueTreeMutationRecord(t,D,[],S,r))}else!function(e,t,r){var n=t._lastChild;l.Guard.isElementNode(e)&&(l.Guard.isDocumentNode(t)&&(t._documentElement=e),e._nodeDocument._hasNamespaces||null===e._namespace&&null===e._namespacePrefix||(e._nodeDocument._hasNamespaces=!0));if(e._parent=t,t._children.add(e),null===t._firstChild)e._previousSibling=null,e._nextSibling=null,t._firstChild=e,t._lastChild=e;else{var i=t._lastChild;e._previousSibling=i,e._nextSibling=null,i&&(i._nextSibling=e),i||(t._firstChild=e),t._lastChild=e}a.dom.features.slots&&null!==t._shadowRoot&&l.Guard.isSlotable(e)&&m.shadowTree_assignASlot(e);a.dom.features.steps&&l.Guard.isTextNode(e)&&v.dom_runChildTextContentChangeSteps(t);a.dom.features.slots&&l.Guard.isShadowRoot(f.tree_rootNode(t))&&l.Guard.isSlot(t)&&c.isEmpty(t._assignedNodes)&&m.shadowTree_signalASlotChange(t);a.dom.features.slots&&m.shadowTree_assignSlotablesForATree(f.tree_rootNode(e));a.dom.features.steps&&v.dom_runInsertionSteps(e);a.dom.features.customElements&&l.Guard.isElementNode(e)&&m.shadowTree_isConnected(e)&&(l.Guard.isCustomElementNode(e)?p.customElement_enqueueACustomElementCallbackReaction(e,"connectedCallback",[]):p.customElement_tryToUpgrade(e));a.dom.features.mutationObservers&&(r||y.observer_queueTreeMutationRecord(t,[e],[],n,null))}(e,t,i)}function w(e,t,r){var i,o,s,u,h,_,g,b;if(0!==a.dom.rangeList.size){var x=f.tree_index(e);try{for(var w=n(a.dom.rangeList),E=w.next();!E.done;E=w.next()){var D=E.value;f.tree_isDescendantOf(e,D._start[0],!0)&&(D._start=[t,x]),f.tree_isDescendantOf(e,D._end[0],!0)&&(D._end=[t,x]),D._start[0]===t&&D._start[1]>x&&D._start[1]--,D._end[0]===t&&D._end[1]>x&&D._end[1]--}}catch(e){i={error:e}}finally{try{E&&!E.done&&(o=w.return)&&o.call(w)}finally{if(i)throw i.error}}try{for(var S=n(a.dom.rangeList),C=S.next();!C.done;C=S.next()){(D=C.value)._start[0]===t&&D._start[1]>x&&(D._start[1]-=1),D._end[0]===t&&D._end[1]>x&&(D._end[1]-=1)}}catch(e){s={error:e}}finally{try{C&&!C.done&&(u=S.return)&&u.call(S)}finally{if(s)throw s.error}}}if(a.dom.features.steps)try{for(var A=n(d.nodeIterator_iteratorList()),N=A.next();!N.done;N=A.next()){var T=N.value;T._root._nodeDocument===e._nodeDocument&&v.dom_runNodeIteratorPreRemovingSteps(T,e)}}catch(e){h={error:e}}finally{try{N&&!N.done&&(_=A.return)&&_.call(A)}finally{if(h)throw h.error}}var O=e._previousSibling,F=e._nextSibling;l.Guard.isDocumentNode(t)&&l.Guard.isElementNode(e)&&(t._documentElement=null),e._parent=null,t._children.delete(e);var k=e._previousSibling,P=e._nextSibling;(e._previousSibling=null,e._nextSibling=null,k&&(k._nextSibling=P),P&&(P._previousSibling=k),k||(t._firstChild=P),P||(t._lastChild=k),a.dom.features.slots&&l.Guard.isSlotable(e)&&null!==e._assignedSlot&&m.shadowTree_isAssigned(e)&&m.shadowTree_assignSlotables(e._assignedSlot),a.dom.features.slots&&l.Guard.isShadowRoot(f.tree_rootNode(t))&&l.Guard.isSlot(t)&&c.isEmpty(t._assignedNodes)&&m.shadowTree_signalASlotChange(t),a.dom.features.slots)&&(null!==f.tree_getFirstDescendantNode(e,!0,!1,(function(e){return l.Guard.isSlot(e)}))&&(m.shadowTree_assignSlotablesForATree(f.tree_rootNode(t)),m.shadowTree_assignSlotablesForATree(e)));a.dom.features.steps&&v.dom_runRemovingSteps(e,t),a.dom.features.customElements&&l.Guard.isCustomElementNode(e)&&p.customElement_enqueueACustomElementCallbackReaction(e,"disconnectedCallback",[]);for(var I=f.tree_getFirstDescendantNode(e,!1,!0);null!==I;)a.dom.features.steps&&v.dom_runRemovingSteps(I,e),a.dom.features.customElements&&l.Guard.isCustomElementNode(I)&&p.customElement_enqueueACustomElementCallbackReaction(I,"disconnectedCallback",[]),I=f.tree_getNextDescendantNode(e,I,!1,!0);if(a.dom.features.mutationObservers)for(var L=f.tree_getFirstAncestorNode(t,!0);null!==L;){try{for(var M=(g=void 0,n(L._registeredObserverList)),B=M.next();!B.done;B=M.next()){var j=B.value;j.options.subtree&&e._registeredObserverList.push({observer:j.observer,options:j.options,source:j})}}catch(e){g={error:e}}finally{try{B&&!B.done&&(b=M.return)&&b.call(M)}finally{if(g)throw g.error}}L=f.tree_getNextAncestorNode(t,L,!0)}a.dom.features.mutationObservers&&(r||y.observer_queueTreeMutationRecord(t,[],[e],O,F)),a.dom.features.steps&&l.Guard.isTextNode(e)&&v.dom_runChildTextContentChangeSteps(t)}t.mutation_ensurePreInsertionValidity=g,t.mutation_preInsert=b,t.mutation_insert=x,t.mutation_append=function(e,t){return b(e,t,null)},t.mutation_replace=function(e,t,r){var i,o,l,c,h,p,d,m;if(r._nodeType!==u.NodeType.Document&&r._nodeType!==u.NodeType.DocumentFragment&&r._nodeType!==u.NodeType.Element)throw new s.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is "+r.nodeName+".");if(f.tree_isHostIncludingAncestorOf(r,t,!0))throw new s.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is "+t.nodeName+", parent node is "+r.nodeName+".");if(e._parent!==r)throw new s.NotFoundError("The reference child node cannot be found under parent node. Child node is "+e.nodeName+", parent node is "+r.nodeName+".");if(t._nodeType!==u.NodeType.DocumentFragment&&t._nodeType!==u.NodeType.DocumentType&&t._nodeType!==u.NodeType.Element&&t._nodeType!==u.NodeType.Text&&t._nodeType!==u.NodeType.ProcessingInstruction&&t._nodeType!==u.NodeType.CData&&t._nodeType!==u.NodeType.Comment)throw new s.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is "+t.nodeName+".");if(t._nodeType===u.NodeType.Text&&r._nodeType===u.NodeType.Document)throw new s.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is "+t.nodeName+".");if(t._nodeType===u.NodeType.DocumentType&&r._nodeType!==u.NodeType.Document)throw new s.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is "+r.nodeName+".");if(r._nodeType===u.NodeType.Document)if(t._nodeType===u.NodeType.DocumentFragment){var v=0;try{for(var g=n(t._children),b=g.next();!b.done;b=g.next()){var E=b.value;if(E._nodeType===u.NodeType.Element)v++;else if(E._nodeType===u.NodeType.Text)throw new s.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is "+E.nodeName+".")}}catch(e){i={error:e}}finally{try{b&&!b.done&&(o=g.return)&&o.call(g)}finally{if(i)throw i.error}}if(v>1)throw new s.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has "+v+" element nodes.");if(1===v){try{for(var D=n(r._children),S=D.next();!S.done;S=D.next()){if((F=S.value)._nodeType===u.NodeType.Element&&F!==e)throw new s.HierarchyRequestError("The document node already has a document element node.")}}catch(e){l={error:e}}finally{try{S&&!S.done&&(c=D.return)&&c.call(D)}finally{if(l)throw l.error}}for(var C=e._nextSibling;C;){if(C._nodeType===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node.");C=C._nextSibling}}}else if(t._nodeType===u.NodeType.Element){try{for(var A=n(r._children),N=A.next();!N.done;N=A.next()){if((F=N.value)._nodeType===u.NodeType.Element&&F!==e)throw new s.HierarchyRequestError("Document already has a document element node. Node is "+t.nodeName+".")}}catch(e){h={error:e}}finally{try{N&&!N.done&&(p=A.return)&&p.call(A)}finally{if(h)throw h.error}}for(C=e._nextSibling;C;){if(C._nodeType===u.NodeType.DocumentType)throw new s.HierarchyRequestError("Cannot insert an element node before a document type node. Node is "+t.nodeName+".");C=C._nextSibling}}else if(t._nodeType===u.NodeType.DocumentType){try{for(var T=n(r._children),O=T.next();!O.done;O=T.next()){var F;if((F=O.value)._nodeType===u.NodeType.DocumentType&&F!==e)throw new s.HierarchyRequestError("Document already has a document type node. Node is "+t.nodeName+".")}}catch(e){d={error:e}}finally{try{O&&!O.done&&(m=T.return)&&m.call(T)}finally{if(d)throw d.error}}for(var k=e._previousSibling;k;){if(k._nodeType===u.NodeType.Element)throw new s.HierarchyRequestError("Cannot insert a document type node before an element node. Node is "+t.nodeName+".");k=k._previousSibling}}var P=e._nextSibling;P===t&&(P=t._nextSibling);var I=e._previousSibling;_.document_adopt(t,r._nodeDocument);var L=[];null!==e._parent&&(L.push(e),w(e,e._parent,!0));var M=[];return t._nodeType===u.NodeType.DocumentFragment?M=Array.from(t._children):M.push(t),x(t,r,P,!0),a.dom.features.mutationObservers&&y.observer_queueTreeMutationRecord(r,M,L,I,P),e},t.mutation_replaceAll=function(e,t){var r,i;null!==e&&_.document_adopt(e,t._nodeDocument);var o=Array.from(t._children),s=[];e&&e._nodeType===u.NodeType.DocumentFragment?s=Array.from(e._children):null!==e&&s.push(e);try{for(var l=n(o),c=l.next();!c.done;c=l.next()){w(c.value,t,!0)}}catch(e){r={error:e}}finally{try{c&&!c.done&&(i=l.return)&&i.call(l)}finally{if(r)throw r.error}}null!==e&&x(e,t,null,!0),a.dom.features.mutationObservers&&y.observer_queueTreeMutationRecord(t,s,o,null,null)},t.mutation_preRemove=function(e,t){if(e._parent!==t)throw new s.NotFoundError("The child node cannot be found under parent node. Child node is "+e.nodeName+", parent node is "+t.nodeName+".");return w(e,t),e},t.mutation_remove=w},function(e,t,r){"use strict";function n(e){return null==e}e.exports.isNothing=n,e.exports.isObject=function(e){return"object"==typeof e&&null!==e},e.exports.toArray=function(e){return Array.isArray(e)?e:n(e)?[]:[e]},e.exports.repeat=function(e,t){var r,n="";for(r=0;r<t;r+=1)n+=e;return n},e.exports.isNegativeZero=function(e){return 0===e&&Number.NEGATIVE_INFINITY===1/e},e.exports.extend=function(e,t){var r,n,i,o;if(t)for(r=0,n=(o=Object.keys(t)).length;r<n;r+=1)e[i=o[r]]=t[i];return e}},function(e,t,r){"use strict";var n=r(38),i=r(53),o=r(10);function a(e,t,r){var n=[];return e.include.forEach((function(e){r=a(e,t,r)})),e[t].forEach((function(e){r.forEach((function(t,r){t.tag===e.tag&&t.kind===e.kind&&n.push(r)})),r.push(e)})),r.filter((function(e,t){return-1===n.indexOf(t)}))}function s(e){this.include=e.include||[],this.implicit=e.implicit||[],this.explicit=e.explicit||[],this.implicit.forEach((function(e){if(e.loadKind&&"scalar"!==e.loadKind)throw new i("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.")})),this.compiledImplicit=a(this,"implicit",[]),this.compiledExplicit=a(this,"explicit",[]),this.compiledTypeMap=function(){var e,t,r={scalar:{},sequence:{},mapping:{},fallback:{}};function n(e){r[e.kind][e.tag]=r.fallback[e.tag]=e}for(e=0,t=arguments.length;e<t;e+=1)arguments[e].forEach(n);return r}(this.compiledImplicit,this.compiledExplicit)}s.DEFAULT=null,s.create=function(){var e,t;switch(arguments.length){case 1:e=s.DEFAULT,t=arguments[0];break;case 2:e=arguments[0],t=arguments[1];break;default:throw new i("Wrong number of arguments for Schema.create function")}if(e=n.toArray(e),t=n.toArray(t),!e.every((function(e){return e instanceof s})))throw new i("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");if(!t.every((function(e){return e instanceof o})))throw new i("Specified list of YAML types (or a single Type object) contains a non-Type object.");return new s({include:e,explicit:t})},e.exports=s},function(e,t){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},function(e,t,r){var n=r(8),i=r(42),o="".split;e.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(e){return"String"==i(e)?o.call(e,""):Object(e)}:Object},function(e,t){var r={}.toString;e.exports=function(e){return r.call(e).slice(8,-1)}},function(e,t,r){var n,i,o,a=r(186),s=r(11),u=r(13),l=r(21),c=r(14),h=r(57),p=r(45),f=s.WeakMap;if(a){var d=new f,m=d.get,y=d.has,v=d.set;n=function(e,t){return v.call(d,e,t),t},i=function(e){return m.call(d,e)||{}},o=function(e){return y.call(d,e)}}else{var _=h("state");p[_]=!0,n=function(e,t){return l(e,_,t),t},i=function(e){return c(e,_)?e[_]:{}},o=function(e){return c(e,_)}}e.exports={set:n,get:i,has:o,enforce:function(e){return o(e)?i(e):n(e,{})},getterFor:function(e){return function(t){var r;if(!u(t)||(r=i(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return r}}}},function(e,t){e.exports=!1},function(e,t){e.exports={}},function(e,t,r){var n=r(120),i=r(11),o=function(e){return"function"==typeof e?e:void 0};e.exports=function(e,t){return arguments.length<2?o(n[e])||o(i[e]):n[e]&&n[e][t]||i[e]&&i[e][t]}},function(e,t){var r=Math.ceil,n=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?n:r)(e)}},function(e,t,r){"use strict";var n=r(8);e.exports=function(e,t){var r=[][e];return!!r&&n((function(){r.call(null,t||function(){throw 1},1)}))}},function(e,t){e.exports={}},function(e,t,r){"use strict";r(31),r(32),r(33),r(220),r(64),r(19),r(65),r(20),r(68),r(66),r(92),r(144),r(22),r(94),r(23);var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(2),s=r(69),u=r(95),l=r(7),c=r(0),h=function(){function e(e){this.level=0,this._builderOptions=e}return e.prototype.declaration=function(e,t,r){},e.prototype.docType=function(e,t,r){},e.prototype.comment=function(e){},e.prototype.text=function(e){},e.prototype.instruction=function(e,t){},e.prototype.cdata=function(e){},e.prototype.openTagBegin=function(e){},e.prototype.openTagEnd=function(e,t,r){},e.prototype.closeTag=function(e){},e.prototype.attributes=function(e){var t,r;try{for(var i=n(e),o=i.next();!o.done;o=i.next()){var a=o.value;this.attribute(null===a[1]?a[2]:a[1]+":"+a[2],a[3])}}catch(e){t={error:e}}finally{try{o&&!o.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}},e.prototype.attribute=function(e,t){},e.prototype.beginElement=function(e){},e.prototype.endElement=function(e){},e.prototype.serializeNode=function(e,t){var r=void 0!==e._nodeDocument&&e._nodeDocument._hasNamespaces;if(this.level=0,this.currentNode=e,r){var n=new u.NamespacePrefixMap;n.set("xml",l.namespace.XML);this._serializeNodeNS(e,null,n,{value:1},t)}else this._serializeNode(e,t)},e.prototype._serializeNodeNS=function(e,t,r,n,i){switch(this.currentNode=e,e.nodeType){case a.NodeType.Element:this._serializeElementNS(e,t,r,n,i);break;case a.NodeType.Document:this._serializeDocumentNS(e,t,r,n,i);break;case a.NodeType.Comment:this._serializeComment(e,i);break;case a.NodeType.Text:this._serializeText(e,i);break;case a.NodeType.DocumentFragment:this._serializeDocumentFragmentNS(e,t,r,n,i);break;case a.NodeType.DocumentType:this._serializeDocumentType(e,i);break;case a.NodeType.ProcessingInstruction:this._serializeProcessingInstruction(e,i);break;case a.NodeType.CData:this._serializeCData(e,i);break;default:throw new Error("Unknown node type: "+e.nodeType)}},e.prototype._serializeNode=function(e,t){switch(this.currentNode=e,e.nodeType){case a.NodeType.Element:this._serializeElement(e,t);break;case a.NodeType.Document:this._serializeDocument(e,t);break;case a.NodeType.Comment:this._serializeComment(e,t);break;case a.NodeType.Text:this._serializeText(e,t);break;case a.NodeType.DocumentFragment:this._serializeDocumentFragment(e,t);break;case a.NodeType.DocumentType:this._serializeDocumentType(e,t);break;case a.NodeType.ProcessingInstruction:this._serializeProcessingInstruction(e,t);break;case a.NodeType.CData:this._serializeCData(e,t);break;default:throw new Error("Unknown node type: "+e.nodeType)}},e.prototype._serializeElementNS=function(t,r,i,a,s){var u,h,p=[];if(s&&(-1!==t.localName.indexOf(":")||!c.xml_isName(t.localName)))throw new Error("Node local name contains invalid characters (well-formed required).");var f="",d=!1,m=!1,y=i.copy(),v={},_=this._recordNamespaceInformation(t,y,v),g=r,b=t.namespaceURI;if(g===b)null!==_&&(m=!0),f=b===l.namespace.XML?"xml:"+t.localName:t.localName,this.beginElement(f),this.openTagBegin(f);else{var x=t.prefix,w=null;if(null===x&&b===_||(w=y.get(x,b)),"xmlns"===x){if(s)throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");w=x}null!==w?(f=w+":"+t.localName,null!==_&&_!==l.namespace.XML&&(g=_||null),this.beginElement(f),this.openTagBegin(f)):null!==x?(x in v&&(x=this._generatePrefix(b,y,a)),y.set(x,b),f+=x+":"+t.localName,this.beginElement(f),this.openTagBegin(f),p.push([null,"xmlns",x,this._serializeAttributeValue(b,s)]),null!==_&&(g=_||null)):null===_||null!==_&&_!==b?(m=!0,f+=t.localName,g=b,this.beginElement(f),this.openTagBegin(f),p.push([null,null,"xmlns",this._serializeAttributeValue(b,s)])):(f+=t.localName,g=b,this.beginElement(f),this.openTagBegin(f))}p.push.apply(p,o(this._serializeAttributesNS(t,y,a,v,m,s))),this.attributes(p);var E=b===l.namespace.HTML;if(E&&0===t.childNodes.length&&e._VoidElementNames.has(t.localName)?(this.openTagEnd(f,!0,!0),this.endElement(f),d=!0):E||0!==t.childNodes.length?this.openTagEnd(f,!1,!1):(this.openTagEnd(f,!0,!1),this.endElement(f),d=!0),!d){if(E&&"template"===t.localName);else try{for(var D=n(t.childNodes),S=D.next();!S.done;S=D.next()){var C=S.value;this.level++,this._serializeNodeNS(C,g,y,a,s),this.level--}}catch(e){u={error:e}}finally{try{S&&!S.done&&(h=D.return)&&h.call(D)}finally{if(u)throw u.error}}this.closeTag(f),this.endElement(f)}},e.prototype._serializeElement=function(e,t){var r,i;if(t&&(-1!==e.localName.indexOf(":")||!c.xml_isName(e.localName)))throw new Error("Node local name contains invalid characters (well-formed required).");var o=!1,a=e.localName;this.beginElement(a),this.openTagBegin(a);var s=this._serializeAttributes(e,t);if(this.attributes(s),e.hasChildNodes()?this.openTagEnd(a,!1,!1):(this.openTagEnd(a,!0,!1),this.endElement(a),o=!0),!o){try{for(var u=n(e._children),l=u.next();!l.done;l=u.next()){var h=l.value;this.level++,this._serializeNode(h,t),this.level--}}catch(e){r={error:e}}finally{try{l&&!l.done&&(i=u.return)&&i.call(u)}finally{if(r)throw r.error}}this.closeTag(a),this.endElement(a)}},e.prototype._serializeDocumentNS=function(e,t,r,i,o){var a,s;if(o&&null===e.documentElement)throw new Error("Missing document element (well-formed required).");try{for(var u=n(e.childNodes),l=u.next();!l.done;l=u.next()){var c=l.value;this._serializeNodeNS(c,t,r,i,o)}}catch(e){a={error:e}}finally{try{l&&!l.done&&(s=u.return)&&s.call(u)}finally{if(a)throw a.error}}},e.prototype._serializeDocument=function(e,t){var r,i;if(t&&null===e.documentElement)throw new Error("Missing document element (well-formed required).");try{for(var o=n(e._children),a=o.next();!a.done;a=o.next()){var s=a.value;this._serializeNode(s,t)}}catch(e){r={error:e}}finally{try{a&&!a.done&&(i=o.return)&&i.call(o)}finally{if(r)throw r.error}}},e.prototype._serializeComment=function(e,t){if(t&&(!c.xml_isLegalChar(e.data)||-1!==e.data.indexOf("--")||e.data.endsWith("-")))throw new Error("Comment data contains invalid characters (well-formed required).");this.comment(e.data)},e.prototype._serializeText=function(e,t){if(t&&!c.xml_isLegalChar(e.data))throw new Error("Text data contains invalid characters (well-formed required).");var r=e.data.replace(/(?!&([^&;]*);)&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");this.text(r)},e.prototype._serializeDocumentFragmentNS=function(e,t,r,i,o){var a,s;try{for(var u=n(e.childNodes),l=u.next();!l.done;l=u.next()){var c=l.value;this._serializeNodeNS(c,t,r,i,o)}}catch(e){a={error:e}}finally{try{l&&!l.done&&(s=u.return)&&s.call(u)}finally{if(a)throw a.error}}},e.prototype._serializeDocumentFragment=function(e,t){var r,i;try{for(var o=n(e._children),a=o.next();!a.done;a=o.next()){var s=a.value;this._serializeNode(s,t)}}catch(e){r={error:e}}finally{try{a&&!a.done&&(i=o.return)&&i.call(o)}finally{if(r)throw r.error}}},e.prototype._serializeDocumentType=function(e,t){if(t&&!c.xml_isPubidChar(e.publicId))throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");if(t&&(!c.xml_isLegalChar(e.systemId)||-1!==e.systemId.indexOf('"')&&-1!==e.systemId.indexOf("'")))throw new Error("DocType system identifier contains invalid characters (well-formed required).");this.docType(e.name,e.publicId,e.systemId)},e.prototype._serializeProcessingInstruction=function(e,t){if(t&&(-1!==e.target.indexOf(":")||/^xml$/i.test(e.target)))throw new Error("Processing instruction target contains invalid characters (well-formed required).");if(t&&(!c.xml_isLegalChar(e.data)||-1!==e.data.indexOf("?>")))throw new Error("Processing instruction data contains invalid characters (well-formed required).");this.instruction(e.target,e.data)},e.prototype._serializeCData=function(e,t){if(t&&-1!==e.data.indexOf("]]>"))throw new Error("CDATA contains invalid characters (well-formed required).");this.cdata(e.data)},e.prototype._serializeAttributesNS=function(e,t,r,i,o,a){var u,h,p=[],f=a?new s.LocalNameSet:void 0;try{for(var d=n(e.attributes),m=d.next();!m.done;m=d.next()){var y=m.value;if(a||o||null!==y.namespaceURI){if(a&&f&&f.has(y.namespaceURI,y.localName))throw new Error("Element contains duplicate attributes (well-formed required).");a&&f&&f.set(y.namespaceURI,y.localName);var v=y.namespaceURI,_=null;if(null!==v)if(_=t.get(y.prefix,v),v===l.namespace.XMLNS){if(y.value===l.namespace.XML||null===y.prefix&&o||null!==y.prefix&&(!(y.localName in i)||i[y.localName]!==y.value)&&t.has(y.localName,y.value))continue;if(a&&y.value===l.namespace.XMLNS)throw new Error("XMLNS namespace is reserved (well-formed required).");if(a&&""===y.value)throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");"xmlns"===y.prefix&&(_="xmlns")}else null===_&&(_=null===y.prefix||t.hasPrefix(y.prefix)&&!t.has(y.prefix,v)?this._generatePrefix(v,t,r):y.prefix,p.push([null,"xmlns",_,this._serializeAttributeValue(v,a)]));if(null!==_&&_,a&&(-1!==y.localName.indexOf(":")||!c.xml_isName(y.localName)||"xmlns"===y.localName&&null===v))throw new Error("Attribute local name contains invalid characters (well-formed required).");p.push([v,_,y.localName,this._serializeAttributeValue(y.value,a)])}else p.push([null,null,y.localName,this._serializeAttributeValue(y.value,a)])}}catch(e){u={error:e}}finally{try{m&&!m.done&&(h=d.return)&&h.call(d)}finally{if(u)throw u.error}}return p},e.prototype._serializeAttributes=function(e,t){var r,i,o=[],a=t?{}:void 0;try{for(var s=n(e.attributes),u=s.next();!u.done;u=s.next()){var l=u.value;if(t){if(t&&a&&l.localName in a)throw new Error("Element contains duplicate attributes (well-formed required).");if(t&&a&&(a[l.localName]=!0),t&&(-1!==l.localName.indexOf(":")||!c.xml_isName(l.localName)))throw new Error("Attribute local name contains invalid characters (well-formed required).");o.push([null,null,l.localName,this._serializeAttributeValue(l.value,t)])}else o.push([null,null,l.localName,this._serializeAttributeValue(l.value,t)])}}catch(e){r={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(r)throw r.error}}return o},e.prototype._recordNamespaceInformation=function(e,t,r){var i,o,a=null;try{for(var s=n(e.attributes),u=s.next();!u.done;u=s.next()){var c=u.value,h=c.namespaceURI,p=c.prefix;if(h===l.namespace.XMLNS){if(null===p){a=c.value;continue}var f=c.localName,d=c.value;if(d===l.namespace.XML)continue;if(""===d&&(d=null),t.has(f,d))continue;t.set(f,d),r[f]=d||""}}}catch(e){i={error:e}}finally{try{u&&!u.done&&(o=s.return)&&o.call(s)}finally{if(i)throw i.error}}return a},e.prototype._generatePrefix=function(e,t,r){var n="ns"+r.value.toString();return r.value++,t.set(n,e),n},e.prototype._serializeAttributeValue=function(e,t){if(t&&null!==e&&!c.xml_isLegalChar(e))throw new Error("Invalid characters in attribute value.");return null===e?"":e.replace(/(?!&([^&;]*);)&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},e._VoidElementNames=new Set(["area","base","basefont","bgsound","br","col","embed","frame","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"]),e}();t.BaseWriter=h},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var o=r(6),a=r(3),s=r(7),u=r(29),l=r(17),c=r(97);function h(){var e=o.dom.window;e._mutationObserverMicrotaskQueued||(e._mutationObserverMicrotaskQueued=!0,Promise.resolve().then((function(){p()})))}function p(){var e,t,r,i,u=o.dom.window;u._mutationObserverMicrotaskQueued=!1;var l=s.set.clone(u._mutationObservers),h=s.set.clone(u._signalSlots);s.set.empty(u._signalSlots);var p=function(e){var t=s.list.clone(e._recordQueue);s.list.empty(e._recordQueue);for(var r=0;r<e._nodeList.length;r++){var n=e._nodeList[r];s.list.remove(n._registeredObserverList,(function(t){return a.Guard.isTransientRegisteredObserver(t)&&t.observer===e}))}if(!s.list.isEmpty(t))try{e._callback.call(e,t,e)}catch(e){}};try{for(var f=n(l),d=f.next();!d.done;d=f.next()){p(d.value)}}catch(t){e={error:t}}finally{try{d&&!d.done&&(t=f.return)&&t.call(f)}finally{if(e)throw e.error}}if(o.dom.features.slots)try{for(var m=n(h),y=m.next();!y.done;y=m.next()){var v=y.value;c.event_fireAnEvent("slotchange",v,void 0,{bubbles:!0})}}catch(e){r={error:e}}finally{try{y&&!y.done&&(i=m.return)&&i.call(m)}finally{if(r)throw r.error}}}function f(e,t,r,o,a,s,c,p,f){for(var d,m,y=new Map,v=l.tree_getFirstAncestorNode(t,!0);null!==v;){for(var _=0;_<v._registeredObserverList.length;_++){var g=v._registeredObserverList[_],b=g.options;if((v===t||b.subtree)&&(("attributes"!==e||b.attributes)&&("attributes"!==e||!b.attributeFilter||b.attributeFilter.indexOf(r||"")&&null===o)&&("characterData"!==e||b.characterData)&&("childList"!==e||b.childList))){var x=g.observer;y.has(x)||y.set(x,null),("attributes"===e&&b.attributeOldValue||"characterData"===e&&b.characterDataOldValue)&&y.set(x,a)}}v=l.tree_getNextAncestorNode(t,v,!0)}try{for(var w=n(y),E=w.next();!E.done;E=w.next()){var D=i(E.value,2),S=D[0],C=D[1],A=u.create_mutationRecord(e,t,u.create_nodeListStatic(t,s),u.create_nodeListStatic(t,c),p,f,r,o,C);S._recordQueue.push(A)}}catch(e){d={error:e}}finally{try{E&&!E.done&&(m=w.return)&&m.call(w)}finally{if(d)throw d.error}}h()}t.observer_queueAMutationObserverMicrotask=h,t.observer_notifyMutationObservers=p,t.observer_queueMutationRecord=f,t.observer_queueTreeMutationRecord=function(e,t,r,n,i){f("childList",e,null,null,null,t,r,n,i)},t.observer_queueAttributeMutationRecord=function(e,t,r,n){f("attributes",e,t,r,n,[],[],null,null)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),i=r(7),o=r(3),a=r(9),s=r(29),u=r(73),l=r(51),c=r(30),h=r(37),p=r(106);function f(e,t,r){n.dom.features.mutationObservers&&l.observer_queueAttributeMutationRecord(t,e._localName,e._namespace,e._value),n.dom.features.customElements&&o.Guard.isCustomElementNode(t)&&u.customElement_enqueueACustomElementCallbackReaction(t,"attributeChangedCallback",[e._localName,e._value,r,e._namespace]),n.dom.features.steps&&c.dom_runAttributeChangeSteps(t,e._localName,e._value,r,e._namespace),e._value=r}function d(e,t){n.dom.features.mutationObservers&&l.observer_queueAttributeMutationRecord(t,e._localName,e._namespace,null),n.dom.features.customElements&&o.Guard.isCustomElementNode(t)&&u.customElement_enqueueACustomElementCallbackReaction(t,"attributeChangedCallback",[e._localName,null,e._value,e._namespace]),n.dom.features.steps&&c.dom_runAttributeChangeSteps(t,e._localName,null,e._value,e._namespace),t._attributeList._asArray().push(e),e._element=t,t._nodeDocument._hasNamespaces||null===e._namespace&&null===e._namespacePrefix&&"xmlns"!==e._localName||(t._nodeDocument._hasNamespaces=!0)}function m(e,t){n.dom.features.mutationObservers&&l.observer_queueAttributeMutationRecord(t,e._localName,e._namespace,e._value),n.dom.features.customElements&&o.Guard.isCustomElementNode(t)&&u.customElement_enqueueACustomElementCallbackReaction(t,"attributeChangedCallback",[e._localName,e._value,null,e._namespace]),n.dom.features.steps&&c.dom_runAttributeChangeSteps(t,e._localName,e._value,null,e._namespace);var r=t._attributeList._asArray().indexOf(e);t._attributeList._asArray().splice(r,1),e._element=null}function y(e,t,r){n.dom.features.mutationObservers&&l.observer_queueAttributeMutationRecord(r,e._localName,e._namespace,e._value),n.dom.features.customElements&&o.Guard.isCustomElementNode(r)&&u.customElement_enqueueACustomElementCallbackReaction(r,"attributeChangedCallback",[e._localName,e._value,t._value,e._namespace]),n.dom.features.steps&&c.dom_runAttributeChangeSteps(r,e._localName,e._value,t._value,e._namespace);var i=r._attributeList._asArray().indexOf(e);-1!==i&&(r._attributeList._asArray()[i]=t),e._element=null,t._element=r,r._nodeDocument._hasNamespaces||null===t._namespace&&null===t._namespacePrefix&&"xmlns"!==t._localName||(r._nodeDocument._hasNamespaces=!0)}function v(e,t){return t._namespace===i.namespace.HTML&&"html"===t._nodeDocument._type&&(e=e.toLowerCase()),t._attributeList._asArray().find((function(t){return t._qualifiedName===e}))||null}function _(e,t,r){var n=e||null;return r._attributeList._asArray().find((function(e){return e._namespace===n&&e._localName===t}))||null}t.element_has=function(e,t){return-1!==t._attributeList._asArray().indexOf(e)},t.element_change=f,t.element_append=d,t.element_remove=m,t.element_replace=y,t.element_getAnAttributeByName=v,t.element_getAnAttributeByNamespaceAndLocalName=_,t.element_getAnAttributeValue=function(e,t,r){void 0===r&&(r="");var n=_(r,t,e);return null===n?"":n._value},t.element_setAnAttribute=function(e,t){if(null!==e._element&&e._element!==t)throw new a.InUseAttributeError("This attribute already exists in the document: "+e._qualifiedName+" as a child of "+e._element._qualifiedName+".");var r=_(e._namespace||"",e._localName,t);return r===e?e:(null!==r?y(r,e,t):d(e,t),r)},t.element_setAnAttributeValue=function(e,t,r,n,i){void 0===n&&(n=null),void 0===i&&(i=null);var o=_(i||"",t,e);if(null===o){var a=s.create_attr(e._nodeDocument,t);return a._namespace=i,a._namespacePrefix=n,a._value=r,void d(a,e)}f(o,e,r)},t.element_removeAnAttributeByName=function(e,t){var r=v(e,t);return null!==r&&m(r,t),r},t.element_removeAnAttributeByNamespaceAndLocalName=function(e,t,r){var n=_(e,t,r);return null!==n&&m(n,r),n},t.element_createAnElement=function(e,t,r,o,l,c){void 0===o&&(o=null),void 0===l&&(l=null),void 0===c&&(c=!1);var h=null;if(!n.dom.features.customElements)return(h=s.create_element(e,t,r,o))._customElementState="uncustomized",h._customElementDefinition=null,h._is=l,h;var f=u.customElement_lookUpACustomElementDefinition(e,r,t,l);if(null!==f&&f.name!==f.localName)(h=new(p.document_elementInterface(t,i.namespace.HTML)))._localName=t,h._namespace=i.namespace.HTML,h._namespacePrefix=o,h._customElementState="undefined",h._customElementDefinition=null,h._is=l,h._nodeDocument=e,c?u.customElement_upgrade(f,h):u.customElement_enqueueACustomElementUpgradeReaction(h,f);else if(null!==f)if(c)try{var d=new(0,f.constructor);if(console.assert(void 0!==d._customElementState),console.assert(void 0!==d._customElementDefinition),console.assert(d._namespace===i.namespace.HTML),0!==d._attributeList.length)throw new a.NotSupportedError("Custom element already has attributes.");if(0!==d._children.size)throw new a.NotSupportedError("Custom element already has child nodes.");if(null!==d._parent)throw new a.NotSupportedError("Custom element already has a parent node.");if(d._nodeDocument!==e)throw new a.NotSupportedError("Custom element is already in a document.");if(d._localName!==t)throw new a.NotSupportedError("Custom element has a different local name.");d._namespacePrefix=o,d._is=null}catch(r){(h=s.create_htmlUnknownElement(e,t,i.namespace.HTML,o))._customElementState="failed",h._customElementDefinition=null,h._is=null}else(h=s.create_htmlElement(e,t,i.namespace.HTML,o))._customElementState="undefined",h._customElementDefinition=null,h._is=null,u.customElement_enqueueACustomElementUpgradeReaction(h,f);else{(h=new(p.document_elementInterface(t,r)))._localName=t,h._namespace=r,h._namespacePrefix=o,h._customElementState="uncustomized",h._customElementDefinition=null,h._is=l,h._nodeDocument=e,r!==i.namespace.HTML||null===l&&!u.customElement_isValidCustomElementName(t)||(h._customElementState="undefined")}if(null===h)throw new Error("Unable to create element.");return h},t.element_insertAdjacent=function(e,t,r){switch(t.toLowerCase()){case"beforebegin":return null===e._parent?null:h.mutation_preInsert(r,e._parent,e);case"afterbegin":return h.mutation_preInsert(r,e,e._firstChild);case"beforeend":return h.mutation_preInsert(r,e,null);case"afterend":return null===e._parent?null:h.mutation_preInsert(r,e._parent,e._nextSibling);default:throw new a.SyntaxError('Invalid \'where\' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected')}}},function(e,t,r){"use strict";function n(e,t){Error.call(this),this.name="YAMLException",this.reason=e,this.mark=t,this.message=(this.reason||"(unknown reason)")+(this.mark?" "+this.mark.toString():""),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack||""}n.prototype=Object.create(Error.prototype),n.prototype.constructor=n,n.prototype.toString=function(e){var t=this.name+": ";return t+=this.reason||"(unknown reason)",!e&&this.mark&&(t+=" "+this.mark.toString()),t},e.exports=n},function(e,t,r){"use strict";var n=r(39);e.exports=new n({include:[r(181)],implicit:[r(293),r(294)],explicit:[r(295),r(296),r(297),r(298)]})},function(e,t,r){var n=r(16),i=r(79),o=r(40),a=r(24),s=r(56),u=r(14),l=r(115),c=Object.getOwnPropertyDescriptor;t.f=n?c:function(e,t){if(e=a(e),t=s(t,!0),l)try{return c(e,t)}catch(e){}if(u(e,t))return o(!i.f.call(e,t),e[t])}},function(e,t,r){var n=r(13);e.exports=function(e,t){if(!n(e))return e;var r,i;if(t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;if("function"==typeof(r=e.valueOf)&&!n(i=r.call(e)))return i;if(!t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;throw TypeError("Can't convert object to primitive value")}},function(e,t,r){var n=r(81),i=r(58),o=n("keys");e.exports=function(e){return o[e]||(o[e]=i(e))}},function(e,t){var r=0,n=Math.random();e.exports=function(e){return"Symbol("+String(void 0===e?"":e)+")_"+(++r+n).toString(36)}},function(e,t,r){var n=r(42);e.exports=Array.isArray||function(e){return"Array"==n(e)}},function(e,t,r){var n,i=r(18),o=r(188),a=r(84),s=r(45),u=r(189),l=r(116),c=r(57),h=c("IE_PROTO"),p=function(){},f=function(e){return"<script>"+e+"<\/script>"},d=function(){try{n=document.domain&&new ActiveXObject("htmlfile")}catch(e){}var e,t;d=n?function(e){e.write(f("")),e.close();var t=e.parentWindow.Object;return e=null,t}(n):((t=l("iframe")).style.display="none",u.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(f("document.F=Object")),e.close(),e.F);for(var r=a.length;r--;)delete d.prototype[a[r]];return d()};s[h]=!0,e.exports=Object.create||function(e,t){var r;return null!==e?(p.prototype=i(e),r=new p,p.prototype=null,r[h]=e):r=d(),void 0===t?r:o(r,t)}},function(e,t,r){var n=r(121),i=r(84);e.exports=Object.keys||function(e){return n(e,i)}},function(e,t,r){var n=r(15).f,i=r(14),o=r(5)("toStringTag");e.exports=function(e,t,r){e&&!i(e=r?e:e.prototype,o)&&n(e,o,{configurable:!0,value:t})}},function(e,t,r){var n=r(8),i=r(5),o=r(129),a=i("species");e.exports=function(e){return o>=51||!n((function(){var t=[];return(t.constructor={})[a]=function(){return{foo:1}},1!==t[e](Boolean).foo}))}},function(e,t,r){"use strict";var n=r(4),i=r(122).indexOf,o=r(48),a=r(28),s=[].indexOf,u=!!s&&1/[1].indexOf(1,-0)<0,l=o("indexOf"),c=a("indexOf",{ACCESSORS:!0,1:0});n({target:"Array",proto:!0,forced:u||!l||!c},{indexOf:function(e){return u?s.apply(this,arguments)||0:i(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){var n=r(16),i=r(15).f,o=Function.prototype,a=o.toString,s=/^\s*function ([^ (]*)/;n&&!("name"in o)&&i(o,"name",{configurable:!0,get:function(){try{return a.call(this).match(s)[1]}catch(e){return""}}})},function(e,t,r){"use strict";var n=r(25),i=r(18),o=r(8),a=r(136),s=RegExp.prototype,u=s.toString,l=o((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),c="toString"!=u.name;(l||c)&&n(RegExp.prototype,"toString",(function(){var e=i(this),t=String(e.source),r=e.flags;return"/"+t+"/"+String(void 0===r&&e instanceof RegExp&&!("flags"in s)?a.call(e):r)}),{unsafe:!0})},function(e,t,r){"use strict";r(31),r(32),r(33),r(19),r(138),r(20),r(66),r(22),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(1),s=r(2),u=function(e){function t(t,r){var n=e.call(this,t)||this;return n._writerOptions=a.applyDefaults(r,{format:"object",wellFormed:!1,group:!1,verbose:!1}),n}return i(t,e),t.prototype.serialize=function(e){return this._currentList=[],this._currentIndex=0,this._listRegister=[this._currentList],this.serializeNode(e,this._writerOptions.wellFormed),this._process(this._currentList,this._writerOptions)},t.prototype._process=function(e,t){var r,n,i,o,u,l,c;if(0===e.length)return{};for(var h={},p=!1,f=0,d=0,m=0,y=0,v=0;v<e.length;v++){var _=e[v];switch(I=Object.keys(_)[0]){case"@":continue;case"#":f++;break;case"!":d++;break;case"?":m++;break;case"$":y++;break;default:h[I]?p=!0:h[I]=!0}}var g=this._getAttrKey(),b=this._getNodeKey(s.NodeType.Text),x=this._getNodeKey(s.NodeType.Comment),w=this._getNodeKey(s.NodeType.ProcessingInstruction),E=this._getNodeKey(s.NodeType.CData);if(1===f&&1===e.length&&a.isString(e[0]["#"]))return e[0]["#"];if(p){var D={};for(v=0;v<e.length;v++){_=e[v];if("@"===(I=Object.keys(_)[0])){var S=_["@"];1===(L=Object.keys(S)).length?D[g+L[0]]=S[L[0]]:D[g]=_["@"]}}var C=[];for(v=0;v<e.length;v++){_=e[v];switch(I=Object.keys(_)[0]){case"@":break;case"#":C.push(((r={})[b]=_["#"],r));break;case"!":C.push(((n={})[x]=_["!"],n));break;case"?":C.push(((i={})[w]=_["?"],i));break;case"$":C.push(((o={})[E]=_.$,o));break;default:if(0!==(B=_)[I].length&&a.isArray(B[I][0])){for(var A=[],N=B[I],T=0;T<N.length;T++)A.push(this._process(N[T],t));C.push(((u={})[I]=A,u))}else t.verbose?C.push(((l={})[I]=[this._process(B[I],t)],l)):C.push(((c={})[I]=this._process(B[I],t),c))}}return D[b]=C,D}var O=1,F=1,k=1,P=1;for(D={},v=0;v<e.length;v++){var I;_=e[v];switch(I=Object.keys(_)[0]){case"@":S=_["@"];var L=Object.keys(S);if(t.group&&1!==L.length)D[g]=S;else for(var M in S)D[g+M]=S[M];break;case"#":O=this._processSpecItem(_["#"],D,t.group,b,f,O);break;case"!":F=this._processSpecItem(_["!"],D,t.group,x,d,F);break;case"?":k=this._processSpecItem(_["?"],D,t.group,w,m,k);break;case"$":P=this._processSpecItem(_.$,D,t.group,E,y,P);break;default:var B;if(0!==(B=_)[I].length&&a.isArray(B[I][0])){A=[],N=B[I];for(var j=0;j<N.length;j++)A.push(this._process(N[j],t));D[I]=A}else t.verbose?D[I]=[this._process(B[I],t)]:D[I]=this._process(B[I],t)}}return D},t.prototype._processSpecItem=function(e,t,r,n,i,s){var u,l;if(!r&&a.isArray(e)&&i+e.length>2)try{for(var c=o(e),h=c.next();!h.done;h=c.next()){var p=h.value;t[n+(s++).toString()]=p}}catch(e){u={error:e}}finally{try{h&&!h.done&&(l=c.return)&&l.call(c)}finally{if(u)throw u.error}}else t[i>1?n+(s++).toString():n]=e;return s},t.prototype.beginElement=function(e){var t,r,n=[];if(0===this._currentList.length)this._currentList.push(((t={})[e]=n,t));else{var i=this._currentList[this._currentList.length-1];if(this._isElementNode(i,e))if(0!==i[e].length&&a.isArray(i[e][0]))i[e].push(n);else i[e]=[i[e],n];else this._currentList.push(((r={})[e]=n,r))}this._currentIndex++,this._listRegister.length>this._currentIndex?this._listRegister[this._currentIndex]=n:this._listRegister.push(n),this._currentList=n},t.prototype.endElement=function(){this._currentList=this._listRegister[--this._currentIndex]},t.prototype.attribute=function(e,t){var r,n;if(0===this._currentList.length)this._currentList.push({"@":(r={},r[e]=t,r)});else{var i=this._currentList[this._currentList.length-1];this._isAttrNode(i)?i["@"][e]=t:this._currentList.push({"@":(n={},n[e]=t,n)})}},t.prototype.comment=function(e){if(0===this._currentList.length)this._currentList.push({"!":e});else{var t=this._currentList[this._currentList.length-1];this._isCommentNode(t)?a.isArray(t["!"])?t["!"].push(e):t["!"]=[t["!"],e]:this._currentList.push({"!":e})}},t.prototype.text=function(e){if(0===this._currentList.length)this._currentList.push({"#":e});else{var t=this._currentList[this._currentList.length-1];this._isTextNode(t)?a.isArray(t["#"])?t["#"].push(e):t["#"]=[t["#"],e]:this._currentList.push({"#":e})}},t.prototype.instruction=function(e,t){var r=""===t?e:e+" "+t;if(0===this._currentList.length)this._currentList.push({"?":r});else{var n=this._currentList[this._currentList.length-1];this._isInstructionNode(n)?a.isArray(n["?"])?n["?"].push(r):n["?"]=[n["?"],r]:this._currentList.push({"?":r})}},t.prototype.cdata=function(e){if(0===this._currentList.length)this._currentList.push({$:e});else{var t=this._currentList[this._currentList.length-1];this._isCDATANode(t)?a.isArray(t.$)?t.$.push(e):t.$=[t.$,e]:this._currentList.push({$:e})}},t.prototype._isAttrNode=function(e){return"@"in e},t.prototype._isTextNode=function(e){return"#"in e},t.prototype._isCommentNode=function(e){return"!"in e},t.prototype._isInstructionNode=function(e){return"?"in e},t.prototype._isCDATANode=function(e){return"$"in e},t.prototype._isElementNode=function(e,t){return t in e},t.prototype._getAttrKey=function(){return this._builderOptions.convert.att},t.prototype._getNodeKey=function(e){switch(e){case s.NodeType.Comment:return this._builderOptions.convert.comment;case s.NodeType.Text:return this._builderOptions.convert.text;case s.NodeType.ProcessingInstruction:return this._builderOptions.convert.ins;case s.NodeType.CData:return this._builderOptions.convert.cdata;default:throw new Error("Invalid node type.")}},t}(r(50).BaseWriter);t.ObjectWriter=u},function(e,t,r){"use strict";var n=r(4),i=r(93);n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){this._items={},this._nullItems={}}return e.prototype.set=function(e,t){null===e?this._nullItems[t]=!0:(this._items[e]||(this._items[e]={}),this._items[e][t]=!0)},e.prototype.has=function(e,t){return null===e?!0===this._nullItems[t]:!!this._items[e]&&!0===this._items[e][t]},e}();t.LocalNameSet=n},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var i=r(9),o=r(3),a=r(0),s=function(){function e(){}return Object.defineProperty(e.prototype,"_eventListenerList",{get:function(){return this.__eventListenerList||(this.__eventListenerList=[])},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_eventHandlerMap",{get:function(){return this.__eventHandlerMap||(this.__eventHandlerMap={})},enumerable:!0,configurable:!0}),e.prototype.addEventListener=function(e,t,r){void 0===r&&(r={passive:!1,once:!1,capture:!1});var i,s=n(a.eventTarget_flattenMore(r),3),u=s[0],l=s[1],c=s[2];t&&(i=o.Guard.isEventListener(t)?t:{handleEvent:t},a.eventTarget_addEventListener(this,{type:e,callback:i,capture:u,passive:l,once:c,removed:!1}))},e.prototype.removeEventListener=function(e,t,r){void 0===r&&(r={capture:!1});var n=a.eventTarget_flatten(r);if(t)for(var i=0;i<this._eventListenerList.length;i++){var s=this._eventListenerList[i];if(s.type===e&&s.capture===n){if(o.Guard.isEventListener(t)&&s.callback===t){a.eventTarget_removeEventListener(this,s,i);break}if(t&&s.callback.handleEvent===t){a.eventTarget_removeEventListener(this,s,i);break}}}},e.prototype.dispatchEvent=function(e){if(e._dispatchFlag||!e._initializedFlag)throw new i.InvalidStateError;return e._isTrusted=!1,a.event_dispatch(e,this)},e.prototype._getTheParent=function(e){return null},e}();t.EventTargetImpl=s},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(34),a=r(0),s=function(e){function t(t){var r=e.call(this)||this;return r._data=t,r}return i(t,e),Object.defineProperty(t.prototype,"data",{get:function(){return this._data},set:function(e){a.characterData_replaceData(this,0,this._data.length,e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"length",{get:function(){return this._data.length},enumerable:!0,configurable:!0}),t.prototype.substringData=function(e,t){return a.characterData_substringData(this,e,t)},t.prototype.appendData=function(e){return a.characterData_replaceData(this,this._data.length,0,e)},t.prototype.insertData=function(e,t){a.characterData_replaceData(this,e,0,t)},t.prototype.deleteData=function(e,t){a.characterData_replaceData(this,e,t,"")},t.prototype.replaceData=function(e,t,r){a.characterData_replaceData(this,e,t,r)},Object.defineProperty(t.prototype,"previousElementSibling",{get:function(){throw new Error("Mixin: NonDocumentTypeChildNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nextElementSibling",{get:function(){throw new Error("Mixin: NonDocumentTypeChildNode not implemented.")},enumerable:!0,configurable:!0}),t.prototype.before=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.after=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.replaceWith=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.remove=function(){throw new Error("Mixin: ChildNode not implemented.")},t}(o.NodeImpl);t.CharacterDataImpl=s},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),s=r(3),u=r(1),l=r(17),c=r(51);function h(e){a.dom.window._signalSlots.add(e),c.observer_queueAMutationObserverMicrotask()}function p(e,t){void 0===t&&(t=!1);var r=s.Cast.asNode(e)._parent;if(null===r)return null;var n=r._shadowRoot||null;if(null===n)return null;if(t&&"open"!==n._mode)return null;for(var i=l.tree_getFirstDescendantNode(n,!1,!0,(function(e){return s.Guard.isSlot(e)}));null!==i;){if(i._name===e._name)return i;i=l.tree_getNextDescendantNode(n,i,!1,!0,(function(e){return s.Guard.isSlot(e)}))}return null}function f(e){var t,r,i=[],o=l.tree_rootNode(e);if(!s.Guard.isShadowRoot(o))return i;var a=o._host;try{for(var u=n(a._children),c=u.next();!c.done;c=u.next()){var h=c.value;if(s.Guard.isSlotable(h))p(h)===e&&i.push(h)}}catch(e){t={error:e}}finally{try{c&&!c.done&&(r=u.return)&&r.call(u)}finally{if(t)throw t.error}}return i}function d(e){var t,r,i=f(e);if(i.length===e._assignedNodes.length){for(var o=!0,a=0;a<i.length;a++)if(i[a]!==e._assignedNodes[a]){o=!1;break}o||h(e)}e._assignedNodes=i;try{for(var s=n(i),u=s.next();!u.done;u=s.next()){u.value._assignedSlot=e}}catch(e){t={error:e}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(t)throw t.error}}}t.shadowTree_signalASlotChange=h,t.shadowTree_isConnected=function(e){return s.Guard.isDocumentNode(l.tree_rootNode(e,!0))},t.shadowTree_isAssigned=function(e){return null!==e._assignedSlot},t.shadowTree_findASlot=p,t.shadowTree_findSlotables=f,t.shadowTree_findFlattenedSlotables=function e(t){var r,i,a,c,h=[],p=l.tree_rootNode(t);if(!s.Guard.isShadowRoot(p))return h;var d=f(t);if(u.isEmpty(d))try{for(var m=n(t._children),y=m.next();!y.done;y=m.next()){var v=y.value;s.Guard.isSlotable(v)&&d.push(v)}}catch(e){r={error:e}}finally{try{y&&!y.done&&(i=m.return)&&i.call(m)}finally{if(r)throw r.error}}try{for(var _=n(d),g=_.next();!g.done;g=_.next()){var b=g.value;if(s.Guard.isSlot(b)&&s.Guard.isShadowRoot(l.tree_rootNode(b))){var x=e(b);h.push.apply(h,o(x))}else h.push(b)}}catch(e){a={error:e}}finally{try{g&&!g.done&&(c=_.return)&&c.call(_)}finally{if(a)throw a.error}}return h},t.shadowTree_assignSlotables=d,t.shadowTree_assignSlotablesForATree=function(e){for(var t=l.tree_getFirstDescendantNode(e,!0,!1,(function(e){return s.Guard.isSlot(e)}));null!==t;)d(t),t=l.tree_getNextDescendantNode(e,t,!0,!1,(function(e){return s.Guard.isSlot(e)}))},t.shadowTree_assignASlot=function(e){var t=p(e);null!==t&&d(t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=/[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/,i=new Set(["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"]),o=new Set(["article","aside","blockquote","body","div","footer","h1","h2","h3","h4","h5","h6","header","main","nav","p","section","span"]),a=new Set(["area","base","basefont","bgsound","br","col","embed","frame","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"]),s=new Set(["article","aside","blockquote","body","div","footer","h1","h2","h3","h4","h5","h6","header","main","nav","p","section","span"]);t.customElement_isValidCustomElementName=function(e){return!!n.test(e)&&!i.has(e)},t.customElement_isValidElementName=function(e){return o.has(e)},t.customElement_isVoidElementName=function(e){return a.has(e)},t.customElement_isValidShadowHostName=function(e){return s.has(e)},t.customElement_enqueueACustomElementUpgradeReaction=function(e,t){},t.customElement_enqueueACustomElementCallbackReaction=function(e,t,r){},t.customElement_upgrade=function(e,t){},t.customElement_tryToUpgrade=function(e){},t.customElement_lookUpACustomElementDefinition=function(e,t,r,n){return null}},function(e,t,r){r(4)({target:"String",proto:!0},{repeat:r(259)})},function(e,t,r){"use strict";r(278),r(68),r(179),r(94),Object.defineProperty(t,"__esModule",{value:!0});var n=r(109),i=function(){function e(e){this._builderOptions=e,e.parser&&Object.assign(this,e.parser)}return e.prototype._docType=function(e,t,r,n){return e.dtd({name:t,pubID:r,sysID:n})},e.prototype._comment=function(e,t){return e.com(t)},e.prototype._text=function(e,t){return e.txt(t)},e.prototype._instruction=function(e,t,r){return e.ins(t,r)},e.prototype._cdata=function(e,t){return e.dat(t)},e.prototype._element=function(e,t,r){return void 0===t?e.ele(r):e.ele(t,r)},e.prototype._attribute=function(e,t,r,n){return void 0===t?e.att(r,n):e.att(t,r,n)},e.prototype._sanitize=function(e){return n.sanitizeInput(e,this._builderOptions.invalidCharReplacement)},e.prototype._decodeText=function(t){return null==t?t:t.replace(/&(quot|amp|apos|lt|gt);/g,(function(t,r){return e._entityTable[r]})).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g,(function(e,t,r){return String.fromCodePoint(parseInt(t||r,t?16:10))}))},e.prototype._decodeAttributeValue=function(e){return this._decodeText(e)},e.prototype.parse=function(e,t){return this._parse(e,t)},e.prototype.docType=function(e,t,r,n){return this._docType(e,t,r,n)},e.prototype.comment=function(e,t){return this._comment(e,t)},e.prototype.text=function(e,t){return this._text(e,t)},e.prototype.instruction=function(e,t,r){return this._instruction(e,t,r)},e.prototype.cdata=function(e,t){return this._cdata(e,t)},e.prototype.element=function(e,t,r){return this._element(e,t,r)},e.prototype.attribute=function(e,t,r,n){return this._attribute(e,t,r,n)},e.prototype.sanitize=function(e){return this._sanitize(e)},e._entityTable={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"},e}();t.BaseReader=i},function(e,t,r){"use strict";var n=r(39);e.exports=n.DEFAULT=new n({include:[r(54)],explicit:[r(299),r(300),r(301)]})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(185);t.XMLBuilderImpl=n.XMLBuilderImpl;var i=r(304);t.XMLBuilderCBImpl=i.XMLBuilderCBImpl;var o=r(183);t.builder=o.builder,t.create=o.create,t.fragment=o.fragment,t.convert=o.convert;var a=r(309);t.createCB=a.createCB,t.fragmentCB=a.fragmentCB},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";var n={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!n.call({1:2},1);t.f=o?function(e){var t=i(this,e);return!!t&&t.enumerable}:n},function(e,t,r){var n=r(11),i=r(21);e.exports=function(e,t){try{i(n,e,t)}catch(r){n[e]=t}return t}},function(e,t,r){var n=r(44),i=r(118);(e.exports=function(e,t){return i[e]||(i[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.6.5",mode:n?"pure":"global",copyright:"© 2020 Denis Pushkarev (zloirock.ru)"})},function(e,t,r){var n=r(121),i=r(84).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return n(e,i)}},function(e,t,r){var n=r(47),i=Math.max,o=Math.min;e.exports=function(e,t){var r=n(e);return r<0?i(r+t,0):o(r,t)}},function(e,t){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(e,t){t.f=Object.getOwnPropertySymbols},function(e,t,r){var n=r(8);e.exports=!!Object.getOwnPropertySymbols&&!n((function(){return!String(Symbol())}))},function(e,t,r){var n=r(127);e.exports=function(e,t,r){if(n(e),void 0===t)return e;switch(r){case 0:return function(){return e.call(t)};case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,i){return e.call(t,r,n,i)}}return function(){return e.apply(t,arguments)}}},function(e,t,r){"use strict";var n=r(4),i=r(195),o=r(132),a=r(133),s=r(62),u=r(21),l=r(25),c=r(5),h=r(44),p=r(49),f=r(131),d=f.IteratorPrototype,m=f.BUGGY_SAFARI_ITERATORS,y=c("iterator"),v=function(){return this};e.exports=function(e,t,r,c,f,_,g){i(r,t,c);var b,x,w,E=function(e){if(e===f&&N)return N;if(!m&&e in C)return C[e];switch(e){case"keys":case"values":case"entries":return function(){return new r(this,e)}}return function(){return new r(this)}},D=t+" Iterator",S=!1,C=e.prototype,A=C[y]||C["@@iterator"]||f&&C[f],N=!m&&A||E(f),T="Array"==t&&C.entries||A;if(T&&(b=o(T.call(new e)),d!==Object.prototype&&b.next&&(h||o(b)===d||(a?a(b,d):"function"!=typeof b[y]&&u(b,y,v)),s(b,D,!0,!0),h&&(p[D]=v))),"values"==f&&A&&"values"!==A.name&&(S=!0,N=function(){return A.call(this)}),h&&!g||C[y]===N||u(C,y,N),p[t]=N,f)if(x={values:E("values"),keys:_?N:E("keys"),entries:E("entries")},g)for(w in x)(m||S||!(w in C))&&l(C,w,x[w]);else n({target:t,proto:!0,forced:m||S},x);return x}},function(e,t,r){"use strict";var n=r(4),i=r(13),o=r(59),a=r(83),s=r(26),u=r(24),l=r(134),c=r(5),h=r(63),p=r(28),f=h("slice"),d=p("slice",{ACCESSORS:!0,0:0,1:2}),m=c("species"),y=[].slice,v=Math.max;n({target:"Array",proto:!0,forced:!f||!d},{slice:function(e,t){var r,n,c,h=u(this),p=s(h.length),f=a(e,p),d=a(void 0===t?p:t,p);if(o(h)&&("function"!=typeof(r=h.constructor)||r!==Array&&!o(r.prototype)?i(r)&&null===(r=r[m])&&(r=void 0):r=void 0,r===Array||void 0===r))return y.call(h,f,d);for(n=new(void 0===r?Array:r)(v(d-f,0)),c=0;f<d;f++,c++)f in h&&l(n,c,h[f]);return n.length=c,n}})},function(e,t,r){var n={};n[r(5)("toStringTag")]="z",e.exports="[object z]"===String(n)},function(e,t,r){"use strict";r(19),r(138),r(20),r(92),r(22),r(23),Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultBuilderOptions={version:"1.0",encoding:void 0,standalone:void 0,keepNullNodes:!1,keepNullAttributes:!1,ignoreConverters:!1,convert:{att:"@",ins:"?",text:"#",cdata:"$",comment:"!"},defaultNamespace:{ele:void 0,att:void 0},namespaceAlias:{html:"http://www.w3.org/1999/xhtml",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg",xlink:"http://www.w3.org/1999/xlink"},invalidCharReplacement:void 0,parser:void 0},t.XMLBuilderOptionKeys=new Set(Object.keys(t.DefaultBuilderOptions)),t.DefaultXMLBuilderCBOptions={format:"xml",wellFormed:!1,prettyPrint:!1,indent:"  ",newline:"\n",offset:0,width:0,allowEmptyTags:!1,spaceBeforeSlash:!1,keepNullNodes:!1,keepNullAttributes:!1,ignoreConverters:!1,convert:{att:"@",ins:"?",text:"#",cdata:"$",comment:"!"},defaultNamespace:{ele:void 0,att:void 0},namespaceAlias:{html:"http://www.w3.org/1999/xhtml",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg",xlink:"http://www.w3.org/1999/xlink"}}},function(e,t,r){"use strict";var n=r(139),i=r(143);e.exports=n("Set",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),i)},function(e,t,r){"use strict";var n,i,o=r(136),a=r(221),s=RegExp.prototype.exec,u=String.prototype.replace,l=s,c=(n=/a/,i=/b*/g,s.call(n,"a"),s.call(i,"a"),0!==n.lastIndex||0!==i.lastIndex),h=a.UNSUPPORTED_Y||a.BROKEN_CARET,p=void 0!==/()??/.exec("")[1];(c||p||h)&&(l=function(e){var t,r,n,i,a=this,l=h&&a.sticky,f=o.call(a),d=a.source,m=0,y=e;return l&&(-1===(f=f.replace("y","")).indexOf("g")&&(f+="g"),y=String(e).slice(a.lastIndex),a.lastIndex>0&&(!a.multiline||a.multiline&&"\n"!==e[a.lastIndex-1])&&(d="(?: "+d+")",y=" "+y,m++),r=new RegExp("^(?:"+d+")",f)),p&&(r=new RegExp("^"+d+"$(?!\\s)",f)),c&&(t=a.lastIndex),n=s.call(l?r:a,y),l?n?(n.input=n.input.slice(m),n[0]=n[0].slice(m),n.index=a.lastIndex,a.lastIndex+=n[0].length):a.lastIndex=0:c&&n&&(a.lastIndex=a.global?n.index+n[0].length:t),p&&n&&n.length>1&&u.call(n[0],r,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(n[i]=void 0)})),n}),e.exports=l},function(e,t,r){"use strict";var n=r(225),i=r(18),o=r(27),a=r(26),s=r(47),u=r(35),l=r(226),c=r(227),h=Math.max,p=Math.min,f=Math.floor,d=/\$([$&'`]|\d\d?|<[^>]*>)/g,m=/\$([$&'`]|\d\d?)/g;n("replace",2,(function(e,t,r,n){var y=n.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,v=n.REPLACE_KEEPS_$0,_=y?"$":"$0";return[function(r,n){var i=u(this),o=null==r?void 0:r[e];return void 0!==o?o.call(r,i,n):t.call(String(i),r,n)},function(e,n){if(!y&&v||"string"==typeof n&&-1===n.indexOf(_)){var o=r(t,e,this,n);if(o.done)return o.value}var u=i(e),f=String(this),d="function"==typeof n;d||(n=String(n));var m=u.global;if(m){var b=u.unicode;u.lastIndex=0}for(var x=[];;){var w=c(u,f);if(null===w)break;if(x.push(w),!m)break;""===String(w[0])&&(u.lastIndex=l(f,a(u.lastIndex),b))}for(var E,D="",S=0,C=0;C<x.length;C++){w=x[C];for(var A=String(w[0]),N=h(p(s(w.index),f.length),0),T=[],O=1;O<w.length;O++)T.push(void 0===(E=w[O])?E:String(E));var F=w.groups;if(d){var k=[A].concat(T,N,f);void 0!==F&&k.push(F);var P=String(n.apply(void 0,k))}else P=g(A,f,N,T,F,n);N>=S&&(D+=f.slice(S,N)+P,S=N+A.length)}return D+f.slice(S)}];function g(e,r,n,i,a,s){var u=n+e.length,l=i.length,c=m;return void 0!==a&&(a=o(a),c=d),t.call(s,c,(function(t,o){var s;switch(o.charAt(0)){case"$":return"$";case"&":return e;case"`":return r.slice(0,n);case"'":return r.slice(u);case"<":s=a[o.slice(1,-1)];break;default:var c=+o;if(0===c)return t;if(c>l){var h=f(c/10);return 0===h?t:h<=l?void 0===i[h-1]?o.charAt(1):i[h-1]+o.charAt(1):t}s=i[c-1]}return void 0===s?"":s}))}}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){this._items={},this._nullItems=[]}return e.prototype.copy=function(){var t=new e;for(var r in this._items)t._items[r]=this._items[r].slice(0);return t._nullItems=this._nullItems.slice(0),t},e.prototype.get=function(e,t){var r=null===t?this._nullItems:this._items[t]||null;if(null===r)return null;for(var n=null,i=0;i<r.length;i++)if((n=r[i])===e)return n;return n},e.prototype.has=function(e,t){var r=null===t?this._nullItems:this._items[t]||null;return null!==r&&-1!==r.indexOf(e)},e.prototype.hasPrefix=function(e){if(-1!==this._nullItems.indexOf(e))return!0;for(var t in this._items)if(-1!==this._items[t].indexOf(e))return!0;return!1},e.prototype.set=function(e,t){var r=null===t?this._nullItems:this._items[t]||null;null!==t&&null===r?this._items[t]=[e]:r.push(e)},e}();t.NamespacePrefixMap=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Surrogate=/[\uD800-\uDFFF]/,t.ScalarValue=/[\uD800-\uDFFF]/,t.NonCharacter=/[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/,t.ASCIICodePoint=/[\u0000-\u007F]/,t.ASCIITabOrNewLine=/[\t\n\r]/,t.ASCIIWhiteSpace=/[\t\n\f\r ]/,t.C0Control=/[\u0000-\u001F]/,t.C0ControlOrSpace=/[\u0000-\u001F ]/,t.Control=/[\u0000-\u001F\u007F-\u009F]/,t.ASCIIDigit=/[0-9]/,t.ASCIIUpperHexDigit=/[0-9A-F]/,t.ASCIILowerHexDigit=/[0-9a-f]/,t.ASCIIHexDigit=/[0-9A-Fa-f]/,t.ASCIIUpperAlpha=/[A-Z]/,t.ASCIILowerAlpha=/[a-z]/,t.ASCIIAlpha=/[A-Za-z]/,t.ASCIIAlphanumeric=/[0-9A-Za-z]/},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),s=r(2),u=r(3),l=r(171),c=r(104),h=r(9),p=r(17),f=r(72),d=r(30);function m(e,t){void 0===t&&(t=void 0),void 0===t&&(t=null);var r=y(e,t,new Date,{});return r._isTrusted=!0,r}function y(e,t,r,n){var i=new e("");return i._initializedFlag=!0,i._timeStamp=r.getTime(),Object.assign(i,n),a.dom.features.steps&&d.dom_runEventConstructingSteps(i),i}function v(e,t,r,i){var o,a,l,c;void 0===r&&(r=!1),void 0===i&&(i={value:!1});var h=!1;e._dispatchFlag=!0;var d=t;if(r){var m=t._associatedDocument;u.Guard.isDocumentNode(m)&&(d=m)}var y=null,v=p.tree_retarget(e._relatedTarget,t);if(t!==v||t===e._relatedTarget){var b=[];try{for(var x=n(e._touchTargetList),w=x.next();!w.done;w=x.next()){var E=w.value;b.push(p.tree_retarget(E,t))}}catch(e){o={error:e}}finally{try{w&&!w.done&&(a=x.return)&&a.call(x)}finally{if(o)throw o.error}}_(e,t,d,v,b,!1);var D=u.Guard.isMouseEvent(e)&&"click"===e._type;D&&void 0!==t._activationBehavior&&(y=t);for(var S=u.Guard.isSlotable(t)&&f.shadowTree_isAssigned(t)?t:null,C=!1,A=t._getTheParent(e);null!==A&&u.Guard.isNode(A);){if(null!==S){if(!u.Guard.isSlot(A))throw new Error("Parent node of a slotable should be a slot.");S=null;var N=p.tree_rootNode(A,!0);u.Guard.isShadowRoot(N)&&"closed"===N._mode&&(C=!0)}u.Guard.isSlotable(A)&&f.shadowTree_isAssigned(A)&&(S=A),v=p.tree_retarget(e._relatedTarget,A),b=[];try{for(var T=(l=void 0,n(e._touchTargetList)),O=T.next();!O.done;O=T.next()){E=O.value;b.push(p.tree_retarget(E,A))}}catch(e){l={error:e}}finally{try{O&&!O.done&&(c=T.return)&&c.call(T)}finally{if(l)throw l.error}}u.Guard.isWindow(A)||u.Guard.isNode(A)&&u.Guard.isNode(t)&&p.tree_isAncestorOf(p.tree_rootNode(t,!0),A,!0,!0)?(D&&e._bubbles&&null===y&&A._activationBehavior&&(y=A),_(e,A,null,v,b,C)):A===v?A=null:(t=A,D&&null===y&&t._activationBehavior&&(y=t),_(e,A,t,v,b,C)),null!==A&&(A=A._getTheParent(e)),C=!1}for(var F=null,k=e._path,P=k.length-1;P>=0;P--){if(null!==(L=k[P]).shadowAdjustedTarget){F=L;break}}if(null!==F)if(u.Guard.isNode(F.shadowAdjustedTarget)&&u.Guard.isShadowRoot(p.tree_rootNode(F.shadowAdjustedTarget,!0)))h=!0;else if(u.Guard.isNode(F.relatedTarget)&&u.Guard.isShadowRoot(p.tree_rootNode(F.relatedTarget,!0)))h=!0;else for(var I=0;I<F.touchTargetList.length;I++){var L=F.touchTargetList[I];if(u.Guard.isNode(L)&&u.Guard.isShadowRoot(p.tree_rootNode(L,!0))){h=!0;break}}null!==y&&void 0!==y._legacyPreActivationBehavior&&y._legacyPreActivationBehavior(e);for(P=k.length-1;P>=0;P--){null!==(L=k[P]).shadowAdjustedTarget?e._eventPhase=s.EventPhase.AtTarget:e._eventPhase=s.EventPhase.Capturing,g(L,e,"capturing",i)}for(P=0;P<k.length;P++){if(null!==(L=k[P]).shadowAdjustedTarget)e._eventPhase=s.EventPhase.AtTarget;else{if(!e._bubbles)continue;e._eventPhase=s.EventPhase.Bubbling}g(L,e,"bubbling",i)}}return e._eventPhase=s.EventPhase.None,e._currentTarget=null,e._path=[],e._dispatchFlag=!1,e._stopPropagationFlag=!1,e._stopImmediatePropagationFlag=!1,h&&(e._target=null,e._relatedTarget=null,e._touchTargetList=[]),null!==y&&(e._canceledFlag||void 0===y._activationBehavior?void 0!==y._legacyCanceledActivationBehavior&&y._legacyCanceledActivationBehavior(e):y._activationBehavior(e)),!e._canceledFlag}function _(e,t,r,n,i,o){var a=!1;u.Guard.isNode(t)&&u.Guard.isShadowRoot(p.tree_rootNode(t))&&(a=!0);var s=!1;u.Guard.isShadowRoot(t)&&"closed"===t._mode&&(s=!0),e._path.push({invocationTarget:t,invocationTargetInShadowTree:a,shadowAdjustedTarget:r,relatedTarget:n,touchTargetList:i,rootOfClosedTree:s,slotInClosedTree:o})}function g(e,t,r,n){void 0===n&&(n={value:!1});for(var i=t._path,a=-1,s=0;s<i.length;s++)if(i[s]===e){a=s;break}if(-1!==a){var u=i[a];(null!==u.shadowAdjustedTarget||a>0&&null!==(u=i[a-1]).shadowAdjustedTarget)&&(t._target=u.shadowAdjustedTarget)}if(t._relatedTarget=e.relatedTarget,t._touchTargetList=e.touchTargetList,!t._stopPropagationFlag){t._currentTarget=e.invocationTarget;var l=t._currentTarget._eventListenerList,c=new(Array.bind.apply(Array,o([void 0],l)));if(!b(t,c,r,e,n)&&t._isTrusted){var h=t._type;"animationend"===h?t._type="webkitAnimationEnd":"animationiteration"===h?t._type="webkitAnimationIteration":"animationstart"===h?t._type="webkitAnimationStart":"transitionend"===h&&(t._type="webkitTransitionEnd"),b(t,c,r,e,n),t._type=h}}}function b(e,t,r,n,i){void 0===i&&(i={value:!1});for(var o=!1,a=0;a<t.length;a++){var s=t[a];if(!s.removed){if(e._type!==s.type)continue;if(o=!0,"capturing"===r&&!s.capture)continue;if("bubbling"===r&&s.capture)continue;if(s.once&&null!==e._currentTarget){for(var l=e._currentTarget,c=-1,h=0;h<l._eventListenerList.length;h++)if(l._eventListenerList[h]===s){c=h;break}-1!==c&&l._eventListenerList.splice(c,1)}var p=void 0,f=void 0;u.Guard.isWindow(p)&&(f=p._currentEvent,!1===n.invocationTargetInShadowTree&&(p._currentEvent=e)),s.passive&&(e._inPassiveListenerFlag=!0);try{s.callback.handleEvent.call(e._currentTarget,e)}catch(e){i.value=!0}if(s.passive&&(e._inPassiveListenerFlag=!1),u.Guard.isWindow(p)&&(p._currentEvent=f),e._stopImmediatePropagationFlag)return o}}return o}function x(e,t){return null}function w(e,t){return null}function E(e,t){}function D(e,t){}t.event_setTheCanceledFlag=function(e){e._cancelable&&!e._inPassiveListenerFlag&&(e._canceledFlag=!0)},t.event_initialize=function(e,t,r,n){e._initializedFlag=!0,e._stopPropagationFlag=!1,e._stopImmediatePropagationFlag=!1,e._canceledFlag=!1,e._isTrusted=!1,e._target=null,e._type=t,e._bubbles=r,e._cancelable=n},t.event_createAnEvent=m,t.event_innerEventCreationSteps=y,t.event_dispatch=v,t.event_appendToAnEventPath=_,t.event_invoke=g,t.event_innerInvoke=b,t.event_fireAnEvent=function(e,t,r,n,i){void 0===r&&(r=c.EventImpl);var o=m(r);if(o._type=e,n)for(var a in n){o[a]=n[a]}return v(o,t,i)},t.event_createLegacyEvent=function(e){var t=null;switch(e.toLowerCase()){case"beforeunloadevent":case"compositionevent":break;case"customevent":t=l.CustomEventImpl;break;case"devicemotionevent":case"deviceorientationevent":case"dragevent":break;case"event":case"events":t=c.EventImpl}if(null===t)throw new h.NotSupportedError("Event constructor not found for interface "+e+".");var r=new t("");return r._type="",r._timeStamp=(new Date).getTime(),r._isTrusted=!1,r._initializedFlag=!1,r},t.event_getterEventHandlerIDLAttribute=function(e,t){return null},t.event_setterEventHandlerIDLAttribute=function(e,t,r){},t.event_determineTheTargetOfAnEventHandler=x,t.event_getTheCurrentValueOfAnEventHandler=w,t.event_activateAnEventHandler=E,t.event_deactivateAnEventHandler=D},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},a=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var s=r(6),u=r(2),l=r(9),c=r(34),h=r(3),p=r(1),f=r(7),d=r(152),m=r(0),y=r(12),v=function(e){function t(){var t=e.call(this)||this;return t._children=new Set,t._encoding={name:"UTF-8",labels:["unicode-1-1-utf-8","utf-8","utf8"]},t._contentType="application/xml",t._URL={scheme:"about",username:"",password:"",host:null,port:null,path:["blank"],query:null,fragment:null,_cannotBeABaseURLFlag:!0,_blobURLEntry:null},t._origin=null,t._type="xml",t._mode="no-quirks",t._documentElement=null,t._hasNamespaces=!1,t._nodeDocumentOverwrite=null,t}return i(t,e),Object.defineProperty(t.prototype,"_nodeDocument",{get:function(){return this._nodeDocumentOverwrite||this},set:function(e){this._nodeDocumentOverwrite=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this._implementation||(this._implementation=m.create_domImplementation(this))},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"URL",{get:function(){return d.urlSerializer(this._URL)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"documentURI",{get:function(){return this.URL},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"origin",{get:function(){return"null"},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"compatMode",{get:function(){return"quirks"===this._mode?"BackCompat":"CSS1Compat"},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"characterSet",{get:function(){return this._encoding.name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"charset",{get:function(){return this._encoding.name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"inputEncoding",{get:function(){return this._encoding.name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"contentType",{get:function(){return this._contentType},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"doctype",{get:function(){var e,t;try{for(var r=o(this._children),n=r.next();!n.done;n=r.next()){var i=n.value;if(h.Guard.isDocumentTypeNode(i))return i}}catch(t){e={error:t}}finally{try{n&&!n.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}return null},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"documentElement",{get:function(){return this._documentElement},enumerable:!0,configurable:!0}),t.prototype.getElementsByTagName=function(e){return m.node_listOfElementsWithQualifiedName(e,this)},t.prototype.getElementsByTagNameNS=function(e,t){return m.node_listOfElementsWithNamespace(e,t,this)},t.prototype.getElementsByClassName=function(e){return m.node_listOfElementsWithClassNames(e,this)},t.prototype.createElement=function(e,t){if(!m.xml_isName(e))throw new l.InvalidCharacterError;"html"===this._type&&(e=e.toLowerCase());var r=null;void 0!==t&&(r=p.isString(t)?t:t.is);var n="html"===this._type||"application/xhtml+xml"===this._contentType?f.namespace.HTML:null;return m.element_createAnElement(this,e,n,null,r,!0)},t.prototype.createElementNS=function(e,t,r){return m.document_internalCreateElementNS(this,e,t,r)},t.prototype.createDocumentFragment=function(){return m.create_documentFragment(this)},t.prototype.createTextNode=function(e){return m.create_text(this,e)},t.prototype.createCDATASection=function(e){if("html"===this._type)throw new l.NotSupportedError;if(-1!==e.indexOf("]]>"))throw new l.InvalidCharacterError;return m.create_cdataSection(this,e)},t.prototype.createComment=function(e){return m.create_comment(this,e)},t.prototype.createProcessingInstruction=function(e,t){if(!m.xml_isName(e))throw new l.InvalidCharacterError;if(-1!==t.indexOf("?>"))throw new l.InvalidCharacterError;return m.create_processingInstruction(this,e,t)},t.prototype.importNode=function(e,t){if(void 0===t&&(t=!1),h.Guard.isDocumentNode(e)||h.Guard.isShadowRoot(e))throw new l.NotSupportedError;return m.node_clone(e,this,t)},t.prototype.adoptNode=function(e){if(h.Guard.isDocumentNode(e))throw new l.NotSupportedError;if(h.Guard.isShadowRoot(e))throw new l.HierarchyRequestError;return m.document_adopt(e,this),e},t.prototype.createAttribute=function(e){if(!m.xml_isName(e))throw new l.InvalidCharacterError;return"html"===this._type&&(e=e.toLowerCase()),m.create_attr(this,e)},t.prototype.createAttributeNS=function(e,t){var r=a(m.namespace_validateAndExtract(e,t),3),n=r[0],i=r[1],o=r[2],s=m.create_attr(this,o);return s._namespace=n,s._namespacePrefix=i,s},t.prototype.createEvent=function(e){return m.event_createLegacyEvent(e)},t.prototype.createRange=function(){var e=m.create_range();return e._start=[this,0],e._end=[this,0],e},t.prototype.createNodeIterator=function(e,t,r){void 0===t&&(t=u.WhatToShow.All),void 0===r&&(r=null);var n=m.create_nodeIterator(e,e,!0);return n._whatToShow=t,n._iteratorCollection=m.create_nodeList(e),p.isFunction(r)?(n._filter=m.create_nodeFilter(),n._filter.acceptNode=r):n._filter=r,n},t.prototype.createTreeWalker=function(e,t,r){void 0===t&&(t=u.WhatToShow.All),void 0===r&&(r=null);var n=m.create_treeWalker(e,e);return n._whatToShow=t,p.isFunction(r)?(n._filter=m.create_nodeFilter(),n._filter.acceptNode=r):n._filter=r,n},t.prototype._getTheParent=function(e){return"load"===e._type?null:s.dom.window},t.prototype.getElementById=function(e){throw new Error("Mixin: NonElementParentNode not implemented.")},Object.defineProperty(t.prototype,"children",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"firstElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"lastElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"childElementCount",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),t.prototype.prepend=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.append=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelector=function(e){throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelectorAll=function(e){throw new Error("Mixin: ParentNode not implemented.")},t}(c.NodeImpl);t.DocumentImpl=v,y.idl_defineConst(v.prototype,"_nodeType",u.NodeType.Document)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},a=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var s=r(2),u=r(34),l=r(9),c=r(7),h=r(0),p=r(12),f=function(e){function t(){var t=e.call(this)||this;return t._children=new Set,t._namespace=null,t._namespacePrefix=null,t._localName="",t._customElementState="undefined",t._customElementDefinition=null,t._is=null,t._shadowRoot=null,t._attributeList=h.create_namedNodeMap(t),t._attributeChangeSteps=[],t._name="",t._assignedSlot=null,t}return i(t,e),Object.defineProperty(t.prototype,"namespaceURI",{get:function(){return this._namespace},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"prefix",{get:function(){return this._namespacePrefix},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"localName",{get:function(){return this._localName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"tagName",{get:function(){return this._htmlUppercasedQualifiedName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"id",{get:function(){return h.element_getAnAttributeValue(this,"id")},set:function(e){h.element_setAnAttributeValue(this,"id",e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"className",{get:function(){return h.element_getAnAttributeValue(this,"class")},set:function(e){h.element_setAnAttributeValue(this,"class",e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"classList",{get:function(){var e=h.element_getAnAttributeByName("class",this);return null===e&&(e=h.create_attr(this._nodeDocument,"class")),h.create_domTokenList(this,e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"slot",{get:function(){return h.element_getAnAttributeValue(this,"slot")},set:function(e){h.element_setAnAttributeValue(this,"slot",e)},enumerable:!0,configurable:!0}),t.prototype.hasAttributes=function(){return 0!==this._attributeList.length},Object.defineProperty(t.prototype,"attributes",{get:function(){return this._attributeList},enumerable:!0,configurable:!0}),t.prototype.getAttributeNames=function(){var e,t,r=[];try{for(var n=o(this._attributeList),i=n.next();!i.done;i=n.next()){var a=i.value;r.push(a._qualifiedName)}}catch(t){e={error:t}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}return r},t.prototype.getAttribute=function(e){var t=h.element_getAnAttributeByName(e,this);return t?t._value:null},t.prototype.getAttributeNS=function(e,t){var r=h.element_getAnAttributeByNamespaceAndLocalName(e,t,this);return r?r._value:null},t.prototype.setAttribute=function(e,t){if(!h.xml_isName(e))throw new l.InvalidCharacterError;this._namespace===c.namespace.HTML&&"html"===this._nodeDocument._type&&(e=e.toLowerCase());for(var r=null,n=0;n<this._attributeList.length;n++){var i=this._attributeList[n];if(i._qualifiedName===e){r=i;break}}if(null===r)return(r=h.create_attr(this._nodeDocument,e))._value=t,void h.element_append(r,this);h.element_change(r,this,t)},t.prototype.setAttributeNS=function(e,t,r){var n=a(h.namespace_validateAndExtract(e,t),3),i=n[0],o=n[1],s=n[2];h.element_setAnAttributeValue(this,s,r,o,i)},t.prototype.removeAttribute=function(e){h.element_removeAnAttributeByName(e,this)},t.prototype.removeAttributeNS=function(e,t){h.element_removeAnAttributeByNamespaceAndLocalName(e,t,this)},t.prototype.hasAttribute=function(e){this._namespace===c.namespace.HTML&&"html"===this._nodeDocument._type&&(e=e.toLowerCase());for(var t=0;t<this._attributeList.length;t++){if(this._attributeList[t]._qualifiedName===e)return!0}return!1},t.prototype.toggleAttribute=function(e,t){if(!h.xml_isName(e))throw new l.InvalidCharacterError;this._namespace===c.namespace.HTML&&"html"===this._nodeDocument._type&&(e=e.toLowerCase());for(var r=null,n=0;n<this._attributeList.length;n++){var i=this._attributeList[n];if(i._qualifiedName===e){r=i;break}}return null===r?(void 0===t||!0===t)&&((r=h.create_attr(this._nodeDocument,e))._value="",h.element_append(r,this),!0):void 0!==t&&!1!==t||(h.element_removeAnAttributeByName(e,this),!1)},t.prototype.hasAttributeNS=function(e,t){for(var r=e||null,n=0;n<this._attributeList.length;n++){var i=this._attributeList[n];if(i._namespace===r&&i._localName===t)return!0}return!1},t.prototype.getAttributeNode=function(e){return h.element_getAnAttributeByName(e,this)},t.prototype.getAttributeNodeNS=function(e,t){return h.element_getAnAttributeByNamespaceAndLocalName(e,t,this)},t.prototype.setAttributeNode=function(e){return h.element_setAnAttribute(e,this)},t.prototype.setAttributeNodeNS=function(e){return h.element_setAnAttribute(e,this)},t.prototype.removeAttributeNode=function(e){for(var t=!1,r=0;r<this._attributeList.length;r++){if(this._attributeList[r]===e){t=!0;break}}if(!t)throw new l.NotFoundError;return h.element_remove(e,this),e},t.prototype.attachShadow=function(e){if(this._namespace!==c.namespace.HTML)throw new l.NotSupportedError;if(!h.customElement_isValidCustomElementName(this._localName)&&!h.customElement_isValidShadowHostName(this._localName))throw new l.NotSupportedError;if(h.customElement_isValidCustomElementName(this._localName)||null!==this._is){var t=h.customElement_lookUpACustomElementDefinition(this._nodeDocument,this._namespace,this._localName,this._is);if(null!==t&&!0===t.disableShadow)throw new l.NotSupportedError}if(null!==this._shadowRoot)throw new l.NotSupportedError;var r=h.create_shadowRoot(this._nodeDocument,this);return r._mode=e.mode,this._shadowRoot=r,r},Object.defineProperty(t.prototype,"shadowRoot",{get:function(){var e=this._shadowRoot;return null===e||"closed"===e.mode?null:e},enumerable:!0,configurable:!0}),t.prototype.closest=function(e){throw new l.NotImplementedError},t.prototype.matches=function(e){throw new l.NotImplementedError},t.prototype.webkitMatchesSelector=function(e){return this.matches(e)},t.prototype.getElementsByTagName=function(e){return h.node_listOfElementsWithQualifiedName(e,this)},t.prototype.getElementsByTagNameNS=function(e,t){return h.node_listOfElementsWithNamespace(e,t,this)},t.prototype.getElementsByClassName=function(e){return h.node_listOfElementsWithClassNames(e,this)},t.prototype.insertAdjacentElement=function(e,t){return h.element_insertAdjacent(this,e,t)},t.prototype.insertAdjacentText=function(e,t){var r=h.create_text(this._nodeDocument,t);h.element_insertAdjacent(this,e,r)},Object.defineProperty(t.prototype,"_qualifiedName",{get:function(){return this._namespacePrefix?this._namespacePrefix+":"+this._localName:this._localName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_htmlUppercasedQualifiedName",{get:function(){var e=this._qualifiedName;return this._namespace===c.namespace.HTML&&"html"===this._nodeDocument._type&&(e=e.toUpperCase()),e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"children",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"firstElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"lastElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"childElementCount",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),t.prototype.prepend=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.append=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelector=function(e){throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelectorAll=function(e){throw new Error("Mixin: ParentNode not implemented.")},Object.defineProperty(t.prototype,"previousElementSibling",{get:function(){throw new Error("Mixin: NonDocumentTypeChildNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nextElementSibling",{get:function(){throw new Error("Mixin: NonDocumentTypeChildNode not implemented.")},enumerable:!0,configurable:!0}),t.prototype.before=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.after=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.replaceWith=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.remove=function(){throw new Error("Mixin: ChildNode not implemented.")},Object.defineProperty(t.prototype,"assignedSlot",{get:function(){throw new Error("Mixin: Slotable not implemented.")},enumerable:!0,configurable:!0}),t._create=function(e,r,n,i){void 0===n&&(n=null),void 0===i&&(i=null);var o=new t;return o._localName=r,o._namespace=n,o._namespacePrefix=i,o._nodeDocument=e,o},t}(u.NodeImpl);t.ElementImpl=f,p.idl_defineConst(f.prototype,"_nodeType",s.NodeType.Element)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(34),s=r(12),u=function(e){function t(t){void 0===t&&(t=null);var r=e.call(this)||this;return r._children=new Set,r._host=t,r}return i(t,e),t.prototype.getElementById=function(e){throw new Error("Mixin: NonElementParentNode not implemented.")},Object.defineProperty(t.prototype,"children",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"firstElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"lastElementChild",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"childElementCount",{get:function(){throw new Error("Mixin: ParentNode not implemented.")},enumerable:!0,configurable:!0}),t.prototype.prepend=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.append=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelector=function(e){throw new Error("Mixin: ParentNode not implemented.")},t.prototype.querySelectorAll=function(e){throw new Error("Mixin: ParentNode not implemented.")},t._create=function(e,r){void 0===r&&(r=null);var n=new t(r);return n._nodeDocument=e,n},t}(a.NodeImpl);t.DocumentFragmentImpl=u,s.idl_defineConst(u.prototype,"_nodeType",o.NodeType.DocumentFragment)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(2),s=r(71),u=r(0),l=r(12),c=function(e){function t(t){void 0===t&&(t="");var r=e.call(this,t)||this;return r._name="",r._assignedSlot=null,r}return i(t,e),Object.defineProperty(t.prototype,"wholeText",{get:function(){var e,t,r="";try{for(var n=o(u.text_contiguousTextNodes(this,!0)),i=n.next();!i.done;i=n.next()){r+=i.value._data}}catch(t){e={error:t}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}return r},enumerable:!0,configurable:!0}),t.prototype.splitText=function(e){return u.text_split(this,e)},Object.defineProperty(t.prototype,"assignedSlot",{get:function(){throw new Error("Mixin: Slotable not implemented.")},enumerable:!0,configurable:!0}),t._create=function(e,r){void 0===r&&(r="");var n=new t(r);return n._nodeDocument=e,n},t}(s.CharacterDataImpl);t.TextImpl=c,l.idl_defineConst(c.prototype,"_nodeType",a.NodeType.Text)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){}return Object.defineProperty(e.prototype,"_startNode",{get:function(){return this._start[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_startOffset",{get:function(){return this._start[1]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_endNode",{get:function(){return this._end[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_endOffset",{get:function(){return this._end[1]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_collapsed",{get:function(){return this._start[0]===this._end[0]&&this._start[1]===this._end[1]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"startContainer",{get:function(){return this._startNode},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"startOffset",{get:function(){return this._startOffset},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"endContainer",{get:function(){return this._endNode},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"endOffset",{get:function(){return this._endOffset},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"collapsed",{get:function(){return this._collapsed},enumerable:!0,configurable:!0}),e}();t.AbstractRangeImpl=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=function(){function e(e){this._activeFlag=!1,this._root=e,this._whatToShow=n.WhatToShow.All,this._filter=null}return Object.defineProperty(e.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"whatToShow",{get:function(){return this._whatToShow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"filter",{get:function(){return this._filter},enumerable:!0,configurable:!0}),e}();t.TraverserImpl=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=r(0),o=r(12),a=function(){function e(e,t){this._target=null,this._relatedTarget=null,this._touchTargetList=[],this._path=[],this._currentTarget=null,this._eventPhase=n.EventPhase.None,this._stopPropagationFlag=!1,this._stopImmediatePropagationFlag=!1,this._canceledFlag=!1,this._inPassiveListenerFlag=!1,this._composedFlag=!1,this._initializedFlag=!1,this._dispatchFlag=!1,this._isTrusted=!1,this._bubbles=!1,this._cancelable=!1,this._type=e,t&&(this._bubbles=t.bubbles||!1,this._cancelable=t.cancelable||!1,this._composedFlag=t.composed||!1),this._initializedFlag=!0,this._timeStamp=(new Date).getTime()}return Object.defineProperty(e.prototype,"type",{get:function(){return this._type},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"target",{get:function(){return this._target},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"srcElement",{get:function(){return this._target},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentTarget",{get:function(){return this._currentTarget},enumerable:!0,configurable:!0}),e.prototype.composedPath=function(){var e=[],t=this._path;if(0===t.length)return e;var r=this._currentTarget;if(null===r)throw new Error("Event currentTarget is null.");e.push(r);for(var n=0,i=0,o=t.length-1;o>=0;){if(t[o].rootOfClosedTree&&i++,t[o].invocationTarget===r){n=o;break}t[o].slotInClosedTree&&i--,o--}var a=i,s=i;for(o=n-1;o>=0;)t[o].rootOfClosedTree&&a++,a<=s&&e.unshift(t[o].invocationTarget),t[o].slotInClosedTree&&--a<s&&(s=a),o--;for(a=i,s=i,o=n+1;o<t.length;)t[o].slotInClosedTree&&a++,a<=s&&e.push(t[o].invocationTarget),t[o].rootOfClosedTree&&--a<s&&(s=a),o++;return e},Object.defineProperty(e.prototype,"eventPhase",{get:function(){return this._eventPhase},enumerable:!0,configurable:!0}),e.prototype.stopPropagation=function(){this._stopPropagationFlag=!0},Object.defineProperty(e.prototype,"cancelBubble",{get:function(){return this._stopPropagationFlag},set:function(e){e&&this.stopPropagation()},enumerable:!0,configurable:!0}),e.prototype.stopImmediatePropagation=function(){this._stopPropagationFlag=!0,this._stopImmediatePropagationFlag=!0},Object.defineProperty(e.prototype,"bubbles",{get:function(){return this._bubbles},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"cancelable",{get:function(){return this._cancelable},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"returnValue",{get:function(){return!this._canceledFlag},set:function(e){e||i.event_setTheCanceledFlag(this)},enumerable:!0,configurable:!0}),e.prototype.preventDefault=function(){i.event_setTheCanceledFlag(this)},Object.defineProperty(e.prototype,"defaultPrevented",{get:function(){return this._canceledFlag},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"composed",{get:function(){return this._composedFlag},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isTrusted",{get:function(){return this._isTrusted},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"timeStamp",{get:function(){return this._timeStamp},enumerable:!0,configurable:!0}),e.prototype.initEvent=function(e,t,r){void 0===t&&(t=!1),void 0===r&&(r=!1),this._dispatchFlag||i.event_initialize(this,e,t,r)},e.NONE=0,e.CAPTURING_PHASE=1,e.AT_TARGET=2,e.BUBBLING_PHASE=3,e}();t.EventImpl=a,o.idl_defineConst(a.prototype,"NONE",0),o.idl_defineConst(a.prototype,"CAPTURING_PHASE",1),o.idl_defineConst(a.prototype,"AT_TARGET",2),o.idl_defineConst(a.prototype,"BUBBLING_PHASE",3)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=r(9);t.traversal_filter=function(e,t){if(e._activeFlag)throw new i.InvalidStateError;var r=1<<t._nodeType-1;if(0==(e.whatToShow&r))return n.FilterResult.Skip;if(!e.filter)return n.FilterResult.Accept;e._activeFlag=!0;var o=n.FilterResult.Reject;try{o=e.filter.acceptNode(t)}catch(t){throw e._activeFlag=!1,t}return e._activeFlag=!1,o}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var o=r(6),a=r(3),s=r(1),u=r(99),l=r(73),c=r(17),h=r(173),p=r(30),f=r(52),d=r(37);t.document_elementInterface=function(e,t){return u.ElementImpl},t.document_internalCreateElementNS=function(e,t,r,i){var o=n(h.namespace_validateAndExtract(t,r),3),a=o[0],u=o[1],l=o[2],c=null;return void 0!==i&&(c=s.isString(i)?i:i.is),f.element_createAnElement(e,l,a,u,c,!0)},t.document_adopt=function(e,t){var r,n;if(e._nodeDocument!==t||null!==e._parent){var s=e._nodeDocument;if(e._parent&&d.mutation_remove(e,e._parent),t!==s)for(var u=c.tree_getFirstDescendantNode(e,!0,!0);null!==u;){if(u._nodeDocument=t,a.Guard.isElementNode(u))try{for(var h=(r=void 0,i(u._attributeList._asArray())),f=h.next();!f.done;f=h.next()){f.value._nodeDocument=t}}catch(e){r={error:e}}finally{try{f&&!f.done&&(n=h.return)&&n.call(h)}finally{if(r)throw r.error}}o.dom.features.customElements&&a.Guard.isElementNode(u)&&"custom"===u._customElementState&&l.customElement_enqueueACustomElementCallbackReaction(u,"adoptedCallback",[s,t]),o.dom.features.steps&&p.dom_runAdoptingSteps(u,s),u=c.tree_getNextDescendantNode(e,u,!0,!0)}}}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(3),a=r(9),s=r(17),u=r(51),l=r(30);t.characterData_replaceData=function(e,t,r,c){var h,p,f=s.tree_nodeLength(e);if(t>f)throw new a.IndexSizeError("Offset exceeds character data length. Offset: "+t+", Length: "+f+", Node is "+e.nodeName+".");t+r>f&&(r=f-t),i.dom.features.mutationObservers&&u.observer_queueMutationRecord("characterData",e,null,null,e._data,[],[],null,null);var d=e._data.substring(0,t)+c+e._data.substring(t+r);e._data=d;try{for(var m=n(i.dom.rangeList),y=m.next();!y.done;y=m.next()){var v=y.value;v._start[0]===e&&v._start[1]>t&&v._start[1]<=t+r&&(v._start[1]=t),v._end[0]===e&&v._end[1]>t&&v._end[1]<=t+r&&(v._end[1]=t),v._start[0]===e&&v._start[1]>t+r&&(v._start[1]+=c.length-r),v._end[0]===e&&v._end[1]>t+r&&(v._end[1]+=c.length-r)}}catch(e){h={error:e}}finally{try{y&&!y.done&&(p=m.return)&&p.call(m)}finally{if(h)throw h.error}}i.dom.features.steps&&o.Guard.isTextNode(e)&&null!==e._parent&&l.dom_runChildTextContentChangeSteps(e._parent)},t.characterData_substringData=function(e,t,r){var n=s.tree_nodeLength(e);if(t>n)throw new a.IndexSizeError("Offset exceeds character data length. Offset: "+t+", Length: "+n+", Node is "+e.nodeName+".");return t+r>n?e._data.substr(t):e._data.substr(t,r)}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e},o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(7);function s(e){var t=a.string.splitAStringOnASCIIWhitespace(e);return new Set(t)}function u(e){return i(e).join(" ")}t.orderedSet_parse=s,t.orderedSet_serialize=u,t.orderedSet_sanitize=function(e){return u(s(e))},t.orderedSet_contains=function(e,t,r){var n,i,a,s;try{for(var u=o(t),l=u.next();!l.done;l=u.next()){var c=l.value,h=!1;try{for(var p=(a=void 0,o(e)),f=p.next();!f.done;f=p.next()){var d=f.value;if(r){if(d===c){h=!0;break}}else if(d.toUpperCase()===c.toUpperCase()){h=!0;break}}}catch(e){a={error:e}}finally{try{f&&!f.done&&(s=p.return)&&s.call(p)}finally{if(a)throw a.error}}if(!h)return!1}}catch(e){n={error:e}}finally{try{l&&!l.done&&(i=u.return)&&i.call(u)}finally{if(n)throw n.error}}return!0}},function(e,t,r){"use strict";r(179),Object.defineProperty(t,"__esModule",{value:!0});var n=r(262),i=r(110),o=r(1);i.dom.setFeatures(!1),t.createDocument=function(){var e=(new n.DOMImplementation).createDocument(null,"root",null);return e.documentElement&&e.removeChild(e.documentElement),e},t.sanitizeInput=function(e,t){if(null==e)return e;if(void 0===t)return e+"";var r="";e+="";for(var n=0;n<e.length;n++){var i=e.charCodeAt(n);if(9===i||10===i||13===i||i>=32&&i<=55295||i>=57344&&i<=65533)r+=e.charAt(n);else if(i>=55296&&i<=56319&&n<e.length-1){var a=e.charCodeAt(n+1);a>=56320&&a<=57343?(i=1024*(i-55296)+a-56320+65536,r+=String.fromCodePoint(i),n++):r+=o.isString(t)?t:t(e.charAt(n),n,e)}else r+=o.isString(t)?t:t(e.charAt(n),n,e)}return r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(153);t.AbortController=i.AbortControllerImpl;var o=r(154);t.AbortSignal=o.AbortSignalImpl;var a=r(102);t.AbstractRange=a.AbstractRangeImpl;var s=r(157);t.Attr=s.AttrImpl;var u=r(158);t.CDATASection=u.CDATASectionImpl;var l=r(71);t.CharacterData=l.CharacterDataImpl;var c=r(263),h=r(159);t.Comment=h.CommentImpl;var p=r(171);t.CustomEvent=p.CustomEventImpl;var f=r(100);t.DocumentFragment=f.DocumentFragmentImpl;var d=r(98);t.Document=d.DocumentImpl;var m=r(264),y=r(155);t.DocumentType=y.DocumentTypeImpl;var v=r(6);t.dom=v.dom;var _=r(148);t.DOMImplementation=_.DOMImplementationImpl;var g=r(170);t.DOMTokenList=g.DOMTokenListImpl;var b=r(99);t.Element=b.ElementImpl;var x=r(104);t.Event=x.EventImpl;var w=r(70);t.EventTarget=w.EventTargetImpl;var E=r(161);t.HTMLCollection=E.HTMLCollectionImpl;var D=r(265);t.MutationObserver=D.MutationObserverImpl;var S=r(169);t.MutationRecord=S.MutationRecordImpl;var C=r(164);t.NamedNodeMap=C.NamedNodeMapImpl;var A=r(168);t.NodeFilter=A.NodeFilterImpl;var N=r(34);t.Node=N.NodeImpl;var T=r(166);t.NodeIterator=T.NodeIteratorImpl;var O=r(162);t.NodeList=O.NodeListImpl;var F=r(163);t.NodeListStatic=F.NodeListStaticImpl;var k=r(266),P=r(267),I=r(268),L=r(160);t.ProcessingInstruction=L.ProcessingInstructionImpl;var M=r(165);t.Range=M.RangeImpl;var B=r(156);t.ShadowRoot=B.ShadowRootImpl;var j=r(269),R=r(270);t.StaticRange=R.StaticRangeImpl;var z=r(101);t.Text=z.TextImpl;var U=r(103);t.Traverser=U.TraverserImpl;var G=r(167);t.TreeWalker=G.TreeWalkerImpl;var X=r(149);t.Window=X.WindowImpl;var q=r(151);t.XMLDocument=q.XMLDocumentImpl,n.applyMixin(b.ElementImpl,c.ChildNodeImpl),n.applyMixin(l.CharacterDataImpl,c.ChildNodeImpl),n.applyMixin(y.DocumentTypeImpl,c.ChildNodeImpl),n.applyMixin(d.DocumentImpl,m.DocumentOrShadowRootImpl),n.applyMixin(B.ShadowRootImpl,m.DocumentOrShadowRootImpl),n.applyMixin(b.ElementImpl,k.NonDocumentTypeChildNodeImpl),n.applyMixin(l.CharacterDataImpl,k.NonDocumentTypeChildNodeImpl),n.applyMixin(d.DocumentImpl,P.NonElementParentNodeImpl),n.applyMixin(f.DocumentFragmentImpl,P.NonElementParentNodeImpl),n.applyMixin(d.DocumentImpl,I.ParentNodeImpl),n.applyMixin(f.DocumentFragmentImpl,I.ParentNodeImpl),n.applyMixin(b.ElementImpl,I.ParentNodeImpl),n.applyMixin(z.TextImpl,j.SlotableImpl),n.applyMixin(b.ElementImpl,j.SlotableImpl)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.EOF=0]="EOF",e[e.Declaration=1]="Declaration",e[e.DocType=2]="DocType",e[e.Element=3]="Element",e[e.Text=4]="Text",e[e.CDATA=5]="CDATA",e[e.PI=6]="PI",e[e.Comment=7]="Comment",e[e.ClosingTag=8]="ClosingTag"}(t.TokenType||(t.TokenType={}))},function(e,t,r){"use strict";r(64),r(20),r(66);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(1),a=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return i(t,e),t.prototype._parse=function(e,t){var r=this,n=this._builderOptions,i=null;return o.isFunction(t)?i=this.parse(e,t.apply(this)):o.isArray(t)||o.isSet(t)?o.forEachArray(t,(function(t){return i=r.parse(e,t)}),this):o.isMap(t)||o.isObject(t)?o.forEachObject(t,(function(t,a){if(o.isFunction(a)&&(a=a.apply(r)),n.ignoreConverters||0!==t.indexOf(n.convert.att))if(n.ignoreConverters||0!==t.indexOf(n.convert.text))if(n.ignoreConverters||0!==t.indexOf(n.convert.cdata))if(n.ignoreConverters||0!==t.indexOf(n.convert.comment))if(n.ignoreConverters||0!==t.indexOf(n.convert.ins))if((o.isArray(a)||o.isSet(a))&&o.isEmpty(a));else if((o.isMap(a)||o.isObject(a))&&o.isEmpty(a))i=r.element(e,void 0,r.sanitize(t))||i;else if(n.keepNullNodes||null!=a)if(o.isArray(a)||o.isSet(a))o.forEachArray(a,(function(n){var o={};o[t]=n,i=r.parse(e,o)}),r);else if(o.isMap(a)||o.isObject(a)){(s=r.element(e,void 0,r.sanitize(t)))&&(i=s,r.parse(s,a))}else if(null!=a&&""!==a){var s;(s=r.element(e,void 0,r.sanitize(t)))&&(i=s,r.text(s,r._decodeText(r.sanitize(a))))}else i=r.element(e,void 0,r.sanitize(t))||i;else;else if(o.isString(a)){var u=a.indexOf(" "),l=-1===u?a:a.substr(0,u),c=-1===u?"":a.substr(u+1);i=r.instruction(e,r.sanitize(l),r.sanitize(c))||i}else o.isArray(a)||o.isSet(a)?o.forEachArray(a,(function(t){var n=t.indexOf(" "),o=-1===n?t:t.substr(0,n),a=-1===n?"":t.substr(n+1);i=r.instruction(e,r.sanitize(o),r.sanitize(a))||i}),r):o.forEachObject(a,(function(t,n){return i=r.instruction(e,r.sanitize(t),r.sanitize(n))||i}),r);else o.isArray(a)||o.isSet(a)?o.forEachArray(a,(function(t){return i=r.comment(e,r.sanitize(t))||i}),r):i=r.comment(e,r.sanitize(a))||i;else o.isArray(a)||o.isSet(a)?o.forEachArray(a,(function(t){return i=r.cdata(e,r.sanitize(t))||i}),r):i=r.cdata(e,r.sanitize(a))||i;else i=o.isMap(a)||o.isObject(a)?r.parse(e,a):r.text(e,r._decodeText(r.sanitize(a)))||i;else if(t===n.convert.att){if(o.isArray(a)||o.isSet(a))throw new Error("Invalid attribute: "+a.toString()+". "+e._debugInfo());o.forEachObject(a,(function(t,n){i=r.attribute(e,void 0,r.sanitize(t),r._decodeAttributeValue(r.sanitize(n)))||i}))}else i=r.attribute(e,void 0,r.sanitize(t.substr(n.convert.att.length)),r._decodeAttributeValue(r.sanitize(a)))||i}),this):(n.keepNullNodes||null!=t)&&(i=this.text(e,this._decodeText(this.sanitize(t)))||i),i||e},t}(r(75).BaseReader);t.ObjectReader=a},function(e,t,r){"use strict";var n=r(39);e.exports=new n({explicit:[r(286),r(287),r(288)]})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(e){this.level=0,this._builderOptions=e,this._writerOptions=e};t.BaseCBWriter=n},function(e,t,r){var n=r(16),i=r(8),o=r(116);e.exports=!n&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(e,t,r){var n=r(11),i=r(13),o=n.document,a=i(o)&&i(o.createElement);e.exports=function(e){return a?o.createElement(e):{}}},function(e,t,r){var n=r(118),i=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(e){return i.call(e)}),e.exports=n.inspectSource},function(e,t,r){var n=r(11),i=r(80),o=n["__core-js_shared__"]||i("__core-js_shared__",{});e.exports=o},function(e,t,r){var n=r(14),i=r(187),o=r(55),a=r(15);e.exports=function(e,t){for(var r=i(t),s=a.f,u=o.f,l=0;l<r.length;l++){var c=r[l];n(e,c)||s(e,c,u(t,c))}}},function(e,t,r){var n=r(11);e.exports=n},function(e,t,r){var n=r(14),i=r(24),o=r(122).indexOf,a=r(45);e.exports=function(e,t){var r,s=i(e),u=0,l=[];for(r in s)!n(a,r)&&n(s,r)&&l.push(r);for(;t.length>u;)n(s,r=t[u++])&&(~o(l,r)||l.push(r));return l}},function(e,t,r){var n=r(24),i=r(26),o=r(83),a=function(e){return function(t,r,a){var s,u=n(t),l=i(u.length),c=o(a,l);if(e&&r!=r){for(;l>c;)if((s=u[c++])!=s)return!0}else for(;l>c;c++)if((e||c in u)&&u[c]===r)return e||c||0;return!e&&-1}};e.exports={includes:a(!0),indexOf:a(!1)}},function(e,t,r){var n=r(8),i=/#|\.prototype\./,o=function(e,t){var r=s[a(e)];return r==l||r!=u&&("function"==typeof t?n(t):!!t)},a=o.normalize=function(e){return String(e).replace(i,".").toLowerCase()},s=o.data={},u=o.NATIVE="N",l=o.POLYFILL="P";e.exports=o},function(e,t,r){var n=r(86);e.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(e,t,r){var n=r(5);t.f=n},function(e,t,r){var n=r(120),i=r(14),o=r(125),a=r(15).f;e.exports=function(e){var t=n.Symbol||(n.Symbol={});i(t,e)||a(t,e,{value:o.f(e)})}},function(e,t){e.exports=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e}},function(e,t,r){var n=r(13),i=r(59),o=r(5)("species");e.exports=function(e,t){var r;return i(e)&&("function"!=typeof(r=e.constructor)||r!==Array&&!i(r.prototype)?n(r)&&null===(r=r[o])&&(r=void 0):r=void 0),new(void 0===r?Array:r)(0===t?0:t)}},function(e,t,r){var n,i,o=r(11),a=r(193),s=o.process,u=s&&s.versions,l=u&&u.v8;l?i=(n=l.split("."))[0]+n[1]:a&&(!(n=a.match(/Edge\/(\d+)/))||n[1]>=74)&&(n=a.match(/Chrome\/(\d+)/))&&(i=n[1]),e.exports=i&&+i},function(e,t,r){var n=r(5),i=r(60),o=r(15),a=n("unscopables"),s=Array.prototype;null==s[a]&&o.f(s,a,{configurable:!0,value:i(null)}),e.exports=function(e){s[a][e]=!0}},function(e,t,r){"use strict";var n,i,o,a=r(132),s=r(21),u=r(14),l=r(5),c=r(44),h=l("iterator"),p=!1;[].keys&&("next"in(o=[].keys())?(i=a(a(o)))!==Object.prototype&&(n=i):p=!0),null==n&&(n={}),c||u(n,h)||s(n,h,(function(){return this})),e.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:p}},function(e,t,r){var n=r(14),i=r(27),o=r(57),a=r(196),s=o("IE_PROTO"),u=Object.prototype;e.exports=a?Object.getPrototypeOf:function(e){return e=i(e),n(e,s)?e[s]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?u:null}},function(e,t,r){var n=r(18),i=r(197);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,r={};try{(e=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),t=r instanceof Array}catch(e){}return function(r,o){return n(r),i(o),t?e.call(r,o):r.__proto__=o,r}}():void 0)},function(e,t,r){"use strict";var n=r(56),i=r(15),o=r(40);e.exports=function(e,t,r){var a=n(t);a in e?i.f(e,a,o(0,r)):e[a]=r}},function(e,t,r){var n=r(90),i=r(42),o=r(5)("toStringTag"),a="Arguments"==i(function(){return arguments}());e.exports=n?i:function(e){var t,r,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),o))?r:a?i(t):"Object"==(n=i(t))&&"function"==typeof t.callee?"Arguments":n}},function(e,t,r){"use strict";var n=r(18);e.exports=function(){var e=n(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t}},function(e,t,r){var n=r(47),i=r(35),o=function(e){return function(t,r){var o,a,s=String(i(t)),u=n(r),l=s.length;return u<0||u>=l?e?"":void 0:(o=s.charCodeAt(u))<55296||o>56319||u+1===l||(a=s.charCodeAt(u+1))<56320||a>57343?e?s.charAt(u):o:e?s.slice(u,u+2):a-56320+(o-55296<<10)+65536}};e.exports={codeAt:o(!1),charAt:o(!0)}},function(e,t,r){var n=r(4),i=r(27),o=r(61);n({target:"Object",stat:!0,forced:r(8)((function(){o(1)}))},{keys:function(e){return o(i(e))}})},function(e,t,r){"use strict";var n=r(4),i=r(11),o=r(123),a=r(25),s=r(140),u=r(141),l=r(142),c=r(13),h=r(8),p=r(208),f=r(62),d=r(209);e.exports=function(e,t,r){var m=-1!==e.indexOf("Map"),y=-1!==e.indexOf("Weak"),v=m?"set":"add",_=i[e],g=_&&_.prototype,b=_,x={},w=function(e){var t=g[e];a(g,e,"add"==e?function(e){return t.call(this,0===e?0:e),this}:"delete"==e?function(e){return!(y&&!c(e))&&t.call(this,0===e?0:e)}:"get"==e?function(e){return y&&!c(e)?void 0:t.call(this,0===e?0:e)}:"has"==e?function(e){return!(y&&!c(e))&&t.call(this,0===e?0:e)}:function(e,r){return t.call(this,0===e?0:e,r),this})};if(o(e,"function"!=typeof _||!(y||g.forEach&&!h((function(){(new _).entries().next()})))))b=r.getConstructor(t,e,m,v),s.REQUIRED=!0;else if(o(e,!0)){var E=new b,D=E[v](y?{}:-0,1)!=E,S=h((function(){E.has(1)})),C=p((function(e){new _(e)})),A=!y&&h((function(){for(var e=new _,t=5;t--;)e[v](t,t);return!e.has(-0)}));C||((b=t((function(t,r){l(t,b,e);var n=d(new _,t,b);return null!=r&&u(r,n[v],n,m),n}))).prototype=g,g.constructor=b),(S||A)&&(w("delete"),w("has"),m&&w("get")),(A||D)&&w(v),y&&g.clear&&delete g.clear}return x[e]=b,n({global:!0,forced:b!=_},x),f(b,e),y||r.setStrong(b,e,m),b}},function(e,t,r){var n=r(45),i=r(13),o=r(14),a=r(15).f,s=r(58),u=r(204),l=s("meta"),c=0,h=Object.isExtensible||function(){return!0},p=function(e){a(e,l,{value:{objectID:"O"+ ++c,weakData:{}}})},f=e.exports={REQUIRED:!1,fastKey:function(e,t){if(!i(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!o(e,l)){if(!h(e))return"F";if(!t)return"E";p(e)}return e[l].objectID},getWeakData:function(e,t){if(!o(e,l)){if(!h(e))return!0;if(!t)return!1;p(e)}return e[l].weakData},onFreeze:function(e){return u&&f.REQUIRED&&h(e)&&!o(e,l)&&p(e),e}};n[l]=!0},function(e,t,r){var n=r(18),i=r(205),o=r(26),a=r(87),s=r(206),u=r(207),l=function(e,t){this.stopped=e,this.result=t};(e.exports=function(e,t,r,c,h){var p,f,d,m,y,v,_,g=a(t,r,c?2:1);if(h)p=e;else{if("function"!=typeof(f=s(e)))throw TypeError("Target is not iterable");if(i(f)){for(d=0,m=o(e.length);m>d;d++)if((y=c?g(n(_=e[d])[0],_[1]):g(e[d]))&&y instanceof l)return y;return new l(!1)}p=f.call(e)}for(v=p.next;!(_=v.call(p)).done;)if("object"==typeof(y=u(p,g,_.value,c))&&y&&y instanceof l)return y;return new l(!1)}).stop=function(e){return new l(!0,e)}},function(e,t){e.exports=function(e,t,r){if(!(e instanceof t))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return e}},function(e,t,r){"use strict";var n=r(15).f,i=r(60),o=r(210),a=r(87),s=r(142),u=r(141),l=r(88),c=r(211),h=r(16),p=r(140).fastKey,f=r(43),d=f.set,m=f.getterFor;e.exports={getConstructor:function(e,t,r,l){var c=e((function(e,n){s(e,c,t),d(e,{type:t,index:i(null),first:void 0,last:void 0,size:0}),h||(e.size=0),null!=n&&u(n,e[l],e,r)})),f=m(t),y=function(e,t,r){var n,i,o=f(e),a=v(e,t);return a?a.value=r:(o.last=a={index:i=p(t,!0),key:t,value:r,previous:n=o.last,next:void 0,removed:!1},o.first||(o.first=a),n&&(n.next=a),h?o.size++:e.size++,"F"!==i&&(o.index[i]=a)),e},v=function(e,t){var r,n=f(e),i=p(t);if("F"!==i)return n.index[i];for(r=n.first;r;r=r.next)if(r.key==t)return r};return o(c.prototype,{clear:function(){for(var e=f(this),t=e.index,r=e.first;r;)r.removed=!0,r.previous&&(r.previous=r.previous.next=void 0),delete t[r.index],r=r.next;e.first=e.last=void 0,h?e.size=0:this.size=0},delete:function(e){var t=f(this),r=v(this,e);if(r){var n=r.next,i=r.previous;delete t.index[r.index],r.removed=!0,i&&(i.next=n),n&&(n.previous=i),t.first==r&&(t.first=n),t.last==r&&(t.last=i),h?t.size--:this.size--}return!!r},forEach:function(e){for(var t,r=f(this),n=a(e,arguments.length>1?arguments[1]:void 0,3);t=t?t.next:r.first;)for(n(t.value,t.key,this);t&&t.removed;)t=t.previous},has:function(e){return!!v(this,e)}}),o(c.prototype,r?{get:function(e){var t=v(this,e);return t&&t.value},set:function(e,t){return y(this,0===e?0:e,t)}}:{add:function(e){return y(this,e=0===e?0:e,e)}}),h&&n(c.prototype,"size",{get:function(){return f(this).size}}),c},setStrong:function(e,t,r){var n=t+" Iterator",i=m(t),o=m(n);l(e,t,(function(e,t){d(this,{type:n,target:e,state:i(e),kind:t,last:void 0})}),(function(){for(var e=o(this),t=e.kind,r=e.last;r&&r.removed;)r=r.previous;return e.target&&(e.last=r=r?r.next:e.state.first)?"keys"==t?{value:r.key,done:!1}:"values"==t?{value:r.value,done:!1}:{value:[r.key,r.value],done:!1}:(e.target=void 0,{value:void 0,done:!0})}),r?"entries":"values",!r,!0),c(t)}}},function(e,t,r){"use strict";var n,i=r(4),o=r(55).f,a=r(26),s=r(222),u=r(35),l=r(224),c=r(44),h="".endsWith,p=Math.min,f=l("endsWith");i({target:"String",proto:!0,forced:!!(c||f||(n=o(String.prototype,"endsWith"),!n||n.writable))&&!f},{endsWith:function(e){var t=String(u(this));s(e);var r=arguments.length>1?arguments[1]:void 0,n=a(t.length),i=void 0===r?n:p(a(r),n),o=String(e);return h?h.call(t,o,i):t.slice(i-o.length,i)===o}})},function(e,t,r){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
var n=r(229),i=r(230),o=r(231);function a(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(e,t){if(a()<t)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=u.prototype:(null===e&&(e=new u(t)),e.length=t),e}function u(e,t,r){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return h(this,e)}return l(this,e,t,r)}function l(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);u.TYPED_ARRAY_SUPPORT?(e=t).__proto__=u.prototype:e=p(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!u.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|d(t,r),i=(e=s(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function(e,t){if(u.isBuffer(t)){var r=0|f(t.length);return 0===(e=s(e,r)).length||t.copy(e,0,0,r),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?s(e,0):p(e,t);if("Buffer"===t.type&&o(t.data))return p(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function h(e,t){if(c(t),e=s(e,t<0?0:0|f(t)),!u.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function p(e,t){var r=t.length<0?0:0|f(t.length);e=s(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function f(e){if(e>=a())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a().toString(16)+" bytes");return 0|e}function d(e,t){if(u.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return z(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return U(e).length;default:if(n)return z(e).length;t=(""+t).toLowerCase(),n=!0}}function m(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return T(this,t,r);case"utf8":case"utf-8":return C(this,t,r);case"ascii":return A(this,t,r);case"latin1":case"binary":return N(this,t,r);case"base64":return S(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function y(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function v(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=u.from(t,n)),u.isBuffer(t))return 0===t.length?-1:_(e,t,r,n,i);if("number"==typeof t)return t&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):_(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function _(e,t,r,n,i){var o,a=1,s=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,u/=2,r/=2}function l(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(i){var c=-1;for(o=r;o<s;o++)if(l(e,o)===l(t,-1===c?0:o-c)){if(-1===c&&(c=o),o-c+1===u)return c*a}else-1!==c&&(o-=o-c),c=-1}else for(r+u>s&&(r=s-u),o=r;o>=0;o--){for(var h=!0,p=0;p<u;p++)if(l(e,o+p)!==l(t,p)){h=!1;break}if(h)return o}return-1}function g(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(t.substr(2*a,2),16);if(isNaN(s))return a;e[r+a]=s}return a}function b(e,t,r,n){return G(z(t,e.length-r),e,r,n)}function x(e,t,r,n){return G(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function w(e,t,r,n){return x(e,t,r,n)}function E(e,t,r,n){return G(U(t),e,r,n)}function D(e,t,r,n){return G(function(e,t){for(var r,n,i,o=[],a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function S(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function C(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o,a,s,u,l=e[i],c=null,h=l>239?4:l>223?3:l>191?2:1;if(i+h<=r)switch(h){case 1:l<128&&(c=l);break;case 2:128==(192&(o=e[i+1]))&&(u=(31&l)<<6|63&o)>127&&(c=u);break;case 3:o=e[i+1],a=e[i+2],128==(192&o)&&128==(192&a)&&(u=(15&l)<<12|(63&o)<<6|63&a)>2047&&(u<55296||u>57343)&&(c=u);break;case 4:o=e[i+1],a=e[i+2],s=e[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(u=(15&l)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&u<1114112&&(c=u)}null===c?(c=65533,h=1):c>65535&&(c-=65536,n.push(c>>>10&1023|55296),c=56320|1023&c),n.push(c),i+=h}return function(e){var t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=4096));return r}(n)}t.Buffer=u,t.SlowBuffer=function(e){+e!=e&&(e=0);return u.alloc(+e)},t.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=a(),u.poolSize=8192,u._augment=function(e){return e.__proto__=u.prototype,e},u.from=function(e,t,r){return l(null,e,t,r)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(e,t,r){return function(e,t,r,n){return c(t),t<=0?s(e,t):void 0!==r?"string"==typeof n?s(e,t).fill(r,n):s(e,t).fill(r):s(e,t)}(null,e,t,r)},u.allocUnsafe=function(e){return h(null,e)},u.allocUnsafeSlow=function(e){return h(null,e)},u.isBuffer=function(e){return!(null==e||!e._isBuffer)},u.compare=function(e,t){if(!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(e,t){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=u.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var a=e[r];if(!u.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(n,i),i+=a.length}return n},u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)y(this,t,t+1);return this},u.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)y(this,t,t+3),y(this,t+1,t+2);return this},u.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)y(this,t,t+7),y(this,t+1,t+6),y(this,t+2,t+5),y(this,t+3,t+4);return this},u.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?C(this,0,e):m.apply(this,arguments)},u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},u.prototype.compare=function(e,t,r,n,i){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0),s=Math.min(o,a),l=this.slice(n,i),c=e.slice(t,r),h=0;h<s;++h)if(l[h]!==c[h]){o=l[h],a=c[h];break}return o<a?-1:a<o?1:0},u.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},u.prototype.indexOf=function(e,t,r){return v(this,e,t,r,!0)},u.prototype.lastIndexOf=function(e,t,r){return v(this,e,t,r,!1)},u.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return g(this,e,t,r);case"utf8":case"utf-8":return b(this,e,t,r);case"ascii":return x(this,e,t,r);case"latin1":case"binary":return w(this,e,t,r);case"base64":return E(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function A(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function N(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function T(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=t;o<r;++o)i+=R(e[o]);return i}function O(e,t,r){for(var n=e.slice(t,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function F(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function k(e,t,r,n,i,o){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function P(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-r,2);i<o;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function I(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-r,4);i<o;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function L(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function M(e,t,r,n,o){return o||L(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function B(e,t,r,n,o){return o||L(e,0,r,8),i.write(e,t,r,n,52,8),r+8}u.prototype.slice=function(e,t){var r,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),u.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=u.prototype;else{var i=t-e;r=new u(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+e]}return r},u.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||F(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},u.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||F(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},u.prototype.readUInt8=function(e,t){return t||F(e,1,this.length),this[e]},u.prototype.readUInt16LE=function(e,t){return t||F(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUInt16BE=function(e,t){return t||F(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUInt32LE=function(e,t){return t||F(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUInt32BE=function(e,t){return t||F(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||F(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},u.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||F(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},u.prototype.readInt8=function(e,t){return t||F(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){t||F(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(e,t){t||F(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(e,t){return t||F(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return t||F(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readFloatLE=function(e,t){return t||F(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return t||F(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return t||F(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return t||F(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||k(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},u.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||k(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},u.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,1,255,0),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},u.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):P(this,e,t,!0),t+2},u.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):P(this,e,t,!1),t+2},u.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):I(this,e,t,!0),t+4},u.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):I(this,e,t,!1),t+4},u.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);k(this,e,t,r,i-1,-i)}var o=0,a=1,s=0;for(this[t]=255&e;++o<r&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},u.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);k(this,e,t,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},u.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,1,127,-128),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):P(this,e,t,!0),t+2},u.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):P(this,e,t,!1),t+2},u.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):I(this,e,t,!0),t+4},u.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):I(this,e,t,!1),t+4},u.prototype.writeFloatLE=function(e,t,r){return M(this,e,t,!0,r)},u.prototype.writeFloatBE=function(e,t,r){return M(this,e,t,!1,r)},u.prototype.writeDoubleLE=function(e,t,r){return B(this,e,t,!0,r)},u.prototype.writeDoubleBE=function(e,t,r){return B(this,e,t,!1,r)},u.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},u.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var a=u.isBuffer(e)?e:z(new u(e,n).toString()),s=a.length;for(o=0;o<r-t;++o)this[o+t]=a[o%s]}return this};var j=/[^+\/0-9A-Za-z-_]/g;function R(e){return e<16?"0"+e.toString(16):e.toString(16)}function z(e,t){var r;t=t||1/0;for(var n=e.length,i=null,o=[],a=0;a<n;++a){if((r=e.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function U(e){return n.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(j,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function G(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}}).call(this,r(78))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isASCIIByte=function(e){return e>=0&&e<=127}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0}),t.length=function(e){return e.length},t.byteLowercase=function(e){for(var t=0;t<e.length;t++){var r=e[t];r>=65&&r<=90&&(e[t]=r+32)}},t.byteUppercase=function(e){for(var t=0;t<e.length;t++){var r=e[t];r>=97&&r<=122&&(e[t]=r-32)}},t.byteCaseInsensitiveMatch=function(e,t){if(e.length!==t.length)return!1;for(var r=0;r<e.length;r++){var n=e[r],i=t[r];if(n>=65&&n<=90&&(n+=32),i>=65&&i<=90&&(i+=32),n!==i)return!1}return!0},t.startsWith=function(e,t){for(var r=0;;){if(r>=e.length)return!1;if(r>=t.length)return!0;if(e[r]!==t[r])return!1;r++}},t.byteLessThan=function(e,t){for(var r=0;;){if(r>=e.length)return!1;if(r>=t.length)return!0;var n=e[r],i=t[r];if(n<i)return!0;if(n>i)return!1;r++}},t.isomorphicDecode=function(e){return String.fromCodePoint.apply(String,i(e))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),i=r(7),o=r(0),a=r(12),s=function(){function e(e){this._associatedDocument=e||n.dom.window.document}return e.prototype.createDocumentType=function(e,t,r){return o.namespace_validate(e),o.create_documentType(this._associatedDocument,e,t,r)},e.prototype.createDocument=function(e,t,r){void 0===r&&(r=null);var n=o.create_xmlDocument(),a=null;return t&&(a=o.document_internalCreateElementNS(n,e,t)),r&&n.appendChild(r),a&&n.appendChild(a),n._origin=this._associatedDocument._origin,e===i.namespace.HTML?n._contentType="application/xhtml+xml":e===i.namespace.SVG?n._contentType="image/svg+xml":n._contentType="application/xml",n},e.prototype.createHTMLDocument=function(e){var t=o.create_document();t._type="html",t._contentType="text/html",t.appendChild(o.create_documentType(t,"html","",""));var r=o.element_createAnElement(t,"html",i.namespace.HTML);t.appendChild(r);var n=o.element_createAnElement(t,"head",i.namespace.HTML);if(r.appendChild(n),void 0!==e){var a=o.element_createAnElement(t,"title",i.namespace.HTML);n.appendChild(a);var s=o.create_text(t,e);a.appendChild(s)}var u=o.element_createAnElement(t,"body",i.namespace.HTML);return r.appendChild(u),t._origin=this._associatedDocument._origin,t},e.prototype.hasFeature=function(){return!0},e._create=function(t){return new e(t)},e}();t.DOMImplementationImpl=s,a.idl_defineConst(s.prototype,"_ID","@oozcitak/dom")},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(70),a=r(1),s=r(0),u=function(e){function t(){var t=e.call(this)||this;return t._signalSlots=new Set,t._mutationObserverMicrotaskQueued=!1,t._mutationObservers=new Set,t._iteratorList=new a.FixedSizeSet,t._associatedDocument=s.create_document(),t}return i(t,e),Object.defineProperty(t.prototype,"document",{get:function(){return this._associatedDocument},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"event",{get:function(){return this._currentEvent},enumerable:!0,configurable:!0}),t._create=function(){return new t},t}(o.EventTargetImpl);t.WindowImpl=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=function(){function e(){}return e.isNode=function(e){return!!e&&void 0!==e._nodeType},e.isDocumentNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.Document},e.isDocumentTypeNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.DocumentType},e.isDocumentFragmentNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.DocumentFragment},e.isAttrNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.Attribute},e.isCharacterDataNode=function(t){if(!e.isNode(t))return!1;var r=t._nodeType;return r===n.NodeType.Text||r===n.NodeType.ProcessingInstruction||r===n.NodeType.Comment||r===n.NodeType.CData},e.isTextNode=function(t){return e.isNode(t)&&(t._nodeType===n.NodeType.Text||t._nodeType===n.NodeType.CData)},e.isExclusiveTextNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.Text},e.isCDATASectionNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.CData},e.isCommentNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.Comment},e.isProcessingInstructionNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.ProcessingInstruction},e.isElementNode=function(t){return e.isNode(t)&&t._nodeType===n.NodeType.Element},e.isCustomElementNode=function(t){return e.isElementNode(t)&&"custom"===t._customElementState},e.isShadowRoot=function(e){return!!e&&void 0!==e.host},e.isMouseEvent=function(e){return!!e&&void 0!==e.screenX&&null!=e.screenY},e.isSlotable=function(t){return!!t&&void 0!==t._name&&void 0!==t._assignedSlot&&(e.isTextNode(t)||e.isElementNode(t))},e.isSlot=function(t){return!!t&&void 0!==t._name&&void 0!==t._assignedNodes&&e.isElementNode(t)},e.isWindow=function(e){return!!e&&void 0!==e.navigator},e.isEventListener=function(e){return!!e&&void 0!==e.handleEvent},e.isRegisteredObserver=function(e){return!!e&&void 0!==e.observer&&void 0!==e.options},e.isTransientRegisteredObserver=function(t){return!!t&&void 0!==t.source&&e.isRegisteredObserver(t)},e}();t.Guard=i},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(){return e.call(this)||this}return i(t,e),t}(r(98).DocumentImpl);t.XMLDocumentImpl=o},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var o,a=r(1),s=r(243),u=r(7),l=r(244),c={ftp:21,file:null,http:80,https:443,ws:80,wss:443},h=/[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,p=/[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,f=/[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,d=/[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,m=/[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/,y=/[\0\t\f\r #%/:?@\[\\\]]/;function v(e){void 0!==o&&o.call(null,"Validation Error: "+e)}function _(){return{scheme:"",username:"",password:"",host:null,port:null,path:[],query:null,fragment:null,_cannotBeABaseURLFlag:!1,_blobURLEntry:null}}function g(e){return e in c}function b(e){return g(e.scheme)}function x(e){return c[e]||null}function w(e){return""!==e.username||""!==e.password}function E(e,t){var r,i;void 0===t&&(t=!1);var o=e.scheme+":";if(null!==e.host?(o+="//",w(e)&&(o+=e.username,""!==e.password&&(o+=":"+e.password),o+="@"),o+=D(e.host),null!==e.port&&(o+=":"+e.port)):null===e.host&&"file"===e.scheme&&(o+="//"),e._cannotBeABaseURLFlag)o+=e.path[0];else try{for(var a=n(e.path),s=a.next();!s.done;s=a.next()){o+="/"+s.value}}catch(e){r={error:e}}finally{try{s&&!s.done&&(i=a.return)&&i.call(a)}finally{if(r)throw r.error}}return null!==e.query&&(o+="?"+e.query),t||null===e.fragment||(o+="#"+e.fragment),o}function D(e){return a.isNumber(e)?S(e):a.isArray(e)?"["+C(e)+"]":e}function S(e){for(var t="",r=e,n=1;n<=4;n++)t=(r%256).toString()+t,4!==n&&(t="."+t),r=Math.floor(r/256);return t}function C(e){for(var t="",r=null,n=-1,i=0,o=0,a=0;a<8;a++)if(0===e[a]){i=1;for(var s=a+1;s<8&&0===e[s];s++)i++;i>o&&(o=i,n=a)}o>1&&(r=n);for(var u=!1,l=0;l<8;l++)u&&0===e[l]||(u&&(u=!1),r!==l?(t+=e[l].toString(16),7!==l&&(t+=":")):(t+=0===l?"::":":",u=!0));return t}function A(e,t,r,i,o){var l,c,y,_;if(void 0===i){i={scheme:"",username:"",password:"",host:null,port:null,path:[],query:null,fragment:null,_cannotBeABaseURLFlag:!1,_blobURLEntry:null};var E=/^[\u0000-\u001F\u0020]+/,D=/[\u0000-\u001F\u0020]+$/;(E.test(e)||D.test(e))&&v("Input string contains leading or trailing control characters or space."),e=(e=e.replace(E,"")).replace(D,"")}var S=/[\u0009\u000A\u000D]/g;S.test(e)&&v("Input string contains tab or newline characters."),e=e.replace(S,"");var C=void 0===o?s.ParserState.SchemeStart:o;void 0===t&&(t=null);for(var A=void 0===r||"replacement"===r||"UTF-16BE"===r||"UTF-16LE"===r?"UTF-8":r,L="",M=!1,B=!1,j=!1,R=new a.StringWalker(e);;){switch(C){case s.ParserState.SchemeStart:if(u.codePoint.ASCIIAlpha.test(R.c()))L+=R.c().toLowerCase(),C=s.ParserState.Scheme;else{if(void 0!==o)return v("Invalid scheme start character."),null;C=s.ParserState.NoScheme,R.pointer--}break;case s.ParserState.Scheme:if(u.codePoint.ASCIIAlphanumeric.test(R.c())||"+"===R.c()||"-"===R.c()||"."===R.c())L+=R.c().toLowerCase();else{if(":"!==R.c()){if(void 0===o){L="",C=s.ParserState.NoScheme,R.pointer=0;continue}return v("Invalid input string."),null}if(void 0!==o){if(g(i.scheme)&&!g(L))return i;if(!g(i.scheme)&&g(L))return i;if((w(i)||null!==i.port)&&"file"===L)return i;if("file"===i.scheme&&(""===i.host||null===i.host))return i}if(i.scheme=L,void 0!==o)return i.port===x(i.scheme)&&(i.port=null),i;L="","file"===i.scheme?(R.remaining().startsWith("//")||v("Invalid file URL scheme, '//' expected."),C=s.ParserState.File):b(i)&&null!==t&&t.scheme===i.scheme?C=s.ParserState.SpecialRelativeOrAuthority:b(i)?C=s.ParserState.SpecialAuthoritySlashes:R.remaining().startsWith("/")?(C=s.ParserState.PathOrAuthority,R.pointer++):(i._cannotBeABaseURLFlag=!0,i.path.push(""),C=s.ParserState.CannotBeABaseURLPath)}break;case s.ParserState.NoScheme:if(null===t||t._cannotBeABaseURLFlag&&"#"!==R.c())return v("Invalid input string."),null;t._cannotBeABaseURLFlag&&"#"===R.c()?(i.scheme=t.scheme,i.path=u.list.clone(t.path),i.query=t.query,i.fragment="",i._cannotBeABaseURLFlag=!0,C=s.ParserState.Fragment):"file"!==t.scheme?(C=s.ParserState.Relative,R.pointer--):(C=s.ParserState.File,R.pointer--);break;case s.ParserState.SpecialRelativeOrAuthority:"/"===R.c()&&R.remaining().startsWith("/")?(C=s.ParserState.SpecialAuthorityIgnoreSlashes,R.pointer++):(v("Invalid input string."),C=s.ParserState.Relative,R.pointer--);break;case s.ParserState.PathOrAuthority:"/"===R.c()?C=s.ParserState.Authority:(C=s.ParserState.Path,R.pointer--);break;case s.ParserState.Relative:if(null===t)throw new Error("Invalid parser state. Base URL is null.");switch(i.scheme=t.scheme,R.c()){case"":i.username=t.username,i.password=t.password,i.host=t.host,i.port=t.port,i.path=u.list.clone(t.path),i.query=t.query;break;case"/":C=s.ParserState.RelativeSlash;break;case"?":i.username=t.username,i.password=t.password,i.host=t.host,i.port=t.port,i.path=u.list.clone(t.path),i.query="",C=s.ParserState.Query;break;case"#":i.username=t.username,i.password=t.password,i.host=t.host,i.port=t.port,i.path=u.list.clone(t.path),i.query=t.query,i.fragment="",C=s.ParserState.Fragment;break;default:b(i)&&"\\"===R.c()?(v("Invalid input string."),C=s.ParserState.RelativeSlash):(i.username=t.username,i.password=t.password,i.host=t.host,i.port=t.port,i.path=u.list.clone(t.path),0!==i.path.length&&i.path.splice(i.path.length-1,1),C=s.ParserState.Path,R.pointer--)}break;case s.ParserState.RelativeSlash:if(!b(i)||"/"!==R.c()&&"\\"!==R.c())if("/"===R.c())C=s.ParserState.Authority;else{if(null===t)throw new Error("Invalid parser state. Base URL is null.");i.username=t.username,i.password=t.password,i.host=t.host,i.port=t.port,C=s.ParserState.Path,R.pointer--}else"\\"===R.c()&&v("Invalid input string."),C=s.ParserState.SpecialAuthorityIgnoreSlashes;break;case s.ParserState.SpecialAuthoritySlashes:"/"===R.c()&&R.remaining().startsWith("/")?(C=s.ParserState.SpecialAuthorityIgnoreSlashes,R.pointer++):(v("Expected '//'."),C=s.ParserState.SpecialAuthorityIgnoreSlashes,R.pointer--);break;case s.ParserState.SpecialAuthorityIgnoreSlashes:"/"!==R.c()&&"\\"!==R.c()?(C=s.ParserState.Authority,R.pointer--):v("Unexpected '/' or '\\'.");break;case s.ParserState.Authority:if("@"===R.c()){v("Unexpected '@'."),M&&(L="%40"+L),M=!0;try{for(var U=(l=void 0,n(L)),G=U.next();!G.done;G=U.next()){var q=G.value;if(":"!==q||j){var W=X(q,d);j?i.password+=W:i.username+=W}else j=!0}}catch(e){l={error:e}}finally{try{G&&!G.done&&(c=U.return)&&c.call(U)}finally{if(l)throw l.error}}L=""}else if(""===R.c()||"/"===R.c()||"?"===R.c()||"#"===R.c()||b(i)&&"\\"===R.c()){if(M&&""===L)return v("Invalid input string."),null;R.pointer-=L.length+1,L="",C=s.ParserState.Host}else L+=R.c();break;case s.ParserState.Host:case s.ParserState.Hostname:if(void 0!==o&&"file"===i.scheme)R.pointer--,C=s.ParserState.FileHost;else if(":"!==R.c()||B)if(""===R.c()||"/"===R.c()||"?"===R.c()||"#"===R.c()||b(i)&&"\\"===R.c()){if(R.pointer--,b(i)&&""===L)return v("Invalid input string."),null;if(void 0!==o&&""===L&&(w(i)||null!==i.port))return v("Invalid input string."),i;if(null===(J=I(L,!b(i))))return null;if(i.host=J,L="",C=s.ParserState.PathStart,void 0!==o)return i}else"["===R.c()&&(B=!0),"]"===R.c()&&(B=!1),L+=R.c();else{if(""===L)return v("Invalid input string."),null;if(null===(J=I(L,!b(i))))return null;if(i.host=J,L="",C=s.ParserState.Port,o===s.ParserState.Hostname)return i}break;case s.ParserState.Port:if(u.codePoint.ASCIIDigit.test(R.c()))L+=R.c();else{if(!(""===R.c()||"/"===R.c()||"?"===R.c()||"#"===R.c()||b(i)&&"\\"===R.c()||o))return v("Invalid input string."),null;if(""!==L&&""!==L){var H=parseInt(L,10);if(H>Math.pow(2,16)-1)return v("Invalid port number."),null;i.port=H===x(i.scheme)?null:H,L=""}if(void 0!==o)return i;C=s.ParserState.PathStart,R.pointer--}break;case s.ParserState.File:if(i.scheme="file","/"===R.c()||"\\"===R.c())"\\"===R.c()&&v("Invalid input string."),C=s.ParserState.FileSlash;else if(null!==t&&"file"===t.scheme)switch(R.c()){case"":i.host=t.host,i.path=u.list.clone(t.path),i.query=t.query;break;case"?":i.host=t.host,i.path=u.list.clone(t.path),i.query="",C=s.ParserState.Query;break;case"#":i.host=t.host,i.path=u.list.clone(t.path),i.query=t.query,i.fragment="",C=s.ParserState.Fragment;break;default:P(R.substring())?v("Unexpected windows drive letter in input string."):(i.host=t.host,i.path=u.list.clone(t.path),O(i)),C=s.ParserState.Path,R.pointer--}else C=s.ParserState.Path,R.pointer--;break;case s.ParserState.FileSlash:"/"===R.c()||"\\"===R.c()?("\\"===R.c()&&v("Invalid input string."),C=s.ParserState.FileHost):(null===t||"file"!==t.scheme||P(R.substring())||(F(t.path[0])?i.path.push(t.path[0]):i.host=t.host),C=s.ParserState.Path,R.pointer--);break;case s.ParserState.FileHost:if(""===R.c()||"/"===R.c()||"\\"===R.c()||"?"===R.c()||"#"===R.c())if(R.pointer--,void 0===o&&k(L))v("Unexpected windows drive letter in input string."),C=s.ParserState.Path;else if(""===L){if(i.host="",void 0!==o)return i;C=s.ParserState.PathStart}else{var J;if(null===(J=I(L,!b(i))))return null;if("localhost"===J&&(J=""),i.host=J,void 0!==o)return i;L="",C=s.ParserState.PathStart}else L+=R.c();break;case s.ParserState.PathStart:b(i)?("\\"===R.c()&&v("Invalid input string."),C=s.ParserState.Path,"/"!==R.c()&&"\\"!==R.c()&&R.pointer--):void 0===o&&"?"===R.c()?(i.query="",C=s.ParserState.Query):void 0===o&&"#"===R.c()?(i.fragment="",C=s.ParserState.Fragment):""!==R.c()&&(C=s.ParserState.Path,"/"!==R.c()&&R.pointer--);break;case s.ParserState.Path:if(""===R.c()||"/"===R.c()||b(i)&&"\\"===R.c()||void 0===o&&("?"===R.c()||"#"===R.c())){if(b(i)&&"\\"===R.c()&&v("Invalid input string."),T(L))O(i),"/"===R.c()||b(i)&&"\\"===R.c()||i.path.push("");else if(!N(L)||"/"===R.c()||b(i)&&"\\"===R.c()){if(!N(L)){if("file"===i.scheme&&0===i.path.length&&k(L)){null!==i.host&&""!==i.host&&(v("Invalid input string."),i.host="");var Y=Array.from(L);L=Y.slice(0,1)+":"+Y.slice(2)}i.path.push(L)}}else i.path.push("");if(L="","file"===i.scheme&&(""===R.c()||"?"===R.c()||"#"===R.c()))for(;i.path.length>1&&""===i.path[0];)v("Invalid input string."),i.path.splice(0,1);"?"===R.c()&&(i.query="",C=s.ParserState.Query),"#"===R.c()&&(i.fragment="",C=s.ParserState.Fragment)}else m.test(R.c())||"%"===R.c()||v("Character is not a URL code point or a percent encoded character."),"%"!==R.c()||/^[0-9a-fA-F][0-9a-fA-F]/.test(R.remaining())||v("Percent encoded character must be followed by two hex digits."),L+=X(R.c(),f);break;case s.ParserState.CannotBeABaseURLPath:"?"===R.c()?(i.query="",C=s.ParserState.Query):"#"===R.c()?(i.fragment="",C=s.ParserState.Fragment):(""===R.c()||m.test(R.c())||"%"===R.c()||v("Character is not a URL code point or a percent encoded character."),"%"!==R.c()||/^[0-9a-fA-F][0-9a-fA-F]/.test(R.remaining())||v("Percent encoded character must be followed by two hex digits."),""!==R.c()&&(i.path[0]+=X(R.c(),h)));break;case s.ParserState.Query:if("UTF-8"===A||b(i)&&"ws"!==i.scheme&&"wss"!==i.scheme||(A="UTF-8"),void 0===o&&"#"===R.c())i.fragment="",C=s.ParserState.Fragment;else if(""!==R.c()){if(m.test(R.c())||"%"===R.c()||v("Character is not a URL code point or a percent encoded character."),"%"!==R.c()||/^[0-9a-fA-F][0-9a-fA-F]/.test(R.remaining())||v("Percent encoded character must be followed by two hex digits."),"UTF-8"!==A.toUpperCase())throw new Error("Only UTF-8 encoding is supported.");var V=a.utf8Encode(R.c());if(V.length>=3&&38===V[0]&&35===V[1]&&59===V[V.length-1])V=V.subarray(2,V.length-1),i.query+="%26%23"+u.byteSequence.isomorphicDecode(V)+"%3B";else try{for(var K=(y=void 0,n(V)),$=K.next();!$.done;$=K.next()){var Q=$.value;Q<33||Q>126||34===Q||35===Q||60===Q||62===Q||39===Q&&b(i)?i.query+=z(Q):i.query+=String.fromCharCode(Q)}}catch(e){y={error:e}}finally{try{$&&!$.done&&(_=K.return)&&_.call(K)}finally{if(y)throw y.error}}}break;case s.ParserState.Fragment:""===R.c()||("\0"===R.c()?v("NULL character in input string."):(m.test(R.c())||"%"===R.c()||v("Unexpected character in fragment string."),"%"!==R.c()||/^[A-Za-z0-9][A-Za-z0-9]/.test(R.remaining())||v("Unexpected character in fragment string."),i.fragment+=X(R.c(),p)))}if(R.eof)break;R.pointer++}return i}function N(e){return"."===e||"%2e"===e.toLowerCase()}function T(e){var t=e.toLowerCase();return".."===t||".%2e"===t||"%2e."===t||"%2e%2e"===t}function O(e){var t=e.path;0!==t.length&&("file"===e.scheme&&1===t.length&&F(t[0])||e.path.splice(e.path.length-1,1))}function F(e){return e.length>=2&&u.codePoint.ASCIIAlpha.test(e[0])&&":"===e[1]}function k(e){return e.length>=2&&u.codePoint.ASCIIAlpha.test(e[0])&&(":"===e[1]||"|"===e[1])}function P(e){return e.length>=2&&k(e)&&(2===e.length||"/"===e[2]||"\\"===e[2]||"?"===e[2]||"#"===e[2])}function I(e,t){if(void 0===t&&(t=!1),e.startsWith("["))return e.endsWith("]")?B(e.substring(1,e.length-1)):(v("Expected ']' after '['."),null);if(t)return j(e);var r=H(a.utf8Decode(G(e)));if(null===r)return v("Invalid domain."),null;if(y.test(r))return v("Invalid domain."),null;var n=M(r);return null===n||a.isNumber(n)?n:r}function L(e,t){void 0===t&&(t={value:!1});var r=10;return e.startsWith("0x")||e.startsWith("0X")?(t.value=!0,e=e.substr(2),r=16):e.length>=2&&"0"===e[0]&&(t.value=!0,e=e.substr(1),r=8),""===e?0:(10===r?/^[0-9]+$/:16===r?/^[0-9A-Fa-f]+$/:/^[0-7]+$/).test(e)?parseInt(e,r):null}function M(e){var t,r,i,o,a={value:!1},s=e.split(".");if(""===s[s.length-1]&&(a.value=!0,s.length>1&&s.pop()),s.length>4)return e;var u=[];try{for(var l=n(s),c=l.next();!c.done;c=l.next()){var h=c.value;if(""===h)return e;if(null===(_=L(h,a)))return e;u.push(_)}}catch(e){t={error:e}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}a.value&&v("Invalid IP v4 address.");for(var p=0;p<u.length;p++){if(u[p]>255&&(v("Invalid IP v4 address."),p<u.length-1))return null}if(u[u.length-1]>=Math.pow(256,5-u.length))return v("Invalid IP v4 address."),null;var f=u[u.length-1];u.pop();var d=0;try{for(var m=n(u),y=m.next();!y.done;y=m.next()){var _;f+=(_=y.value)*Math.pow(256,3-d),d++}}catch(e){i={error:e}}finally{try{y&&!y.done&&(o=m.return)&&o.call(m)}finally{if(i)throw i.error}}return f}function B(e){var t,r=[0,0,0,0,0,0,0,0],n=0,o=null,s=new a.StringWalker(e);if(":"===s.c()){if(!s.remaining().startsWith(":"))return v("Invalid IP v6 address."),null;s.pointer+=2,o=n+=1}for(;""!==s.c();){if(8===n)return v("Invalid IP v6 address."),null;if(":"!==s.c()){for(var l=0,c=0;c<4&&u.codePoint.ASCIIHexDigit.test(s.c());)l=16*l+parseInt(s.c(),16),s.pointer++,c++;if("."===s.c()){if(0===c)return v("Invalid IP v6 address."),null;if(s.pointer-=c,n>6)return v("Invalid IP v6 address."),null;for(var h=0;""!==s.c();){var p=null;if(h>0){if(!("."===s.c()&&h<4))return v("Invalid IP v6 address."),null;s.pointer++}if(!u.codePoint.ASCIIDigit.test(s.c()))return v("Invalid IP v6 address."),null;for(;u.codePoint.ASCIIDigit.test(s.c());){var f=parseInt(s.c(),10);if(null===p)p=f;else{if(0===p)return v("Invalid IP v6 address."),null;p=10*p+f}if(p>255)return v("Invalid IP v6 address."),null;s.pointer++}if(null===p)return v("Invalid IP v6 address."),null;r[n]=256*r[n]+p,2!==++h&&4!==h||n++}if(4!==h)return v("Invalid IP v6 address."),null;break}if(":"===s.c()){if(s.pointer++,""===s.c())return v("Invalid IP v6 address."),null}else if(""!==s.c())return v("Invalid IP v6 address."),null;r[n]=l,n++}else{if(null!==o)return v("Invalid IP v6 address."),null;s.pointer++,o=++n}}if(null!==o){var d=n-o;for(n=7;0!==n&&d>0;)t=i([r[o+d-1],r[n]],2),r[n]=t[0],r[o+d-1]=t[1],n--,d--}else if(null===o&&8!==n)return v("Invalid IP v6 address."),null;return r}function j(e){var t,r;if(/[\x00\t\f\r #/:?@\[\\\]]/.test(e))return v("Invalid host string."),null;var i="";try{for(var o=n(e),a=o.next();!a.done;a=o.next()){i+=X(a.value,h)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return i}function R(e){return null}function z(e){return"%"+("00"+e.toString(16).toUpperCase()).slice(-2)}function U(e){for(var t=function(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102},r=new Uint8Array(e.length),n=0,i=0;i<e.length;i++){var o=e[i];if(37!==o)r[n]=o,n++;else if(37===o&&i>=e.length-2)r[n]=o,n++;else if(37!==o||t(e[i+1])&&t(e[i+2])){var s=parseInt(a.utf8Decode(Uint8Array.of(e[i+1],e[i+2])),16);r[n]=s,n++,i+=2}else r[n]=o,n++}return r.subarray(0,n)}function G(e){return U(a.utf8Encode(e))}function X(e,t){var r,i;if(!t.test(e))return e;var o=a.utf8Encode(e),s="";try{for(var u=n(o),l=u.next();!l.done;l=u.next()){s+=z(l.value)}}catch(e){r={error:e}}finally{try{l&&!l.done&&(i=u.return)&&i.call(u)}finally{if(r)throw r.error}}return s}function q(e){var t,r,i,o,s=[],u=[];try{for(var l=n(e),c=l.next();!c.done;c=l.next()){var h=c.value;38===h?(s.push(Uint8Array.from(u)),u=[]):u.push(h)}}catch(e){t={error:e}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}0!==u.length&&s.push(Uint8Array.from(u));var p=[];try{for(var f=n(s),d=f.next();!d.done;d=f.next()){var m=d.value;if(0!==m.length){for(var y=m.indexOf(61),v=-1!==y?m.slice(0,y):m,_=-1!==y?m.slice(y+1):new Uint8Array,g=0;g<v.length;g++)43===v[g]&&(v[g]=32);for(g=0;g<_.length;g++)43===_[g]&&(_[g]=32);var b=a.utf8Decode(v),x=a.utf8Decode(_);p.push([b,x])}}}catch(e){i={error:e}}finally{try{d&&!d.done&&(o=f.return)&&o.call(f)}finally{if(i)throw i.error}}return p}function W(e){var t,r,i="";try{for(var o=n(e),a=o.next();!a.done;a=o.next()){var s=a.value;i+=32===s?"+":42===s||45===s||46===s||s>=48&&s<=57||s>=65&&s<=90||95===s||s>=97&&s<=122?String.fromCodePoint(s):z(s)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return i}function H(e,t){void 0===t&&(t=!1);var r=l.domainToASCII(e);return""===r?(v("Invalid domain name."),null):r}t.setValidationErrorCallback=function(e){o=e},t.newURL=_,t.isSpecialScheme=g,t.isSpecial=b,t.defaultPort=x,t.includesCredentials=w,t.cannotHaveAUsernamePasswordPort=function(e){return null===e.host||""===e.host||e._cannotBeABaseURLFlag||"file"===e.scheme},t.urlSerializer=E,t.hostSerializer=D,t.iPv4Serializer=S,t.iPv6Serializer=C,t.urlParser=function(e,t,r){var n=A(e,t,r);return null===n?null:("blob"!==n.scheme||(n._blobURLEntry=null),n)},t.basicURLParser=A,t.setTheUsername=function(e,t){var r,i,o="";try{for(var a=n(t),s=a.next();!s.done;s=a.next()){o+=X(s.value,d)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(i=a.return)&&i.call(a)}finally{if(r)throw r.error}}e.username=o},t.setThePassword=function(e,t){var r,i,o="";try{for(var a=n(t),s=a.next();!s.done;s=a.next()){o+=X(s.value,d)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(i=a.return)&&i.call(a)}finally{if(r)throw r.error}}e.password=o},t.isSingleDotPathSegment=N,t.isDoubleDotPathSegment=T,t.shorten=O,t.isNormalizedWindowsDriveLetter=F,t.isWindowsDriveLetter=k,t.startsWithAWindowsDriveLetter=P,t.hostParser=I,t.iPv4NumberParser=L,t.iPv4Parser=M,t.iPv6Parser=B,t.opaqueHostParser=j,t.resolveABlobURL=R,t.percentEncode=z,t.percentDecode=U,t.stringPercentDecode=G,t.utf8PercentEncode=X,t.hostEquals=function(e,t){return e===t},t.urlEquals=function(e,t,r){return void 0===r&&(r=!1),E(e,r)===E(t,r)},t.urlEncodedStringParser=function(e){return q(a.utf8Encode(e))},t.urlEncodedParser=q,t.urlEncodedByteSerializer=W,t.urlEncodedSerializer=function(e,t){var r,i;if("UTF-8"!==(void 0===t||"replacement"===t||"UTF-16BE"===t||"UTF-16LE"===t?"UTF-8":t).toUpperCase())throw new Error("Only UTF-8 encoding is supported.");var o="";try{for(var s=n(e),u=s.next();!u.done;u=s.next()){var l=u.value,c=W(a.utf8Encode(l[0])),h=l[1];h=W(a.utf8Encode(h)),""!==o&&(o+="&"),o+=c+"="+h}}catch(e){r={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(r)throw r.error}}return o},t.origin=function e(t){switch(t.scheme){case"blob":t._blobURLEntry;var r=A(t.path[0]);return null===r?s.OpaqueOrigin:e(r);case"ftp":case"http":case"https":case"ws":case"wss":return[t.scheme,null===t.host?"":t.host,t.port,null];case"file":default:return s.OpaqueOrigin}},t.domainToASCII=H,t.domainToUnicode=function(e,t){void 0===t&&(t=!1);var r=l.domainToUnicode(e);return""===r&&v("Invalid domain name."),r},t.asciiSerializationOfAnOrigin=function(e){if(""===e[0]&&""===e[1]&&null===e[2]&&null===e[3])return"null";var t=e[0]+"://"+D(e[1]);return null!==e[2]&&(t+=":"+e[2].toString()),t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function e(){this._signal=n.create_abortSignal()}return Object.defineProperty(e.prototype,"signal",{get:function(){return this._signal},enumerable:!0,configurable:!0}),e.prototype.abort=function(){n.abort_signalAbort(this._signal)},e}();t.AbortControllerImpl=i},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(70),a=r(0),s=function(e){function t(){var t=e.call(this)||this;return t._abortedFlag=!1,t._abortAlgorithms=new Set,t}return i(t,e),Object.defineProperty(t.prototype,"aborted",{get:function(){return this._abortedFlag},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"onabort",{get:function(){return a.event_getterEventHandlerIDLAttribute(this,"onabort")},set:function(e){a.event_setterEventHandlerIDLAttribute(this,"onabort",e)},enumerable:!0,configurable:!0}),t._create=function(){return new t},t}(o.EventTargetImpl);t.AbortSignalImpl=s},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(34),s=r(12),u=function(e){function t(t,r,n){var i=e.call(this)||this;return i._name="",i._publicId="",i._systemId="",i._name=t,i._publicId=r,i._systemId=n,i}return i(t,e),Object.defineProperty(t.prototype,"name",{get:function(){return this._name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"publicId",{get:function(){return this._publicId},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"systemId",{get:function(){return this._systemId},enumerable:!0,configurable:!0}),t.prototype.before=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.after=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.replaceWith=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Mixin: ChildNode not implemented.")},t.prototype.remove=function(){throw new Error("Mixin: ChildNode not implemented.")},t._create=function(e,r,n,i){void 0===n&&(n=""),void 0===i&&(i="");var o=new t(r,n,i);return o._nodeDocument=e,o},t}(a.NodeImpl);t.DocumentTypeImpl=u,s.idl_defineConst(u.prototype,"_nodeType",o.NodeType.DocumentType)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(100),a=r(1),s=r(0),u=function(e){function t(t,r){var n=e.call(this)||this;return n._host=t,n._mode=r,n}return i(t,e),Object.defineProperty(t.prototype,"mode",{get:function(){return this._mode},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"host",{get:function(){return this._host},enumerable:!0,configurable:!0}),t.prototype._getTheParent=function(e){return e._composedFlag||a.isEmpty(e._path)||s.tree_rootNode(e._path[0].invocationTarget)!==this?this._host:null},t._create=function(e,r){return new t(r,"closed")},t}(o.DocumentFragmentImpl);t.ShadowRootImpl=u},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(34),s=r(0),u=r(12),l=function(e){function t(t){var r=e.call(this)||this;return r._namespace=null,r._namespacePrefix=null,r._element=null,r._value="",r._localName=t,r}return i(t,e),Object.defineProperty(t.prototype,"ownerElement",{get:function(){return this._element},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"namespaceURI",{get:function(){return this._namespace},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"prefix",{get:function(){return this._namespacePrefix},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"localName",{get:function(){return this._localName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"name",{get:function(){return this._qualifiedName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"value",{get:function(){return this._value},set:function(e){s.attr_setAnExistingAttributeValue(this,e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"_qualifiedName",{get:function(){return null!==this._namespacePrefix?this._namespacePrefix+":"+this._localName:this._localName},enumerable:!0,configurable:!0}),t._create=function(e,r){var n=new t(r);return n._nodeDocument=e,n},t}(a.NodeImpl);t.AttrImpl=l,u.idl_defineConst(l.prototype,"_nodeType",o.NodeType.Attribute),u.idl_defineConst(l.prototype,"specified",!0)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(101),a=r(2),s=r(12),u=function(e){function t(t){return e.call(this,t)||this}return i(t,e),t._create=function(e,r){void 0===r&&(r="");var n=new t(r);return n._nodeDocument=e,n},t}(o.TextImpl);t.CDATASectionImpl=u,s.idl_defineConst(u.prototype,"_nodeType",a.NodeType.CData)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(71),s=r(12),u=function(e){function t(t){return void 0===t&&(t=""),e.call(this,t)||this}return i(t,e),t._create=function(e,r){void 0===r&&(r="");var n=new t(r);return n._nodeDocument=e,n},t}(a.CharacterDataImpl);t.CommentImpl=u,s.idl_defineConst(u.prototype,"_nodeType",o.NodeType.Comment)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(71),s=r(12),u=function(e){function t(t,r){var n=e.call(this,r)||this;return n._target=t,n}return i(t,e),Object.defineProperty(t.prototype,"target",{get:function(){return this._target},enumerable:!0,configurable:!0}),t._create=function(e,r,n){var i=new t(r,n);return i._nodeDocument=e,i},t}(a.CharacterDataImpl);t.ProcessingInstructionImpl=u,s.idl_defineConst(u.prototype,"_nodeType",o.NodeType.ProcessingInstruction)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(7),i=r(0),o=r(3),a=r(1),s=function(){function e(e,t){return this._live=!0,this._root=e,this._filter=t,new Proxy(this,this)}return Object.defineProperty(e.prototype,"length",{get:function(){for(var e=this,t=0,r=i.tree_getFirstDescendantNode(this._root,!1,!1,(function(t){return o.Guard.isElementNode(t)&&e._filter(t)}));null!==r;)t++,r=i.tree_getNextDescendantNode(this._root,r,!1,!1,(function(t){return o.Guard.isElementNode(t)&&e._filter(t)}));return t},enumerable:!0,configurable:!0}),e.prototype.item=function(e){for(var t=this,r=0,n=i.tree_getFirstDescendantNode(this._root,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t._filter(e)}));null!==n;){if(r===e)return n;r++,n=i.tree_getNextDescendantNode(this._root,n,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t._filter(e)}))}return null},e.prototype.namedItem=function(e){var t=this;if(""===e)return null;for(var r=i.tree_getFirstDescendantNode(this._root,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t._filter(e)}));null!=r;){if(r._uniqueIdentifier===e)return r;if(r._namespace===n.namespace.HTML)for(var a=0;a<r._attributeList.length;a++){var s=r._attributeList[a];if("name"===s._localName&&null===s._namespace&&null===s._namespacePrefix&&s._value===e)return r}r=i.tree_getNextDescendantNode(this._root,r,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t._filter(e)}))}return null},e.prototype[Symbol.iterator]=function(){var e=this._root,t=this._filter,r=i.tree_getFirstDescendantNode(e,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t(e)}));return{next:function(){if(null===r)return{done:!0,value:null};var n={done:!1,value:r};return r=i.tree_getNextDescendantNode(e,r,!1,!1,(function(e){return o.Guard.isElementNode(e)&&t(e)})),n}}},e.prototype.get=function(t,r,n){if(!a.isString(r)||-1!==e.reservedNames.indexOf(r))return Reflect.get(t,r,n);var i=Number(r);return isNaN(i)?t.namedItem(r)||void 0:t.item(i)||void 0},e.prototype.set=function(t,r,n,o){if(!a.isString(r)||-1!==e.reservedNames.indexOf(r))return Reflect.set(t,r,n,o);var s=Number(r),u=isNaN(s)?t.namedItem(r)||void 0:t.item(s)||void 0;return!(!u||!u._parent)&&(i.mutation_replace(u,n,u._parent),!0)},e._create=function(t,r){return void 0===r&&(r=function(){return!0}),new e(t,r)},e.reservedNames=["_root","_live","_filter","length","item","namedItem","get","set"],e}();t.HTMLCollectionImpl=s},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(1),a=r(0),s=function(){function e(e){return this._live=!0,this._filter=null,this._length=0,this._root=e,new Proxy(this,this)}return Object.defineProperty(e.prototype,"length",{get:function(){return this._root._children.size},enumerable:!0,configurable:!0}),e.prototype.item=function(e){if(e<0||e>this.length-1)return null;if(e<this.length/2){for(var t=0,r=this._root._firstChild;null!==r&&t!==e;)r=r._nextSibling,t++;return r}for(t=this.length-1,r=this._root._lastChild;null!==r&&t!==e;)r=r._previousSibling,t--;return r},e.prototype.keys=function(){var e;return(e={})[Symbol.iterator]=function(){var e=0;return{next:function(){return e===this.length?{done:!0,value:null}:{done:!1,value:e++}}.bind(this)}}.bind(this),e},e.prototype.values=function(){var e;return(e={})[Symbol.iterator]=function(){var e=this[Symbol.iterator]();return{next:function(){return e.next()}}}.bind(this),e},e.prototype.entries=function(){var e;return(e={})[Symbol.iterator]=function(){var e=this[Symbol.iterator](),t=0;return{next:function(){var r=e.next();return r.done?{done:!0,value:null}:{done:!1,value:[t++,r.value]}}}}.bind(this),e},e.prototype[Symbol.iterator]=function(){return this._root._children[Symbol.iterator]()},e.prototype.forEach=function(e,t){var r,o;void 0===t&&(t=i.dom.window);var a=0;try{for(var s=n(this._root._children),u=s.next();!u.done;u=s.next()){var l=u.value;e.call(t,l,a++,this)}}catch(e){r={error:e}}finally{try{u&&!u.done&&(o=s.return)&&o.call(s)}finally{if(r)throw r.error}}},e.prototype.get=function(e,t,r){if(!o.isString(t))return Reflect.get(e,t,r);var n=Number(t);return isNaN(n)?Reflect.get(e,t,r):e.item(n)||void 0},e.prototype.set=function(e,t,r,n){if(!o.isString(t))return Reflect.set(e,t,r,n);var i=Number(t);if(isNaN(i))return Reflect.set(e,t,r,n);var s=e.item(i)||void 0;return!!s&&(!!s._parent&&(a.mutation_replace(s,r,s._parent),!0))},e._create=function(t){return new e(t)},e}();t.NodeListImpl=s},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(1),a=function(){function e(e){return this._live=!1,this._items=[],this._length=0,this._root=e,this._items=[],this._filter=function(e){return!0},new Proxy(this,this)}return Object.defineProperty(e.prototype,"length",{get:function(){return this._items.length},enumerable:!0,configurable:!0}),e.prototype.item=function(e){return e<0||e>this.length-1?null:this._items[e]},e.prototype.keys=function(){var e;return(e={})[Symbol.iterator]=function(){var e=0;return{next:function(){return e===this.length?{done:!0,value:null}:{done:!1,value:e++}}.bind(this)}}.bind(this),e},e.prototype.values=function(){var e;return(e={})[Symbol.iterator]=function(){var e=this[Symbol.iterator]();return{next:function(){return e.next()}}}.bind(this),e},e.prototype.entries=function(){var e;return(e={})[Symbol.iterator]=function(){var e=this[Symbol.iterator](),t=0;return{next:function(){var r=e.next();return r.done?{done:!0,value:null}:{done:!1,value:[t++,r.value]}}}}.bind(this),e},e.prototype[Symbol.iterator]=function(){var e=this._items[Symbol.iterator]();return{next:function(){return e.next()}}},e.prototype.forEach=function(e,t){var r,o;void 0===t&&(t=i.dom.window);var a=0;try{for(var s=n(this._items),u=s.next();!u.done;u=s.next()){var l=u.value;e.call(t,l,a++,this)}}catch(e){r={error:e}}finally{try{u&&!u.done&&(o=s.return)&&o.call(s)}finally{if(r)throw r.error}}},e.prototype.get=function(e,t,r){if(!o.isString(t))return Reflect.get(e,t,r);var n=Number(t);return isNaN(n)?Reflect.get(e,t,r):e._items[n]||void 0},e.prototype.set=function(e,t,r,n){if(!o.isString(t))return Reflect.set(e,t,r,n);var i=Number(t);return isNaN(i)?Reflect.set(e,t,r,n):i>=0&&i<e._items.length&&(e._items[i]=r,!0)},e._create=function(t,r){var n=new e(t);return n._items=r,n},e}();t.NodeListStaticImpl=a},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(9),a=r(0),s=function(e){function t(r){var n=e.call(this)||this;return n._element=r,Object.setPrototypeOf(n,t.prototype),n}return i(t,e),t.prototype._asArray=function(){return this},t.prototype.item=function(e){return this[e]||null},t.prototype.getNamedItem=function(e){return a.element_getAnAttributeByName(e,this._element)},t.prototype.getNamedItemNS=function(e,t){return a.element_getAnAttributeByNamespaceAndLocalName(e||"",t,this._element)},t.prototype.setNamedItem=function(e){return a.element_setAnAttribute(e,this._element)},t.prototype.setNamedItemNS=function(e){return a.element_setAnAttribute(e,this._element)},t.prototype.removeNamedItem=function(e){var t=a.element_removeAnAttributeByName(e,this._element);if(null===t)throw new o.NotFoundError;return t},t.prototype.removeNamedItemNS=function(e,t){var r=a.element_removeAnAttributeByNamespaceAndLocalName(e||"",t,this._element);if(null===r)throw new o.NotFoundError;return r},t._create=function(e){return new t(e)},t}(Array);t.NamedNodeMapImpl=s},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(6),s=r(2),u=r(102),l=r(9),c=r(0),h=r(12),p=r(3),f=function(e){function t(){var t=e.call(this)||this,r=a.dom.window._associatedDocument;return t._start=[r,0],t._end=[r,0],a.dom.rangeList.add(t),t}return i(t,e),Object.defineProperty(t.prototype,"commonAncestorContainer",{get:function(){for(var e=this._start[0];!c.tree_isAncestorOf(this._end[0],e,!0);){if(null===e._parent)throw new Error("Parent node  is null.");e=e._parent}return e},enumerable:!0,configurable:!0}),t.prototype.setStart=function(e,t){c.range_setTheStart(this,e,t)},t.prototype.setEnd=function(e,t){c.range_setTheEnd(this,e,t)},t.prototype.setStartBefore=function(e){var t=e._parent;if(null===t)throw new l.InvalidNodeTypeError;c.range_setTheStart(this,t,c.tree_index(e))},t.prototype.setStartAfter=function(e){var t=e._parent;if(null===t)throw new l.InvalidNodeTypeError;c.range_setTheStart(this,t,c.tree_index(e)+1)},t.prototype.setEndBefore=function(e){var t=e._parent;if(null===t)throw new l.InvalidNodeTypeError;c.range_setTheEnd(this,t,c.tree_index(e))},t.prototype.setEndAfter=function(e){var t=e._parent;if(null===t)throw new l.InvalidNodeTypeError;c.range_setTheEnd(this,t,c.tree_index(e)+1)},t.prototype.collapse=function(e){e?this._end=this._start:this._start=this._end},t.prototype.selectNode=function(e){c.range_select(e,this)},t.prototype.selectNodeContents=function(e){if(p.Guard.isDocumentTypeNode(e))throw new l.InvalidNodeTypeError;var t=c.tree_nodeLength(e);this._start=[e,0],this._end=[e,t]},t.prototype.compareBoundaryPoints=function(e,t){if(e!==s.HowToCompare.StartToStart&&e!==s.HowToCompare.StartToEnd&&e!==s.HowToCompare.EndToEnd&&e!==s.HowToCompare.EndToStart)throw new l.NotSupportedError;if(c.range_root(this)!==c.range_root(t))throw new l.WrongDocumentError;var r,n;switch(e){case s.HowToCompare.StartToStart:r=this._start,n=t._start;break;case s.HowToCompare.StartToEnd:r=this._end,n=t._start;break;case s.HowToCompare.EndToEnd:r=this._end,n=t._end;break;case s.HowToCompare.EndToStart:r=this._start,n=t._end;break;default:throw new l.NotSupportedError}var i=c.boundaryPoint_position(r,n);return i===s.BoundaryPosition.Before?-1:i===s.BoundaryPosition.After?1:0},t.prototype.deleteContents=function(){var e,t,r,n;if(!c.range_collapsed(this)){var i=this._startNode,a=this._startOffset,s=this._endNode,u=this._endOffset;if(i===s&&p.Guard.isCharacterDataNode(i))c.characterData_replaceData(i,a,u-a,"");else{var l,h,f=[];try{for(var d=o(c.range_getContainedNodes(this)),m=d.next();!m.done;m=d.next()){var y=(b=m.value)._parent;null!==y&&c.range_isContained(y,this)||f.push(b)}}catch(t){e={error:t}}finally{try{m&&!m.done&&(t=d.return)&&t.call(d)}finally{if(e)throw e.error}}if(c.tree_isAncestorOf(s,i,!0))l=i,h=a;else{for(var v=i;null!==v._parent&&!c.tree_isAncestorOf(s,v._parent,!0);)v=v._parent;if(null===v._parent)throw new Error("Parent node is null.");l=v._parent,h=c.tree_index(v)+1}p.Guard.isCharacterDataNode(i)&&c.characterData_replaceData(i,a,c.tree_nodeLength(i)-a,"");try{for(var _=o(f),g=_.next();!g.done;g=_.next()){var b;(b=g.value)._parent&&c.mutation_remove(b,b._parent)}}catch(e){r={error:e}}finally{try{g&&!g.done&&(n=_.return)&&n.call(_)}finally{if(r)throw r.error}}p.Guard.isCharacterDataNode(s)&&c.characterData_replaceData(s,0,u,""),this._start=[l,h],this._end=[l,h]}}},t.prototype.extractContents=function(){return c.range_extract(this)},t.prototype.cloneContents=function(){return c.range_cloneTheContents(this)},t.prototype.insertNode=function(e){return c.range_insert(e,this)},t.prototype.surroundContents=function(e){var t,r;try{for(var n=o(c.range_getPartiallyContainedNodes(this)),i=n.next();!i.done;i=n.next()){var a=i.value;if(!p.Guard.isTextNode(a))throw new l.InvalidStateError}}catch(e){t={error:e}}finally{try{i&&!i.done&&(r=n.return)&&r.call(n)}finally{if(t)throw t.error}}if(p.Guard.isDocumentNode(e)||p.Guard.isDocumentTypeNode(e)||p.Guard.isDocumentFragmentNode(e))throw new l.InvalidNodeTypeError;var s=c.range_extract(this);0!==e._children.size&&c.mutation_replaceAll(null,e),c.range_insert(e,this),c.mutation_append(s,e),c.range_select(e,this)},t.prototype.cloneRange=function(){return c.create_range(this._start,this._end)},t.prototype.detach=function(){a.dom.rangeList.delete(this)},t.prototype.isPointInRange=function(e,t){if(c.tree_rootNode(e)!==c.range_root(this))return!1;if(p.Guard.isDocumentTypeNode(e))throw new l.InvalidNodeTypeError;if(t>c.tree_nodeLength(e))throw new l.IndexSizeError;var r=[e,t];return c.boundaryPoint_position(r,this._start)!==s.BoundaryPosition.Before&&c.boundaryPoint_position(r,this._end)!==s.BoundaryPosition.After},t.prototype.comparePoint=function(e,t){if(c.tree_rootNode(e)!==c.range_root(this))throw new l.WrongDocumentError;if(p.Guard.isDocumentTypeNode(e))throw new l.InvalidNodeTypeError;if(t>c.tree_nodeLength(e))throw new l.IndexSizeError;var r=[e,t];return c.boundaryPoint_position(r,this._start)===s.BoundaryPosition.Before?-1:c.boundaryPoint_position(r,this._end)===s.BoundaryPosition.After?1:0},t.prototype.intersectsNode=function(e){if(c.tree_rootNode(e)!==c.range_root(this))return!1;var t=e._parent;if(null===t)return!0;var r=c.tree_index(e);return c.boundaryPoint_position([t,r],this._end)===s.BoundaryPosition.Before&&c.boundaryPoint_position([t,r+1],this._start)===s.BoundaryPosition.After},t.prototype.toString=function(){var e,t,r="";if(this._startNode===this._endNode&&p.Guard.isTextNode(this._startNode))return this._startNode._data.substring(this._startOffset,this._endOffset);p.Guard.isTextNode(this._startNode)&&(r+=this._startNode._data.substring(this._startOffset));try{for(var n=o(c.range_getContainedNodes(this)),i=n.next();!i.done;i=n.next()){var a=i.value;p.Guard.isTextNode(a)&&(r+=a._data)}}catch(t){e={error:t}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}return p.Guard.isTextNode(this._endNode)&&(r+=this._endNode._data.substring(0,this._endOffset)),r},t._create=function(e,r){var n=new t;return e&&(n._start=e),r&&(n._end=r),n},t.START_TO_START=0,t.START_TO_END=1,t.END_TO_END=2,t.END_TO_START=3,t}(u.AbstractRangeImpl);t.RangeImpl=f,h.idl_defineConst(f.prototype,"START_TO_START",0),h.idl_defineConst(f.prototype,"START_TO_END",1),h.idl_defineConst(f.prototype,"END_TO_END",2),h.idl_defineConst(f.prototype,"END_TO_START",3)},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(103),a=r(0),s=function(e){function t(t,r,n){var i=e.call(this,t)||this;return i._iteratorCollection=void 0,i._reference=r,i._pointerBeforeReference=n,a.nodeIterator_iteratorList().add(i),i}return i(t,e),Object.defineProperty(t.prototype,"referenceNode",{get:function(){return this._reference},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"pointerBeforeReferenceNode",{get:function(){return this._pointerBeforeReference},enumerable:!0,configurable:!0}),t.prototype.nextNode=function(){return a.nodeIterator_traverse(this,!0)},t.prototype.previousNode=function(){return a.nodeIterator_traverse(this,!1)},t.prototype.detach=function(){a.nodeIterator_iteratorList().delete(this)},t._create=function(e,r,n){return new t(e,r,n)},t}(o.TraverserImpl);t.NodeIteratorImpl=s},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(2),a=r(103),s=r(0),u=function(e){function t(t,r){var n=e.call(this,t)||this;return n._current=r,n}return i(t,e),Object.defineProperty(t.prototype,"currentNode",{get:function(){return this._current},set:function(e){this._current=e},enumerable:!0,configurable:!0}),t.prototype.parentNode=function(){for(var e=this._current;null!==e&&e!==this._root;)if(null!==(e=e._parent)&&s.traversal_filter(this,e)===o.FilterResult.Accept)return this._current=e,e;return null},t.prototype.firstChild=function(){return s.treeWalker_traverseChildren(this,!0)},t.prototype.lastChild=function(){return s.treeWalker_traverseChildren(this,!1)},t.prototype.nextSibling=function(){return s.treeWalker_traverseSiblings(this,!0)},t.prototype.previousNode=function(){for(var e=this._current;e!==this._root;){for(var t=e._previousSibling;t;){e=t;for(var r=s.traversal_filter(this,e);r!==o.FilterResult.Reject&&e._lastChild;)e=e._lastChild,r=s.traversal_filter(this,e);if(r===o.FilterResult.Accept)return this._current=e,e;t=e._previousSibling}if(e===this._root||null===e._parent)return null;if(e=e._parent,s.traversal_filter(this,e)===o.FilterResult.Accept)return this._current=e,e}return null},t.prototype.previousSibling=function(){return s.treeWalker_traverseSiblings(this,!1)},t.prototype.nextNode=function(){for(var e=this._current,t=o.FilterResult.Accept;;){for(;t!==o.FilterResult.Reject&&e._firstChild;)if(e=e._firstChild,(t=s.traversal_filter(this,e))===o.FilterResult.Accept)return this._current=e,e;for(var r=null,n=e;null!==n;){if(n===this._root)return null;if(null!==(r=n._nextSibling)){e=r;break}n=n._parent}if((t=s.traversal_filter(this,e))===o.FilterResult.Accept)return this._current=e,e}},t._create=function(e,r){return new t(e,r)},t}(a.TraverserImpl);t.TreeWalkerImpl=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=r(12),o=function(){function e(){}return e.prototype.acceptNode=function(e){return n.FilterResult.Accept},e._create=function(){return new e},e.FILTER_ACCEPT=1,e.FILTER_REJECT=2,e.FILTER_SKIP=3,e.SHOW_ALL=4294967295,e.SHOW_ELEMENT=1,e.SHOW_ATTRIBUTE=2,e.SHOW_TEXT=4,e.SHOW_CDATA_SECTION=8,e.SHOW_ENTITY_REFERENCE=16,e.SHOW_ENTITY=32,e.SHOW_PROCESSING_INSTRUCTION=64,e.SHOW_COMMENT=128,e.SHOW_DOCUMENT=256,e.SHOW_DOCUMENT_TYPE=512,e.SHOW_DOCUMENT_FRAGMENT=1024,e.SHOW_NOTATION=2048,e}();t.NodeFilterImpl=o,i.idl_defineConst(o.prototype,"FILTER_ACCEPT",1),i.idl_defineConst(o.prototype,"FILTER_REJECT",2),i.idl_defineConst(o.prototype,"FILTER_SKIP",3),i.idl_defineConst(o.prototype,"SHOW_ALL",4294967295),i.idl_defineConst(o.prototype,"SHOW_ELEMENT",1),i.idl_defineConst(o.prototype,"SHOW_ATTRIBUTE",2),i.idl_defineConst(o.prototype,"SHOW_TEXT",4),i.idl_defineConst(o.prototype,"SHOW_CDATA_SECTION",8),i.idl_defineConst(o.prototype,"SHOW_ENTITY_REFERENCE",16),i.idl_defineConst(o.prototype,"SHOW_ENTITY",32),i.idl_defineConst(o.prototype,"SHOW_PROCESSING_INSTRUCTION",64),i.idl_defineConst(o.prototype,"SHOW_COMMENT",128),i.idl_defineConst(o.prototype,"SHOW_DOCUMENT",256),i.idl_defineConst(o.prototype,"SHOW_DOCUMENT_TYPE",512),i.idl_defineConst(o.prototype,"SHOW_DOCUMENT_FRAGMENT",1024),i.idl_defineConst(o.prototype,"SHOW_NOTATION",2048)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t,r,n,i,o,a,s,u){this._type=e,this._target=t,this._addedNodes=r,this._removedNodes=n,this._previousSibling=i,this._nextSibling=o,this._attributeName=a,this._attributeNamespace=s,this._oldValue=u}return Object.defineProperty(e.prototype,"type",{get:function(){return this._type},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"target",{get:function(){return this._target},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"addedNodes",{get:function(){return this._addedNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"removedNodes",{get:function(){return this._removedNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"previousSibling",{get:function(){return this._previousSibling},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nextSibling",{get:function(){return this._nextSibling},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"attributeName",{get:function(){return this._attributeName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"attributeNamespace",{get:function(){return this._attributeNamespace},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"oldValue",{get:function(){return this._oldValue},enumerable:!0,configurable:!0}),e._create=function(t,r,n,i,o,a,s,u,l){return new e(t,r,n,i,o,a,s,u,l)},e}();t.MutationRecordImpl=n},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(9),a=r(7),s=r(0),u=function(){function e(e,t){this._element=e,this._attribute=t,this._tokenSet=new Set;var r=t._localName,n=s.element_getAnAttributeValue(e,r),o=this;this._element._attributeChangeSteps.push((function(e,t,r,n,i){t===o._attribute._localName&&null===i&&(n?o._tokenSet=s.orderedSet_parse(n):o._tokenSet.clear())})),i.dom.features.steps&&s.dom_runAttributeChangeSteps(e,r,n,n,null)}return Object.defineProperty(e.prototype,"length",{get:function(){return this._tokenSet.size},enumerable:!0,configurable:!0}),e.prototype.item=function(e){var t,r,i=0;try{for(var o=n(this._tokenSet),a=o.next();!a.done;a=o.next()){var s=a.value;if(i===e)return s;i++}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return null},e.prototype.contains=function(e){return this._tokenSet.has(e)},e.prototype.add=function(){for(var e,t,r=[],i=0;i<arguments.length;i++)r[i]=arguments[i];try{for(var u=n(r),l=u.next();!l.done;l=u.next()){var c=l.value;if(""===c)throw new o.SyntaxError("Cannot add an empty token.");if(a.codePoint.ASCIIWhiteSpace.test(c))throw new o.InvalidCharacterError("Token cannot contain whitespace.");this._tokenSet.add(c)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(t=u.return)&&t.call(u)}finally{if(e)throw e.error}}s.tokenList_updateSteps(this)},e.prototype.remove=function(){for(var e,t,r=[],i=0;i<arguments.length;i++)r[i]=arguments[i];try{for(var u=n(r),l=u.next();!l.done;l=u.next()){var c=l.value;if(""===c)throw new o.SyntaxError("Cannot remove an empty token.");if(a.codePoint.ASCIIWhiteSpace.test(c))throw new o.InvalidCharacterError("Token cannot contain whitespace.");this._tokenSet.delete(c)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(t=u.return)&&t.call(u)}finally{if(e)throw e.error}}s.tokenList_updateSteps(this)},e.prototype.toggle=function(e,t){if(void 0===t&&(t=void 0),""===e)throw new o.SyntaxError("Cannot toggle an empty token.");if(a.codePoint.ASCIIWhiteSpace.test(e))throw new o.InvalidCharacterError("Token cannot contain whitespace.");return this._tokenSet.has(e)?void 0!==t&&!1!==t||(this._tokenSet.delete(e),s.tokenList_updateSteps(this),!1):(void 0===t||!0===t)&&(this._tokenSet.add(e),s.tokenList_updateSteps(this),!0)},e.prototype.replace=function(e,t){if(""===e||""===t)throw new o.SyntaxError("Cannot replace an empty token.");if(a.codePoint.ASCIIWhiteSpace.test(e)||a.codePoint.ASCIIWhiteSpace.test(t))throw new o.InvalidCharacterError("Token cannot contain whitespace.");return!!this._tokenSet.has(e)&&(a.set.replace(this._tokenSet,e,t),s.tokenList_updateSteps(this),!0)},e.prototype.supports=function(e){return s.tokenList_validationSteps(this,e)},Object.defineProperty(e.prototype,"value",{get:function(){return s.tokenList_serializeSteps(this)},set:function(e){s.element_setAnAttributeValue(this._element,this._attribute._localName,e)},enumerable:!0,configurable:!0}),e.prototype[Symbol.iterator]=function(){var e=this._tokenSet[Symbol.iterator]();return{next:function(){return e.next()}}},e._create=function(t,r){return new e(t,r)},e}();t.DOMTokenListImpl=u},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(104),a=r(0),s=function(e){function t(t,r){var n=e.call(this,t,r)||this;return n._detail=null,n._detail=r&&r.detail||null,n}return i(t,e),Object.defineProperty(t.prototype,"detail",{get:function(){return this._detail},enumerable:!0,configurable:!0}),t.prototype.initCustomEvent=function(e,t,r,n){void 0===t&&(t=!1),void 0===r&&(r=!1),void 0===n&&(n=null),this._dispatchFlag||(a.event_initialize(this,e,t,r),this._detail=n)},t}(o.EventImpl);t.CustomEventImpl=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),i=r(2),o=r(105),a=r(17);t.nodeIterator_traverse=function(e,t){for(var r=e._reference,n=e._pointerBeforeReference;;){if(t)if(n)n=!1;else{var s=a.tree_getFollowingNode(e._root,r);if(!s)return null;r=s}else if(n){var u=a.tree_getPrecedingNode(e.root,r);if(!u)return null;r=u}else n=!0;if(o.traversal_filter(e,r)===i.FilterResult.Accept)break}return e._reference=r,e._pointerBeforeReference=n,r},t.nodeIterator_iteratorList=function(){return n.dom.window._iteratorList}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(9),i=r(7),o=r(174);function a(e){if(!o.xml_isName(e))throw new n.InvalidCharacterError("Invalid XML name: "+e);if(!o.xml_isQName(e))throw new n.InvalidCharacterError("Invalid XML qualified name: "+e+".")}t.namespace_validate=a,t.namespace_validateAndExtract=function(e,t){e||(e=null),a(t);var r=t.split(":"),o=2===r.length?r[0]:null,s=2===r.length?r[1]:t;if(o&&null===e)throw new n.NamespaceError("Qualified name includes a prefix but the namespace is null.");if("xml"===o&&e!==i.namespace.XML)throw new n.NamespaceError('Qualified name includes the "xml" prefix but the namespace is not the XML namespace.');if(e!==i.namespace.XMLNS&&("xmlns"===o||"xmlns"===t))throw new n.NamespaceError('Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.');if(e===i.namespace.XMLNS&&"xmlns"!==o&&"xmlns"!==t)throw new n.NamespaceError('Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.');return[e,o,s]},t.namespace_extractQName=function(e){a(e);var t=e.split(":");return[2===t.length?t[0]:null,2===t.length?t[1]:e]}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.xml_isName=function(e){for(var t=0;t<e.length;t++){var r=e.charCodeAt(t);if(!(r>=97&&r<=122||r>=65&&r<=90||58===r||95===r||r>=192&&r<=214||r>=216&&r<=246||r>=248&&r<=767||r>=880&&r<=893||r>=895&&r<=8191||r>=8204&&r<=8205||r>=8304&&r<=8591||r>=11264&&r<=12271||r>=12289&&r<=55295||r>=63744&&r<=64975||r>=65008&&r<=65533)&&(0===t||!(45===r||46===r||r>=48&&r<=57||183===r||r>=768&&r<=879||r>=8255&&r<=8256))){if(r>=55296&&r<=56319&&t<e.length-1){var n=e.charCodeAt(t+1);if(n>=56320&&n<=57343&&(t++,(r=1024*(r-55296)+n-56320+65536)>=65536&&r<=983039))continue}return!1}}return!0},t.xml_isQName=function(e){for(var t=!1,r=0;r<e.length;r++){var n=e.charCodeAt(r);if(!(n>=97&&n<=122||n>=65&&n<=90||95===n||n>=192&&n<=214||n>=216&&n<=246||n>=248&&n<=767||n>=880&&n<=893||n>=895&&n<=8191||n>=8204&&n<=8205||n>=8304&&n<=8591||n>=11264&&n<=12271||n>=12289&&n<=55295||n>=63744&&n<=64975||n>=65008&&n<=65533)&&(0===r||!(45===n||46===n||n>=48&&n<=57||183===n||n>=768&&n<=879||n>=8255&&n<=8256))){if(0===r||58!==n){if(n>=55296&&n<=56319&&r<e.length-1){var i=e.charCodeAt(r+1);if(i>=56320&&i<=57343&&(r++,(n=1024*(n-55296)+i-56320+65536)>=65536&&n<=983039))continue}return!1}if(t)return!1;if(r===e.length-1)return!1;t=!0}}return!0},t.xml_isLegalChar=function(e){for(var t=0;t<e.length;t++){var r=e.charCodeAt(t);if(!(9===r||10===r||13===r||r>=32&&r<=55295||r>=57344&&r<=65533)){if(r>=55296&&r<=56319&&t<e.length-1){var n=e.charCodeAt(t+1);if(n>=56320&&n<=57343&&(t++,(r=1024*(r-55296)+n-56320+65536)>=65536&&r<=1114111))continue}return!1}}return!0},t.xml_isPubidChar=function(e){for(var t=0;t<e.length;t++){var r=e.charCodeAt(t);if(!(r>=97&&r<=122||r>=65&&r<=90||r>=39&&r<=59||32===r||13===r||10===r||r>=35&&r<=37||33===r||61===r||63===r||64===r||95===r))return!1}return!0}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=r(17);t.boundaryPoint_position=function e(t,r){var o=t[0],a=t[1],s=r[0],u=r[1];if(console.assert(i.tree_rootNode(o)===i.tree_rootNode(s),"Boundary points must share the same root node."),o===s)return a===u?n.BoundaryPosition.Equal:a<u?n.BoundaryPosition.Before:n.BoundaryPosition.After;if(i.tree_isFollowing(s,o)){var l=e([s,u],[o,a]);if(l===n.BoundaryPosition.Before)return n.BoundaryPosition.After;if(l===n.BoundaryPosition.After)return n.BoundaryPosition.Before}if(i.tree_isAncestorOf(s,o)){for(var c=s;!i.tree_isChildOf(o,c);)null!==c._parent&&(c=c._parent);if(i.tree_index(c)<a)return n.BoundaryPosition.After}return n.BoundaryPosition.Before}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(3),a=r(7),s=r(29),u=r(108),l=r(30),c=r(37),h=r(52);t.node_stringReplaceAll=function(e,t){var r=null;""!==e&&(r=s.create_text(t._nodeDocument,e)),c.mutation_replaceAll(r,t)},t.node_clone=function e(t,r,a){var u,p,f,d,m;if(void 0===r&&(r=null),void 0===a&&(a=!1),null===r&&(r=t._nodeDocument),o.Guard.isElementNode(t)){m=h.element_createAnElement(r,t._localName,t._namespace,t._namespacePrefix,t._is,!1);try{for(var y=n(t._attributeList),v=y.next();!v.done;v=y.next()){var _=e(v.value,r);h.element_append(_,m)}}catch(e){u={error:e}}finally{try{v&&!v.done&&(p=y.return)&&p.call(y)}finally{if(u)throw u.error}}}else if(o.Guard.isDocumentNode(t)){var g=s.create_document();g._encoding=t._encoding,g._contentType=t._contentType,g._URL=t._URL,g._origin=t._origin,g._type=t._type,g._mode=t._mode,m=g}else if(o.Guard.isDocumentTypeNode(t)){m=s.create_documentType(r,t._name,t._publicId,t._systemId)}else if(o.Guard.isAttrNode(t)){var b=s.create_attr(r,t.localName);b._namespace=t._namespace,b._namespacePrefix=t._namespacePrefix,b._value=t._value,m=b}else m=o.Guard.isExclusiveTextNode(t)?s.create_text(r,t._data):o.Guard.isCDATASectionNode(t)?s.create_cdataSection(r,t._data):o.Guard.isCommentNode(t)?s.create_comment(r,t._data):o.Guard.isProcessingInstructionNode(t)?s.create_processingInstruction(r,t._target,t._data):o.Guard.isDocumentFragmentNode(t)?s.create_documentFragment(r):Object.create(t);if(o.Guard.isDocumentNode(m)?(m._nodeDocument=m,r=m):m._nodeDocument=r,i.dom.features.steps&&l.dom_runCloningSteps(m,t,r,a),a)try{for(var x=n(t._children),w=x.next();!w.done;w=x.next()){var E=e(w.value,r,!0);c.mutation_append(E,m)}}catch(e){f={error:e}}finally{try{w&&!w.done&&(d=x.return)&&d.call(x)}finally{if(f)throw f.error}}return m},t.node_equals=function e(t,r){var i,a,s,u;if(t._nodeType!==r._nodeType)return!1;if(o.Guard.isDocumentTypeNode(t)&&o.Guard.isDocumentTypeNode(r)){if(t._name!==r._name||t._publicId!==r._publicId||t._systemId!==r._systemId)return!1}else if(o.Guard.isElementNode(t)&&o.Guard.isElementNode(r)){if(t._namespace!==r._namespace||t._namespacePrefix!==r._namespacePrefix||t._localName!==r._localName||t._attributeList.length!==r._attributeList.length)return!1}else if(o.Guard.isAttrNode(t)&&o.Guard.isAttrNode(r)){if(t._namespace!==r._namespace||t._localName!==r._localName||t._value!==r._value)return!1}else if(o.Guard.isProcessingInstructionNode(t)&&o.Guard.isProcessingInstructionNode(r)){if(t._target!==r._target||t._data!==r._data)return!1}else if(o.Guard.isCharacterDataNode(t)&&o.Guard.isCharacterDataNode(r)&&t._data!==r._data)return!1;if(o.Guard.isElementNode(t)&&o.Guard.isElementNode(r)){var l={};try{for(var c=n(t._attributeList),h=c.next();!h.done;h=c.next()){l[(d=h.value)._localName]=d}}catch(e){i={error:e}}finally{try{h&&!h.done&&(a=c.return)&&a.call(c)}finally{if(i)throw i.error}}try{for(var p=n(r._attributeList),f=p.next();!f.done;f=p.next()){var d,m=f.value;if(!(d=l[m._localName]))return!1;if(!e(d,m))return!1}}catch(e){s={error:e}}finally{try{f&&!f.done&&(u=p.return)&&u.call(p)}finally{if(s)throw s.error}}}if(t._children.size!==r._children.size)return!1;for(var y=t._children[Symbol.iterator](),v=r._children[Symbol.iterator](),_=y.next(),g=v.next();!_.done&&!g.done;){if(!e(_.value,g.value))return!1;_=y.next(),g=v.next()}return!0},t.node_listOfElementsWithQualifiedName=function(e,t){return"*"===e?s.create_htmlCollection(t):"html"===t._nodeDocument._type?s.create_htmlCollection(t,(function(t){return t._namespace===a.namespace.HTML&&t._qualifiedName===e.toLowerCase()||t._namespace!==a.namespace.HTML&&t._qualifiedName===e})):s.create_htmlCollection(t,(function(t){return t._qualifiedName===e}))},t.node_listOfElementsWithNamespace=function(e,t,r){return""===e&&(e=null),"*"===e&&"*"===t?s.create_htmlCollection(r):"*"===e?s.create_htmlCollection(r,(function(e){return e._localName===t})):"*"===t?s.create_htmlCollection(r,(function(t){return t._namespace===e})):s.create_htmlCollection(r,(function(r){return r._localName===t&&r._namespace===e}))},t.node_listOfElementsWithClassNames=function(e,t){var r=u.orderedSet_parse(e);if(0===r.size)return s.create_htmlCollection(t,(function(){return!1}));var n="quirks"!==t._nodeDocument._mode;return s.create_htmlCollection(t,(function(e){var t=e.classList;return u.orderedSet_contains(t._tokenSet,r,n)}))},t.node_locateANamespacePrefix=function e(t,r){if(t._namespace===r&&null!==t._namespacePrefix)return t._namespacePrefix;for(var n=0;n<t._attributeList.length;n++){var i=t._attributeList[n];if("xmlns"===i._namespacePrefix&&i._value===r)return i._localName}return t._parent&&o.Guard.isElementNode(t._parent)?e(t._parent,r):null},t.node_locateANamespace=function e(t,r){if(o.Guard.isElementNode(t)){if(null!==t._namespace&&t._namespacePrefix===r)return t._namespace;for(var n=0;n<t._attributeList.length;n++){var i=t._attributeList[n];if(i._namespace===a.namespace.XMLNS&&"xmlns"===i._namespacePrefix&&i._localName===r)return i._value||null;if(null===r&&i._namespace===a.namespace.XMLNS&&null===i._namespacePrefix&&"xmlns"===i._localName)return i._value||null}return null===t.parentElement?null:e(t.parentElement,r)}return o.Guard.isDocumentNode(t)?null===t.documentElement?null:e(t.documentElement,r):o.Guard.isDocumentTypeNode(t)||o.Guard.isDocumentFragmentNode(t)?null:o.Guard.isAttrNode(t)?null===t._element?null:e(t._element,r):t._parent&&o.Guard.isElementNode(t._parent)?e(t._parent,r):null}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(3),a=r(9),s=r(29),u=r(17),l=r(107),c=r(37);t.text_contiguousTextNodes=function(e,t){var r;return void 0===t&&(t=!1),(r={})[Symbol.iterator]=function(){for(var r=e;r&&o.Guard.isTextNode(r._previousSibling);)r=r._previousSibling;return{next:function(){if(r&&!t&&r===e&&(r=o.Guard.isTextNode(r._nextSibling)?r._nextSibling:null),null===r)return{done:!0,value:null};var n={done:!1,value:r};return r=o.Guard.isTextNode(r._nextSibling)?r._nextSibling:null,n}}},r},t.text_contiguousExclusiveTextNodes=function(e,t){var r;return void 0===t&&(t=!1),(r={})[Symbol.iterator]=function(){for(var r=e;r&&o.Guard.isExclusiveTextNode(r._previousSibling);)r=r._previousSibling;return{next:function(){if(r&&!t&&r===e&&(r=o.Guard.isExclusiveTextNode(r._nextSibling)?r._nextSibling:null),null===r)return{done:!0,value:null};var n={done:!1,value:r};return r=o.Guard.isExclusiveTextNode(r._nextSibling)?r._nextSibling:null,n}}},r},t.text_descendantTextContent=function(e){for(var t="",r=u.tree_getFirstDescendantNode(e,!1,!1,(function(e){return o.Guard.isTextNode(e)}));null!==r;)t+=r._data,r=u.tree_getNextDescendantNode(e,r,!1,!1,(function(e){return o.Guard.isTextNode(e)}));return t},t.text_split=function(e,t){var r,o,h=e._data.length;if(t>h)throw new a.IndexSizeError;var p=h-t,f=l.characterData_substringData(e,t,p),d=s.create_text(e._nodeDocument,f),m=e._parent;if(null!==m){c.mutation_insert(d,m,e._nextSibling);try{for(var y=n(i.dom.rangeList),v=y.next();!v.done;v=y.next()){var _=v.value;_._start[0]===e&&_._start[1]>t&&(_._start[0]=d,_._start[1]-=t),_._end[0]===e&&_._end[1]>t&&(_._end[0]=d,_._end[1]-=t);var g=u.tree_index(e);_._start[0]===m&&_._start[1]===g+1&&_._start[1]++,_._end[0]===m&&_._end[1]===g+1&&_._end[1]++}}catch(e){r={error:e}}finally{try{v&&!v.done&&(o=y.return)&&o.call(y)}finally{if(r)throw r.error}}}return l.characterData_replaceData(e,t,p,""),d}},function(e,t,r){"use strict";var n=r(4),i=r(41),o=r(24),a=r(48),s=[].join,u=i!=Object,l=a("join",",");n({target:"Array",proto:!0,forced:u||!l},{join:function(e){return s.call(o(this),void 0===e?",":e)}})},function(e,t,r){var n=r(4),i=r(83),o=String.fromCharCode,a=String.fromCodePoint;n({target:"String",stat:!0,forced:!!a&&1!=a.length},{fromCodePoint:function(e){for(var t,r=[],n=arguments.length,a=0;n>a;){if(t=+arguments[a++],i(t,1114111)!==t)throw RangeError(t+" is not a valid code point");r.push(t<65536?o(t):o(55296+((t-=65536)>>10),t%1024+56320))}return r.join("")}})},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var i=r(111),o=function(){function e(e,t){this._options={skipWhitespaceOnlyText:!1},this.err={line:-1,col:-1,index:-1,str:""},this._str=e,this._index=0,this._length=e.length,t&&(this._options.skipWhitespaceOnlyText=t.skipWhitespaceOnlyText||!1)}return e.prototype.nextToken=function(){if(this.eof())return{type:i.TokenType.EOF};var t=this.skipIfStartsWith("<")?this.openBracket():this.text();return this._options.skipWhitespaceOnlyText&&t.type===i.TokenType.Text&&e.isWhiteSpaceToken(t)&&(t=this.nextToken()),t},e.prototype.openBracket=function(){return this.skipIfStartsWith("?")?this.skipIfStartsWith("xml")?e.isSpace(this._str[this._index])?this.declaration():(this.seek(-3),this.pi()):this.pi():this.skipIfStartsWith("!")?this.skipIfStartsWith("--")?this.comment():this.skipIfStartsWith("[CDATA[")?this.cdata():this.skipIfStartsWith("DOCTYPE")?this.doctype():void this.throwError("Invalid '!' in opening tag."):this.skipIfStartsWith("/")?this.closeTag():this.openTag()},e.prototype.declaration=function(){for(var e="",t="",r="";!this.eof();){if(this.skipSpace(),this.skipIfStartsWith("?>"))return{type:i.TokenType.Declaration,version:e,encoding:t,standalone:r};var o=n(this.attribute(),2),a=o[0],s=o[1];"version"===a?e=s:"encoding"===a?t=s:"standalone"===a?r=s:this.throwError("Invalid attribute name: "+a)}this.throwError("Missing declaration end symbol `?>`")},e.prototype.doctype=function(){var e="",t="";this.skipSpace();var r=this.takeUntil2("[",">",!0);return this.skipSpace(),this.skipIfStartsWith("PUBLIC")?(e=this.quotedString(),t=this.quotedString()):this.skipIfStartsWith("SYSTEM")&&(t=this.quotedString()),this.skipSpace(),this.skipIfStartsWith("[")&&(this.skipUntil("]"),this.skipIfStartsWith("]")||this.throwError("Missing end bracket of DTD internal subset")),this.skipSpace(),this.skipIfStartsWith(">")||this.throwError("Missing doctype end symbol `>`"),{type:i.TokenType.DocType,name:r,pubId:e,sysId:t}},e.prototype.pi=function(){var e=this.takeUntilStartsWith("?>",!0);if(this.eof()&&this.throwError("Missing processing instruction end symbol `?>`"),this.skipSpace(),this.skipIfStartsWith("?>"))return{type:i.TokenType.PI,target:e,data:""};var t=this.takeUntilStartsWith("?>");return this.eof()&&this.throwError("Missing processing instruction end symbol `?>`"),this.seek(2),{type:i.TokenType.PI,target:e,data:t}},e.prototype.text=function(){var e=this.takeUntil("<");return{type:i.TokenType.Text,data:e}},e.prototype.comment=function(){var e=this.takeUntilStartsWith("--\x3e");return this.eof()&&this.throwError("Missing comment end symbol `--\x3e`"),this.seek(3),{type:i.TokenType.Comment,data:e}},e.prototype.cdata=function(){var e=this.takeUntilStartsWith("]]>");return this.eof()&&this.throwError("Missing CDATA end symbol `]>`"),this.seek(3),{type:i.TokenType.CDATA,data:e}},e.prototype.openTag=function(){this.skipSpace();var e=this.takeUntil2(">","/",!0);if(this.skipSpace(),this.skipIfStartsWith(">"))return{type:i.TokenType.Element,name:e,attributes:[],selfClosing:!1};if(this.skipIfStartsWith("/>"))return{type:i.TokenType.Element,name:e,attributes:[],selfClosing:!0};for(var t=[];!this.eof();){if(this.skipSpace(),this.skipIfStartsWith(">"))return{type:i.TokenType.Element,name:e,attributes:t,selfClosing:!1};if(this.skipIfStartsWith("/>"))return{type:i.TokenType.Element,name:e,attributes:t,selfClosing:!0};var r=this.attribute();t.push(r)}this.throwError("Missing opening element tag end symbol `>`")},e.prototype.closeTag=function(){this.skipSpace();var e=this.takeUntil(">",!0);return this.skipSpace(),this.skipIfStartsWith(">")||this.throwError("Missing closing element tag end symbol `>`"),{type:i.TokenType.ClosingTag,name:e}},e.prototype.attribute=function(){this.skipSpace();var e=this.takeUntil("=",!0);return this.skipSpace(),this.skipIfStartsWith("=")||this.throwError("Missing equals sign before attribute value"),[e,this.quotedString()]},e.prototype.quotedString=function(){this.skipSpace();var t=this.take(1);e.isQuote(t)||this.throwError("Missing start quote character before quoted value");var r=this.takeUntil(t);return this.skipIfStartsWith(t)||this.throwError("Missing end quote character after quoted value"),r},e.prototype.eof=function(){return this._index>=this._length},e.prototype.skipIfStartsWith=function(e){var t=e.length;if(1===t)return this._str[this._index]===e&&(this._index++,!0);for(var r=0;r<t;r++)if(this._str[this._index+r]!==e[r])return!1;return this._index+=t,!0},e.prototype.seek=function(e){this._index+=e,this._index<0&&(this._index=0),this._index>this._length&&(this._index=this._length)},e.prototype.skipSpace=function(){for(;!this.eof()&&e.isSpace(this._str[this._index]);)this._index++},e.prototype.take=function(e){if(1===e)return this._str[this._index++];var t=this._index;return this.seek(e),this._str.slice(t,this._index)},e.prototype.takeUntil=function(t,r){void 0===r&&(r=!1);for(var n=this._index;this._index<this._length;){var i=this._str[this._index];if(i===t||r&&e.isSpace(i))break;this._index++}return this._str.slice(n,this._index)},e.prototype.takeUntil2=function(t,r,n){void 0===n&&(n=!1);for(var i=this._index;this._index<this._length;){var o=this._str[this._index];if(o===t||o===r||n&&e.isSpace(o))break;this._index++}return this._str.slice(i,this._index)},e.prototype.takeUntilStartsWith=function(t,r){void 0===r&&(r=!1);for(var n=this._index,i=t.length;this._index<this._length;){for(var o=!0,a=0;a<i;a++){var s=this._str[this._index+a],u=t[a];if(r&&e.isSpace(s))return this._str.slice(n,this._index);if(s!==u){this._index++,o=!1;break}}if(o)return this._str.slice(n,this._index)}return this._index=this._length,this._str.slice(n)},e.prototype.skipUntil=function(e){for(;this._index<this._length;){if(this._str[this._index]===e)break;this._index++}},e.isWhiteSpaceToken=function(e){for(var t=e.data,r=0;r<t.length;r++){var n=t[r];if(" "!==n&&"\n"!==n&&"\r"!==n&&"\t"!==n&&"\f"!==n)return!1}return!0},e.isSpace=function(e){return" "===e||"\n"===e||"\r"===e||"\t"===e},e.isQuote=function(e){return'"'===e||"'"===e},e.prototype.throwError=function(e){for(var t=/\r\n|\r|\n/g,r=null,n=0,i=0,o=this._str.length;null!==(r=t.exec(this._str))&&null!==r;)if(n++,r.index<this._index&&(i=t.lastIndex),r.index>this._index){o=r.index;break}throw this.err={line:n,col:this._index-i,index:this._index,str:this._str.substring(i,o)},new Error(e+"\nIndex: "+this.err.index+"\nLn: "+this.err.line+", Col: "+this.err.col+"\nInput: "+this.err.str)},e.prototype[Symbol.iterator]=function(){return this._index=0,{next:function(){var e=this.nextToken();return e.type===i.TokenType.EOF?{done:!0,value:null}:{done:!1,value:e}}.bind(this)}},e}();t.XMLStringLexer=o},function(e,t,r){"use strict";var n=r(39);e.exports=new n({include:[r(182)]})},function(e,t,r){"use strict";var n=r(39);e.exports=new n({include:[r(113)],implicit:[r(289),r(290),r(291),r(292)]})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(91),i=r(1),o=r(3),a=r(77),s=r(109);function u(e,t){var r=c(void 0===e||l(e)?e:n.DefaultBuilderOptions),i=l(e)?t:e,o=s.createDocument();h(o,r);var u=new a.XMLBuilderImpl(o);return void 0!==i&&u.ele(i),u}function l(e){if(!i.isPlainObject(e))return!1;for(var t in e)if(e.hasOwnProperty(t)&&!n.XMLBuilderOptionKeys.has(t))return!1;return!0}function c(e){void 0===e&&(e={});var t=i.applyDefaults(e,n.DefaultBuilderOptions);if(0===t.convert.att.length||0===t.convert.ins.length||0===t.convert.text.length||0===t.convert.cdata.length||0===t.convert.comment.length)throw new Error("JS object converter strings cannot be zero length.");return t}function h(e,t,r){var n=e;n._xmlBuilderOptions=t,n._isFragment=r}t.builder=function(e,t){var r=c(l(e)?e:n.DefaultBuilderOptions),s=o.Guard.isNode(e)||i.isArray(e)?e:t;if(void 0===s)throw new Error("Invalid arguments.");if(i.isArray(s)){for(var u=[],h=0;h<s.length;h++){var p=new a.XMLBuilderImpl(s[h]);p.set(r),u.push(p)}return u}var f=new a.XMLBuilderImpl(s);return f.set(r),f},t.create=u,t.fragment=function(e,t){var r=c(void 0===e||l(e)?e:n.DefaultBuilderOptions),i=l(e)?t:e,o=s.createDocument();h(o,r,!0);var u=new a.XMLBuilderImpl(o.createDocumentFragment());return void 0!==i&&u.ele(i),u},t.convert=function(e,t,r){var i,o,a;return l(e)&&void 0!==t?(i=e,o=t,a=r):(i=n.DefaultBuilderOptions,o=e,a=t||void 0),u(i,o).end(a)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(77);t.builder=n.builder,t.create=n.create,t.fragment=n.fragment,t.convert=n.convert,t.createCB=n.createCB,t.fragmentCB=n.fragmentCB},function(e,t,r){"use strict";r(31),r(32),r(33),r(191),r(192),r(194),r(64),r(19),r(198),r(199),r(89),r(201),r(65),r(20),r(66),r(22),r(23);var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var o=r(91),a=r(1),s=r(217),u=r(2),l=r(3),c=r(0),h=r(109),p=r(7),f=r(276),d=function(){function e(e){this._domNode=e}return Object.defineProperty(e.prototype,"node",{get:function(){return this._domNode},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"options",{get:function(){return this._options},enumerable:!0,configurable:!0}),e.prototype.set=function(e){return this._options=a.applyDefaults(a.applyDefaults(this._options,e,!0),o.DefaultBuilderOptions),this},e.prototype.ele=function(t,r,i){var o,s,u,l,p,d;if(a.isObject(t))return new f.ObjectReader(this._options).parse(this,t);if(null!==t&&/^\s*</.test(t))return new f.XMLReader(this._options).parse(this,t);if(null!==t&&/^\s*[\{\[]/.test(t))return new f.JSONReader(this._options).parse(this,t);if(null!==t&&/^(\s*|(#.*)|(%.*))*---/.test(t))return new f.YAMLReader(this._options).parse(this,t);if((null===t||a.isString(t))&&a.isString(r))l=(o=n([t,r,i],3))[0],p=o[1],d=o[2];else{if(null===t)throw new Error("Element name cannot be null. "+this._debugInfo());l=(s=n([void 0,t,a.isObject(r)?r:void 0],3))[0],p=s[1],d=s[2]}if(d&&(d=a.getValue(d)),l=(u=n(this._extractNamespace(h.sanitizeInput(l,this._options.invalidCharReplacement),h.sanitizeInput(p,this._options.invalidCharReplacement),!0),2))[0],p=u[1],void 0===l){var m=n(c.namespace_extractQName(p),1)[0];l=this.node.lookupNamespaceURI(m)}var y=null!=l?this._doc.createElementNS(l,p):this._doc.createElement(p);this.node.appendChild(y);var v=new e(y),_=this._doc.doctype;if(y===this._doc.documentElement&&null!==_){var g=this._doc.implementation.createDocumentType(this._doc.documentElement.tagName,_.publicId,_.systemId);this._doc.replaceChild(g,_)}return d&&!a.isEmpty(d)&&v.att(d),v},e.prototype.remove=function(){var e=this.up();return e.node.removeChild(this.node),e},e.prototype.att=function(e,t,r){var i,o,s,u,f,d,m=this;if(a.isMap(e)||a.isObject(e))return a.forEachObject(e,(function(e,t){return m.att(e,t)}),this),this;if(null!=e&&(e=a.getValue(e+"")),null!=t&&(t=a.getValue(t+"")),null!=r&&(r=a.getValue(r+"")),null!==e&&!a.isString(e)||!a.isString(t)||null!==r&&!a.isString(r)){if(!a.isString(e)||null!=t&&!a.isString(t))throw new Error("Attribute name and value not specified. "+this._debugInfo());u=(o=n([void 0,e,t],3))[0],f=o[1],d=o[2]}else u=(i=n([e,t,r],3))[0],f=i[1],d=i[2];if(this._options.keepNullAttributes&&null==d)d="";else if(null==d)return this;if(!l.Guard.isElementNode(this.node))throw new Error("An attribute can only be assigned to an element node.");var y=this.node;u=(s=n(this._extractNamespace(u,f,!1),2))[0],f=s[1],f=h.sanitizeInput(f,this._options.invalidCharReplacement),u=h.sanitizeInput(u,this._options.invalidCharReplacement),d=h.sanitizeInput(d,this._options.invalidCharReplacement);var v=n(c.namespace_extractQName(f),2),_=v[0],g=v[1],b=n(c.namespace_extractQName(y.prefix?y.prefix+":"+y.localName:y.localName),1)[0],x=null;return"xmlns"===_?(u=p.namespace.XMLNS,null===y.namespaceURI&&b===g&&(x=d)):null===_&&"xmlns"===g&&null===b&&(u=p.namespace.XMLNS,x=d),null!==x&&(this._updateNamespace(x),y=this.node),void 0!==u?y.setAttributeNS(u,f,d):y.setAttribute(f,d),this},e.prototype.removeAtt=function(e,t){var r,n,i=this;if(!l.Guard.isElementNode(this.node))throw new Error("An attribute can only be removed from an element node.");if(e=a.getValue(e),void 0!==t&&(t=a.getValue(t)),null!==e&&void 0===t)n=e;else{if(null!==e&&!a.isString(e)||void 0===t)throw new Error("Attribute namespace must be a string. "+this._debugInfo());r=e,n=t}return a.isArray(n)||a.isSet(n)?a.forEachArray(n,(function(e){return void 0===r?i.removeAtt(e):i.removeAtt(r,e)}),this):void 0!==r?(n=h.sanitizeInput(n,this._options.invalidCharReplacement),r=h.sanitizeInput(r,this._options.invalidCharReplacement),this.node.removeAttributeNS(r,n)):(n=h.sanitizeInput(n,this._options.invalidCharReplacement),this.node.removeAttribute(n)),this},e.prototype.txt=function(e){if(null==e){if(!this._options.keepNullNodes)return this;e=""}var t=this._doc.createTextNode(h.sanitizeInput(e,this._options.invalidCharReplacement));return this.node.appendChild(t),this},e.prototype.com=function(e){if(null==e){if(!this._options.keepNullNodes)return this;e=""}var t=this._doc.createComment(h.sanitizeInput(e,this._options.invalidCharReplacement));return this.node.appendChild(t),this},e.prototype.dat=function(e){if(null==e){if(!this._options.keepNullNodes)return this;e=""}var t=this._doc.createCDATASection(h.sanitizeInput(e,this._options.invalidCharReplacement));return this.node.appendChild(t),this},e.prototype.ins=function(e,t){var r=this;if(void 0===t&&(t=""),null==t){if(!this._options.keepNullNodes)return this;t=""}if(a.isArray(e)||a.isSet(e))a.forEachArray(e,(function(e){var t=(e+="").indexOf(" "),n=-1===t?e:e.substr(0,t),i=-1===t?"":e.substr(t+1);r.ins(n,i)}),this);else if(a.isMap(e)||a.isObject(e))a.forEachObject(e,(function(e,t){return r.ins(e,t)}),this);else{var n=this._doc.createProcessingInstruction(h.sanitizeInput(e,this._options.invalidCharReplacement),h.sanitizeInput(t,this._options.invalidCharReplacement));this.node.appendChild(n)}return this},e.prototype.dec=function(e){return this._options.version=e.version||"1.0",this._options.encoding=e.encoding,this._options.standalone=e.standalone,this},e.prototype.dtd=function(e){var t=h.sanitizeInput(e&&e.name||(this._doc.documentElement?this._doc.documentElement.tagName:"ROOT"),this._options.invalidCharReplacement),r=h.sanitizeInput(e&&e.pubID||"",this._options.invalidCharReplacement),n=h.sanitizeInput(e&&e.sysID||"",this._options.invalidCharReplacement);if(null!==this._doc.documentElement&&t!==this._doc.documentElement.tagName)throw new Error("DocType name does not match document element name.");var i=this._doc.implementation.createDocumentType(t,r,n);return null!==this._doc.doctype?this._doc.replaceChild(i,this._doc.doctype):this._doc.insertBefore(i,this._doc.documentElement),this},e.prototype.import=function(t){var r,o,a=this._domNode,s=this._doc,u=t.node;if(l.Guard.isDocumentNode(u)){var h=u.documentElement;if(null===h)throw new Error("Imported document has no document element node. "+this._debugInfo());var p=s.importNode(h,!0);a.appendChild(p);var f=n(c.namespace_extractQName(p.prefix?p.prefix+":"+p.localName:p.localName),1)[0],d=a.lookupNamespaceURI(f);new e(p)._updateNamespace(d)}else if(l.Guard.isDocumentFragmentNode(u))try{for(var m=i(u.childNodes),y=m.next();!y.done;y=m.next()){var v=y.value;p=s.importNode(v,!0);if(a.appendChild(p),l.Guard.isElementNode(p)){f=n(c.namespace_extractQName(p.prefix?p.prefix+":"+p.localName:p.localName),1)[0],d=a.lookupNamespaceURI(f);new e(p)._updateNamespace(d)}}}catch(e){r={error:e}}finally{try{y&&!y.done&&(o=m.return)&&o.call(m)}finally{if(r)throw r.error}}else{p=s.importNode(u,!0);if(a.appendChild(p),l.Guard.isElementNode(p)){f=n(c.namespace_extractQName(p.prefix?p.prefix+":"+p.localName:p.localName),1)[0],d=a.lookupNamespaceURI(f);new e(p)._updateNamespace(d)}}return this},e.prototype.doc=function(){if(this._doc._isFragment){for(var t=this.node;t&&t.nodeType!==u.NodeType.DocumentFragment;)t=t.parentNode;if(null===t)throw new Error("Node has no parent node while searching for document fragment ancestor. "+this._debugInfo());return new e(t)}return new e(this._doc)},e.prototype.root=function(){var t=this._doc.documentElement;if(!t)throw new Error("Document root element is null. "+this._debugInfo());return new e(t)},e.prototype.up=function(){var t=this._domNode.parentNode;if(!t)throw new Error("Parent node is null. "+this._debugInfo());return new e(t)},e.prototype.prev=function(){var t=this._domNode.previousSibling;if(!t)throw new Error("Previous sibling node is null. "+this._debugInfo());return new e(t)},e.prototype.next=function(){var t=this._domNode.nextSibling;if(!t)throw new Error("Next sibling node is null. "+this._debugInfo());return new e(t)},e.prototype.first=function(){var t=this._domNode.firstChild;if(!t)throw new Error("First child node is null. "+this._debugInfo());return new e(t)},e.prototype.last=function(){var t=this._domNode.lastChild;if(!t)throw new Error("Last child node is null. "+this._debugInfo());return new e(t)},e.prototype.each=function(t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=this._getFirstDescendantNode(this._domNode,r,n);o[0];){var a=this._getNextDescendantNode(this._domNode,o[0],n,o[1],o[2]);t.call(i,new e(o[0]),o[1],o[2]),o=a}return this},e.prototype.map=function(e,t,r,n){void 0===t&&(t=!1),void 0===r&&(r=!1);var i=[];return this.each((function(t,r,o){return i.push(e.call(n,t,r,o))}),t,r),i},e.prototype.reduce=function(e,t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);var o=t;return this.each((function(t,r,n){return o=e.call(i,o,t,r,n)}),r,n),o},e.prototype.find=function(t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=this._getFirstDescendantNode(this._domNode,r,n);o[0];){var a=new e(o[0]);if(t.call(i,a,o[1],o[2]))return a;o=this._getNextDescendantNode(this._domNode,o[0],n,o[1],o[2])}},e.prototype.filter=function(e,t,r,n){void 0===t&&(t=!1),void 0===r&&(r=!1);var i=[];return this.each((function(t,r,o){e.call(n,t,r,o)&&i.push(t)}),t,r),i},e.prototype.every=function(t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=this._getFirstDescendantNode(this._domNode,r,n);o[0];){var a=new e(o[0]);if(!t.call(i,a,o[1],o[2]))return!1;o=this._getNextDescendantNode(this._domNode,o[0],n,o[1],o[2])}return!0},e.prototype.some=function(t,r,n,i){void 0===r&&(r=!1),void 0===n&&(n=!1);for(var o=this._getFirstDescendantNode(this._domNode,r,n);o[0];){var a=new e(o[0]);if(t.call(i,a,o[1],o[2]))return!0;o=this._getNextDescendantNode(this._domNode,o[0],n,o[1],o[2])}return!1},e.prototype.toArray=function(e,t){void 0===e&&(e=!1),void 0===t&&(t=!1);var r=[];return this.each((function(e){return r.push(e)}),e,t),r},e.prototype.toString=function(e){return void 0===(e=e||{}).format&&(e.format="xml"),this._serialize(e)},e.prototype.toObject=function(e){return void 0===(e=e||{}).format&&(e.format="object"),this._serialize(e)},e.prototype.end=function(e){return void 0===(e=e||{}).format&&(e.format="xml"),this.doc()._serialize(e)},e.prototype._getFirstDescendantNode=function(e,t,r){return t?[this._domNode,0,0]:r?this._getNextDescendantNode(e,e,r,0,0):[this._domNode.firstChild,0,1]},e.prototype._getNextDescendantNode=function(e,t,r,n,i){if(!r)return e===t?[t.firstChild,0,i+1]:[t.nextSibling,n+1,i];if(t.firstChild)return[t.firstChild,0,i+1];if(t===e)return[null,-1,-1];if(t.nextSibling)return[t.nextSibling,n+1,i];for(var o=t.parentNode;o&&o!==e;){if(o.nextSibling)return[o.nextSibling,c.tree_index(o.nextSibling),i-1];o=o.parentNode,i--}return[null,-1,-1]},e.prototype._serialize=function(e){if("xml"===e.format)return new s.XMLWriter(this._options,e).serialize(this.node);if("map"===e.format)return new s.MapWriter(this._options,e).serialize(this.node);if("object"===e.format)return new s.ObjectWriter(this._options,e).serialize(this.node);if("json"===e.format)return new s.JSONWriter(this._options,e).serialize(this.node);if("yaml"===e.format)return new s.YAMLWriter(this._options,e).serialize(this.node);throw new Error("Invalid writer format: "+e.format+". "+this._debugInfo())},e.prototype._extractNamespace=function(e,t,r){var n=t.indexOf("@");if(n>0&&(void 0===e&&(e=t.slice(n+1)),t=t.slice(0,n)),void 0===e)e=r?this._options.defaultNamespace.ele:this._options.defaultNamespace.att;else if(null!==e&&"@"===e[0]){var i=e.slice(1);if(void 0===(e=this._options.namespaceAlias[i]))throw new Error("Namespace alias `"+i+"` is not defined. "+this._debugInfo())}return[e,t]},e.prototype._updateNamespace=function(t){var r,o,a,s,u=this._domNode;if(l.Guard.isElementNode(u)&&null!==t&&u.namespaceURI!==t){var h=n(c.namespace_extractQName(u.prefix?u.prefix+":"+u.localName:u.localName),2),p=h[0],f=h[1],d=c.create_element(this._doc,f,t,p);try{for(var m=i(u.attributes),y=m.next();!y.done;y=m.next()){var v=y.value,_=v.prefix?v.prefix+":"+v.localName:v.localName,g=n(c.namespace_extractQName(_),1)[0],b=v.namespaceURI;null===b&&null!==g&&(b=u.lookupNamespaceURI(g)),null===b?d.setAttribute(_,v.value):d.setAttributeNS(b,_,v.value)}}catch(e){r={error:e}}finally{try{y&&!y.done&&(o=m.return)&&o.call(m)}finally{if(r)throw r.error}}var x=u.parentNode;if(null===x)throw new Error("Parent node is null."+this._debugInfo());x.replaceChild(d,u),this._domNode=d;try{for(var w=i(u.childNodes),E=w.next();!E.done;E=w.next()){var D=E.value.cloneNode(!0);if(d.appendChild(D),l.Guard.isElementNode(D)){var S=n(c.namespace_extractQName(D.prefix?D.prefix+":"+D.localName:D.localName),1)[0],C=d.lookupNamespaceURI(S);new e(D)._updateNamespace(C)}}}catch(e){a={error:e}}finally{try{E&&!E.done&&(s=w.return)&&s.call(w)}finally{if(a)throw a.error}}}},Object.defineProperty(e.prototype,"_doc",{get:function(){var e=this.node;if(l.Guard.isDocumentNode(e))return e;var t=e.ownerDocument;if(!t)throw new Error("Owner document is null. "+this._debugInfo());return t},enumerable:!0,configurable:!0}),e.prototype._debugInfo=function(e){var t=this.node,r=t.parentNode;e=e||t.nodeName;var n=r?r.nodeName:"";return n?"node: <"+e+">, parent: <"+n+">":"node: <"+e+">"},Object.defineProperty(e.prototype,"_options",{get:function(){var e=this._doc;if(void 0===e._xmlBuilderOptions)throw new Error("Builder options is not set.");return e._xmlBuilderOptions},set:function(e){this._doc._xmlBuilderOptions=e},enumerable:!0,configurable:!0}),e}();t.XMLBuilderImpl=d},function(e,t,r){var n=r(11),i=r(117),o=n.WeakMap;e.exports="function"==typeof o&&/native code/.test(i(o))},function(e,t,r){var n=r(46),i=r(82),o=r(85),a=r(18);e.exports=n("Reflect","ownKeys")||function(e){var t=i.f(a(e)),r=o.f;return r?t.concat(r(e)):t}},function(e,t,r){var n=r(16),i=r(15),o=r(18),a=r(61);e.exports=n?Object.defineProperties:function(e,t){o(e);for(var r,n=a(t),s=n.length,u=0;s>u;)i.f(e,r=n[u++],t[r]);return e}},function(e,t,r){var n=r(46);e.exports=n("document","documentElement")},function(e,t,r){var n=r(24),i=r(82).f,o={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];e.exports.f=function(e){return a&&"[object Window]"==o.call(e)?function(e){try{return i(e)}catch(e){return a.slice()}}(e):i(n(e))}},function(e,t,r){"use strict";var n=r(4),i=r(36).every,o=r(48),a=r(28),s=o("every"),u=a("every");n({target:"Array",proto:!0,forced:!s||!u},{every:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){"use strict";var n=r(4),i=r(36).filter,o=r(63),a=r(28),s=o("filter"),u=a("filter");n({target:"Array",proto:!0,forced:!s||!u},{filter:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){var n=r(46);e.exports=n("navigator","userAgent")||""},function(e,t,r){"use strict";var n=r(4),i=r(36).find,o=r(130),a=r(28),s=!0,u=a("find");"find"in[]&&Array(1).find((function(){s=!1})),n({target:"Array",proto:!0,forced:s||!u},{find:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}}),o("find")},function(e,t,r){"use strict";var n=r(131).IteratorPrototype,i=r(60),o=r(40),a=r(62),s=r(49),u=function(){return this};e.exports=function(e,t,r){var l=t+" Iterator";return e.prototype=i(n,{next:o(1,r)}),a(e,l,!1,!0),s[l]=u,e}},function(e,t,r){var n=r(8);e.exports=!n((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},function(e,t,r){var n=r(13);e.exports=function(e){if(!n(e)&&null!==e)throw TypeError("Can't set "+String(e)+" as a prototype");return e}},function(e,t,r){"use strict";var n=r(4),i=r(36).map,o=r(63),a=r(28),s=o("map"),u=a("map");n({target:"Array",proto:!0,forced:!s||!u},{map:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){"use strict";var n=r(4),i=r(200).left,o=r(48),a=r(28),s=o("reduce"),u=a("reduce",{1:0});n({target:"Array",proto:!0,forced:!s||!u},{reduce:function(e){return i(this,e,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){var n=r(127),i=r(27),o=r(41),a=r(26),s=function(e){return function(t,r,s,u){n(r);var l=i(t),c=o(l),h=a(l.length),p=e?h-1:0,f=e?-1:1;if(s<2)for(;;){if(p in c){u=c[p],p+=f;break}if(p+=f,e?p<0:h<=p)throw TypeError("Reduce of empty array with no initial value")}for(;e?p>=0:h>p;p+=f)p in c&&(u=r(u,c[p],p,l));return u}};e.exports={left:s(!1),right:s(!0)}},function(e,t,r){"use strict";var n=r(4),i=r(36).some,o=r(48),a=r(28),s=o("some"),u=a("some");n({target:"Array",proto:!0,forced:!s||!u},{some:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,t,r){"use strict";var n=r(90),i=r(135);e.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},function(e,t){e.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(e,t,r){var n=r(8);e.exports=!n((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(e,t,r){var n=r(5),i=r(49),o=n("iterator"),a=Array.prototype;e.exports=function(e){return void 0!==e&&(i.Array===e||a[o]===e)}},function(e,t,r){var n=r(135),i=r(49),o=r(5)("iterator");e.exports=function(e){if(null!=e)return e[o]||e["@@iterator"]||i[n(e)]}},function(e,t,r){var n=r(18);e.exports=function(e,t,r,i){try{return i?t(n(r)[0],r[1]):t(r)}catch(t){var o=e.return;throw void 0!==o&&n(o.call(e)),t}}},function(e,t,r){var n=r(5)("iterator"),i=!1;try{var o=0,a={next:function(){return{done:!!o++}},return:function(){i=!0}};a[n]=function(){return this},Array.from(a,(function(){throw 2}))}catch(e){}e.exports=function(e,t){if(!t&&!i)return!1;var r=!1;try{var o={};o[n]=function(){return{next:function(){return{done:r=!0}}}},e(o)}catch(e){}return r}},function(e,t,r){var n=r(13),i=r(133);e.exports=function(e,t,r){var o,a;return i&&"function"==typeof(o=t.constructor)&&o!==r&&n(a=o.prototype)&&a!==r.prototype&&i(e,a),e}},function(e,t,r){var n=r(25);e.exports=function(e,t,r){for(var i in t)n(e,i,t[i],r);return e}},function(e,t,r){"use strict";var n=r(46),i=r(15),o=r(5),a=r(16),s=o("species");e.exports=function(e){var t=n(e),r=i.f;a&&t&&!t[s]&&r(t,s,{configurable:!0,get:function(){return this}})}},function(e,t,r){"use strict";var n=this&&this.__generator||function(e,t){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e){void 0===e&&(e=1e3),this._items=new Set,this._limit=e}return e.prototype.add=function(e){if(this._items.add(e),this._items.size>this._limit){var t=this._items.values().next();t.done||this._items.delete(t.value)}return this},e.prototype.delete=function(e){return this._items.delete(e)},e.prototype.has=function(e){return this._items.has(e)},e.prototype.clear=function(){this._items.clear()},Object.defineProperty(e.prototype,"size",{get:function(){return this._items.size},enumerable:!0,configurable:!0}),e.prototype.forEach=function(e,t){var r=this;this._items.forEach((function(n){return e.call(t,n,n,r)}))},e.prototype.keys=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.keys())];case 1:return e.sent(),[2]}}))},e.prototype.values=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.values())];case 1:return e.sent(),[2]}}))},e.prototype.entries=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.entries())];case 1:return e.sent(),[2]}}))},e.prototype[Symbol.iterator]=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items)];case 1:return e.sent(),[2]}}))},Object.defineProperty(e.prototype,Symbol.toStringTag,{get:function(){return"FixedSizeSet"},enumerable:!0,configurable:!0}),e}();t.FixedSizeSet=o},function(e,t,r){"use strict";var n=this&&this.__generator||function(e,t){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e){void 0===e&&(e=1e3),this._items=new Map,this._limit=e}return e.prototype.get=function(e){return this._items.get(e)},e.prototype.set=function(e,t){if(this._items.set(e,t),this._items.size>this._limit){var r=this._items.keys().next();r.done||this._items.delete(r.value)}},e.prototype.delete=function(e){return this._items.delete(e)},e.prototype.has=function(e){return this._items.has(e)},e.prototype.clear=function(){this._items.clear()},Object.defineProperty(e.prototype,"size",{get:function(){return this._items.size},enumerable:!0,configurable:!0}),e.prototype.forEach=function(e,t){this._items.forEach((function(r,n){return e.call(t,n,r)}))},e.prototype.keys=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.keys())];case 1:return e.sent(),[2]}}))},e.prototype.values=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.values())];case 1:return e.sent(),[2]}}))},e.prototype.entries=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items.entries())];case 1:return e.sent(),[2]}}))},e.prototype[Symbol.iterator]=function(){return n(this,(function(e){switch(e.label){case 0:return[5,i(this._items)];case 1:return e.sent(),[2]}}))},Object.defineProperty(e.prototype,Symbol.toStringTag,{get:function(){return"ObjectCache"},enumerable:!0,configurable:!0}),e}();t.ObjectCache=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e){void 0===e&&(e=1e3),this._items=new Map,this._limit=e}return e.prototype.check=function(e,t){if(this._items.get(e)===t)return!0;if(this._items.get(t)===e)return!1;var r=Math.random()<.5;if(r?this._items.set(e,t):this._items.set(t,e),this._items.size>this._limit){var n=this._items.keys().next();n.done||this._items.delete(n.value)}return r},e}();t.CompareCache=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e){this._initialized=!1,this._value=void 0,this._initFunc=e}return Object.defineProperty(e.prototype,"value",{get:function(){return this._initialized||(this._value=this._initFunc(),this._initialized=!0),this._value},enumerable:!0,configurable:!0}),e}();t.Lazy=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e){this._pointer=0,this._chars=Array.from(e),this._length=this._chars.length}return Object.defineProperty(e.prototype,"eof",{get:function(){return this._pointer>=this._length},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._length},enumerable:!0,configurable:!0}),e.prototype.codePoint=function(){if(void 0===this._codePoint)if(this.eof)this._codePoint=-1;else{var e=this._chars[this._pointer].codePointAt(0);this._codePoint=void 0!==e?e:-1}return this._codePoint},e.prototype.c=function(){return void 0===this._c&&(this._c=this.eof?"":this._chars[this._pointer]),this._c},e.prototype.remaining=function(){return void 0===this._remaining&&(this._remaining=this.eof?"":this._chars.slice(this._pointer+1).join("")),this._remaining},e.prototype.substring=function(){return void 0===this._substring&&(this._substring=this.eof?"":this._chars.slice(this._pointer).join("")),this._substring},Object.defineProperty(e.prototype,"pointer",{get:function(){return this._pointer},set:function(e){e!==this._pointer&&(this._pointer=e,this._codePoint=void 0,this._c=void 0,this._remaining=void 0,this._substring=void 0)},enumerable:!0,configurable:!0}),e}();t.StringWalker=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(218);t.MapWriter=n.MapWriter;var i=r(258);t.XMLWriter=i.XMLWriter;var o=r(67);t.ObjectWriter=o.ObjectWriter;var a=r(260);t.JSONWriter=a.JSONWriter;var s=r(261);t.YAMLWriter=s.YAMLWriter},function(e,t,r){"use strict";r(19),r(219),r(20),r(22),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(1),a=r(67),s=function(e){function t(t,r){var n=e.call(this,t)||this;return n._writerOptions=o.applyDefaults(r,{format:"map",wellFormed:!1,group:!1,verbose:!1}),n}return i(t,e),t.prototype.serialize=function(e){var t=o.applyDefaults(this._writerOptions,{format:"object",wellFormed:!1,verbose:!1}),r=new a.ObjectWriter(this._builderOptions,t).serialize(e);return this._convertObject(r)},t.prototype._convertObject=function(e){if(o.isArray(e)){for(var t=0;t<e.length;t++)e[t]=this._convertObject(e[t]);return e}if(o.isObject(e)){var r=new Map;for(var n in e)r.set(n,this._convertObject(e[n]));return r}return e},t}(r(50).BaseWriter);t.MapWriter=s},function(e,t,r){"use strict";var n=r(139),i=r(143);e.exports=n("Map",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),i)},function(e,t,r){"use strict";var n=r(4),i=r(8),o=r(59),a=r(13),s=r(27),u=r(26),l=r(134),c=r(128),h=r(63),p=r(5),f=r(129),d=p("isConcatSpreadable"),m=f>=51||!i((function(){var e=[];return e[d]=!1,e.concat()[0]!==e})),y=h("concat"),v=function(e){if(!a(e))return!1;var t=e[d];return void 0!==t?!!t:o(e)};n({target:"Array",proto:!0,forced:!m||!y},{concat:function(e){var t,r,n,i,o,a=s(this),h=c(a,0),p=0;for(t=-1,n=arguments.length;t<n;t++)if(v(o=-1===t?a:arguments[t])){if(p+(i=u(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(r=0;r<i;r++,p++)r in o&&l(h,p,o[r])}else{if(p>=9007199254740991)throw TypeError("Maximum allowed index exceeded");l(h,p++,o)}return h.length=p,h}})},function(e,t,r){"use strict";var n=r(8);function i(e,t){return RegExp(e,t)}t.UNSUPPORTED_Y=n((function(){var e=i("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),t.BROKEN_CARET=n((function(){var e=i("^r","gy");return e.lastIndex=2,null!=e.exec("str")}))},function(e,t,r){var n=r(223);e.exports=function(e){if(n(e))throw TypeError("The method doesn't accept regular expressions");return e}},function(e,t,r){var n=r(13),i=r(42),o=r(5)("match");e.exports=function(e){var t;return n(e)&&(void 0!==(t=e[o])?!!t:"RegExp"==i(e))}},function(e,t,r){var n=r(5)("match");e.exports=function(e){var t=/./;try{"/./"[e](t)}catch(r){try{return t[n]=!1,"/./"[e](t)}catch(e){}}return!1}},function(e,t,r){"use strict";r(68);var n=r(25),i=r(8),o=r(5),a=r(93),s=r(21),u=o("species"),l=!i((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")})),c="$0"==="a".replace(/./,"$0"),h=o("replace"),p=!!/./[h]&&""===/./[h]("a","$0"),f=!i((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var r="ab".split(e);return 2!==r.length||"a"!==r[0]||"b"!==r[1]}));e.exports=function(e,t,r,h){var d=o(e),m=!i((function(){var t={};return t[d]=function(){return 7},7!=""[e](t)})),y=m&&!i((function(){var t=!1,r=/a/;return"split"===e&&((r={}).constructor={},r.constructor[u]=function(){return r},r.flags="",r[d]=/./[d]),r.exec=function(){return t=!0,null},r[d](""),!t}));if(!m||!y||"replace"===e&&(!l||!c||p)||"split"===e&&!f){var v=/./[d],_=r(d,""[e],(function(e,t,r,n,i){return t.exec===a?m&&!i?{done:!0,value:v.call(t,r,n)}:{done:!0,value:e.call(r,t,n)}:{done:!1}}),{REPLACE_KEEPS_$0:c,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:p}),g=_[0],b=_[1];n(String.prototype,e,g),n(RegExp.prototype,d,2==t?function(e,t){return b.call(e,this,t)}:function(e){return b.call(e,this)})}h&&s(RegExp.prototype[d],"sham",!0)}},function(e,t,r){"use strict";var n=r(137).charAt;e.exports=function(e,t,r){return t+(r?n(e,t).length:1)}},function(e,t,r){var n=r(42),i=r(93);e.exports=function(e,t){var r=e.exec;if("function"==typeof r){var o=r.call(e,t);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==n(e))throw TypeError("RegExp#exec called on incompatible receiver");return i.call(e,t)}},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});var n=r(96);t.forgivingBase64Encode=function(t){return e.from(t).toString("base64")},t.forgivingBase64Decode=function(t){return""===t?"":((t=t.replace(n.ASCIIWhiteSpace,"")).length%4==0&&(t.endsWith("==")?t=t.substr(0,t.length-2):t.endsWith("=")&&(t=t.substr(0,t.length-1))),t.length%4==1?null:/[0-9A-Za-z+/]/.test(t)?e.from(t,"base64").toString("utf8"):null)}}).call(this,r(145).Buffer)},function(e,t,r){"use strict";t.byteLength=function(e){var t=l(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,n=l(e),a=n[0],s=n[1],u=new o(function(e,t,r){return 3*(t+r)/4-r}(0,a,s)),c=0,h=s>0?a-4:a;for(r=0;r<h;r+=4)t=i[e.charCodeAt(r)]<<18|i[e.charCodeAt(r+1)]<<12|i[e.charCodeAt(r+2)]<<6|i[e.charCodeAt(r+3)],u[c++]=t>>16&255,u[c++]=t>>8&255,u[c++]=255&t;2===s&&(t=i[e.charCodeAt(r)]<<2|i[e.charCodeAt(r+1)]>>4,u[c++]=255&t);1===s&&(t=i[e.charCodeAt(r)]<<10|i[e.charCodeAt(r+1)]<<4|i[e.charCodeAt(r+2)]>>2,u[c++]=t>>8&255,u[c++]=255&t);return u},t.fromByteArray=function(e){for(var t,r=e.length,i=r%3,o=[],a=0,s=r-i;a<s;a+=16383)o.push(c(e,a,a+16383>s?s:a+16383));1===i?(t=e[r-1],o.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[r-2]<<8)+e[r-1],o.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return o.join("")};for(var n=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,u=a.length;s<u;++s)n[s]=a[s],i[a.charCodeAt(s)]=s;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function c(e,t,r){for(var i,o,a=[],s=t;s<r;s+=3)i=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),a.push(n[(o=i)>>18&63]+n[o>>12&63]+n[o>>6&63]+n[63&o]);return a.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,r,n,i){var o,a,s=8*i-n-1,u=(1<<s)-1,l=u>>1,c=-7,h=r?i-1:0,p=r?-1:1,f=e[t+h];for(h+=p,o=f&(1<<-c)-1,f>>=-c,c+=s;c>0;o=256*o+e[t+h],h+=p,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=256*a+e[t+h],h+=p,c-=8);if(0===o)o=1-l;else{if(o===u)return a?NaN:1/0*(f?-1:1);a+=Math.pow(2,n),o-=l}return(f?-1:1)*a*Math.pow(2,o-n)},t.write=function(e,t,r,n,i,o){var a,s,u,l=8*o-i-1,c=(1<<l)-1,h=c>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:o-1,d=n?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-a))<1&&(a--,u*=2),(t+=a+h>=1?p/u:p*Math.pow(2,1-h))*u>=2&&(a++,u/=2),a+h>=c?(s=0,a=c):a+h>=1?(s=(t*u-1)*Math.pow(2,i),a+=h):(s=t*Math.pow(2,h-1)*Math.pow(2,i),a=0));i>=8;e[r+f]=255&s,f+=d,s/=256,i-=8);for(a=a<<i|s,l+=i;l>0;e[r+f]=255&a,f+=d,a/=256,l-=8);e[r+f-d]|=128*m}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(1);function o(e){var t,r;if(null===e||i.isString(e)||i.isNumber(e))return e;if(i.isArray(e)){var a=new Array;try{for(var s=n(e),u=s.next();!u.done;u=s.next()){var l=u.value;a.push(o(l))}}catch(e){t={error:e}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(t)throw t.error}}return a}if(i.isObject(e)){a=new Map;for(var c in e)if(e.hasOwnProperty(c)){var h=e[c];a.set(c,o(h))}return a}return e}t.parseJSONFromBytes=function(e){var t=i.utf8Decode(e);return JSON.parse.call(void 0,t)},t.serializeJSONToBytes=function(e){var t=JSON.stringify.call(void 0,e);return i.utf8Encode(t)},t.parseJSONIntoInfraValues=function(e){return o(JSON.parse.call(void 0,e))},t.convertAJSONDerivedJavaScriptValueToAnInfraValue=o},function(e,t,r){"use strict";var n=this&&this.__generator||function(e,t){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e},a=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var s=r(1);t.append=function(e,t){e.push(t)},t.extend=function(e,t){e.push.apply(e,o(t))},t.prepend=function(e,t){e.unshift(t)},t.replace=function(e,t,r){var n,i,o=0;try{for(var u=a(e),l=u.next();!l.done;l=u.next()){var c=l.value;if(s.isFunction(t))t.call(null,c)&&(e[o]=r);else if(c===t)return void(e[o]=r);o++}}catch(e){n={error:e}}finally{try{l&&!l.done&&(i=u.return)&&i.call(u)}finally{if(n)throw n.error}}},t.insert=function(e,t,r){e.splice(r,0,t)},t.remove=function(e,t){for(var r=e.length;r--;){var n=e[r];if(s.isFunction(t))t.call(null,n)&&e.splice(r,1);else if(n===t)return void e.splice(r,1)}},t.empty=function(e){e.length=0},t.contains=function(e,t){var r,n;try{for(var i=a(e),o=i.next();!o.done;o=i.next()){var u=o.value;if(s.isFunction(t)){if(t.call(null,u))return!0}else if(u===t)return!0}}catch(e){r={error:e}}finally{try{o&&!o.done&&(n=i.return)&&n.call(i)}finally{if(r)throw r.error}}return!1},t.size=function(e,t){var r,n;if(void 0===t)return e.length;var i=0;try{for(var o=a(e),s=o.next();!s.done;s=o.next()){var u=s.value;t.call(null,u)&&i++}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return i},t.isEmpty=function(e){return 0===e.length},t.forEach=function(e,t){var r,i,o,s,u,l;return n(this,(function(n){switch(n.label){case 0:return void 0!==t?[3,2]:[5,a(e)];case 1:return n.sent(),[3,9];case 2:n.trys.push([2,7,8,9]),r=a(e),i=r.next(),n.label=3;case 3:return i.done?[3,6]:(o=i.value,t.call(null,o)?[4,o]:[3,5]);case 4:n.sent(),n.label=5;case 5:return i=r.next(),[3,3];case 6:return[3,9];case 7:return s=n.sent(),u={error:s},[3,9];case 8:try{i&&!i.done&&(l=r.return)&&l.call(r)}finally{if(u)throw u.error}return[7];case 9:return[2]}}))},t.clone=function(e){return new(Array.bind.apply(Array,o([void 0],e)))},t.sortInAscendingOrder=function(e,t){return e.sort((function(e,r){return t.call(null,e,r)?-1:1}))},t.sortInDescendingOrder=function(e,t){return e.sort((function(e,r){return t.call(null,e,r)?1:-1}))}},function(e,t,r){"use strict";var n=this&&this.__generator||function(e,t){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},o=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},a=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(o(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var s=r(1);t.get=function(e,t){return e.get(t)},t.set=function(e,t,r){e.set(t,r)},t.remove=function(e,t){var r,n,o,a;if(s.isFunction(t)){var u=[];try{for(var l=i(e),c=l.next();!c.done;c=l.next()){var h=c.value;t.call(null,h)&&u.push(h[0])}}catch(e){r={error:e}}finally{try{c&&!c.done&&(n=l.return)&&n.call(l)}finally{if(r)throw r.error}}try{for(var p=i(u),f=p.next();!f.done;f=p.next()){var d=f.value;e.delete(d)}}catch(e){o={error:e}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(o)throw o.error}}}else e.delete(t)},t.contains=function(e,t){var r,n;if(s.isFunction(t)){try{for(var o=i(e),a=o.next();!a.done;a=o.next()){var u=a.value;if(t.call(null,u))return!0}}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return!1}return e.has(t)},t.keys=function(e){return new Set(e.keys())},t.values=function(e){return a(e.values())},t.size=function(e,t){var r,n;if(void 0===t)return e.size;var o=0;try{for(var a=i(e),s=a.next();!s.done;s=a.next()){var u=s.value;t.call(null,u)&&o++}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=a.return)&&n.call(a)}finally{if(r)throw r.error}}return o},t.isEmpty=function(e){return 0===e.size},t.forEach=function(e,t){var r,o,a,s,u,l;return n(this,(function(n){switch(n.label){case 0:return void 0!==t?[3,2]:[5,i(e)];case 1:return n.sent(),[3,9];case 2:n.trys.push([2,7,8,9]),r=i(e),o=r.next(),n.label=3;case 3:return o.done?[3,6]:(a=o.value,t.call(null,a)?[4,a]:[3,5]);case 4:n.sent(),n.label=5;case 5:return o=r.next(),[3,3];case 6:return[3,9];case 7:return s=n.sent(),u={error:s},[3,9];case 8:try{o&&!o.done&&(l=r.return)&&l.call(r)}finally{if(u)throw u.error}return[7];case 9:return[2]}}))},t.clone=function(e){return new Map(e)},t.sortInAscendingOrder=function(e,t){var r=new(Array.bind.apply(Array,a([void 0],e)));return r.sort((function(e,r){return t.call(null,e,r)?-1:1})),new Map(r)},t.sortInDescendingOrder=function(e,t){var r=new(Array.bind.apply(Array,a([void 0],e)));return r.sort((function(e,r){return t.call(null,e,r)?1:-1})),new Map(r)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HTML="http://www.w3.org/1999/xhtml",t.XML="http://www.w3.org/XML/1998/namespace",t.XMLNS="http://www.w3.org/2000/xmlns/",t.MathML="http://www.w3.org/1998/Math/MathML",t.SVG="http://www.w3.org/2000/svg",t.XLink="http://www.w3.org/1999/xlink"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.enqueue=function(e,t){e.push(t)},t.dequeue=function(e){return e.shift()||null}},function(e,t,r){"use strict";var n=this&&this.__generator||function(e,t){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},o=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},a=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(o(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var s=r(1);function u(e,t){var r,n;try{for(var o=i(e),a=o.next();!a.done;a=o.next()){var s=a.value;if(!t.has(s))return!1}}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return!0}t.append=function(e,t){e.add(t)},t.extend=function(e,t){t.forEach(e.add,e)},t.prepend=function(e,t){var r=new Set(e);e.clear(),e.add(t),r.forEach(e.add,e)},t.replace=function(e,t,r){var n,o,a=new Set;try{for(var u=i(e),l=u.next();!l.done;l=u.next()){var c=l.value;s.isFunction(t)?t.call(null,c)?a.add(r):a.add(c):c===t?a.add(r):a.add(c)}}catch(e){n={error:e}}finally{try{l&&!l.done&&(o=u.return)&&o.call(u)}finally{if(n)throw n.error}}e.clear(),a.forEach(e.add,e)},t.insert=function(e,t,r){var n,o,a=new Set,s=0;try{for(var u=i(e),l=u.next();!l.done;l=u.next()){var c=l.value;s===r&&a.add(t),a.add(c),s++}}catch(e){n={error:e}}finally{try{l&&!l.done&&(o=u.return)&&o.call(u)}finally{if(n)throw n.error}}e.clear(),a.forEach(e.add,e)},t.remove=function(e,t){var r,n,o,a;if(s.isFunction(t)){var u=[];try{for(var l=i(e),c=l.next();!c.done;c=l.next()){var h=c.value;t.call(null,h)&&u.push(h)}}catch(e){r={error:e}}finally{try{c&&!c.done&&(n=l.return)&&n.call(l)}finally{if(r)throw r.error}}try{for(var p=i(u),f=p.next();!f.done;f=p.next()){var d=f.value;e.delete(d)}}catch(e){o={error:e}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(o)throw o.error}}}else e.delete(t)},t.empty=function(e){e.clear()},t.contains=function(e,t){var r,n;if(!s.isFunction(t))return e.has(t);try{for(var o=i(e),a=o.next();!a.done;a=o.next()){var u=a.value;if(t.call(null,u))return!0}}catch(e){r={error:e}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(r)throw r.error}}return!1},t.size=function(e,t){var r,n;if(void 0===t)return e.size;var o=0;try{for(var a=i(e),s=a.next();!s.done;s=a.next()){var u=s.value;t.call(null,u)&&o++}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=a.return)&&n.call(a)}finally{if(r)throw r.error}}return o},t.isEmpty=function(e){return 0===e.size},t.forEach=function(e,t){var r,o,a,s,u,l;return n(this,(function(n){switch(n.label){case 0:return void 0!==t?[3,2]:[5,i(e)];case 1:return n.sent(),[3,9];case 2:n.trys.push([2,7,8,9]),r=i(e),o=r.next(),n.label=3;case 3:return o.done?[3,6]:(a=o.value,t.call(null,a)?[4,a]:[3,5]);case 4:n.sent(),n.label=5;case 5:return o=r.next(),[3,3];case 6:return[3,9];case 7:return s=n.sent(),u={error:s},[3,9];case 8:try{o&&!o.done&&(l=r.return)&&l.call(r)}finally{if(u)throw u.error}return[7];case 9:return[2]}}))},t.clone=function(e){return new Set(e)},t.sortInAscendingOrder=function(e,t){var r=new(Array.bind.apply(Array,a([void 0],e)));return r.sort((function(e,r){return t.call(null,e,r)?-1:1})),new Set(r)},t.sortInDescendingOrder=function(e,t){var r=new(Array.bind.apply(Array,a([void 0],e)));return r.sort((function(e,r){return t.call(null,e,r)?1:-1})),new Set(r)},t.isSubsetOf=u,t.isSupersetOf=function(e,t){return u(t,e)},t.intersection=function(e,t){var r,n,o=new Set;try{for(var a=i(e),s=a.next();!s.done;s=a.next()){var u=s.value;t.has(u)&&o.add(u)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(n=a.return)&&n.call(a)}finally{if(r)throw r.error}}return o},t.union=function(e,t){var r=new Set(e);return t.forEach(r.add,r),r},t.range=function(e,t){for(var r=new Set,n=e;n<=t;n++)r.add(n);return r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.push=function(e,t){e.push(t)},t.pop=function(e){return e.pop()||null}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(96),o=r(147),a=r(146),s=r(1);function u(e,t){for(var r=0;;){var n=r<e.length?e.charCodeAt(r):null,i=r<t.length?t.charCodeAt(r):null;if(null===n)return!0;if(n!==i)return!1;r++}}function l(e){var t,r,i=Array.from(e),o=new Uint8Array(i.length),a=0;try{for(var s=n(e),u=s.next();!u.done;u=s.next()){var l=u.value.codePointAt(0);console.assert(void 0!==l&&l<=255,"isomorphicEncode requires string bytes to be less than or equal to 0x00FF."),void 0!==l&&l<=255&&(o[a++]=l)}}catch(e){t={error:e}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(t)throw t.error}}return o}function c(e){return/^[\u0000-\u007F]*$/.test(e)}function h(e){var t,r,i="";try{for(var o=n(e),a=o.next();!a.done;a=o.next()){var s=a.value,u=s.codePointAt(0);i+=void 0!==u&&u>=65&&u<=90?String.fromCodePoint(u+32):s}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return i}function p(e){return e.replace(/^[\t\n\f\r ]+/,"").replace(/[\t\n\f\r ]+$/,"")}function f(e,t,r){if(!s.isArray(t))return f(e,Array.from(t),r);for(var n="";r.position<t.length&&e.call(null,t[r.position]);)n+=t[r.position],r.position++;return n}function d(e,t){f((function(e){return i.ASCIIWhiteSpace.test(e)}),e,t)}t.isCodeUnitPrefix=u,t.isCodeUnitLessThan=function(e,t){if(u(t,e))return!1;if(u(e,t))return!0;for(var r=0;r<Math.min(e.length,t.length);r++){var n=e.charCodeAt(r),i=t.charCodeAt(r);if(n!==i)return n<i}return!1},t.isomorphicEncode=l,t.isASCIIString=c,t.asciiLowercase=h,t.asciiUppercase=function(e){var t,r,i="";try{for(var o=n(e),a=o.next();!a.done;a=o.next()){var s=a.value,u=s.codePointAt(0);i+=void 0!==u&&u>=97&&u<=122?String.fromCodePoint(u-32):s}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}return i},t.asciiCaseInsensitiveMatch=function(e,t){return h(e)===h(t)},t.asciiEncode=function(e){return console.assert(c(e),"asciiEncode requires an ASCII string."),l(e)},t.asciiDecode=function(e){var t,r;try{for(var i=n(e),s=i.next();!s.done;s=i.next()){var u=s.value;console.assert(a.isASCIIByte(u),"asciiDecode requires an ASCII byte sequence.")}}catch(e){t={error:e}}finally{try{s&&!s.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}return o.isomorphicDecode(e)},t.stripNewlines=function(e){return e.replace(/[\n\r]/g,"")},t.normalizeNewlines=function(e){return e.replace(/\r\n/g,"\n").replace(/\r/g,"\n")},t.stripLeadingAndTrailingASCIIWhitespace=p,t.stripAndCollapseASCIIWhitespace=function(e){return p(e.replace(/[\t\n\f\r ]{2,}/g," "))},t.collectASequenceOfCodePoints=f,t.skipASCIIWhitespace=d,t.strictlySplit=function e(t,r){if(!s.isArray(t))return e(Array.from(t),r);var n={position:0},i=[],o=f((function(e){return r!==e}),t,n);for(i.push(o);n.position<t.length;)console.assert(t[n.position]===r,"strictlySplit found no delimiter in input string."),n.position++,o=f((function(e){return r!==e}),t,n),i.push(o);return i},t.splitAStringOnASCIIWhitespace=function e(t){if(!s.isArray(t))return e(Array.from(t));var r={position:0},n=[];for(d(t,r);r.position<t.length;){var o=f((function(e){return!i.ASCIIWhiteSpace.test(e)}),t,r);n.push(o),d(t,r)}return n},t.splitAStringOnCommas=function e(t){if(!s.isArray(t))return e(Array.from(t));for(var r={position:0},n=[];r.position<t.length;){var i=f((function(e){return","!==e}),t,r);n.push(p(i)),r.position<t.length&&(console.assert(","===t[r.position],"splitAStringOnCommas found no delimiter in input string."),r.position++)}return n},t.concatenate=function(e,t){return void 0===t&&(t=""),0===e.length?"":e.join(t)}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(97);t.abort_add=function(e,t){t._abortedFlag||t._abortAlgorithms.add(e)},t.abort_remove=function(e,t){t._abortAlgorithms.delete(e)},t.abort_signalAbort=function(e){var t,r;if(!e._abortedFlag){e._abortedFlag=!0;try{for(var o=n(e._abortAlgorithms),a=o.next();!a.done;a=o.next()){a.value.call(e)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o.return)&&r.call(o)}finally{if(t)throw t.error}}e._abortAlgorithms.clear(),i.event_fireAnEvent("abort",e)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(150),i=function(){function e(){}return e.asNode=function(e){if(n.Guard.isNode(e))return e;throw new Error("Invalid object. Node expected.")},e}();t.Cast=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){}return Object.defineProperty(e.prototype,"size",{get:function(){return 0},enumerable:!0,configurable:!0}),e.prototype.add=function(e){throw new Error("Cannot add to an empty set.")},e.prototype.clear=function(){},e.prototype.delete=function(e){return!1},e.prototype.forEach=function(e,t){},e.prototype.has=function(e){return!1},e.prototype[Symbol.iterator]=function(){return new i},e.prototype.entries=function(){return new i},e.prototype.keys=function(){return new i},e.prototype.values=function(){return new i},Object.defineProperty(e.prototype,Symbol.toStringTag,{get:function(){return"EmptySet"},enumerable:!0,configurable:!0}),e}();t.EmptySet=n;var i=function(){function e(){}return e.prototype[Symbol.iterator]=function(){return this},e.prototype.next=function(){return{done:!0,value:null}},e}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.SchemeStart=0]="SchemeStart",e[e.Scheme=1]="Scheme",e[e.NoScheme=2]="NoScheme",e[e.SpecialRelativeOrAuthority=3]="SpecialRelativeOrAuthority",e[e.PathOrAuthority=4]="PathOrAuthority",e[e.Relative=5]="Relative",e[e.RelativeSlash=6]="RelativeSlash",e[e.SpecialAuthoritySlashes=7]="SpecialAuthoritySlashes",e[e.SpecialAuthorityIgnoreSlashes=8]="SpecialAuthorityIgnoreSlashes",e[e.Authority=9]="Authority",e[e.Host=10]="Host",e[e.Hostname=11]="Hostname",e[e.Port=12]="Port",e[e.File=13]="File",e[e.FileSlash=14]="FileSlash",e[e.FileHost=15]="FileHost",e[e.PathStart=16]="PathStart",e[e.Path=17]="Path",e[e.CannotBeABaseURLPath=18]="CannotBeABaseURLPath",e[e.Query=19]="Query",e[e.Fragment=20]="Fragment"}(t.ParserState||(t.ParserState={})),t.OpaqueOrigin=["","",null,null]},function(e,t,r){"use strict";var n=r(245),i=r(247);function o(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}t.parse=g,t.resolve=function(e,t){return g(e,!1,!0).resolve(t)},t.resolveObject=function(e,t){return e?g(e,!1,!0).resolveObject(t):t},t.format=function(e){i.isString(e)&&(e=g(e));return e instanceof o?e.format():o.prototype.format.call(e)},t.Url=o;var a=/^([a-z0-9.+-]+:)/i,s=/:[0-9]*$/,u=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,l=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","\t"]),c=["'"].concat(l),h=["%","/","?",";","#"].concat(c),p=["/","?","#"],f=/^[+a-z0-9A-Z_-]{0,63}$/,d=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,m={javascript:!0,"javascript:":!0},y={javascript:!0,"javascript:":!0},v={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},_=r(248);function g(e,t,r){if(e&&i.isObject(e)&&e instanceof o)return e;var n=new o;return n.parse(e,t,r),n}o.prototype.parse=function(e,t,r){if(!i.isString(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var o=e.indexOf("?"),s=-1!==o&&o<e.indexOf("#")?"?":"#",l=e.split(s);l[0]=l[0].replace(/\\/g,"/");var g=e=l.join(s);if(g=g.trim(),!r&&1===e.split("#").length){var b=u.exec(g);if(b)return this.path=g,this.href=g,this.pathname=b[1],b[2]?(this.search=b[2],this.query=t?_.parse(this.search.substr(1)):this.search.substr(1)):t&&(this.search="",this.query={}),this}var x=a.exec(g);if(x){var w=(x=x[0]).toLowerCase();this.protocol=w,g=g.substr(x.length)}if(r||x||g.match(/^\/\/[^@\/]+@[^@\/]+/)){var E="//"===g.substr(0,2);!E||x&&y[x]||(g=g.substr(2),this.slashes=!0)}if(!y[x]&&(E||x&&!v[x])){for(var D,S,C=-1,A=0;A<p.length;A++){-1!==(N=g.indexOf(p[A]))&&(-1===C||N<C)&&(C=N)}-1!==(S=-1===C?g.lastIndexOf("@"):g.lastIndexOf("@",C))&&(D=g.slice(0,S),g=g.slice(S+1),this.auth=decodeURIComponent(D)),C=-1;for(A=0;A<h.length;A++){var N;-1!==(N=g.indexOf(h[A]))&&(-1===C||N<C)&&(C=N)}-1===C&&(C=g.length),this.host=g.slice(0,C),g=g.slice(C),this.parseHost(),this.hostname=this.hostname||"";var T="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!T)for(var O=this.hostname.split(/\./),F=(A=0,O.length);A<F;A++){var k=O[A];if(k&&!k.match(f)){for(var P="",I=0,L=k.length;I<L;I++)k.charCodeAt(I)>127?P+="x":P+=k[I];if(!P.match(f)){var M=O.slice(0,A),B=O.slice(A+1),j=k.match(d);j&&(M.push(j[1]),B.unshift(j[2])),B.length&&(g="/"+B.join(".")+g),this.hostname=M.join(".");break}}}this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),T||(this.hostname=n.toASCII(this.hostname));var R=this.port?":"+this.port:"",z=this.hostname||"";this.host=z+R,this.href+=this.host,T&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==g[0]&&(g="/"+g))}if(!m[w])for(A=0,F=c.length;A<F;A++){var U=c[A];if(-1!==g.indexOf(U)){var G=encodeURIComponent(U);G===U&&(G=escape(U)),g=g.split(U).join(G)}}var X=g.indexOf("#");-1!==X&&(this.hash=g.substr(X),g=g.slice(0,X));var q=g.indexOf("?");if(-1!==q?(this.search=g.substr(q),this.query=g.substr(q+1),t&&(this.query=_.parse(this.query)),g=g.slice(0,q)):t&&(this.search="",this.query={}),g&&(this.pathname=g),v[w]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){R=this.pathname||"";var W=this.search||"";this.path=R+W}return this.href=this.format(),this},o.prototype.format=function(){var e=this.auth||"";e&&(e=(e=encodeURIComponent(e)).replace(/%3A/i,":"),e+="@");var t=this.protocol||"",r=this.pathname||"",n=this.hash||"",o=!1,a="";this.host?o=e+this.host:this.hostname&&(o=e+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(o+=":"+this.port)),this.query&&i.isObject(this.query)&&Object.keys(this.query).length&&(a=_.stringify(this.query));var s=this.search||a&&"?"+a||"";return t&&":"!==t.substr(-1)&&(t+=":"),this.slashes||(!t||v[t])&&!1!==o?(o="//"+(o||""),r&&"/"!==r.charAt(0)&&(r="/"+r)):o||(o=""),n&&"#"!==n.charAt(0)&&(n="#"+n),s&&"?"!==s.charAt(0)&&(s="?"+s),t+o+(r=r.replace(/[?#]/g,(function(e){return encodeURIComponent(e)})))+(s=s.replace("#","%23"))+n},o.prototype.resolve=function(e){return this.resolveObject(g(e,!1,!0)).format()},o.prototype.resolveObject=function(e){if(i.isString(e)){var t=new o;t.parse(e,!1,!0),e=t}for(var r=new o,n=Object.keys(this),a=0;a<n.length;a++){var s=n[a];r[s]=this[s]}if(r.hash=e.hash,""===e.href)return r.href=r.format(),r;if(e.slashes&&!e.protocol){for(var u=Object.keys(e),l=0;l<u.length;l++){var c=u[l];"protocol"!==c&&(r[c]=e[c])}return v[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname="/"),r.href=r.format(),r}if(e.protocol&&e.protocol!==r.protocol){if(!v[e.protocol]){for(var h=Object.keys(e),p=0;p<h.length;p++){var f=h[p];r[f]=e[f]}return r.href=r.format(),r}if(r.protocol=e.protocol,e.host||y[e.protocol])r.pathname=e.pathname;else{for(var d=(e.pathname||"").split("/");d.length&&!(e.host=d.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==d[0]&&d.unshift(""),d.length<2&&d.unshift(""),r.pathname=d.join("/")}if(r.search=e.search,r.query=e.query,r.host=e.host||"",r.auth=e.auth,r.hostname=e.hostname||e.host,r.port=e.port,r.pathname||r.search){var m=r.pathname||"",_=r.search||"";r.path=m+_}return r.slashes=r.slashes||e.slashes,r.href=r.format(),r}var g=r.pathname&&"/"===r.pathname.charAt(0),b=e.host||e.pathname&&"/"===e.pathname.charAt(0),x=b||g||r.host&&e.pathname,w=x,E=r.pathname&&r.pathname.split("/")||[],D=(d=e.pathname&&e.pathname.split("/")||[],r.protocol&&!v[r.protocol]);if(D&&(r.hostname="",r.port=null,r.host&&(""===E[0]?E[0]=r.host:E.unshift(r.host)),r.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===d[0]?d[0]=e.host:d.unshift(e.host)),e.host=null),x=x&&(""===d[0]||""===E[0])),b)r.host=e.host||""===e.host?e.host:r.host,r.hostname=e.hostname||""===e.hostname?e.hostname:r.hostname,r.search=e.search,r.query=e.query,E=d;else if(d.length)E||(E=[]),E.pop(),E=E.concat(d),r.search=e.search,r.query=e.query;else if(!i.isNullOrUndefined(e.search)){if(D)r.hostname=r.host=E.shift(),(T=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=T.shift(),r.host=r.hostname=T.shift());return r.search=e.search,r.query=e.query,i.isNull(r.pathname)&&i.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.href=r.format(),r}if(!E.length)return r.pathname=null,r.search?r.path="/"+r.search:r.path=null,r.href=r.format(),r;for(var S=E.slice(-1)[0],C=(r.host||e.host||E.length>1)&&("."===S||".."===S)||""===S,A=0,N=E.length;N>=0;N--)"."===(S=E[N])?E.splice(N,1):".."===S?(E.splice(N,1),A++):A&&(E.splice(N,1),A--);if(!x&&!w)for(;A--;A)E.unshift("..");!x||""===E[0]||E[0]&&"/"===E[0].charAt(0)||E.unshift(""),C&&"/"!==E.join("/").substr(-1)&&E.push("");var T,O=""===E[0]||E[0]&&"/"===E[0].charAt(0);D&&(r.hostname=r.host=O?"":E.length?E.shift():"",(T=!!(r.host&&r.host.indexOf("@")>0)&&r.host.split("@"))&&(r.auth=T.shift(),r.host=r.hostname=T.shift()));return(x=x||r.host&&E.length)&&!O&&E.unshift(""),E.length?r.pathname=E.join("/"):(r.pathname=null,r.path=null),i.isNull(r.pathname)&&i.isNull(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.auth=e.auth||r.auth,r.slashes=r.slashes||e.slashes,r.href=r.format(),r},o.prototype.parseHost=function(){var e=this.host,t=s.exec(e);t&&(":"!==(t=t[0])&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)}},function(e,t,r){(function(e,n){var i;/*! https://mths.be/punycode v1.4.1 by @mathias */!function(o){t&&t.nodeType,e&&e.nodeType;var a="object"==typeof n&&n;a.global!==a&&a.window!==a&&a.self;var s,u=2147483647,l=/^xn--/,c=/[^\x20-\x7E]/,h=/[\x2E\u3002\uFF0E\uFF61]/g,p={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},f=Math.floor,d=String.fromCharCode;function m(e){throw new RangeError(p[e])}function y(e,t){for(var r=e.length,n=[];r--;)n[r]=t(e[r]);return n}function v(e,t){var r=e.split("@"),n="";return r.length>1&&(n=r[0]+"@",e=r[1]),n+y((e=e.replace(h,".")).split("."),t).join(".")}function _(e){for(var t,r,n=[],i=0,o=e.length;i<o;)(t=e.charCodeAt(i++))>=55296&&t<=56319&&i<o?56320==(64512&(r=e.charCodeAt(i++)))?n.push(((1023&t)<<10)+(1023&r)+65536):(n.push(t),i--):n.push(t);return n}function g(e){return y(e,(function(e){var t="";return e>65535&&(t+=d((e-=65536)>>>10&1023|55296),e=56320|1023&e),t+=d(e)})).join("")}function b(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function x(e,t,r){var n=0;for(e=r?f(e/700):e>>1,e+=f(e/t);e>455;n+=36)e=f(e/35);return f(n+36*e/(e+38))}function w(e){var t,r,n,i,o,a,s,l,c,h,p,d=[],y=e.length,v=0,_=128,b=72;for((r=e.lastIndexOf("-"))<0&&(r=0),n=0;n<r;++n)e.charCodeAt(n)>=128&&m("not-basic"),d.push(e.charCodeAt(n));for(i=r>0?r+1:0;i<y;){for(o=v,a=1,s=36;i>=y&&m("invalid-input"),((l=(p=e.charCodeAt(i++))-48<10?p-22:p-65<26?p-65:p-97<26?p-97:36)>=36||l>f((u-v)/a))&&m("overflow"),v+=l*a,!(l<(c=s<=b?1:s>=b+26?26:s-b));s+=36)a>f(u/(h=36-c))&&m("overflow"),a*=h;b=x(v-o,t=d.length+1,0==o),f(v/t)>u-_&&m("overflow"),_+=f(v/t),v%=t,d.splice(v++,0,_)}return g(d)}function E(e){var t,r,n,i,o,a,s,l,c,h,p,y,v,g,w,E=[];for(y=(e=_(e)).length,t=128,r=0,o=72,a=0;a<y;++a)(p=e[a])<128&&E.push(d(p));for(n=i=E.length,i&&E.push("-");n<y;){for(s=u,a=0;a<y;++a)(p=e[a])>=t&&p<s&&(s=p);for(s-t>f((u-r)/(v=n+1))&&m("overflow"),r+=(s-t)*v,t=s,a=0;a<y;++a)if((p=e[a])<t&&++r>u&&m("overflow"),p==t){for(l=r,c=36;!(l<(h=c<=o?1:c>=o+26?26:c-o));c+=36)w=l-h,g=36-h,E.push(d(b(h+w%g,0))),l=f(w/g);E.push(d(b(l,0))),o=x(r,v,n==i),r=0,++n}++r,++t}return E.join("")}s={version:"1.4.1",ucs2:{decode:_,encode:g},decode:w,encode:E,toASCII:function(e){return v(e,(function(e){return c.test(e)?"xn--"+E(e):e}))},toUnicode:function(e){return v(e,(function(e){return l.test(e)?w(e.slice(4).toLowerCase()):e}))}},void 0===(i=function(){return s}.call(t,r,t,e))||(e.exports=i)}()}).call(this,r(246)(e),r(78))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,r){"use strict";e.exports={isString:function(e){return"string"==typeof e},isObject:function(e){return"object"==typeof e&&null!==e},isNull:function(e){return null===e},isNullOrUndefined:function(e){return null==e}}},function(e,t,r){"use strict";t.decode=t.parse=r(249),t.encode=t.stringify=r(250)},function(e,t,r){"use strict";function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}e.exports=function(e,t,r,o){t=t||"&",r=r||"=";var a={};if("string"!=typeof e||0===e.length)return a;var s=/\+/g;e=e.split(t);var u=1e3;o&&"number"==typeof o.maxKeys&&(u=o.maxKeys);var l=e.length;u>0&&l>u&&(l=u);for(var c=0;c<l;++c){var h,p,f,d,m=e[c].replace(s,"%20"),y=m.indexOf(r);y>=0?(h=m.substr(0,y),p=m.substr(y+1)):(h=m,p=""),f=decodeURIComponent(h),d=decodeURIComponent(p),n(a,f)?i(a[f])?a[f].push(d):a[f]=[a[f],d]:a[f]=d}return a};var i=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,r){"use strict";var n=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}};e.exports=function(e,t,r,s){return t=t||"&",r=r||"=",null===e&&(e=void 0),"object"==typeof e?o(a(e),(function(a){var s=encodeURIComponent(n(a))+r;return i(e[a])?o(e[a],(function(e){return s+encodeURIComponent(n(e))})).join(t):s+encodeURIComponent(n(e[a]))})).join(t):s?encodeURIComponent(n(s))+r+encodeURIComponent(n(e)):""};var i=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)};function o(e,t){if(e.map)return e.map(t);for(var r=[],n=0;n<e.length;n++)r.push(t(e[n],n));return r}var a=Object.keys||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.push(r);return t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(52);t.attr_setAnExistingAttributeValue=function(e,t){null===e._element?e._value=t:n.element_change(e,e._element,t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(108),i=r(30),o=r(52);t.tokenList_validationSteps=function(e,t){if(!i.dom_hasSupportedTokens(e._attribute._localName))throw new TypeError("There are no supported tokens defined for attribute name: '"+e._attribute._localName+"'.");return i.dom_getSupportedTokens(e._attribute._localName).has(t.toLowerCase())},t.tokenList_updateSteps=function(e){(e._element.hasAttribute(e._attribute._localName)||0!==e._tokenSet.size)&&o.element_setAnAttributeValue(e._element,e._attribute._localName,n.orderedSet_serialize(e._tokenSet))},t.tokenList_serializeSteps=function(e){return o.element_getAnAttributeValue(e._element,e._attribute._localName)}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(1);function o(e){return i.isBoolean(e)?e:e.capture||!1}t.eventTarget_flatten=o,t.eventTarget_flattenMore=function(e){var t=o(e),r=!1,n=!1;return i.isBoolean(e)||(r=e.once||!1,n=e.passive||!1),[t,n,r]},t.eventTarget_addEventListener=function(e,t){if(null!==t.callback){for(var r=0;r<e._eventListenerList.length;r++){var n=e._eventListenerList[r];if(n.type===t.type&&n.callback.handleEvent===t.callback.handleEvent&&n.capture===t.capture)return}e._eventListenerList.push(t)}},t.eventTarget_removeEventListener=function(e,t,r){t.removed=!0,e._eventListenerList.splice(r,1)},t.eventTarget_removeAllEventListeners=function(e){var t,r;try{for(var i=n(e._eventListenerList),o=i.next();!o.done;o=i.next()){o.value.removed=!0}}catch(e){t={error:e}}finally{try{o&&!o.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}e._eventListenerList.length=0}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(1),o=r(29);t.parentNode_convertNodesIntoANode=function(e,t){for(var r,a,s=null,u=0;u<e.length;u++){var l=e[u];if(i.isString(l)){var c=o.create_text(t,l);e[u]=c}}if(1===e.length)s=e[0];else{var h=s=o.create_documentFragment(t);try{for(var p=n(e),f=p.next();!f.done;f=p.next()){l=f.value;h.appendChild(l)}}catch(e){r={error:e}}finally{try{f&&!f.done&&(a=p.return)&&a.call(p)}finally{if(r)throw r.error}}}return s}},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(2),s=r(9),u=r(3),l=r(29),c=r(17),h=r(175),p=r(107),f=r(176),d=r(37),m=r(177);function y(e){return e._startNode===e._endNode&&e._startOffset===e._endOffset}function v(e){return c.tree_rootNode(e._startNode)}function _(e,t){return c.tree_rootNode(e)===v(t)&&h.boundaryPoint_position([e,0],t._start)===a.BoundaryPosition.After&&h.boundaryPoint_position([e,c.tree_nodeLength(e)],t._end)===a.BoundaryPosition.Before}function g(e,t){var r=c.tree_isAncestorOf(t._startNode,e,!0),n=c.tree_isAncestorOf(t._endNode,e,!0);return r&&!n||!r&&n}function b(e){var t,r,i,a,h,m,v=l.create_documentFragment(e._startNode._nodeDocument);if(y(e))return v;var x=e._startNode,w=e._startOffset,E=e._endNode,D=e._endOffset;if(x===E&&u.Guard.isCharacterDataNode(x))return(R=f.node_clone(x))._data=p.characterData_substringData(x,w,D-w),d.mutation_append(R,v),p.characterData_replaceData(x,w,D-w,""),v;for(var S=x;!c.tree_isAncestorOf(E,S,!0);){if(null===S._parent)throw new Error("Parent node  is null.");S=S._parent}var C=null;if(!c.tree_isAncestorOf(E,x,!0))try{for(var A=n(S._children),N=A.next();!N.done;N=A.next()){if(g(k=N.value,e)){C=k;break}}}catch(e){t={error:e}}finally{try{N&&!N.done&&(r=A.return)&&r.call(A)}finally{if(t)throw t.error}}var T=null;if(!c.tree_isAncestorOf(x,E,!0))for(var O=o(S._children),F=O.length-1;F>0;F--){var k;if(g(k=O[F],e)){T=k;break}}var P,I,L=[];try{for(var M=n(S._children),B=M.next();!B.done;B=M.next()){if(_(X=B.value,e)){if(u.Guard.isDocumentTypeNode(X))throw new s.HierarchyRequestError;L.push(X)}}}catch(e){i={error:e}}finally{try{B&&!B.done&&(a=M.return)&&a.call(M)}finally{if(i)throw i.error}}if(c.tree_isAncestorOf(E,x,!0))P=x,I=w;else{for(var j=x;null!==j._parent&&!c.tree_isAncestorOf(E,j._parent);)j=j._parent;if(null===j._parent)throw new Error("Parent node is null.");P=j._parent,I=1+c.tree_index(j)}if(u.Guard.isCharacterDataNode(C))(R=f.node_clone(x))._data=p.characterData_substringData(x,w,c.tree_nodeLength(x)-w),d.mutation_append(R,v),p.characterData_replaceData(x,w,c.tree_nodeLength(x)-w,"");else if(null!==C){var R=f.node_clone(C);d.mutation_append(R,v);var z=b(l.create_range([x,w],[C,c.tree_nodeLength(C)]));d.mutation_append(z,R)}try{for(var U=n(L),G=U.next();!G.done;G=U.next()){var X=G.value;d.mutation_append(X,v)}}catch(e){h={error:e}}finally{try{G&&!G.done&&(m=U.return)&&m.call(U)}finally{if(h)throw h.error}}if(u.Guard.isCharacterDataNode(T))(R=f.node_clone(E))._data=p.characterData_substringData(E,0,D),d.mutation_append(R,v),p.characterData_replaceData(E,0,D,"");else if(null!==T){R=f.node_clone(T);d.mutation_append(R,v);z=b(l.create_range([T,0],[E,D]));d.mutation_append(z,R)}return e._start=[P,I],e._end=[P,I],v}t.range_collapsed=y,t.range_root=v,t.range_isContained=_,t.range_isPartiallyContained=g,t.range_setTheStart=function(e,t,r){if(u.Guard.isDocumentTypeNode(t))throw new s.InvalidNodeTypeError;if(r>c.tree_nodeLength(t))throw new s.IndexSizeError;var n=[t,r];v(e)===c.tree_rootNode(t)&&h.boundaryPoint_position(n,e._end)!==a.BoundaryPosition.After||(e._end=n),e._start=n},t.range_setTheEnd=function(e,t,r){if(u.Guard.isDocumentTypeNode(t))throw new s.InvalidNodeTypeError;if(r>c.tree_nodeLength(t))throw new s.IndexSizeError;var n=[t,r];v(e)===c.tree_rootNode(t)&&h.boundaryPoint_position(n,e._start)!==a.BoundaryPosition.Before||(e._start=n),e._end=n},t.range_select=function(e,t){var r=e._parent;if(null===r)throw new s.InvalidNodeTypeError;var n=c.tree_index(e);t._start=[r,n],t._end=[r,n+1]},t.range_extract=b,t.range_cloneTheContents=function e(t){var r,i,a,h,m,v,x=l.create_documentFragment(t._startNode._nodeDocument);if(y(t))return x;var w=t._startNode,E=t._startOffset,D=t._endNode,S=t._endOffset;w===D&&u.Guard.isCharacterDataNode(w)&&((B=f.node_clone(w))._data=p.characterData_substringData(w,E,S-E),d.mutation_append(B,x));for(var C=w;!c.tree_isAncestorOf(D,C,!0);){if(null===C._parent)throw new Error("Parent node  is null.");C=C._parent}var A=null;if(!c.tree_isAncestorOf(D,w,!0))try{for(var N=n(C._children),T=N.next();!T.done;T=N.next()){if(g(P=T.value,t)){A=P;break}}}catch(e){r={error:e}}finally{try{T&&!T.done&&(i=N.return)&&i.call(N)}finally{if(r)throw r.error}}var O=null;if(!c.tree_isAncestorOf(w,D,!0))for(var F=o(C._children),k=F.length-1;k>0;k--){var P;if(g(P=F[k],t)){O=P;break}}var I=[];try{for(var L=n(C._children),M=L.next();!M.done;M=L.next()){if(_(U=M.value,t)){if(u.Guard.isDocumentTypeNode(U))throw new s.HierarchyRequestError;I.push(U)}}}catch(e){a={error:e}}finally{try{M&&!M.done&&(h=L.return)&&h.call(L)}finally{if(a)throw a.error}}if(u.Guard.isCharacterDataNode(A))(B=f.node_clone(w))._data=p.characterData_substringData(w,E,c.tree_nodeLength(w)-E),d.mutation_append(B,x);else if(null!==A){var B=f.node_clone(A);d.mutation_append(B,x);var j=e(l.create_range([w,E],[A,c.tree_nodeLength(A)]));d.mutation_append(j,B)}try{for(var R=n(I),z=R.next();!z.done;z=R.next()){var U=z.value,B=f.node_clone(U);d.mutation_append(B,x)}}catch(e){m={error:e}}finally{try{z&&!z.done&&(v=R.return)&&v.call(R)}finally{if(m)throw m.error}}if(u.Guard.isCharacterDataNode(O))(B=f.node_clone(D))._data=p.characterData_substringData(D,0,S),d.mutation_append(B,x);else if(null!==O){B=f.node_clone(O);x.append(B);j=b(l.create_range([O,0],[D,S]));d.mutation_append(j,B)}return x},t.range_insert=function(e,t){var r,i;if(u.Guard.isProcessingInstructionNode(t._startNode)||u.Guard.isCommentNode(t._startNode)||u.Guard.isTextNode(t._startNode)&&null===t._startNode._parent||t._startNode===e)throw new s.HierarchyRequestError;var o,a=null;if(u.Guard.isTextNode(t._startNode))a=t._startNode;else{var l=0;try{for(var h=n(t._startNode._children),p=h.next();!p.done;p=h.next()){var f=p.value;if(l===t._startOffset){a=f;break}l++}}catch(e){r={error:e}}finally{try{p&&!p.done&&(i=h.return)&&i.call(h)}finally{if(r)throw r.error}}}if(null===a)o=t._startNode;else{if(null===a._parent)throw new Error("Parent node is null.");o=a._parent}d.mutation_ensurePreInsertionValidity(e,o,a),u.Guard.isTextNode(t._startNode)&&(a=m.text_split(t._startNode,t._startOffset)),e===a&&(a=e._nextSibling),null!==e._parent&&d.mutation_remove(e,e._parent);var v=null===a?c.tree_nodeLength(o):c.tree_index(a);u.Guard.isDocumentFragmentNode(e)?v+=c.tree_nodeLength(e):v++,d.mutation_preInsert(e,o,a),y(t)&&(t._end=[o,v])},t.range_getContainedNodes=function(e){var t;return(t={})[Symbol.iterator]=function(){var t=e.commonAncestorContainer,r=c.tree_getFirstDescendantNode(t);return{next:function(){for(;r&&!_(r,e);)r=c.tree_getNextDescendantNode(t,r);if(null===r)return{done:!0,value:null};var n={done:!1,value:r};return r=c.tree_getNextDescendantNode(t,r),n}}},t},t.range_getPartiallyContainedNodes=function(e){var t;return(t={})[Symbol.iterator]=function(){var t=e.commonAncestorContainer,r=c.tree_getFirstDescendantNode(t);return{next:function(){for(;r&&!g(r,e);)r=c.tree_getNextDescendantNode(t,r);if(null===r)return{done:!0,value:null};var n={done:!1,value:r};return r=c.tree_getNextDescendantNode(t,r),n}}},t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(9);t.selectors_scopeMatchASelectorsString=function(e,t){throw new n.NotSupportedError}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=r(105);t.treeWalker_traverseChildren=function(e,t){for(var r=t?e._current._firstChild:e._current._lastChild;null!==r;){var o=i.traversal_filter(e,r);if(o===n.FilterResult.Accept)return e._current=r,r;if(o===n.FilterResult.Skip){var a=t?r._firstChild:r._lastChild;if(null!==a){r=a;continue}}for(;null!==r;){var s=t?r._nextSibling:r._previousSibling;if(null!==s){r=s;break}var u=r._parent;if(null===u||u===e._root||u===e._current)return null;r=u}}return null},t.treeWalker_traverseSiblings=function(e,t){var r=e._current;if(r===e._root)return null;for(;;){for(var o=t?r._nextSibling:r._previousSibling;null!==o;){r=o;var a=i.traversal_filter(e,r);if(a===n.FilterResult.Accept)return e._current=r,r;o=t?r._firstChild:r._lastChild,a!==n.FilterResult.Reject&&null!==o||(o=t?r._nextSibling:r._previousSibling)}if(null===(r=r._parent)||r===e._root)return null;if(i.traversal_filter(e,r)===n.FilterResult.Accept)return null}}},function(e,t,r){"use strict";r(89),r(74);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(1),a=r(2),s=r(50),u=r(3),l=function(e){function t(t,r){var n=e.call(this,t)||this;return n._indentation={},n._lengthToLastNewline=0,n._writerOptions=o.applyDefaults(r,{wellFormed:!1,headless:!1,prettyPrint:!1,indent:"  ",newline:"\n",offset:0,width:0,allowEmptyTags:!1,indentTextOnlyNodes:!1,spaceBeforeSlash:!1}),n}return i(t,e),t.prototype.serialize=function(e){return this._refs={suppressPretty:!1,emptyNode:!1,markup:""},e.nodeType!==a.NodeType.Document||this._writerOptions.headless||this.declaration(this._builderOptions.version,this._builderOptions.encoding,this._builderOptions.standalone),this.serializeNode(e,this._writerOptions.wellFormed),this._writerOptions.prettyPrint&&this._refs.markup.slice(-this._writerOptions.newline.length)===this._writerOptions.newline&&(this._refs.markup=this._refs.markup.slice(0,-this._writerOptions.newline.length)),this._refs.markup},t.prototype.declaration=function(e,t,r){this._beginLine(),this._refs.markup+='<?xml version="'+e+'"',void 0!==t&&(this._refs.markup+=' encoding="'+t+'"'),void 0!==r&&(this._refs.markup+=' standalone="'+(r?"yes":"no")+'"'),this._refs.markup+="?>",this._endLine()},t.prototype.docType=function(e,t,r){this._beginLine(),this._refs.markup+=t&&r?"<!DOCTYPE "+e+' PUBLIC "'+t+'" "'+r+'">':t?"<!DOCTYPE "+e+' PUBLIC "'+t+'">':r?"<!DOCTYPE "+e+' SYSTEM "'+r+'">':"<!DOCTYPE "+e+">",this._endLine()},t.prototype.openTagBegin=function(e){this._beginLine(),this._refs.markup+="<"+e},t.prototype.openTagEnd=function(e,t,r){if(this._refs.suppressPretty=!1,this._refs.emptyNode=!1,this._writerOptions.prettyPrint&&!t&&!r){for(var n=!0,i=!0,o=this.currentNode.firstChild,a=0,s=0;o;){if(u.Guard.isExclusiveTextNode(o))s++;else{if(!u.Guard.isCDATASectionNode(o)){n=!1,i=!1;break}a++}""!==o.data&&(i=!1),o=o.nextSibling}this._refs.suppressPretty=!this._writerOptions.indentTextOnlyNodes&&n&&(a<=1&&0===s||0===a),this._refs.emptyNode=i}(r||t||this._refs.emptyNode)&&this._writerOptions.allowEmptyTags?this._refs.markup+="></"+e+">":this._refs.markup+=r?" />":t||this._refs.emptyNode?this._writerOptions.spaceBeforeSlash?" />":"/>":">",this._endLine()},t.prototype.closeTag=function(e){this._refs.emptyNode||(this._beginLine(),this._refs.markup+="</"+e+">"),this._refs.suppressPretty=!1,this._refs.emptyNode=!1,this._endLine()},t.prototype.attribute=function(e,t){var r=e+'="'+t+'"';this._writerOptions.prettyPrint&&this._writerOptions.width>0&&this._refs.markup.length-this._lengthToLastNewline+1+r.length>this._writerOptions.width?(this._endLine(),this._beginLine(),this._refs.markup+=this._indent(1)+r):this._refs.markup+=" "+r},t.prototype.text=function(e){""!==e&&(this._beginLine(),this._refs.markup+=e,this._endLine())},t.prototype.cdata=function(e){""!==e&&(this._beginLine(),this._refs.markup+="<![CDATA["+e+"]]>",this._endLine())},t.prototype.comment=function(e){this._beginLine(),this._refs.markup+="\x3c!--"+e+"--\x3e",this._endLine()},t.prototype.instruction=function(e,t){this._beginLine(),this._refs.markup+="<?"+(""===t?e:e+" "+t)+"?>",this._endLine()},t.prototype._beginLine=function(){this._writerOptions.prettyPrint&&!this._refs.suppressPretty&&(this._refs.markup+=this._indent(this._writerOptions.offset+this.level))},t.prototype._endLine=function(){this._writerOptions.prettyPrint&&!this._refs.suppressPretty&&(this._refs.markup+=this._writerOptions.newline,this._lengthToLastNewline=this._refs.markup.length)},t.prototype._indent=function(e){if(e<=0)return"";if(void 0!==this._indentation[e])return this._indentation[e];var t=this._writerOptions.indent.repeat(e);return this._indentation[e]=t,t},t}(s.BaseWriter);t.XMLWriter=l},function(e,t,r){"use strict";var n=r(47),i=r(35);e.exports="".repeat||function(e){var t=String(i(this)),r="",o=n(e);if(o<0||o==1/0)throw RangeError("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(t+=t))1&o&&(r+=t);return r}},function(e,t,r){"use strict";r(31),r(32),r(33),r(19),r(178),r(20),r(22),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(67),s=r(1),u=function(e){function t(t,r){var n=e.call(this,t)||this;return n._writerOptions=s.applyDefaults(r,{wellFormed:!1,prettyPrint:!1,indent:"  ",newline:"\n",offset:0,group:!1,verbose:!1}),n}return i(t,e),t.prototype.serialize=function(e){var t=s.applyDefaults(this._writerOptions,{format:"object",wellFormed:!1}),r=new a.ObjectWriter(this._builderOptions,t).serialize(e);return this._beginLine(this._writerOptions,0)+this._convertObject(r,this._writerOptions)},t.prototype._convertObject=function(e,t,r){var n,i,a=this;void 0===r&&(r=0);var u="",l=this._isLeafNode(e);if(s.isArray(e)){u+="[";var c=e.length,h=0;try{for(var p=o(e),f=p.next();!f.done;f=p.next()){var d=f.value;u+=this._endLine(t,r+1)+this._beginLine(t,r+1)+this._convertObject(d,t,r+1),h<c-1&&(u+=","),h++}}catch(e){n={error:e}}finally{try{f&&!f.done&&(i=p.return)&&i.call(p)}finally{if(n)throw n.error}}u+=this._endLine(t,r)+this._beginLine(t,r),u+="]"}else if(s.isObject(e)){u+="{";var m=s.objectLength(e),y=0;s.forEachObject(e,(function(e,n){l&&t.prettyPrint?u+=" ":u+=a._endLine(t,r+1)+a._beginLine(t,r+1),u+=a._key(e),t.prettyPrint&&(u+=" "),u+=a._convertObject(n,t,r+1),y<m-1&&(u+=","),y++}),this),l&&t.prettyPrint?u+=" ":u+=this._endLine(t,r)+this._beginLine(t,r),u+="}"}else u+=this._val(e);return u},t.prototype._beginLine=function(e,t){if(!e.prettyPrint)return"";var r=e.offset+t+1;return r>0?new Array(r).join(e.indent):""},t.prototype._endLine=function(e,t){return e.prettyPrint?e.newline:""},t.prototype._key=function(e){return'"'+e+'":'},t.prototype._val=function(e){return JSON.stringify(e)},t.prototype._isLeafNode=function(e){return this._descendantCount(e)<=1},t.prototype._descendantCount=function(e,t){var r=this;return void 0===t&&(t=0),s.isArray(e)?s.forEachArray(e,(function(e){return t+=r._descendantCount(e,t)}),this):s.isObject(e)?s.forEachObject(e,(function(e,n){return t+=r._descendantCount(n,t)}),this):t++,t},t}(r(50).BaseWriter);t.JSONWriter=u},function(e,t,r){"use strict";r(31),r(32),r(33),r(19),r(178),r(89),r(20),r(22),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var a=r(67),s=r(1),u=function(e){function t(t,r){var n=e.call(this,t)||this;if(n._writerOptions=s.applyDefaults(r,{wellFormed:!1,indent:"  ",newline:"\n",offset:0,group:!1,verbose:!1}),n._writerOptions.indent.length<2)throw new Error("YAML indententation string must be at least two characters long.");if(n._writerOptions.offset<0)throw new Error("YAML offset should be zero or a positive number.");return n}return i(t,e),t.prototype.serialize=function(e){var t=s.applyDefaults(this._writerOptions,{format:"object",wellFormed:!1}),r=new a.ObjectWriter(this._builderOptions,t).serialize(e),n=this._beginLine(this._writerOptions,0)+"---"+this._endLine(this._writerOptions)+this._convertObject(r,this._writerOptions,0);return n.slice(-this._writerOptions.newline.length)===this._writerOptions.newline&&(n=n.slice(0,-this._writerOptions.newline.length)),n},t.prototype._convertObject=function(e,t,r,n){var i,a,u=this;void 0===n&&(n=!1);var l="";if(s.isArray(e))try{for(var c=o(e),h=c.next();!h.done;h=c.next()){var p=h.value;l+=this._beginLine(t,r,!0),s.isObject(p)?s.isEmpty(p)?l+='""'+this._endLine(t):l+=this._convertObject(p,t,r,!0):l+=this._val(p)+this._endLine(t)}}catch(e){i={error:e}}finally{try{h&&!h.done&&(a=c.return)&&a.call(c)}finally{if(i)throw i.error}}else s.forEachObject(e,(function(e,i){n?(l+=u._key(e),n=!1):l+=u._beginLine(t,r)+u._key(e),s.isObject(i)?s.isEmpty(i)?l+=' ""'+u._endLine(t):l+=u._endLine(t)+u._convertObject(i,t,r+1):l+=" "+u._val(i)+u._endLine(t)}),this);return l},t.prototype._beginLine=function(e,t,r){void 0===r&&(r=!1);var n=e.offset+t+1,i=new Array(n).join(e.indent);return r?i.substr(0,i.length-2)+"-"+i.substr(-1,1):i},t.prototype._endLine=function(e){return e.newline},t.prototype._key=function(e){return'"'+e+'":'},t.prototype._val=function(e){return JSON.stringify(e)},t}(r(50).BaseWriter);t.YAMLWriter=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),r(110).dom.setFeatures(!0);var n=r(110);t.DOMImplementation=n.DOMImplementation;var i=r(271);t.DOMParser=i.DOMParser;var o=r(274);t.XMLSerializer=o.XMLSerializer},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),i=r(0),o=function(){function e(){}return e.prototype.before=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=n.Cast.asNode(this),o=r._parent;if(null!==o){for(var a=r._previousSibling,s=!0;s&&a;){s=!1;for(var u=0;u<e.length;u++){var l=e[u];if(l===a){a=a._previousSibling,s=!0;break}}}var c=i.parentNode_convertNodesIntoANode(e,r._nodeDocument);a=null===a?o._firstChild:a._nextSibling,i.mutation_preInsert(c,o,a)}},e.prototype.after=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=n.Cast.asNode(this),o=r._parent;if(o){for(var a=r._nextSibling,s=!0;s&&a;){s=!1;for(var u=0;u<e.length;u++){var l=e[u];if(l===a){a=a._nextSibling,s=!0;break}}}var c=i.parentNode_convertNodesIntoANode(e,r._nodeDocument);i.mutation_preInsert(c,o,a)}},e.prototype.replaceWith=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=n.Cast.asNode(this),o=r._parent;if(o){for(var a=r._nextSibling,s=!0;s&&a;){s=!1;for(var u=0;u<e.length;u++){var l=e[u];if(l===a){a=a._nextSibling,s=!0;break}}}var c=i.parentNode_convertNodesIntoANode(e,r._nodeDocument);r._parent===o?i.mutation_replace(r,c,o):i.mutation_preInsert(c,o,a)}},e.prototype.remove=function(){var e=n.Cast.asNode(this),t=e._parent;t&&i.mutation_remove(e,t)},e}();t.ChildNodeImpl=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){};t.DocumentOrShadowRootImpl=n},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(6),o=r(3),a=r(7),s=function(){function e(e){this._nodeList=[],this._recordQueue=[],this._callback=e;var t=i.dom.window;a.set.append(t._mutationObservers,this)}return e.prototype.observe=function(e,t){var r,i;if(void 0===(t=t||{childList:!1,subtree:!1}).attributeOldValue&&void 0===t.attributeFilter||void 0!==t.attributes||(t.attributes=!0),void 0!==t.characterDataOldValue&&void 0===t.characterData&&(t.characterData=!0),!t.childList&&!t.attributes&&!t.characterData)throw new TypeError;if(t.attributeOldValue&&!t.attributes)throw new TypeError;if(void 0!==t.attributeFilter&&!t.attributes)throw new TypeError;if(t.characterDataOldValue&&!t.characterData)throw new TypeError;var s=!1,u=t,l=function(e){var t,r;if(e.observer===c){s=!0;try{for(var i=(t=void 0,n(c._nodeList)),l=i.next();!l.done;l=i.next()){var h=l.value;a.list.remove(h._registeredObserverList,(function(t){return o.Guard.isTransientRegisteredObserver(t)&&t.source===e}))}}catch(e){t={error:e}}finally{try{l&&!l.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}e.options=u}},c=this;try{for(var h=n(e._registeredObserverList),p=h.next();!p.done;p=h.next()){l(p.value)}}catch(e){r={error:e}}finally{try{p&&!p.done&&(i=h.return)&&i.call(h)}finally{if(r)throw r.error}}s||(e._registeredObserverList.push({observer:this,options:t}),this._nodeList.push(e))},e.prototype.disconnect=function(){var e,t,r=this;try{for(var i=n(this._nodeList),o=i.next();!o.done;o=i.next()){var s=o.value;a.list.remove(s._registeredObserverList,(function(e){return e.observer===r}))}}catch(t){e={error:t}}finally{try{o&&!o.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}this._recordQueue=[]},e.prototype.takeRecords=function(){var e=this._recordQueue;return this._recordQueue=[],e},e}();t.MutationObserverImpl=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),i=function(){function e(){}return Object.defineProperty(e.prototype,"previousElementSibling",{get:function(){for(var e=n.Cast.asNode(this)._previousSibling;e;){if(n.Guard.isElementNode(e))return e;e=e._previousSibling}return null},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"nextElementSibling",{get:function(){for(var e=n.Cast.asNode(this)._nextSibling;e;){if(n.Guard.isElementNode(e))return e;e=e._nextSibling}return null},enumerable:!0,configurable:!0}),e}();t.NonDocumentTypeChildNodeImpl=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),i=r(0),o=function(){function e(){}return e.prototype.getElementById=function(e){for(var t=i.tree_getFirstDescendantNode(n.Cast.asNode(this),!1,!1,(function(e){return n.Guard.isElementNode(e)}));null!==t;){if(t._uniqueIdentifier===e)return t;t=i.tree_getNextDescendantNode(n.Cast.asNode(this),t,!1,!1,(function(e){return n.Guard.isElementNode(e)}))}return null},e}();t.NonElementParentNodeImpl=o},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(3),o=r(0),a=function(){function e(){}return Object.defineProperty(e.prototype,"children",{get:function(){return o.create_htmlCollection(i.Cast.asNode(this))},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"firstElementChild",{get:function(){for(var e=i.Cast.asNode(this)._firstChild;e;){if(i.Guard.isElementNode(e))return e;e=e._nextSibling}return null},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"lastElementChild",{get:function(){for(var e=i.Cast.asNode(this)._lastChild;e;){if(i.Guard.isElementNode(e))return e;e=e._previousSibling}return null},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"childElementCount",{get:function(){var e,t,r=0;try{for(var o=n(i.Cast.asNode(this)._children),a=o.next();!a.done;a=o.next()){var s=a.value;i.Guard.isElementNode(s)&&r++}}catch(t){e={error:t}}finally{try{a&&!a.done&&(t=o.return)&&t.call(o)}finally{if(e)throw e.error}}return r},enumerable:!0,configurable:!0}),e.prototype.prepend=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=i.Cast.asNode(this),n=o.parentNode_convertNodesIntoANode(e,r._nodeDocument);o.mutation_preInsert(n,r,r._firstChild)},e.prototype.append=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=i.Cast.asNode(this),n=o.parentNode_convertNodesIntoANode(e,r._nodeDocument);o.mutation_append(n,r)},e.prototype.querySelector=function(e){var t=i.Cast.asNode(this),r=o.selectors_scopeMatchASelectorsString(e,t);return 0===r.length?null:r[0]},e.prototype.querySelectorAll=function(e){var t=i.Cast.asNode(this),r=o.selectors_scopeMatchASelectorsString(e,t);return o.create_nodeListStatic(t,r)},e}();t.ParentNodeImpl=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function e(){}return Object.defineProperty(e.prototype,"_name",{get:function(){return this.__name||""},set:function(e){this.__name=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"_assignedSlot",{get:function(){return this.__assignedSlot||null},set:function(e){this.__assignedSlot=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"assignedSlot",{get:function(){return n.shadowTree_findASlot(this,!0)},enumerable:!0,configurable:!0}),e}();t.SlotableImpl=i},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(102),a=r(9),s=r(3),u=function(e){function t(t){var r=e.call(this)||this;if(s.Guard.isDocumentTypeNode(t.startContainer)||s.Guard.isAttrNode(t.startContainer)||s.Guard.isDocumentTypeNode(t.endContainer)||s.Guard.isAttrNode(t.endContainer))throw new a.InvalidNodeTypeError;return r._start=[t.startContainer,t.startOffset],r._end=[t.endContainer,t.endOffset],r}return i(t,e),t}(o.AbstractRangeImpl);t.StaticRangeImpl=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(272);t.DOMParser=n.DOMParserImpl},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=r(273),o=function(){function e(){}return e.prototype.parseFromString=function(e,t){if("text/html"===t)throw new Error("HTML parser not implemented.");try{return(r=(new i.XMLParserImpl).parse(e))._contentType=t,r}catch(e){var r,o="http://www.mozilla.org/newlayout/xml/parsererror.xml",a=(r=n.create_xmlDocument()).createElementNS(o,"parsererror"),s=r.createElementNS(o,"error");return s.setAttribute("message",e.message),a.appendChild(s),r.appendChild(a),r}},e}();t.DOMParserImpl=o},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var o=r(180),a=r(111),s=r(7),u=r(0),l=r(69),c=function(){function e(){}return e.prototype.parse=function(e){for(var t,r,c,h,p=new o.XMLStringLexer(e,{skipWhitespaceOnlyText:!0}),f=u.create_document(),d=f,m=p.nextToken();m.type!==a.TokenType.EOF;){switch(m.type){case a.TokenType.Declaration:var y=m;if("1.0"!==y.version)throw new Error("Invalid xml version: "+y.version);break;case a.TokenType.DocType:var v=m;if(!u.xml_isPubidChar(v.pubId))throw new Error("DocType public identifier does not match PubidChar construct.");if(!u.xml_isLegalChar(v.sysId)||-1!==v.sysId.indexOf('"')&&-1!==v.sysId.indexOf("'"))throw new Error("DocType system identifier contains invalid characters.");d.appendChild(f.implementation.createDocumentType(v.name,v.pubId,v.sysId));break;case a.TokenType.CDATA:var _=m;if(!u.xml_isLegalChar(_.data)||-1!==_.data.indexOf("]]>"))throw new Error("CDATA contains invalid characters.");d.appendChild(f.createCDATASection(_.data));break;case a.TokenType.Comment:var g=m;if(!u.xml_isLegalChar(g.data)||-1!==g.data.indexOf("--")||g.data.endsWith("-"))throw new Error("Comment data contains invalid characters.");d.appendChild(f.createComment(g.data));break;case a.TokenType.PI:var b=m;if(-1!==b.target.indexOf(":")||/^xml$/i.test(b.target))throw new Error("Processing instruction target contains invalid characters.");if(!u.xml_isLegalChar(b.data)||-1!==b.data.indexOf("?>"))throw new Error("Processing instruction data contains invalid characters.");d.appendChild(f.createProcessingInstruction(b.target,b.data));break;case a.TokenType.Text:var x=m;if(!u.xml_isLegalChar(x.data))throw new Error("Text data contains invalid characters.");d.appendChild(f.createTextNode(this._decodeText(x.data)));break;case a.TokenType.Element:var w=m,E=n(u.namespace_extractQName(w.name),2),D=E[0],S=E[1];if(-1!==S.indexOf(":")||!u.xml_isName(S))throw new Error("Node local name contains invalid characters.");if("xmlns"===D)throw new Error("An element cannot have the 'xmlns' prefix.");var C=d.lookupNamespaceURI(D),A={};try{for(var N=(t=void 0,i(w.attributes)),T=N.next();!T.done;T=N.next()){var O=n(T.value,2),F=O[0],k=O[1];if("xmlns"===F)C=k;else{var P=n(u.namespace_extractQName(F),2),I=P[0],L=P[1];"xmlns"===I&&(L===D&&(C=k),A[L]=k)}}}catch(e){t={error:e}}finally{try{T&&!T.done&&(r=N.return)&&r.call(N)}finally{if(t)throw t.error}}var M=null!==C?f.createElementNS(C,w.name):f.createElement(w.name);d.appendChild(M);var B=new l.LocalNameSet;try{for(var j=(c=void 0,i(w.attributes)),R=j.next();!R.done;R=j.next()){var z=n(R.value,2),U=(F=z[0],k=z[1],n(u.namespace_extractQName(F),2)),G=(I=U[0],L=U[1],null);if("xmlns"===I||null===I&&"xmlns"===L?G=s.namespace.XMLNS:null!==(G=M.lookupNamespaceURI(I))&&M.isDefaultNamespace(G)?G=null:null===G&&null!==I&&(G=A[I]||null),B.has(G,L))throw new Error("Element contains duplicate attributes.");if(B.set(G,L),G===s.namespace.XMLNS&&k===s.namespace.XMLNS)throw new Error("XMLNS namespace is reserved.");if(-1!==L.indexOf(":")||!u.xml_isName(L))throw new Error("Attribute local name contains invalid characters.");if("xmlns"===I&&""===k)throw new Error("Empty XML namespace is not allowed.");null!==G?M.setAttributeNS(G,F,this._decodeAttributeValue(k)):M.setAttribute(F,this._decodeAttributeValue(k))}}catch(e){c={error:e}}finally{try{R&&!R.done&&(h=j.return)&&h.call(j)}finally{if(c)throw c.error}}w.selfClosing||(d=M);break;case a.TokenType.ClosingTag:if(m.name!==d.nodeName)throw new Error("Closing tag name does not match opening tag name.");d._parent&&(d=d._parent)}m=p.nextToken()}return f},e.prototype._decodeText=function(e){return null==e?e:e.replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&")},e.prototype._decodeAttributeValue=function(e){return null==e?e:e.replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&")},e}();t.XMLParserImpl=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(275);t.XMLSerializer=n.XMLSerializerImpl},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(2),o=r(69),a=r(95),s=r(9),u=r(7),l=r(0),c=function(){function e(){}return e.prototype.serializeToString=function(e){return this._xmlSerialization(e,!1)},e.prototype._xmlSerialization=function(e,t){if(void 0===e._nodeDocument||e._nodeDocument._hasNamespaces){var r=new a.NamespacePrefixMap;r.set("xml",u.namespace.XML);try{return this._serializeNodeNS(e,null,r,{value:1},t)}catch(e){throw new s.InvalidStateError}}else try{return this._serializeNode(e,t)}catch(e){throw new s.InvalidStateError}},e.prototype._serializeNodeNS=function(e,t,r,n,o){switch(e.nodeType){case i.NodeType.Element:return this._serializeElementNS(e,t,r,n,o);case i.NodeType.Document:return this._serializeDocumentNS(e,t,r,n,o);case i.NodeType.Comment:return this._serializeComment(e,o);case i.NodeType.Text:return this._serializeText(e,o);case i.NodeType.DocumentFragment:return this._serializeDocumentFragmentNS(e,t,r,n,o);case i.NodeType.DocumentType:return this._serializeDocumentType(e,o);case i.NodeType.ProcessingInstruction:return this._serializeProcessingInstruction(e,o);case i.NodeType.CData:return this._serializeCData(e,o);default:throw new Error("Unknown node type: "+e.nodeType)}},e.prototype._serializeNode=function(e,t){switch(e.nodeType){case i.NodeType.Element:return this._serializeElement(e,t);case i.NodeType.Document:return this._serializeDocument(e,t);case i.NodeType.Comment:return this._serializeComment(e,t);case i.NodeType.Text:return this._serializeText(e,t);case i.NodeType.DocumentFragment:return this._serializeDocumentFragment(e,t);case i.NodeType.DocumentType:return this._serializeDocumentType(e,t);case i.NodeType.ProcessingInstruction:return this._serializeProcessingInstruction(e,t);case i.NodeType.CData:return this._serializeCData(e,t);default:throw new Error("Unknown node type: "+e.nodeType)}},e.prototype._serializeElementNS=function(t,r,i,o,a){var s,c;if(a&&(-1!==t.localName.indexOf(":")||!l.xml_isName(t.localName)))throw new Error("Node local name contains invalid characters (well-formed required).");var h="<",p="",f=!1,d=!1,m=i.copy(),y={},v=this._recordNamespaceInformation(t,m,y),_=r,g=t.namespaceURI;if(_===g)null!==v&&(d=!0),h+=p=g===u.namespace.XML?"xml:"+t.localName:t.localName;else{var b=t.prefix,x=null;if(null===b&&g===v||(x=m.get(b,g)),"xmlns"===b){if(a)throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");x=b}null!==x?(p=x+":"+t.localName,null!==v&&v!==u.namespace.XML&&(_=v||null),h+=p):null!==b?(b in y&&(b=this._generatePrefix(g,m,o)),m.set(b,g),h+=p+=b+":"+t.localName,h+=" xmlns:"+b+'="'+this._serializeAttributeValue(g,a)+'"',null!==v&&(_=v||null)):null===v||null!==v&&v!==g?(d=!0,_=g,h+=p+=t.localName,h+=' xmlns="'+this._serializeAttributeValue(g,a)+'"'):(_=g,h+=p+=t.localName)}h+=this._serializeAttributesNS(t,m,o,y,d,a);var w=g===u.namespace.HTML;if(w&&0===t.childNodes.length&&e._VoidElementNames.has(t.localName)?(h+=" /",f=!0):w||0!==t.childNodes.length||(h+="/",f=!0),h+=">",f)return h;if(w&&"template"===t.localName);else try{for(var E=n(t._children||t.childNodes),D=E.next();!D.done;D=E.next()){var S=D.value;h+=this._serializeNodeNS(S,_,m,o,a)}}catch(e){s={error:e}}finally{try{D&&!D.done&&(c=E.return)&&c.call(E)}finally{if(s)throw s.error}}return h+="</"+p+">"},e.prototype._serializeDocumentNS=function(e,t,r,i,o){var a,s;if(o&&null===e.documentElement)throw new Error("Missing document element (well-formed required).");var u="";try{for(var l=n(e._children||e.childNodes),c=l.next();!c.done;c=l.next()){var h=c.value;u+=this._serializeNodeNS(h,t,r,i,o)}}catch(e){a={error:e}}finally{try{c&&!c.done&&(s=l.return)&&s.call(l)}finally{if(a)throw a.error}}return u},e.prototype._serializeComment=function(e,t){if(t&&(!l.xml_isLegalChar(e.data)||-1!==e.data.indexOf("--")||e.data.endsWith("-")))throw new Error("Comment data contains invalid characters (well-formed required).");return"\x3c!--"+e.data+"--\x3e"},e.prototype._serializeText=function(e,t){if(t&&!l.xml_isLegalChar(e.data))throw new Error("Text data contains invalid characters (well-formed required).");for(var r="",n=0;n<e.data.length;n++){var i=e.data[n];r+="&"===i?"&amp;":"<"===i?"&lt;":">"===i?"&gt;":i}return r},e.prototype._serializeDocumentFragmentNS=function(e,t,r,i,o){var a,s,u="";try{for(var l=n(e._children||e.childNodes),c=l.next();!c.done;c=l.next()){var h=c.value;u+=this._serializeNodeNS(h,t,r,i,o)}}catch(e){a={error:e}}finally{try{c&&!c.done&&(s=l.return)&&s.call(l)}finally{if(a)throw a.error}}return u},e.prototype._serializeDocumentType=function(e,t){if(t&&!l.xml_isPubidChar(e.publicId))throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");if(t&&(!l.xml_isLegalChar(e.systemId)||-1!==e.systemId.indexOf('"')&&-1!==e.systemId.indexOf("'")))throw new Error("DocType system identifier contains invalid characters (well-formed required).");return e.publicId&&e.systemId?"<!DOCTYPE "+e.name+' PUBLIC "'+e.publicId+'" "'+e.systemId+'">':e.publicId?"<!DOCTYPE "+e.name+' PUBLIC "'+e.publicId+'">':e.systemId?"<!DOCTYPE "+e.name+' SYSTEM "'+e.systemId+'">':"<!DOCTYPE "+e.name+">"},e.prototype._serializeProcessingInstruction=function(e,t){if(t&&(-1!==e.target.indexOf(":")||/^xml$/i.test(e.target)))throw new Error("Processing instruction target contains invalid characters (well-formed required).");if(t&&(!l.xml_isLegalChar(e.data)||-1!==e.data.indexOf("?>")))throw new Error("Processing instruction data contains invalid characters (well-formed required).");return"<?"+(""===e.data?e.target:e.target+" "+e.data)+"?>"},e.prototype._serializeCData=function(e,t){if(t&&-1!==e.data.indexOf("]]>"))throw new Error("CDATA contains invalid characters (well-formed required).");return"<![CDATA["+e.data+"]]>"},e.prototype._serializeAttributesNS=function(e,t,r,i,a,s){var c,h,p="",f=s?new o.LocalNameSet:void 0;try{for(var d=n(e.attributes),m=d.next();!m.done;m=d.next()){var y=m.value;if(a||s||null!==y.namespaceURI){if(s&&f&&f.has(y.namespaceURI,y.localName))throw new Error("Element contains duplicate attributes (well-formed required).");s&&f&&f.set(y.namespaceURI,y.localName);var v=y.namespaceURI,_=null;if(null!==v)if(_=t.get(y.prefix,v),v===u.namespace.XMLNS){if(y.value===u.namespace.XML||null===y.prefix&&a||null!==y.prefix&&(!(y.localName in i)||i[y.localName]!==y.value)&&t.has(y.localName,y.value))continue;if(s&&y.value===u.namespace.XMLNS)throw new Error("XMLNS namespace is reserved (well-formed required).");if(s&&""===y.value)throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");"xmlns"===y.prefix&&(_="xmlns")}else null===_&&(p+=" xmlns:"+(_=null===y.prefix||t.hasPrefix(y.prefix)&&!t.has(y.prefix,v)?this._generatePrefix(v,t,r):y.prefix)+'="'+this._serializeAttributeValue(v,s)+'"');if(p+=" ",null!==_&&(p+=_+":"),s&&(-1!==y.localName.indexOf(":")||!l.xml_isName(y.localName)||"xmlns"===y.localName&&null===v))throw new Error("Attribute local name contains invalid characters (well-formed required).");p+=y.localName+'="'+this._serializeAttributeValue(y.value,s)+'"'}else p+=" "+y.localName+'="'+this._serializeAttributeValue(y.value,s)+'"'}}catch(e){c={error:e}}finally{try{m&&!m.done&&(h=d.return)&&h.call(d)}finally{if(c)throw c.error}}return p},e.prototype._recordNamespaceInformation=function(e,t,r){var i,o,a=null;try{for(var s=n(e.attributes),l=s.next();!l.done;l=s.next()){var c=l.value,h=c.namespaceURI,p=c.prefix;if(h===u.namespace.XMLNS){if(null===p){a=c.value;continue}var f=c.localName,d=c.value;if(d===u.namespace.XML)continue;if(""===d&&(d=null),t.has(f,d))continue;t.set(f,d),r[f]=d||""}}}catch(e){i={error:e}}finally{try{l&&!l.done&&(o=s.return)&&o.call(s)}finally{if(i)throw i.error}}return a},e.prototype._generatePrefix=function(e,t,r){var n="ns"+r.value;return r.value++,t.set(n,e),n},e.prototype._serializeAttributeValue=function(e,t){if(t&&null!==e&&!l.xml_isLegalChar(e))throw new Error("Invalid characters in attribute value.");if(null===e)return"";for(var r="",n=0;n<e.length;n++){var i=e[n];r+='"'===i?"&quot;":"&"===i?"&amp;":"<"===i?"&lt;":">"===i?"&gt;":i}return r},e.prototype._serializeElement=function(e,t){var r,i;if(t&&(-1!==e.localName.indexOf(":")||!l.xml_isName(e.localName)))throw new Error("Node local name contains invalid characters (well-formed required).");var o=!1,a=e.localName,s="<"+a;if(s+=this._serializeAttributes(e,t),0===e._children.size&&(s+="/",o=!0),s+=">",o)return s;try{for(var u=n(e._children),c=u.next();!c.done;c=u.next()){var h=c.value;s+=this._serializeNode(h,t)}}catch(e){r={error:e}}finally{try{c&&!c.done&&(i=u.return)&&i.call(u)}finally{if(r)throw r.error}}return s+="</"+a+">"},e.prototype._serializeDocument=function(e,t){var r,i;if(t&&null===e.documentElement)throw new Error("Missing document element (well-formed required).");var o="";try{for(var a=n(e._children),s=a.next();!s.done;s=a.next()){var u=s.value;o+=this._serializeNode(u,t)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(i=a.return)&&i.call(a)}finally{if(r)throw r.error}}return o},e.prototype._serializeDocumentFragment=function(e,t){var r,i,o="";try{for(var a=n(e._children),s=a.next();!s.done;s=a.next()){var u=s.value;o+=this._serializeNode(u,t)}}catch(e){r={error:e}}finally{try{s&&!s.done&&(i=a.return)&&i.call(a)}finally{if(r)throw r.error}}return o},e.prototype._serializeAttributes=function(e,t){var r,i,o="",a=t?{}:void 0;try{for(var s=n(e.attributes),u=s.next();!u.done;u=s.next()){var c=u.value;if(t&&a&&c.localName in a)throw new Error("Element contains duplicate attributes (well-formed required).");if(t&&a&&(a[c.localName]=!0),t&&(-1!==c.localName.indexOf(":")||!l.xml_isName(c.localName)))throw new Error("Attribute local name contains invalid characters (well-formed required).");o+=" "+c.localName+'="'+this._serializeAttributeValue(c.value,t)+'"'}}catch(e){r={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(r)throw r.error}}return o},e._VoidElementNames=new Set(["area","base","basefont","bgsound","br","col","embed","frame","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"]),e}();t.XMLSerializerImpl=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(277);t.XMLReader=n.XMLReader;var i=r(112);t.ObjectReader=i.ObjectReader;var o=r(280);t.JSONReader=o.JSONReader;var a=r(281);t.YAMLReader=a.YAMLReader},function(e,t,r){"use strict";r(31),r(32),r(33),r(19),r(65),r(20),r(22),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a},a=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var s=r(180),u=r(111),l=r(7),c=r(0),h=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return i(t,e),t.prototype._parse=function(e,t){for(var r,n,i,h,p=new s.XMLStringLexer(t,{skipWhitespaceOnlyText:!0}),f=e,d=e,m=p.nextToken();m.type!==u.TokenType.EOF;){switch(m.type){case u.TokenType.Declaration:var y=m,v=this.sanitize(y.version);if("1.0"!==v)throw new Error("Invalid xml version: "+v);var _={version:v};y.encoding&&(_.encoding=this.sanitize(y.encoding)),y.standalone&&(_.standalone="yes"===this.sanitize(y.standalone)),d.set(_);break;case u.TokenType.DocType:var g=m;d=this.docType(d,this.sanitize(g.name),this.sanitize(g.pubId),this.sanitize(g.sysId))||d;break;case u.TokenType.CDATA:var b=m;d=this.cdata(d,this.sanitize(b.data))||d;break;case u.TokenType.Comment:var x=m;d=this.comment(d,this.sanitize(x.data))||d;break;case u.TokenType.PI:var w=m;d=this.instruction(d,this.sanitize(w.target),this.sanitize(w.data))||d;break;case u.TokenType.Text:var E=m;d=this.text(d,this._decodeText(this.sanitize(E.data)))||d;break;case u.TokenType.Element:var D=m,S=this.sanitize(D.name),C=o(c.namespace_extractQName(S),1)[0],A=d.node.lookupNamespaceURI(C),N={};try{for(var T=(r=void 0,a(D.attributes)),O=T.next();!O.done;O=T.next()){var F=o(O.value,2),k=F[0],P=F[1];if(k=this.sanitize(k),P=this.sanitize(P),"xmlns"===k)A=P;else{var I=o(c.namespace_extractQName(k),2),L=I[0],M=I[1];"xmlns"===L&&(M===C&&(A=P),N[M]=P)}}}catch(e){r={error:e}}finally{try{O&&!O.done&&(n=T.return)&&n.call(T)}finally{if(r)throw r.error}}var B=null!==A?this.element(d,A,S):this.element(d,void 0,S);if(void 0===B)break;d.node===e.node&&(f=B);try{for(var j=(i=void 0,a(D.attributes)),R=j.next();!R.done;R=j.next()){var z=o(R.value,2);k=z[0],P=z[1];k=this.sanitize(k),P=this.sanitize(P);var U=o(c.namespace_extractQName(k),2),G=(L=U[0],M=U[1],null);"xmlns"===L||null===L&&"xmlns"===M?G=l.namespace.XMLNS:null!==(G=B.node.lookupNamespaceURI(L))&&B.node.isDefaultNamespace(G)?G=null:null===G&&null!==L&&(G=N[L]||null),null!==G?this.attribute(B,G,k,this._decodeAttributeValue(P)):this.attribute(B,void 0,k,this._decodeAttributeValue(P))}}catch(e){i={error:e}}finally{try{R&&!R.done&&(h=j.return)&&h.call(j)}finally{if(i)throw i.error}}D.selfClosing||(d=B);break;case u.TokenType.ClosingTag:d.node.parentNode&&(d=d.up())}m=p.nextToken()}return f},t}(r(75).BaseReader);t.XMLReader=h},function(e,t,r){var n=r(4),i=r(279);n({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(e,t,r){"use strict";var n=r(16),i=r(8),o=r(61),a=r(85),s=r(79),u=r(27),l=r(41),c=Object.assign,h=Object.defineProperty;e.exports=!c||i((function(){if(n&&1!==c({b:1},c(h({},"a",{enumerable:!0,get:function(){h(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},t={},r=Symbol();return e[r]=7,"abcdefghijklmnopqrst".split("").forEach((function(e){t[e]=e})),7!=c({},e)[r]||"abcdefghijklmnopqrst"!=o(c({},t)).join("")}))?function(e,t){for(var r=u(e),i=arguments.length,c=1,h=a.f,p=s.f;i>c;)for(var f,d=l(arguments[c++]),m=h?o(d).concat(h(d)):o(d),y=m.length,v=0;y>v;)f=m[v++],n&&!p.call(d,f)||(r[f]=d[f]);return r}:c},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(112),a=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return i(t,e),t.prototype._parse=function(e,t){return new o.ObjectReader(this._builderOptions).parse(e,JSON.parse(t))},t}(r(75).BaseReader);t.JSONReader=a},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(112),a=r(75),s=r(282),u=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return i(t,e),t.prototype._parse=function(e,t){var r=s.safeLoad(t);if(void 0===r)throw new Error("Unable to parse YAML document.");return new o.ObjectReader(this._builderOptions).parse(e,r)},t}(a.BaseReader);t.YAMLReader=u},function(e,t,r){"use strict";var n=r(283);e.exports=n},function(e,t,r){"use strict";var n=r(284),i=r(303);function o(e){return function(){throw new Error("Function "+e+" is deprecated and cannot be used.")}}e.exports.Type=r(10),e.exports.Schema=r(39),e.exports.FAILSAFE_SCHEMA=r(113),e.exports.JSON_SCHEMA=r(182),e.exports.CORE_SCHEMA=r(181),e.exports.DEFAULT_SAFE_SCHEMA=r(54),e.exports.DEFAULT_FULL_SCHEMA=r(76),e.exports.load=n.load,e.exports.loadAll=n.loadAll,e.exports.safeLoad=n.safeLoad,e.exports.safeLoadAll=n.safeLoadAll,e.exports.dump=i.dump,e.exports.safeDump=i.safeDump,e.exports.YAMLException=r(53),e.exports.MINIMAL_SCHEMA=r(113),e.exports.SAFE_SCHEMA=r(54),e.exports.DEFAULT_SCHEMA=r(76),e.exports.scan=o("scan"),e.exports.parse=o("parse"),e.exports.compose=o("compose"),e.exports.addConstructor=o("addConstructor")},function(e,t,r){"use strict";var n=r(38),i=r(53),o=r(285),a=r(54),s=r(76),u=Object.prototype.hasOwnProperty,l=/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,c=/[\x85\u2028\u2029]/,h=/[,\[\]\{\}]/,p=/^(?:!|!!|![a-z\-]+!)$/i,f=/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;function d(e){return Object.prototype.toString.call(e)}function m(e){return 10===e||13===e}function y(e){return 9===e||32===e}function v(e){return 9===e||32===e||10===e||13===e}function _(e){return 44===e||91===e||93===e||123===e||125===e}function g(e){var t;return 48<=e&&e<=57?e-48:97<=(t=32|e)&&t<=102?t-97+10:-1}function b(e){return 48===e?"\0":97===e?"":98===e?"\b":116===e||9===e?"\t":110===e?"\n":118===e?"\v":102===e?"\f":114===e?"\r":101===e?"":32===e?" ":34===e?'"':47===e?"/":92===e?"\\":78===e?"":95===e?" ":76===e?"\u2028":80===e?"\u2029":""}function x(e){return e<=65535?String.fromCharCode(e):String.fromCharCode(55296+(e-65536>>10),56320+(e-65536&1023))}for(var w=new Array(256),E=new Array(256),D=0;D<256;D++)w[D]=b(D)?1:0,E[D]=b(D);function S(e,t){this.input=e,this.filename=t.filename||null,this.schema=t.schema||s,this.onWarning=t.onWarning||null,this.legacy=t.legacy||!1,this.json=t.json||!1,this.listener=t.listener||null,this.implicitTypes=this.schema.compiledImplicit,this.typeMap=this.schema.compiledTypeMap,this.length=e.length,this.position=0,this.line=0,this.lineStart=0,this.lineIndent=0,this.documents=[]}function C(e,t){return new i(t,new o(e.filename,e.input,e.position,e.line,e.position-e.lineStart))}function A(e,t){throw C(e,t)}function N(e,t){e.onWarning&&e.onWarning.call(null,C(e,t))}var T={YAML:function(e,t,r){var n,i,o;null!==e.version&&A(e,"duplication of %YAML directive"),1!==r.length&&A(e,"YAML directive accepts exactly one argument"),null===(n=/^([0-9]+)\.([0-9]+)$/.exec(r[0]))&&A(e,"ill-formed argument of the YAML directive"),i=parseInt(n[1],10),o=parseInt(n[2],10),1!==i&&A(e,"unacceptable YAML version of the document"),e.version=r[0],e.checkLineBreaks=o<2,1!==o&&2!==o&&N(e,"unsupported YAML version of the document")},TAG:function(e,t,r){var n,i;2!==r.length&&A(e,"TAG directive accepts exactly two arguments"),n=r[0],i=r[1],p.test(n)||A(e,"ill-formed tag handle (first argument) of the TAG directive"),u.call(e.tagMap,n)&&A(e,'there is a previously declared suffix for "'+n+'" tag handle'),f.test(i)||A(e,"ill-formed tag prefix (second argument) of the TAG directive"),e.tagMap[n]=i}};function O(e,t,r,n){var i,o,a,s;if(t<r){if(s=e.input.slice(t,r),n)for(i=0,o=s.length;i<o;i+=1)9===(a=s.charCodeAt(i))||32<=a&&a<=1114111||A(e,"expected valid JSON character");else l.test(s)&&A(e,"the stream contains non-printable characters");e.result+=s}}function F(e,t,r,i){var o,a,s,l;for(n.isObject(r)||A(e,"cannot merge mappings; the provided source object is unacceptable"),s=0,l=(o=Object.keys(r)).length;s<l;s+=1)a=o[s],u.call(t,a)||(t[a]=r[a],i[a]=!0)}function k(e,t,r,n,i,o,a,s){var l,c;if(Array.isArray(i))for(l=0,c=(i=Array.prototype.slice.call(i)).length;l<c;l+=1)Array.isArray(i[l])&&A(e,"nested arrays are not supported inside keys"),"object"==typeof i&&"[object Object]"===d(i[l])&&(i[l]="[object Object]");if("object"==typeof i&&"[object Object]"===d(i)&&(i="[object Object]"),i=String(i),null===t&&(t={}),"tag:yaml.org,2002:merge"===n)if(Array.isArray(o))for(l=0,c=o.length;l<c;l+=1)F(e,t,o[l],r);else F(e,t,o,r);else e.json||u.call(r,i)||!u.call(t,i)||(e.line=a||e.line,e.position=s||e.position,A(e,"duplicated mapping key")),t[i]=o,delete r[i];return t}function P(e){var t;10===(t=e.input.charCodeAt(e.position))?e.position++:13===t?(e.position++,10===e.input.charCodeAt(e.position)&&e.position++):A(e,"a line break is expected"),e.line+=1,e.lineStart=e.position}function I(e,t,r){for(var n=0,i=e.input.charCodeAt(e.position);0!==i;){for(;y(i);)i=e.input.charCodeAt(++e.position);if(t&&35===i)do{i=e.input.charCodeAt(++e.position)}while(10!==i&&13!==i&&0!==i);if(!m(i))break;for(P(e),i=e.input.charCodeAt(e.position),n++,e.lineIndent=0;32===i;)e.lineIndent++,i=e.input.charCodeAt(++e.position)}return-1!==r&&0!==n&&e.lineIndent<r&&N(e,"deficient indentation"),n}function L(e){var t,r=e.position;return!(45!==(t=e.input.charCodeAt(r))&&46!==t||t!==e.input.charCodeAt(r+1)||t!==e.input.charCodeAt(r+2)||(r+=3,0!==(t=e.input.charCodeAt(r))&&!v(t)))}function M(e,t){1===t?e.result+=" ":t>1&&(e.result+=n.repeat("\n",t-1))}function B(e,t){var r,n,i=e.tag,o=e.anchor,a=[],s=!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=a),n=e.input.charCodeAt(e.position);0!==n&&45===n&&v(e.input.charCodeAt(e.position+1));)if(s=!0,e.position++,I(e,!0,-1)&&e.lineIndent<=t)a.push(null),n=e.input.charCodeAt(e.position);else if(r=e.line,z(e,t,3,!1,!0),a.push(e.result),I(e,!0,-1),n=e.input.charCodeAt(e.position),(e.line===r||e.lineIndent>t)&&0!==n)A(e,"bad indentation of a sequence entry");else if(e.lineIndent<t)break;return!!s&&(e.tag=i,e.anchor=o,e.kind="sequence",e.result=a,!0)}function j(e){var t,r,n,i,o=!1,a=!1;if(33!==(i=e.input.charCodeAt(e.position)))return!1;if(null!==e.tag&&A(e,"duplication of a tag property"),60===(i=e.input.charCodeAt(++e.position))?(o=!0,i=e.input.charCodeAt(++e.position)):33===i?(a=!0,r="!!",i=e.input.charCodeAt(++e.position)):r="!",t=e.position,o){do{i=e.input.charCodeAt(++e.position)}while(0!==i&&62!==i);e.position<e.length?(n=e.input.slice(t,e.position),i=e.input.charCodeAt(++e.position)):A(e,"unexpected end of the stream within a verbatim tag")}else{for(;0!==i&&!v(i);)33===i&&(a?A(e,"tag suffix cannot contain exclamation marks"):(r=e.input.slice(t-1,e.position+1),p.test(r)||A(e,"named tag handle cannot contain such characters"),a=!0,t=e.position+1)),i=e.input.charCodeAt(++e.position);n=e.input.slice(t,e.position),h.test(n)&&A(e,"tag suffix cannot contain flow indicator characters")}return n&&!f.test(n)&&A(e,"tag name cannot contain such characters: "+n),o?e.tag=n:u.call(e.tagMap,r)?e.tag=e.tagMap[r]+n:"!"===r?e.tag="!"+n:"!!"===r?e.tag="tag:yaml.org,2002:"+n:A(e,'undeclared tag handle "'+r+'"'),!0}function R(e){var t,r;if(38!==(r=e.input.charCodeAt(e.position)))return!1;for(null!==e.anchor&&A(e,"duplication of an anchor property"),r=e.input.charCodeAt(++e.position),t=e.position;0!==r&&!v(r)&&!_(r);)r=e.input.charCodeAt(++e.position);return e.position===t&&A(e,"name of an anchor node must contain at least one character"),e.anchor=e.input.slice(t,e.position),!0}function z(e,t,r,i,o){var a,s,l,c,h,p,f,d,b=1,D=!1,S=!1;if(null!==e.listener&&e.listener("open",e),e.tag=null,e.anchor=null,e.kind=null,e.result=null,a=s=l=4===r||3===r,i&&I(e,!0,-1)&&(D=!0,e.lineIndent>t?b=1:e.lineIndent===t?b=0:e.lineIndent<t&&(b=-1)),1===b)for(;j(e)||R(e);)I(e,!0,-1)?(D=!0,l=a,e.lineIndent>t?b=1:e.lineIndent===t?b=0:e.lineIndent<t&&(b=-1)):l=!1;if(l&&(l=D||o),1!==b&&4!==r||(f=1===r||2===r?t:t+1,d=e.position-e.lineStart,1===b?l&&(B(e,d)||function(e,t,r){var n,i,o,a,s,u=e.tag,l=e.anchor,c={},h={},p=null,f=null,d=null,m=!1,_=!1;for(null!==e.anchor&&(e.anchorMap[e.anchor]=c),s=e.input.charCodeAt(e.position);0!==s;){if(n=e.input.charCodeAt(e.position+1),o=e.line,a=e.position,63!==s&&58!==s||!v(n)){if(!z(e,r,2,!1,!0))break;if(e.line===o){for(s=e.input.charCodeAt(e.position);y(s);)s=e.input.charCodeAt(++e.position);if(58===s)v(s=e.input.charCodeAt(++e.position))||A(e,"a whitespace character is expected after the key-value separator within a block mapping"),m&&(k(e,c,h,p,f,null),p=f=d=null),_=!0,m=!1,i=!1,p=e.tag,f=e.result;else{if(!_)return e.tag=u,e.anchor=l,!0;A(e,"can not read an implicit mapping pair; a colon is missed")}}else{if(!_)return e.tag=u,e.anchor=l,!0;A(e,"can not read a block mapping entry; a multiline key may not be an implicit key")}}else 63===s?(m&&(k(e,c,h,p,f,null),p=f=d=null),_=!0,m=!0,i=!0):m?(m=!1,i=!0):A(e,"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),e.position+=1,s=n;if((e.line===o||e.lineIndent>t)&&(z(e,t,4,!0,i)&&(m?f=e.result:d=e.result),m||(k(e,c,h,p,f,d,o,a),p=f=d=null),I(e,!0,-1),s=e.input.charCodeAt(e.position)),e.lineIndent>t&&0!==s)A(e,"bad indentation of a mapping entry");else if(e.lineIndent<t)break}return m&&k(e,c,h,p,f,null),_&&(e.tag=u,e.anchor=l,e.kind="mapping",e.result=c),_}(e,d,f))||function(e,t){var r,n,i,o,a,s,u,l,c,h,p=!0,f=e.tag,d=e.anchor,m={};if(91===(h=e.input.charCodeAt(e.position)))i=93,s=!1,n=[];else{if(123!==h)return!1;i=125,s=!0,n={}}for(null!==e.anchor&&(e.anchorMap[e.anchor]=n),h=e.input.charCodeAt(++e.position);0!==h;){if(I(e,!0,t),(h=e.input.charCodeAt(e.position))===i)return e.position++,e.tag=f,e.anchor=d,e.kind=s?"mapping":"sequence",e.result=n,!0;p||A(e,"missed comma between flow collection entries"),c=null,o=a=!1,63===h&&v(e.input.charCodeAt(e.position+1))&&(o=a=!0,e.position++,I(e,!0,t)),r=e.line,z(e,t,1,!1,!0),l=e.tag,u=e.result,I(e,!0,t),h=e.input.charCodeAt(e.position),!a&&e.line!==r||58!==h||(o=!0,h=e.input.charCodeAt(++e.position),I(e,!0,t),z(e,t,1,!1,!0),c=e.result),s?k(e,n,m,l,u,c):o?n.push(k(e,null,m,l,u,c)):n.push(u),I(e,!0,t),44===(h=e.input.charCodeAt(e.position))?(p=!0,h=e.input.charCodeAt(++e.position)):p=!1}A(e,"unexpected end of the stream within a flow collection")}(e,f)?S=!0:(s&&function(e,t){var r,i,o,a,s,u=1,l=!1,c=!1,h=t,p=0,f=!1;if(124===(a=e.input.charCodeAt(e.position)))i=!1;else{if(62!==a)return!1;i=!0}for(e.kind="scalar",e.result="";0!==a;)if(43===(a=e.input.charCodeAt(++e.position))||45===a)1===u?u=43===a?3:2:A(e,"repeat of a chomping mode identifier");else{if(!((o=48<=(s=a)&&s<=57?s-48:-1)>=0))break;0===o?A(e,"bad explicit indentation width of a block scalar; it cannot be less than one"):c?A(e,"repeat of an indentation width identifier"):(h=t+o-1,c=!0)}if(y(a)){do{a=e.input.charCodeAt(++e.position)}while(y(a));if(35===a)do{a=e.input.charCodeAt(++e.position)}while(!m(a)&&0!==a)}for(;0!==a;){for(P(e),e.lineIndent=0,a=e.input.charCodeAt(e.position);(!c||e.lineIndent<h)&&32===a;)e.lineIndent++,a=e.input.charCodeAt(++e.position);if(!c&&e.lineIndent>h&&(h=e.lineIndent),m(a))p++;else{if(e.lineIndent<h){3===u?e.result+=n.repeat("\n",l?1+p:p):1===u&&l&&(e.result+="\n");break}for(i?y(a)?(f=!0,e.result+=n.repeat("\n",l?1+p:p)):f?(f=!1,e.result+=n.repeat("\n",p+1)):0===p?l&&(e.result+=" "):e.result+=n.repeat("\n",p):e.result+=n.repeat("\n",l?1+p:p),l=!0,c=!0,p=0,r=e.position;!m(a)&&0!==a;)a=e.input.charCodeAt(++e.position);O(e,r,e.position,!1)}}return!0}(e,f)||function(e,t){var r,n,i;if(39!==(r=e.input.charCodeAt(e.position)))return!1;for(e.kind="scalar",e.result="",e.position++,n=i=e.position;0!==(r=e.input.charCodeAt(e.position));)if(39===r){if(O(e,n,e.position,!0),39!==(r=e.input.charCodeAt(++e.position)))return!0;n=e.position,e.position++,i=e.position}else m(r)?(O(e,n,i,!0),M(e,I(e,!1,t)),n=i=e.position):e.position===e.lineStart&&L(e)?A(e,"unexpected end of the document within a single quoted scalar"):(e.position++,i=e.position);A(e,"unexpected end of the stream within a single quoted scalar")}(e,f)||function(e,t){var r,n,i,o,a,s,u;if(34!==(s=e.input.charCodeAt(e.position)))return!1;for(e.kind="scalar",e.result="",e.position++,r=n=e.position;0!==(s=e.input.charCodeAt(e.position));){if(34===s)return O(e,r,e.position,!0),e.position++,!0;if(92===s){if(O(e,r,e.position,!0),m(s=e.input.charCodeAt(++e.position)))I(e,!1,t);else if(s<256&&w[s])e.result+=E[s],e.position++;else if((a=120===(u=s)?2:117===u?4:85===u?8:0)>0){for(i=a,o=0;i>0;i--)(a=g(s=e.input.charCodeAt(++e.position)))>=0?o=(o<<4)+a:A(e,"expected hexadecimal character");e.result+=x(o),e.position++}else A(e,"unknown escape sequence");r=n=e.position}else m(s)?(O(e,r,n,!0),M(e,I(e,!1,t)),r=n=e.position):e.position===e.lineStart&&L(e)?A(e,"unexpected end of the document within a double quoted scalar"):(e.position++,n=e.position)}A(e,"unexpected end of the stream within a double quoted scalar")}(e,f)?S=!0:!function(e){var t,r,n;if(42!==(n=e.input.charCodeAt(e.position)))return!1;for(n=e.input.charCodeAt(++e.position),t=e.position;0!==n&&!v(n)&&!_(n);)n=e.input.charCodeAt(++e.position);return e.position===t&&A(e,"name of an alias node must contain at least one character"),r=e.input.slice(t,e.position),e.anchorMap.hasOwnProperty(r)||A(e,'unidentified alias "'+r+'"'),e.result=e.anchorMap[r],I(e,!0,-1),!0}(e)?function(e,t,r){var n,i,o,a,s,u,l,c,h=e.kind,p=e.result;if(v(c=e.input.charCodeAt(e.position))||_(c)||35===c||38===c||42===c||33===c||124===c||62===c||39===c||34===c||37===c||64===c||96===c)return!1;if((63===c||45===c)&&(v(n=e.input.charCodeAt(e.position+1))||r&&_(n)))return!1;for(e.kind="scalar",e.result="",i=o=e.position,a=!1;0!==c;){if(58===c){if(v(n=e.input.charCodeAt(e.position+1))||r&&_(n))break}else if(35===c){if(v(e.input.charCodeAt(e.position-1)))break}else{if(e.position===e.lineStart&&L(e)||r&&_(c))break;if(m(c)){if(s=e.line,u=e.lineStart,l=e.lineIndent,I(e,!1,-1),e.lineIndent>=t){a=!0,c=e.input.charCodeAt(e.position);continue}e.position=o,e.line=s,e.lineStart=u,e.lineIndent=l;break}}a&&(O(e,i,o,!1),M(e,e.line-s),i=o=e.position,a=!1),y(c)||(o=e.position+1),c=e.input.charCodeAt(++e.position)}return O(e,i,o,!1),!!e.result||(e.kind=h,e.result=p,!1)}(e,f,1===r)&&(S=!0,null===e.tag&&(e.tag="?")):(S=!0,null===e.tag&&null===e.anchor||A(e,"alias node should not have any properties")),null!==e.anchor&&(e.anchorMap[e.anchor]=e.result)):0===b&&(S=l&&B(e,d))),null!==e.tag&&"!"!==e.tag)if("?"===e.tag){for(null!==e.result&&"scalar"!==e.kind&&A(e,'unacceptable node kind for !<?> tag; it should be "scalar", not "'+e.kind+'"'),c=0,h=e.implicitTypes.length;c<h;c+=1)if((p=e.implicitTypes[c]).resolve(e.result)){e.result=p.construct(e.result),e.tag=p.tag,null!==e.anchor&&(e.anchorMap[e.anchor]=e.result);break}}else u.call(e.typeMap[e.kind||"fallback"],e.tag)?(p=e.typeMap[e.kind||"fallback"][e.tag],null!==e.result&&p.kind!==e.kind&&A(e,"unacceptable node kind for !<"+e.tag+'> tag; it should be "'+p.kind+'", not "'+e.kind+'"'),p.resolve(e.result)?(e.result=p.construct(e.result),null!==e.anchor&&(e.anchorMap[e.anchor]=e.result)):A(e,"cannot resolve a node with !<"+e.tag+"> explicit tag")):A(e,"unknown tag !<"+e.tag+">");return null!==e.listener&&e.listener("close",e),null!==e.tag||null!==e.anchor||S}function U(e){var t,r,n,i,o=e.position,a=!1;for(e.version=null,e.checkLineBreaks=e.legacy,e.tagMap={},e.anchorMap={};0!==(i=e.input.charCodeAt(e.position))&&(I(e,!0,-1),i=e.input.charCodeAt(e.position),!(e.lineIndent>0||37!==i));){for(a=!0,i=e.input.charCodeAt(++e.position),t=e.position;0!==i&&!v(i);)i=e.input.charCodeAt(++e.position);for(n=[],(r=e.input.slice(t,e.position)).length<1&&A(e,"directive name must not be less than one character in length");0!==i;){for(;y(i);)i=e.input.charCodeAt(++e.position);if(35===i){do{i=e.input.charCodeAt(++e.position)}while(0!==i&&!m(i));break}if(m(i))break;for(t=e.position;0!==i&&!v(i);)i=e.input.charCodeAt(++e.position);n.push(e.input.slice(t,e.position))}0!==i&&P(e),u.call(T,r)?T[r](e,r,n):N(e,'unknown document directive "'+r+'"')}I(e,!0,-1),0===e.lineIndent&&45===e.input.charCodeAt(e.position)&&45===e.input.charCodeAt(e.position+1)&&45===e.input.charCodeAt(e.position+2)?(e.position+=3,I(e,!0,-1)):a&&A(e,"directives end mark is expected"),z(e,e.lineIndent-1,4,!1,!0),I(e,!0,-1),e.checkLineBreaks&&c.test(e.input.slice(o,e.position))&&N(e,"non-ASCII line breaks are interpreted as content"),e.documents.push(e.result),e.position===e.lineStart&&L(e)?46===e.input.charCodeAt(e.position)&&(e.position+=3,I(e,!0,-1)):e.position<e.length-1&&A(e,"end of the stream or a document separator is expected")}function G(e,t){t=t||{},0!==(e=String(e)).length&&(10!==e.charCodeAt(e.length-1)&&13!==e.charCodeAt(e.length-1)&&(e+="\n"),65279===e.charCodeAt(0)&&(e=e.slice(1)));var r=new S(e,t),n=e.indexOf("\0");for(-1!==n&&(r.position=n,A(r,"null byte is not allowed in input")),r.input+="\0";32===r.input.charCodeAt(r.position);)r.lineIndent+=1,r.position+=1;for(;r.position<r.length-1;)U(r);return r.documents}function X(e,t,r){null!==t&&"object"==typeof t&&void 0===r&&(r=t,t=null);var n=G(e,r);if("function"!=typeof t)return n;for(var i=0,o=n.length;i<o;i+=1)t(n[i])}function q(e,t){var r=G(e,t);if(0!==r.length){if(1===r.length)return r[0];throw new i("expected a single document in the stream, but found more")}}e.exports.loadAll=X,e.exports.load=q,e.exports.safeLoadAll=function(e,t,r){return"object"==typeof t&&null!==t&&void 0===r&&(r=t,t=null),X(e,t,n.extend({schema:a},r))},e.exports.safeLoad=function(e,t){return q(e,n.extend({schema:a},t))}},function(e,t,r){"use strict";var n=r(38);function i(e,t,r,n,i){this.name=e,this.buffer=t,this.position=r,this.line=n,this.column=i}i.prototype.getSnippet=function(e,t){var r,i,o,a,s;if(!this.buffer)return null;for(e=e||4,t=t||75,r="",i=this.position;i>0&&-1==="\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(i-1));)if(i-=1,this.position-i>t/2-1){r=" ... ",i+=5;break}for(o="",a=this.position;a<this.buffer.length&&-1==="\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(a));)if((a+=1)-this.position>t/2-1){o=" ... ",a-=5;break}return s=this.buffer.slice(i,a),n.repeat(" ",e)+r+s+o+"\n"+n.repeat(" ",e+this.position-i+r.length)+"^"},i.prototype.toString=function(e){var t,r="";return this.name&&(r+='in "'+this.name+'" '),r+="at line "+(this.line+1)+", column "+(this.column+1),e||(t=this.getSnippet())&&(r+=":\n"+t),r},e.exports=i},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:str",{kind:"scalar",construct:function(e){return null!==e?e:""}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:seq",{kind:"sequence",construct:function(e){return null!==e?e:[]}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:map",{kind:"mapping",construct:function(e){return null!==e?e:{}}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:null",{kind:"scalar",resolve:function(e){if(null===e)return!0;var t=e.length;return 1===t&&"~"===e||4===t&&("null"===e||"Null"===e||"NULL"===e)},construct:function(){return null},predicate:function(e){return null===e},represent:{canonical:function(){return"~"},lowercase:function(){return"null"},uppercase:function(){return"NULL"},camelcase:function(){return"Null"}},defaultStyle:"lowercase"})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:bool",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t=e.length;return 4===t&&("true"===e||"True"===e||"TRUE"===e)||5===t&&("false"===e||"False"===e||"FALSE"===e)},construct:function(e){return"true"===e||"True"===e||"TRUE"===e},predicate:function(e){return"[object Boolean]"===Object.prototype.toString.call(e)},represent:{lowercase:function(e){return e?"true":"false"},uppercase:function(e){return e?"TRUE":"FALSE"},camelcase:function(e){return e?"True":"False"}},defaultStyle:"lowercase"})},function(e,t,r){"use strict";var n=r(38),i=r(10);function o(e){return 48<=e&&e<=55}function a(e){return 48<=e&&e<=57}e.exports=new i("tag:yaml.org,2002:int",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t,r,n=e.length,i=0,s=!1;if(!n)return!1;if("-"!==(t=e[i])&&"+"!==t||(t=e[++i]),"0"===t){if(i+1===n)return!0;if("b"===(t=e[++i])){for(i++;i<n;i++)if("_"!==(t=e[i])){if("0"!==t&&"1"!==t)return!1;s=!0}return s&&"_"!==t}if("x"===t){for(i++;i<n;i++)if("_"!==(t=e[i])){if(!(48<=(r=e.charCodeAt(i))&&r<=57||65<=r&&r<=70||97<=r&&r<=102))return!1;s=!0}return s&&"_"!==t}for(;i<n;i++)if("_"!==(t=e[i])){if(!o(e.charCodeAt(i)))return!1;s=!0}return s&&"_"!==t}if("_"===t)return!1;for(;i<n;i++)if("_"!==(t=e[i])){if(":"===t)break;if(!a(e.charCodeAt(i)))return!1;s=!0}return!(!s||"_"===t)&&(":"!==t||/^(:[0-5]?[0-9])+$/.test(e.slice(i)))},construct:function(e){var t,r,n=e,i=1,o=[];return-1!==n.indexOf("_")&&(n=n.replace(/_/g,"")),"-"!==(t=n[0])&&"+"!==t||("-"===t&&(i=-1),t=(n=n.slice(1))[0]),"0"===n?0:"0"===t?"b"===n[1]?i*parseInt(n.slice(2),2):"x"===n[1]?i*parseInt(n,16):i*parseInt(n,8):-1!==n.indexOf(":")?(n.split(":").forEach((function(e){o.unshift(parseInt(e,10))})),n=0,r=1,o.forEach((function(e){n+=e*r,r*=60})),i*n):i*parseInt(n,10)},predicate:function(e){return"[object Number]"===Object.prototype.toString.call(e)&&e%1==0&&!n.isNegativeZero(e)},represent:{binary:function(e){return e>=0?"0b"+e.toString(2):"-0b"+e.toString(2).slice(1)},octal:function(e){return e>=0?"0"+e.toString(8):"-0"+e.toString(8).slice(1)},decimal:function(e){return e.toString(10)},hexadecimal:function(e){return e>=0?"0x"+e.toString(16).toUpperCase():"-0x"+e.toString(16).toUpperCase().slice(1)}},defaultStyle:"decimal",styleAliases:{binary:[2,"bin"],octal:[8,"oct"],decimal:[10,"dec"],hexadecimal:[16,"hex"]}})},function(e,t,r){"use strict";var n=r(38),i=r(10),o=new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");var a=/^[-+]?[0-9]+e/;e.exports=new i("tag:yaml.org,2002:float",{kind:"scalar",resolve:function(e){return null!==e&&!(!o.test(e)||"_"===e[e.length-1])},construct:function(e){var t,r,n,i;return r="-"===(t=e.replace(/_/g,"").toLowerCase())[0]?-1:1,i=[],"+-".indexOf(t[0])>=0&&(t=t.slice(1)),".inf"===t?1===r?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:".nan"===t?NaN:t.indexOf(":")>=0?(t.split(":").forEach((function(e){i.unshift(parseFloat(e,10))})),t=0,n=1,i.forEach((function(e){t+=e*n,n*=60})),r*t):r*parseFloat(t,10)},predicate:function(e){return"[object Number]"===Object.prototype.toString.call(e)&&(e%1!=0||n.isNegativeZero(e))},represent:function(e,t){var r;if(isNaN(e))switch(t){case"lowercase":return".nan";case"uppercase":return".NAN";case"camelcase":return".NaN"}else if(Number.POSITIVE_INFINITY===e)switch(t){case"lowercase":return".inf";case"uppercase":return".INF";case"camelcase":return".Inf"}else if(Number.NEGATIVE_INFINITY===e)switch(t){case"lowercase":return"-.inf";case"uppercase":return"-.INF";case"camelcase":return"-.Inf"}else if(n.isNegativeZero(e))return"-0.0";return r=e.toString(10),a.test(r)?r.replace("e",".e"):r},defaultStyle:"lowercase"})},function(e,t,r){"use strict";var n=r(10),i=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),o=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");e.exports=new n("tag:yaml.org,2002:timestamp",{kind:"scalar",resolve:function(e){return null!==e&&(null!==i.exec(e)||null!==o.exec(e))},construct:function(e){var t,r,n,a,s,u,l,c,h=0,p=null;if(null===(t=i.exec(e))&&(t=o.exec(e)),null===t)throw new Error("Date resolve error");if(r=+t[1],n=+t[2]-1,a=+t[3],!t[4])return new Date(Date.UTC(r,n,a));if(s=+t[4],u=+t[5],l=+t[6],t[7]){for(h=t[7].slice(0,3);h.length<3;)h+="0";h=+h}return t[9]&&(p=6e4*(60*+t[10]+ +(t[11]||0)),"-"===t[9]&&(p=-p)),c=new Date(Date.UTC(r,n,a,s,u,l,h)),p&&c.setTime(c.getTime()-p),c},instanceOf:Date,represent:function(e){return e.toISOString()}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:merge",{kind:"scalar",resolve:function(e){return"<<"===e||null===e}})},function(e,t,r){"use strict";var n;try{n=r(145).Buffer}catch(e){}var i=r(10),o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";e.exports=new i("tag:yaml.org,2002:binary",{kind:"scalar",resolve:function(e){if(null===e)return!1;var t,r,n=0,i=e.length,a=o;for(r=0;r<i;r++)if(!((t=a.indexOf(e.charAt(r)))>64)){if(t<0)return!1;n+=6}return n%8==0},construct:function(e){var t,r,i=e.replace(/[\r\n=]/g,""),a=i.length,s=o,u=0,l=[];for(t=0;t<a;t++)t%4==0&&t&&(l.push(u>>16&255),l.push(u>>8&255),l.push(255&u)),u=u<<6|s.indexOf(i.charAt(t));return 0===(r=a%4*6)?(l.push(u>>16&255),l.push(u>>8&255),l.push(255&u)):18===r?(l.push(u>>10&255),l.push(u>>2&255)):12===r&&l.push(u>>4&255),n?n.from?n.from(l):new n(l):l},predicate:function(e){return n&&n.isBuffer(e)},represent:function(e){var t,r,n="",i=0,a=e.length,s=o;for(t=0;t<a;t++)t%3==0&&t&&(n+=s[i>>18&63],n+=s[i>>12&63],n+=s[i>>6&63],n+=s[63&i]),i=(i<<8)+e[t];return 0===(r=a%3)?(n+=s[i>>18&63],n+=s[i>>12&63],n+=s[i>>6&63],n+=s[63&i]):2===r?(n+=s[i>>10&63],n+=s[i>>4&63],n+=s[i<<2&63],n+=s[64]):1===r&&(n+=s[i>>2&63],n+=s[i<<4&63],n+=s[64],n+=s[64]),n}})},function(e,t,r){"use strict";var n=r(10),i=Object.prototype.hasOwnProperty,o=Object.prototype.toString;e.exports=new n("tag:yaml.org,2002:omap",{kind:"sequence",resolve:function(e){if(null===e)return!0;var t,r,n,a,s,u=[],l=e;for(t=0,r=l.length;t<r;t+=1){if(n=l[t],s=!1,"[object Object]"!==o.call(n))return!1;for(a in n)if(i.call(n,a)){if(s)return!1;s=!0}if(!s)return!1;if(-1!==u.indexOf(a))return!1;u.push(a)}return!0},construct:function(e){return null!==e?e:[]}})},function(e,t,r){"use strict";var n=r(10),i=Object.prototype.toString;e.exports=new n("tag:yaml.org,2002:pairs",{kind:"sequence",resolve:function(e){if(null===e)return!0;var t,r,n,o,a,s=e;for(a=new Array(s.length),t=0,r=s.length;t<r;t+=1){if(n=s[t],"[object Object]"!==i.call(n))return!1;if(1!==(o=Object.keys(n)).length)return!1;a[t]=[o[0],n[o[0]]]}return!0},construct:function(e){if(null===e)return[];var t,r,n,i,o,a=e;for(o=new Array(a.length),t=0,r=a.length;t<r;t+=1)n=a[t],i=Object.keys(n),o[t]=[i[0],n[i[0]]];return o}})},function(e,t,r){"use strict";var n=r(10),i=Object.prototype.hasOwnProperty;e.exports=new n("tag:yaml.org,2002:set",{kind:"mapping",resolve:function(e){if(null===e)return!0;var t,r=e;for(t in r)if(i.call(r,t)&&null!==r[t])return!1;return!0},construct:function(e){return null!==e?e:{}}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:js/undefined",{kind:"scalar",resolve:function(){return!0},construct:function(){},predicate:function(e){return void 0===e},represent:function(){return""}})},function(e,t,r){"use strict";var n=r(10);e.exports=new n("tag:yaml.org,2002:js/regexp",{kind:"scalar",resolve:function(e){if(null===e)return!1;if(0===e.length)return!1;var t=e,r=/\/([gim]*)$/.exec(e),n="";if("/"===t[0]){if(r&&(n=r[1]),n.length>3)return!1;if("/"!==t[t.length-n.length-1])return!1}return!0},construct:function(e){var t=e,r=/\/([gim]*)$/.exec(e),n="";return"/"===t[0]&&(r&&(n=r[1]),t=t.slice(1,t.length-n.length-1)),new RegExp(t,n)},predicate:function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},represent:function(e){var t="/"+e.source+"/";return e.global&&(t+="g"),e.multiline&&(t+="m"),e.ignoreCase&&(t+="i"),t}})},function(e,t,r){"use strict";var n;try{n=r(302)}catch(e){"undefined"!=typeof window&&(n=window.esprima)}var i=r(10);e.exports=new i("tag:yaml.org,2002:js/function",{kind:"scalar",resolve:function(e){if(null===e)return!1;try{var t="("+e+")",r=n.parse(t,{range:!0});return"Program"===r.type&&1===r.body.length&&"ExpressionStatement"===r.body[0].type&&("ArrowFunctionExpression"===r.body[0].expression.type||"FunctionExpression"===r.body[0].expression.type)}catch(e){return!1}},construct:function(e){var t,r="("+e+")",i=n.parse(r,{range:!0}),o=[];if("Program"!==i.type||1!==i.body.length||"ExpressionStatement"!==i.body[0].type||"ArrowFunctionExpression"!==i.body[0].expression.type&&"FunctionExpression"!==i.body[0].expression.type)throw new Error("Failed to resolve function");return i.body[0].expression.params.forEach((function(e){o.push(e.name)})),t=i.body[0].expression.body.range,"BlockStatement"===i.body[0].expression.body.type?new Function(o,r.slice(t[0]+1,t[1]-1)):new Function(o,"return "+r.slice(t[0],t[1]))},predicate:function(e){return"[object Function]"===Object.prototype.toString.call(e)},represent:function(e){return e.toString()}})},function(e,t,r){var n;n=function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={exports:{},id:n,loaded:!1};return e[n].call(i.exports,i,i.exports,r),i.loaded=!0,i.exports}return r.m=e,r.c=t,r.p="",r(0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(3),o=r(8),a=r(15);function s(e,t,r){var a=null,s=function(e,t){r&&r(e,t),a&&a.visit(e,t)},u="function"==typeof r?s:null,l=!1;if(t){l="boolean"==typeof t.comment&&t.comment;var c="boolean"==typeof t.attachComment&&t.attachComment;(l||c)&&((a=new n.CommentHandler).attach=c,t.comment=!0,u=s)}var h,p=!1;t&&"string"==typeof t.sourceType&&(p="module"===t.sourceType),h=t&&"boolean"==typeof t.jsx&&t.jsx?new i.JSXParser(e,t,u):new o.Parser(e,t,u);var f=p?h.parseModule():h.parseScript();return l&&a&&(f.comments=a.comments),h.config.tokens&&(f.tokens=h.tokens),h.config.tolerant&&(f.errors=h.errorHandler.errors),f}t.parse=s,t.parseModule=function(e,t,r){var n=t||{};return n.sourceType="module",s(e,n,r)},t.parseScript=function(e,t,r){var n=t||{};return n.sourceType="script",s(e,n,r)},t.tokenize=function(e,t,r){var n,i=new a.Tokenizer(e,t);n=[];try{for(;;){var o=i.getNextToken();if(!o)break;r&&(o=r(o)),n.push(o)}}catch(e){i.errorHandler.tolerate(e)}return i.errorHandler.tolerant&&(n.errors=i.errors()),n};var u=r(2);t.Syntax=u.Syntax,t.version="4.0.1"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=function(){function e(){this.attach=!1,this.comments=[],this.stack=[],this.leading=[],this.trailing=[]}return e.prototype.insertInnerComments=function(e,t){if(e.type===n.Syntax.BlockStatement&&0===e.body.length){for(var r=[],i=this.leading.length-1;i>=0;--i){var o=this.leading[i];t.end.offset>=o.start&&(r.unshift(o.comment),this.leading.splice(i,1),this.trailing.splice(i,1))}r.length&&(e.innerComments=r)}},e.prototype.findTrailingComments=function(e){var t=[];if(this.trailing.length>0){for(var r=this.trailing.length-1;r>=0;--r){var n=this.trailing[r];n.start>=e.end.offset&&t.unshift(n.comment)}return this.trailing.length=0,t}var i=this.stack[this.stack.length-1];if(i&&i.node.trailingComments){var o=i.node.trailingComments[0];o&&o.range[0]>=e.end.offset&&(t=i.node.trailingComments,delete i.node.trailingComments)}return t},e.prototype.findLeadingComments=function(e){for(var t,r=[];this.stack.length>0&&((o=this.stack[this.stack.length-1])&&o.start>=e.start.offset);)t=o.node,this.stack.pop();if(t){for(var n=(t.leadingComments?t.leadingComments.length:0)-1;n>=0;--n){var i=t.leadingComments[n];i.range[1]<=e.start.offset&&(r.unshift(i),t.leadingComments.splice(n,1))}return t.leadingComments&&0===t.leadingComments.length&&delete t.leadingComments,r}for(n=this.leading.length-1;n>=0;--n){var o;(o=this.leading[n]).start<=e.start.offset&&(r.unshift(o.comment),this.leading.splice(n,1))}return r},e.prototype.visitNode=function(e,t){if(!(e.type===n.Syntax.Program&&e.body.length>0)){this.insertInnerComments(e,t);var r=this.findTrailingComments(t),i=this.findLeadingComments(t);i.length>0&&(e.leadingComments=i),r.length>0&&(e.trailingComments=r),this.stack.push({node:e,start:t.start.offset})}},e.prototype.visitComment=function(e,t){var r="L"===e.type[0]?"Line":"Block",n={type:r,value:e.value};if(e.range&&(n.range=e.range),e.loc&&(n.loc=e.loc),this.comments.push(n),this.attach){var i={comment:{type:r,value:e.value,range:[t.start.offset,t.end.offset]},start:t.start.offset};e.loc&&(i.comment.loc=e.loc),e.type=r,this.leading.push(i),this.trailing.push(i)}},e.prototype.visit=function(e,t){"LineComment"===e.type||"BlockComment"===e.type?this.visitComment(e,t):this.attach&&this.visitNode(e,t)},e}();t.CommentHandler=i},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Syntax={AssignmentExpression:"AssignmentExpression",AssignmentPattern:"AssignmentPattern",ArrayExpression:"ArrayExpression",ArrayPattern:"ArrayPattern",ArrowFunctionExpression:"ArrowFunctionExpression",AwaitExpression:"AwaitExpression",BlockStatement:"BlockStatement",BinaryExpression:"BinaryExpression",BreakStatement:"BreakStatement",CallExpression:"CallExpression",CatchClause:"CatchClause",ClassBody:"ClassBody",ClassDeclaration:"ClassDeclaration",ClassExpression:"ClassExpression",ConditionalExpression:"ConditionalExpression",ContinueStatement:"ContinueStatement",DoWhileStatement:"DoWhileStatement",DebuggerStatement:"DebuggerStatement",EmptyStatement:"EmptyStatement",ExportAllDeclaration:"ExportAllDeclaration",ExportDefaultDeclaration:"ExportDefaultDeclaration",ExportNamedDeclaration:"ExportNamedDeclaration",ExportSpecifier:"ExportSpecifier",ExpressionStatement:"ExpressionStatement",ForStatement:"ForStatement",ForOfStatement:"ForOfStatement",ForInStatement:"ForInStatement",FunctionDeclaration:"FunctionDeclaration",FunctionExpression:"FunctionExpression",Identifier:"Identifier",IfStatement:"IfStatement",ImportDeclaration:"ImportDeclaration",ImportDefaultSpecifier:"ImportDefaultSpecifier",ImportNamespaceSpecifier:"ImportNamespaceSpecifier",ImportSpecifier:"ImportSpecifier",Literal:"Literal",LabeledStatement:"LabeledStatement",LogicalExpression:"LogicalExpression",MemberExpression:"MemberExpression",MetaProperty:"MetaProperty",MethodDefinition:"MethodDefinition",NewExpression:"NewExpression",ObjectExpression:"ObjectExpression",ObjectPattern:"ObjectPattern",Program:"Program",Property:"Property",RestElement:"RestElement",ReturnStatement:"ReturnStatement",SequenceExpression:"SequenceExpression",SpreadElement:"SpreadElement",Super:"Super",SwitchCase:"SwitchCase",SwitchStatement:"SwitchStatement",TaggedTemplateExpression:"TaggedTemplateExpression",TemplateElement:"TemplateElement",TemplateLiteral:"TemplateLiteral",ThisExpression:"ThisExpression",ThrowStatement:"ThrowStatement",TryStatement:"TryStatement",UnaryExpression:"UnaryExpression",UpdateExpression:"UpdateExpression",VariableDeclaration:"VariableDeclaration",VariableDeclarator:"VariableDeclarator",WhileStatement:"WhileStatement",WithStatement:"WithStatement",YieldExpression:"YieldExpression"}},function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(4),a=r(5),s=r(6),u=r(7),l=r(8),c=r(13),h=r(14);function p(e){var t;switch(e.type){case s.JSXSyntax.JSXIdentifier:t=e.name;break;case s.JSXSyntax.JSXNamespacedName:var r=e;t=p(r.namespace)+":"+p(r.name);break;case s.JSXSyntax.JSXMemberExpression:var n=e;t=p(n.object)+"."+p(n.property)}return t}c.TokenName[100]="JSXIdentifier",c.TokenName[101]="JSXText";var f=function(e){function t(t,r,n){return e.call(this,t,r,n)||this}return i(t,e),t.prototype.parsePrimaryExpression=function(){return this.match("<")?this.parseJSXRoot():e.prototype.parsePrimaryExpression.call(this)},t.prototype.startJSX=function(){this.scanner.index=this.startMarker.index,this.scanner.lineNumber=this.startMarker.line,this.scanner.lineStart=this.startMarker.index-this.startMarker.column},t.prototype.finishJSX=function(){this.nextToken()},t.prototype.reenterJSX=function(){this.startJSX(),this.expectJSX("}"),this.config.tokens&&this.tokens.pop()},t.prototype.createJSXNode=function(){return this.collectComments(),{index:this.scanner.index,line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart}},t.prototype.createJSXChildNode=function(){return{index:this.scanner.index,line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart}},t.prototype.scanXHTMLEntity=function(e){for(var t="&",r=!0,n=!1,i=!1,a=!1;!this.scanner.eof()&&r&&!n;){var s=this.scanner.source[this.scanner.index];if(s===e)break;if(n=";"===s,t+=s,++this.scanner.index,!n)switch(t.length){case 2:i="#"===s;break;case 3:i&&(r=(a="x"===s)||o.Character.isDecimalDigit(s.charCodeAt(0)),i=i&&!a);break;default:r=(r=r&&!(i&&!o.Character.isDecimalDigit(s.charCodeAt(0))))&&!(a&&!o.Character.isHexDigit(s.charCodeAt(0)))}}if(r&&n&&t.length>2){var u=t.substr(1,t.length-2);i&&u.length>1?t=String.fromCharCode(parseInt(u.substr(1),10)):a&&u.length>2?t=String.fromCharCode(parseInt("0"+u.substr(1),16)):i||a||!h.XHTMLEntities[u]||(t=h.XHTMLEntities[u])}return t},t.prototype.lexJSX=function(){var e=this.scanner.source.charCodeAt(this.scanner.index);if(60===e||62===e||47===e||58===e||61===e||123===e||125===e)return{type:7,value:s=this.scanner.source[this.scanner.index++],lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:this.scanner.index-1,end:this.scanner.index};if(34===e||39===e){for(var t=this.scanner.index,r=this.scanner.source[this.scanner.index++],n="";!this.scanner.eof()&&(u=this.scanner.source[this.scanner.index++])!==r;)n+="&"===u?this.scanXHTMLEntity(r):u;return{type:8,value:n,lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:t,end:this.scanner.index}}if(46===e){var i=this.scanner.source.charCodeAt(this.scanner.index+1),a=this.scanner.source.charCodeAt(this.scanner.index+2),s=46===i&&46===a?"...":".";return t=this.scanner.index,this.scanner.index+=s.length,{type:7,value:s,lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:t,end:this.scanner.index}}if(96===e)return{type:10,value:"",lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:this.scanner.index,end:this.scanner.index};if(o.Character.isIdentifierStart(e)&&92!==e){for(t=this.scanner.index,++this.scanner.index;!this.scanner.eof();){var u=this.scanner.source.charCodeAt(this.scanner.index);if(o.Character.isIdentifierPart(u)&&92!==u)++this.scanner.index;else{if(45!==u)break;++this.scanner.index}}return{type:100,value:this.scanner.source.slice(t,this.scanner.index),lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:t,end:this.scanner.index}}return this.scanner.lex()},t.prototype.nextJSXToken=function(){this.collectComments(),this.startMarker.index=this.scanner.index,this.startMarker.line=this.scanner.lineNumber,this.startMarker.column=this.scanner.index-this.scanner.lineStart;var e=this.lexJSX();return this.lastMarker.index=this.scanner.index,this.lastMarker.line=this.scanner.lineNumber,this.lastMarker.column=this.scanner.index-this.scanner.lineStart,this.config.tokens&&this.tokens.push(this.convertToken(e)),e},t.prototype.nextJSXText=function(){this.startMarker.index=this.scanner.index,this.startMarker.line=this.scanner.lineNumber,this.startMarker.column=this.scanner.index-this.scanner.lineStart;for(var e=this.scanner.index,t="";!this.scanner.eof();){var r=this.scanner.source[this.scanner.index];if("{"===r||"<"===r)break;++this.scanner.index,t+=r,o.Character.isLineTerminator(r.charCodeAt(0))&&(++this.scanner.lineNumber,"\r"===r&&"\n"===this.scanner.source[this.scanner.index]&&++this.scanner.index,this.scanner.lineStart=this.scanner.index)}this.lastMarker.index=this.scanner.index,this.lastMarker.line=this.scanner.lineNumber,this.lastMarker.column=this.scanner.index-this.scanner.lineStart;var n={type:101,value:t,lineNumber:this.scanner.lineNumber,lineStart:this.scanner.lineStart,start:e,end:this.scanner.index};return t.length>0&&this.config.tokens&&this.tokens.push(this.convertToken(n)),n},t.prototype.peekJSXToken=function(){var e=this.scanner.saveState();this.scanner.scanComments();var t=this.lexJSX();return this.scanner.restoreState(e),t},t.prototype.expectJSX=function(e){var t=this.nextJSXToken();7===t.type&&t.value===e||this.throwUnexpectedToken(t)},t.prototype.matchJSX=function(e){var t=this.peekJSXToken();return 7===t.type&&t.value===e},t.prototype.parseJSXIdentifier=function(){var e=this.createJSXNode(),t=this.nextJSXToken();return 100!==t.type&&this.throwUnexpectedToken(t),this.finalize(e,new a.JSXIdentifier(t.value))},t.prototype.parseJSXElementName=function(){var e=this.createJSXNode(),t=this.parseJSXIdentifier();if(this.matchJSX(":")){var r=t;this.expectJSX(":");var n=this.parseJSXIdentifier();t=this.finalize(e,new a.JSXNamespacedName(r,n))}else if(this.matchJSX("."))for(;this.matchJSX(".");){var i=t;this.expectJSX(".");var o=this.parseJSXIdentifier();t=this.finalize(e,new a.JSXMemberExpression(i,o))}return t},t.prototype.parseJSXAttributeName=function(){var e,t=this.createJSXNode(),r=this.parseJSXIdentifier();if(this.matchJSX(":")){var n=r;this.expectJSX(":");var i=this.parseJSXIdentifier();e=this.finalize(t,new a.JSXNamespacedName(n,i))}else e=r;return e},t.prototype.parseJSXStringLiteralAttribute=function(){var e=this.createJSXNode(),t=this.nextJSXToken();8!==t.type&&this.throwUnexpectedToken(t);var r=this.getTokenRaw(t);return this.finalize(e,new u.Literal(t.value,r))},t.prototype.parseJSXExpressionAttribute=function(){var e=this.createJSXNode();this.expectJSX("{"),this.finishJSX(),this.match("}")&&this.tolerateError("JSX attributes must only be assigned a non-empty expression");var t=this.parseAssignmentExpression();return this.reenterJSX(),this.finalize(e,new a.JSXExpressionContainer(t))},t.prototype.parseJSXAttributeValue=function(){return this.matchJSX("{")?this.parseJSXExpressionAttribute():this.matchJSX("<")?this.parseJSXElement():this.parseJSXStringLiteralAttribute()},t.prototype.parseJSXNameValueAttribute=function(){var e=this.createJSXNode(),t=this.parseJSXAttributeName(),r=null;return this.matchJSX("=")&&(this.expectJSX("="),r=this.parseJSXAttributeValue()),this.finalize(e,new a.JSXAttribute(t,r))},t.prototype.parseJSXSpreadAttribute=function(){var e=this.createJSXNode();this.expectJSX("{"),this.expectJSX("..."),this.finishJSX();var t=this.parseAssignmentExpression();return this.reenterJSX(),this.finalize(e,new a.JSXSpreadAttribute(t))},t.prototype.parseJSXAttributes=function(){for(var e=[];!this.matchJSX("/")&&!this.matchJSX(">");){var t=this.matchJSX("{")?this.parseJSXSpreadAttribute():this.parseJSXNameValueAttribute();e.push(t)}return e},t.prototype.parseJSXOpeningElement=function(){var e=this.createJSXNode();this.expectJSX("<");var t=this.parseJSXElementName(),r=this.parseJSXAttributes(),n=this.matchJSX("/");return n&&this.expectJSX("/"),this.expectJSX(">"),this.finalize(e,new a.JSXOpeningElement(t,n,r))},t.prototype.parseJSXBoundaryElement=function(){var e=this.createJSXNode();if(this.expectJSX("<"),this.matchJSX("/")){this.expectJSX("/");var t=this.parseJSXElementName();return this.expectJSX(">"),this.finalize(e,new a.JSXClosingElement(t))}var r=this.parseJSXElementName(),n=this.parseJSXAttributes(),i=this.matchJSX("/");return i&&this.expectJSX("/"),this.expectJSX(">"),this.finalize(e,new a.JSXOpeningElement(r,i,n))},t.prototype.parseJSXEmptyExpression=function(){var e=this.createJSXChildNode();return this.collectComments(),this.lastMarker.index=this.scanner.index,this.lastMarker.line=this.scanner.lineNumber,this.lastMarker.column=this.scanner.index-this.scanner.lineStart,this.finalize(e,new a.JSXEmptyExpression)},t.prototype.parseJSXExpressionContainer=function(){var e,t=this.createJSXNode();return this.expectJSX("{"),this.matchJSX("}")?(e=this.parseJSXEmptyExpression(),this.expectJSX("}")):(this.finishJSX(),e=this.parseAssignmentExpression(),this.reenterJSX()),this.finalize(t,new a.JSXExpressionContainer(e))},t.prototype.parseJSXChildren=function(){for(var e=[];!this.scanner.eof();){var t=this.createJSXChildNode(),r=this.nextJSXText();if(r.start<r.end){var n=this.getTokenRaw(r),i=this.finalize(t,new a.JSXText(r.value,n));e.push(i)}if("{"!==this.scanner.source[this.scanner.index])break;var o=this.parseJSXExpressionContainer();e.push(o)}return e},t.prototype.parseComplexJSXElement=function(e){for(var t=[];!this.scanner.eof();){e.children=e.children.concat(this.parseJSXChildren());var r=this.createJSXChildNode(),n=this.parseJSXBoundaryElement();if(n.type===s.JSXSyntax.JSXOpeningElement){var i=n;if(i.selfClosing){var o=this.finalize(r,new a.JSXElement(i,[],null));e.children.push(o)}else t.push(e),e={node:r,opening:i,closing:null,children:[]}}if(n.type===s.JSXSyntax.JSXClosingElement){e.closing=n;var u=p(e.opening.name);if(u!==p(e.closing.name)&&this.tolerateError("Expected corresponding JSX closing tag for %0",u),!(t.length>0))break;o=this.finalize(e.node,new a.JSXElement(e.opening,e.children,e.closing)),(e=t[t.length-1]).children.push(o),t.pop()}}return e},t.prototype.parseJSXElement=function(){var e=this.createJSXNode(),t=this.parseJSXOpeningElement(),r=[],n=null;if(!t.selfClosing){var i=this.parseComplexJSXElement({node:e,opening:t,closing:n,children:r});r=i.children,n=i.closing}return this.finalize(e,new a.JSXElement(t,r,n))},t.prototype.parseJSXRoot=function(){this.config.tokens&&this.tokens.pop(),this.startJSX();var e=this.parseJSXElement();return this.finishJSX(),e},t.prototype.isStartOfExpression=function(){return e.prototype.isStartOfExpression.call(this)||this.match("<")},t}(l.Parser);t.JSXParser=f},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/};t.Character={fromCodePoint:function(e){return e<65536?String.fromCharCode(e):String.fromCharCode(55296+(e-65536>>10))+String.fromCharCode(56320+(e-65536&1023))},isWhiteSpace:function(e){return 32===e||9===e||11===e||12===e||160===e||e>=5760&&[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].indexOf(e)>=0},isLineTerminator:function(e){return 10===e||13===e||8232===e||8233===e},isIdentifierStart:function(e){return 36===e||95===e||e>=65&&e<=90||e>=97&&e<=122||92===e||e>=128&&r.NonAsciiIdentifierStart.test(t.Character.fromCodePoint(e))},isIdentifierPart:function(e){return 36===e||95===e||e>=65&&e<=90||e>=97&&e<=122||e>=48&&e<=57||92===e||e>=128&&r.NonAsciiIdentifierPart.test(t.Character.fromCodePoint(e))},isDecimalDigit:function(e){return e>=48&&e<=57},isHexDigit:function(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102},isOctalDigit:function(e){return e>=48&&e<=55}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),i=function(e){this.type=n.JSXSyntax.JSXClosingElement,this.name=e};t.JSXClosingElement=i;var o=function(e,t,r){this.type=n.JSXSyntax.JSXElement,this.openingElement=e,this.children=t,this.closingElement=r};t.JSXElement=o;var a=function(){this.type=n.JSXSyntax.JSXEmptyExpression};t.JSXEmptyExpression=a;var s=function(e){this.type=n.JSXSyntax.JSXExpressionContainer,this.expression=e};t.JSXExpressionContainer=s;var u=function(e){this.type=n.JSXSyntax.JSXIdentifier,this.name=e};t.JSXIdentifier=u;var l=function(e,t){this.type=n.JSXSyntax.JSXMemberExpression,this.object=e,this.property=t};t.JSXMemberExpression=l;var c=function(e,t){this.type=n.JSXSyntax.JSXAttribute,this.name=e,this.value=t};t.JSXAttribute=c;var h=function(e,t){this.type=n.JSXSyntax.JSXNamespacedName,this.namespace=e,this.name=t};t.JSXNamespacedName=h;var p=function(e,t,r){this.type=n.JSXSyntax.JSXOpeningElement,this.name=e,this.selfClosing=t,this.attributes=r};t.JSXOpeningElement=p;var f=function(e){this.type=n.JSXSyntax.JSXSpreadAttribute,this.argument=e};t.JSXSpreadAttribute=f;var d=function(e,t){this.type=n.JSXSyntax.JSXText,this.value=e,this.raw=t};t.JSXText=d},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JSXSyntax={JSXAttribute:"JSXAttribute",JSXClosingElement:"JSXClosingElement",JSXElement:"JSXElement",JSXEmptyExpression:"JSXEmptyExpression",JSXExpressionContainer:"JSXExpressionContainer",JSXIdentifier:"JSXIdentifier",JSXMemberExpression:"JSXMemberExpression",JSXNamespacedName:"JSXNamespacedName",JSXOpeningElement:"JSXOpeningElement",JSXSpreadAttribute:"JSXSpreadAttribute",JSXText:"JSXText"}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),i=function(e){this.type=n.Syntax.ArrayExpression,this.elements=e};t.ArrayExpression=i;var o=function(e){this.type=n.Syntax.ArrayPattern,this.elements=e};t.ArrayPattern=o;var a=function(e,t,r){this.type=n.Syntax.ArrowFunctionExpression,this.id=null,this.params=e,this.body=t,this.generator=!1,this.expression=r,this.async=!1};t.ArrowFunctionExpression=a;var s=function(e,t,r){this.type=n.Syntax.AssignmentExpression,this.operator=e,this.left=t,this.right=r};t.AssignmentExpression=s;var u=function(e,t){this.type=n.Syntax.AssignmentPattern,this.left=e,this.right=t};t.AssignmentPattern=u;var l=function(e,t,r){this.type=n.Syntax.ArrowFunctionExpression,this.id=null,this.params=e,this.body=t,this.generator=!1,this.expression=r,this.async=!0};t.AsyncArrowFunctionExpression=l;var c=function(e,t,r){this.type=n.Syntax.FunctionDeclaration,this.id=e,this.params=t,this.body=r,this.generator=!1,this.expression=!1,this.async=!0};t.AsyncFunctionDeclaration=c;var h=function(e,t,r){this.type=n.Syntax.FunctionExpression,this.id=e,this.params=t,this.body=r,this.generator=!1,this.expression=!1,this.async=!0};t.AsyncFunctionExpression=h;var p=function(e){this.type=n.Syntax.AwaitExpression,this.argument=e};t.AwaitExpression=p;var f=function(e,t,r){var i="||"===e||"&&"===e;this.type=i?n.Syntax.LogicalExpression:n.Syntax.BinaryExpression,this.operator=e,this.left=t,this.right=r};t.BinaryExpression=f;var d=function(e){this.type=n.Syntax.BlockStatement,this.body=e};t.BlockStatement=d;var m=function(e){this.type=n.Syntax.BreakStatement,this.label=e};t.BreakStatement=m;var y=function(e,t){this.type=n.Syntax.CallExpression,this.callee=e,this.arguments=t};t.CallExpression=y;var v=function(e,t){this.type=n.Syntax.CatchClause,this.param=e,this.body=t};t.CatchClause=v;var _=function(e){this.type=n.Syntax.ClassBody,this.body=e};t.ClassBody=_;var g=function(e,t,r){this.type=n.Syntax.ClassDeclaration,this.id=e,this.superClass=t,this.body=r};t.ClassDeclaration=g;var b=function(e,t,r){this.type=n.Syntax.ClassExpression,this.id=e,this.superClass=t,this.body=r};t.ClassExpression=b;var x=function(e,t){this.type=n.Syntax.MemberExpression,this.computed=!0,this.object=e,this.property=t};t.ComputedMemberExpression=x;var w=function(e,t,r){this.type=n.Syntax.ConditionalExpression,this.test=e,this.consequent=t,this.alternate=r};t.ConditionalExpression=w;var E=function(e){this.type=n.Syntax.ContinueStatement,this.label=e};t.ContinueStatement=E;var D=function(){this.type=n.Syntax.DebuggerStatement};t.DebuggerStatement=D;var S=function(e,t){this.type=n.Syntax.ExpressionStatement,this.expression=e,this.directive=t};t.Directive=S;var C=function(e,t){this.type=n.Syntax.DoWhileStatement,this.body=e,this.test=t};t.DoWhileStatement=C;var A=function(){this.type=n.Syntax.EmptyStatement};t.EmptyStatement=A;var N=function(e){this.type=n.Syntax.ExportAllDeclaration,this.source=e};t.ExportAllDeclaration=N;var T=function(e){this.type=n.Syntax.ExportDefaultDeclaration,this.declaration=e};t.ExportDefaultDeclaration=T;var O=function(e,t,r){this.type=n.Syntax.ExportNamedDeclaration,this.declaration=e,this.specifiers=t,this.source=r};t.ExportNamedDeclaration=O;var F=function(e,t){this.type=n.Syntax.ExportSpecifier,this.exported=t,this.local=e};t.ExportSpecifier=F;var k=function(e){this.type=n.Syntax.ExpressionStatement,this.expression=e};t.ExpressionStatement=k;var P=function(e,t,r){this.type=n.Syntax.ForInStatement,this.left=e,this.right=t,this.body=r,this.each=!1};t.ForInStatement=P;var I=function(e,t,r){this.type=n.Syntax.ForOfStatement,this.left=e,this.right=t,this.body=r};t.ForOfStatement=I;var L=function(e,t,r,i){this.type=n.Syntax.ForStatement,this.init=e,this.test=t,this.update=r,this.body=i};t.ForStatement=L;var M=function(e,t,r,i){this.type=n.Syntax.FunctionDeclaration,this.id=e,this.params=t,this.body=r,this.generator=i,this.expression=!1,this.async=!1};t.FunctionDeclaration=M;var B=function(e,t,r,i){this.type=n.Syntax.FunctionExpression,this.id=e,this.params=t,this.body=r,this.generator=i,this.expression=!1,this.async=!1};t.FunctionExpression=B;var j=function(e){this.type=n.Syntax.Identifier,this.name=e};t.Identifier=j;var R=function(e,t,r){this.type=n.Syntax.IfStatement,this.test=e,this.consequent=t,this.alternate=r};t.IfStatement=R;var z=function(e,t){this.type=n.Syntax.ImportDeclaration,this.specifiers=e,this.source=t};t.ImportDeclaration=z;var U=function(e){this.type=n.Syntax.ImportDefaultSpecifier,this.local=e};t.ImportDefaultSpecifier=U;var G=function(e){this.type=n.Syntax.ImportNamespaceSpecifier,this.local=e};t.ImportNamespaceSpecifier=G;var X=function(e,t){this.type=n.Syntax.ImportSpecifier,this.local=e,this.imported=t};t.ImportSpecifier=X;var q=function(e,t){this.type=n.Syntax.LabeledStatement,this.label=e,this.body=t};t.LabeledStatement=q;var W=function(e,t){this.type=n.Syntax.Literal,this.value=e,this.raw=t};t.Literal=W;var H=function(e,t){this.type=n.Syntax.MetaProperty,this.meta=e,this.property=t};t.MetaProperty=H;var J=function(e,t,r,i,o){this.type=n.Syntax.MethodDefinition,this.key=e,this.computed=t,this.value=r,this.kind=i,this.static=o};t.MethodDefinition=J;var Y=function(e){this.type=n.Syntax.Program,this.body=e,this.sourceType="module"};t.Module=Y;var V=function(e,t){this.type=n.Syntax.NewExpression,this.callee=e,this.arguments=t};t.NewExpression=V;var K=function(e){this.type=n.Syntax.ObjectExpression,this.properties=e};t.ObjectExpression=K;var $=function(e){this.type=n.Syntax.ObjectPattern,this.properties=e};t.ObjectPattern=$;var Q=function(e,t,r,i,o,a){this.type=n.Syntax.Property,this.key=t,this.computed=r,this.value=i,this.kind=e,this.method=o,this.shorthand=a};t.Property=Q;var Z=function(e,t,r,i){this.type=n.Syntax.Literal,this.value=e,this.raw=t,this.regex={pattern:r,flags:i}};t.RegexLiteral=Z;var ee=function(e){this.type=n.Syntax.RestElement,this.argument=e};t.RestElement=ee;var te=function(e){this.type=n.Syntax.ReturnStatement,this.argument=e};t.ReturnStatement=te;var re=function(e){this.type=n.Syntax.Program,this.body=e,this.sourceType="script"};t.Script=re;var ne=function(e){this.type=n.Syntax.SequenceExpression,this.expressions=e};t.SequenceExpression=ne;var ie=function(e){this.type=n.Syntax.SpreadElement,this.argument=e};t.SpreadElement=ie;var oe=function(e,t){this.type=n.Syntax.MemberExpression,this.computed=!1,this.object=e,this.property=t};t.StaticMemberExpression=oe;var ae=function(){this.type=n.Syntax.Super};t.Super=ae;var se=function(e,t){this.type=n.Syntax.SwitchCase,this.test=e,this.consequent=t};t.SwitchCase=se;var ue=function(e,t){this.type=n.Syntax.SwitchStatement,this.discriminant=e,this.cases=t};t.SwitchStatement=ue;var le=function(e,t){this.type=n.Syntax.TaggedTemplateExpression,this.tag=e,this.quasi=t};t.TaggedTemplateExpression=le;var ce=function(e,t){this.type=n.Syntax.TemplateElement,this.value=e,this.tail=t};t.TemplateElement=ce;var he=function(e,t){this.type=n.Syntax.TemplateLiteral,this.quasis=e,this.expressions=t};t.TemplateLiteral=he;var pe=function(){this.type=n.Syntax.ThisExpression};t.ThisExpression=pe;var fe=function(e){this.type=n.Syntax.ThrowStatement,this.argument=e};t.ThrowStatement=fe;var de=function(e,t,r){this.type=n.Syntax.TryStatement,this.block=e,this.handler=t,this.finalizer=r};t.TryStatement=de;var me=function(e,t){this.type=n.Syntax.UnaryExpression,this.operator=e,this.argument=t,this.prefix=!0};t.UnaryExpression=me;var ye=function(e,t,r){this.type=n.Syntax.UpdateExpression,this.operator=e,this.argument=t,this.prefix=r};t.UpdateExpression=ye;var ve=function(e,t){this.type=n.Syntax.VariableDeclaration,this.declarations=e,this.kind=t};t.VariableDeclaration=ve;var _e=function(e,t){this.type=n.Syntax.VariableDeclarator,this.id=e,this.init=t};t.VariableDeclarator=_e;var ge=function(e,t){this.type=n.Syntax.WhileStatement,this.test=e,this.body=t};t.WhileStatement=ge;var be=function(e,t){this.type=n.Syntax.WithStatement,this.object=e,this.body=t};t.WithStatement=be;var xe=function(e,t){this.type=n.Syntax.YieldExpression,this.argument=e,this.delegate=t};t.YieldExpression=xe},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(9),i=r(10),o=r(11),a=r(7),s=r(12),u=r(2),l=r(13),c=function(){function e(e,t,r){void 0===t&&(t={}),this.config={range:"boolean"==typeof t.range&&t.range,loc:"boolean"==typeof t.loc&&t.loc,source:null,tokens:"boolean"==typeof t.tokens&&t.tokens,comment:"boolean"==typeof t.comment&&t.comment,tolerant:"boolean"==typeof t.tolerant&&t.tolerant},this.config.loc&&t.source&&null!==t.source&&(this.config.source=String(t.source)),this.delegate=r,this.errorHandler=new i.ErrorHandler,this.errorHandler.tolerant=this.config.tolerant,this.scanner=new s.Scanner(e,this.errorHandler),this.scanner.trackComment=this.config.comment,this.operatorPrecedence={")":0,";":0,",":0,"=":0,"]":0,"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":11,"/":11,"%":11},this.lookahead={type:2,value:"",lineNumber:this.scanner.lineNumber,lineStart:0,start:0,end:0},this.hasLineTerminator=!1,this.context={isModule:!1,await:!1,allowIn:!0,allowStrictDirective:!0,allowYield:!0,firstCoverInitializedNameError:null,isAssignmentTarget:!1,isBindingElement:!1,inFunctionBody:!1,inIteration:!1,inSwitch:!1,labelSet:{},strict:!1},this.tokens=[],this.startMarker={index:0,line:this.scanner.lineNumber,column:0},this.lastMarker={index:0,line:this.scanner.lineNumber,column:0},this.nextToken(),this.lastMarker={index:this.scanner.index,line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart}}return e.prototype.throwError=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var i=Array.prototype.slice.call(arguments,1),o=e.replace(/%(\d)/g,(function(e,t){return n.assert(t<i.length,"Message reference must be in range"),i[t]})),a=this.lastMarker.index,s=this.lastMarker.line,u=this.lastMarker.column+1;throw this.errorHandler.createError(a,s,u,o)},e.prototype.tolerateError=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var i=Array.prototype.slice.call(arguments,1),o=e.replace(/%(\d)/g,(function(e,t){return n.assert(t<i.length,"Message reference must be in range"),i[t]})),a=this.lastMarker.index,s=this.scanner.lineNumber,u=this.lastMarker.column+1;this.errorHandler.tolerateError(a,s,u,o)},e.prototype.unexpectedTokenError=function(e,t){var r,n=t||o.Messages.UnexpectedToken;if(e?(t||(n=2===e.type?o.Messages.UnexpectedEOS:3===e.type?o.Messages.UnexpectedIdentifier:6===e.type?o.Messages.UnexpectedNumber:8===e.type?o.Messages.UnexpectedString:10===e.type?o.Messages.UnexpectedTemplate:o.Messages.UnexpectedToken,4===e.type&&(this.scanner.isFutureReservedWord(e.value)?n=o.Messages.UnexpectedReserved:this.context.strict&&this.scanner.isStrictModeReservedWord(e.value)&&(n=o.Messages.StrictReservedWord))),r=e.value):r="ILLEGAL",n=n.replace("%0",r),e&&"number"==typeof e.lineNumber){var i=e.start,a=e.lineNumber,s=this.lastMarker.index-this.lastMarker.column,u=e.start-s+1;return this.errorHandler.createError(i,a,u,n)}return i=this.lastMarker.index,a=this.lastMarker.line,u=this.lastMarker.column+1,this.errorHandler.createError(i,a,u,n)},e.prototype.throwUnexpectedToken=function(e,t){throw this.unexpectedTokenError(e,t)},e.prototype.tolerateUnexpectedToken=function(e,t){this.errorHandler.tolerate(this.unexpectedTokenError(e,t))},e.prototype.collectComments=function(){if(this.config.comment){var e=this.scanner.scanComments();if(e.length>0&&this.delegate)for(var t=0;t<e.length;++t){var r=e[t],n=void 0;n={type:r.multiLine?"BlockComment":"LineComment",value:this.scanner.source.slice(r.slice[0],r.slice[1])},this.config.range&&(n.range=r.range),this.config.loc&&(n.loc=r.loc);var i={start:{line:r.loc.start.line,column:r.loc.start.column,offset:r.range[0]},end:{line:r.loc.end.line,column:r.loc.end.column,offset:r.range[1]}};this.delegate(n,i)}}else this.scanner.scanComments()},e.prototype.getTokenRaw=function(e){return this.scanner.source.slice(e.start,e.end)},e.prototype.convertToken=function(e){var t={type:l.TokenName[e.type],value:this.getTokenRaw(e)};if(this.config.range&&(t.range=[e.start,e.end]),this.config.loc&&(t.loc={start:{line:this.startMarker.line,column:this.startMarker.column},end:{line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart}}),9===e.type){var r=e.pattern,n=e.flags;t.regex={pattern:r,flags:n}}return t},e.prototype.nextToken=function(){var e=this.lookahead;this.lastMarker.index=this.scanner.index,this.lastMarker.line=this.scanner.lineNumber,this.lastMarker.column=this.scanner.index-this.scanner.lineStart,this.collectComments(),this.scanner.index!==this.startMarker.index&&(this.startMarker.index=this.scanner.index,this.startMarker.line=this.scanner.lineNumber,this.startMarker.column=this.scanner.index-this.scanner.lineStart);var t=this.scanner.lex();return this.hasLineTerminator=e.lineNumber!==t.lineNumber,t&&this.context.strict&&3===t.type&&this.scanner.isStrictModeReservedWord(t.value)&&(t.type=4),this.lookahead=t,this.config.tokens&&2!==t.type&&this.tokens.push(this.convertToken(t)),e},e.prototype.nextRegexToken=function(){this.collectComments();var e=this.scanner.scanRegExp();return this.config.tokens&&(this.tokens.pop(),this.tokens.push(this.convertToken(e))),this.lookahead=e,this.nextToken(),e},e.prototype.createNode=function(){return{index:this.startMarker.index,line:this.startMarker.line,column:this.startMarker.column}},e.prototype.startNode=function(e,t){void 0===t&&(t=0);var r=e.start-e.lineStart,n=e.lineNumber;return r<0&&(r+=t,n--),{index:e.start,line:n,column:r}},e.prototype.finalize=function(e,t){if(this.config.range&&(t.range=[e.index,this.lastMarker.index]),this.config.loc&&(t.loc={start:{line:e.line,column:e.column},end:{line:this.lastMarker.line,column:this.lastMarker.column}},this.config.source&&(t.loc.source=this.config.source)),this.delegate){var r={start:{line:e.line,column:e.column,offset:e.index},end:{line:this.lastMarker.line,column:this.lastMarker.column,offset:this.lastMarker.index}};this.delegate(t,r)}return t},e.prototype.expect=function(e){var t=this.nextToken();7===t.type&&t.value===e||this.throwUnexpectedToken(t)},e.prototype.expectCommaSeparator=function(){if(this.config.tolerant){var e=this.lookahead;7===e.type&&","===e.value?this.nextToken():7===e.type&&";"===e.value?(this.nextToken(),this.tolerateUnexpectedToken(e)):this.tolerateUnexpectedToken(e,o.Messages.UnexpectedToken)}else this.expect(",")},e.prototype.expectKeyword=function(e){var t=this.nextToken();4===t.type&&t.value===e||this.throwUnexpectedToken(t)},e.prototype.match=function(e){return 7===this.lookahead.type&&this.lookahead.value===e},e.prototype.matchKeyword=function(e){return 4===this.lookahead.type&&this.lookahead.value===e},e.prototype.matchContextualKeyword=function(e){return 3===this.lookahead.type&&this.lookahead.value===e},e.prototype.matchAssign=function(){if(7!==this.lookahead.type)return!1;var e=this.lookahead.value;return"="===e||"*="===e||"**="===e||"/="===e||"%="===e||"+="===e||"-="===e||"<<="===e||">>="===e||">>>="===e||"&="===e||"^="===e||"|="===e},e.prototype.isolateCoverGrammar=function(e){var t=this.context.isBindingElement,r=this.context.isAssignmentTarget,n=this.context.firstCoverInitializedNameError;this.context.isBindingElement=!0,this.context.isAssignmentTarget=!0,this.context.firstCoverInitializedNameError=null;var i=e.call(this);return null!==this.context.firstCoverInitializedNameError&&this.throwUnexpectedToken(this.context.firstCoverInitializedNameError),this.context.isBindingElement=t,this.context.isAssignmentTarget=r,this.context.firstCoverInitializedNameError=n,i},e.prototype.inheritCoverGrammar=function(e){var t=this.context.isBindingElement,r=this.context.isAssignmentTarget,n=this.context.firstCoverInitializedNameError;this.context.isBindingElement=!0,this.context.isAssignmentTarget=!0,this.context.firstCoverInitializedNameError=null;var i=e.call(this);return this.context.isBindingElement=this.context.isBindingElement&&t,this.context.isAssignmentTarget=this.context.isAssignmentTarget&&r,this.context.firstCoverInitializedNameError=n||this.context.firstCoverInitializedNameError,i},e.prototype.consumeSemicolon=function(){this.match(";")?this.nextToken():this.hasLineTerminator||(2===this.lookahead.type||this.match("}")||this.throwUnexpectedToken(this.lookahead),this.lastMarker.index=this.startMarker.index,this.lastMarker.line=this.startMarker.line,this.lastMarker.column=this.startMarker.column)},e.prototype.parsePrimaryExpression=function(){var e,t,r,n=this.createNode();switch(this.lookahead.type){case 3:(this.context.isModule||this.context.await)&&"await"===this.lookahead.value&&this.tolerateUnexpectedToken(this.lookahead),e=this.matchAsyncFunction()?this.parseFunctionExpression():this.finalize(n,new a.Identifier(this.nextToken().value));break;case 6:case 8:this.context.strict&&this.lookahead.octal&&this.tolerateUnexpectedToken(this.lookahead,o.Messages.StrictOctalLiteral),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,t=this.nextToken(),r=this.getTokenRaw(t),e=this.finalize(n,new a.Literal(t.value,r));break;case 1:this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,t=this.nextToken(),r=this.getTokenRaw(t),e=this.finalize(n,new a.Literal("true"===t.value,r));break;case 5:this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,t=this.nextToken(),r=this.getTokenRaw(t),e=this.finalize(n,new a.Literal(null,r));break;case 10:e=this.parseTemplateLiteral();break;case 7:switch(this.lookahead.value){case"(":this.context.isBindingElement=!1,e=this.inheritCoverGrammar(this.parseGroupExpression);break;case"[":e=this.inheritCoverGrammar(this.parseArrayInitializer);break;case"{":e=this.inheritCoverGrammar(this.parseObjectInitializer);break;case"/":case"/=":this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,this.scanner.index=this.startMarker.index,t=this.nextRegexToken(),r=this.getTokenRaw(t),e=this.finalize(n,new a.RegexLiteral(t.regex,r,t.pattern,t.flags));break;default:e=this.throwUnexpectedToken(this.nextToken())}break;case 4:!this.context.strict&&this.context.allowYield&&this.matchKeyword("yield")?e=this.parseIdentifierName():!this.context.strict&&this.matchKeyword("let")?e=this.finalize(n,new a.Identifier(this.nextToken().value)):(this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,this.matchKeyword("function")?e=this.parseFunctionExpression():this.matchKeyword("this")?(this.nextToken(),e=this.finalize(n,new a.ThisExpression)):e=this.matchKeyword("class")?this.parseClassExpression():this.throwUnexpectedToken(this.nextToken()));break;default:e=this.throwUnexpectedToken(this.nextToken())}return e},e.prototype.parseSpreadElement=function(){var e=this.createNode();this.expect("...");var t=this.inheritCoverGrammar(this.parseAssignmentExpression);return this.finalize(e,new a.SpreadElement(t))},e.prototype.parseArrayInitializer=function(){var e=this.createNode(),t=[];for(this.expect("[");!this.match("]");)if(this.match(","))this.nextToken(),t.push(null);else if(this.match("...")){var r=this.parseSpreadElement();this.match("]")||(this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1,this.expect(",")),t.push(r)}else t.push(this.inheritCoverGrammar(this.parseAssignmentExpression)),this.match("]")||this.expect(",");return this.expect("]"),this.finalize(e,new a.ArrayExpression(t))},e.prototype.parsePropertyMethod=function(e){this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1;var t=this.context.strict,r=this.context.allowStrictDirective;this.context.allowStrictDirective=e.simple;var n=this.isolateCoverGrammar(this.parseFunctionSourceElements);return this.context.strict&&e.firstRestricted&&this.tolerateUnexpectedToken(e.firstRestricted,e.message),this.context.strict&&e.stricted&&this.tolerateUnexpectedToken(e.stricted,e.message),this.context.strict=t,this.context.allowStrictDirective=r,n},e.prototype.parsePropertyMethodFunction=function(){var e=this.createNode(),t=this.context.allowYield;this.context.allowYield=!0;var r=this.parseFormalParameters(),n=this.parsePropertyMethod(r);return this.context.allowYield=t,this.finalize(e,new a.FunctionExpression(null,r.params,n,!1))},e.prototype.parsePropertyMethodAsyncFunction=function(){var e=this.createNode(),t=this.context.allowYield,r=this.context.await;this.context.allowYield=!1,this.context.await=!0;var n=this.parseFormalParameters(),i=this.parsePropertyMethod(n);return this.context.allowYield=t,this.context.await=r,this.finalize(e,new a.AsyncFunctionExpression(null,n.params,i))},e.prototype.parseObjectPropertyKey=function(){var e,t=this.createNode(),r=this.nextToken();switch(r.type){case 8:case 6:this.context.strict&&r.octal&&this.tolerateUnexpectedToken(r,o.Messages.StrictOctalLiteral);var n=this.getTokenRaw(r);e=this.finalize(t,new a.Literal(r.value,n));break;case 3:case 1:case 5:case 4:e=this.finalize(t,new a.Identifier(r.value));break;case 7:"["===r.value?(e=this.isolateCoverGrammar(this.parseAssignmentExpression),this.expect("]")):e=this.throwUnexpectedToken(r);break;default:e=this.throwUnexpectedToken(r)}return e},e.prototype.isPropertyKey=function(e,t){return e.type===u.Syntax.Identifier&&e.name===t||e.type===u.Syntax.Literal&&e.value===t},e.prototype.parseObjectProperty=function(e){var t,r=this.createNode(),n=this.lookahead,i=null,s=null,u=!1,l=!1,c=!1,h=!1;if(3===n.type){var p=n.value;this.nextToken(),u=this.match("["),i=(h=!(this.hasLineTerminator||"async"!==p||this.match(":")||this.match("(")||this.match("*")||this.match(",")))?this.parseObjectPropertyKey():this.finalize(r,new a.Identifier(p))}else this.match("*")?this.nextToken():(u=this.match("["),i=this.parseObjectPropertyKey());var f=this.qualifiedPropertyName(this.lookahead);if(3===n.type&&!h&&"get"===n.value&&f)t="get",u=this.match("["),i=this.parseObjectPropertyKey(),this.context.allowYield=!1,s=this.parseGetterMethod();else if(3===n.type&&!h&&"set"===n.value&&f)t="set",u=this.match("["),i=this.parseObjectPropertyKey(),s=this.parseSetterMethod();else if(7===n.type&&"*"===n.value&&f)t="init",u=this.match("["),i=this.parseObjectPropertyKey(),s=this.parseGeneratorMethod(),l=!0;else if(i||this.throwUnexpectedToken(this.lookahead),t="init",this.match(":")&&!h)!u&&this.isPropertyKey(i,"__proto__")&&(e.value&&this.tolerateError(o.Messages.DuplicateProtoProperty),e.value=!0),this.nextToken(),s=this.inheritCoverGrammar(this.parseAssignmentExpression);else if(this.match("("))s=h?this.parsePropertyMethodAsyncFunction():this.parsePropertyMethodFunction(),l=!0;else if(3===n.type)if(p=this.finalize(r,new a.Identifier(n.value)),this.match("=")){this.context.firstCoverInitializedNameError=this.lookahead,this.nextToken(),c=!0;var d=this.isolateCoverGrammar(this.parseAssignmentExpression);s=this.finalize(r,new a.AssignmentPattern(p,d))}else c=!0,s=p;else this.throwUnexpectedToken(this.nextToken());return this.finalize(r,new a.Property(t,i,u,s,l,c))},e.prototype.parseObjectInitializer=function(){var e=this.createNode();this.expect("{");for(var t=[],r={value:!1};!this.match("}");)t.push(this.parseObjectProperty(r)),this.match("}")||this.expectCommaSeparator();return this.expect("}"),this.finalize(e,new a.ObjectExpression(t))},e.prototype.parseTemplateHead=function(){n.assert(this.lookahead.head,"Template literal must start with a template head");var e=this.createNode(),t=this.nextToken(),r=t.value,i=t.cooked;return this.finalize(e,new a.TemplateElement({raw:r,cooked:i},t.tail))},e.prototype.parseTemplateElement=function(){10!==this.lookahead.type&&this.throwUnexpectedToken();var e=this.createNode(),t=this.nextToken(),r=t.value,n=t.cooked;return this.finalize(e,new a.TemplateElement({raw:r,cooked:n},t.tail))},e.prototype.parseTemplateLiteral=function(){var e=this.createNode(),t=[],r=[],n=this.parseTemplateHead();for(r.push(n);!n.tail;)t.push(this.parseExpression()),n=this.parseTemplateElement(),r.push(n);return this.finalize(e,new a.TemplateLiteral(r,t))},e.prototype.reinterpretExpressionAsPattern=function(e){switch(e.type){case u.Syntax.Identifier:case u.Syntax.MemberExpression:case u.Syntax.RestElement:case u.Syntax.AssignmentPattern:break;case u.Syntax.SpreadElement:e.type=u.Syntax.RestElement,this.reinterpretExpressionAsPattern(e.argument);break;case u.Syntax.ArrayExpression:e.type=u.Syntax.ArrayPattern;for(var t=0;t<e.elements.length;t++)null!==e.elements[t]&&this.reinterpretExpressionAsPattern(e.elements[t]);break;case u.Syntax.ObjectExpression:for(e.type=u.Syntax.ObjectPattern,t=0;t<e.properties.length;t++)this.reinterpretExpressionAsPattern(e.properties[t].value);break;case u.Syntax.AssignmentExpression:e.type=u.Syntax.AssignmentPattern,delete e.operator,this.reinterpretExpressionAsPattern(e.left)}},e.prototype.parseGroupExpression=function(){var e;if(this.expect("("),this.match(")"))this.nextToken(),this.match("=>")||this.expect("=>"),e={type:"ArrowParameterPlaceHolder",params:[],async:!1};else{var t=this.lookahead,r=[];if(this.match("..."))e=this.parseRestElement(r),this.expect(")"),this.match("=>")||this.expect("=>"),e={type:"ArrowParameterPlaceHolder",params:[e],async:!1};else{var n=!1;if(this.context.isBindingElement=!0,e=this.inheritCoverGrammar(this.parseAssignmentExpression),this.match(",")){var i=[];for(this.context.isAssignmentTarget=!1,i.push(e);2!==this.lookahead.type&&this.match(",");){if(this.nextToken(),this.match(")")){this.nextToken();for(var o=0;o<i.length;o++)this.reinterpretExpressionAsPattern(i[o]);n=!0,e={type:"ArrowParameterPlaceHolder",params:i,async:!1}}else if(this.match("...")){for(this.context.isBindingElement||this.throwUnexpectedToken(this.lookahead),i.push(this.parseRestElement(r)),this.expect(")"),this.match("=>")||this.expect("=>"),this.context.isBindingElement=!1,o=0;o<i.length;o++)this.reinterpretExpressionAsPattern(i[o]);n=!0,e={type:"ArrowParameterPlaceHolder",params:i,async:!1}}else i.push(this.inheritCoverGrammar(this.parseAssignmentExpression));if(n)break}n||(e=this.finalize(this.startNode(t),new a.SequenceExpression(i)))}if(!n){if(this.expect(")"),this.match("=>")&&(e.type===u.Syntax.Identifier&&"yield"===e.name&&(n=!0,e={type:"ArrowParameterPlaceHolder",params:[e],async:!1}),!n)){if(this.context.isBindingElement||this.throwUnexpectedToken(this.lookahead),e.type===u.Syntax.SequenceExpression)for(o=0;o<e.expressions.length;o++)this.reinterpretExpressionAsPattern(e.expressions[o]);else this.reinterpretExpressionAsPattern(e);e={type:"ArrowParameterPlaceHolder",params:e.type===u.Syntax.SequenceExpression?e.expressions:[e],async:!1}}this.context.isBindingElement=!1}}}return e},e.prototype.parseArguments=function(){this.expect("(");var e=[];if(!this.match(")"))for(;;){var t=this.match("...")?this.parseSpreadElement():this.isolateCoverGrammar(this.parseAssignmentExpression);if(e.push(t),this.match(")"))break;if(this.expectCommaSeparator(),this.match(")"))break}return this.expect(")"),e},e.prototype.isIdentifierName=function(e){return 3===e.type||4===e.type||1===e.type||5===e.type},e.prototype.parseIdentifierName=function(){var e=this.createNode(),t=this.nextToken();return this.isIdentifierName(t)||this.throwUnexpectedToken(t),this.finalize(e,new a.Identifier(t.value))},e.prototype.parseNewExpression=function(){var e,t=this.createNode(),r=this.parseIdentifierName();if(n.assert("new"===r.name,"New expression must start with `new`"),this.match("."))if(this.nextToken(),3===this.lookahead.type&&this.context.inFunctionBody&&"target"===this.lookahead.value){var i=this.parseIdentifierName();e=new a.MetaProperty(r,i)}else this.throwUnexpectedToken(this.lookahead);else{var o=this.isolateCoverGrammar(this.parseLeftHandSideExpression),s=this.match("(")?this.parseArguments():[];e=new a.NewExpression(o,s),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1}return this.finalize(t,e)},e.prototype.parseAsyncArgument=function(){var e=this.parseAssignmentExpression();return this.context.firstCoverInitializedNameError=null,e},e.prototype.parseAsyncArguments=function(){this.expect("(");var e=[];if(!this.match(")"))for(;;){var t=this.match("...")?this.parseSpreadElement():this.isolateCoverGrammar(this.parseAsyncArgument);if(e.push(t),this.match(")"))break;if(this.expectCommaSeparator(),this.match(")"))break}return this.expect(")"),e},e.prototype.parseLeftHandSideExpressionAllowCall=function(){var e,t=this.lookahead,r=this.matchContextualKeyword("async"),n=this.context.allowIn;for(this.context.allowIn=!0,this.matchKeyword("super")&&this.context.inFunctionBody?(e=this.createNode(),this.nextToken(),e=this.finalize(e,new a.Super),this.match("(")||this.match(".")||this.match("[")||this.throwUnexpectedToken(this.lookahead)):e=this.inheritCoverGrammar(this.matchKeyword("new")?this.parseNewExpression:this.parsePrimaryExpression);;)if(this.match(".")){this.context.isBindingElement=!1,this.context.isAssignmentTarget=!0,this.expect(".");var i=this.parseIdentifierName();e=this.finalize(this.startNode(t),new a.StaticMemberExpression(e,i))}else if(this.match("(")){var o=r&&t.lineNumber===this.lookahead.lineNumber;this.context.isBindingElement=!1,this.context.isAssignmentTarget=!1;var s=o?this.parseAsyncArguments():this.parseArguments();if(e=this.finalize(this.startNode(t),new a.CallExpression(e,s)),o&&this.match("=>")){for(var u=0;u<s.length;++u)this.reinterpretExpressionAsPattern(s[u]);e={type:"ArrowParameterPlaceHolder",params:s,async:!0}}}else if(this.match("["))this.context.isBindingElement=!1,this.context.isAssignmentTarget=!0,this.expect("["),i=this.isolateCoverGrammar(this.parseExpression),this.expect("]"),e=this.finalize(this.startNode(t),new a.ComputedMemberExpression(e,i));else{if(10!==this.lookahead.type||!this.lookahead.head)break;var l=this.parseTemplateLiteral();e=this.finalize(this.startNode(t),new a.TaggedTemplateExpression(e,l))}return this.context.allowIn=n,e},e.prototype.parseSuper=function(){var e=this.createNode();return this.expectKeyword("super"),this.match("[")||this.match(".")||this.throwUnexpectedToken(this.lookahead),this.finalize(e,new a.Super)},e.prototype.parseLeftHandSideExpression=function(){n.assert(this.context.allowIn,"callee of new expression always allow in keyword.");for(var e=this.startNode(this.lookahead),t=this.matchKeyword("super")&&this.context.inFunctionBody?this.parseSuper():this.inheritCoverGrammar(this.matchKeyword("new")?this.parseNewExpression:this.parsePrimaryExpression);;)if(this.match("[")){this.context.isBindingElement=!1,this.context.isAssignmentTarget=!0,this.expect("[");var r=this.isolateCoverGrammar(this.parseExpression);this.expect("]"),t=this.finalize(e,new a.ComputedMemberExpression(t,r))}else if(this.match("."))this.context.isBindingElement=!1,this.context.isAssignmentTarget=!0,this.expect("."),r=this.parseIdentifierName(),t=this.finalize(e,new a.StaticMemberExpression(t,r));else{if(10!==this.lookahead.type||!this.lookahead.head)break;var i=this.parseTemplateLiteral();t=this.finalize(e,new a.TaggedTemplateExpression(t,i))}return t},e.prototype.parseUpdateExpression=function(){var e,t=this.lookahead;if(this.match("++")||this.match("--")){var r=this.startNode(t),n=this.nextToken();e=this.inheritCoverGrammar(this.parseUnaryExpression),this.context.strict&&e.type===u.Syntax.Identifier&&this.scanner.isRestrictedWord(e.name)&&this.tolerateError(o.Messages.StrictLHSPrefix),this.context.isAssignmentTarget||this.tolerateError(o.Messages.InvalidLHSInAssignment);var i=!0;e=this.finalize(r,new a.UpdateExpression(n.value,e,i)),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1}else if(e=this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall),!this.hasLineTerminator&&7===this.lookahead.type&&(this.match("++")||this.match("--"))){this.context.strict&&e.type===u.Syntax.Identifier&&this.scanner.isRestrictedWord(e.name)&&this.tolerateError(o.Messages.StrictLHSPostfix),this.context.isAssignmentTarget||this.tolerateError(o.Messages.InvalidLHSInAssignment),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1;var s=this.nextToken().value;i=!1,e=this.finalize(this.startNode(t),new a.UpdateExpression(s,e,i))}return e},e.prototype.parseAwaitExpression=function(){var e=this.createNode();this.nextToken();var t=this.parseUnaryExpression();return this.finalize(e,new a.AwaitExpression(t))},e.prototype.parseUnaryExpression=function(){var e;if(this.match("+")||this.match("-")||this.match("~")||this.match("!")||this.matchKeyword("delete")||this.matchKeyword("void")||this.matchKeyword("typeof")){var t=this.startNode(this.lookahead),r=this.nextToken();e=this.inheritCoverGrammar(this.parseUnaryExpression),e=this.finalize(t,new a.UnaryExpression(r.value,e)),this.context.strict&&"delete"===e.operator&&e.argument.type===u.Syntax.Identifier&&this.tolerateError(o.Messages.StrictDelete),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1}else e=this.context.await&&this.matchContextualKeyword("await")?this.parseAwaitExpression():this.parseUpdateExpression();return e},e.prototype.parseExponentiationExpression=function(){var e=this.lookahead,t=this.inheritCoverGrammar(this.parseUnaryExpression);if(t.type!==u.Syntax.UnaryExpression&&this.match("**")){this.nextToken(),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1;var r=t,n=this.isolateCoverGrammar(this.parseExponentiationExpression);t=this.finalize(this.startNode(e),new a.BinaryExpression("**",r,n))}return t},e.prototype.binaryPrecedence=function(e){var t=e.value;return 7===e.type?this.operatorPrecedence[t]||0:4===e.type&&("instanceof"===t||this.context.allowIn&&"in"===t)?7:0},e.prototype.parseBinaryExpression=function(){var e=this.lookahead,t=this.inheritCoverGrammar(this.parseExponentiationExpression),r=this.lookahead,n=this.binaryPrecedence(r);if(n>0){this.nextToken(),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1;for(var i=[e,this.lookahead],o=t,s=this.isolateCoverGrammar(this.parseExponentiationExpression),u=[o,r.value,s],l=[n];!((n=this.binaryPrecedence(this.lookahead))<=0);){for(;u.length>2&&n<=l[l.length-1];){s=u.pop();var c=u.pop();l.pop(),o=u.pop(),i.pop();var h=this.startNode(i[i.length-1]);u.push(this.finalize(h,new a.BinaryExpression(c,o,s)))}u.push(this.nextToken().value),l.push(n),i.push(this.lookahead),u.push(this.isolateCoverGrammar(this.parseExponentiationExpression))}var p=u.length-1;t=u[p];for(var f=i.pop();p>1;){var d=i.pop(),m=f&&f.lineStart;h=this.startNode(d,m),c=u[p-1],t=this.finalize(h,new a.BinaryExpression(c,u[p-2],t)),p-=2,f=d}}return t},e.prototype.parseConditionalExpression=function(){var e=this.lookahead,t=this.inheritCoverGrammar(this.parseBinaryExpression);if(this.match("?")){this.nextToken();var r=this.context.allowIn;this.context.allowIn=!0;var n=this.isolateCoverGrammar(this.parseAssignmentExpression);this.context.allowIn=r,this.expect(":");var i=this.isolateCoverGrammar(this.parseAssignmentExpression);t=this.finalize(this.startNode(e),new a.ConditionalExpression(t,n,i)),this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1}return t},e.prototype.checkPatternParam=function(e,t){switch(t.type){case u.Syntax.Identifier:this.validateParam(e,t,t.name);break;case u.Syntax.RestElement:this.checkPatternParam(e,t.argument);break;case u.Syntax.AssignmentPattern:this.checkPatternParam(e,t.left);break;case u.Syntax.ArrayPattern:for(var r=0;r<t.elements.length;r++)null!==t.elements[r]&&this.checkPatternParam(e,t.elements[r]);break;case u.Syntax.ObjectPattern:for(r=0;r<t.properties.length;r++)this.checkPatternParam(e,t.properties[r].value)}e.simple=e.simple&&t instanceof a.Identifier},e.prototype.reinterpretAsCoverFormalsList=function(e){var t,r=[e],n=!1;switch(e.type){case u.Syntax.Identifier:break;case"ArrowParameterPlaceHolder":r=e.params,n=e.async;break;default:return null}t={simple:!0,paramSet:{}};for(var i=0;i<r.length;++i)(a=r[i]).type===u.Syntax.AssignmentPattern?a.right.type===u.Syntax.YieldExpression&&(a.right.argument&&this.throwUnexpectedToken(this.lookahead),a.right.type=u.Syntax.Identifier,a.right.name="yield",delete a.right.argument,delete a.right.delegate):n&&a.type===u.Syntax.Identifier&&"await"===a.name&&this.throwUnexpectedToken(this.lookahead),this.checkPatternParam(t,a),r[i]=a;if(this.context.strict||!this.context.allowYield)for(i=0;i<r.length;++i){var a;(a=r[i]).type===u.Syntax.YieldExpression&&this.throwUnexpectedToken(this.lookahead)}if(t.message===o.Messages.StrictParamDupe){var s=this.context.strict?t.stricted:t.firstRestricted;this.throwUnexpectedToken(s,t.message)}return{simple:t.simple,params:r,stricted:t.stricted,firstRestricted:t.firstRestricted,message:t.message}},e.prototype.parseAssignmentExpression=function(){var e;if(!this.context.allowYield&&this.matchKeyword("yield"))e=this.parseYieldExpression();else{var t=this.lookahead,r=t;if(e=this.parseConditionalExpression(),3===r.type&&r.lineNumber===this.lookahead.lineNumber&&"async"===r.value&&(3===this.lookahead.type||this.matchKeyword("yield"))){var n=this.parsePrimaryExpression();this.reinterpretExpressionAsPattern(n),e={type:"ArrowParameterPlaceHolder",params:[n],async:!0}}if("ArrowParameterPlaceHolder"===e.type||this.match("=>")){this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1;var i=e.async,s=this.reinterpretAsCoverFormalsList(e);if(s){this.hasLineTerminator&&this.tolerateUnexpectedToken(this.lookahead),this.context.firstCoverInitializedNameError=null;var l=this.context.strict,c=this.context.allowStrictDirective;this.context.allowStrictDirective=s.simple;var h=this.context.allowYield,p=this.context.await;this.context.allowYield=!0,this.context.await=i;var f=this.startNode(t);this.expect("=>");var d=void 0;if(this.match("{")){var m=this.context.allowIn;this.context.allowIn=!0,d=this.parseFunctionSourceElements(),this.context.allowIn=m}else d=this.isolateCoverGrammar(this.parseAssignmentExpression);var y=d.type!==u.Syntax.BlockStatement;this.context.strict&&s.firstRestricted&&this.throwUnexpectedToken(s.firstRestricted,s.message),this.context.strict&&s.stricted&&this.tolerateUnexpectedToken(s.stricted,s.message),e=i?this.finalize(f,new a.AsyncArrowFunctionExpression(s.params,d,y)):this.finalize(f,new a.ArrowFunctionExpression(s.params,d,y)),this.context.strict=l,this.context.allowStrictDirective=c,this.context.allowYield=h,this.context.await=p}}else if(this.matchAssign()){if(this.context.isAssignmentTarget||this.tolerateError(o.Messages.InvalidLHSInAssignment),this.context.strict&&e.type===u.Syntax.Identifier){var v=e;this.scanner.isRestrictedWord(v.name)&&this.tolerateUnexpectedToken(r,o.Messages.StrictLHSAssignment),this.scanner.isStrictModeReservedWord(v.name)&&this.tolerateUnexpectedToken(r,o.Messages.StrictReservedWord)}this.match("=")?this.reinterpretExpressionAsPattern(e):(this.context.isAssignmentTarget=!1,this.context.isBindingElement=!1);var _=(r=this.nextToken()).value,g=this.isolateCoverGrammar(this.parseAssignmentExpression);e=this.finalize(this.startNode(t),new a.AssignmentExpression(_,e,g)),this.context.firstCoverInitializedNameError=null}}return e},e.prototype.parseExpression=function(){var e=this.lookahead,t=this.isolateCoverGrammar(this.parseAssignmentExpression);if(this.match(",")){var r=[];for(r.push(t);2!==this.lookahead.type&&this.match(",");)this.nextToken(),r.push(this.isolateCoverGrammar(this.parseAssignmentExpression));t=this.finalize(this.startNode(e),new a.SequenceExpression(r))}return t},e.prototype.parseStatementListItem=function(){var e;if(this.context.isAssignmentTarget=!0,this.context.isBindingElement=!0,4===this.lookahead.type)switch(this.lookahead.value){case"export":this.context.isModule||this.tolerateUnexpectedToken(this.lookahead,o.Messages.IllegalExportDeclaration),e=this.parseExportDeclaration();break;case"import":this.context.isModule||this.tolerateUnexpectedToken(this.lookahead,o.Messages.IllegalImportDeclaration),e=this.parseImportDeclaration();break;case"const":e=this.parseLexicalDeclaration({inFor:!1});break;case"function":e=this.parseFunctionDeclaration();break;case"class":e=this.parseClassDeclaration();break;case"let":e=this.isLexicalDeclaration()?this.parseLexicalDeclaration({inFor:!1}):this.parseStatement();break;default:e=this.parseStatement()}else e=this.parseStatement();return e},e.prototype.parseBlock=function(){var e=this.createNode();this.expect("{");for(var t=[];!this.match("}");)t.push(this.parseStatementListItem());return this.expect("}"),this.finalize(e,new a.BlockStatement(t))},e.prototype.parseLexicalBinding=function(e,t){var r=this.createNode(),n=this.parsePattern([],e);this.context.strict&&n.type===u.Syntax.Identifier&&this.scanner.isRestrictedWord(n.name)&&this.tolerateError(o.Messages.StrictVarName);var i=null;return"const"===e?this.matchKeyword("in")||this.matchContextualKeyword("of")||(this.match("=")?(this.nextToken(),i=this.isolateCoverGrammar(this.parseAssignmentExpression)):this.throwError(o.Messages.DeclarationMissingInitializer,"const")):(!t.inFor&&n.type!==u.Syntax.Identifier||this.match("="))&&(this.expect("="),i=this.isolateCoverGrammar(this.parseAssignmentExpression)),this.finalize(r,new a.VariableDeclarator(n,i))},e.prototype.parseBindingList=function(e,t){for(var r=[this.parseLexicalBinding(e,t)];this.match(",");)this.nextToken(),r.push(this.parseLexicalBinding(e,t));return r},e.prototype.isLexicalDeclaration=function(){var e=this.scanner.saveState();this.scanner.scanComments();var t=this.scanner.lex();return this.scanner.restoreState(e),3===t.type||7===t.type&&"["===t.value||7===t.type&&"{"===t.value||4===t.type&&"let"===t.value||4===t.type&&"yield"===t.value},e.prototype.parseLexicalDeclaration=function(e){var t=this.createNode(),r=this.nextToken().value;n.assert("let"===r||"const"===r,"Lexical declaration must be either let or const");var i=this.parseBindingList(r,e);return this.consumeSemicolon(),this.finalize(t,new a.VariableDeclaration(i,r))},e.prototype.parseBindingRestElement=function(e,t){var r=this.createNode();this.expect("...");var n=this.parsePattern(e,t);return this.finalize(r,new a.RestElement(n))},e.prototype.parseArrayPattern=function(e,t){var r=this.createNode();this.expect("[");for(var n=[];!this.match("]");)if(this.match(","))this.nextToken(),n.push(null);else{if(this.match("...")){n.push(this.parseBindingRestElement(e,t));break}n.push(this.parsePatternWithDefault(e,t)),this.match("]")||this.expect(",")}return this.expect("]"),this.finalize(r,new a.ArrayPattern(n))},e.prototype.parsePropertyPattern=function(e,t){var r,n,i=this.createNode(),o=!1,s=!1;if(3===this.lookahead.type){var u=this.lookahead;r=this.parseVariableIdentifier();var l=this.finalize(i,new a.Identifier(u.value));if(this.match("=")){e.push(u),s=!0,this.nextToken();var c=this.parseAssignmentExpression();n=this.finalize(this.startNode(u),new a.AssignmentPattern(l,c))}else this.match(":")?(this.expect(":"),n=this.parsePatternWithDefault(e,t)):(e.push(u),s=!0,n=l)}else o=this.match("["),r=this.parseObjectPropertyKey(),this.expect(":"),n=this.parsePatternWithDefault(e,t);return this.finalize(i,new a.Property("init",r,o,n,!1,s))},e.prototype.parseObjectPattern=function(e,t){var r=this.createNode(),n=[];for(this.expect("{");!this.match("}");)n.push(this.parsePropertyPattern(e,t)),this.match("}")||this.expect(",");return this.expect("}"),this.finalize(r,new a.ObjectPattern(n))},e.prototype.parsePattern=function(e,t){var r;return this.match("[")?r=this.parseArrayPattern(e,t):this.match("{")?r=this.parseObjectPattern(e,t):(!this.matchKeyword("let")||"const"!==t&&"let"!==t||this.tolerateUnexpectedToken(this.lookahead,o.Messages.LetInLexicalBinding),e.push(this.lookahead),r=this.parseVariableIdentifier(t)),r},e.prototype.parsePatternWithDefault=function(e,t){var r=this.lookahead,n=this.parsePattern(e,t);if(this.match("=")){this.nextToken();var i=this.context.allowYield;this.context.allowYield=!0;var o=this.isolateCoverGrammar(this.parseAssignmentExpression);this.context.allowYield=i,n=this.finalize(this.startNode(r),new a.AssignmentPattern(n,o))}return n},e.prototype.parseVariableIdentifier=function(e){var t=this.createNode(),r=this.nextToken();return 4===r.type&&"yield"===r.value?this.context.strict?this.tolerateUnexpectedToken(r,o.Messages.StrictReservedWord):this.context.allowYield||this.throwUnexpectedToken(r):3!==r.type?this.context.strict&&4===r.type&&this.scanner.isStrictModeReservedWord(r.value)?this.tolerateUnexpectedToken(r,o.Messages.StrictReservedWord):(this.context.strict||"let"!==r.value||"var"!==e)&&this.throwUnexpectedToken(r):(this.context.isModule||this.context.await)&&3===r.type&&"await"===r.value&&this.tolerateUnexpectedToken(r),this.finalize(t,new a.Identifier(r.value))},e.prototype.parseVariableDeclaration=function(e){var t=this.createNode(),r=this.parsePattern([],"var");this.context.strict&&r.type===u.Syntax.Identifier&&this.scanner.isRestrictedWord(r.name)&&this.tolerateError(o.Messages.StrictVarName);var n=null;return this.match("=")?(this.nextToken(),n=this.isolateCoverGrammar(this.parseAssignmentExpression)):r.type===u.Syntax.Identifier||e.inFor||this.expect("="),this.finalize(t,new a.VariableDeclarator(r,n))},e.prototype.parseVariableDeclarationList=function(e){var t={inFor:e.inFor},r=[];for(r.push(this.parseVariableDeclaration(t));this.match(",");)this.nextToken(),r.push(this.parseVariableDeclaration(t));return r},e.prototype.parseVariableStatement=function(){var e=this.createNode();this.expectKeyword("var");var t=this.parseVariableDeclarationList({inFor:!1});return this.consumeSemicolon(),this.finalize(e,new a.VariableDeclaration(t,"var"))},e.prototype.parseEmptyStatement=function(){var e=this.createNode();return this.expect(";"),this.finalize(e,new a.EmptyStatement)},e.prototype.parseExpressionStatement=function(){var e=this.createNode(),t=this.parseExpression();return this.consumeSemicolon(),this.finalize(e,new a.ExpressionStatement(t))},e.prototype.parseIfClause=function(){return this.context.strict&&this.matchKeyword("function")&&this.tolerateError(o.Messages.StrictFunction),this.parseStatement()},e.prototype.parseIfStatement=function(){var e,t=this.createNode(),r=null;this.expectKeyword("if"),this.expect("(");var n=this.parseExpression();return!this.match(")")&&this.config.tolerant?(this.tolerateUnexpectedToken(this.nextToken()),e=this.finalize(this.createNode(),new a.EmptyStatement)):(this.expect(")"),e=this.parseIfClause(),this.matchKeyword("else")&&(this.nextToken(),r=this.parseIfClause())),this.finalize(t,new a.IfStatement(n,e,r))},e.prototype.parseDoWhileStatement=function(){var e=this.createNode();this.expectKeyword("do");var t=this.context.inIteration;this.context.inIteration=!0;var r=this.parseStatement();this.context.inIteration=t,this.expectKeyword("while"),this.expect("(");var n=this.parseExpression();return!this.match(")")&&this.config.tolerant?this.tolerateUnexpectedToken(this.nextToken()):(this.expect(")"),this.match(";")&&this.nextToken()),this.finalize(e,new a.DoWhileStatement(r,n))},e.prototype.parseWhileStatement=function(){var e,t=this.createNode();this.expectKeyword("while"),this.expect("(");var r=this.parseExpression();if(!this.match(")")&&this.config.tolerant)this.tolerateUnexpectedToken(this.nextToken()),e=this.finalize(this.createNode(),new a.EmptyStatement);else{this.expect(")");var n=this.context.inIteration;this.context.inIteration=!0,e=this.parseStatement(),this.context.inIteration=n}return this.finalize(t,new a.WhileStatement(r,e))},e.prototype.parseForStatement=function(){var e,t,r,n=null,i=null,s=null,l=!0,c=this.createNode();if(this.expectKeyword("for"),this.expect("("),this.match(";"))this.nextToken();else if(this.matchKeyword("var")){n=this.createNode(),this.nextToken();var h=this.context.allowIn;this.context.allowIn=!1;var p=this.parseVariableDeclarationList({inFor:!0});if(this.context.allowIn=h,1===p.length&&this.matchKeyword("in")){var f=p[0];f.init&&(f.id.type===u.Syntax.ArrayPattern||f.id.type===u.Syntax.ObjectPattern||this.context.strict)&&this.tolerateError(o.Messages.ForInOfLoopInitializer,"for-in"),n=this.finalize(n,new a.VariableDeclaration(p,"var")),this.nextToken(),e=n,t=this.parseExpression(),n=null}else 1===p.length&&null===p[0].init&&this.matchContextualKeyword("of")?(n=this.finalize(n,new a.VariableDeclaration(p,"var")),this.nextToken(),e=n,t=this.parseAssignmentExpression(),n=null,l=!1):(n=this.finalize(n,new a.VariableDeclaration(p,"var")),this.expect(";"))}else if(this.matchKeyword("const")||this.matchKeyword("let")){n=this.createNode();var d=this.nextToken().value;this.context.strict||"in"!==this.lookahead.value?(h=this.context.allowIn,this.context.allowIn=!1,p=this.parseBindingList(d,{inFor:!0}),this.context.allowIn=h,1===p.length&&null===p[0].init&&this.matchKeyword("in")?(n=this.finalize(n,new a.VariableDeclaration(p,d)),this.nextToken(),e=n,t=this.parseExpression(),n=null):1===p.length&&null===p[0].init&&this.matchContextualKeyword("of")?(n=this.finalize(n,new a.VariableDeclaration(p,d)),this.nextToken(),e=n,t=this.parseAssignmentExpression(),n=null,l=!1):(this.consumeSemicolon(),n=this.finalize(n,new a.VariableDeclaration(p,d)))):(n=this.finalize(n,new a.Identifier(d)),this.nextToken(),e=n,t=this.parseExpression(),n=null)}else{var m=this.lookahead;if(h=this.context.allowIn,this.context.allowIn=!1,n=this.inheritCoverGrammar(this.parseAssignmentExpression),this.context.allowIn=h,this.matchKeyword("in"))this.context.isAssignmentTarget&&n.type!==u.Syntax.AssignmentExpression||this.tolerateError(o.Messages.InvalidLHSInForIn),this.nextToken(),this.reinterpretExpressionAsPattern(n),e=n,t=this.parseExpression(),n=null;else if(this.matchContextualKeyword("of"))this.context.isAssignmentTarget&&n.type!==u.Syntax.AssignmentExpression||this.tolerateError(o.Messages.InvalidLHSInForLoop),this.nextToken(),this.reinterpretExpressionAsPattern(n),e=n,t=this.parseAssignmentExpression(),n=null,l=!1;else{if(this.match(",")){for(var y=[n];this.match(",");)this.nextToken(),y.push(this.isolateCoverGrammar(this.parseAssignmentExpression));n=this.finalize(this.startNode(m),new a.SequenceExpression(y))}this.expect(";")}}if(void 0===e&&(this.match(";")||(i=this.parseExpression()),this.expect(";"),this.match(")")||(s=this.parseExpression())),!this.match(")")&&this.config.tolerant)this.tolerateUnexpectedToken(this.nextToken()),r=this.finalize(this.createNode(),new a.EmptyStatement);else{this.expect(")");var v=this.context.inIteration;this.context.inIteration=!0,r=this.isolateCoverGrammar(this.parseStatement),this.context.inIteration=v}return void 0===e?this.finalize(c,new a.ForStatement(n,i,s,r)):l?this.finalize(c,new a.ForInStatement(e,t,r)):this.finalize(c,new a.ForOfStatement(e,t,r))},e.prototype.parseContinueStatement=function(){var e=this.createNode();this.expectKeyword("continue");var t=null;if(3===this.lookahead.type&&!this.hasLineTerminator){var r=this.parseVariableIdentifier();t=r;var n="$"+r.name;Object.prototype.hasOwnProperty.call(this.context.labelSet,n)||this.throwError(o.Messages.UnknownLabel,r.name)}return this.consumeSemicolon(),null!==t||this.context.inIteration||this.throwError(o.Messages.IllegalContinue),this.finalize(e,new a.ContinueStatement(t))},e.prototype.parseBreakStatement=function(){var e=this.createNode();this.expectKeyword("break");var t=null;if(3===this.lookahead.type&&!this.hasLineTerminator){var r=this.parseVariableIdentifier(),n="$"+r.name;Object.prototype.hasOwnProperty.call(this.context.labelSet,n)||this.throwError(o.Messages.UnknownLabel,r.name),t=r}return this.consumeSemicolon(),null!==t||this.context.inIteration||this.context.inSwitch||this.throwError(o.Messages.IllegalBreak),this.finalize(e,new a.BreakStatement(t))},e.prototype.parseReturnStatement=function(){this.context.inFunctionBody||this.tolerateError(o.Messages.IllegalReturn);var e=this.createNode();this.expectKeyword("return");var t=(this.match(";")||this.match("}")||this.hasLineTerminator||2===this.lookahead.type)&&8!==this.lookahead.type&&10!==this.lookahead.type?null:this.parseExpression();return this.consumeSemicolon(),this.finalize(e,new a.ReturnStatement(t))},e.prototype.parseWithStatement=function(){this.context.strict&&this.tolerateError(o.Messages.StrictModeWith);var e,t=this.createNode();this.expectKeyword("with"),this.expect("(");var r=this.parseExpression();return!this.match(")")&&this.config.tolerant?(this.tolerateUnexpectedToken(this.nextToken()),e=this.finalize(this.createNode(),new a.EmptyStatement)):(this.expect(")"),e=this.parseStatement()),this.finalize(t,new a.WithStatement(r,e))},e.prototype.parseSwitchCase=function(){var e,t=this.createNode();this.matchKeyword("default")?(this.nextToken(),e=null):(this.expectKeyword("case"),e=this.parseExpression()),this.expect(":");for(var r=[];!(this.match("}")||this.matchKeyword("default")||this.matchKeyword("case"));)r.push(this.parseStatementListItem());return this.finalize(t,new a.SwitchCase(e,r))},e.prototype.parseSwitchStatement=function(){var e=this.createNode();this.expectKeyword("switch"),this.expect("(");var t=this.parseExpression();this.expect(")");var r=this.context.inSwitch;this.context.inSwitch=!0;var n=[],i=!1;for(this.expect("{");!this.match("}");){var s=this.parseSwitchCase();null===s.test&&(i&&this.throwError(o.Messages.MultipleDefaultsInSwitch),i=!0),n.push(s)}return this.expect("}"),this.context.inSwitch=r,this.finalize(e,new a.SwitchStatement(t,n))},e.prototype.parseLabelledStatement=function(){var e,t=this.createNode(),r=this.parseExpression();if(r.type===u.Syntax.Identifier&&this.match(":")){this.nextToken();var n=r,i="$"+n.name;Object.prototype.hasOwnProperty.call(this.context.labelSet,i)&&this.throwError(o.Messages.Redeclaration,"Label",n.name),this.context.labelSet[i]=!0;var s=void 0;if(this.matchKeyword("class"))this.tolerateUnexpectedToken(this.lookahead),s=this.parseClassDeclaration();else if(this.matchKeyword("function")){var l=this.lookahead,c=this.parseFunctionDeclaration();this.context.strict?this.tolerateUnexpectedToken(l,o.Messages.StrictFunction):c.generator&&this.tolerateUnexpectedToken(l,o.Messages.GeneratorInLegacyContext),s=c}else s=this.parseStatement();delete this.context.labelSet[i],e=new a.LabeledStatement(n,s)}else this.consumeSemicolon(),e=new a.ExpressionStatement(r);return this.finalize(t,e)},e.prototype.parseThrowStatement=function(){var e=this.createNode();this.expectKeyword("throw"),this.hasLineTerminator&&this.throwError(o.Messages.NewlineAfterThrow);var t=this.parseExpression();return this.consumeSemicolon(),this.finalize(e,new a.ThrowStatement(t))},e.prototype.parseCatchClause=function(){var e=this.createNode();this.expectKeyword("catch"),this.expect("("),this.match(")")&&this.throwUnexpectedToken(this.lookahead);for(var t=[],r=this.parsePattern(t),n={},i=0;i<t.length;i++){var s="$"+t[i].value;Object.prototype.hasOwnProperty.call(n,s)&&this.tolerateError(o.Messages.DuplicateBinding,t[i].value),n[s]=!0}this.context.strict&&r.type===u.Syntax.Identifier&&this.scanner.isRestrictedWord(r.name)&&this.tolerateError(o.Messages.StrictCatchVariable),this.expect(")");var l=this.parseBlock();return this.finalize(e,new a.CatchClause(r,l))},e.prototype.parseFinallyClause=function(){return this.expectKeyword("finally"),this.parseBlock()},e.prototype.parseTryStatement=function(){var e=this.createNode();this.expectKeyword("try");var t=this.parseBlock(),r=this.matchKeyword("catch")?this.parseCatchClause():null,n=this.matchKeyword("finally")?this.parseFinallyClause():null;return r||n||this.throwError(o.Messages.NoCatchOrFinally),this.finalize(e,new a.TryStatement(t,r,n))},e.prototype.parseDebuggerStatement=function(){var e=this.createNode();return this.expectKeyword("debugger"),this.consumeSemicolon(),this.finalize(e,new a.DebuggerStatement)},e.prototype.parseStatement=function(){var e;switch(this.lookahead.type){case 1:case 5:case 6:case 8:case 10:case 9:e=this.parseExpressionStatement();break;case 7:var t=this.lookahead.value;e="{"===t?this.parseBlock():"("===t?this.parseExpressionStatement():";"===t?this.parseEmptyStatement():this.parseExpressionStatement();break;case 3:e=this.matchAsyncFunction()?this.parseFunctionDeclaration():this.parseLabelledStatement();break;case 4:switch(this.lookahead.value){case"break":e=this.parseBreakStatement();break;case"continue":e=this.parseContinueStatement();break;case"debugger":e=this.parseDebuggerStatement();break;case"do":e=this.parseDoWhileStatement();break;case"for":e=this.parseForStatement();break;case"function":e=this.parseFunctionDeclaration();break;case"if":e=this.parseIfStatement();break;case"return":e=this.parseReturnStatement();break;case"switch":e=this.parseSwitchStatement();break;case"throw":e=this.parseThrowStatement();break;case"try":e=this.parseTryStatement();break;case"var":e=this.parseVariableStatement();break;case"while":e=this.parseWhileStatement();break;case"with":e=this.parseWithStatement();break;default:e=this.parseExpressionStatement()}break;default:e=this.throwUnexpectedToken(this.lookahead)}return e},e.prototype.parseFunctionSourceElements=function(){var e=this.createNode();this.expect("{");var t=this.parseDirectivePrologues(),r=this.context.labelSet,n=this.context.inIteration,i=this.context.inSwitch,o=this.context.inFunctionBody;for(this.context.labelSet={},this.context.inIteration=!1,this.context.inSwitch=!1,this.context.inFunctionBody=!0;2!==this.lookahead.type&&!this.match("}");)t.push(this.parseStatementListItem());return this.expect("}"),this.context.labelSet=r,this.context.inIteration=n,this.context.inSwitch=i,this.context.inFunctionBody=o,this.finalize(e,new a.BlockStatement(t))},e.prototype.validateParam=function(e,t,r){var n="$"+r;this.context.strict?(this.scanner.isRestrictedWord(r)&&(e.stricted=t,e.message=o.Messages.StrictParamName),Object.prototype.hasOwnProperty.call(e.paramSet,n)&&(e.stricted=t,e.message=o.Messages.StrictParamDupe)):e.firstRestricted||(this.scanner.isRestrictedWord(r)?(e.firstRestricted=t,e.message=o.Messages.StrictParamName):this.scanner.isStrictModeReservedWord(r)?(e.firstRestricted=t,e.message=o.Messages.StrictReservedWord):Object.prototype.hasOwnProperty.call(e.paramSet,n)&&(e.stricted=t,e.message=o.Messages.StrictParamDupe)),"function"==typeof Object.defineProperty?Object.defineProperty(e.paramSet,n,{value:!0,enumerable:!0,writable:!0,configurable:!0}):e.paramSet[n]=!0},e.prototype.parseRestElement=function(e){var t=this.createNode();this.expect("...");var r=this.parsePattern(e);return this.match("=")&&this.throwError(o.Messages.DefaultRestParameter),this.match(")")||this.throwError(o.Messages.ParameterAfterRestParameter),this.finalize(t,new a.RestElement(r))},e.prototype.parseFormalParameter=function(e){for(var t=[],r=this.match("...")?this.parseRestElement(t):this.parsePatternWithDefault(t),n=0;n<t.length;n++)this.validateParam(e,t[n],t[n].value);e.simple=e.simple&&r instanceof a.Identifier,e.params.push(r)},e.prototype.parseFormalParameters=function(e){var t;if(t={simple:!0,params:[],firstRestricted:e},this.expect("("),!this.match(")"))for(t.paramSet={};2!==this.lookahead.type&&(this.parseFormalParameter(t),!this.match(")"))&&(this.expect(","),!this.match(")")););return this.expect(")"),{simple:t.simple,params:t.params,stricted:t.stricted,firstRestricted:t.firstRestricted,message:t.message}},e.prototype.matchAsyncFunction=function(){var e=this.matchContextualKeyword("async");if(e){var t=this.scanner.saveState();this.scanner.scanComments();var r=this.scanner.lex();this.scanner.restoreState(t),e=t.lineNumber===r.lineNumber&&4===r.type&&"function"===r.value}return e},e.prototype.parseFunctionDeclaration=function(e){var t=this.createNode(),r=this.matchContextualKeyword("async");r&&this.nextToken(),this.expectKeyword("function");var n,i=!r&&this.match("*");i&&this.nextToken();var s=null,u=null;if(!e||!this.match("(")){var l=this.lookahead;s=this.parseVariableIdentifier(),this.context.strict?this.scanner.isRestrictedWord(l.value)&&this.tolerateUnexpectedToken(l,o.Messages.StrictFunctionName):this.scanner.isRestrictedWord(l.value)?(u=l,n=o.Messages.StrictFunctionName):this.scanner.isStrictModeReservedWord(l.value)&&(u=l,n=o.Messages.StrictReservedWord)}var c=this.context.await,h=this.context.allowYield;this.context.await=r,this.context.allowYield=!i;var p=this.parseFormalParameters(u),f=p.params,d=p.stricted;u=p.firstRestricted,p.message&&(n=p.message);var m=this.context.strict,y=this.context.allowStrictDirective;this.context.allowStrictDirective=p.simple;var v=this.parseFunctionSourceElements();return this.context.strict&&u&&this.throwUnexpectedToken(u,n),this.context.strict&&d&&this.tolerateUnexpectedToken(d,n),this.context.strict=m,this.context.allowStrictDirective=y,this.context.await=c,this.context.allowYield=h,r?this.finalize(t,new a.AsyncFunctionDeclaration(s,f,v)):this.finalize(t,new a.FunctionDeclaration(s,f,v,i))},e.prototype.parseFunctionExpression=function(){var e=this.createNode(),t=this.matchContextualKeyword("async");t&&this.nextToken(),this.expectKeyword("function");var r,n=!t&&this.match("*");n&&this.nextToken();var i,s=null,u=this.context.await,l=this.context.allowYield;if(this.context.await=t,this.context.allowYield=!n,!this.match("(")){var c=this.lookahead;s=this.context.strict||n||!this.matchKeyword("yield")?this.parseVariableIdentifier():this.parseIdentifierName(),this.context.strict?this.scanner.isRestrictedWord(c.value)&&this.tolerateUnexpectedToken(c,o.Messages.StrictFunctionName):this.scanner.isRestrictedWord(c.value)?(i=c,r=o.Messages.StrictFunctionName):this.scanner.isStrictModeReservedWord(c.value)&&(i=c,r=o.Messages.StrictReservedWord)}var h=this.parseFormalParameters(i),p=h.params,f=h.stricted;i=h.firstRestricted,h.message&&(r=h.message);var d=this.context.strict,m=this.context.allowStrictDirective;this.context.allowStrictDirective=h.simple;var y=this.parseFunctionSourceElements();return this.context.strict&&i&&this.throwUnexpectedToken(i,r),this.context.strict&&f&&this.tolerateUnexpectedToken(f,r),this.context.strict=d,this.context.allowStrictDirective=m,this.context.await=u,this.context.allowYield=l,t?this.finalize(e,new a.AsyncFunctionExpression(s,p,y)):this.finalize(e,new a.FunctionExpression(s,p,y,n))},e.prototype.parseDirective=function(){var e=this.lookahead,t=this.createNode(),r=this.parseExpression(),n=r.type===u.Syntax.Literal?this.getTokenRaw(e).slice(1,-1):null;return this.consumeSemicolon(),this.finalize(t,n?new a.Directive(r,n):new a.ExpressionStatement(r))},e.prototype.parseDirectivePrologues=function(){for(var e=null,t=[];;){var r=this.lookahead;if(8!==r.type)break;var n=this.parseDirective();t.push(n);var i=n.directive;if("string"!=typeof i)break;"use strict"===i?(this.context.strict=!0,e&&this.tolerateUnexpectedToken(e,o.Messages.StrictOctalLiteral),this.context.allowStrictDirective||this.tolerateUnexpectedToken(r,o.Messages.IllegalLanguageModeDirective)):!e&&r.octal&&(e=r)}return t},e.prototype.qualifiedPropertyName=function(e){switch(e.type){case 3:case 8:case 1:case 5:case 6:case 4:return!0;case 7:return"["===e.value}return!1},e.prototype.parseGetterMethod=function(){var e=this.createNode(),t=this.context.allowYield;this.context.allowYield=!0;var r=this.parseFormalParameters();r.params.length>0&&this.tolerateError(o.Messages.BadGetterArity);var n=this.parsePropertyMethod(r);return this.context.allowYield=t,this.finalize(e,new a.FunctionExpression(null,r.params,n,!1))},e.prototype.parseSetterMethod=function(){var e=this.createNode(),t=this.context.allowYield;this.context.allowYield=!0;var r=this.parseFormalParameters();1!==r.params.length?this.tolerateError(o.Messages.BadSetterArity):r.params[0]instanceof a.RestElement&&this.tolerateError(o.Messages.BadSetterRestParameter);var n=this.parsePropertyMethod(r);return this.context.allowYield=t,this.finalize(e,new a.FunctionExpression(null,r.params,n,!1))},e.prototype.parseGeneratorMethod=function(){var e=this.createNode(),t=this.context.allowYield;this.context.allowYield=!0;var r=this.parseFormalParameters();this.context.allowYield=!1;var n=this.parsePropertyMethod(r);return this.context.allowYield=t,this.finalize(e,new a.FunctionExpression(null,r.params,n,!0))},e.prototype.isStartOfExpression=function(){var e=!0,t=this.lookahead.value;switch(this.lookahead.type){case 7:e="["===t||"("===t||"{"===t||"+"===t||"-"===t||"!"===t||"~"===t||"++"===t||"--"===t||"/"===t||"/="===t;break;case 4:e="class"===t||"delete"===t||"function"===t||"let"===t||"new"===t||"super"===t||"this"===t||"typeof"===t||"void"===t||"yield"===t}return e},e.prototype.parseYieldExpression=function(){var e=this.createNode();this.expectKeyword("yield");var t=null,r=!1;if(!this.hasLineTerminator){var n=this.context.allowYield;this.context.allowYield=!1,(r=this.match("*"))?(this.nextToken(),t=this.parseAssignmentExpression()):this.isStartOfExpression()&&(t=this.parseAssignmentExpression()),this.context.allowYield=n}return this.finalize(e,new a.YieldExpression(t,r))},e.prototype.parseClassElement=function(e){var t=this.lookahead,r=this.createNode(),n="",i=null,s=null,u=!1,l=!1,c=!1,h=!1;if(this.match("*"))this.nextToken();else if(u=this.match("["),"static"===(i=this.parseObjectPropertyKey()).name&&(this.qualifiedPropertyName(this.lookahead)||this.match("*"))&&(t=this.lookahead,c=!0,u=this.match("["),this.match("*")?this.nextToken():i=this.parseObjectPropertyKey()),3===t.type&&!this.hasLineTerminator&&"async"===t.value){var p=this.lookahead.value;":"!==p&&"("!==p&&"*"!==p&&(h=!0,t=this.lookahead,i=this.parseObjectPropertyKey(),3===t.type&&"constructor"===t.value&&this.tolerateUnexpectedToken(t,o.Messages.ConstructorIsAsync))}var f=this.qualifiedPropertyName(this.lookahead);return 3===t.type?"get"===t.value&&f?(n="get",u=this.match("["),i=this.parseObjectPropertyKey(),this.context.allowYield=!1,s=this.parseGetterMethod()):"set"===t.value&&f&&(n="set",u=this.match("["),i=this.parseObjectPropertyKey(),s=this.parseSetterMethod()):7===t.type&&"*"===t.value&&f&&(n="init",u=this.match("["),i=this.parseObjectPropertyKey(),s=this.parseGeneratorMethod(),l=!0),!n&&i&&this.match("(")&&(n="init",s=h?this.parsePropertyMethodAsyncFunction():this.parsePropertyMethodFunction(),l=!0),n||this.throwUnexpectedToken(this.lookahead),"init"===n&&(n="method"),u||(c&&this.isPropertyKey(i,"prototype")&&this.throwUnexpectedToken(t,o.Messages.StaticPrototype),!c&&this.isPropertyKey(i,"constructor")&&(("method"!==n||!l||s&&s.generator)&&this.throwUnexpectedToken(t,o.Messages.ConstructorSpecialMethod),e.value?this.throwUnexpectedToken(t,o.Messages.DuplicateConstructor):e.value=!0,n="constructor")),this.finalize(r,new a.MethodDefinition(i,u,s,n,c))},e.prototype.parseClassElementList=function(){var e=[],t={value:!1};for(this.expect("{");!this.match("}");)this.match(";")?this.nextToken():e.push(this.parseClassElement(t));return this.expect("}"),e},e.prototype.parseClassBody=function(){var e=this.createNode(),t=this.parseClassElementList();return this.finalize(e,new a.ClassBody(t))},e.prototype.parseClassDeclaration=function(e){var t=this.createNode(),r=this.context.strict;this.context.strict=!0,this.expectKeyword("class");var n=e&&3!==this.lookahead.type?null:this.parseVariableIdentifier(),i=null;this.matchKeyword("extends")&&(this.nextToken(),i=this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));var o=this.parseClassBody();return this.context.strict=r,this.finalize(t,new a.ClassDeclaration(n,i,o))},e.prototype.parseClassExpression=function(){var e=this.createNode(),t=this.context.strict;this.context.strict=!0,this.expectKeyword("class");var r=3===this.lookahead.type?this.parseVariableIdentifier():null,n=null;this.matchKeyword("extends")&&(this.nextToken(),n=this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));var i=this.parseClassBody();return this.context.strict=t,this.finalize(e,new a.ClassExpression(r,n,i))},e.prototype.parseModule=function(){this.context.strict=!0,this.context.isModule=!0,this.scanner.isModule=!0;for(var e=this.createNode(),t=this.parseDirectivePrologues();2!==this.lookahead.type;)t.push(this.parseStatementListItem());return this.finalize(e,new a.Module(t))},e.prototype.parseScript=function(){for(var e=this.createNode(),t=this.parseDirectivePrologues();2!==this.lookahead.type;)t.push(this.parseStatementListItem());return this.finalize(e,new a.Script(t))},e.prototype.parseModuleSpecifier=function(){var e=this.createNode();8!==this.lookahead.type&&this.throwError(o.Messages.InvalidModuleSpecifier);var t=this.nextToken(),r=this.getTokenRaw(t);return this.finalize(e,new a.Literal(t.value,r))},e.prototype.parseImportSpecifier=function(){var e,t,r=this.createNode();return 3===this.lookahead.type?(t=e=this.parseVariableIdentifier(),this.matchContextualKeyword("as")&&(this.nextToken(),t=this.parseVariableIdentifier())):(t=e=this.parseIdentifierName(),this.matchContextualKeyword("as")?(this.nextToken(),t=this.parseVariableIdentifier()):this.throwUnexpectedToken(this.nextToken())),this.finalize(r,new a.ImportSpecifier(t,e))},e.prototype.parseNamedImports=function(){this.expect("{");for(var e=[];!this.match("}");)e.push(this.parseImportSpecifier()),this.match("}")||this.expect(",");return this.expect("}"),e},e.prototype.parseImportDefaultSpecifier=function(){var e=this.createNode(),t=this.parseIdentifierName();return this.finalize(e,new a.ImportDefaultSpecifier(t))},e.prototype.parseImportNamespaceSpecifier=function(){var e=this.createNode();this.expect("*"),this.matchContextualKeyword("as")||this.throwError(o.Messages.NoAsAfterImportNamespace),this.nextToken();var t=this.parseIdentifierName();return this.finalize(e,new a.ImportNamespaceSpecifier(t))},e.prototype.parseImportDeclaration=function(){this.context.inFunctionBody&&this.throwError(o.Messages.IllegalImportDeclaration);var e,t=this.createNode();this.expectKeyword("import");var r=[];if(8===this.lookahead.type)e=this.parseModuleSpecifier();else{if(this.match("{")?r=r.concat(this.parseNamedImports()):this.match("*")?r.push(this.parseImportNamespaceSpecifier()):this.isIdentifierName(this.lookahead)&&!this.matchKeyword("default")?(r.push(this.parseImportDefaultSpecifier()),this.match(",")&&(this.nextToken(),this.match("*")?r.push(this.parseImportNamespaceSpecifier()):this.match("{")?r=r.concat(this.parseNamedImports()):this.throwUnexpectedToken(this.lookahead))):this.throwUnexpectedToken(this.nextToken()),!this.matchContextualKeyword("from")){var n=this.lookahead.value?o.Messages.UnexpectedToken:o.Messages.MissingFromClause;this.throwError(n,this.lookahead.value)}this.nextToken(),e=this.parseModuleSpecifier()}return this.consumeSemicolon(),this.finalize(t,new a.ImportDeclaration(r,e))},e.prototype.parseExportSpecifier=function(){var e=this.createNode(),t=this.parseIdentifierName(),r=t;return this.matchContextualKeyword("as")&&(this.nextToken(),r=this.parseIdentifierName()),this.finalize(e,new a.ExportSpecifier(t,r))},e.prototype.parseExportDeclaration=function(){this.context.inFunctionBody&&this.throwError(o.Messages.IllegalExportDeclaration);var e,t=this.createNode();if(this.expectKeyword("export"),this.matchKeyword("default"))if(this.nextToken(),this.matchKeyword("function")){var r=this.parseFunctionDeclaration(!0);e=this.finalize(t,new a.ExportDefaultDeclaration(r))}else this.matchKeyword("class")?(r=this.parseClassDeclaration(!0),e=this.finalize(t,new a.ExportDefaultDeclaration(r))):this.matchContextualKeyword("async")?(r=this.matchAsyncFunction()?this.parseFunctionDeclaration(!0):this.parseAssignmentExpression(),e=this.finalize(t,new a.ExportDefaultDeclaration(r))):(this.matchContextualKeyword("from")&&this.throwError(o.Messages.UnexpectedToken,this.lookahead.value),r=this.match("{")?this.parseObjectInitializer():this.match("[")?this.parseArrayInitializer():this.parseAssignmentExpression(),this.consumeSemicolon(),e=this.finalize(t,new a.ExportDefaultDeclaration(r)));else if(this.match("*")){if(this.nextToken(),!this.matchContextualKeyword("from")){var n=this.lookahead.value?o.Messages.UnexpectedToken:o.Messages.MissingFromClause;this.throwError(n,this.lookahead.value)}this.nextToken();var i=this.parseModuleSpecifier();this.consumeSemicolon(),e=this.finalize(t,new a.ExportAllDeclaration(i))}else if(4===this.lookahead.type){switch(r=void 0,this.lookahead.value){case"let":case"const":r=this.parseLexicalDeclaration({inFor:!1});break;case"var":case"class":case"function":r=this.parseStatementListItem();break;default:this.throwUnexpectedToken(this.lookahead)}e=this.finalize(t,new a.ExportNamedDeclaration(r,[],null))}else if(this.matchAsyncFunction())r=this.parseFunctionDeclaration(),e=this.finalize(t,new a.ExportNamedDeclaration(r,[],null));else{var s=[],u=null,l=!1;for(this.expect("{");!this.match("}");)l=l||this.matchKeyword("default"),s.push(this.parseExportSpecifier()),this.match("}")||this.expect(",");this.expect("}"),this.matchContextualKeyword("from")?(this.nextToken(),u=this.parseModuleSpecifier(),this.consumeSemicolon()):l?(n=this.lookahead.value?o.Messages.UnexpectedToken:o.Messages.MissingFromClause,this.throwError(n,this.lookahead.value)):this.consumeSemicolon(),e=this.finalize(t,new a.ExportNamedDeclaration(null,s,u))}return e},e}();t.Parser=c},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.assert=function(e,t){if(!e)throw new Error("ASSERT: "+t)}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(){this.errors=[],this.tolerant=!1}return e.prototype.recordError=function(e){this.errors.push(e)},e.prototype.tolerate=function(e){if(!this.tolerant)throw e;this.recordError(e)},e.prototype.constructError=function(e,t){var r=new Error(e);try{throw r}catch(e){Object.create&&Object.defineProperty&&(r=Object.create(e),Object.defineProperty(r,"column",{value:t}))}return r},e.prototype.createError=function(e,t,r,n){var i="Line "+t+": "+n,o=this.constructError(i,r);return o.index=e,o.lineNumber=t,o.description=n,o},e.prototype.throwError=function(e,t,r,n){throw this.createError(e,t,r,n)},e.prototype.tolerateError=function(e,t,r,n){var i=this.createError(e,t,r,n);if(!this.tolerant)throw i;this.recordError(i)},e}();t.ErrorHandler=r},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Messages={BadGetterArity:"Getter must not have any formal parameters",BadSetterArity:"Setter must have exactly one formal parameter",BadSetterRestParameter:"Setter function argument must not be a rest parameter",ConstructorIsAsync:"Class constructor may not be an async method",ConstructorSpecialMethod:"Class constructor may not be an accessor",DeclarationMissingInitializer:"Missing initializer in %0 declaration",DefaultRestParameter:"Unexpected token =",DuplicateBinding:"Duplicate binding %0",DuplicateConstructor:"A class may only have one constructor",DuplicateProtoProperty:"Duplicate __proto__ fields are not allowed in object literals",ForInOfLoopInitializer:"%0 loop variable declaration may not have an initializer",GeneratorInLegacyContext:"Generator declarations are not allowed in legacy contexts",IllegalBreak:"Illegal break statement",IllegalContinue:"Illegal continue statement",IllegalExportDeclaration:"Unexpected token",IllegalImportDeclaration:"Unexpected token",IllegalLanguageModeDirective:"Illegal 'use strict' directive in function with non-simple parameter list",IllegalReturn:"Illegal return statement",InvalidEscapedReservedWord:"Keyword must not contain escaped characters",InvalidHexEscapeSequence:"Invalid hexadecimal escape sequence",InvalidLHSInAssignment:"Invalid left-hand side in assignment",InvalidLHSInForIn:"Invalid left-hand side in for-in",InvalidLHSInForLoop:"Invalid left-hand side in for-loop",InvalidModuleSpecifier:"Unexpected token",InvalidRegExp:"Invalid regular expression",LetInLexicalBinding:"let is disallowed as a lexically bound name",MissingFromClause:"Unexpected token",MultipleDefaultsInSwitch:"More than one default clause in switch statement",NewlineAfterThrow:"Illegal newline after throw",NoAsAfterImportNamespace:"Unexpected token",NoCatchOrFinally:"Missing catch or finally after try",ParameterAfterRestParameter:"Rest parameter must be last formal parameter",Redeclaration:"%0 '%1' has already been declared",StaticPrototype:"Classes may not have static property named prototype",StrictCatchVariable:"Catch variable may not be eval or arguments in strict mode",StrictDelete:"Delete of an unqualified identifier in strict mode.",StrictFunction:"In strict mode code, functions can only be declared at top level or inside a block",StrictFunctionName:"Function name may not be eval or arguments in strict mode",StrictLHSAssignment:"Assignment to eval or arguments is not allowed in strict mode",StrictLHSPostfix:"Postfix increment/decrement may not have eval or arguments operand in strict mode",StrictLHSPrefix:"Prefix increment/decrement may not have eval or arguments operand in strict mode",StrictModeWith:"Strict mode code may not include a with statement",StrictOctalLiteral:"Octal literals are not allowed in strict mode.",StrictParamDupe:"Strict mode function may not have duplicate parameter names",StrictParamName:"Parameter name eval or arguments is not allowed in strict mode",StrictReservedWord:"Use of future reserved word in strict mode",StrictVarName:"Variable name may not be eval or arguments in strict mode",TemplateOctalLiteral:"Octal literals are not allowed in template strings.",UnexpectedEOS:"Unexpected end of input",UnexpectedIdentifier:"Unexpected identifier",UnexpectedNumber:"Unexpected number",UnexpectedReserved:"Unexpected reserved word",UnexpectedString:"Unexpected string",UnexpectedTemplate:"Unexpected quasi %0",UnexpectedToken:"Unexpected token %0",UnexpectedTokenIllegal:"Unexpected token ILLEGAL",UnknownLabel:"Undefined label '%0'",UnterminatedRegExp:"Invalid regular expression: missing /"}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(9),i=r(4),o=r(11);function a(e){return"0123456789abcdef".indexOf(e.toLowerCase())}function s(e){return"01234567".indexOf(e)}var u=function(){function e(e,t){this.source=e,this.errorHandler=t,this.trackComment=!1,this.isModule=!1,this.length=e.length,this.index=0,this.lineNumber=e.length>0?1:0,this.lineStart=0,this.curlyStack=[]}return e.prototype.saveState=function(){return{index:this.index,lineNumber:this.lineNumber,lineStart:this.lineStart}},e.prototype.restoreState=function(e){this.index=e.index,this.lineNumber=e.lineNumber,this.lineStart=e.lineStart},e.prototype.eof=function(){return this.index>=this.length},e.prototype.throwUnexpectedToken=function(e){return void 0===e&&(e=o.Messages.UnexpectedTokenIllegal),this.errorHandler.throwError(this.index,this.lineNumber,this.index-this.lineStart+1,e)},e.prototype.tolerateUnexpectedToken=function(e){void 0===e&&(e=o.Messages.UnexpectedTokenIllegal),this.errorHandler.tolerateError(this.index,this.lineNumber,this.index-this.lineStart+1,e)},e.prototype.skipSingleLineComment=function(e){var t,r,n=[];for(this.trackComment&&(n=[],t=this.index-e,r={start:{line:this.lineNumber,column:this.index-this.lineStart-e},end:{}});!this.eof();){var o=this.source.charCodeAt(this.index);if(++this.index,i.Character.isLineTerminator(o)){if(this.trackComment){r.end={line:this.lineNumber,column:this.index-this.lineStart-1};var a={multiLine:!1,slice:[t+e,this.index-1],range:[t,this.index-1],loc:r};n.push(a)}return 13===o&&10===this.source.charCodeAt(this.index)&&++this.index,++this.lineNumber,this.lineStart=this.index,n}}return this.trackComment&&(r.end={line:this.lineNumber,column:this.index-this.lineStart},a={multiLine:!1,slice:[t+e,this.index],range:[t,this.index],loc:r},n.push(a)),n},e.prototype.skipMultiLineComment=function(){var e,t,r=[];for(this.trackComment&&(r=[],e=this.index-2,t={start:{line:this.lineNumber,column:this.index-this.lineStart-2},end:{}});!this.eof();){var n=this.source.charCodeAt(this.index);if(i.Character.isLineTerminator(n))13===n&&10===this.source.charCodeAt(this.index+1)&&++this.index,++this.lineNumber,++this.index,this.lineStart=this.index;else if(42===n){if(47===this.source.charCodeAt(this.index+1)){if(this.index+=2,this.trackComment){t.end={line:this.lineNumber,column:this.index-this.lineStart};var o={multiLine:!0,slice:[e+2,this.index-2],range:[e,this.index],loc:t};r.push(o)}return r}++this.index}else++this.index}return this.trackComment&&(t.end={line:this.lineNumber,column:this.index-this.lineStart},o={multiLine:!0,slice:[e+2,this.index],range:[e,this.index],loc:t},r.push(o)),this.tolerateUnexpectedToken(),r},e.prototype.scanComments=function(){var e;this.trackComment&&(e=[]);for(var t=0===this.index;!this.eof();){var r=this.source.charCodeAt(this.index);if(i.Character.isWhiteSpace(r))++this.index;else if(i.Character.isLineTerminator(r))++this.index,13===r&&10===this.source.charCodeAt(this.index)&&++this.index,++this.lineNumber,this.lineStart=this.index,t=!0;else if(47===r)if(47===(r=this.source.charCodeAt(this.index+1))){this.index+=2;var n=this.skipSingleLineComment(2);this.trackComment&&(e=e.concat(n)),t=!0}else{if(42!==r)break;this.index+=2,n=this.skipMultiLineComment(),this.trackComment&&(e=e.concat(n))}else if(t&&45===r){if(45!==this.source.charCodeAt(this.index+1)||62!==this.source.charCodeAt(this.index+2))break;this.index+=3,n=this.skipSingleLineComment(3),this.trackComment&&(e=e.concat(n))}else{if(60!==r||this.isModule)break;if("!--"!==this.source.slice(this.index+1,this.index+4))break;this.index+=4,n=this.skipSingleLineComment(4),this.trackComment&&(e=e.concat(n))}}return e},e.prototype.isFutureReservedWord=function(e){switch(e){case"enum":case"export":case"import":case"super":return!0;default:return!1}},e.prototype.isStrictModeReservedWord=function(e){switch(e){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"yield":case"let":return!0;default:return!1}},e.prototype.isRestrictedWord=function(e){return"eval"===e||"arguments"===e},e.prototype.isKeyword=function(e){switch(e.length){case 2:return"if"===e||"in"===e||"do"===e;case 3:return"var"===e||"for"===e||"new"===e||"try"===e||"let"===e;case 4:return"this"===e||"else"===e||"case"===e||"void"===e||"with"===e||"enum"===e;case 5:return"while"===e||"break"===e||"catch"===e||"throw"===e||"const"===e||"yield"===e||"class"===e||"super"===e;case 6:return"return"===e||"typeof"===e||"delete"===e||"switch"===e||"export"===e||"import"===e;case 7:return"default"===e||"finally"===e||"extends"===e;case 8:return"function"===e||"continue"===e||"debugger"===e;case 10:return"instanceof"===e;default:return!1}},e.prototype.codePointAt=function(e){var t=this.source.charCodeAt(e);if(t>=55296&&t<=56319){var r=this.source.charCodeAt(e+1);r>=56320&&r<=57343&&(t=1024*(t-55296)+r-56320+65536)}return t},e.prototype.scanHexEscape=function(e){for(var t="u"===e?4:2,r=0,n=0;n<t;++n){if(this.eof()||!i.Character.isHexDigit(this.source.charCodeAt(this.index)))return null;r=16*r+a(this.source[this.index++])}return String.fromCharCode(r)},e.prototype.scanUnicodeCodePointEscape=function(){var e=this.source[this.index],t=0;for("}"===e&&this.throwUnexpectedToken();!this.eof()&&(e=this.source[this.index++],i.Character.isHexDigit(e.charCodeAt(0)));)t=16*t+a(e);return(t>1114111||"}"!==e)&&this.throwUnexpectedToken(),i.Character.fromCodePoint(t)},e.prototype.getIdentifier=function(){for(var e=this.index++;!this.eof();){var t=this.source.charCodeAt(this.index);if(92===t)return this.index=e,this.getComplexIdentifier();if(t>=55296&&t<57343)return this.index=e,this.getComplexIdentifier();if(!i.Character.isIdentifierPart(t))break;++this.index}return this.source.slice(e,this.index)},e.prototype.getComplexIdentifier=function(){var e,t=this.codePointAt(this.index),r=i.Character.fromCodePoint(t);for(this.index+=r.length,92===t&&(117!==this.source.charCodeAt(this.index)&&this.throwUnexpectedToken(),++this.index,"{"===this.source[this.index]?(++this.index,e=this.scanUnicodeCodePointEscape()):null!==(e=this.scanHexEscape("u"))&&"\\"!==e&&i.Character.isIdentifierStart(e.charCodeAt(0))||this.throwUnexpectedToken(),r=e);!this.eof()&&(t=this.codePointAt(this.index),i.Character.isIdentifierPart(t));)r+=e=i.Character.fromCodePoint(t),this.index+=e.length,92===t&&(r=r.substr(0,r.length-1),117!==this.source.charCodeAt(this.index)&&this.throwUnexpectedToken(),++this.index,"{"===this.source[this.index]?(++this.index,e=this.scanUnicodeCodePointEscape()):null!==(e=this.scanHexEscape("u"))&&"\\"!==e&&i.Character.isIdentifierPart(e.charCodeAt(0))||this.throwUnexpectedToken(),r+=e);return r},e.prototype.octalToDecimal=function(e){var t="0"!==e,r=s(e);return!this.eof()&&i.Character.isOctalDigit(this.source.charCodeAt(this.index))&&(t=!0,r=8*r+s(this.source[this.index++]),"0123".indexOf(e)>=0&&!this.eof()&&i.Character.isOctalDigit(this.source.charCodeAt(this.index))&&(r=8*r+s(this.source[this.index++]))),{code:r,octal:t}},e.prototype.scanIdentifier=function(){var e,t=this.index,r=92===this.source.charCodeAt(t)?this.getComplexIdentifier():this.getIdentifier();if(3!=(e=1===r.length?3:this.isKeyword(r)?4:"null"===r?5:"true"===r||"false"===r?1:3)&&t+r.length!==this.index){var n=this.index;this.index=t,this.tolerateUnexpectedToken(o.Messages.InvalidEscapedReservedWord),this.index=n}return{type:e,value:r,lineNumber:this.lineNumber,lineStart:this.lineStart,start:t,end:this.index}},e.prototype.scanPunctuator=function(){var e=this.index,t=this.source[this.index];switch(t){case"(":case"{":"{"===t&&this.curlyStack.push("{"),++this.index;break;case".":++this.index,"."===this.source[this.index]&&"."===this.source[this.index+1]&&(this.index+=2,t="...");break;case"}":++this.index,this.curlyStack.pop();break;case")":case";":case",":case"[":case"]":case":":case"?":case"~":++this.index;break;default:">>>="===(t=this.source.substr(this.index,4))?this.index+=4:"==="===(t=t.substr(0,3))||"!=="===t||">>>"===t||"<<="===t||">>="===t||"**="===t?this.index+=3:"&&"===(t=t.substr(0,2))||"||"===t||"=="===t||"!="===t||"+="===t||"-="===t||"*="===t||"/="===t||"++"===t||"--"===t||"<<"===t||">>"===t||"&="===t||"|="===t||"^="===t||"%="===t||"<="===t||">="===t||"=>"===t||"**"===t?this.index+=2:(t=this.source[this.index],"<>=!+-*%&|^/".indexOf(t)>=0&&++this.index)}return this.index===e&&this.throwUnexpectedToken(),{type:7,value:t,lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.scanHexLiteral=function(e){for(var t="";!this.eof()&&i.Character.isHexDigit(this.source.charCodeAt(this.index));)t+=this.source[this.index++];return 0===t.length&&this.throwUnexpectedToken(),i.Character.isIdentifierStart(this.source.charCodeAt(this.index))&&this.throwUnexpectedToken(),{type:6,value:parseInt("0x"+t,16),lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.scanBinaryLiteral=function(e){for(var t,r="";!this.eof()&&("0"===(t=this.source[this.index])||"1"===t);)r+=this.source[this.index++];return 0===r.length&&this.throwUnexpectedToken(),this.eof()||(t=this.source.charCodeAt(this.index),(i.Character.isIdentifierStart(t)||i.Character.isDecimalDigit(t))&&this.throwUnexpectedToken()),{type:6,value:parseInt(r,2),lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.scanOctalLiteral=function(e,t){var r="",n=!1;for(i.Character.isOctalDigit(e.charCodeAt(0))?(n=!0,r="0"+this.source[this.index++]):++this.index;!this.eof()&&i.Character.isOctalDigit(this.source.charCodeAt(this.index));)r+=this.source[this.index++];return n||0!==r.length||this.throwUnexpectedToken(),(i.Character.isIdentifierStart(this.source.charCodeAt(this.index))||i.Character.isDecimalDigit(this.source.charCodeAt(this.index)))&&this.throwUnexpectedToken(),{type:6,value:parseInt(r,8),octal:n,lineNumber:this.lineNumber,lineStart:this.lineStart,start:t,end:this.index}},e.prototype.isImplicitOctalLiteral=function(){for(var e=this.index+1;e<this.length;++e){var t=this.source[e];if("8"===t||"9"===t)return!1;if(!i.Character.isOctalDigit(t.charCodeAt(0)))return!0}return!0},e.prototype.scanNumericLiteral=function(){var e=this.index,t=this.source[e];n.assert(i.Character.isDecimalDigit(t.charCodeAt(0))||"."===t,"Numeric literal must start with a decimal digit or a decimal point");var r="";if("."!==t){if(r=this.source[this.index++],t=this.source[this.index],"0"===r){if("x"===t||"X"===t)return++this.index,this.scanHexLiteral(e);if("b"===t||"B"===t)return++this.index,this.scanBinaryLiteral(e);if("o"===t||"O"===t)return this.scanOctalLiteral(t,e);if(t&&i.Character.isOctalDigit(t.charCodeAt(0))&&this.isImplicitOctalLiteral())return this.scanOctalLiteral(t,e)}for(;i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r+=this.source[this.index++];t=this.source[this.index]}if("."===t){for(r+=this.source[this.index++];i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r+=this.source[this.index++];t=this.source[this.index]}if("e"===t||"E"===t)if(r+=this.source[this.index++],"+"!==(t=this.source[this.index])&&"-"!==t||(r+=this.source[this.index++]),i.Character.isDecimalDigit(this.source.charCodeAt(this.index)))for(;i.Character.isDecimalDigit(this.source.charCodeAt(this.index));)r+=this.source[this.index++];else this.throwUnexpectedToken();return i.Character.isIdentifierStart(this.source.charCodeAt(this.index))&&this.throwUnexpectedToken(),{type:6,value:parseFloat(r),lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.scanStringLiteral=function(){var e=this.index,t=this.source[e];n.assert("'"===t||'"'===t,"String literal must starts with a quote"),++this.index;for(var r=!1,a="";!this.eof();){var s=this.source[this.index++];if(s===t){t="";break}if("\\"===s)if((s=this.source[this.index++])&&i.Character.isLineTerminator(s.charCodeAt(0)))++this.lineNumber,"\r"===s&&"\n"===this.source[this.index]&&++this.index,this.lineStart=this.index;else switch(s){case"u":if("{"===this.source[this.index])++this.index,a+=this.scanUnicodeCodePointEscape();else{var u=this.scanHexEscape(s);null===u&&this.throwUnexpectedToken(),a+=u}break;case"x":var l=this.scanHexEscape(s);null===l&&this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence),a+=l;break;case"n":a+="\n";break;case"r":a+="\r";break;case"t":a+="\t";break;case"b":a+="\b";break;case"f":a+="\f";break;case"v":a+="\v";break;case"8":case"9":a+=s,this.tolerateUnexpectedToken();break;default:if(s&&i.Character.isOctalDigit(s.charCodeAt(0))){var c=this.octalToDecimal(s);r=c.octal||r,a+=String.fromCharCode(c.code)}else a+=s}else{if(i.Character.isLineTerminator(s.charCodeAt(0)))break;a+=s}}return""!==t&&(this.index=e,this.throwUnexpectedToken()),{type:8,value:a,octal:r,lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.scanTemplate=function(){var e="",t=!1,r=this.index,n="`"===this.source[r],a=!1,s=2;for(++this.index;!this.eof();){var u=this.source[this.index++];if("`"===u){s=1,a=!0,t=!0;break}if("$"===u){if("{"===this.source[this.index]){this.curlyStack.push("${"),++this.index,t=!0;break}e+=u}else if("\\"===u)if(u=this.source[this.index++],i.Character.isLineTerminator(u.charCodeAt(0)))++this.lineNumber,"\r"===u&&"\n"===this.source[this.index]&&++this.index,this.lineStart=this.index;else switch(u){case"n":e+="\n";break;case"r":e+="\r";break;case"t":e+="\t";break;case"u":if("{"===this.source[this.index])++this.index,e+=this.scanUnicodeCodePointEscape();else{var l=this.index,c=this.scanHexEscape(u);null!==c?e+=c:(this.index=l,e+=u)}break;case"x":var h=this.scanHexEscape(u);null===h&&this.throwUnexpectedToken(o.Messages.InvalidHexEscapeSequence),e+=h;break;case"b":e+="\b";break;case"f":e+="\f";break;case"v":e+="\v";break;default:"0"===u?(i.Character.isDecimalDigit(this.source.charCodeAt(this.index))&&this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral),e+="\0"):i.Character.isOctalDigit(u.charCodeAt(0))?this.throwUnexpectedToken(o.Messages.TemplateOctalLiteral):e+=u}else i.Character.isLineTerminator(u.charCodeAt(0))?(++this.lineNumber,"\r"===u&&"\n"===this.source[this.index]&&++this.index,this.lineStart=this.index,e+="\n"):e+=u}return t||this.throwUnexpectedToken(),n||this.curlyStack.pop(),{type:10,value:this.source.slice(r+1,this.index-s),cooked:e,head:n,tail:a,lineNumber:this.lineNumber,lineStart:this.lineStart,start:r,end:this.index}},e.prototype.testRegExp=function(e,t){var r=e,n=this;t.indexOf("u")>=0&&(r=r.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g,(function(e,t,r){var i=parseInt(t||r,16);return i>1114111&&n.throwUnexpectedToken(o.Messages.InvalidRegExp),i<=65535?String.fromCharCode(i):"￿"})).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"￿"));try{RegExp(r)}catch(e){this.throwUnexpectedToken(o.Messages.InvalidRegExp)}try{return new RegExp(e,t)}catch(e){return null}},e.prototype.scanRegExpBody=function(){var e=this.source[this.index];n.assert("/"===e,"Regular expression literal must start with a slash");for(var t=this.source[this.index++],r=!1,a=!1;!this.eof();)if(t+=e=this.source[this.index++],"\\"===e)e=this.source[this.index++],i.Character.isLineTerminator(e.charCodeAt(0))&&this.throwUnexpectedToken(o.Messages.UnterminatedRegExp),t+=e;else if(i.Character.isLineTerminator(e.charCodeAt(0)))this.throwUnexpectedToken(o.Messages.UnterminatedRegExp);else if(r)"]"===e&&(r=!1);else{if("/"===e){a=!0;break}"["===e&&(r=!0)}return a||this.throwUnexpectedToken(o.Messages.UnterminatedRegExp),t.substr(1,t.length-2)},e.prototype.scanRegExpFlags=function(){for(var e="";!this.eof();){var t=this.source[this.index];if(!i.Character.isIdentifierPart(t.charCodeAt(0)))break;if(++this.index,"\\"!==t||this.eof())e+=t;else if("u"===(t=this.source[this.index])){++this.index;var r=this.index,n=this.scanHexEscape("u");if(null!==n)for(e+=n;r<this.index;++r)this.source[r];else this.index=r,e+="u";this.tolerateUnexpectedToken()}else this.tolerateUnexpectedToken()}return e},e.prototype.scanRegExp=function(){var e=this.index,t=this.scanRegExpBody(),r=this.scanRegExpFlags();return{type:9,value:"",pattern:t,flags:r,regex:this.testRegExp(t,r),lineNumber:this.lineNumber,lineStart:this.lineStart,start:e,end:this.index}},e.prototype.lex=function(){if(this.eof())return{type:2,value:"",lineNumber:this.lineNumber,lineStart:this.lineStart,start:this.index,end:this.index};var e=this.source.charCodeAt(this.index);return i.Character.isIdentifierStart(e)?this.scanIdentifier():40===e||41===e||59===e?this.scanPunctuator():39===e||34===e?this.scanStringLiteral():46===e?i.Character.isDecimalDigit(this.source.charCodeAt(this.index+1))?this.scanNumericLiteral():this.scanPunctuator():i.Character.isDecimalDigit(e)?this.scanNumericLiteral():96===e||125===e&&"${"===this.curlyStack[this.curlyStack.length-1]?this.scanTemplate():e>=55296&&e<57343&&i.Character.isIdentifierStart(this.codePointAt(this.index))?this.scanIdentifier():this.scanPunctuator()},e}();t.Scanner=u},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TokenName={},t.TokenName[1]="Boolean",t.TokenName[2]="<end>",t.TokenName[3]="Identifier",t.TokenName[4]="Keyword",t.TokenName[5]="Null",t.TokenName[6]="Numeric",t.TokenName[7]="Punctuator",t.TokenName[8]="String",t.TokenName[9]="RegularExpression",t.TokenName[10]="Template"},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.XHTMLEntities={quot:'"',amp:"&",apos:"'",gt:">",nbsp:" ",iexcl:"¡",cent:"¢",pound:"£",curren:"¤",yen:"¥",brvbar:"¦",sect:"§",uml:"¨",copy:"©",ordf:"ª",laquo:"«",not:"¬",shy:"­",reg:"®",macr:"¯",deg:"°",plusmn:"±",sup2:"²",sup3:"³",acute:"´",micro:"µ",para:"¶",middot:"·",cedil:"¸",sup1:"¹",ordm:"º",raquo:"»",frac14:"¼",frac12:"½",frac34:"¾",iquest:"¿",Agrave:"À",Aacute:"Á",Acirc:"Â",Atilde:"Ã",Auml:"Ä",Aring:"Å",AElig:"Æ",Ccedil:"Ç",Egrave:"È",Eacute:"É",Ecirc:"Ê",Euml:"Ë",Igrave:"Ì",Iacute:"Í",Icirc:"Î",Iuml:"Ï",ETH:"Ð",Ntilde:"Ñ",Ograve:"Ò",Oacute:"Ó",Ocirc:"Ô",Otilde:"Õ",Ouml:"Ö",times:"×",Oslash:"Ø",Ugrave:"Ù",Uacute:"Ú",Ucirc:"Û",Uuml:"Ü",Yacute:"Ý",THORN:"Þ",szlig:"ß",agrave:"à",aacute:"á",acirc:"â",atilde:"ã",auml:"ä",aring:"å",aelig:"æ",ccedil:"ç",egrave:"è",eacute:"é",ecirc:"ê",euml:"ë",igrave:"ì",iacute:"í",icirc:"î",iuml:"ï",eth:"ð",ntilde:"ñ",ograve:"ò",oacute:"ó",ocirc:"ô",otilde:"õ",ouml:"ö",divide:"÷",oslash:"ø",ugrave:"ù",uacute:"ú",ucirc:"û",uuml:"ü",yacute:"ý",thorn:"þ",yuml:"ÿ",OElig:"Œ",oelig:"œ",Scaron:"Š",scaron:"š",Yuml:"Ÿ",fnof:"ƒ",circ:"ˆ",tilde:"˜",Alpha:"Α",Beta:"Β",Gamma:"Γ",Delta:"Δ",Epsilon:"Ε",Zeta:"Ζ",Eta:"Η",Theta:"Θ",Iota:"Ι",Kappa:"Κ",Lambda:"Λ",Mu:"Μ",Nu:"Ν",Xi:"Ξ",Omicron:"Ο",Pi:"Π",Rho:"Ρ",Sigma:"Σ",Tau:"Τ",Upsilon:"Υ",Phi:"Φ",Chi:"Χ",Psi:"Ψ",Omega:"Ω",alpha:"α",beta:"β",gamma:"γ",delta:"δ",epsilon:"ε",zeta:"ζ",eta:"η",theta:"θ",iota:"ι",kappa:"κ",lambda:"λ",mu:"μ",nu:"ν",xi:"ξ",omicron:"ο",pi:"π",rho:"ρ",sigmaf:"ς",sigma:"σ",tau:"τ",upsilon:"υ",phi:"φ",chi:"χ",psi:"ψ",omega:"ω",thetasym:"ϑ",upsih:"ϒ",piv:"ϖ",ensp:" ",emsp:" ",thinsp:" ",zwnj:"‌",zwj:"‍",lrm:"‎",rlm:"‏",ndash:"–",mdash:"—",lsquo:"‘",rsquo:"’",sbquo:"‚",ldquo:"“",rdquo:"”",bdquo:"„",dagger:"†",Dagger:"‡",bull:"•",hellip:"…",permil:"‰",prime:"′",Prime:"″",lsaquo:"‹",rsaquo:"›",oline:"‾",frasl:"⁄",euro:"€",image:"ℑ",weierp:"℘",real:"ℜ",trade:"™",alefsym:"ℵ",larr:"←",uarr:"↑",rarr:"→",darr:"↓",harr:"↔",crarr:"↵",lArr:"⇐",uArr:"⇑",rArr:"⇒",dArr:"⇓",hArr:"⇔",forall:"∀",part:"∂",exist:"∃",empty:"∅",nabla:"∇",isin:"∈",notin:"∉",ni:"∋",prod:"∏",sum:"∑",minus:"−",lowast:"∗",radic:"√",prop:"∝",infin:"∞",ang:"∠",and:"∧",or:"∨",cap:"∩",cup:"∪",int:"∫",there4:"∴",sim:"∼",cong:"≅",asymp:"≈",ne:"≠",equiv:"≡",le:"≤",ge:"≥",sub:"⊂",sup:"⊃",nsub:"⊄",sube:"⊆",supe:"⊇",oplus:"⊕",otimes:"⊗",perp:"⊥",sdot:"⋅",lceil:"⌈",rceil:"⌉",lfloor:"⌊",rfloor:"⌋",loz:"◊",spades:"♠",clubs:"♣",hearts:"♥",diams:"♦",lang:"⟨",rang:"⟩"}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(10),i=r(12),o=r(13),a=function(){function e(){this.values=[],this.curly=this.paren=-1}return e.prototype.beforeFunctionExpression=function(e){return["(","{","[","in","typeof","instanceof","new","return","case","delete","throw","void","=","+=","-=","*=","**=","/=","%=","<<=",">>=",">>>=","&=","|=","^=",",","+","-","*","**","/","%","++","--","<<",">>",">>>","&","|","^","!","~","&&","||","?",":","===","==",">=","<=","<",">","!=","!=="].indexOf(e)>=0},e.prototype.isRegexStart=function(){var e=this.values[this.values.length-1],t=null!==e;switch(e){case"this":case"]":t=!1;break;case")":var r=this.values[this.paren-1];t="if"===r||"while"===r||"for"===r||"with"===r;break;case"}":if(t=!1,"function"===this.values[this.curly-3])t=!!(n=this.values[this.curly-4])&&!this.beforeFunctionExpression(n);else if("function"===this.values[this.curly-4]){var n;t=!(n=this.values[this.curly-5])||!this.beforeFunctionExpression(n)}}return t},e.prototype.push=function(e){7===e.type||4===e.type?("{"===e.value?this.curly=this.values.length:"("===e.value&&(this.paren=this.values.length),this.values.push(e.value)):this.values.push(null)},e}(),s=function(){function e(e,t){this.errorHandler=new n.ErrorHandler,this.errorHandler.tolerant=!!t&&"boolean"==typeof t.tolerant&&t.tolerant,this.scanner=new i.Scanner(e,this.errorHandler),this.scanner.trackComment=!!t&&"boolean"==typeof t.comment&&t.comment,this.trackRange=!!t&&"boolean"==typeof t.range&&t.range,this.trackLoc=!!t&&"boolean"==typeof t.loc&&t.loc,this.buffer=[],this.reader=new a}return e.prototype.errors=function(){return this.errorHandler.errors},e.prototype.getNextToken=function(){if(0===this.buffer.length){var e=this.scanner.scanComments();if(this.scanner.trackComment)for(var t=0;t<e.length;++t){var r=e[t],n=this.scanner.source.slice(r.slice[0],r.slice[1]),i={type:r.multiLine?"BlockComment":"LineComment",value:n};this.trackRange&&(i.range=r.range),this.trackLoc&&(i.loc=r.loc),this.buffer.push(i)}if(!this.scanner.eof()){var a=void 0;this.trackLoc&&(a={start:{line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart},end:{}});var s="/"===this.scanner.source[this.scanner.index]&&this.reader.isRegexStart()?this.scanner.scanRegExp():this.scanner.lex();this.reader.push(s);var u={type:o.TokenName[s.type],value:this.scanner.source.slice(s.start,s.end)};if(this.trackRange&&(u.range=[s.start,s.end]),this.trackLoc&&(a.end={line:this.scanner.lineNumber,column:this.scanner.index-this.scanner.lineStart},u.loc=a),9===s.type){var l=s.pattern,c=s.flags;u.regex={pattern:l,flags:c}}this.buffer.push(u)}}return this.buffer.shift()},e}();t.Tokenizer=s}])},e.exports=n()},function(e,t,r){"use strict";var n=r(38),i=r(53),o=r(76),a=r(54),s=Object.prototype.toString,u=Object.prototype.hasOwnProperty,l={0:"\\0",7:"\\a",8:"\\b",9:"\\t",10:"\\n",11:"\\v",12:"\\f",13:"\\r",27:"\\e",34:'\\"',92:"\\\\",133:"\\N",160:"\\_",8232:"\\L",8233:"\\P"},c=["y","Y","yes","Yes","YES","on","On","ON","n","N","no","No","NO","off","Off","OFF"];function h(e){var t,r,o;if(t=e.toString(16).toUpperCase(),e<=255)r="x",o=2;else if(e<=65535)r="u",o=4;else{if(!(e<=4294967295))throw new i("code point within a string may not be greater than 0xFFFFFFFF");r="U",o=8}return"\\"+r+n.repeat("0",o-t.length)+t}function p(e){this.schema=e.schema||o,this.indent=Math.max(1,e.indent||2),this.noArrayIndent=e.noArrayIndent||!1,this.skipInvalid=e.skipInvalid||!1,this.flowLevel=n.isNothing(e.flowLevel)?-1:e.flowLevel,this.styleMap=function(e,t){var r,n,i,o,a,s,l;if(null===t)return{};for(r={},i=0,o=(n=Object.keys(t)).length;i<o;i+=1)a=n[i],s=String(t[a]),"!!"===a.slice(0,2)&&(a="tag:yaml.org,2002:"+a.slice(2)),(l=e.compiledTypeMap.fallback[a])&&u.call(l.styleAliases,s)&&(s=l.styleAliases[s]),r[a]=s;return r}(this.schema,e.styles||null),this.sortKeys=e.sortKeys||!1,this.lineWidth=e.lineWidth||80,this.noRefs=e.noRefs||!1,this.noCompatMode=e.noCompatMode||!1,this.condenseFlow=e.condenseFlow||!1,this.implicitTypes=this.schema.compiledImplicit,this.explicitTypes=this.schema.compiledExplicit,this.tag=null,this.result="",this.duplicates=[],this.usedDuplicates=null}function f(e,t){for(var r,i=n.repeat(" ",t),o=0,a=-1,s="",u=e.length;o<u;)-1===(a=e.indexOf("\n",o))?(r=e.slice(o),o=u):(r=e.slice(o,a+1),o=a+1),r.length&&"\n"!==r&&(s+=i),s+=r;return s}function d(e,t){return"\n"+n.repeat(" ",e.indent*t)}function m(e){return 32===e||9===e}function y(e){return 32<=e&&e<=126||161<=e&&e<=55295&&8232!==e&&8233!==e||57344<=e&&e<=65533&&65279!==e||65536<=e&&e<=1114111}function v(e,t){return y(e)&&65279!==e&&44!==e&&91!==e&&93!==e&&123!==e&&125!==e&&58!==e&&(35!==e||t&&function(e){return y(e)&&!m(e)&&65279!==e&&13!==e&&10!==e}(t))}function _(e){return/^\n* /.test(e)}function g(e,t,r,n,i){var o,a,s,u,l=!1,c=!1,h=-1!==n,p=-1,f=y(u=e.charCodeAt(0))&&65279!==u&&!m(u)&&45!==u&&63!==u&&58!==u&&44!==u&&91!==u&&93!==u&&123!==u&&125!==u&&35!==u&&38!==u&&42!==u&&33!==u&&124!==u&&61!==u&&62!==u&&39!==u&&34!==u&&37!==u&&64!==u&&96!==u&&!m(e.charCodeAt(e.length-1));if(t)for(o=0;o<e.length;o++){if(!y(a=e.charCodeAt(o)))return 5;s=o>0?e.charCodeAt(o-1):null,f=f&&v(a,s)}else{for(o=0;o<e.length;o++){if(10===(a=e.charCodeAt(o)))l=!0,h&&(c=c||o-p-1>n&&" "!==e[p+1],p=o);else if(!y(a))return 5;s=o>0?e.charCodeAt(o-1):null,f=f&&v(a,s)}c=c||h&&o-p-1>n&&" "!==e[p+1]}return l||c?r>9&&_(e)?5:c?4:3:f&&!i(e)?1:2}function b(e,t,r,n){e.dump=function(){if(0===t.length)return"''";if(!e.noCompatMode&&-1!==c.indexOf(t))return"'"+t+"'";var o=e.indent*Math.max(1,r),a=-1===e.lineWidth?-1:Math.max(Math.min(e.lineWidth,40),e.lineWidth-o),s=n||e.flowLevel>-1&&r>=e.flowLevel;switch(g(t,s,e.indent,a,(function(t){return function(e,t){var r,n;for(r=0,n=e.implicitTypes.length;r<n;r+=1)if(e.implicitTypes[r].resolve(t))return!0;return!1}(e,t)}))){case 1:return t;case 2:return"'"+t.replace(/'/g,"''")+"'";case 3:return"|"+x(t,e.indent)+w(f(t,o));case 4:return">"+x(t,e.indent)+w(f(function(e,t){var r,n,i=/(\n+)([^\n]*)/g,o=(s=e.indexOf("\n"),s=-1!==s?s:e.length,i.lastIndex=s,E(e.slice(0,s),t)),a="\n"===e[0]||" "===e[0];var s;for(;n=i.exec(e);){var u=n[1],l=n[2];r=" "===l[0],o+=u+(a||r||""===l?"":"\n")+E(l,t),a=r}return o}(t,a),o));case 5:return'"'+function(e){for(var t,r,n,i="",o=0;o<e.length;o++)(t=e.charCodeAt(o))>=55296&&t<=56319&&(r=e.charCodeAt(o+1))>=56320&&r<=57343?(i+=h(1024*(t-55296)+r-56320+65536),o++):(n=l[t],i+=!n&&y(t)?e[o]:n||h(t));return i}(t)+'"';default:throw new i("impossible error: invalid scalar style")}}()}function x(e,t){var r=_(e)?String(t):"",n="\n"===e[e.length-1];return r+(n&&("\n"===e[e.length-2]||"\n"===e)?"+":n?"":"-")+"\n"}function w(e){return"\n"===e[e.length-1]?e.slice(0,-1):e}function E(e,t){if(""===e||" "===e[0])return e;for(var r,n,i=/ [^ ]/g,o=0,a=0,s=0,u="";r=i.exec(e);)(s=r.index)-o>t&&(n=a>o?a:s,u+="\n"+e.slice(o,n),o=n+1),a=s;return u+="\n",e.length-o>t&&a>o?u+=e.slice(o,a)+"\n"+e.slice(a+1):u+=e.slice(o),u.slice(1)}function D(e,t,r){var n,o,a,l,c,h;for(a=0,l=(o=r?e.explicitTypes:e.implicitTypes).length;a<l;a+=1)if(((c=o[a]).instanceOf||c.predicate)&&(!c.instanceOf||"object"==typeof t&&t instanceof c.instanceOf)&&(!c.predicate||c.predicate(t))){if(e.tag=r?c.tag:"?",c.represent){if(h=e.styleMap[c.tag]||c.defaultStyle,"[object Function]"===s.call(c.represent))n=c.represent(t,h);else{if(!u.call(c.represent,h))throw new i("!<"+c.tag+'> tag resolver accepts not "'+h+'" style');n=c.represent[h](t,h)}e.dump=n}return!0}return!1}function S(e,t,r,n,o,a){e.tag=null,e.dump=r,D(e,r,!1)||D(e,r,!0);var u=s.call(e.dump);n&&(n=e.flowLevel<0||e.flowLevel>t);var l,c,h="[object Object]"===u||"[object Array]"===u;if(h&&(c=-1!==(l=e.duplicates.indexOf(r))),(null!==e.tag&&"?"!==e.tag||c||2!==e.indent&&t>0)&&(o=!1),c&&e.usedDuplicates[l])e.dump="*ref_"+l;else{if(h&&c&&!e.usedDuplicates[l]&&(e.usedDuplicates[l]=!0),"[object Object]"===u)n&&0!==Object.keys(e.dump).length?(!function(e,t,r,n){var o,a,s,u,l,c,h="",p=e.tag,f=Object.keys(r);if(!0===e.sortKeys)f.sort();else if("function"==typeof e.sortKeys)f.sort(e.sortKeys);else if(e.sortKeys)throw new i("sortKeys must be a boolean or a function");for(o=0,a=f.length;o<a;o+=1)c="",n&&0===o||(c+=d(e,t)),u=r[s=f[o]],S(e,t+1,s,!0,!0,!0)&&((l=null!==e.tag&&"?"!==e.tag||e.dump&&e.dump.length>1024)&&(e.dump&&10===e.dump.charCodeAt(0)?c+="?":c+="? "),c+=e.dump,l&&(c+=d(e,t)),S(e,t+1,u,!0,l)&&(e.dump&&10===e.dump.charCodeAt(0)?c+=":":c+=": ",h+=c+=e.dump));e.tag=p,e.dump=h||"{}"}(e,t,e.dump,o),c&&(e.dump="&ref_"+l+e.dump)):(!function(e,t,r){var n,i,o,a,s,u="",l=e.tag,c=Object.keys(r);for(n=0,i=c.length;n<i;n+=1)s="",0!==n&&(s+=", "),e.condenseFlow&&(s+='"'),a=r[o=c[n]],S(e,t,o,!1,!1)&&(e.dump.length>1024&&(s+="? "),s+=e.dump+(e.condenseFlow?'"':"")+":"+(e.condenseFlow?"":" "),S(e,t,a,!1,!1)&&(u+=s+=e.dump));e.tag=l,e.dump="{"+u+"}"}(e,t,e.dump),c&&(e.dump="&ref_"+l+" "+e.dump));else if("[object Array]"===u){var p=e.noArrayIndent&&t>0?t-1:t;n&&0!==e.dump.length?(!function(e,t,r,n){var i,o,a="",s=e.tag;for(i=0,o=r.length;i<o;i+=1)S(e,t+1,r[i],!0,!0)&&(n&&0===i||(a+=d(e,t)),e.dump&&10===e.dump.charCodeAt(0)?a+="-":a+="- ",a+=e.dump);e.tag=s,e.dump=a||"[]"}(e,p,e.dump,o),c&&(e.dump="&ref_"+l+e.dump)):(!function(e,t,r){var n,i,o="",a=e.tag;for(n=0,i=r.length;n<i;n+=1)S(e,t,r[n],!1,!1)&&(0!==n&&(o+=","+(e.condenseFlow?"":" ")),o+=e.dump);e.tag=a,e.dump="["+o+"]"}(e,p,e.dump),c&&(e.dump="&ref_"+l+" "+e.dump))}else{if("[object String]"!==u){if(e.skipInvalid)return!1;throw new i("unacceptable kind of an object to dump "+u)}"?"!==e.tag&&b(e,e.dump,t,a)}null!==e.tag&&"?"!==e.tag&&(e.dump="!<"+e.tag+"> "+e.dump)}return!0}function C(e,t){var r,n,i=[],o=[];for(function e(t,r,n){var i,o,a;if(null!==t&&"object"==typeof t)if(-1!==(o=r.indexOf(t)))-1===n.indexOf(o)&&n.push(o);else if(r.push(t),Array.isArray(t))for(o=0,a=t.length;o<a;o+=1)e(t[o],r,n);else for(i=Object.keys(t),o=0,a=i.length;o<a;o+=1)e(t[i[o]],r,n)}(e,i,o),r=0,n=o.length;r<n;r+=1)t.duplicates.push(i[o[r]]);t.usedDuplicates=new Array(n)}function A(e,t){var r=new p(t=t||{});return r.noRefs||C(e,r),S(r,0,e,!0,!0)?r.dump+"\n":""}e.exports.dump=A,e.exports.safeDump=function(e,t){return A(e,n.extend({schema:a},t))}},function(e,t,r){"use strict";r(31),r(32),r(33),r(64),r(19),r(65),r(20),r(68),r(92),r(144),r(22),r(94),r(23);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},a=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o.return)&&r.call(o)}finally{if(i)throw i.error}}return a};Object.defineProperty(t,"__esModule",{value:!0});var s=r(91),u=r(1),l=r(183),c=r(0),h=r(7),p=r(95),f=r(69),d=r(3),m=r(305),y=r(306),v=r(307),_=function(e){function t(t,r){void 0===r&&(r=!1);var n=e.call(this)||this;return n._hasDeclaration=!1,n._docTypeName="",n._hasDocumentElement=!1,n._currentElementSerialized=!1,n._openTags=[],n._ended=!1,n._fragment=r,n._options=u.applyDefaults(t||{},s.DefaultXMLBuilderCBOptions),n._builderOptions={defaultNamespace:n._options.defaultNamespace,namespaceAlias:n._options.namespaceAlias},"json"===n._options.format?n._writer=new y.JSONCBWriter(n._options):"yaml"===n._options.format?n._writer=new v.YAMLCBWriter(n._options):n._writer=new m.XMLCBWriter(n._options),void 0!==n._options.data&&n.on("data",n._options.data),void 0!==n._options.end&&n.on("end",n._options.end),void 0!==n._options.error&&n.on("error",n._options.error),n._prefixMap=new p.NamespacePrefixMap,n._prefixMap.set("xml",h.namespace.XML),n._prefixIndex={value:1},n._push(n._writer.frontMatter()),n}return i(t,e),t.prototype.ele=function(e,t,r){var n,i;if(u.isObject(e)||u.isString(e)&&(/^\s*</.test(e)||/^\s*[\{\[]/.test(e)||/^(\s*|(#.*)|(%.*))*---/.test(e))){var a=l.fragment().set(this._options);try{a.ele(e)}catch(e){return this.emit("error",e),this}try{for(var s=o(a.node.childNodes),c=s.next();!c.done;c=s.next()){var h=c.value;this._fromNode(h)}}catch(e){n={error:e}}finally{try{c&&!c.done&&(i=s.return)&&i.call(s)}finally{if(n)throw n.error}}return this}if(this._serializeOpenTag(!0),!this._fragment&&this._hasDocumentElement&&0===this._writer.level)return this.emit("error",new Error("Document cannot have multiple document element nodes.")),this;try{this._currentElement=l.fragment(this._builderOptions).ele(e,t,r)}catch(e){return this.emit("error",e),this}return this._fragment||this._hasDocumentElement||""===this._docTypeName||this._currentElement.node._qualifiedName===this._docTypeName?(this._currentElementSerialized=!1,this._fragment||(this._hasDocumentElement=!0),this):(this.emit("error",new Error("Document element name does not match DocType declaration name.")),this)},t.prototype.att=function(e,t,r){if(void 0===this._currentElement)return this.emit("error",new Error("Cannot insert an attribute node as child of a document node.")),this;try{this._currentElement.att(e,t,r)}catch(e){return this.emit("error",e),this}return this},t.prototype.com=function(e){var t;this._serializeOpenTag(!0);try{t=l.fragment(this._builderOptions).com(e).first().node}catch(e){return this.emit("error",e),this}return!this._options.wellFormed||c.xml_isLegalChar(t.data)&&-1===t.data.indexOf("--")&&!t.data.endsWith("-")?(this._push(this._writer.comment(t.data)),this):(this.emit("error",new Error("Comment data contains invalid characters (well-formed required).")),this)},t.prototype.txt=function(e){if(!this._fragment&&void 0===this._currentElement)return this.emit("error",new Error("Cannot insert a text node as child of a document node.")),this;var t;this._serializeOpenTag(!0);try{t=l.fragment(this._builderOptions).txt(e).first().node}catch(e){return this.emit("error",e),this}if(this._options.wellFormed&&!c.xml_isLegalChar(t.data))return this.emit("error",new Error("Text data contains invalid characters (well-formed required).")),this;var r=t.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");return this._push(this._writer.text(r)),this},t.prototype.ins=function(e,t){var r;void 0===t&&(t=""),this._serializeOpenTag(!0);try{r=l.fragment(this._builderOptions).ins(e,t).first().node}catch(e){return this.emit("error",e),this}return this._options.wellFormed&&(-1!==r.target.indexOf(":")||/^xml$/i.test(r.target))?(this.emit("error",new Error("Processing instruction target contains invalid characters (well-formed required).")),this):this._options.wellFormed&&!c.xml_isLegalChar(r.data)?(this.emit("error",Error("Processing instruction data contains invalid characters (well-formed required).")),this):(this._push(this._writer.instruction(r.target,r.data)),this)},t.prototype.dat=function(e){var t;this._serializeOpenTag(!0);try{t=l.fragment(this._builderOptions).dat(e).first().node}catch(e){return this.emit("error",e),this}return this._push(this._writer.cdata(t.data)),this},t.prototype.dec=function(e){return void 0===e&&(e={version:"1.0"}),this._fragment?(this.emit("error",Error("Cannot insert an XML declaration into a document fragment.")),this):this._hasDeclaration?(this.emit("error",Error("XML declaration is already inserted.")),this):(this._push(this._writer.declaration(e.version||"1.0",e.encoding,e.standalone)),this._hasDeclaration=!0,this)},t.prototype.dtd=function(e){if(this._fragment)return this.emit("error",Error("Cannot insert a DocType declaration into a document fragment.")),this;if(""!==this._docTypeName)return this.emit("error",new Error("DocType declaration is already inserted.")),this;if(this._hasDocumentElement)return this.emit("error",new Error("Cannot insert DocType declaration after document element.")),this;var t;try{t=l.create().dtd(e).first().node}catch(e){return this.emit("error",e),this}return this._options.wellFormed&&!c.xml_isPubidChar(t.publicId)?(this.emit("error",new Error("DocType public identifier does not match PubidChar construct (well-formed required).")),this):this._options.wellFormed&&(!c.xml_isLegalChar(t.systemId)||-1!==t.systemId.indexOf('"')&&-1!==t.systemId.indexOf("'"))?(this.emit("error",new Error("DocType system identifier contains invalid characters (well-formed required).")),this):(this._docTypeName=e.name,this._push(this._writer.docType(e.name,t.publicId,t.systemId)),this)},t.prototype.import=function(e){var t,r,n=l.fragment().set(this._options);try{n.import(e)}catch(e){return this.emit("error",e),this}try{for(var i=o(n.node.childNodes),a=i.next();!a.done;a=i.next()){var s=a.value;this._fromNode(s)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=i.return)&&r.call(i)}finally{if(t)throw t.error}}return this},t.prototype.up=function(){return this._serializeOpenTag(!1),this._serializeCloseTag(),this},t.prototype.end=function(){for(this._serializeOpenTag(!1);this._openTags.length>0;)this._serializeCloseTag();return this._push(null),this},t.prototype._serializeOpenTag=function(e){if(!this._currentElementSerialized&&void 0!==this._currentElement){var r=this._currentElement.node;if(!this._options.wellFormed||-1===r.localName.indexOf(":")&&c.xml_isName(r.localName)){var n="",i=!1,o=this._prefixMap.copy(),a={},s=this._recordNamespaceInformation(r,o,a),u=0===this._openTags.length?null:this._openTags[this._openTags.length-1][1],l=r.namespaceURI;if(null===l&&(l=u),u===l)null!==s&&(i=!0),n=l===h.namespace.XML?"xml:"+r.localName:r.localName,this._writer.beginElement(n),this._push(this._writer.openTagBegin(n));else{var p=r.prefix,f=null;if(null===p&&l===s||(f=o.get(p,l)),"xmlns"===p){if(this._options.wellFormed)return void this.emit("error",new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));f=p}null!==f?(n=f+":"+r.localName,null!==s&&s!==h.namespace.XML&&(u=s||null),this._writer.beginElement(n),this._push(this._writer.openTagBegin(n))):null!==p?(p in a&&(p=this._generatePrefix(l,o,this._prefixIndex)),o.set(p,l),n+=p+":"+r.localName,this._writer.beginElement(n),this._push(this._writer.openTagBegin(n)),this._push(this._writer.attribute("xmlns:"+p,this._serializeAttributeValue(l,this._options.wellFormed))),null!==s&&(u=s||null)):null===s||null!==s&&s!==l?(i=!0,n+=r.localName,u=l,this._writer.beginElement(n),this._push(this._writer.openTagBegin(n)),this._push(this._writer.attribute("xmlns",this._serializeAttributeValue(l,this._options.wellFormed)))):(n+=r.localName,u=l,this._writer.beginElement(n),this._push(this._writer.openTagBegin(n)))}this._serializeAttributes(r,o,this._prefixIndex,a,i,this._options.wellFormed);var d=l===h.namespace.HTML;d&&!e&&t._VoidElementNames.has(r.localName)?(this._push(this._writer.openTagEnd(n,!0,!0)),this._writer.endElement(n)):d||e?this._push(this._writer.openTagEnd(n,!1,!1)):(this._push(this._writer.openTagEnd(n,!0,!1)),this._writer.endElement(n)),this._currentElementSerialized=!0,this._openTags.push([n,u,this._prefixMap,e]),this._isPrefixMapModified(this._prefixMap,o)&&(this._prefixMap=o),this._writer.level++}else this.emit("error",new Error("Node local name contains invalid characters (well-formed required)."))}},t.prototype._serializeCloseTag=function(){this._writer.level--;var e=this._openTags.pop();if(void 0!==e){var t=a(e,4),r=t[0],n=(t[1],t[2]),i=t[3];this._prefixMap=n,i&&(this._push(this._writer.closeTag(r)),this._writer.endElement(r))}else this.emit("error",new Error("Last element is undefined."))},t.prototype._push=function(e){null===e?(this._ended=!0,this.emit("end")):this._ended?this.emit("error",new Error("Cannot push to ended stream.")):0!==e.length&&(this._writer.hasData=!0,this.emit("data",e,this._writer.level))},t.prototype._fromNode=function(e){var t,r,n,i;if(d.Guard.isElementNode(e)){var a=e.prefix?e.prefix+":"+e.localName:e.localName;null!==e.namespaceURI?this.ele(e.namespaceURI,a):this.ele(a);try{for(var s=o(e.attributes),u=s.next();!u.done;u=s.next()){var l=u.value,c=l.prefix?l.prefix+":"+l.localName:l.localName;null!==l.namespaceURI?this.att(l.namespaceURI,c,l.value):this.att(c,l.value)}}catch(e){t={error:e}}finally{try{u&&!u.done&&(r=s.return)&&r.call(s)}finally{if(t)throw t.error}}try{for(var h=o(e.childNodes),p=h.next();!p.done;p=h.next()){var f=p.value;this._fromNode(f)}}catch(e){n={error:e}}finally{try{p&&!p.done&&(i=h.return)&&i.call(h)}finally{if(n)throw n.error}}this.up()}else d.Guard.isExclusiveTextNode(e)&&e.data?this.txt(e.data):d.Guard.isCommentNode(e)?this.com(e.data):d.Guard.isCDATASectionNode(e)?this.dat(e.data):d.Guard.isProcessingInstructionNode(e)&&this.ins(e.target,e.data)},t.prototype._serializeAttributes=function(e,t,r,n,i,a){var s,u,l=a?new f.LocalNameSet:void 0;try{for(var p=o(e.attributes),d=p.next();!d.done;d=p.next()){var m=d.value;if(a||i||null!==m.namespaceURI){if(a&&l&&l.has(m.namespaceURI,m.localName))return void this.emit("error",new Error("Element contains duplicate attributes (well-formed required)."));a&&l&&l.set(m.namespaceURI,m.localName);var y=m.namespaceURI,v=null;if(null!==y)if(v=t.get(m.prefix,y),y===h.namespace.XMLNS){if(m.value===h.namespace.XML||null===m.prefix&&i||null!==m.prefix&&(!(m.localName in n)||n[m.localName]!==m.value)&&t.has(m.localName,m.value))continue;if(a&&m.value===h.namespace.XMLNS)return void this.emit("error",new Error("XMLNS namespace is reserved (well-formed required)."));if(a&&""===m.value)return void this.emit("error",new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));"xmlns"===m.prefix&&(v="xmlns")}else null===v&&(v=null===m.prefix||t.hasPrefix(m.prefix)&&!t.has(m.prefix,y)?this._generatePrefix(y,t,r):m.prefix,this._push(this._writer.attribute("xmlns:"+v,this._serializeAttributeValue(y,this._options.wellFormed))));if(a&&(-1!==m.localName.indexOf(":")||!c.xml_isName(m.localName)||"xmlns"===m.localName&&null===y))return void this.emit("error",new Error("Attribute local name contains invalid characters (well-formed required)."));this._push(this._writer.attribute((null!==v?v+":":"")+m.localName,this._serializeAttributeValue(m.value,this._options.wellFormed)))}else this._push(this._writer.attribute(m.localName,this._serializeAttributeValue(m.value,this._options.wellFormed)))}}catch(e){s={error:e}}finally{try{d&&!d.done&&(u=p.return)&&u.call(p)}finally{if(s)throw s.error}}},t.prototype._serializeAttributeValue=function(e,t){return t&&null!==e&&!c.xml_isLegalChar(e)?(this.emit("error",new Error("Invalid characters in attribute value.")),""):null===e?"":e.replace(/(?!&(lt|gt|amp|apos|quot);)&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},t.prototype._recordNamespaceInformation=function(e,t,r){var n,i,a=null;try{for(var s=o(e.attributes),u=s.next();!u.done;u=s.next()){var l=u.value,c=l.namespaceURI,p=l.prefix;if(c===h.namespace.XMLNS){if(null===p){a=l.value;continue}var f=l.localName,d=l.value;if(d===h.namespace.XML)continue;if(""===d&&(d=null),t.has(f,d))continue;t.set(f,d),r[f]=d||""}}}catch(e){n={error:e}}finally{try{u&&!u.done&&(i=s.return)&&i.call(s)}finally{if(n)throw n.error}}return a},t.prototype._generatePrefix=function(e,t,r){var n="ns"+r.value;return r.value++,t.set(n,e),n},t.prototype._isPrefixMapModified=function(e,t){var r=e._items,n=t._items,i=e._nullItems,o=t._nullItems;for(var a in n){var s=r[a];if(void 0===s)return!0;var u=n[a];if(s.length!==u.length)return!0;for(var l=0;l<s.length;l++)if(s[l]!==u[l])return!0}if(i.length!==o.length)return!0;for(l=0;l<i.length;l++)if(i[l]!==o[l])return!0;return!1},t._VoidElementNames=new Set(["area","base","basefont","bgsound","br","col","embed","frame","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"]),t}(r(308).EventEmitter);t.XMLBuilderCBImpl=_},function(e,t,r){"use strict";r(74);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(t){var r=e.call(this,t)||this;return r._lineLength=0,r}return i(t,e),t.prototype.frontMatter=function(){return""},t.prototype.declaration=function(e,t,r){var n=this._beginLine()+"<?xml";return n+=' version="'+e+'"',void 0!==t&&(n+=' encoding="'+t+'"'),void 0!==r&&(n+=' standalone="'+(r?"yes":"no")+'"'),n+="?>"},t.prototype.docType=function(e,t,r){var n=this._beginLine();return n+=t&&r?"<!DOCTYPE "+e+' PUBLIC "'+t+'" "'+r+'">':t?"<!DOCTYPE "+e+' PUBLIC "'+t+'">':r?"<!DOCTYPE "+e+' SYSTEM "'+r+'">':"<!DOCTYPE "+e+">"},t.prototype.comment=function(e){return this._beginLine()+"\x3c!--"+e+"--\x3e"},t.prototype.text=function(e){return this._beginLine()+e},t.prototype.instruction=function(e,t){return t?this._beginLine()+"<?"+e+" "+t+"?>":this._beginLine()+"<?"+e+"?>"},t.prototype.cdata=function(e){return this._beginLine()+"<![CDATA["+e+"]]>"},t.prototype.openTagBegin=function(e){return this._lineLength+=1+e.length,this._beginLine()+"<"+e},t.prototype.openTagEnd=function(e,t,r){return r?" />":t?this._writerOptions.allowEmptyTags?"></"+e+">":this._writerOptions.spaceBeforeSlash?" />":"/>":">"},t.prototype.closeTag=function(e){return this._beginLine()+"</"+e+">"},t.prototype.attribute=function(e,t){var r=e+'="'+t+'"';return this._writerOptions.prettyPrint&&this._writerOptions.width>0&&this._lineLength+1+r.length>this._writerOptions.width?(r=this._beginLine()+this._indent(1)+r,this._lineLength=r.length,r):(this._lineLength+=1+r.length," "+r)},t.prototype.beginElement=function(e){},t.prototype.endElement=function(e){},t.prototype._beginLine=function(){if(this._writerOptions.prettyPrint){var e=(this.hasData?this._writerOptions.newline:"")+this._indent(this._writerOptions.offset+this.level);return this._lineLength=e.length,e}return""},t.prototype._indent=function(e){return e<=0?"":this._writerOptions.indent.repeat(e)},t}(r(114).BaseCBWriter);t.XMLCBWriter=o},function(e,t,r){"use strict";r(74);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(t){var r=e.call(this,t)||this;return r._hasChildren=[],r._additionalLevel=0,r}return i(t,e),t.prototype.frontMatter=function(){return""},t.prototype.declaration=function(e,t,r){return""},t.prototype.docType=function(e,t,r){return""},t.prototype.comment=function(e){return this._comma()+this._beginLine()+"{"+this._sep()+this._key(this._builderOptions.convert.comment)+this._sep()+this._val(e)+this._sep()+"}"},t.prototype.text=function(e){return this._comma()+this._beginLine()+"{"+this._sep()+this._key(this._builderOptions.convert.text)+this._sep()+this._val(e)+this._sep()+"}"},t.prototype.instruction=function(e,t){return this._comma()+this._beginLine()+"{"+this._sep()+this._key(this._builderOptions.convert.ins)+this._sep()+this._val(t?e+" "+t:e)+this._sep()+"}"},t.prototype.cdata=function(e){return this._comma()+this._beginLine()+"{"+this._sep()+this._key(this._builderOptions.convert.cdata)+this._sep()+this._val(e)+this._sep()+"}"},t.prototype.attribute=function(e,t){return this._comma()+this._beginLine(1)+"{"+this._sep()+this._key(this._builderOptions.convert.att+e)+this._sep()+this._val(t)+this._sep()+"}"},t.prototype.openTagBegin=function(e){var t=this._comma()+this._beginLine()+"{"+this._sep()+this._key(e)+this._sep()+"{";return this._additionalLevel++,this.hasData=!0,t+=this._beginLine()+this._key(this._builderOptions.convert.text)+this._sep()+"[",this._hasChildren.push(!1),t},t.prototype.openTagEnd=function(e,t,r){if(t){var n=this._sep()+"]";return this._additionalLevel--,n+=this._beginLine()+"}"+this._sep()+"}"}return""},t.prototype.closeTag=function(e){var t=this._beginLine()+"]";return this._additionalLevel--,t+=this._beginLine()+"}"+this._sep()+"}"},t.prototype.beginElement=function(e){},t.prototype.endElement=function(e){this._hasChildren.pop()},t.prototype._beginLine=function(e){return void 0===e&&(e=0),this._writerOptions.prettyPrint?(this.hasData?this._writerOptions.newline:"")+this._indent(this._writerOptions.offset+this.level+e):""},t.prototype._indent=function(e){return e+this._additionalLevel<=0?"":this._writerOptions.indent.repeat(e+this._additionalLevel)},t.prototype._comma=function(){var e=this._hasChildren[this._hasChildren.length-1]?",":"";return this._hasChildren.length>0&&(this._hasChildren[this._hasChildren.length-1]=!0),e},t.prototype._sep=function(){return this._writerOptions.prettyPrint?" ":""},t.prototype._key=function(e){return'"'+e+'":'},t.prototype._val=function(e){return JSON.stringify(e)},t}(r(114).BaseCBWriter);t.JSONCBWriter=o},function(e,t,r){"use strict";r(74);var n,i=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){function t(t){var r=e.call(this,t)||this;if(r._rootWritten=!1,r._additionalLevel=0,t.indent.length<2)throw new Error("YAML indententation string must be at least two characters long.");if(t.offset<0)throw new Error("YAML offset should be zero or a positive number.");return r}return i(t,e),t.prototype.frontMatter=function(){return this._beginLine()+"---"},t.prototype.declaration=function(e,t,r){return""},t.prototype.docType=function(e,t,r){return""},t.prototype.comment=function(e){return this._beginLine()+this._key(this._builderOptions.convert.comment)+" "+this._val(e)},t.prototype.text=function(e){return this._beginLine()+this._key(this._builderOptions.convert.text)+" "+this._val(e)},t.prototype.instruction=function(e,t){return this._beginLine()+this._key(this._builderOptions.convert.ins)+" "+this._val(t?e+" "+t:e)},t.prototype.cdata=function(e){return this._beginLine()+this._key(this._builderOptions.convert.cdata)+" "+this._val(e)},t.prototype.attribute=function(e,t){this._additionalLevel++;var r=this._beginLine()+this._key(this._builderOptions.convert.att+e)+" "+this._val(t);return this._additionalLevel--,r},t.prototype.openTagBegin=function(e){var t=this._beginLine()+this._key(e);return this._rootWritten||(this._rootWritten=!0),this.hasData=!0,this._additionalLevel++,t+=this._beginLine(!0)+this._key(this._builderOptions.convert.text)},t.prototype.openTagEnd=function(e,t,r){return t?" "+this._val(""):""},t.prototype.closeTag=function(e){return this._additionalLevel--,""},t.prototype.beginElement=function(e){},t.prototype.endElement=function(e){},t.prototype._beginLine=function(e){return void 0===e&&(e=!1),(this.hasData?this._writerOptions.newline:"")+this._indent(this._writerOptions.offset+this.level,e)},t.prototype._indent=function(e,t){if(e+this._additionalLevel<=0)return"";var r=this._writerOptions.indent.repeat(e+this._additionalLevel);return!t&&this._rootWritten?r.substr(0,r.length-2)+"-"+r.substr(-1,1):r},t.prototype._key=function(e){return'"'+e+'":'},t.prototype._val=function(e){return JSON.stringify(e)},t}(r(114).BaseCBWriter);t.YAMLCBWriter=o},function(e,t,r){"use strict";var n,i="object"==typeof Reflect?Reflect:null,o=i&&"function"==typeof i.apply?i.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};n=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var a=Number.isNaN||function(e){return e!=e};function s(){s.init.call(this)}e.exports=s,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var u=10;function l(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function c(e){return void 0===e._maxListeners?s.defaultMaxListeners:e._maxListeners}function h(e,t,r,n){var i,o,a,s;if(l(r),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),a=o[t]),void 0===a)a=o[t]=r,++e._eventsCount;else if("function"==typeof a?a=o[t]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),(i=c(e))>0&&a.length>i&&!a.warned){a.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=e,u.type=t,u.count=a.length,s=u,console&&console.warn&&console.warn(s)}return e}function p(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function f(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},i=p.bind(n);return i.listener=r,n.wrapFn=i,i}function d(e,t,r){var n=e._events;if(void 0===n)return[];var i=n[t];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(i):y(i,i.length)}function m(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function y(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return u},set:function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");u=e}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},s.prototype.getMaxListeners=function(){return c(this)},s.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var n="error"===e,i=this._events;if(void 0!==i)n=n&&void 0===i.error;else if(!n)return!1;if(n){var a;if(t.length>0&&(a=t[0]),a instanceof Error)throw a;var s=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw s.context=a,s}var u=i[e];if(void 0===u)return!1;if("function"==typeof u)o(u,this,t);else{var l=u.length,c=y(u,l);for(r=0;r<l;++r)o(c[r],this,t)}return!0},s.prototype.addListener=function(e,t){return h(this,e,t,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(e,t){return h(this,e,t,!0)},s.prototype.once=function(e,t){return l(t),this.on(e,f(this,e,t)),this},s.prototype.prependOnceListener=function(e,t){return l(t),this.prependListener(e,f(this,e,t)),this},s.prototype.removeListener=function(e,t){var r,n,i,o,a;if(l(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(r,i),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,a||t)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},s.prototype.listeners=function(e){return d(this,e,!0)},s.prototype.rawListeners=function(e){return d(this,e,!1)},s.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):m.call(e,t)},s.prototype.listenerCount=m,s.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(77);t.createCB=function(e){return new n.XMLBuilderCBImpl(e)},t.fragmentCB=function(e){return new n.XMLBuilderCBImpl(e,!0)}}])}));

/***/ }),

/***/ 99178:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A2: () => (/* binding */ releaseProxy),
/* harmony export */   BX: () => (/* binding */ proxy),
/* harmony export */   LV: () => (/* binding */ wrap),
/* harmony export */   p: () => (/* binding */ expose)
/* harmony export */ });
/* unused harmony exports createEndpoint, finalizer, proxyMarker, transfer, transferHandlers, windowEndpoint */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
        if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
        }
        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
        }
    }
    return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case "GET" /* MessageType.GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case "SET" /* MessageType.SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case "APPLY" /* MessageType.APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case "CONSTRUCT" /* MessageType.CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case "ENDPOINT" /* MessageType.ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case "RELEASE" /* MessageType.RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
                default:
                    return;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE" /* MessageType.RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
                if (finalizer in obj && typeof obj[finalizer] === "function") {
                    obj[finalizer]();
                }
            }
        })
            .catch((error) => {
            // Send Serialization Error To Caller
            const [wireValue, transferables] = toWireValue({
                value: new TypeError("Unserializable return value"),
                [throwMarker]: 0,
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function releaseEndpoint(ep) {
    return requestResponseMessage(ep, {
        type: "RELEASE" /* MessageType.RELEASE */,
    }).then(() => {
        closeEndPoint(ep);
    });
}
const proxyCounter = new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis &&
    new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    });
function registerProxy(proxy, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
        proxyFinalizers.register(proxy, ep, proxy);
    }
}
function unregisterProxy(proxy) {
    if (proxyFinalizers) {
        proxyFinalizers.unregister(proxy);
    }
}
function createProxy(ep, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    unregisterProxy(proxy);
                    releaseEndpoint(ep);
                    isProxyReleased = true;
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, {
                    type: "GET" /* MessageType.GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
                type: "SET" /* MessageType.SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, {
                    type: "ENDPOINT" /* MessageType.ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didn’t happen.
            if (last === "bind") {
                return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "APPLY" /* MessageType.APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
                type: "CONSTRUCT" /* MessageType.CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    registerProxy(proxy, ep);
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: "HANDLER" /* WireValueType.HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: "RAW" /* WireValueType.RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case "HANDLER" /* WireValueType.HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case "RAW" /* WireValueType.RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        ep.addEventListener("message", function l(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
                return;
            }
            ep.removeEventListener("message", l);
            resolve(ev.data);
        });
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map


/***/ }),

/***/ 20071:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  h1: () => (/* reexport */ src_bisect),
  yl: () => (/* reexport */ bisector),
  lq: () => (/* reexport */ ticks_tickIncrement),
  sG: () => (/* reexport */ tickStep),
  Zc: () => (/* reexport */ ticks_ticks),
  yU: () => (/* reexport */ zip/* default */.A)
});

// UNUSED EXPORTS: Adder, InternMap, InternSet, ascending, bin, bisectCenter, bisectLeft, bisectRight, blur, blur2, blurImage, count, cross, cumsum, descending, deviation, difference, disjoint, every, extent, fcumsum, filter, flatGroup, flatRollup, fsum, greatest, greatestIndex, group, groupSort, groups, histogram, index, indexes, intersection, least, leastIndex, map, max, maxIndex, mean, median, medianIndex, merge, min, minIndex, mode, nice, pairs, permute, quantile, quantileIndex, quantileSorted, quickselect, range, rank, reduce, reverse, rollup, rollups, scan, shuffle, shuffler, some, sort, subset, sum, superset, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, transpose, union, variance

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/ascending.js
function ascending_ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/bisector.js



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = ascending_ascending;
    compare2 = (d, x) => ascending_ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending_ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/number.js
function number_number(x) {
  return x === null ? NaN : +x;
}

function* number_numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/bisect.js




const ascendingBisect = bisector(ascending_ascending);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = bisector(number_number).center;
/* harmony default export */ const src_bisect = (bisectRight);

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/blur.js
function blur_blur(values, r) {
  if (!((r = +r) >= 0)) throw new RangeError("invalid r");
  let length = values.length;
  if (!((length = Math.floor(length)) >= 0)) throw new RangeError("invalid length");
  if (!length || !r) return values;
  const blur = blurf(r);
  const temp = values.slice();
  blur(values, temp, 0, length, 1);
  blur(temp, values, 0, length, 1);
  blur(values, temp, 0, length, 1);
  return values;
}

const blur2 = Blur2(blurf);

const blurImage = Blur2(blurfImage);

function Blur2(blur) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let {data: values, width, height} = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || (!rx && !ry)) return data;
    const blurx = rx && blur(rx);
    const blury = ry && blur(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}

function blurh(blur, T, S, w, h) {
  for (let y = 0, n = w * h; y < n;) {
    blur(T, S, y, y += w, 1);
  }
}

function blurv(blur, T, S, w, h) {
  for (let x = 0, n = w * h; x < w; ++x) {
    blur(T, S, x, x + n, w);
  }
}

function blurfImage(radius) {
  const blur = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur(T, S, start + 0, stop + 0, step);
    blur(T, S, start + 1, stop + 1, step);
    blur(T, S, start + 2, stop + 2, step);
    blur(T, S, start + 3, stop + 3, step);
  };
}

// Given a target array T, a source array S, sets each value T[i] to the average
// of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,
// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between
// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an
// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted
// according to r - ⌊radius⌋.
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => { // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    let sum = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum += S[Math.min(stop, i + s0)];
      T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum -= S[Math.max(start, i - s0)];
    }
  };
}

// Like blurf, but optimized for integer radius.
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => { // stop must be aligned!
    if (!((stop -= step) >= start)) return; // inclusive stop
    let sum = radius * S[start];
    const s = step * radius;
    for (let i = start, j = start + s; i < j; i += step) {
      sum += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum += S[Math.min(stop, i + s)];
      T[i] = sum / w;
      sum -= S[Math.max(start, i - s)];
    }
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/count.js
function count_count(values, valueof) {
  let count = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }
  return count;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/cross.js
function cross_length(array) {
  return array.length | 0;
}

function empty(length) {
  return !(length > 0);
}

function arrayify(values) {
  return typeof values !== "object" || "length" in values ? values : Array.from(values);
}

function reducer(reduce) {
  return values => reduce(...values);
}

function cross(...values) {
  const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  const lengths = values.map(cross_length);
  const j = values.length - 1;
  const index = new Array(j + 1).fill(0);
  const product = [];
  if (j < 0 || lengths.some(empty)) return product;
  while (true) {
    product.push(index.map((j, i) => values[i][j]));
    let i = j;
    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/cumsum.js
function cumsum(values, valueof) {
  var sum = 0, index = 0;
  return Float64Array.from(values, valueof === undefined
    ? v => (sum += +v || 0)
    : v => (sum += +valueof(v, index++, values) || 0));
}
;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/variance.js
function variance_variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/deviation.js


function deviation_deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/extent.js
function extent_extent(values, valueof) {
  let min;
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/fsum.js
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}

;// CONCATENATED MODULE: ../../../node_modules/internmap/src/index.js
class src_InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (entries != null) for (const [key, value] of entries) this.set(key, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}

class src_InternSet extends Set {
  constructor(values, key = keyof) {
    super();
    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
    if (values != null) for (const value of values) this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
}

function intern_get({_intern, _key}, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value);
  return value;
}

function intern_delete({_intern, _key}, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/identity.js
function identity_identity(x) {
  return x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/group.js



function group_group(values, ...keys) {
  return nest(values, identity, identity, keys);
}

function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}

function flatten(groups, keys) {
  for (let i = 1, n = keys.length; i < n; ++i) {
    groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
  }
  return groups;
}

function flatGroup(values, ...keys) {
  return flatten(groups(values, ...keys), keys);
}

function flatRollup(values, reduce, ...keys) {
  return flatten(rollups(values, reduce, ...keys), keys);
}

function group_rollup(values, reduce, ...keys) {
  return nest(values, identity, reduce, keys);
}

function rollups(values, reduce, ...keys) {
  return nest(values, Array.from, reduce, keys);
}

function index(values, ...keys) {
  return nest(values, identity, unique, keys);
}

function indexes(values, ...keys) {
  return nest(values, Array.from, unique, keys);
}

function unique(values) {
  if (values.length !== 1) throw new Error("duplicate key");
  return values[0];
}

function nest(values, map, reduce, keys) {
  return (function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new InternMap();
    const keyof = keys[i++];
    let index = -1;
    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);
      else groups.set(key, [value]);
    }
    for (const [key, values] of groups) {
      groups.set(key, regroup(values, i));
    }
    return map(groups);
  })(values, 0);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/permute.js
function permute_permute(source, keys) {
  return Array.from(keys, key => source[key]);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/sort.js



function sort_sort(values, ...F) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);
  let [f] = F;
  if ((f && f.length !== 2) || F.length > 1) {
    const index = Uint32Array.from(values, (d, i) => i);
    if (F.length > 1) {
      F = F.map(f => values.map(f));
      index.sort((i, j) => {
        for (const f of F) {
          const c = sort_ascendingDefined(f[i], f[j]);
          if (c) return c;
        }
      });
    } else {
      f = values.map(f);
      index.sort((i, j) => sort_ascendingDefined(f[i], f[j]));
    }
    return permute(values, index);
  }
  return values.sort(sort_compareDefined(f));
}

function sort_compareDefined(compare = ascending) {
  if (compare === ascending) return sort_ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x = compare(a, b);
    if (x || x === 0) return x;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}

function sort_ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/groupSort.js




function groupSort(values, reduce, key) {
  return (reduce.length !== 2
    ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)))
    : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))))
    .map(([key]) => key);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/array.js
var array = Array.prototype;

var array_slice = array.slice;
var map = array.map;

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/constant.js
function constant_constant(x) {
  return () => x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/ticks.js
const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log10(step)),
      error = step / Math.pow(10, power),
      factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}

function ticks_ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
  }
  return ticks;
}

function ticks_tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}

function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse = stop < start, inc = reverse ? ticks_tickIncrement(stop, start, count) : ticks_tickIncrement(start, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/nice.js


function nice_nice(start, stop, count) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/threshold/sturges.js


function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/bin.js









function bin() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);

    var i,
        n = data.length,
        x,
        step,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds, and nice the
    // default domain accordingly.
    if (!Array.isArray(tz)) {
      const max = x1, tn = +tz;
      if (domain === extent) [x0, x1] = nice(x0, x1, tn);
      tz = ticks(x0, x1, tn);

      // If the domain is aligned with the first tick (which it will by
      // default), then we can use quantization rather than bisection to bin
      // values, which is substantially faster.
      if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

      // If the last threshold is coincident with the domain’s upper bound, the
      // last bin will be zero-width. If the default domain is used, and this
      // last threshold is coincident with the maximum input value, we can
      // extend the niced upper bound by one tick to ensure uniform bin widths;
      // otherwise, we simply remove the last threshold. Note that we don’t
      // coerce values or the domain to numbers, and thus must be careful to
      // compare order (>=) rather than strict equality (===)!
      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === extent) {
          const step = tickIncrement(x0, x1, tn);
          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }

    // Remove any thresholds outside the domain.
    // Be careful not to mutate an array owned by the user!
    var m = tz.length, a = 0, b = m;
    while (tz[a] <= x0) ++a;
    while (tz[b - 1] > x1) --b;
    if (a || b < m) tz = tz.slice(a, b), m = b - a;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            const j = Math.floor((x0 - x) * step);
            bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x = values[i]) != null && x0 <= x && x <= x1) {
          bins[bisect(tz, x, 0, m)].push(data[i]);
        }
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;
  };

  return histogram;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/max.js
function max_max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/maxIndex.js
function maxIndex_maxIndex(values, valueof) {
  let max;
  let maxIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value, maxIndex = index;
      }
    }
  }
  return maxIndex;
}

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/min.js
var src_min = __webpack_require__(80004);
;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/minIndex.js
function minIndex_minIndex(values, valueof) {
  let min;
  let minIndex = -1;
  let index = -1;
  if (valueof === undefined) {
    for (const value of values) {
      ++index;
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  } else {
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value, minIndex = index;
      }
    }
  }
  return minIndex;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/quickselect.js


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect_quickselect(array, k, left = 0, right = Infinity, compare) {
  k = Math.floor(k);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array.length - 1, right));

  if (!(left <= k && k <= right)) return array;

  compare = compare === undefined ? ascendingDefined : compareDefined(compare);

  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect_quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/greatest.js


function greatest_greatest(values, compare = ascending) {
  let max;
  let defined = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, maxValue) > 0
          : ascending(value, value) === 0) {
        max = element;
        maxValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, max) > 0
          : compare(value, value) === 0) {
        max = value;
        defined = true;
      }
    }
  }
  return max;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/quantile.js









function quantile_quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
      value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function quantile_quantileIndex(values, p, valueof = number) {
  if (isNaN(p = +p)) return;
  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));
  if (p <= 0) return minIndex(numbers);
  if (p >= 1) return maxIndex(numbers);
  var numbers,
      index = Uint32Array.from(values, (_, i) => i),
      j = numbers.length - 1,
      i = Math.floor(j * p);
  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));
  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);
  return i >= 0 ? i : -1;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/threshold/freedmanDiaconis.js



function thresholdFreedmanDiaconis(values, min, max) {
  const c = count(values), d = quantile(values, 0.75) - quantile(values, 0.25);
  return c && d ? Math.ceil((max - min) / (2 * d * Math.pow(c, -1 / 3))) : 1;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/threshold/scott.js



function thresholdScott(values, min, max) {
  const c = count(values), d = deviation(values);
  return c && d ? Math.ceil((max - min) * Math.cbrt(c) / (3.49 * d)) : 1;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/median.js


function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}

function medianIndex(values, valueof) {
  return quantileIndex(values, 0.5, valueof);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/merge.js
function* merge_flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(merge_flatten(arrays));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/mode.js


function mode(values, valueof) {
  const counts = new InternMap();
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count] of counts) {
    if (count > modeCount) {
      modeCount = count;
      modeValue = value;
    }
  }
  return modeValue;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/pairs.js
function pairs(values, pairof = pair) {
  const pairs = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/range.js
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/rank.js



function rank(values, valueof = ascending) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  let V = Array.from(values);
  const R = new Float64Array(V.length);
  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;
  const compareIndex = (i, j) => valueof(V[i], V[j]);
  let k, r;
  values = Uint32Array.from(V, (_, i) => i);
  // Risky chaining due to Safari 14 https://github.com/d3/d3-array/issues/123
  values.sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
  values.forEach((j, i) => {
      const c = compareIndex(j, k === undefined ? j : k);
      if (c >= 0) {
        if (k === undefined || c > 0) k = j, r = i;
        R[j] = r;
      } else {
        R[j] = NaN;
      }
    });
  return R;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/least.js


function least(values, compare = ascending) {
  let min;
  let defined = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values) {
      const value = compare(element);
      if (defined
          ? ascending(value, minValue) < 0
          : ascending(value, value) === 0) {
        min = element;
        minValue = value;
        defined = true;
      }
    }
  } else {
    for (const value of values) {
      if (defined
          ? compare(value, min) < 0
          : compare(value, value) === 0) {
        min = value;
        defined = true;
      }
    }
  }
  return min;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/leastIndex.js



function leastIndex_leastIndex(values, compare = ascending) {
  if (compare.length === 1) return minIndex(values, compare);
  let minValue;
  let min = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (min < 0
        ? compare(value, value) === 0
        : compare(value, minValue) < 0) {
      minValue = value;
      min = index;
    }
  }
  return min;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/greatestIndex.js



function greatestIndex(values, compare = ascending) {
  if (compare.length === 1) return maxIndex(values, compare);
  let maxValue;
  let max = -1;
  let index = -1;
  for (const value of values) {
    ++index;
    if (max < 0
        ? compare(value, value) === 0
        : compare(value, maxValue) > 0) {
      maxValue = value;
      max = index;
    }
  }
  return max;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/scan.js


function scan(values, compare) {
  const index = leastIndex(values, compare);
  return index < 0 ? undefined : index;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/shuffle.js
/* harmony default export */ const shuffle = (shuffler(Math.random));

function shuffler(random) {
  return function shuffle(array, i0 = 0, i1 = array.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }
    return array;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/transpose.js
var transpose = __webpack_require__(43183);
// EXTERNAL MODULE: ../../../node_modules/d3-array/src/zip.js
var zip = __webpack_require__(44779);
;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/every.js
function every(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index = -1;
  for (const value of values) {
    if (!test(value, ++index, values)) {
      return false;
    }
  }
  return true;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/some.js
function some(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  let index = -1;
  for (const value of values) {
    if (test(value, ++index, values)) {
      return true;
    }
  }
  return false;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/filter.js
function filter(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  const array = [];
  let index = -1;
  for (const value of values) {
    if (test(value, ++index, values)) {
      array.push(value);
    }
  }
  return array;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/map.js
function map_map(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
  return Array.from(values, (value, index) => mapper(value, index, values));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/reduce.js
function reduce(values, reducer, value) {
  if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
  const iterator = values[Symbol.iterator]();
  let done, next, index = -1;
  if (arguments.length < 3) {
    ({done, value} = iterator.next());
    if (done) return;
    ++index;
  }
  while (({done, value: next} = iterator.next()), !done) {
    value = reducer(value, next, ++index, values);
  }
  return value;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/reverse.js
function reverse(values) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/difference.js


function difference(values, ...others) {
  values = new InternSet(values);
  for (const other of others) {
    for (const value of other) {
      values.delete(value);
    }
  }
  return values;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/disjoint.js


function disjoint(values, other) {
  const iterator = other[Symbol.iterator](), set = new InternSet();
  for (const v of values) {
    if (set.has(v)) return false;
    let value, done;
    while (({value, done} = iterator.next())) {
      if (done) break;
      if (Object.is(v, value)) return false;
      set.add(value);
    }
  }
  return true;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/intersection.js


function intersection(values, ...others) {
  values = new InternSet(values);
  others = others.map(set);
  out: for (const value of values) {
    for (const other of others) {
      if (!other.has(value)) {
        values.delete(value);
        continue out;
      }
    }
  }
  return values;
}

function set(values) {
  return values instanceof InternSet ? values : new InternSet(values);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/superset.js
function superset_superset(values, other) {
  const iterator = values[Symbol.iterator](), set = new Set();
  for (const o of other) {
    const io = intern(o);
    if (set.has(io)) continue;
    let value, done;
    while (({value, done} = iterator.next())) {
      if (done) return false;
      const ivalue = intern(value);
      set.add(ivalue);
      if (Object.is(io, ivalue)) break;
    }
  }
  return true;
}

function intern(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/subset.js


function subset(values, other) {
  return superset(other, values);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/union.js


function union(...others) {
  const set = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set.add(o);
    }
  }
  return set;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-array/src/index.js













 // Deprecated; use bin.






















 // Deprecated; use leastIndex.






















/***/ }),

/***/ 80004:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ 43183:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80004);


function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = (0,_min_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}


/***/ }),

/***/ 54603:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  yW: () => (/* reexport */ color),
  UB: () => (/* reexport */ cubehelix),
  aq: () => (/* reexport */ hcl),
  KI: () => (/* reexport */ hsl),
  Qh: () => (/* reexport */ rgb)
});

// UNUSED EXPORTS: gray, lab, lch

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/define.js
/* harmony default export */ function src_define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/color.js


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

src_define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/math.js
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/lab.js




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

src_define(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

src_define(Hcl, hcl, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/cubehelix.js




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

src_define(Cubehelix, cubehelix, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

;// CONCATENATED MODULE: ../../../node_modules/d3-color/src/index.js





/***/ }),

/***/ 56399:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  GW: () => (/* reexport */ src_value),
  Qm: () => (/* reexport */ src_basis),
  Dj: () => (/* reexport */ number),
  sH: () => (/* reexport */ round),
  yd: () => (/* reexport */ quantize/* default */.A)
});

// UNUSED EXPORTS: interpolateArray, interpolateBasisClosed, interpolateCubehelix, interpolateCubehelixLong, interpolateDate, interpolateDiscrete, interpolateHcl, interpolateHclLong, interpolateHsl, interpolateHslLong, interpolateHue, interpolateLab, interpolateNumberArray, interpolateObject, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, piecewise

// EXTERNAL MODULE: ../../../node_modules/d3-color/src/index.js + 5 modules
var src = __webpack_require__(54603);
;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function src_basis(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/basisClosed.js


/* harmony default export */ function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/constant.js
/* harmony default export */ const constant = (x => () => x);

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/color.js


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function color_hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/rgb.js





/* harmony default export */ const rgb = ((function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = (0,src/* rgb */.Qh)(start)).r, (end = (0,src/* rgb */.Qh)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,src/* rgb */.Qh)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/numberArray.js
/* harmony default export */ function src_numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function numberArray_isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/array.js



/* harmony default export */ function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = src_value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/date.js
/* harmony default export */ function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/number.js
/* harmony default export */ function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/object.js


/* harmony default export */ function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = src_value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/string.js


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/value.js










/* harmony default export */ function src_value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = (0,src/* color */.yW)(b)) ? (b = c, rgb) : string)
      : b instanceof src/* color */.yW ? rgb
      : b instanceof Date ? date
      : numberArray_isNumberArray(b) ? src_numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/discrete.js
/* harmony default export */ function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/hue.js


/* harmony default export */ function src_hue(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/round.js
/* harmony default export */ function round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/parse.js


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/transform/index.js



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const zoom = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/hsl.js



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = (0,src/* hsl */.KI)(start)).h, (end = (0,src/* hsl */.KI)(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const src_hsl = (hsl(color_hue));
var hslLong = hsl(nogamma);

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/lab.js



function lab(start, end) {
  var l = color((start = colorLab(start)).l, (end = colorLab(end)).l),
      a = color(start.a, end.a),
      b = color(start.b, end.b),
      opacity = color(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/hcl.js



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = (0,src/* hcl */.aq)(start)).h, (end = (0,src/* hcl */.aq)(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const src_hcl = (hcl(color_hue));
var hclLong = hcl(nogamma);

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/cubehelix.js



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0,src/* cubehelix */.UB)(start)).h, (end = (0,src/* cubehelix */.UB)(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ const src_cubehelix = (cubehelix(color_hue));
var cubehelixLong = cubehelix(nogamma);

;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/piecewise.js


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = value;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

// EXTERNAL MODULE: ../../../node_modules/d3-interpolate/src/quantize.js
var quantize = __webpack_require__(20919);
;// CONCATENATED MODULE: ../../../node_modules/d3-interpolate/src/index.js























/***/ }),

/***/ 95583:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  m4: () => (/* reexport */ linear)
});

// UNUSED EXPORTS: scaleBand, scaleDiverging, scaleDivergingLog, scaleDivergingPow, scaleDivergingSqrt, scaleDivergingSymlog, scaleIdentity, scaleImplicit, scaleLog, scaleOrdinal, scalePoint, scalePow, scaleQuantile, scaleQuantize, scaleRadial, scaleSequential, scaleSequentialLog, scaleSequentialPow, scaleSequentialQuantile, scaleSequentialSqrt, scaleSequentialSymlog, scaleSqrt, scaleSymlog, scaleThreshold, scaleTime, scaleUtc, tickFormat

// EXTERNAL MODULE: ../../../node_modules/d3-array/src/index.js + 58 modules
var src = __webpack_require__(20071);
;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/init.js
function init_initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function init_initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/ordinal.js



const implicit = Symbol("implicit");

function ordinal_ordinal() {
  var index = new InternMap(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    let i = index.get(d);
    if (i === undefined) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range[i % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value)) continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal_ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/band.js




function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// EXTERNAL MODULE: ../../../node_modules/d3-interpolate/src/index.js + 24 modules
var d3_interpolate_src = __webpack_require__(56399);
;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/number.js
function number_number(x) {
  return +x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/continuous.js





var unit = [0, 1];

function continuous_identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constants(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,src/* bisect */.h1)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function continuous_copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function continuous_transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate_src/* interpolate */.GW,
      transform,
      untransform,
      unknown,
      clamp = continuous_identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== continuous_identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate_src/* interpolateNumber */.Dj)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number_number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate_src/* interpolateRound */.sH, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : continuous_identity, rescale()) : clamp !== continuous_identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous_continuous() {
  return continuous_transformer()(continuous_identity, continuous_identity);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatDecimal.js
/* harmony default export */ function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/exponent.js


/* harmony default export */ function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatGroup.js
/* harmony default export */ function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatNumerals.js
/* harmony default export */ function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatSpecifier.js
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier_formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier_formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatTrim.js
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatPrefixAuto.js


var prefixExponent;

/* harmony default export */ function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatRounded.js


/* harmony default export */ function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/formatTypes.js




/* harmony default export */ const formatTypes = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/identity.js
/* harmony default export */ function src_identity(x) {
  return x;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/locale.js









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function locale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? src_identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? src_identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "−" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier_formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier_formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/defaultLocale.js


var defaultLocale_locale;
var defaultLocale_format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  defaultLocale_locale = locale(definition);
  defaultLocale_format = defaultLocale_locale.format;
  formatPrefix = defaultLocale_locale.formatPrefix;
  return defaultLocale_locale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionFixed.js


/* harmony default export */ function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionPrefix.js


/* harmony default export */ function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/precisionRound.js


/* harmony default export */ function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-format/src/index.js







;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/tickFormat.js



function tickFormat(start, stop, count, specifier) {
  var step = (0,src/* tickStep */.sG)(start, stop, count),
      precision;
  specifier = formatSpecifier_formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return defaultLocale_format(specifier);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/linear.js





function linear_linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,src/* ticks */.Zc)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,src/* tickIncrement */.lq)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous_continuous();

  scale.copy = function() {
    return continuous_copy(scale, linear());
  };

  init_initRange.apply(scale, arguments);

  return linear_linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/identity.js



function identity_identity(domain) {
  var unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity_identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, number) : [0, 1];

  return linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/nice.js
function nice_nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/log.js






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : x => Math.pow(base, x);
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), x => Math.log(x) / base);
}

function reflect(f) {
  return (x, k) => -f(-x, k);
}

function log_loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;

    if (r) ([u, v] = [v, u]);

    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };

  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = () => {
    return domain(nice(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };

  return scale;
}

function log() {
  const scale = log_loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/symlog.js




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlog_symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlog_symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/pow.js




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function pow_powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = pow_powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/radial.js





function square(x) {
  return Math.sign(x) * x * x;
}

function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}

function radial() {
  var squared = continuous(),
      range = [0, 1],
      round = false,
      unknown;

  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }

  scale.invert = function(y) {
    return squared.invert(square(y));
  };

  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };

  scale.range = function(_) {
    return arguments.length ? (squared.range((range = Array.from(_, number)).map(square)), scale) : range.slice();
  };

  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, scale) : round;
  };

  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return radial(squared.domain(), range)
        .round(round)
        .clamp(squared.clamp())
        .unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/quantile.js



function quantile_quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile_quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/quantize.js




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/threshold.js



function threshold_threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold_threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/interval.js
const t0 = new Date, t1 = new Date;

function timeInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = (date) => {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = (date, step) => {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = (start, stop, step) => {
    const range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    let previous;
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? (d) => field(d) % step === 0
              : (d) => interval.count(0, d) % step === 0);
    };
  }

  return interval;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/millisecond.js


const millisecond = timeInterval(() => {
  // noop
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = (k) => {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k) * k);
  }, (date, step) => {
    date.setTime(+date + step * k);
  }, (start, end) => {
    return (end - start) / k;
  });
};

const milliseconds = millisecond.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/duration.js
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/second.js



const second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});

const seconds = second.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/minute.js



const minute_timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});

const timeMinutes = minute_timeMinute.range;

const minute_utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});

const utcMinutes = minute_utcMinute.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/hour.js



const hour_timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});

const timeHours = hour_timeHour.range;

const hour_utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});

const utcHours = hour_utcHour.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/day.js



const day_timeDay = timeInterval(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  date => date.getDate() - 1
);

const timeDays = day_timeDay.range;

const day_utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});

const utcDays = day_utcDay.range;

const unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});

const unixDays = unixDay.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/week.js



function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);

const timeSundays = timeSunday.range;
const timeMondays = timeMonday.range;
const timeTuesdays = timeTuesday.range;
const timeWednesdays = timeWednesday.range;
const timeThursdays = timeThursday.range;
const timeFridays = timeFriday.range;
const timeSaturdays = timeSaturday.range;

function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}

const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);

const utcSundays = utcSunday.range;
const utcMondays = utcMonday.range;
const utcTuesdays = utcTuesday.range;
const utcWednesdays = utcWednesday.range;
const utcThursdays = utcThursday.range;
const utcFridays = utcFriday.range;
const utcSaturdays = utcSaturday.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/month.js


const month_timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});

const timeMonths = month_timeMonth.range;

const month_utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});

const utcMonths = month_utcMonth.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/year.js


const year_timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year_timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

const timeYears = year_timeYear.range;

const year_utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
year_utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

const utcYears = year_utcYear.range;

;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/ticks.js











function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = (0,src/* bisector */.yl)(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0,src/* tickStep */.sG)(start / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond.every(Math.max((0,src/* tickStep */.sG)(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [ticks_utcTicks, ticks_utcTickInterval] = ticker(year_utcYear, month_utcMonth, utcSunday, unixDay, hour_utcHour, minute_utcMinute);
const [ticks_timeTicks, ticks_timeTickInterval] = ticker(year_timeYear, month_timeMonth, timeSunday, day_timeDay, hour_timeHour, minute_timeMinute);



;// CONCATENATED MODULE: ../../../node_modules/d3-time/src/index.js




















;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/locale.js


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = day_utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = day_timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day_timeDay.count(year_timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(year_timeYear(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(year_timeYear(d), d) + (year_timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(year_timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + day_utcDay.count(year_utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(year_utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(year_utcYear(d), d) + (year_utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(year_utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/defaultLocale.js


var src_defaultLocale_locale;
var defaultLocale_timeFormat;
var timeParse;
var defaultLocale_utcFormat;
var utcParse;

defaultLocale_defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale_defaultLocale(definition) {
  src_defaultLocale_locale = formatLocale(definition);
  defaultLocale_timeFormat = src_defaultLocale_locale.format;
  timeParse = src_defaultLocale_locale.parse;
  defaultLocale_utcFormat = src_defaultLocale_locale.utcFormat;
  utcParse = src_defaultLocale_locale.utcParse;
  return src_defaultLocale_locale;
}

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/isoFormat.js


var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : defaultLocale_utcFormat(isoSpecifier);

/* harmony default export */ const isoFormat = ((/* unused pure expression or super */ null && (formatIso)));

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/isoParse.js



function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

/* harmony default export */ const isoParse = ((/* unused pure expression or super */ null && (parseIso)));

;// CONCATENATED MODULE: ../../../node_modules/d3-time-format/src/index.js





;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/time.js






function date(t) {
  return new Date(t);
}

function time_number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function time_calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, time_number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function() {
    return copy(scale, time_calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(time_calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/utcTime.js





function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/sequential.js








function sequential_transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(interpolate);

  scale.rangeRound = range(interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function sequential_copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(sequential_transformer()(identity));

  scale.copy = function() {
    return sequential_copy(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(sequential_transformer()).domain([1, 10]);

  scale.copy = function() {
    return sequential_copy(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(sequential_transformer());

  scale.copy = function() {
    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/sequentialQuantile.js




function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };

  scale.quantiles = function(n) {
    return Array.from({length: n + 1}, (_, i) => quantile(domain, i / n));
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/diverging.js









function diverging_transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(interpolate);

  scale.rangeRound = range(interpolateRound);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = linearish(diverging_transformer()(identity));

  scale.copy = function() {
    return copy(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(diverging_transformer());

  scale.copy = function() {
    return copy(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(diverging_transformer());

  scale.copy = function() {
    return copy(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

;// CONCATENATED MODULE: ../../../node_modules/d3-scale/src/index.js



































/***/ })

}]);