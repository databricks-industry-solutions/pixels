<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOMweb Endpoint Metrics</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <style>
        :root {
            --bg: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary: #38bdf8;
            --secondary: #818cf8;
            --accent: #f472b6;
            --text: #f8fafc;
            --text-dim: #94a3b8;
            --success: #4ade80;
            --warning: #facc15;
            --error: #fb7185;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 2.25rem;
            margin: 0 0 1.5rem 0;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* ── Status bar ────────────────────────────────────────── */

        .status-bar {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 0.85rem;
            margin-bottom: 1.5rem;
            color: var(--text-dim);
            flex-wrap: wrap;
            justify-content: center;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-dim);
            box-shadow: none;
        }

        .dot.live {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.5; }
        }

        .node-selector label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-right: 0.4rem;
        }

        .node-selector select {
            background: rgba(30, 41, 59, 0.9);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 0.4rem;
            padding: 0.3rem 0.6rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            outline: none;
        }

        .node-selector select:focus {
            border-color: var(--primary);
        }

        .node-badge {
            background: rgba(56, 189, 248, 0.12);
            color: var(--primary);
            border-radius: 0.4rem;
            padding: 0.2rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        /* ── KPI tiles ─────────────────────────────────────────── */

        .kpi-row {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 1.5rem;
        }

        .kpi {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            text-align: center;
            transition: border-color 0.2s;
        }

        .kpi:hover { border-color: rgba(255, 255, 255, 0.2); }

        .kpi-label {
            display: block;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-dim);
            margin-bottom: 0.35rem;
        }

        .kpi-value {
            display: block;
            font-size: 1.5rem;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            color: var(--text);
            transition: color 0.3s;
        }

        /* ── Chart grid ────────────────────────────────────────── */

        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            width: 100%;
            max-width: 1400px;
        }

        .chart-card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1.25rem 1.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, border-color 0.2s;
        }

        .chart-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .chart-card h2 {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            margin: 0 0 0.75rem 0;
            color: var(--text-dim);
        }

        .chart-wrap {
            position: relative;
            height: 200px;
        }

        footer {
            margin-top: 2rem;
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        @media (max-width: 900px) {
            .kpi-row { grid-template-columns: repeat(3, 1fr); }
            .chart-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 500px) {
            .kpi-row { grid-template-columns: repeat(2, 1fr); }
            body { padding: 1rem; }
        }
    </style>
</head>

<body>

    <h1>DICOMweb Endpoint Dashboard</h1>

    <div class="status-bar">
        <div class="status-group">
            <div class="dot" id="status-dot"></div>
            <span id="status-text">Connecting&hellip;</span>
        </div>
        <span id="timestamp">&mdash;</span>
        <span class="node-badge" id="node-count" style="display:none;"></span>
        <div class="node-selector" id="node-selector-wrap" style="display:none;">
            <label for="node-select">Node</label>
            <select id="node-select">
                <option value="__all__">All Nodes (avg)</option>
            </select>
        </div>
    </div>

    <div class="kpi-row">
        <div class="kpi">
            <span class="kpi-label">CPU</span>
            <span class="kpi-value" id="kpi-cpu">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Memory (RSS)</span>
            <span class="kpi-value" id="kpi-ram">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">BOT Cache</span>
            <span class="kpi-value" id="kpi-bot">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Path Cache</span>
            <span class="kpi-value" id="kpi-path">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Srv Latency</span>
            <span class="kpi-value" id="kpi-slat">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Gw Latency</span>
            <span class="kpi-value" id="kpi-glat">&mdash;</span>
        </div>
    </div>

    <div class="chart-grid">
        <div class="chart-card">
            <h2>System Resources</h2>
            <div class="chart-wrap"><canvas id="chart-system"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Cache Hit Rates</h2>
            <div class="chart-wrap"><canvas id="chart-caches"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Request Throughput</h2>
            <div class="chart-wrap"><canvas id="chart-throughput"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Latency</h2>
            <div class="chart-wrap"><canvas id="chart-latency"></canvas></div>
        </div>
    </div>

    <footer>
        DICOMweb Endpoint Monitoring &bull; Live via WebSocket &bull; Data from Lakebase
    </footer>

    <script>
        /* ── Configuration ──────────────────────────────────────── */

        var REST_ENDPOINT = '/api/metrics';
        var MAX_POINTS = 60;

        /* ── WebSocket state ────────────────────────────────────── */

        var ws = null;
        var reconnectTimer = null;
        var reconnectDelay = 1000;
        var MAX_RECONNECT_DELAY = 30000;
        var restFallback = null;

        /* ── Per-node data storage ──────────────────────────────── */

        var labels = [];
        var nodeData = {};       // nodeId -> { cpu:[], memPct:[], botHit:[], pathHit:[], req:[], err:[], lat:[] }
        var knownNodes = [];     // ordered list of discovered node IDs
        var activeNode = null;   // null = aggregate, string = specific node

        var gwBuf = { req: [], err: [], lat: [] };

        function emptyNodeBuf() {
            return { cpu: [], memPct: [], botHit: [], pathHit: [], req: [], err: [], lat: [] };
        }

        function ensureNode(nodeId) {
            if (nodeData[nodeId]) return;
            nodeData[nodeId] = emptyNodeBuf();
            var padLen = labels.length;
            var keys = Object.keys(nodeData[nodeId]);
            for (var k = 0; k < keys.length; k++) {
                for (var i = 0; i < padLen; i++) nodeData[nodeId][keys[k]].push(0);
            }
            knownNodes.push(nodeId);
            rebuildNodeSelector();
        }

        function pushBuf(arr, val) {
            arr.push(val);
            if (arr.length > MAX_POINTS) arr.shift();
        }

        function extractNodeId(source) {
            var idx = source.indexOf(':');
            if (idx === -1 || idx === source.length - 1) return null;
            return source.substring(idx + 1);
        }

        /* ── Node selector ──────────────────────────────────────── */

        var selectEl = document.getElementById('node-select');
        var selectorWrap = document.getElementById('node-selector-wrap');
        var badgeEl = document.getElementById('node-count');

        selectEl.addEventListener('change', function () {
            activeNode = this.value === '__all__' ? null : this.value;
            syncCharts();
        });

        function rebuildNodeSelector() {
            var prev = selectEl.value;
            while (selectEl.options.length > 1) selectEl.remove(1);
            for (var i = 0; i < knownNodes.length; i++) {
                var opt = document.createElement('option');
                opt.value = knownNodes[i];
                opt.text = knownNodes[i];
                selectEl.add(opt);
            }
            selectEl.value = prev;
            if (!selectEl.value) selectEl.value = '__all__';
            selectorWrap.style.display = knownNodes.length > 0 ? '' : 'none';
            badgeEl.style.display = knownNodes.length > 1 ? '' : 'none';
            badgeEl.innerText = knownNodes.length + ' nodes';
        }

        /* ── DOM helpers ────────────────────────────────────────── */

        function setKpi(id, text, level) {
            var el = document.getElementById(id);
            if (!el) return;
            el.innerText = text;
            var palette = { good: '#4ade80', warn: '#facc15', bad: '#fb7185' };
            el.style.color = palette[level] || '#f8fafc';
        }

        function setStatus(state) {
            var dot = document.getElementById('status-dot');
            var txt = document.getElementById('status-text');
            if (state === 'connected') {
                dot.className = 'dot live';
                txt.innerText = 'Connected (live)';
            } else {
                dot.className = 'dot';
                txt.innerText = 'Reconnecting\u2026';
            }
        }

        /* ── Aggregate helpers ──────────────────────────────────── */

        function aggregate(key, mode) {
            if (knownNodes.length === 0) return [];
            if (knownNodes.length === 1) return nodeData[knownNodes[0]][key];
            var len = labels.length;
            var out = [];
            for (var i = 0; i < len; i++) {
                var sum = 0, cnt = 0;
                for (var n = 0; n < knownNodes.length; n++) {
                    var arr = nodeData[knownNodes[n]][key];
                    if (arr && i < arr.length) { sum += arr[i]; cnt++; }
                }
                out.push(mode === 'sum' ? sum : (cnt ? +(sum / cnt).toFixed(2) : 0));
            }
            return out;
        }

        function latestAggregate(key, mode) {
            var total = 0, cnt = 0;
            for (var n = 0; n < knownNodes.length; n++) {
                var arr = nodeData[knownNodes[n]][key];
                if (arr.length) { total += arr[arr.length - 1]; cnt++; }
            }
            if (mode === 'sum') return total;
            return cnt ? +(total / cnt).toFixed(2) : 0;
        }

        /* ── Chart.js setup ─────────────────────────────────────── */

        Chart.defaults.color = '#94a3b8';
        Chart.defaults.borderColor = 'rgba(255,255,255,0.06)';
        Chart.defaults.font.family = "'Inter', sans-serif";
        Chart.defaults.font.size = 11;

        function makeOpts(yOverride) {
            var base = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { boxWidth: 10, padding: 10, usePointStyle: true }
                    },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: {
                        grid: { color: 'rgba(255,255,255,0.03)' },
                        ticks: { maxTicksLimit: 6, maxRotation: 0 }
                    },
                    y: {
                        beginAtZero: true,
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    }
                },
                elements: {
                    point: { radius: 0, hoverRadius: 3 },
                    line: { tension: 0.35, borderWidth: 1.5 }
                }
            };
            if (yOverride) Object.assign(base.scales.y, yOverride);
            return base;
        }

        function ds(label, data, hex, extra) {
            var r = parseInt(hex.slice(1, 3), 16);
            var g = parseInt(hex.slice(3, 5), 16);
            var b = parseInt(hex.slice(5, 7), 16);
            var out = {
                label: label,
                data: data,
                borderColor: hex,
                backgroundColor: 'rgba(' + r + ',' + g + ',' + b + ',0.06)',
                fill: true
            };
            if (extra) Object.assign(out, extra);
            return out;
        }

        /* Placeholder arrays — reassigned every sync cycle */
        var _empty = [];

        var chartSystem = new Chart(document.getElementById('chart-system'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('CPU %', _empty, '#38bdf8'),
                    ds('Memory %', _empty, '#818cf8')
                ]
            },
            options: makeOpts({ max: 100, ticks: { callback: function (v) { return v + '%'; } } })
        });

        var chartCaches = new Chart(document.getElementById('chart-caches'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('BOT Hit Rate', _empty, '#4ade80'),
                    ds('Path Hit Rate', _empty, '#facc15')
                ]
            },
            options: makeOpts({ max: 100, ticks: { callback: function (v) { return v + '%'; } } })
        });

        var chartThroughput = new Chart(document.getElementById('chart-throughput'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('Serving', _empty, '#38bdf8'),
                    ds('Gateway', gwBuf.req, '#818cf8'),
                    ds('Srv Errors', _empty, '#fb7185', { fill: false, borderDash: [4, 2] }),
                    ds('Gw Errors', gwBuf.err, '#f472b6', { fill: false, borderDash: [2, 2] })
                ]
            },
            options: makeOpts()
        });

        var chartLatency = new Chart(document.getElementById('chart-latency'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('Serving', _empty, '#38bdf8'),
                    ds('Gateway', gwBuf.lat, '#818cf8')
                ]
            },
            options: makeOpts({ ticks: { callback: function (v) { return v + ' ms'; } } })
        });

        var allCharts = [chartSystem, chartCaches, chartThroughput, chartLatency];

        /* ── Sync chart data to active node selection ───────────── */

        function syncCharts() {
            var isAll = !activeNode || !nodeData[activeNode];
            var buf;

            if (isAll) {
                chartSystem.data.datasets[0].data = aggregate('cpu', 'avg');
                chartSystem.data.datasets[1].data = aggregate('memPct', 'avg');
                chartCaches.data.datasets[0].data = aggregate('botHit', 'avg');
                chartCaches.data.datasets[1].data = aggregate('pathHit', 'avg');
                chartThroughput.data.datasets[0].data = aggregate('req', 'sum');
                chartThroughput.data.datasets[2].data = aggregate('err', 'sum');
                chartLatency.data.datasets[0].data = aggregate('lat', 'avg');
            } else {
                buf = nodeData[activeNode];
                chartSystem.data.datasets[0].data = buf.cpu;
                chartSystem.data.datasets[1].data = buf.memPct;
                chartCaches.data.datasets[0].data = buf.botHit;
                chartCaches.data.datasets[1].data = buf.pathHit;
                chartThroughput.data.datasets[0].data = buf.req;
                chartThroughput.data.datasets[2].data = buf.err;
                chartLatency.data.datasets[0].data = buf.lat;
            }

            chartThroughput.data.datasets[1].data = gwBuf.req;
            chartThroughput.data.datasets[3].data = gwBuf.err;
            chartLatency.data.datasets[1].data = gwBuf.lat;

            allCharts.forEach(function (ch) { ch.update('none'); });
        }

        /* ── Dashboard update (shared by WS and REST) ───────────── */

        function updateDashboard(data) {
            var sRows = data.serving || [];
            var gRows = data.gateway || [];

            /* ── Timestamp label ─────────────────────────────────── */
            var now = new Date().toLocaleTimeString([], {
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            labels.push(now);
            if (labels.length > MAX_POINTS) labels.shift();

            /* ── Group serving rows by node (latest per node) ────── */
            var latestPerNode = {};
            for (var i = 0; i < sRows.length; i++) {
                var nodeId = extractNodeId(sRows[i].source);
                if (nodeId && !latestPerNode[nodeId]) latestPerNode[nodeId] = sRows[i];
            }

            /* ── Push serving data per node ──────────────────────── */
            var reportedNodes = Object.keys(latestPerNode);
            for (var r = 0; r < reportedNodes.length; r++) {
                var nid = reportedNodes[r];
                ensureNode(nid);
                var m = latestPerNode[nid].metrics;
                var sys = m.system || {};
                var c = m.caches || {};
                var bot = c.bot_cache || {};
                var path = c.instance_path_cache || {};
                var req = m.requests || {};

                pushBuf(nodeData[nid].cpu, parseFloat(sys.cpu_percent_process) || 0);
                pushBuf(nodeData[nid].memPct, parseFloat(sys.system_memory_used_percent) || 0);
                pushBuf(nodeData[nid].botHit, parseFloat(String(bot.hit_rate || '0').replace('%', '')));
                pushBuf(nodeData[nid].pathHit, parseFloat(String(path.hit_rate || '0').replace('%', '')));
                pushBuf(nodeData[nid].req, req.request_count || 0);
                pushBuf(nodeData[nid].err, req.error_count || 0);
                pushBuf(nodeData[nid].lat, Math.round((req.avg_latency_s || 0) * 1000));

                if (r === 0 && latestPerNode[nid].recorded_at) {
                    document.getElementById('timestamp').innerText =
                        new Date(latestPerNode[nid].recorded_at).toLocaleTimeString();
                }
            }

            /* Push zeros for nodes that didn't report this tick */
            for (var k = 0; k < knownNodes.length; k++) {
                if (!latestPerNode[knownNodes[k]]) {
                    var nb = nodeData[knownNodes[k]];
                    pushBuf(nb.cpu, 0); pushBuf(nb.memPct, 0);
                    pushBuf(nb.botHit, 0); pushBuf(nb.pathHit, 0);
                    pushBuf(nb.req, 0); pushBuf(nb.err, 0); pushBuf(nb.lat, 0);
                }
            }

            /* ── Gateway data ────────────────────────────────────── */
            var gLatest = gRows.length ? gRows[0] : null;
            if (gLatest) {
                var gm = gLatest.metrics;
                pushBuf(gwBuf.req, gm.request_count || 0);
                pushBuf(gwBuf.err, gm.error_count || 0);
                pushBuf(gwBuf.lat, Math.round((gm.avg_latency_s || 0) * 1000));
            } else {
                pushBuf(gwBuf.req, 0); pushBuf(gwBuf.err, 0); pushBuf(gwBuf.lat, 0);
            }

            /* ── KPI tiles (based on active selection) ───────────── */
            updateKpis(latestPerNode, gLatest);

            /* ── Sync charts ─────────────────────────────────────── */
            syncCharts();
            setStatus('connected');
        }

        function updateKpis(latestPerNode, gLatest) {
            var isAll = !activeNode || !nodeData[activeNode];
            var cpu, memPct, ramMb, botHit, pathHit, srvLat;

            if (isAll && knownNodes.length > 0) {
                cpu = latestAggregate('cpu', 'avg');
                memPct = latestAggregate('memPct', 'avg');
                botHit = latestAggregate('botHit', 'avg');
                pathHit = latestAggregate('pathHit', 'avg');
                srvLat = Math.round(latestAggregate('lat', 'avg'));

                var totalRam = 0, cnt = 0;
                for (var n = 0; n < knownNodes.length; n++) {
                    var row = latestPerNode[knownNodes[n]];
                    if (row) { totalRam += (row.metrics.system || {}).memory_rss_mb || 0; cnt++; }
                }
                ramMb = cnt ? Math.round(totalRam / cnt) : 0;
            } else if (activeNode && nodeData[activeNode]) {
                var buf = nodeData[activeNode];
                cpu = buf.cpu.length ? buf.cpu[buf.cpu.length - 1] : 0;
                memPct = buf.memPct.length ? buf.memPct[buf.memPct.length - 1] : 0;
                botHit = buf.botHit.length ? buf.botHit[buf.botHit.length - 1] : 0;
                pathHit = buf.pathHit.length ? buf.pathHit[buf.pathHit.length - 1] : 0;
                srvLat = buf.lat.length ? buf.lat[buf.lat.length - 1] : 0;
                var row = latestPerNode[activeNode];
                ramMb = row ? ((row.metrics.system || {}).memory_rss_mb || 0) : 0;
            } else {
                return;
            }

            setKpi('kpi-cpu', cpu.toFixed(1) + '%',
                cpu < 50 ? 'good' : cpu < 80 ? 'warn' : 'bad');
            setKpi('kpi-ram', ramMb + ' MB',
                memPct < 70 ? 'good' : memPct < 90 ? 'warn' : 'bad');
            setKpi('kpi-bot', botHit.toFixed(1) + '%',
                botHit > 80 ? 'good' : botHit > 50 ? 'warn' : 'bad');
            setKpi('kpi-path', pathHit.toFixed(1) + '%',
                pathHit > 80 ? 'good' : pathHit > 50 ? 'warn' : 'bad');
            setKpi('kpi-slat', srvLat + ' ms',
                srvLat < 100 ? 'good' : srvLat < 500 ? 'warn' : 'bad');

            if (gLatest) {
                var gwLat = Math.round((gLatest.metrics.avg_latency_s || 0) * 1000);
                setKpi('kpi-glat', gwLat + ' ms',
                    gwLat < 100 ? 'good' : gwLat < 500 ? 'warn' : 'bad');
            }
        }

        /* ── REST fallback ──────────────────────────────────────── */

        function fetchRest() {
            fetch(REST_ENDPOINT, { credentials: 'include' })
                .then(function (res) { return res.json(); })
                .then(updateDashboard)
                .catch(function () { setStatus('disconnected'); });
        }

        /* ── WebSocket with auto-reconnect ──────────────────────── */

        function connectWebSocket() {
            var proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(proto + '//' + location.host + '/ws/metrics');

            ws.onopen = function () {
                reconnectDelay = 1000;
                if (restFallback) { clearInterval(restFallback); restFallback = null; }
                setStatus('connected');
            };

            ws.onmessage = function (event) {
                updateDashboard(JSON.parse(event.data));
            };

            ws.onclose = function () {
                setStatus('disconnected');
                scheduleReconnect();
            };

            ws.onerror = function () { ws.close(); };
        }

        function scheduleReconnect() {
            if (reconnectTimer) return;
            if (!restFallback) {
                restFallback = setInterval(fetchRest, 3000);
            }
            reconnectTimer = setTimeout(function () {
                reconnectTimer = null;
                connectWebSocket();
            }, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
        }

        connectWebSocket();
    </script>

</body>

</html>
