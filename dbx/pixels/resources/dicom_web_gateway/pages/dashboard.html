<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOMweb Endpoint Metrics</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <style>
        :root {
            --bg: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary: #38bdf8;
            --secondary: #818cf8;
            --accent: #f472b6;
            --text: #f8fafc;
            --text-dim: #94a3b8;
            --success: #4ade80;
            --warning: #facc15;
            --error: #fb7185;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 2.25rem;
            margin: 0 0 1.5rem 0;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            margin-bottom: 1.5rem;
            color: var(--text-dim);
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-dim);
            box-shadow: none;
        }

        .dot.live {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.5; }
        }

        /* ── KPI tiles ─────────────────────────────────────────── */

        .kpi-row {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            width: 100%;
            max-width: 1400px;
            margin-bottom: 1.5rem;
        }

        .kpi {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            text-align: center;
            transition: border-color 0.2s;
        }

        .kpi:hover { border-color: rgba(255, 255, 255, 0.2); }

        .kpi-label {
            display: block;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-dim);
            margin-bottom: 0.35rem;
        }

        .kpi-value {
            display: block;
            font-size: 1.5rem;
            font-weight: 600;
            font-family: 'Outfit', sans-serif;
            color: var(--text);
            transition: color 0.3s;
        }

        /* ── Chart grid ────────────────────────────────────────── */

        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            width: 100%;
            max-width: 1400px;
        }

        .chart-card {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            padding: 1.25rem 1.5rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, border-color 0.2s;
        }

        .chart-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .chart-card h2 {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            margin: 0 0 0.75rem 0;
            color: var(--text-dim);
        }

        .chart-wrap {
            position: relative;
            height: 200px;
        }

        footer {
            margin-top: 2rem;
            color: var(--text-dim);
            font-size: 0.75rem;
        }

        @media (max-width: 900px) {
            .kpi-row { grid-template-columns: repeat(3, 1fr); }
            .chart-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 500px) {
            .kpi-row { grid-template-columns: repeat(2, 1fr); }
            body { padding: 1rem; }
        }
    </style>
</head>

<body>

    <h1>DICOMweb Endpoint Dashboard</h1>

    <div class="status">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">Connecting&hellip;</span>
        <span style="margin-left: 1rem;" id="timestamp">&mdash;</span>
    </div>

    <div class="kpi-row">
        <div class="kpi">
            <span class="kpi-label">CPU</span>
            <span class="kpi-value" id="kpi-cpu">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Memory (RSS)</span>
            <span class="kpi-value" id="kpi-ram">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">BOT Cache</span>
            <span class="kpi-value" id="kpi-bot">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Path Cache</span>
            <span class="kpi-value" id="kpi-path">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Srv Latency</span>
            <span class="kpi-value" id="kpi-slat">&mdash;</span>
        </div>
        <div class="kpi">
            <span class="kpi-label">Gw Latency</span>
            <span class="kpi-value" id="kpi-glat">&mdash;</span>
        </div>
    </div>

    <div class="chart-grid">
        <div class="chart-card">
            <h2>System Resources</h2>
            <div class="chart-wrap"><canvas id="chart-system"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Cache Hit Rates</h2>
            <div class="chart-wrap"><canvas id="chart-caches"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Request Throughput</h2>
            <div class="chart-wrap"><canvas id="chart-throughput"></canvas></div>
        </div>
        <div class="chart-card">
            <h2>Latency</h2>
            <div class="chart-wrap"><canvas id="chart-latency"></canvas></div>
        </div>
    </div>

    <footer>
        DICOMweb Endpoint Monitoring &bull; Live via WebSocket &bull; Data from Lakebase
    </footer>

    <script>
        /* ── Configuration ──────────────────────────────────────── */

        var REST_ENDPOINT = '/api/metrics';
        var MAX_POINTS = 60;

        /* ── WebSocket state ────────────────────────────────────── */

        var ws = null;
        var reconnectTimer = null;
        var reconnectDelay = 1000;
        var MAX_RECONNECT_DELAY = 30000;
        var restFallback = null;

        /* ── Data buffers (shared references used by Chart.js) ── */

        var labels = [];
        var buf = {
            cpu: [], memPct: [],
            botHit: [], pathHit: [],
            srvReq: [], srvErr: [],
            gwReq: [], gwErr: [],
            srvLat: [], gwLat: []
        };

        function pushBuf(key, val) {
            buf[key].push(val);
            if (buf[key].length > MAX_POINTS) buf[key].shift();
        }

        /* ── DOM helpers ────────────────────────────────────────── */

        function setKpi(id, text, level) {
            var el = document.getElementById(id);
            if (!el) return;
            el.innerText = text;
            var palette = { good: '#4ade80', warn: '#facc15', bad: '#fb7185' };
            el.style.color = palette[level] || '#f8fafc';
        }

        function setStatus(state) {
            var dot = document.getElementById('status-dot');
            var txt = document.getElementById('status-text');
            if (state === 'connected') {
                dot.className = 'dot live';
                txt.innerText = 'Connected (live)';
            } else {
                dot.className = 'dot';
                txt.innerText = 'Reconnecting\u2026';
            }
        }

        /* ── Chart.js defaults & factory ────────────────────────── */

        Chart.defaults.color = '#94a3b8';
        Chart.defaults.borderColor = 'rgba(255,255,255,0.06)';
        Chart.defaults.font.family = "'Inter', sans-serif";
        Chart.defaults.font.size = 11;

        function makeOpts(yOverride) {
            var base = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { boxWidth: 10, padding: 10, usePointStyle: true }
                    },
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    x: {
                        grid: { color: 'rgba(255,255,255,0.03)' },
                        ticks: { maxTicksLimit: 6, maxRotation: 0 }
                    },
                    y: {
                        beginAtZero: true,
                        grid: { color: 'rgba(255,255,255,0.05)' }
                    }
                },
                elements: {
                    point: { radius: 0, hoverRadius: 3 },
                    line: { tension: 0.35, borderWidth: 1.5 }
                }
            };
            if (yOverride) Object.assign(base.scales.y, yOverride);
            return base;
        }

        function ds(label, data, hex, extra) {
            var r = parseInt(hex.slice(1, 3), 16);
            var g = parseInt(hex.slice(3, 5), 16);
            var b = parseInt(hex.slice(5, 7), 16);
            var out = {
                label: label,
                data: data,
                borderColor: hex,
                backgroundColor: 'rgba(' + r + ',' + g + ',' + b + ',0.06)',
                fill: true
            };
            if (extra) Object.assign(out, extra);
            return out;
        }

        /* ── Create charts ──────────────────────────────────────── */

        var chartSystem = new Chart(document.getElementById('chart-system'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('CPU %', buf.cpu, '#38bdf8'),
                    ds('Memory %', buf.memPct, '#818cf8')
                ]
            },
            options: makeOpts({ max: 100, ticks: { callback: function (v) { return v + '%'; } } })
        });

        var chartCaches = new Chart(document.getElementById('chart-caches'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('BOT Hit Rate', buf.botHit, '#4ade80'),
                    ds('Path Hit Rate', buf.pathHit, '#facc15')
                ]
            },
            options: makeOpts({ max: 100, ticks: { callback: function (v) { return v + '%'; } } })
        });

        var chartThroughput = new Chart(document.getElementById('chart-throughput'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('Serving', buf.srvReq, '#38bdf8'),
                    ds('Gateway', buf.gwReq, '#818cf8'),
                    ds('Srv Errors', buf.srvErr, '#fb7185', { fill: false, borderDash: [4, 2] }),
                    ds('Gw Errors', buf.gwErr, '#f472b6', { fill: false, borderDash: [2, 2] })
                ]
            },
            options: makeOpts()
        });

        var chartLatency = new Chart(document.getElementById('chart-latency'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    ds('Serving', buf.srvLat, '#38bdf8'),
                    ds('Gateway', buf.gwLat, '#818cf8')
                ]
            },
            options: makeOpts({ ticks: { callback: function (v) { return v + ' ms'; } } })
        });

        var allCharts = [chartSystem, chartCaches, chartThroughput, chartLatency];

        /* ── Dashboard update (shared by WS and REST paths) ─────── */

        function updateDashboard(data) {
            var sRows = data.serving || [];
            var gRows = data.gateway || [];
            var sLatest = sRows.length ? sRows[0] : null;
            var gLatest = gRows.length ? gRows[0] : null;

            var now = new Date().toLocaleTimeString([], {
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            labels.push(now);
            if (labels.length > MAX_POINTS) labels.shift();

            if (sLatest) {
                var m = sLatest.metrics;
                document.getElementById('timestamp').innerText =
                    new Date(sLatest.recorded_at).toLocaleTimeString();

                var sys = m.system || {};
                var cpu = parseFloat(sys.cpu_percent_process) || 0;
                var memPct = parseFloat(sys.system_memory_used_percent) || 0;
                pushBuf('cpu', cpu);
                pushBuf('memPct', memPct);
                setKpi('kpi-cpu', cpu.toFixed(1) + '%',
                    cpu < 50 ? 'good' : cpu < 80 ? 'warn' : 'bad');
                setKpi('kpi-ram', (sys.memory_rss_mb || 0) + ' MB',
                    memPct < 70 ? 'good' : memPct < 90 ? 'warn' : 'bad');

                var c = m.caches || {};
                var bot = c.bot_cache || {};
                var path = c.instance_path_cache || {};
                var botHit = parseFloat(String(bot.hit_rate || '0').replace('%', ''));
                var pathHit = parseFloat(String(path.hit_rate || '0').replace('%', ''));
                pushBuf('botHit', botHit);
                pushBuf('pathHit', pathHit);
                setKpi('kpi-bot', botHit.toFixed(1) + '%',
                    botHit > 80 ? 'good' : botHit > 50 ? 'warn' : 'bad');
                setKpi('kpi-path', pathHit.toFixed(1) + '%',
                    pathHit > 80 ? 'good' : pathHit > 50 ? 'warn' : 'bad');

                var r = m.requests || {};
                pushBuf('srvReq', r.request_count || 0);
                pushBuf('srvErr', r.error_count || 0);
                var srvLatMs = Math.round((r.avg_latency_s || 0) * 1000);
                pushBuf('srvLat', srvLatMs);
                setKpi('kpi-slat', srvLatMs + ' ms',
                    srvLatMs < 100 ? 'good' : srvLatMs < 500 ? 'warn' : 'bad');
            } else {
                pushBuf('cpu', 0); pushBuf('memPct', 0);
                pushBuf('botHit', 0); pushBuf('pathHit', 0);
                pushBuf('srvReq', 0); pushBuf('srvErr', 0);
                pushBuf('srvLat', 0);
            }

            if (gLatest) {
                var gm = gLatest.metrics;
                pushBuf('gwReq', gm.request_count || 0);
                pushBuf('gwErr', gm.error_count || 0);
                var gwLatMs = Math.round((gm.avg_latency_s || 0) * 1000);
                pushBuf('gwLat', gwLatMs);
                setKpi('kpi-glat', gwLatMs + ' ms',
                    gwLatMs < 100 ? 'good' : gwLatMs < 500 ? 'warn' : 'bad');
            } else {
                pushBuf('gwReq', 0); pushBuf('gwErr', 0); pushBuf('gwLat', 0);
            }

            allCharts.forEach(function (ch) { ch.update('none'); });
            setStatus('connected');
        }

        /* ── REST fallback (active while WebSocket reconnects) ── */

        function fetchRest() {
            fetch(REST_ENDPOINT, { credentials: 'include' })
                .then(function (res) { return res.json(); })
                .then(updateDashboard)
                .catch(function () { setStatus('disconnected'); });
        }

        /* ── WebSocket with auto-reconnect ──────────────────────── */

        function connectWebSocket() {
            var proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(proto + '//' + location.host + '/ws/metrics');

            ws.onopen = function () {
                reconnectDelay = 1000;
                if (restFallback) { clearInterval(restFallback); restFallback = null; }
                setStatus('connected');
            };

            ws.onmessage = function (event) {
                updateDashboard(JSON.parse(event.data));
            };

            ws.onclose = function () {
                setStatus('disconnected');
                scheduleReconnect();
            };

            ws.onerror = function () { ws.close(); };
        }

        function scheduleReconnect() {
            if (reconnectTimer) return;
            if (!restFallback) {
                restFallback = setInterval(fetchRest, 3000);
            }
            reconnectTimer = setTimeout(function () {
                reconnectTimer = null;
                connectWebSocket();
            }, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
        }

        connectWebSocket();
    </script>

</body>

</html>
